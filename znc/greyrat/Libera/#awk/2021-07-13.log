[00:00:28] *** Quits: springb0k (~springb0k@96.77.120.193) (Read error: Connection reset by peer)
[00:18:24] *** Quits: roarde (~roarde@user/roarde) (Remote host closed the connection)
[00:24:14] *** Joins: emanuele6 (~emanuele6@user/emanuele6)
[00:27:18] *** Quits: jetchisel (jetchisel@user/jetchisel) (Ping timeout: 276 seconds)
[00:34:25] *** Joins: jetchisel (~jetchisel@user/jetchisel)
[00:40:28] *** Joins: roarde (~roarde@user/roarde)
[00:40:30] *** Joins: lavaball (felix@31.204.155.215)
[00:48:01] *** Joins: TanoMarcelo (~TanoMarce@179.63.242.126)
[00:57:27] <zenema> I can't find a reason why the '{}' which translates to the default action '{ print }' should be included in the following shebang:
[00:57:30] <zenema> #!/bin/sh
[00:57:31] <zenema> "exec" "awk" "-f" "$0" "$@" && 0 {}
[00:58:13] <zenema> If I omit the {} (keeping the negation of the quoted strings - && 0) then everything still seems to work as expected.
[00:58:24] <zenema> Is there a reason I may need the {} to be here?
[00:59:16] <zenema> To me this, this is just a pattern without an action, which would usually fine (causing the default action).
[01:00:09] <zenema> If I feed '"blah" && 0' through the gawk prettifier, it does fill in the "missing" '{ print }'.
[01:02:20] <geirha> when awk parses  "exec" "awk" "-f" "$0" "$@"  it's considered true
[01:02:33] <emg> looks to me like that is shell syntax not awk syntax, the     && 0 {}    seems to be after awk
[01:03:23] <geirha> it's hybrid sh/awk code
[01:03:53] <zenema> geirha: Yes, so when awk processes the entire file it would print each input line if it wasn't for the logical AND of 0 with the 1/true of the quoted text.
[01:04:16] <zenema> But what I don't understand, is why (if at all) the empty function {} is required after the && 0.
[01:05:09] <zenema> emg: Yup, it's a "polyglot", which I'm using for portability (Due to all the fun with /usr/bin/env and how different platforms handle the arguments as single or multiple arguments).
[01:05:46] <emg> oh yeah yeah yeah I see now, the "$0", well shit, that's mind bending, fun
[01:06:11] <zenema> Haha, it's a beautiful monster :)
[01:06:31] <geirha> I suspect it may be an oawk thing
[01:06:41] <zenema> geirha: Ah, I was wondering about that.
[01:06:58] <zenema> So nawk and gawk just handle it fine, but oawk may not like it.
[01:07:06] <zenema> (The lack of {})
[01:08:19] <geirha> ah no, I found the reason
[01:09:52] <geirha> or not ... nevermind
[01:10:08] <zenema> Ah, you had me on the edge of my seat then! :)
[01:10:12] <geirha> not sure why, but probably to avoid some edge case
[01:10:55] <zenema> Yup, I can't imagine one logically - considering a pattern without an action, or an action without a pattern is normal.
[01:11:18] <zenema> I may have to find a copy of oawk and compile it, no version in FreeBSD ports :/
[01:12:07] <emg> is   "string" && number    well defined for awk?
[01:13:20] <geirha> heirloom has one
[01:13:37] <geirha> http://heirloom.sourceforge.net/tools.html
[01:16:26] <geirha> oawk doesn't like number at least. it considers   0 {...} a syntax error, while  0 == 1 {...} is fine
[01:16:52] <emg> ok, looks like it is well defined as per POSIX
[01:17:02] <geirha> so it can't really be to cater for oawk, since it won't be valid at all there
[01:24:51] <phillbush> Anyone here have access to the draft for the next POSIX revision (202x)? Anything new for awk?
[01:26:47] <phillbush> I really want to see something like gawk -E or mawk -W exec
[01:37:34] *** Quits: lavaball (felix@31.204.155.215) (Remote host closed the connection)
[01:44:03] <Riviera> ... because?
[01:46:08] <zenema> geirha, emg: Ah, ok, well thank you both for your help. I'll keep digging, it's only a minor thing, but it's bugging me!
[01:48:20] *** Joins: lavaball (felix@31.204.155.215)
[02:18:08] *** Quits: lavaball (felix@31.204.155.215) (Remote host closed the connection)
[02:57:38] <nmz> Patsie: I saw, My knowledge of electronics is elementary at best so... but how would you go about it?
[03:04:06] *** Joins: dfg (dfg@user/dfg)
[03:38:44] *** Joins: Torr (~Torr@user/torr)
[03:53:15] *** Quits: emanuele6 (~emanuele6@user/emanuele6) (Read error: Connection reset by peer)
[03:59:59] *** Joins: emanuele6 (~emanuele6@user/emanuele6)
[04:01:46] *** Quits: emg (~emg@cpe-70-93-247-186.natsow.res.rr.com) (Remote host closed the connection)
[04:05:57] *** Quits: TanoMarcelo (~TanoMarce@179.63.242.126) (Quit: WeeChat 3.1)
[04:15:16] *** Quits: yuesbeez (uid458354@id-458354.tinside.irccloud.com) (Quit: Connection closed for inactivity)
[04:36:19] *** Joins: TanoMarcelo (~TanoMarce@179.63.242.126)
[05:02:33] *** Quits: earnestly (~earnest@user/earnestly) (Ping timeout: 255 seconds)
[05:16:19] *** Joins: downunder (~downunder@110.151.19.142)
[05:18:49] *** Quits: jetchisel (~jetchisel@user/jetchisel) (Quit: Unfortunately time is always against us -- [Morpheus])
[05:30:20] *** Quits: vlm (~vlm@user/vlm) (Quit: "")
[05:34:03] *** Joins: vlm (~vlm@user/vlm)
[05:37:35] *** Quits: phillbush (~phillbush@user/phillbush) (Remote host closed the connection)
[06:03:34] *** Quits: downunder (~downunder@110.151.19.142) (Quit: WeeChat 3.2)
[06:07:01] *** Joins: nate1 (~nate@108-233-125-227.lightspeed.sntcca.sbcglobal.net)
[06:11:43] *** Quits: vinipsmaker (~vinipsmak@2804:14c:f427:a9bc::1001) (Quit: Leaving)
[06:25:14] *** Quits: nate1 (~nate@108-233-125-227.lightspeed.sntcca.sbcglobal.net) (Ping timeout: 256 seconds)
[06:29:52] *** Joins: jmcantrell (~weechat@user/jmcantrell)
[06:35:03] *** Quits: Torr (~Torr@user/torr) (Quit: leaving)
[06:39:48] *** Joins: nate1 (~nate@108-233-125-227.lightspeed.sntcca.sbcglobal.net)
[06:55:03] *** Quits: nate1 (~nate@108-233-125-227.lightspeed.sntcca.sbcglobal.net) (Ping timeout: 255 seconds)
[07:00:21] *** Joins: nate1 (~nate@108-233-125-227.lightspeed.sntcca.sbcglobal.net)
[07:34:07] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[07:37:20] *** Quits: jmcantrell (~weechat@user/jmcantrell) (Ping timeout: 272 seconds)
[07:47:58] *** Quits: nate1 (~nate@108-233-125-227.lightspeed.sntcca.sbcglobal.net) (Ping timeout: 256 seconds)
[08:07:28] *** Joins: nate1 (~nate@108-233-125-227.lightspeed.sntcca.sbcglobal.net)
[08:32:33] *** Joins: earnestly (~earnest@user/earnestly)
[08:50:10] *** Quits: nate1 (~nate@108-233-125-227.lightspeed.sntcca.sbcglobal.net) (Ping timeout: 272 seconds)
[09:03:48] *** Quits: __jmcantrell__ (~weechat@user/jmcantrell) (Quit: WeeChat 3.2)
[09:07:45] *** Joins: wwalker (~wwalker@platinum.solid-constructs.com)
[09:07:59] *** Joins: madprops (~hj8oijo@user/madprops)
[09:08:35] <madprops> hello
[09:08:42] <madprops> Why does this replace the separator with whitespace? 
[09:08:42] <madprops> echo "key2|ex|am||ple" | awk -F "|" '{$1=""; print}'
[09:08:42] <madprops> If I remove $1="" it doesn't do that
[09:13:10] <wwalker> It appears to me that rather than replacing, it is changing the delimiter from "|" to " ".  But, I don't understand why either...
[09:17:11] *** Joins: siraben (~siraben@user/siraben)
[09:18:12] <yeti> maybe setting FS doesn't set OFS
[09:20:39] <wwalker> yeti: it does, IF you do not modify a field.  That is what is weird...
[09:21:03] <yeti> $0 gets reconstructed if fields change
[09:21:09] <yeti> and then OFS is used
[09:21:37] <yeti> so printing an unchanged $0 has the original line wth your FS untouched
[09:21:46] <yeti> changing $0 brings OFS into the game
[09:22:02] <yeti> # echo "key2|ex|am||ple" | awk -F "|" '{$1=""; print}'
[09:22:04] <shbot> yeti:  ex am  ple
[09:22:17] <wwalker> yeti: Thanks!! echo "key2|ex|am||ple" | awk -F "|" '{OFS="|"; $1=""; print}'
[09:22:29] <yeti> oh... had still teh wrong studd in the clipboard
[09:22:31] <wwalker> madprops: echo "key2|ex|am||ple" | awk -F "|" '{OFS="|"; $1=""; print}'
[09:22:44] <yeti> # echo 1 | awk -F'|' '{print"FS : "FS;print"OFS: "OFS}'
[09:22:46] <shbot> yeti: FS : |
[09:22:46] <shbot> yeti: OFS:
[09:23:17] <madprops> I see so I had to modify the output field separator
[09:23:34] <madprops> since a reconstruct was triggered
[09:24:22] <wwalker> Yep. I didn't realize it was a reconstruct.  Thanks yeti 
[09:24:34] <yeti> there should be an awk-surprises man page!
[09:28:07] *** Joins: roarde_ (~roarde@user/roarde)
[09:29:48] *** Quits: roarde (~roarde@user/roarde) (Read error: Connection reset by peer)
[09:30:15] *** roarde_ is now known as roarde
[09:39:28] <siraben> Is anyone aware of why https://github.com/onetrueawk/awk/issues/74#issuecomment-589982693 does not do releases?
[09:39:51] <siraben> I'm maintaining the package for Nixpkgs and several distros still lock to the one and only tg
[09:39:54] <siraben> tag*
[09:51:23] <wwalker> probably they are being either lazy or pragmatic.  Neither is a bad thing.  If I was the one maintiaining it and I only had 10 hours a month to put into it, I would likely only do buf fixes and feature adds and leave the versioning to someone else.  That frees up more of my time for the thing I'm good at (fixing bugs in awk in C) that others are not.
[09:52:24] <wwalker> If I spent 5 hours a month creating tags and versions etc, then I would only get half the bugs fixed.
[09:54:34] <wwalker> If instead I offload that work onto the package maintainers, I get twice as many bugs fixed.   You can always just pick a commit to build and call it onetrueawk-0.0.1-20210701-b3aff7a921d
[09:59:22] *** Joins: downunder (~downunder@110.151.19.142)
[10:02:44] <yeti> ++
[10:06:36] <Patsie> that would be a bad way to maintain your code because slowly but surely nobody would start using it anymore 'it's so old!' plus making a release doesn't take up 5 hours a month
[10:06:54] <Patsie> it sounds more like 'I don't like doing that part of the work'
[10:10:39] <yeti> with a project not having frrwuent commits, you can treat each one as new release
[10:10:51] <yeti> frrwuent->frequent
[10:11:32] <yeti> probably users of rolling release distributions will complain about his more than others
[10:11:34] <yeti> .-P
[10:20:08] *** Quits: lgc (~lgc@user/lgc) (Quit: WeeChat 3.2-dev)
[10:42:46] <Patsie> still excuses
[10:42:59] <Patsie> it's just part of the maintaining job
[10:46:10] *** Joins: nate1 (~nate@108-233-125-227.lightspeed.sntcca.sbcglobal.net)
[10:47:08] <yeti> what's part of maintaining is decided by the repo owner.
[10:47:32] <yeti> if his decissions dont match your preferences, fork it.
[10:48:22] <yeti> dont tell others what to do with their time unless you pay them.
[10:50:51] *** Quits: nate1 (~nate@108-233-125-227.lightspeed.sntcca.sbcglobal.net) (Ping timeout: 255 seconds)
[10:51:29] <Patsie> I couldn't care less what he does or doesn't do
[11:00:38] *** Quits: emanuele6 (~emanuele6@user/emanuele6) (Ping timeout: 272 seconds)
[11:19:27] <wwalker> yeti: ++ ++ ++ ++  don't tell me what to do with my time, unless you are going to pay me!!
[11:21:03] *** Quits: roarde (~roarde@user/roarde) (Quit: Leaving)
[11:21:23] <yeti> :-)
[11:22:31] <wwalker> My real question is "what do the onetrueawk version of awk bring to the table?"
[11:23:58] <geirha> It brings the pain of the past to the present
[11:24:24] <yeti> gawk is the pain of the present, so maybe both should exist.. ;-P
[11:37:20] *** wwalker is now known as wwalker_comatose
[11:37:39] <wwalker_comatose> lol
[11:54:42] <madprops> is the only way to access what was printed saving it to a variable?
[11:55:26] <madprops> or, what's the best way to join various fields with a separator?
[11:55:50] <madprops> I'm printing the fields with a | separator, and removing the last | in END
[12:01:23] <geirha> Using OFS would be the simplest, but not always applicable
[12:02:12] <geirha> otherwise, a trick is to use a loop like:  sep=""; for (...) { printf("%s%s", sep, $x); sep="|" }
[12:02:43] <madprops> can't understand that easily :o
[12:02:50] <madprops> how would the OFS way be?
[12:03:17] <geirha> # awk -v OFS='|' 'BEGIN { print "a", "b", "c" }'
[12:03:19] <shbot> geirha: a|b|c
[12:03:52] <geirha> # awk -v OFS='|' '{$1 = toupper($1); print}' <<< 'a b c'
[12:03:54] <shbot> geirha: A|b|c
[12:06:12] <madprops> can I use 'arr' variable in print to do that?
[12:06:20] <madprops> "fatal: attempt to use array `a' in a scalar context"
[12:07:24] <madprops> should I do a for loop?
[12:08:21] <geirha> if the data is in an array, you'll need a loop instead, yes
[12:09:26] <geirha> sep = ""; for (i in arr) { printf("%s%s", sep, arr[i]); sep = "|" }
[12:09:33] <geirha> printf("\n")
[12:10:05] <madprops> OFS won't work here?
[12:10:50] <madprops> also, would that cover the case of not showing the separator at the end?
[12:10:52] <geirha> not unless you assign the values to the fields
[12:11:41] <madprops> seems it doesn't
[12:12:35] <geirha> # awk -v OFS='|' 'BEGIN{a[++n]="a"; a[++n]="b"; a[++n]="c"; NF = n; for (i = 1; i <= n; ++i) $i = a[i]; print}'
[12:12:37] <shbot> geirha: a|b|c
[12:14:23] <geirha> madprops: it does cover the case of not printing separator at the end
[12:14:35] <madprops> i'm trying to understand it
[12:14:47] <madprops> it's still a for loop
[12:14:54] <madprops> don't know why it would be different
[12:14:58] <geirha> which one? the one using the sep variable? or the one assigning to $i?
[12:15:37] *** Quits: euandreh (~euandreh@2804:14c:33:9fe5:3720:61ec:ee32:2ddc) (Ping timeout: 246 seconds)
[12:16:34] <madprops> it works
[12:16:49] *** Joins: euandreh (~euandreh@2804:14c:33:9fe5:50a8:9802:856c:54ce)
[12:17:31] <madprops> maybe adding the print at the end did the difference
[12:19:05] <madprops> awk -v OFS='|' 'NR > 1 {a[++n]=$1} END{for(i=1; i<=n; i++) $i = a[i]; print}' sv1.txt
[12:19:13] <madprops> does n start at 0 or 1?
[12:20:48] <madprops> what does: $i = a[i]  .. do?
[12:20:48] <geirha> awk starts counting at 1
[12:21:09] <madprops> wouldn't a[++n] start at a[2] then?
[12:21:17] <geirha> assigns to field i.  $1 = a[1]; $2 = a[2] etc...
[12:21:46] <madprops> hm but fields of what?
[12:21:48] <geirha> ah, no integers default to 0 when they are not set
[12:22:10] <madprops> since it's END
[12:22:18] <geirha> but when you use split() for example, the resulting array's indices will start at 1 rather than 0
[12:23:01] <geirha> in END it still remembers the last line
[12:23:32] <geirha> so   awk 'END{print}'  is equivalent to  tail -n1
[12:24:12] <madprops> I don't get why it's modifying the fields of the last line
[12:24:48] <madprops> when I inteded to join the contents of the array
[12:24:48] <madprops> (but it works)
[12:24:58] <geirha> when you modify a field, it has to recreate the line ($0)
[12:25:10] <geirha> when it recreates the line, it joins all the fields with OFS in between
[12:25:45] <geirha> # awk 'BEGIN { FS=","; OFS="|" } {print}' <<< a,b,c
[12:25:47] <shbot> geirha: a,b,c
[12:25:55] <geirha> no modifications done, so the line is unchanged
[12:26:01] <madprops> I see a problem with this
[12:26:05] <geirha> # awk 'BEGIN { FS=","; OFS="|" } {$1 = $1; print}' <<< a,b,c
[12:26:06] <shbot> geirha: a|b|c
[12:26:18] <madprops> it works with this: https://pastebin.com/bdyfgwh3
[12:26:38] <geirha> assignment to $1 causes it to recreate $0 as $1 OFS $2 OFS $3
[12:26:53] <geirha> https://pastebin.com/raw/bdyfgwh3
[12:27:20] <madprops> if I add extra fields to the last line
[12:27:29] <madprops> it includes them in the concatenation
[12:27:41] <madprops> for it to work NR has to == NF
[12:27:51] <geirha> that's why I did NF = n
[12:28:11] <madprops> oh I missed that
[12:28:25] <madprops> you're right
[12:29:01] <madprops> isn't it a bit hackish though?
[12:29:53] <madprops> modifying the last line
[12:30:05] <madprops> a bit hard to grasp
[12:30:23] <geirha> then perhaps use the sep loop instead?
[12:30:53] <geirha> or, don't even need the sep var
[12:31:07] <geirha> at least as long as you know there's at least one value
[12:31:53] <geirha> END{ printf("%s", a[1]); for (i = 2; i <= n; ++i) printf("|%s", a[i]); printf("\n" }
[12:33:45] <madprops> getting a syntax error in printf("\n" }
[12:34:04] <madprops> oh
[12:34:07] <madprops> the parenthesis
[12:34:17] <madprops> yeah it works
[12:34:27] <madprops> gonna analyse it now
[12:35:33] <madprops> ah I see what you did
[12:35:46] <madprops> you prepend | except on the first one
[12:37:23] <madprops> maybe an if would be shorter?
[12:37:57] <madprops> nah
[12:39:45] <madprops> awk 'NR > 1 {a[++n]=$1} END{for(i=1; i<=n; ++i){if(i>1) printf("|"); printf("%s", a[i])} printf("\n")}'
[12:41:47] <madprops> both are actually same length
[12:46:47] <geirha> sep=""; for(i=1;i<=n;++i) { printf("%s%s", sep, a[i]); sep="|" }   and this works as the first iteration sep will be empty, all other iterations it will be "|"
[12:48:00] *** Joins: lavaball (felix@31.204.155.215)
[12:48:03] *** Joins: emanuele6 (~emanuele6@user/emanuele6)
[13:04:39] *** Quits: lavaball (felix@31.204.155.215) (Remote host closed the connection)
[13:06:32] <madprops> geirha, clever
[13:06:41] <madprops> still have to print \n at the end though
[13:07:49] <madprops> oh nvm
[13:08:41] *** Joins: lavaball (felix@31.204.155.215)
[13:08:44] *** Quits: pyre (~pyre@crimeboss.nillas-power.com) (Ping timeout: 255 seconds)
[13:12:38] <geirha> yes
[13:30:29] *** Quits: lavaball (felix@31.204.155.215) (Remote host closed the connection)
[13:34:38] *** Joins: lavaball (felix@31.204.155.215)
[13:40:44] *** Quits: lavaball (felix@31.204.155.215) (Remote host closed the connection)
[13:40:59] *** Quits: simbioz (~simbioz@user/simbioz) (Ping timeout: 265 seconds)
[13:41:38] *** Joins: simbioz (~simbioz@user/simbioz)
[13:44:46] *** Joins: lavaball (felix@31.204.155.215)
[14:46:47] *** Quits: lavaball (felix@31.204.155.215) (Quit: lavaball)
[14:47:23] *** Joins: lavaball (felix@31.204.155.215)
[15:03:09] *** Joins: pyre (~pyre@crimeboss.nillas-power.com)
[15:39:39] *** Quits: downunder (~downunder@110.151.19.142) (Quit: WeeChat 3.2)
[16:40:34] *** Joins: phillbush (~phillbush@user/phillbush)
[17:08:03] *** Joins: kensanata (~user@user/kensanata)
[18:20:34] *** Quits: ttmrichter (~thelounge@185.94.228.137) (Quit: Ping timeout (120 seconds))
[18:20:55] *** Joins: ttmrichter (~thelounge@185.94.228.137)
[18:48:47] *** wwalker_comatose is now known as wwalker
[18:58:10] *** Quits: ccl (ccl@shell.xshellz.com) (*.net *.split)
[18:58:10] *** Quits: ^[ (~user@user//x-8473491) (*.net *.split)
[18:58:10] *** Quits: odc (sid197788@id-197788.brockwell.irccloud.com) (*.net *.split)
[18:58:18] *** Joins: odc (sid197788@id-197788.brockwell.irccloud.com)
[18:58:18] *** Joins: ccl (ccl@shell.xshellz.com)
[19:33:15] *** Joins: lgc (~lgc@user/lgc)
[19:40:29] <siraben> wwalker: which version of awk do you recommend then
[19:40:39] <siraben> onetrueawk version seems decent but I'm not nuanced enough to say
[19:53:34] <wwalker> siraben: I'm a visitor here.  I use awk for very simple stuff.  I have no opinion.  I use what the distro installs (which to my knowledge is always gawk)
[19:54:57] <geirha> on debian/ubuntu it's mawk by default. On MacOS it's nawk
[19:55:30] <siraben> only difference i've discerned so far between awk implementations is traversal order in `for (i in s)`
[19:55:33] <siraben> https://github.com/siraben/awk-vm/blob/fd68d920de4a0347c9194c2255d1095aaa754a4c/vm.awk#L47
[19:56:42] <geirha> yes, the order is arbitrary in all awk implementations except gawk4 and newer
[19:57:05] <geirha> In gawk3 you could get sorted order if you passed WHINY_USERS=1 as environment variable
[19:58:46] *** Joins: ^[ (~user@user//x-8473491)
[20:03:25] <geirha> if you just assume the order is arbitrary, you'll no problems with any of the awks in that regard
[20:06:36] <siraben> geirha: is that because of the hashtable implementation?
[20:08:33] <zenema> WHINY_USERS made me chuckle when I read it was an undocumented gawk environment variable.
[20:11:29] <zenema> siraben: If your aiming for the most portable awk script and POSIX compliance, go for one-true-awk/nawk. If it's speed your after, mawk. If it's "features", gawk.
[20:11:41] <zenema> s/your/you're/
[20:11:52] <siraben> I see
[20:12:55] <geirha> yes, awk uses associative arrays and you generally can't expect a specific ordering of associative arrays
[20:45:12] *** Quits: kensanata (~user@user/kensanata) (Ping timeout: 272 seconds)
[20:51:39] *** Joins: jetchisel (jetchisel@user/jetchisel)
[21:19:03] *** Quits: emanuele6 (~emanuele6@user/emanuele6) (Ping timeout: 255 seconds)
[21:19:58] <nmz> welp, code golf is BS
[21:20:30] <nmz> just spent like an hour on the fizzbuzz problem, but I can't use external commands on the bash problems
[21:21:15] <nmz> anyway, heres fizzbuzz in sh/awk    seq 100|awk '$0=(x=($0%3?z:"fizz")($0%5?z:"buzz"))?x:$0'
[21:25:30] *** Joins: yuesbeez (uid458354@id-458354.tinside.irccloud.com)
[21:28:37] *** Joins: emanuele6 (~emanuele6@user/emanuele6)
[21:42:59] *** Quits: jess (~jess@libera/staff/jess) ()
[22:24:59] <phillbush> My issue got discarded ;-; https://github.com/onetrueawk/awk/issues/125
[22:33:34] <OMGOMG> makes sense, -n is an option in e.g. gawk
[22:34:47] <phillbush> I'm not asking for -n to be a option. I'm asking for a new option for read a program from a file and for that option to be the last one processed, like gawk's -E.
[22:34:55] <OMGOMG> (the behaviour makes sense, i realise what you're asking)
[22:35:14] <OMGOMG> didn't know gawk had it already
[22:52:05] <geirha> that'll break with shbot's seq
[22:52:48] *** Quits: jetchisel (jetchisel@user/jetchisel) (Ping timeout: 276 seconds)
[22:53:25] <geirha> phillbush: getopt(1) isn't posix, but getopts(1) is
[22:54:21] *** Joins: jetchisel (jetchisel@user/jetchisel)
[22:54:32] <geirha> but if you write an sh wrapper, you can just do  awk 'yourscript' -- "$@"
[22:55:58] *** Joins: magyar (~magyar@user/magyar)
[23:38:51] *** Joins: jess (~jess@libera/staff/jess)
[23:44:59] <yeti> nmz: codegolf is BS... look for the ascii mandelbrot task for a given coordinate range... the winner was a graphical solution with even a different image coords range!
[23:46:13] <yeti> if the competition evaluates the winner by other rules than given in the task, it makes no sense to waste time on that
