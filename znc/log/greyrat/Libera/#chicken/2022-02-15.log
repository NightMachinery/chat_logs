[01:19:55] *** Quits: fantazo (~fantazo@192-164-154-92.hdsl.highway.telekom.at) (Ping timeout: 256 seconds)
[02:56:02] *** Quits: rgherdt_ (~rgherdt@83.236.30.76) (Remote host closed the connection)
[03:05:40] *** Quits: cjb (~cjb@user/cjb) (Ping timeout: 260 seconds)
[03:16:40] *** Quits: crumpo (~crumpo@user/crumpo) (Quit: Buh bye)
[03:18:16] *** Joins: skapata (~Skapata@2804:14c:87b0:9d2e:ad66:4f1c:f9e8:2233)
[03:18:16] *** Quits: skapata (~Skapata@2804:14c:87b0:9d2e:ad66:4f1c:f9e8:2233) (Changing host)
[03:18:16] *** Joins: skapata (~Skapata@user/skapata)
[04:32:34] *** Joins: m455 (~m455@user/m455)
[04:35:15] *** Joins: cjb (~cjb@user/cjb)
[05:10:44] *** Quits: m455 (~m455@user/m455) (Quit: WeeChat 3.0)
[05:11:02] *** Joins: m455 (~m455@user/m455)
[05:29:44] *** Joins: Rue (~rue@2001-b011-1000-17d9-d616-1cce-b758-6ab8.dynamic-ip6.hinet.net)
[05:57:52] *** Joins: s-liao (~s-liao@101.86.96.21)
[06:34:26] *** Quits: ublx (~ublx@user/ublx) (Quit: ublx)
[06:47:33] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[06:49:35] *** Quits: skapata (~Skapata@user/skapata) (Remote host closed the connection)
[07:16:33] *** Quits: sts-q (~sts-q@91.200.108.237) (Ping timeout: 250 seconds)
[07:17:00] *** Joins: sts-q (~sts-q@212.53.219.149)
[07:17:31] *** Joins: s-liao (~s-liao@101.86.96.21)
[07:31:44] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[07:57:35] *** Quits: cjb (~cjb@user/cjb) (Quit: rcirc on GNU Emacs 29.0.50)
[07:59:40] *** Joins: s-liao (~s-liao@101.86.96.21)
[08:13:28] *** Quits: keyehzh (~keyehzh@user/keyehzh) (Remote host closed the connection)
[10:10:27] *** Joins: fantazo (~fantazo@192-164-154-92.hdsl.highway.telekom.at)
[10:20:48] *** Quits: klovett (~klovett@107.127.17.177) (Quit: ZZZzzzâ€¦)
[10:41:08] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[10:49:24] *** Quits: ASau (~user@lmpc.drb.insel.de) (Remote host closed the connection)
[10:58:34] *** Quits: yagamisa3o (~SingSong@183.234.128.117) (Ping timeout: 272 seconds)
[10:58:55] *** Joins: yagamisa3o (~SingSong@183.234.128.117)
[11:57:34] *** Joins: crumpo (~crumpo@user/crumpo)
[12:07:22] *** Quits: yagamisa3o (~SingSong@183.234.128.117) (Changing host)
[12:07:22] *** Joins: yagamisa3o (~SingSong@user/yagamisato)
[12:12:07] <Bunny351> grep -rnH -- 'Channel' .
[12:12:13] <Bunny351> oops
[12:26:43] <zilti[m]> Heheh
[12:54:23] <zilti[m]> Which is the better language for me to learn from - Prolog or Erlang? (Or even another?)
[12:55:40] <Bunny351> prolog
[12:56:08] <Bunny351> erlang is just lispy with prolog syntax, prolog is completely different and will first frustrate you, then open your mind
[12:57:44] <zilti[m]> Oh really? I was given the impression that Erlang is rather close to Prolog. Hm. Guess some people mixed up syntax and actual paradigms. Well considering you implemented two Prolog compilers I guess that answer was to be expected ^^ Do you happen to have a link to a good resource for bloody beginners?
[12:57:46] <fantazo> Bunny351: calling Erlang "lispy" is a little weird.
[12:59:03] <Bunny351> no, erlang only has the superficial syntax and single-assignment variables, vars are not first class, there is no backtracking, no unification
[12:59:09] <fantazo> I have never experienced the "open your mind" part of prolog. I mean mostly it's indirect imperative coding, I try to formulate the facts so that prolog maybe finally does specific things in a definet sequential order.
[12:59:22] <Bunny351> yes, it needs practice
[12:59:48] <fantazo> Bunny351: "it needs practice", that means it's totally useless.
[13:00:05] <zilti[m]> fantazo: so programming is totally useless in general, then?
[13:00:05] <Bunny351> it took me long not to get frustrated by the different way of doing things. once you learn how to take advantage of the excecution model, code shrinks and everything becomes easy
[13:00:20] <Bunny351> fantazo: it means you didn't try hard enough
[13:00:30] <fantazo> zilti[m]: no.
[13:01:14] <zilti[m]> Well, all programming needs practice (beyond "programming = copying javascript snippets from StackOverflow")
[13:01:49] <fantazo> hmpf, now you are trying to insult me. javascript, pah!
[13:01:58] <zilti[m]> (:
[13:02:09] <Bunny351> fantazo: I'm not, not at all.
[13:02:23] <Bunny351> my advice: implement it - either your head explodes or you see the light
[13:02:47] <Bunny351> I recommend "The Craft of Prolog", it helped me a lot.
[13:03:21] <Bunny351> most other books are crap, especially "Art of Prolog"
[13:03:25] <zilti[m]> Ok, I'm gonna have a look at that
[13:03:28] <Bunny351> Bratko is sort of ok
[13:04:14] <Bunny351> "The Implementation of Prolog" by Boizumault et al is pure magic
[13:05:23] <zilti[m]> Wow, it has a hefty price tag though ^^
[13:05:26] <Bunny351> once you get around the overly "scientific" logic programming jargon it gets easier
[13:06:06] <Bunny351> yes, that's true. if you seriously think about implementing prolog it's good though.
[13:06:50] <Bunny351> "WAM - a tutorial reconstruction" is good and free, but it leaves out crucial details, which nearly all papers on Prolog-impl do, funnily enough...
[13:06:58] <zilti[m]> I'm gonna add it to my notes, although I'd say I am still quite a bit away from implementing a language myself. And when I get to that point I'm probably gonna implement a Scheme first ^^
[13:08:18] <Bunny351> yeah, and it is not really pure joy. but if you really want to grok a language or execution model, it helps a lot
[13:09:08] <Bunny351> O'Keefe wrote "you optimize prolog programs by removing code" and it's true, as weird as that sounds!
[13:10:04] <zilti[m]> Heh, reminds me a bit of the old "How do you sculpt a lion?" - "Well I take a big block of marble and remove everything that doesn't look like a lion"
[13:10:08] <Bunny351> it is a pity that there are few simple, portable no-nonsense implementations for Prolog. gprolog is good but x86 only, I think
[13:10:38] <Bunny351> SWI prolog is a monstrous pile of features but every version is slightly different.
[13:10:41] <zilti[m]> I've seen that you implemented one as well?
[13:11:05] <Bunny351> yeah, it is buggy, discontinued. debugging it made me mad.
[13:11:51] <Bunny351> now I prefer committed choice languages, without backtracking, because the execution model is so incredibly simple
[13:12:05] <Bunny351> but prolog is more powerful and concise
[13:14:14] <zilti[m]> I guess I've got some reading to do now, thanks for the pointers!
[13:14:42] <zilti[m]> gprolog seems to have been ported to pretty much everything by now it seems
[13:15:23] <Bunny351> really? Hm... it doesn't seem to be packaged for the non-x86 systems I have
[13:16:03] <zilti[m]> The page mentions x86_64, PowerPC, SPARC, Alpha, Mips, and armv6, armv7, armv8
[13:16:40] <Bunny351> well, great.
[13:16:51] <sts-q> Bunny351: What is a commited chiose language?
[13:17:02] <Corbin> You might also be interested in miniKanren. There's a pile of papers at http://minikanren.org/ and a CHICKEN egg.
[13:17:03] <Bunny351> what I never looked at was constraint programming, gprolog has a lot of support, it seems
[13:17:53] <sts-q> s/chiose/choise/
[13:18:00] <zilti[m]> Ah miniKanren, that I've even worked with before already. I implemented the rule set of a board game with it
[13:18:18] <Bunny351> sts-q: languages like GHC (not Haskell), Strand, Parlog. parallel prolog-derivates that, once a rule head matches, "commit" to that clause and do not backtrack
[13:19:35] <Bunny351> I absolutely never understood Kanren.,.
[13:19:35] <sts-q> ok, seems above the scope of my tutorials...
[13:20:13] <zilti[m]> The problem with Kanren for me always was the incredibly lacking documentation
[13:21:23] <zilti[m]> To this day I have no idea what the differences between Kanren and miniKanren are supposed to be
[13:21:33] <Bunny351> yep, same here
[13:22:35] <zilti[m]> The only helping thing was The Reasoned Schemer 
[13:22:37] <Corbin> IIUC Kanren was the dialect used in a book ("The Reasoned Schemer" perhaps?) but I haven't read it.
[13:23:10] <zilti[m]> Well in my experience miniKanren contains all features needed in The Reasoned Schemer
[13:23:59] <Bunny351> do people actually use kanren (or minikanren) for actual problems?
[13:25:13] <zilti[m]> Apparently, yes. I heard a talk once about core.logic (Clojure's miniKanren) and they use it for business logic. They apparently created a rule engine with it simple enough that business people write rules for it
[13:26:01] <Bunny351> yes, but clojure people use every feature thrown at them. I mean "real" programmers using "real" programming languages, you know?
[13:26:09] <Bunny351> vandusen: SMILEY
[13:26:14] <vandusen> Bunny351: This I accept!
[13:26:56] <zilti[m]> heheh
[13:26:57] <Bunny351> you won't find a nion-trivial clojure program that doesn't use components, channels, transducers, and whatever someone recently came up with, because the can!
[13:27:07] <Bunny351> they, even
[13:29:09] <zilti[m]> Components?
[13:29:16] <Corbin> Bunny351: I wrote a typechecker in CHICKEN miniKanren. I'm a musician, though.
[13:29:39] <sjamaan> Bunny351: ^ Truth
[13:29:43] <Bunny351> cool. was it rewarding?
[13:29:58] <zilti[m]> I do have a non-trivial Clojure program here without channels (and thus without Transducers) :P
[13:30:05] <sjamaan> Transducers are kinda cool, but the syntax is so confusing
[13:30:15] <sjamaan> zilti[m]: You can use transducers without channels ;)
[13:30:41] <sjamaan> That's one of the confusing things, you can use it for two quite seemingly different purposes
[13:30:52] <zilti[m]> Yea I haven't fully grasped transducers yet. For me they look like partially applied transforming functions
[13:30:59] <sjamaan> They are
[13:31:16] <Corbin> Very rewarding. I can run the typechecker backwards to generate programs based on type signatures, and it works very well for polymorphic signatures.
[13:31:29] <sjamaan> Basically, it's a way to stack transformations like UNIX pipes, so you don't produce intermediate lists all the time (which wouldn't work for endless lazy sequences anyway)
[13:31:29] <Bunny351> sounds nice
[13:31:42] <zilti[m]> Why the nomenclature then, though? 
[13:31:44] <sjamaan> So you can combine filter and map without first mapping and then filtering
[13:31:48] <Bunny351> sjamaan: I wonder how that is implemented...
[13:32:06] <Bunny351> zilti: because "Rich Hickey"!
[13:32:08] <Corbin> zilti[m]: What are the alternatives? "Foldable" from GHC Haskell, I guess?
[13:32:13] <zilti[m]> Corbin: you can...what?!?
[13:32:18] <Bunny351> deforestation
[13:32:46] <Bunny351> zilti: like in prolog - a parser can parse or generate a sentence, if you code it cleanly
[13:33:14] <zilti[m]> Speaking of haskell. I also never understood what's supposed to be so special about monads
[13:33:34] <Corbin> zilti[m]: https://osdn.net/users/corbin/pf/cammy/scm/blobs/master/movelist/movelist.scm is the code. I'm loading the environment so I can demonstrate it.
[13:34:18] <zilti[m]> Bunny351: sure, it's just that the idea of generating programs from type signatures sounds wild :) 
[13:35:36] <Bunny351> I guess not really operational programs, unless the type-system is already turing complete...
[13:36:47] <Corbin> Yeah, types are not much of a specification. It's useful when the type signature is "linear" in the sense that every input is used, but that's about it.
[13:38:06] <Corbin> zilti[m]: Ignoring Haskell: A monad is a natural way to talk about how a computer emits effects as it evaluates a program. In terms of theory, *every* programming language's effects can be structured monadically.
[13:38:40] <zilti[m]> Bunny351: ...like Scala's type system? ^^ I think that was the final straw that made me abandon Scala back then. With every bit I learned more about Scala, it smelled more like complete insanity
[13:48:53] <Corbin> zilti[m]: https://bpa.st/OVSQ shows off some automatically-generated Cammy programs. I recently reordered the clauses of the typechecker, and now the final two examples don't work. This is what I don't like about CSP: it's unpredictable how the order of your code will affect its runtime.
[13:49:48] <vandusen> [eggs repo (r41115, by sjamaan)] spiffy (5): Add security note regarding the safe usage of spiffy's not-found-handler and vhost handlers.
[13:50:12] <zilti[m]> Oh, hm, I find the examples quite impressive nonetheless, as "simple" as they are
[13:51:33] <vandusen> [eggs repo (r41116, by sjamaan)] spiffy (4): Add security note regarding the safe usage of spiffy's not-found-handler and vhost handlers.
[13:52:35] <zilti[m]> By the way... Not sure who is handling that, but my repositories are up again since a few days, so the eggs could be reactivated now for the ones hosted on gitea.lyrion.ch
[13:56:02] <vandusen> [eggs repo (r41117, by sjamaan)] Reactivate zilti's eggs now that the server has been restored
[13:56:19] <zilti[m]> Thanks :)
[13:56:22] <sjamaan> yw
[14:35:57] *** Joins: ASau (~user@lmpc.drb.insel.de)
[14:59:11] <Bunny351> zilti: I don't know Scala, but heard nothing but bad things about it
[15:01:32] *** Joins: skapata (~Skapata@2804:14c:87b0:9d2e:3c70:5798:e730:7b29)
[15:01:32] *** Quits: skapata (~Skapata@2804:14c:87b0:9d2e:3c70:5798:e730:7b29) (Changing host)
[15:01:32] *** Joins: skapata (~Skapata@user/skapata)
[15:12:56] <megane> Bunny351: why is "The Art of Prolog" crap? i seem to have it for some reason, but haven't really looked at it.
[15:42:59] <ASau> I don't remember a lot about it, but I can confirm that it is either totally useless or very close to that.
[16:12:31] *** Joins: s-liao (~s-liao@101.86.96.21)
[16:28:35] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[16:31:35] *** Joins: s-liao (~s-liao@101.86.96.21)
[17:14:59] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Ping timeout (120 seconds))
[17:17:31] *** Joins: s-liao (~s-liao@101.86.96.21)
[17:18:50] *** Quits: s-liao (~s-liao@101.86.96.21) (Client Quit)
[17:19:47] *** Joins: s-liao (~s-liao@101.86.96.21)
[17:19:55] *** Quits: s-liao (~s-liao@101.86.96.21) (Client Quit)
[17:58:36] *** Joins: klovett (~klovett@107.127.17.177)
[18:19:05] *** Joins: keyehzh (~keyehzh@user/keyehzh)
[19:17:39] <fantazo> ASau: can it be used to press down a piece of Tofu?
[19:29:39] <zilti[m]> Depending on the number of pages it might also doulbe as an instrument for self-defence
[19:30:43] <fantazo> zilti[m]: surely practical for "planned accidents". sometimes big books fall out of windows ...
[19:31:28] <fantazo> or maybe it could be useful if tissue paper ran out.
[19:45:13] *** Quits: Guest3567 (~cat@h-98-128-128-173.A351.priv.bahnhof.se) (Quit: Reconnecting)
[19:45:25] *** Joins: sudden (~cat@h-98-128-128-173.A351.priv.bahnhof.se)
[19:45:49] *** sudden is now known as Guest402
[19:46:15] *** Quits: Guest402 (~cat@h-98-128-128-173.A351.priv.bahnhof.se) (Changing host)
[19:46:15] *** Joins: Guest402 (~cat@user/sudden)
[19:58:05] <Bunny351> well, the cover is attractive...
[20:00:50] <fantazo> Bunny351: is it so attractive, that the internet has porn of it?
[20:19:49] <Bunny351> that would have to be investigated
[20:39:01] <vandusen> SPAM! SPAM! SPAM! by fereeee
[21:32:11] <vandusen> SPAM! SPAM! SPAM! by freee
[22:03:51] *** Joins: v_m_v (~vm_v@adsl-84-226-66-30.adslplus.ch)
[22:23:24] *** Quits: sts-q (~sts-q@212.53.219.149) (Ping timeout: 240 seconds)
[22:24:24] *** Joins: sts-q (~sts-q@91.200.108.201)
[23:01:59] *** Quits: keyehzh (~keyehzh@user/keyehzh) (Read error: Connection reset by peer)
[23:02:13] *** Joins: keyehzh (~keyehzh@user/keyehzh)
[23:27:08] *** Quits: clacke (88d96f2df3@knopi.disroot.org) (Read error: Connection reset by peer)
[23:29:06] *** Joins: ublx (~ublx@user/ublx)
[23:36:27] *** Quits: v_m_v (~vm_v@adsl-84-226-66-30.adslplus.ch) (Remote host closed the connection)
