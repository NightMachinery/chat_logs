[00:01:10] *** Joins: Tuplanolla (~Tuplanoll@91-159-68-166.elisa-laajakaista.fi)
[00:42:02] *** Quits: eggplantade (~Eggplanta@2600:1700:bef1:5e10:494b:f936:f65f:424f) (Remote host closed the connection)
[01:05:24] *** Quits: geekosaur (~geekosaur@xmonad/geekosaur) (Remote host closed the connection)
[01:07:04] *** Joins: geekosaur (~geekosaur@xmonad/geekosaur)
[01:32:21] *** Joins: coot (~coot@89-64-85-93.dynamic.chello.pl)
[01:42:23] *** Quits: fendor_ (~fendor@178.115.77.166.wireless.dyn.drei.com) (Remote host closed the connection)
[01:42:26] *** Joins: eggplantade (~Eggplanta@2600:1700:bef1:5e10:494b:f936:f65f:424f)
[01:46:37] *** Quits: eggplantade (~Eggplanta@2600:1700:bef1:5e10:494b:f936:f65f:424f) (Ping timeout: 240 seconds)
[01:49:35] *** Joins: merijn (~merijn@c-001-001-018.client.esciencecenter.eduvpn.nl)
[02:03:58] *** Quits: coot (~coot@89-64-85-93.dynamic.chello.pl) (Quit: coot)
[02:14:55] *** Quits: __monty__ (~toonn@user/toonn) (Quit: leaving)
[02:23:49] *** Quits: merijn (~merijn@c-001-001-018.client.esciencecenter.eduvpn.nl) (Ping timeout: 256 seconds)
[02:26:50] *** Joins: boxscape_ (~boxscape_@p4ff0b9d5.dip0.t-ipconnect.de)
[02:37:56] *** Quits: Cale (~cale@cpef48e38ee8583-cm30b7d4b3fc20.cpe.net.cable.rogers.com) (Remote host closed the connection)
[02:39:54] *** Joins: Cale (~cale@cpef48e38ee8583-cm30b7d4b3fc20.cpe.net.cable.rogers.com)
[03:07:40] *** Joins: lispy (~lispy3@84.69.59.93)
[03:29:52] *** Joins: eggplantade (~Eggplanta@2600:1700:bef1:5e10:494b:f936:f65f:424f)
[03:42:10] *** Quits: vicfred (~vicfred@user/vicfred) (Quit: Leaving)
[04:19:58] *** Joins: merijn (~merijn@c-001-001-018.client.esciencecenter.eduvpn.nl)
[04:36:21] *** Quits: Tuplanolla (~Tuplanoll@91-159-68-166.elisa-laajakaista.fi) (Quit: Leaving.)
[04:39:15] *** Quits: raehik (~raehik@cpc95906-rdng25-2-0-cust156.15-3.cable.virginm.net) (Ping timeout: 256 seconds)
[04:53:57] *** Quits: merijn (~merijn@c-001-001-018.client.esciencecenter.eduvpn.nl) (Ping timeout: 240 seconds)
[05:24:18] *** Quits: lispy (~lispy3@84.69.59.93) (Quit: Leaving)
[06:50:46] *** Joins: merijn (~merijn@c-001-001-018.client.esciencecenter.eduvpn.nl)
[07:24:54] *** Quits: merijn (~merijn@c-001-001-018.client.esciencecenter.eduvpn.nl) (Ping timeout: 256 seconds)
[07:36:50] *** Quits: Midjak (~Midjak@may53-1-78-226-116-92.fbx.proxad.net) (Quit: This computer has gone to sleep)
[07:45:28] *** Joins: syntactic_sugar (~amoljha@2601:644:8601:2e30::a5c9)
[07:46:53] *** Joins: vicfred (~vicfred@user/vicfred)
[08:28:41] *** Quits: syntactic_sugar (~amoljha@2601:644:8601:2e30::a5c9) (Quit: WeeChat 3.3)
[08:49:29] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 268 seconds)
[08:52:21] *** Quits: boxscape_ (~boxscape_@p4ff0b9d5.dip0.t-ipconnect.de) (Quit: Connection closed)
[09:21:20] *** Joins: merijn (~merijn@c-001-001-018.client.esciencecenter.eduvpn.nl)
[09:48:25] *** Joins: ix (~ix@2a02:8010:674f:0:cda6:d05:f0d7:4922)
[09:50:58] <ix> ski: how you been?
[09:55:38] *** Quits: merijn (~merijn@c-001-001-018.client.esciencecenter.eduvpn.nl) (Ping timeout: 256 seconds)
[10:20:57] *** Quits: geekosaur (~geekosaur@xmonad/geekosaur) (Ping timeout: 240 seconds)
[10:28:54] *** Joins: geekosaur (~geekosaur@xmonad/geekosaur)
[10:39:17] *** Quits: mvk (~mvk@2607:fea8:5cdd:f000::55f8) (Ping timeout: 240 seconds)
[10:41:05] *** Joins: mvk (~mvk@173.33.176.132)
[10:58:25] *** Joins: notzmv (~zmv@user/notzmv)
[11:32:37] *** Quits: polyphem (~rod@2a02:810d:840:8754:b6f3:5141:3b3:83de) (Ping timeout: 240 seconds)
[11:32:47] *** Joins: polyphem (~rod@2a02:810d:840:8754:b6f3:5141:3b3:83de)
[11:51:58] *** Joins: merijn (~merijn@c-001-001-018.client.esciencecenter.eduvpn.nl)
[11:53:19] *** Joins: coot (~coot@89-64-85-93.dynamic.chello.pl)
[11:54:11] *** Quits: polyphem (~rod@2a02:810d:840:8754:b6f3:5141:3b3:83de) (Quit: WeeChat 3.4)
[11:54:23] *** Joins: polyphem (~rod@2a02:810d:840:8754:b6f3:5141:3b3:83de)
[12:03:41] <ix> If i'm understanding right, Propeller ( https://hackage.haskell.org/package/propellor-5.1.0 ) should be possible to reimplement using Polysemy/fused-effects and have much more general code
[12:21:17] *** Quits: eggplantade (~Eggplanta@2600:1700:bef1:5e10:494b:f936:f65f:424f) (Remote host closed the connection)
[12:26:22] *** Quits: merijn (~merijn@c-001-001-018.client.esciencecenter.eduvpn.nl) (Ping timeout: 256 seconds)
[12:30:37] *** Joins: merijn (~merijn@c-001-001-018.client.esciencecenter.eduvpn.nl)
[12:47:44] *** Quits: geekosaur (~geekosaur@xmonad/geekosaur) (Killed (NickServ (GHOST command used by allbery_b)))
[12:47:44] *** Joins: allbery_b (~geekosaur@xmonad/geekosaur)
[12:47:47] *** allbery_b is now known as geekosaur
[12:58:59] <turlando> I've got very little experience with this stuff, so I'm just wondering if the solution I'm thinking of can work. I'm writing a very little and as simple as possible discrete event simulator. I've got an interface that requires the simulation to provide an Event data type describing the events that can happen at any time, a State data type representing the state of the simulated system at any given time, and a state transition function State -> 
[12:58:59] <turlando> Event -> State. I provide the program with the history of events and an initial state and it produces the final state. So far so good. I now want to be able to perform random simulations. So for instance I'm describing a single threaded server, queuing clients when they arrive, servicing them one by one sequentially. I basically sample an exponential distribution generating two values: arrival time and delta service time, put the eventsin a 
[12:58:59] <turlando> priority queue indexing by arrival time and have the simulation run off the priority queue. So far so good. Now I want to be able to generate random events while the simulation is running in order to avoid to generate the whole event list beforehand. The naive approach would be to generate the first event, have the simulator handle it and generate the next event and so on. Could this approach distort the results? It feels like I'm limiting the 
[12:58:59] <turlando> simulation: for instance the time of arrival of the first client determines the minimum arrival time for the following clients.
[13:21:40] *** Joins: eggplantade (~Eggplanta@2600:1700:bef1:5e10:494b:f936:f65f:424f)
[13:21:58] *** Joins: Tuplanolla (~Tuplanoll@91-159-68-166.elisa-laajakaista.fi)
[13:25:17] *** Quits: coot (~coot@89-64-85-93.dynamic.chello.pl) (Quit: coot)
[13:25:57] *** Quits: eggplantade (~Eggplanta@2600:1700:bef1:5e10:494b:f936:f65f:424f) (Ping timeout: 240 seconds)
[13:56:02] *** Joins: Guest5234 (~Guest52@80-100-97-100.ip.xs4all.nl)
[14:01:06] *** Joins: coot (~coot@89-64-85-93.dynamic.chello.pl)
[14:03:50] *** Quits: merijn (~merijn@c-001-001-018.client.esciencecenter.eduvpn.nl) (Ping timeout: 256 seconds)
[14:05:14] <polyphem> turlando: sure if you generate random events with times after first client and before seconf client arrival its gonna influence the outcome
[14:07:16] <polyphem> why dont randomly all requests for all clients beforehand and feed that to simulator
[14:07:30] <polyphem> generate
[14:08:42] <turlando> Yep polyphem, it is what I'm doing right now, I'm wondering if there's a proper way to generate events while it's running the simulation and be statistically correct?
[14:10:39] <turlando> By statistically correct I mean have an event condition the following events
[14:10:59] <polyphem> are you generating events before the simulation runs or while its running
[14:12:13] <turlando> Right now I'm generating event before the simulation runs, then I hand the event list the the simulator that reduces it to a final state. I'm wondering if is it possible to avoid generating the whole list beforehand in order to reduce memory usage
[14:12:16] <polyphem> are generated eventst dependent on current simulator state ?
[14:13:54] <polyphem> if you be carefull laziness  wont generate *all* events beforehand at once , instead only wheh next event is needed
[14:13:56] <turlando> In the simple example I'm considering right now they're not depending on the simulator state. The generic event is (arrival_time, service_time) right now. But I might think of other examples that are dependent on the state
[14:15:10] <turlando> But can lazyness really solve the problem this time? It looks like it present the same issue I was talking about before
[14:18:19] <polyphem> > print . take 3 $ sequence [ev | e <- [1..] , let ev = pure e >> getCurrentTime]
[14:18:20] <lambdabot>  error:
[14:18:20] <lambdabot>      Variable not in scope: getCurrentTime :: [a0]
[14:18:41] <polyphem> > print . take 3 $ sequence [ev | e <- [1..] , let ev = pure e >> putStr "e"]
[14:18:42] <lambdabot>  error:
[14:18:42] <lambdabot>      • Couldn't match type ‘IO’ with ‘[]’
[14:18:42] <lambdabot>        Expected type: [[()]]
[14:20:28] <turlando> Yeah, but if I lazily generate e1 schedulet at t1, process it with the simulator, then suppose i generate e2 scheduled at time t0, I can't schedule e2 anymore, I can only sample values that are greater than t1
[14:20:30] <turlando> Right?
[14:22:52] *** Joins: eggplantade (~Eggplanta@2600:1700:bef1:5e10:5d8e:db89:f241:b6e3)
[14:26:57] *** Quits: eggplantade (~Eggplanta@2600:1700:bef1:5e10:5d8e:db89:f241:b6e3) (Ping timeout: 240 seconds)
[14:31:03] <polyphem> so you wanna make seure generated e/t are in ascending order , thats a generator issue then , right ?
[14:31:03] *** Joins: fendor (~fendor@178.115.77.166.wireless.dyn.drei.com)
[14:32:31] <turlando> I think so, maybe there is no solution for that. I'm wondering how other simulators do this
[14:41:19] <polyphem> its an issue of the generator : you could generate (e,et,randomDeltaTime) and then return (e,t-randomDeltaTime) , no ?
[14:41:55] <polyphem> so you could have e1/t1 , e2/t0 
[14:44:27] <polyphem> ok, now i see your problem , the simulator has to consume the events in ascending time order to fold the state correctly
[14:46:20] <turlando> Yep polyphem, it is a consuming/scheduling problem in order to make the simulation advance properly
[14:46:32] <polyphem> normally youd wouldnt consume the events right away , youd store them , and then make a projection with retrievs the events in correct cronological order from then store
[14:47:53] <turlando> I'm already using a priority queue in order to have them "sorted" in the chronological order. That's what you're suggesting, right?
[14:48:27] <turlando> E.g.: I want N clients, sample N arrival times and N service times, put the event in the PQ keying by arrival time
[14:52:29] <polyphem> ok its  an online vs offline algorithm thing. you have to store the events , and run the simulation on all stored events afterwards, if a new event comes in, you have to reru n the entire simulation an all new events
[14:53:25] <turlando> I see, thank you polyphem!
[14:54:56] <polyphem> however you can apply snapshotting
[14:57:21] <polyphem> that is split your events in chunks and store the intermediate states incrementally , when a new event comes in  for time t , you can start with the last chunk before t as your initial state and fold only the events afterwards (with the new event a t time t)
[15:01:33] <polyphem> s0 --chunk0--> s1(chunk0) --chunk1--> s2(chunk1) --chunk3--> s3(chunk2) --> (ev,t4) --chunk3--> s4(chunk3) --> finalstate , youd only have to recompute final state with s3 as initial state and all events onward to present time
[15:05:25] <polyphem> s0 --chunk0--> s1(chunk0) --chunk1--> s2(chunk1) --*chunk2*--> s3(chunk2) --> (ev,t4) --chunk3--> s4(chunk3) --> finalstate 
[15:05:52] <turlando> Yep, that is a solution, thanks again polyphem
[15:06:45] <polyphem> foldl sim s3 ((ev,t4):chunk3)
[15:06:52] <polyphem> :)
[15:08:36] <polyphem> its funny , because myself is writing an eventsourcing library right now , that works very similar to your event processing
[15:14:08] <polyphem> you can also window your recomputation , i.e. collect n new events and do one recomputation for all of them starting with the snapshot before the minimum_new_event time as starting state
[15:14:37] *** Quits: juri_ (~juri@178.63.35.222) (Ping timeout: 240 seconds)
[15:15:08] <polyphem> depends on the rate your events come in and what the requierments are for actuallity on the simulation
[16:00:07] *** Joins: merijn (~merijn@c-001-001-018.client.esciencecenter.eduvpn.nl)
[16:06:50] *** Joins: juri_ (~juri@178.63.35.222)
[16:22:32] *** Joins: __monty__ (~toonn@user/toonn)
[16:34:34] *** Quits: merijn (~merijn@c-001-001-018.client.esciencecenter.eduvpn.nl) (Ping timeout: 256 seconds)
[16:40:44] *** Joins: fendor_ (~fendor@91.141.78.76.wireless.dyn.drei.com)
[16:43:02] *** Quits: fendor (~fendor@178.115.77.166.wireless.dyn.drei.com) (Ping timeout: 240 seconds)
[16:52:28] *** Joins: zincy_ (~zincy@host86-151-99-97.range86-151.btcentralplus.com)
[17:14:43] *** Joins: Midjak (~Midjak@may53-1-78-226-116-92.fbx.proxad.net)
[17:26:56] *** Quits: fendor_ (~fendor@91.141.78.76.wireless.dyn.drei.com) (Remote host closed the connection)
[17:28:59] *** Joins: fendor (~fendor@91.141.78.76.wireless.dyn.drei.com)
[17:43:30] *** Joins: merijn (~merijn@c-001-001-018.client.esciencecenter.eduvpn.nl)
[18:11:23] *** Quits: geekosaur (~geekosaur@xmonad/geekosaur) (Remote host closed the connection)
[18:13:10] *** Joins: geekosaur (~geekosaur@xmonad/geekosaur)
[18:17:46] *** Quits: merijn (~merijn@c-001-001-018.client.esciencecenter.eduvpn.nl) (Ping timeout: 250 seconds)
[18:23:01] *** Quits: zincy_ (~zincy@host86-151-99-97.range86-151.btcentralplus.com) (Remote host closed the connection)
[18:35:05] *** Joins: zincy_ (~zincy@host86-151-99-97.range86-151.btcentralplus.com)
[18:48:41] *** Quits: zincy_ (~zincy@host86-151-99-97.range86-151.btcentralplus.com) (Remote host closed the connection)
[18:54:05] *** Joins: zincy_ (~zincy@2a00:23c8:970c:4801:f0bc:c4cb:1665:1c67)
[18:55:42] *** Quits: Midjak (~Midjak@may53-1-78-226-116-92.fbx.proxad.net) (Quit: Leaving)
[18:56:21] *** Quits: zincy_ (~zincy@2a00:23c8:970c:4801:f0bc:c4cb:1665:1c67) (Remote host closed the connection)
[18:57:23] *** Joins: Midjak (~Midjak@may53-1-78-226-116-92.fbx.proxad.net)
[19:17:14] *** Joins: zincy_ (~zincy@2a00:23c8:970c:4801:f0bc:c4cb:1665:1c67)
[19:17:24] *** Quits: zincy_ (~zincy@2a00:23c8:970c:4801:f0bc:c4cb:1665:1c67) (Remote host closed the connection)
[19:40:58] *** Quits: Guest5234 (~Guest52@80-100-97-100.ip.xs4all.nl) (Quit: Connection closed)
[20:00:01] *** Joins: raehik (~raehik@cpc95906-rdng25-2-0-cust156.15-3.cable.virginm.net)
[20:14:00] *** Joins: merijn (~merijn@c-001-001-018.client.esciencecenter.eduvpn.nl)
[20:23:57] *** Joins: eggplantade (~Eggplanta@108-201-191-115.lightspeed.sntcca.sbcglobal.net)
[20:34:18] *** Joins: lispy (~lispy3@84.69.59.93)
[20:47:57] *** Quits: merijn (~merijn@c-001-001-018.client.esciencecenter.eduvpn.nl) (Ping timeout: 240 seconds)
[21:29:46] *** Quits: turlando (~turlando@user/turlando) (Read error: Connection reset by peer)
[21:34:17] *** Joins: turlando (~turlando@93-42-250-112.ip89.fastwebnet.it)
[21:34:17] *** Quits: turlando (~turlando@93-42-250-112.ip89.fastwebnet.it) (Changing host)
[21:34:17] *** Joins: turlando (~turlando@user/turlando)
[22:08:10] *** Quits: coot (~coot@89-64-85-93.dynamic.chello.pl) (Quit: coot)
[22:19:15] <[exa]> side thought: we need software packaging&distribution systems à la carte
[22:20:46] <monochrom> Windows people have InstallShield and others.
[22:21:16] <monochrom> The Unix world, I say that the "you can always build from source" mentality is the culprit.
[22:22:42] <monochrom> Now, automation of updates, that's an even more interesting story.
[22:22:48] <geekosaur> oh, the unix world has its solution. it's called docker. :(
[22:22:58] <monochrom> haha
[22:23:00] <hpc> maybe we just need a standard for "this is the name of a package"
[22:23:29] <hpc> and then you can at least have some level of "i want this user-level rpm which depends on libc, which is from ubuntu's repos because that's the distro this box is on"
[22:23:59] <hpc> and then just... leave build configuration stuff up in the air?
[22:24:07] <geekosaur> and 2 days later comes the next distro with its own names for everything
[22:24:22] <hpc> same as 2 days later someone can write a new os that isn't posix
[22:26:00] <monochrom> BTW -static is already the default unless archlinux. (And from past conversations, whatif is not on archlinux.)
[22:26:37] <geekosaur> right but that means umpteen different static archives. they want one
[22:26:58] <geekosaur> and apparently building the whole app local and copying it over hasn't occurred to them
[22:27:09] <geekosaur> they want to build a lib and copy it over
[22:41:00] *** Joins: coot (~coot@89-64-85-93.dynamic.chello.pl)
[22:44:37] *** Joins: merijn (~merijn@c-001-001-018.client.esciencecenter.eduvpn.nl)
[22:50:43] *** Quits: eggplantade (~Eggplanta@108-201-191-115.lightspeed.sntcca.sbcglobal.net) (Remote host closed the connection)
[22:57:41] *** Quits: lispy (~lispy3@84.69.59.93) (Quit: Leaving)
[23:18:37] *** Quits: merijn (~merijn@c-001-001-018.client.esciencecenter.eduvpn.nl) (Ping timeout: 240 seconds)
[23:30:16] *** Joins: eggplantade (~Eggplanta@2600:1700:bef1:5e10:5d8e:db89:f241:b6e3)
[23:49:15] *** Quits: hololeap (~hololeap@user/hololeap) (Excess Flood)
[23:50:37] *** Joins: hololeap (~hololeap@user/hololeap)
