[00:13:40] *** Joins: pmwals09 (~pmwals09@c-73-218-223-243.hsd1.ma.comcast.net)
[00:13:58] *** Joins: flyke (~flyke@user/flyke)
[00:13:59] *** Quits: pmwals09 (~pmwals09@c-73-218-223-243.hsd1.ma.comcast.net) (Remote host closed the connection)
[00:14:11] *** Joins: pmwals09 (~pmwals09@c-73-218-223-243.hsd1.ma.comcast.net)
[00:14:20] *** Quits: pmwals09 (~pmwals09@c-73-218-223-243.hsd1.ma.comcast.net) (Remote host closed the connection)
[00:17:29] *** Joins: klovett_ (~klovett@107.127.17.177)
[00:17:34] *** Joins: kjak (~kjak@pool-108-45-56-21.washdc.fios.verizon.net)
[00:21:24] *** Quits: klovett (~klovett@107.127.17.177) (Ping timeout: 256 seconds)
[00:26:06] <ecraven> I've heard interesting things about idris 2 ;)
[00:26:49] <Zipheir> It is quite interesting.
[00:30:43] *** Joins: TCZ (~tcz@91.150.178.124)
[00:35:09] <Zipheir> From a Scheme perspective, it would be very interesting to take Pie (the closest thing to dependently-typed Scheme) and extend it to something more general-purpose.  https://docs.racket-lang.org/pie/
[00:52:21] <sham1> And of course Typed Racket can also have a mention since it's very good as well
[00:56:15] <Zipheir> Indeed, Pie is built on TR.
[01:07:58] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 260 seconds)
[01:09:06] *** Joins: seninha (~seninha@user/seninha)
[01:15:18] * ski . o O ( higher-order contracts )
[01:19:35] <Zipheir> In the Findler & Felleisen 2002 sense?
[01:21:19] <Zipheir> (https://www2.ccs.neu.edu/racket/pubs/icfp2002-ff.pdf)
[01:21:49] *** Joins: sp1ff (~user@c-73-189-25-64.hsd1.ca.comcast.net)
[01:28:03] *** Joins: pmwals09 (~pmwals09@c-73-218-223-243.hsd1.ma.comcast.net)
[01:29:03] <ski> yes
[01:32:17] *** Quits: pmwals09 (~pmwals09@c-73-218-223-243.hsd1.ma.comcast.net) (Ping timeout: 240 seconds)
[01:32:39] *** Quits: wnklmnn (~wnklmnn@2a02:908:4e2:9740:2d8:61ff:fef9:b4c2) (Quit: Leaving)
[01:51:30] *** Quits: ouestbillie (~gallup@62.28.193.74) (Ping timeout: 256 seconds)
[01:58:22] *** Quits: jeko (~jeko@2a01:e0a:25f:d8f0:4cc9:4184:da45:6beb) (Ping timeout: 260 seconds)
[02:02:53] *** Joins: Techcable (~Techcable@168.235.93.147)
[02:09:11] *** Quits: TCZ (~tcz@91.150.178.124) (Quit: Leaving)
[02:36:16] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 256 seconds)
[02:37:47] *** Joins: aeth (~aeth@user/aeth)
[02:48:00] *** Joins: jeko (~jeko@2a01:e0a:25f:d8f0:c0de:374f:b56:a49b)
[02:57:17] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 240 seconds)
[02:59:23] *** Joins: aeth (~aeth@user/aeth)
[03:06:00] *** Quits: jeko (~jeko@2a01:e0a:25f:d8f0:c0de:374f:b56:a49b) (Quit: Konversation terminated!)
[03:20:24] *** Joins: notzmv (~zmv@user/notzmv)
[03:22:45] *** Quits: alMalsamo (~alMalsamo@gateway/tor-sasl/almalsamo) (Ping timeout: 276 seconds)
[03:29:04] *** Quits: kopiyka (~user@2001:983:fe8b:1:b26e:bfff:fe2b:503f) (Remote host closed the connection)
[03:29:26] *** Joins: kopiyka (~user@2001:983:fe8b:1:b26e:bfff:fe2b:503f)
[03:33:54] *** Joins: alMalsamo (~alMalsamo@gateway/tor-sasl/almalsamo)
[05:11:02] *** Quits: epony (epony@user/epony) (Ping timeout: 240 seconds)
[05:17:07] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[05:45:36] *** Parts: pranavats (3fba1d1b34@2a00:c70:1:178:170:40:189:1) ()
[05:50:29] *** Joins: s-liao (~s-liao@101.86.96.21)
[06:13:28] *** Joins: pranavats (3fba1d1b34@2a00:c70:1:178:170:40:189:1)
[06:15:28] *** Joins: epony (epony@user/epony)
[06:18:10] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 250 seconds)
[06:19:55] *** Joins: aeth (~aeth@user/aeth)
[06:32:33] *** Quits: ZombieChicken (~weechat@user/zombiechicken) (Ping timeout: 276 seconds)
[06:51:37] *** Joins: klovett (~klovett@107.127.17.177)
[06:54:08] *** Quits: klovett_ (~klovett@107.127.17.177) (Ping timeout: 250 seconds)
[06:58:59] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[07:01:02] *** Joins: klovett_ (~klovett@107.127.17.177)
[07:03:02] *** Joins: klovett__ (~klovett@107.127.17.177)
[07:04:14] *** Joins: klovett___ (~klovett@107.127.17.177)
[07:04:52] *** Quits: klovett (~klovett@107.127.17.177) (Ping timeout: 256 seconds)
[07:05:17] *** Quits: klovett_ (~klovett@107.127.17.177) (Ping timeout: 240 seconds)
[07:07:42] *** Quits: klovett__ (~klovett@107.127.17.177) (Ping timeout: 256 seconds)
[07:12:17] *** Quits: terrorjack (~terrorjac@2a01:4f8:1c1e:509a::1) (Quit: The Lounge - https://thelounge.chat)
[07:14:28] *** Joins: terrorjack (~terrorjac@2a01:4f8:1c1e:509a::1)
[07:17:14] *** Joins: em (~em@user/emnode)
[07:25:31] *** Joins: klovett (~klovett@107.127.17.177)
[07:26:03] *** Joins: klovett_ (~klovett@107.127.17.177)
[07:27:52] *** Joins: klovett__ (~klovett@107.127.17.177)
[07:28:49] *** Joins: klovett____ (~klovett@107.127.17.177)
[07:29:14] *** Quits: klovett___ (~klovett@107.127.17.177) (Ping timeout: 256 seconds)
[07:29:48] *** Quits: klovett (~klovett@107.127.17.177) (Ping timeout: 256 seconds)
[07:29:50] *** Joins: klovett___ (~klovett@107.127.17.177)
[07:30:17] *** Quits: klovett_ (~klovett@107.127.17.177) (Ping timeout: 240 seconds)
[07:30:23] *** Joins: klovett (~klovett@107.127.17.177)
[07:31:36] *** Joins: klovett_ (~klovett@107.127.17.177)
[07:31:40] *** Quits: edmrk[m] (~edmrkmatr@2001:470:69fc:105::1:5a63) (K-Lined)
[07:31:42] *** Quits: Irvise (~irvise@2001:470:69fc:105::84c) (K-Lined)
[07:31:42] *** Quits: TomWesterhout[m] (~twesterho@2001:470:69fc:105::1:2918) (K-Lined)
[07:31:42] *** Quits: Mrtn[m] (~mrtn@2001:470:69fc:105::1f44) (K-Lined)
[07:31:42] *** Quits: nazarii[m] (~nazariim]@2001:470:69fc:105::63a) (K-Lined)
[07:31:43] *** Quits: ormaaj (~ormaaj@user/ormaaj) (K-Lined)
[07:31:43] *** Quits: magicalegg[m] (~magicaleg@2001:470:69fc:105::1:52e9) (K-Lined)
[07:31:43] *** Quits: nomagno (~nomagno@2001:470:69fc:105::c1f0) (K-Lined)
[07:31:43] *** Quits: dieggsy (~dieggsy@2001:470:69fc:105::91f) (K-Lined)
[07:31:43] *** Quits: DeeEff_ (~deeeff@user/deeeff) (K-Lined)
[07:31:43] *** Quits: saltrocklamp[m] (~hexology@user/hexology) (K-Lined)
[07:32:16] *** Quits: klovett__ (~klovett@107.127.17.177) (Ping timeout: 250 seconds)
[07:33:08] *** Quits: klovett____ (~klovett@107.127.17.177) (Ping timeout: 250 seconds)
[07:33:57] *** Quits: klovett___ (~klovett@107.127.17.177) (Ping timeout: 240 seconds)
[07:34:52] *** Quits: klovett (~klovett@107.127.17.177) (Ping timeout: 250 seconds)
[07:54:29] <ns12> Is (define quote display) allowed in Scheme?
[07:56:52] <ns12> Will it work in all standard compliant Scheme implementations?
[08:16:47] *** Joins: Irvise (~irvise@2001:470:69fc:105::84c)
[08:16:47] *** Joins: saltrocklamp[m] (~hexology@user/hexology)
[08:16:47] *** Joins: nazarii[m] (~nazariim]@2001:470:69fc:105::63a)
[08:16:47] *** Joins: magicalegg[m] (~magicaleg@2001:470:69fc:105::1:52e9)
[08:16:47] *** Joins: nomagno (~nomagno@2001:470:69fc:105::c1f0)
[08:16:47] *** Joins: edmrk[m] (~edmrkmatr@2001:470:69fc:105::1:5a63)
[08:16:47] *** Joins: dieggsy (~dieggsy@2001:470:69fc:105::91f)
[08:16:47] *** Joins: Mrtn[m] (~mrtn@2001:470:69fc:105::1f44)
[08:16:48] *** Joins: ormaaj (~ormaaj@user/ormaaj)
[08:17:00] *** Joins: TomWesterhout[m] (~twesterho@2001:470:69fc:105::1:2918)
[08:17:11] *** Quits: nomagno (~nomagno@2001:470:69fc:105::c1f0) (Quit: Client limit exceeded: 20000)
[08:17:17] *** Joins: klovett (~klovett@107.127.17.177)
[08:18:03] *** Quits: edmrk[m] (~edmrkmatr@2001:470:69fc:105::1:5a63) (Quit: Client limit exceeded: 20000)
[08:19:06] *** Quits: klovett_ (~klovett@107.127.17.177) (Ping timeout: 256 seconds)
[08:19:48] *** Quits: dieggsy (~dieggsy@2001:470:69fc:105::91f) (Quit: Client limit exceeded: 20000)
[08:20:41] *** Joins: klovett_ (~klovett@107.127.17.177)
[08:22:11] *** Quits: nazarii[m] (~nazariim]@2001:470:69fc:105::63a) (Quit: Client limit exceeded: 20000)
[08:23:50] *** Quits: klovett (~klovett@107.127.17.177) (Ping timeout: 250 seconds)
[08:28:22] *** Quits: ormaaj (~ormaaj@user/ormaaj) (Quit: Client limit exceeded: 20000)
[08:29:15] *** Quits: saltrocklamp[m] (~hexology@user/hexology) (Quit: Client limit exceeded: 20000)
[08:39:33] *** Quits: klovett_ (~klovett@107.127.17.177) (Quit: ZZZzzz‚Ä¶)
[08:48:44] *** Joins: s-liao (~s-liao@101.86.96.21)
[09:10:42] *** Quits: jao (~jao@68.235.43.172) (Remote host closed the connection)
[09:18:27] *** Joins: Everything (~Everythin@37.115.210.35)
[09:22:35] *** Quits: skapata (~Skapata@user/skapata) (Remote host closed the connection)
[09:30:46] *** Joins: jao (~jao@68.235.43.172)
[09:41:35] *** Joins: ouestbillie (~gallup@62.28.193.74)
[09:42:56] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[09:55:23] *** Quits: madage (~madage@user/madage) (Remote host closed the connection)
[09:55:38] *** Joins: madage (~madage@user/madage)
[09:59:32] *** Quits: Everything (~Everythin@37.115.210.35) (Quit: leaving)
[10:25:46] *** Quits: ouestbillie (~gallup@62.28.193.74) (Ping timeout: 245 seconds)
[10:43:25] <amazigh> ns12: yes
[10:43:39] *** Joins: edmrk[m] (~edmrkmatr@2001:470:69fc:105::1:5a63)
[10:43:39] *** Joins: DeeEff_ (~deeeff@user/deeeff)
[10:43:39] *** Joins: dieggsy (~dieggsy@2001:470:69fc:105::91f)
[10:43:39] *** Joins: ormaaj (~ormaaj@user/ormaaj)
[10:43:39] *** Joins: saltrocklamp[m] (~hexology@user/hexology)
[10:43:40] *** Joins: nazarii[m] (~nazariim]@2001:470:69fc:105::63a)
[10:43:40] *** Joins: nomagno (~nomagno@2001:470:69fc:105::c1f0)
[10:46:48] <ns12> Is that the conventional way to change the meaning of ' ?
[10:47:04] <ns12> Can I change the meaning of ( and ) and " too?
[10:48:54] *** Quits: m455 (~m455@user/m455) (Quit: WeeChat 3.0)
[10:49:12] *** Joins: m455 (~m455@user/m455)
[10:49:35] <ns12> (define quote -)  '-1  '1
[10:49:35] <ns12> Lovely.
[11:08:04] *** Quits: jao (~jao@68.235.43.172) (Remote host closed the connection)
[11:08:23] *** Quits: grettke (~grettke@cpe-65-29-228-30.wi.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[11:08:46] *** Joins: grettke (~grettke@cpe-65-29-228-30.wi.res.rr.com)
[11:18:06] *** Joins: jao (~jao@68.235.43.172)
[11:28:52] *** Quits: jao (~jao@68.235.43.172) (Remote host closed the connection)
[11:30:20] *** Joins: jao (~jao@68.235.43.172)
[11:33:39] *** Joins: jeko (~jeko@2a01:e0a:25f:d8f0:e552:2a23:8acd:a103)
[11:38:42] <amazigh> no, the meaning of parentheses can not be changed.
[11:39:15] <amazigh> I never seen the meaning of quote changed, but I have seen quasiquote being changed.
[11:39:48] <amazigh> e.g. nanopass
[11:39:53] <amazigh> e.g. nanopass framework
[11:42:27] <amazigh> re parentheses, you can change the placement of parentheses, e.g. change (let ((a b) ...) body ...) into (let (a b ...) body ...)
[11:43:00] <amazigh> syntax-rule is enough for that kind of trick
[11:44:06] *** Quits: jao (~jao@68.235.43.172) (Ping timeout: 245 seconds)
[11:48:51] <amazigh> re ", you can not change it.
[11:49:01] *** Quits: robin (~robin@user/terpri) (Remote host closed the connection)
[11:49:54] *** Joins: robin (~robin@user/terpri)
[11:51:20] <amazigh> What I have seen, is adding more literal syntax through reader macros, e.g. guix use them, see https://www.nongnu.org/guile-reader/
[11:51:36] *** Quits: Fare (~fare@pool-72-94-152-64.phlapa.fios.verizon.net) (Ping timeout: 256 seconds)
[11:52:10] <amazigh> an example might be a literal syntax for sets, such as #set(abc 42 "hello ns12") 
[11:52:45] <amazigh> it requires specialized tooling in the reader, not a lot of scheme support it.
[11:53:35] <amazigh> and fwiw, more literal syntax (for set, dict, and whatnot) confuse me.
[11:54:46] <amazigh> clojure is an example lisp that has support for more data types literal than standard Scheme. See what is called EDN.
[11:56:31] <Andrew> Isn't clojure more for common lisp than scheme, or did I remember wrong?
[11:56:34] <Andrew> s/for/like/
[11:57:04] <amazigh> the creator of clojure comes from CL community, but clojure is a LISP-1 like Scheme.
[12:07:57] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 276 seconds)
[12:19:41] *** Quits: magicalegg[m] (~magicaleg@2001:470:69fc:105::1:52e9) (Quit: Client limit exceeded: 20000)
[12:19:57] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 240 seconds)
[12:21:49] *** Parts: aoh__ (~aki@haltp.org) ()
[12:22:06] *** Joins: aeth (~aeth@user/aeth)
[12:22:37] *** Joins: aoh (~aki@haltp.org)
[13:11:57] *** Quits: jeko (~jeko@2a01:e0a:25f:d8f0:e552:2a23:8acd:a103) (Ping timeout: 240 seconds)
[13:23:55] *** Joins: s-liao (~s-liao@101.86.96.21)
[13:31:50] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 260 seconds)
[13:33:47] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[13:50:55] <Franciman> i think it also favours minimalism
[13:50:55] *** Joins: magicalegg[m] (~magicaleg@2001:470:69fc:105::1:52e9)
[13:50:57] <Franciman> like scheme
[13:51:02] <Franciman> rather than maximalism like CL?
[14:32:53] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[14:37:18] *** Joins: s-liao (~s-liao@101.86.96.21)
[14:57:29] *** Joins: frost (~frost@user/frost)
[15:02:21] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[15:05:41] <edgar-rft> CL prefers CAPITALISM :-)
[15:12:37] *** Joins: s-liao (~s-liao@101.86.96.21)
[15:17:54] *** Parts: pranavats (3fba1d1b34@2a00:c70:1:178:170:40:189:1) ()
[15:19:50] *** Quits: zwr (~zwr@2804:d45:b966:fb00:d3a7:44f8:3616:d9d) (Ping timeout: 250 seconds)
[15:27:03] *** Quits: flyke (~flyke@user/flyke) (Remote host closed the connection)
[15:32:40] <wasamasa> lol
[15:32:54] <wasamasa> have you looked at clojure's standard library?
[15:33:14] <wasamasa> did you know it's written by a former CL programmer?
[15:34:12] <wasamasa> it sits somewhere between
[15:36:31] <Franciman> do you prefer scheme or clojure design?
[15:36:53] <Franciman> i mean scheme i don't think it has strong tradition, while clojure kind of enforces the ideas of its dictator for benevolent life
[15:49:27] *** Quits: frost (~frost@user/frost) (Quit: Connection closed)
[15:50:18] <wasamasa> hm
[15:50:22] <wasamasa> I kind of want both really
[15:50:54] <wasamasa> scheme APIs strike me as over-engineered at times
[15:51:07] <wasamasa> but I like that the core language is pretty small
[15:51:29] <wasamasa> whereas clojure has lots of conveniences and extra data types
[15:51:43] <ns12> wasamasa: "scheme APIs strike me as over-engineered at times" - e.g. syntax-rules which is unable to express some things?
[15:51:55] <wasamasa> I mean loads of R7RS-large SRFIs
[15:52:15] <wasamasa> if I have the choice between the mappings API and clojure maps, I'll take clojure maps any time
[15:53:19] <ns12> I wanted to ask: does Scheme require garbage collection?
[15:53:23] <wasamasa> lol
[15:53:44] <Franciman> ns12: r7rs small says that data are required to be in memory 
[15:53:53] <Franciman> but can be removed when the runtime can prove that the data is not needed
[15:54:01] <Franciman> so it's not strictly required
[15:54:32] <Franciman> no wait, i think it is
[15:55:48] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Quit: WeeChat 3.4)
[15:57:46] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[15:57:53] <ns12> Franciman: Section 1.1 says: "[Scheme implementations] are permitted to reclaim the storage occupied by an object if they can prove that the object
[15:57:53] <ns12> cannot possibly matter to any future computation".
[15:58:19] *** Joins: jeko (~jeko@2a01:e0a:25f:d8f0:41b7:8b4:70e:df01)
[15:58:34] <ns12> I think garbage collection is an optional feature in Scheme.
[15:59:17] <Franciman> ah are permitted
[15:59:19] <Franciman> then yes
[15:59:22] <Franciman> it is not required
[15:59:28] <Franciman> it is optional
[15:59:43] <Franciman> but you can't have manual memory management, imho
[16:01:47] <ns12> Why not? It could be implemented in a library that implements the Scheme equivalent of "malloc" and "free".
[16:01:51] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 250 seconds)
[16:01:56] <Franciman> because you can get memory errors
[16:02:03] <Franciman> like use after free
[16:02:21] <ns12> Are memory errors forbidden by R7RS-small?
[16:02:28] <Franciman> so you would go against ¬´yo uare permitted to reclaim the storage occupied by an object if you can prove that the object cannot possibly matter to any future computation¬ª
[16:02:36] <Franciman> if you allow a free function
[16:02:47] <Franciman> you should only allow it when the user can prove that it can be used
[16:03:24] <Franciman> hm but it speaks about scheme implementations
[16:03:28] <Franciman> so uhm no idea :D
[16:04:04] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[16:05:03] <Franciman> i mean, ns12 suppose you expose a free function
[16:05:09] <ns12> It says "permitted to reclaim the storage occupied by an object if they can prove that the object cannot possibly matter to any future computation". Note that it says "if", but not "iff". Therefore, "free" is permitted to reclaim storage.
[16:05:36] <Franciman> so you mean that
[16:05:47] <Franciman> if you can prove the object is not needed, you can reclaim storage
[16:05:57] <Franciman> but you can reclaim it in other situations too?
[16:06:09] <ns12> Yes. That's how I read it.
[16:06:34] <ns12> I don't know if that is the intention of the authors, however.
[16:06:48] <Franciman> wait
[16:06:55] <ns12> I am probably speaking nonsense.
[16:06:56] <Franciman> ns12: i think you can't have a free function because the standard says
[16:07:13] <Franciman> All objects created in the course of a Scheme computation,
[16:07:15] <Franciman> including procedures and continuations, have unlimited ex-
[16:07:17] <Franciman> tent. No Scheme object is ever destroyed. The reason that
[16:07:19] <Franciman> implementations of Scheme do not (usually!) run out of
[16:07:24] <Franciman> so, no object is ever destroyed
[16:07:28] <Franciman> while a free would destroy the object
[16:07:38] <Franciman> i mean a reasonable free would
[16:07:40] <Franciman> :D
[16:07:59] <Franciman> you could have a free function that gives hints to a more complex garbage collection system, tho
[16:08:36] <ns12> So, if "free" is not allowed, then what is the use of making garbage collection an optional part of Scheme? Why not just say: "Garbage collection must be implemented"?
[16:08:49] <Franciman> it's my opinion, ns12 
[16:08:55] <Franciman> and uhm
[16:09:00] <Franciman> i think you can have no garbage collection
[16:09:09] <Franciman> and this is useful when you guarantee your program doesn't allocate more than X memory
[16:09:16] <Franciman> so to have fast speed
[16:09:29] <Franciman> like in embedded systems
[16:11:53] <ns12> wasamasa: Why "lol"? ü§î
[16:13:04] <wasamasa> there are different styles of garbage collection
[16:13:36] <wasamasa> like the style of not doing garbage collection because you have a program that does a very short task and quits immediately
[16:13:51] <wasamasa> but I don't think I've ever seen a scheme implementation punting on garbage collection
[16:16:36] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 250 seconds)
[16:16:40] <Franciman> wasamasa: can you have manual memory management?
[16:16:43] <ns12> Can a Scheme implementation have manual garbage collection, where explicit calls to (garbage-collect) is required to collect garbage?
[16:17:12] <wasamasa> it's hardly manual memory management if the memory is allocated automatically for you
[16:17:23] <wasamasa> calling garbage-collect periodically, wow
[16:17:25] <wasamasa> very advanced
[16:17:49] <wasamasa> if you have automatic allocation, it's trivial to invoke a garbage-collect procedure during that when exceeding limits
[16:18:07] <wasamasa> now, what would make more sense is to temporarily inhibit garbage collection
[16:35:27] <ns12> Is there a portable API to temporarily inhibit garbage collection, or to force garbage collection?
[16:35:53] <wasamasa> did you just volunteer to write yet another SRFI the world doesn't need?
[16:36:35] <Franciman> lol come on
[16:36:43] <Franciman> ns12: do you have a specific case in mind where you need it?
[16:38:24] <ns12> wasamasa: Is this something that's not really needed? I mean, some Common Lisp implementations have such functionality.
[16:38:37] <ns12> Also, https://github.com/trivial-garbage/trivial-garbage for Common Lisp.
[16:39:07] <wasamasa> go on, name me common usecases where this is actually needed
[16:39:37] <ns12> None that I can think of.
[16:39:41] <wasamasa> QED
[16:40:17] <wasamasa> the few schemes catering to these usecases can have a not portable implementation of the pattern and that's fine really
[16:40:22] <ns12> Then, I wonder why some implementations bother to provide a garbage collection API.
[16:41:07] <ns12> Okay.
[16:43:51] <ns12> amazigh: "I never seen the meaning of quote changed, but I have seen quasiquote being changed." - Why did they change the meaning of quasiquote?
[16:45:49] *** Quits: jeko (~jeko@2a01:e0a:25f:d8f0:41b7:8b4:70e:df01) (Ping timeout: 250 seconds)
[17:03:07] <amazigh> ns12: good question! 
[17:05:27] <amazigh> They changed quasiquote, somewhat to change the semantic of parentheses, for instance `(let ((,a ,(b)) ...) ,(body) ...) will recurse the current pass the expression b.
[17:05:36] <amazigh> e.g. https://github.com/akeep/scheme-to-c/blob/main/c.ss#L2585 with le*
[17:06:14] <amazigh> the pass called lift lambda will recurse into le* before execution inside the current expression
[17:07:30] <amazigh> basically nanopass framework is a `match` / `matchable` on steroids, with the de facto standard for match looks like (match e ((pattern expression)) ...)
[17:08:04] <amazigh> in nanopass, inside expression, quasiquote is also rebound to produce records instead of mere symbols, record associated with the production language
[17:09:49] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 240 seconds)
[17:09:55] <amazigh> regular match, the expression main contain a quasiquote, to construct the output expression, but that quasiquote produce an "untyped" ast that is made of regular symbols
[17:10:46] <dpk> wasamasa: real-time applications where GC pauses are undesirable while a time-critical operation is happening
[17:11:00] <amazigh> with nanopass, quasiquote will specify what expression to build using symbols, but what is returned are more than symbols, and the literal symbol is associated with record with the same record name as the symbol used in the quasiquote
[17:11:06] <dpk> it can be useful to defer to a moment where you know you can spare a millisecond or two
[17:11:16] <wasamasa> alright, but scheme for that, really
[17:12:07] <wasamasa> I don't expect a general-purpose programming language to fulfill these requirements at all
[17:12:15] <wasamasa> a special-purpose implementation of it, perhaps
[17:12:26] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[17:12:29] <dpk> also applications where you'd rather just run out of memory than keep trying an operation endlessly
[17:12:37] <wasamasa> what
[17:12:54] <dpk> (see ITA Software's dastardly trick with their CONS! function to emulate that in Common Lisp)
[17:13:21] <amazigh> ns12: chez scheme has an api to disable gc, and force gc.
[17:15:52] <amazigh> recently, they added the ability to disable gc for ffi calls that are blocking that is opt-in
[17:16:35] <amazigh> ... disable gc just for the thread that is running the blockign ffi call, basically, gc will execute but exclude the thread where the ffi blocking call is happening.
[17:19:04] *** Joins: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net)
[17:22:53] *** Joins: klovett (~klovett@107.127.17.177)
[17:33:30] <ns12> dpk: "see ITA Software's dastardly trick with their CONS! function" - Where can I read more about this? Is the source code publicly available?
[17:34:54] <dpk> to avoid actual memory allocation and limit memory (and, de facto, time) use during a flight search, they pre-allocated an array of like 100,000 pairs before starting a search. CONS! pulled a 'fresh' cons pair out of that array; if it reached the end of the array, it gave up with the search
[17:35:15] <dpk> http://www.paulgraham.com/carl.html
[17:35:33] <dpk> (oh, actually 10,000,000 cells)
[18:01:54] *** Joins: s-liao (~s-liao@101.86.96.21)
[18:11:57] *** Quits: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net) (Ping timeout: 240 seconds)
[18:14:16] <wasamasa> what's a few cells among friends
[18:21:24] *** Quits: psf (~pi@206.55.172.18) (Ping timeout: 250 seconds)
[18:21:37] *** Joins: psf (~pi@206.55.172.18)
[18:21:45] *** Joins: Fare (~fare@pool-72-94-152-64.phlapa.fios.verizon.net)
[18:22:04] *** Joins: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net)
[18:23:38] *** Joins: Rue (~rue@2001-b011-1000-11b6-9802-64fa-1e5c-3e4d.dynamic-ip6.hinet.net)
[18:52:26] <Oxyd> Assuming a 32-bit architecture where a cons cell is 8 bytes, that's like 76 MB.
[18:56:23] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[19:13:42] *** Quits: alMalsamo (~alMalsamo@gateway/tor-sasl/almalsamo) (Ping timeout: 276 seconds)
[19:20:09] *** Joins: alMalsamo (~alMalsamo@gateway/tor-sasl/almalsamo)
[19:21:33] *** Joins: notzmv (~zmv@user/notzmv)
[19:34:00] *** Quits: Fare (~fare@pool-72-94-152-64.phlapa.fios.verizon.net) (Ping timeout: 256 seconds)
[19:36:36] *** Joins: zwr (~zwr@2804:d45:b966:fb00:9fc4:4e83:5c60:86bb)
[19:48:17] *** Quits: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net) (Ping timeout: 240 seconds)
[19:59:37] *** Joins: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net)
[20:05:49] *** Quits: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net) (Ping timeout: 250 seconds)
[20:28:17] *** Joins: flyke (~flyke@user/flyke)
[20:33:06] *** Joins: jao (~jao@68.235.43.84)
[20:34:19] *** Joins: Fare (~fare@pool-72-94-152-64.phlapa.fios.verizon.net)
[20:44:05] *** Joins: civodul (~user@guix/contributor/civodul)
[20:51:04] *** Joins: skapata (~Skapata@2804:14c:87b0:9d2e:a9ca:f4c8:c996:a5a2)
[20:51:04] *** Quits: skapata (~Skapata@2804:14c:87b0:9d2e:a9ca:f4c8:c996:a5a2) (Changing host)
[20:51:04] *** Joins: skapata (~Skapata@user/skapata)
[20:57:52] *** Quits: klovett (~klovett@107.127.17.177) (Ping timeout: 256 seconds)
[20:59:13] *** Joins: klovett (~klovett@107.127.17.177)
[20:59:38] *** Joins: pranavats (3fba1d1b34@2a00:c70:1:178:170:40:189:1)
[21:19:56] *** Joins: shawnw (~shawn_w@152.44.212.188)
[21:22:43] <mdhughes> tinyscheme makes you do manual gc calls. If you don't, it doesn't run (at least not before exhausting memory).
[21:23:17] <mdhughes> Which is perfect for a small, embedded system: Consume memory to some predetermined limit, exit, OS reclaims memory.
[21:25:28] <em> hm.
[21:31:20] <Franciman> mdhughes: but our question is, is it r5rs compliant?
[21:31:28] <Franciman> ah sure
[21:31:33] <Franciman> because you just ask the gc to run
[21:31:38] <Franciman> you don't explicitly tell what to free
[21:50:12] *** Joins: klovett_ (~klovett@107.127.17.177)
[21:51:15] <mdhughes> Well, tinyscheme's more R4RS and probably not completely that.
[21:51:18] <Zipheir> Hmm, TIL.  I guess I've never used the TinyScheme REPL enough for it to run out of space.
[21:53:00] <mdhughes> But there's no reason why a standard Scheme couldn't do the same. All the spec seems to me to require is that you don't *have* to manually track & release each object.
[21:53:18] *** Quits: klovett (~klovett@107.127.17.177) (Ping timeout: 250 seconds)
[21:53:32] <mdhughes> I think (but am tired, not gonna read code) the REPL calls gc each loop. Scripts don't.
[21:53:47] <Zipheir> Aha.
[21:54:23] <Zipheir> It's still used in GIMP, which is kind of remarkable.
[21:58:10] <sham1> Manual GC does make sense in more real-time-y applications, but I don't really understand why The GIMP would do that
[22:10:22] <Zipheir> All I can say is that it's the strangest embedding of a language into a program I've ever seen.
[22:11:05] <Zipheir> GIMP Scheme programming looks very much like Python, and I suspect they'll eventually replace TinyScheme with that.
[22:11:30] <sham1> The various GNU projects have moved away from using Guile
[22:11:42] <Zipheir> Unfortunate.
[22:11:58] <sham1> It was (and probably still technically is) the official scripting language of the GNU project. But, well‚Ä¶ Python and in the case of GNOME, JavaScript
[22:12:55] <Zipheir> (This is standard GIMP style: (let ((foo #f) (bar #f)) (set! foo some-actual-value) (set! bar some-other-value)) )
[22:14:26] <sham1> That's just let*
[22:14:51] <sham1> Or maybe letrec
[22:15:06] <Oxyd> letrec*
[22:15:07] <Zipheir> Well, sort of.  The point is that they state that "declaring variables" is good style.
[22:15:32] <Oxyd> And at that point, extending let syntax to support (let (foo bar) ‚Ä¶) would probably make sense instead of requiring (foo #f) every time.
[22:15:33] <Zipheir> I don't understand that idea in Scheme.
[22:15:57] <sham1> Yeah, the let form is specifically for declaring variables and giving them default values
[22:16:27] <sham1> And yeah, if they wanted to do that, they'd probably be better off supporting (let (foo bar) (set! foo some-actual-value) (set! bar some-other-value))
[22:17:26] <Zipheir> The bigger challenge is that most uses of embedded "scripting" Scheme make almost no use of the real strengths of the language: expressions.  Most scripting interfaces are just globally-mutative statements, so I understand why people lean toward imperative-flavored languages.
[22:17:30] <dpk> hmm, Chibi's writer outputs symbols containing U+00B5 ¬µ inside pipes, which afaik it usually only does for symbols whose names are not technically allowed outside of pipes in R7RS but which Chibi's reader nonetheless accepts. is it actually not allowed or is this just a weirdness?
[22:18:07] *** Quits: Irvise (~irvise@2001:470:69fc:105::84c) (Quit: Bridge terminating on SIGTERM)
[22:18:08] *** Quits: Mrtn[m] (~mrtn@2001:470:69fc:105::1f44) (Quit: Bridge terminating on SIGTERM)
[22:18:08] <sham1> Pipes? You mean just UNIX pipes or something else
[22:18:10] *** Quits: TomWesterhout[m] (~twesterho@2001:470:69fc:105::1:2918) (Quit: Bridge terminating on SIGTERM)
[22:18:11] *** Quits: nomagno (~nomagno@2001:470:69fc:105::c1f0) (Quit: Bridge terminating on SIGTERM)
[22:18:11] *** Quits: edmrk[m] (~edmrkmatr@2001:470:69fc:105::1:5a63) (Quit: Bridge terminating on SIGTERM)
[22:18:11] *** Quits: dieggsy (~dieggsy@2001:470:69fc:105::91f) (Quit: Bridge terminating on SIGTERM)
[22:18:12] *** Quits: nazarii[m] (~nazariim]@2001:470:69fc:105::63a) (Quit: Bridge terminating on SIGTERM)
[22:18:12] *** Quits: ormaaj (~ormaaj@user/ormaaj) (Quit: Bridge terminating on SIGTERM)
[22:18:12] *** Quits: saltrocklamp[m] (~hexology@user/hexology) (Quit: Bridge terminating on SIGTERM)
[22:18:12] *** Quits: magicalegg[m] (~magicaleg@2001:470:69fc:105::1:52e9) (Quit: Bridge terminating on SIGTERM)
[22:18:12] *** Quits: DeeEff_ (~deeeff@user/deeeff) (Quit: Bridge terminating on SIGTERM)
[22:18:21] <dpk> i mean as |¬µ| and not just bare ¬µ
[22:18:22] <Zipheir> Oof, goodbye, Matrix bot.
[22:18:25] <sham1> Ah
[22:18:32] <dpk> oh. it does the same with Œª. i guess it just doesn't like Unicode
[22:18:42] * dpk continues writing code with ¬µ in identifier names
[22:18:52] <sham1> Wait, |¬µ| isn't the same symbol as ¬µ?
[22:18:57] <dpk> doch
[22:20:18] <Oxyd> R7RS says about the write procedure: ‚ÄúSymbols that contain non-ASCII characters are escaped with vertical lines.‚Äù
[22:20:25] <dpk> oh, interesting
[22:20:27] <dpk> also: annoying
[22:21:45] *** Joins: DeeEff_ (~deeeff@user/deeeff)
[22:22:59] <Oxyd> Questionable. I'd see the value if it also required that such symbols also use the \xNN; notation to make them representable in ASCII. But requiring just pipes but not the hex notation is just silly.
[22:23:00] *** Joins: Irvise (~irvise@2001:470:69fc:105::84c)
[22:23:00] *** Joins: edmrk[m] (~edmrkmatr@2001:470:69fc:105::1:5a63)
[22:23:00] *** Joins: Mrtn[m] (~mrtn@2001:470:69fc:105::1f44)
[22:23:14] *** Joins: dieggsy (~dieggsy@2001:470:69fc:105::91f)
[22:23:14] *** Joins: ormaaj (~ormaaj@user/ormaaj)
[22:23:14] *** Joins: saltrocklamp[m] (~hexology@user/hexology)
[22:23:29] *** Joins: nazarii[m] (~nazariim]@2001:470:69fc:105::63a)
[22:23:29] *** Joins: nomagno (~nomagno@2001:470:69fc:105::c1f0)
[22:23:42] *** Joins: magicalegg[m] (~magicaleg@2001:470:69fc:105::1:52e9)
[22:23:48] <Oxyd> Also, it doesn't say anything about symbols with spaces in them.
[22:23:54] *** Joins: TomWesterhout[m] (~twesterho@2001:470:69fc:105::1:2918)
[22:24:54] <Oxyd> So unless there's something else in R7RS prohibiting this, in a compliant implementation (write '|foo bar|) could produce "foo bar".
[22:25:47] <sham1> Well the difference in that is that "foo bar" cannot be read the same way as |foo bar|
[22:25:49] <dpk> hmm, indeed
[22:26:25] <sham1> Meanwhile a compatible implementation shouldn't have problem reading both ¬µ and |¬µ|
[22:26:45] <sham1> As the same symbol even
[22:26:50] <dpk> yes, but it's not actually an explicit requirement that reading the output of write will produce a datum which, for example, is equal? to the original under any circumstances
[22:27:51] <sham1> Well to be fair, what would it read then. A normalized version of the symbol according to some unicode normalisation
[22:28:11] <sham1> No reason to differentiate between the two even if one can
[22:28:52] *** Joins: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net)
[22:42:51] <Zipheir> Was that an R7 addition?  I can't find a similar requirement in R6, though I didn't search very carefully.
[22:44:40] *** Joins: silasfox (~sbv@p54bc2d93.dip0.t-ipconnect.de)
[22:44:40] *** Quits: silasfox (~sbv@p54bc2d93.dip0.t-ipconnect.de) (Client Quit)
[22:46:38] *** Quits: Mrtn[m] (~mrtn@2001:470:69fc:105::1f44) (Quit: Client limit exceeded: 20000)
[22:46:40] *** Quits: ormaaj (~ormaaj@user/ormaaj) (Quit: Client limit exceeded: 20000)
[22:47:20] *** Quits: DeeEff_ (~deeeff@user/deeeff) (Quit: Client limit exceeded: 20000)
[22:48:58] *** Quits: saltrocklamp[m] (~hexology@user/hexology) (Quit: Client limit exceeded: 20000)
[22:49:22] *** Quits: nomagno (~nomagno@2001:470:69fc:105::c1f0) (Quit: Client limit exceeded: 20000)
[22:49:55] <Franciman> fortunately r7rs small doesn't oblige me to deal with unicode
[22:50:24] *** Joins: DeeEff_ (~deeeff@user/deeeff)
[22:50:31] *** Quits: edmrk[m] (~edmrkmatr@2001:470:69fc:105::1:5a63) (Quit: Client limit exceeded: 20000)
[22:50:43] *** Joins: Mrtn[m] (~mrtn@2001:470:69fc:105::1f44)
[22:50:43] *** Joins: ormaaj (~ormaaj@user/ormaaj)
[22:50:44] *** Joins: saltrocklamp[m] (~hexology@user/hexology)
[22:51:13] *** Joins: nomagno (~nomagno@2001:470:69fc:105::c1f0)
[22:55:42] *** Quits: dieggsy (~dieggsy@2001:470:69fc:105::91f) (Quit: Client limit exceeded: 20000)
[22:55:44] <aeth> not dealing with Unicode (even though the host PLTScheme/Racket could afaik handle it) killed Arc on arrival and that was over a decade ago
[22:55:44] *** Joins: edmrk[m] (~edmrkmatr@2001:470:69fc:105::1:5a63)
[22:55:58] *** Joins: dieggsy (~dieggsy@2001:470:69fc:105::91f)
[22:55:58] <aeth> It had other problems, but Unicode was definitely the main one.
[22:56:00] <Franciman> arc?
[22:56:12] *** Quits: nazarii[m] (~nazariim]@2001:470:69fc:105::63a) (Quit: Client limit exceeded: 20000)
[22:56:28] <aeth> Paul Graham was a famous Common Lisp author of the late '90s and early '00s and then he mostly went silent for a few years after hyping up his new Lisp. It disappointed.
[22:56:47] *** Joins: nazarii[m] (~nazariim]@2001:470:69fc:105::63a)
[22:56:48] *** Quits: magicalegg[m] (~magicaleg@2001:470:69fc:105::1:52e9) (Quit: Client limit exceeded: 20000)
[22:56:50] <aeth> people were expecting "The Hundred‚ÄîYear Language". http://paulgraham.com/hundred.html
[22:56:53] <mdhughes> What was the next one, Bar? Also don't recall it supporting Unicode.
[22:56:56] <aeth> It's a good lesson in overpromising and underdelivering
[22:57:01] <aeth> Bel, apparently
[22:57:01] *** Joins: magicalegg[m] (~magicaleg@2001:470:69fc:105::1:52e9)
[22:57:12] <aeth> at least, based on the sidebar of that article ("Bel" is under "Arc")
[22:57:16] *** Quits: TomWesterhout[m] (~twesterho@2001:470:69fc:105::1:2918) (Quit: Client limit exceeded: 20000)
[22:57:31] *** Joins: TomWesterhout[m] (~twesterho@2001:470:69fc:105::1:2918)
[22:57:44] <mdhughes> Right. Maybe the next one can be Car.
[22:59:06] <aeth> January 2008, 14 years ago, back when Reddit was still a tech/news website like Slashdot or Digg instead of a meme site. https://old.reddit.com/r/programming/comments/6710p/arcs_out/
[22:59:13] <aeth> If you want to read the disappointment on launch
[22:59:40] <aeth> Technically, it's not a Scheme, it was just built on Scheme using a strange mix of Perl (already on its way out), Common Lisp, and Scheme as its inspiration.
[23:00:13] <aeth> Just extending r5rs (if it was even out back then) probably would've seen it get some adoption
[23:00:49] <mdhughes> I think not enough consideration has been given to supporting EBCDIC
[23:03:19] <aeth> Anyway, the main reason I don't call Airship Scheme The Thousand‚ÄîYear Language (even though it will be) is because of Arc. It's way easier to write prose that's good enough to convince some people of the hype than it is to follow through on it.
[23:04:56] <aeth> Here are the steps by which I will make Airship Scheme The Thousand‚ÄîYear Language: (1) Make Airship Scheme, (2) ???, (3) Acquire several hundred billion dollars, (4) buy IBM, (5) put Airship Scheme on every bank mainframe
[23:05:43] <drakonis> ha
[23:05:58] <drakonis> arc.
[23:06:15] * dpk grumbles about her (chibi parse) parser which is pretending like it's got left recursion (one rule is diverging on all input) but has no idea why
[23:06:15] <sham1> Automatic reference counting. What else
[23:06:18] <drakonis> its really funny how pg stated that he thought of arc as a cl competitor
[23:07:18] <drakonis> in hindsight, it is very funny.
[23:08:17] <aeth> drakonis: as opposed to Linux, which was announced as: "Hello everybody out there using minix - I'm doing a (free) operating system (just a hobby, won't be big and professional like gnu) for 386(486) AT clones,"
[23:08:27] <drakonis> yes.
[23:08:28] <mdhughes> I will say, pg's hubris makes me want to either dust off my ObjC Lispy interpreter, or write a proper one the SICP way. Because I'm at least that good, just not a VC.
[23:09:27] <mdhughes> Practically, there's no reason for there to be another Scheme after Chez. But egomaniacally, sure!
[23:09:35] <drakonis> to be fair
[23:09:46] <drakonis> chez's code is kind of inscrutable
[23:09:54] <dpk> hmm, i wonder if this is a (chibi parse) bug. it only diverges if the rule is wrapped in the * operator¬†‚Ä¶
[23:09:57] <Zipheir> aeth: Such hubris!
[23:10:02] <drakonis> its the fastest scheme right now
[23:10:15] <mdhughes> But it's *fast*! And seems correct. Maybe good things are hard to read.
[23:10:29] <aeth> I need to write a book called Hackers & Pianists because I can kind of sort of play the piano again after needing to do something that involves 0 screens after the pandemic started.
[23:10:40] <aeth> (pg wrote a book called Hackers & Painters)
[23:11:04] <mdhughes> > It's not so much "Paul Grahams all the way down", so much as a "thin layer of Paul Graham." 
[23:11:06] <mdhughes> LOL
[23:11:12] <mdhughes> (from the reddit thread)
[23:11:14] *** Quits: Rue (~rue@2001-b011-1000-11b6-9802-64fa-1e5c-3e4d.dynamic-ip6.hinet.net) (Quit: WeeChat 3.4)
[23:11:21] <drakonis> why no cl in scheme tho?
[23:11:22] <Zipheir> A delicious Paul Graham crust.
[23:12:12] <aeth> drakonis: easier to write Scheme in CL than CL in Scheme because CL is a larger language, specifying things like an OOP system and an exception system (well, they call them conditions because they're more general than exceptions)
[23:12:24] <sham1> Being an egomaniac seems to follow programming people
[23:12:39] <aeth> drakonis: Obviously, you can write any language in any other language, but at some point, if they're too incompatible, you're probably just writing an interpreter or compiler and interfacing with the implementation language will be hard
[23:12:59] <aeth> You could write CL in Scheme without incompatibilities if you first wrote the Scheme with CL compatibility in mind but at that point...
[23:13:03] <drakonis> that is true.
[23:13:34] <drakonis> then there's always cultural impedance/mismatch
[23:15:26] <aeth> e.g. CL-in-Scheme: here's an entire OOP system that's similar to the host OOP system, but just incompatible enough that it has to be implemented from scratch in a way that can't cleanly interface with the host OOP system (if it exists, anyway... Schemes don't guarantee that)
[23:15:41] <aeth> vs Scheme-in-CL: want OOP? OK, let's figure out how to wrap CLOS in a Schemey way...
[23:16:03] <drakonis> hm, alright.
[23:16:34] <aeth> since Schemers will be fine with their OOP not being portable, but if your CL OOP is incompatible, then CL libraries just won't run
[23:17:43] <sham1> One can always try to implement CLOS on scheme, but it'd get just about everywhere
[23:19:17] <drakonis> it has already been done in the past, hasnt it?
[23:20:11] <sham1> Yes it has, there are some CLOS clones that are more or less standalone libraries, and Guile for example has GOOPS
[23:20:26] <aeth> most Scheme OOP is inspired by CLOS, but if they're not entirely compatible, you probably wouldn't be able to use it to implement CLOS and expect CL libraries to run, unless they use a very flexible MOP
[23:20:40] <aeth> it'd be like expecting C++ to run in Java or vice versa
[23:20:57] <drakonis> i'm not suggesting such a thing.
[23:22:31] <drakonis> but i agree that there shouldn't be an expectations that it'll be fully supported
[23:22:35] <sham1> Well yeah, it's not totally compatible but it could be
[23:22:40] <sham1> And yeah
[23:23:50] <mdhughes> Which is why you should implement Scheme and just stop. All the other stuff you can just add from srfi.
[23:24:07] <aeth> right
[23:24:15] <aeth> Just implement Scheme, starting from CL
[23:24:16] <mdhughes> OOP? All you need is (define (make-obj) (let [(data '())] (lambda (msg . rest) (case msg [(hi) (display "Hi!\n")] [else (error 'obj "ERROR" msg)]))) )
[23:24:43] <sham1> Can't make Smalltalk into a thing
[23:25:45] <drakonis> scheme needs more libraries, that's what
[23:25:55] <Zipheir> Scheme has lots of libraries.
[23:26:13] <Zipheir> Pre-R7RS-large Scheme has few standard-ish libraries.
[23:26:31] <mdhughes> > sheesh not another fucking computer language  (also from reddit)
[23:26:40] <drakonis> thanks reddit.
[23:26:52] <sham1> There needs to be a Scheme first instead of a bunch of mutually semi-intelligible dialects
[23:27:10] <Franciman> r7rs 
[23:27:12] <aeth> that's what makes #scheme an interesting channel
[23:27:14] <Franciman> large and small
[23:27:15] <drakonis> maybe with r7rs-large that could be done
[23:27:24] <sham1> I certainly hope so
[23:27:48] <aeth> half of #scheme writes portable Scheme and wants portable Scheme libraries; half of #scheme writes Scheme implementations and is actively working against the other group by writing non-portable implementation-specific code
[23:28:13] <drakonis> it is the polar opposite of CL in a way
[23:28:53] <flyke> > There needs to be a Scheme first instead of a bunch of mutually semi-intelligible dialects
[23:29:11] <drakonis> my opinions about CL are like a swinging pendulum
[23:29:26] <flyke> that is what hindered scheme acceptance outside of the academic circle.
[23:29:37] <aeth> If I wrote portable-first Scheme, I probably wouldn't write any Scheme at all.
[23:29:47] <drakonis> on one hand, its great that it has so many libraries with interop, on the other, there's a lot of clunky remnants from interop with existing lisp dialects at the time of inception
[23:29:50] <aeth> On the other hand, if I wrote unportable CL, I'd instantly get disowned by the entire CL community
[23:30:10] <flyke> it's impractical, too many dialects with differents (often wild) levels of mutually intelligibility
[23:30:14] <Zipheir> flyke: I really doubt that.  I think it's more the Lisp Winter that hit somewhere in the '90s.
[23:30:43] <sham1> While also lacking things like tail recs (somewhat understandable at the time, but still irritating) and stuff like support for \n and such without using custom readtable things
[23:30:52] <mdhughes> My view is 0 tinyscheme      5 r5rs,r7rs-small  6 r6rs  9 r7rs-large 10 CL   And I want something around 6 or even 5.5, sure as hell not 9 or 10.
[23:31:04] <Zipheir> There was never anything stopping a company from adopting one implementation and going with it.  It's just that Lisp got unfashionable.
[23:31:10] <aeth> If I wanted to poorly and inefficiently use a minimalist language to write a bunch of things that should be provided by the standard library, I'd write Lua :-p
[23:31:32] <sham1> Lua is actually very nice
[23:31:33] <drakonis> r7rs-large is probably going to be larger than CL
[23:31:39] <drakonis> with the way things are going
[23:31:43] <flyke> it's a new standard?
[23:31:50] <sham1> And of course Lua has one of the best JIT implementations around
[23:31:51] <drakonis> its going to be a very good draw
[23:31:58] <Zipheir> drakonis: Yes, jcowan has said that; iff everything is voted in.
[23:32:09] <Zipheir> And, the way things are going, *most* things get voted in.
[23:32:11] <drakonis> i'd appreciate that.
[23:32:14] <mdhughes> Yeah, I would score it an 11 on size, but at least the core isn't as bad as CL. There is an escape, which is using r7rs-small and adding some libraries.
[23:32:33] <flyke> I feel like each new standard is corrupting the language more from its philosophy of minimalism
[23:32:39] <drakonis> the core is still there
[23:32:41] <mdhughes> There is no escape when you're in CL. Type sbcl and 10 minutes later you can run qlisp and an hour later you can do something.
[23:32:46] <sham1> R7 large will also have the advantage that the standard is actually available for everyone without paying a ridiculous sum of money
[23:32:46] <Zipheir> flyke: There's always Œª-calculus.
[23:32:53] <aeth> drakonis: r7rs-large would be larger in some ways, but not in others. It's probably politically impossible to get OOP, a fully-specified conditions (exceptions) system (to be fair, CL doesn't always specify what error to throw so that's sometimes non-portable), a CFFI (technically not part of the CL standard, but de facto), etc.
[23:33:11] <aeth> drakonis: while a lot of the things that r7rs-large can pass are things that could easily be written as libraries
[23:33:12] <drakonis> all the standard does is specify is a bigger baseline
[23:33:33] <drakonis> guile already has OOP, conditions and CFFI
[23:33:41] <drakonis> its almost CL at this point
[23:33:52] <Zipheir> flyke: Libraries are easy to add or remove; I'd say they don't really complicate a language.  Adding sytax is similarly modular for Scheme.
[23:33:56] <drakonis> from the available schemes
[23:33:57] <Zipheir> *syntax
[23:34:17] <Zipheir> And, unlike with R6, subsetting R7RS-large is encouraged.
[23:34:18] <aeth> drakonis: the problem is that the implementations added those features in their own specific ways
[23:34:24] <aeth> drakonis: some copied CL, some explicitly rejected CL
[23:34:26] <drakonis> yes.
[23:34:31] <aeth> you'll see this even with e.g. keyword arguments
[23:35:04] <sham1> #:foo is still the only good compromise we have
[23:35:18] <sham1> Had keywords been there since R7-small, we could have had :foo, but no
[23:35:28] <Zipheir> Racket's keywords are my favorite approach.
[23:35:35] <nomagno> ... Then you have me who is interested in implementing scheme on a machine that doesn't support recursion at all.
[23:35:56] <nomagno> After a few months of pondering, I'm still just as lost
[23:36:34] <sham1> Meanwhile I want to look into doing JIT and GC implementations for a Scheme in Scheme and it's a mind-warp of epic proportions
[23:36:38] <mdhughes> All machines support recursion! And if not, you write a Cheney-on-the-MTA.
[23:36:46] <Zipheir> nomagno: What kind of machine is that?
[23:37:45] <drakonis> scheme in scheme?
[23:37:53] <drakonis> you mean a self hosting scheme?
[23:38:13] <sham1> Yes
[23:38:16] <aeth> sham1: CL-style :foo is something that I'm used to and will probably have in Airship Scheme at some point
[23:38:20] <drakonis> neat.
[23:38:29] <aeth> sham1: but just designing things from scratch, foo: is probably the way to go, like in the language that almost got chosen over CSS
[23:38:30] <drakonis> that's always a nice thing to have.
[23:38:44] <aeth> https://en.wikipedia.org/wiki/Document_Style_Semantics_and_Specification_Language
[23:39:02] <sham1> aeth: :foo does work, and I'd say that :foo is better, but since with R7-small and large, that looks like a symbol instead, it'd be a weird thing to make it into a keyword
[23:39:05] <aeth> it's mostly intuitive to see '(foo: 42 bar: 43)
[23:39:17] <aeth> especially on more than one line for each key/value
[23:39:19] <sham1> Unless one just has keywords being symbols with a special format for them, it being :<stuff>
[23:39:34] <aeth> it might be confusing for someone used to another language because they might try foo : 42 but they'd find out very quickly the spacing rules
[23:39:43] <sham1> "foo": 42
[23:39:48] <sham1> /s
[23:40:29] <mdhughes> '((foo . 42) (bar . 43))
[23:41:12] <Zipheir> Keywords ‚â° symbols is just a very, very slippery approach, as easy as it is.
[23:41:20] <aeth> a "normie" is going to prefer plists to alists if they don't really know Scheme
[23:41:27] <aeth> but Scheme can't really have plists without keywords
[23:41:30] <Zipheir> Again, Racket did a nice thing: Keywords are a distinct datum.
[23:41:31] <flyke> I'm very new to Lisp(scheme), I'm trying this language because I have heard talking good about it. 
[23:41:39] <Zipheir> flyke: Welcome!
[23:42:28] <sham1> Zipheir: indeed, and that's why I'm a proponent of the idea that keywords are made into #:foo since we can't change :foo to be (symbol? :foo) => #f
[23:42:51] <flyke> It's veeery hard to get used to it because I grew up with C-like languages and infix notation. I often make mistake while typing like (2 + 3) instead of (+ 2 3) because of my muscle memory used to C-like languages. 
[23:43:26] <sham1> It's especially fun when transcribing normal mathematics becomes a chore, nevermind C-like languages. But one gets used to it
[23:43:41] <Oxyd> I think this disdain for breaking changes is holding Scheme back. Even C++ is more progressive with making breaking changes at this point. :P
[23:44:01] <Zipheir> flyke: It's a bit tricky at first.
[23:44:06] <sham1> If only the R7-large working group had a wider mandate...
[23:44:11] <sham1> But alas, no
[23:44:18] <aeth> personally, I always overused parentheses in C-like languages before I even heard of Lisp, especially since the operator precedence might change between languages and lots of projects use more than one language
[23:44:43] <jrincayc> Oxyd: What is a breaking change you think might be useful for Scheme?
[23:44:49] <Oxyd> Making :foo not be a symbol.
[23:45:28] <Oxyd> Making strings immutable is another thing I'd like to see.
[23:45:32] <Zipheir> Static types. :)
[23:45:34] <drakonis> sham1: a wider mandate?
[23:45:35] <aeth> Ime, it's just a lot clearer to do ((x + y) / z) or ((x / y) + z) instead of doing (x+y)/z and x/y+z and relying on the syntax... and at that point you're half of the way to Lisp
[23:45:48] <Zipheir> Oxyd: I second both of those changes.
[23:46:25] <sham1> drakonis: yes. Because R7-small stuff must be supported even with decisions that might now retroactively seem like a mistake, like not having immutable strings or the symbol syntax or whatnot
[23:46:34] <Oxyd> The first is especially easy to do, in my opinion. First of, there shouldn't be much code that would break (someone should research how much code exactly so that the decision is based on facts, not feelings). Second, there's an easy migration: Change all :foo to |:foo| which would still be a symbol.
[23:46:53] <aeth> But I still use infix in prefix languages or vice versa sometimes. Easy mistake to make when you're switching between them constantly
[23:47:17] <jcowan> Minimalism isn't part of "Scheme philosophy" even insofar as there is such a thing.  `length` has been part of Scheme since r2rs, despite it being definabkle in 2 lines.
[23:47:38] <flyke> Zipheir: I don't if I can get used simultaneously to two radical different notations (infix or this polish notation). Seems like I have to brainwash my previous knowledge to give room to learn lisp.
[23:47:40] <aeth> Oxyd: but why?
[23:47:47] <flyke> s/I dont/I dont know/
[23:47:47] <sham1> One line, depending on how terse you want to be
[23:48:16] <aeth> (define (length l) (length l))
[23:48:17] <aeth> oops
[23:48:34] <sham1> But yeah, to me Scheme never seemed like a "minimalist" language by construction, it just hasn't had a lot of things
[23:49:30] <mdhughes> Read the INTRODUCTION in r*rs.
[23:49:37] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 240 seconds)
[23:49:38] <aeth> well, I guess you could turn my joke into (define (length l) (1+ (length (cdr l)))) but any intro Scheme book will tell you that you should rewrite that to be tail recursive
[23:49:50] <drakonis> the core is small but you can build anything with it
[23:49:55] <aeth> and that's probably why you should include length because people will use that definition because it's easier to write
[23:49:57] <drakonis> that's the whole thing.
[23:50:07] <Zipheir> flyke: IME, it gets easy.  I regularly switch between the two (Haskell and Scheme).
[23:50:20] <aeth> (well, oops, you still need to terminate on 0)
[23:50:43] <aeth> (unless it's polymorphic between a cons and a '())
[23:50:56] <Zipheir> Scheme standards are minimal-ish; Scheme libraries tend toward the maximal (cf. SRFI 1).
[23:51:37] <sham1> (length) is naturally defined by induction. And thus (define (length xs) (let loop ((xs xs) (c 0)) (if (null? xs) c (loop (cdr xs) (+ c 1))))
[23:51:49] <jcowan> One of the R7-small changes was to block arguments like "Vectors would be a better data structure than lists for this problems, but lists have more primitives so I'll use them instead."
[23:52:55] <jcowan> In a few places we overdid this.
[23:53:45] <drakonis> Oxyd: is scheme so averse to change though?
[23:54:19] <Oxyd> Feels like it. I mean, strings are still mutable decades later for no good reason other than backward compatibility.
[23:55:01] <jcowan> Backward incompatible change, yes.
[23:55:22] <drakonis> there's an srfi for immutable strings
[23:55:27] <Zipheir> SRFI 135.
[23:55:28] <jcowan> CL even more so.
[23:55:29] <jrincayc> Hm, there is a proposal (or at least notes) for immutable strings here https://github.com/johnwcowan/r7rs-work/blob/master/BottomScheme.md
[23:55:29] <drakonis> srfi-140
[23:55:38] <drakonis> and 135
[23:55:40] <Zipheir> Oh, right, there's *also* 140.
[23:55:48] <drakonis> CL is even more averse to change
[23:55:57] *** Joins: jeko (~jeko@2a01:e0a:25f:d8f0:1d6a:fdfd:ebc4:592f)
[23:55:57] <drakonis> violently so.
[23:56:11] <jcowan> Too many string SRFIs
[23:56:26] <drakonis> is there such a thing :V?
[23:56:32] <aeth> jcowan: the problem of using lists over vectors should just be called 2.2.4 in reference to Worse Is Better. https://dreamsongs.com/WIB.html
[23:57:49] <aeth> definitely seems more common in Scheme these days than in the Common Lisp that that article is talking about
[23:57:52] <mdhughes> Still occasionally paging thru that reddit page, and I see a guy I just had an argument with, incorrecting someone here. 14 years, glad to see community is stable.
[23:57:59] <dpk> jcowan! i hope you're well after everything?
[23:58:00] <Zipheir> I ported SRFI 135 to CHICKEN and I remain very impressed by Will Clinger's work on that library.
[23:58:35] <sham1> Could be worse, we could be using lists of characters as strings
[23:58:43] <Zipheir> Haha.
[23:58:49] <mdhughes> We should just have string->list list->string and use SRFI 1 for all string processing.
[23:59:06] <mdhughes> sham1: EXACTLY.
[23:59:13] <drakonis> so, a gripe i have about CL is that it has several mostly compatible implementations, not too unlike scheme and everyone has to write code to ensure their libraries work across every CL implementation
[23:59:15] <aeth> maybe the advantage of something like Haskell is that people try to be mathematically elegant at compile time instead of at runtime so it only hurts compilation times instead of making the program slower.
[23:59:43] <jcowan> Going home from the hospital as soon as an ambulette is available
[23:59:45] <drakonis> haskell also has quite the community.
[23:59:46] <sham1> drakonis: at least in practice one can just target SBCL and be happy, meanwhile with Schemes it's harder to pick an implementation
[23:59:49] <aeth> mdhughes: or, embed Tcl into r7rs-large and use string processing for all other processing
[23:59:53] <drakonis> sham1: i picked guile :V
