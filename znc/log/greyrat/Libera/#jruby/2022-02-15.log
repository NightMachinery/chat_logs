[00:17:56] <headius> the module super change is green at least, moving on to block supers
[00:29:01] <headius> hmm cloning and rewriting the closure is not straightforward
[05:23:03] <byteit101[m]> two things: I should have some time starting wednesday to write some stuff up as per your request two weeks ago, headius. What is the intended audience, platform, etc that you were hoping for?
[05:23:20] <byteit101[m]> and second: any further thoughts on the api naming?
[05:40:58] <headius> Oh shoot yeah, I have been all over the place. Tomorrow perhaps we can finalize this with enebo 
[05:43:19] <byteit101[m]> Tomorrow I'm very busy but read my comments, ponder, and respond, and I will hopefully read your thoughts in the evening
[05:44:16] <headius> Ok no problem
[17:28:33] *** Joins: dangerousdave (~dangerous@host-92-16-220-133.as13285.net)
[20:02:46] *** Quits: dangerousdave (~dangerous@host-92-16-220-133.as13285.net) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[20:15:34] *** Joins: dangerousdave (~dangerous@host-92-16-220-133.as13285.net)
[20:47:31] *** Joins: sagax (~sagax_nb@user/sagax)
[21:20:45] *** Quits: dangerousdave (~dangerous@host-92-16-220-133.as13285.net) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[21:24:56] *** Joins: dangerousdave (~dangerous@host-92-16-220-133.as13285.net)
[21:36:10] *** Quits: dangerousdave (~dangerous@host-92-16-220-133.as13285.net) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[22:59:34] <headius> enebo: You have any more thoughts on the naming for byteit101 instance variable Java field feature?
[23:00:12] <enebo[m]> oh let me review his latest comment
[23:04:30] <enebo[m]> heh...I am not sure what is the actual proposal at this point
[23:04:57] <enebo[m]> I see you say instance_variable but then you use java_field
[23:05:30] <headius> java_field is the existing method we are adding this to
[23:06:44] <enebo[m]> So we declare java_field and this other method name is how we access it from ruby as an instance variable?
[23:08:39] <enebo[m]> ok I reread this
[23:09:56] <enebo[m]> instance_variable: true to me makes it clear the field is going to become accessible via @ivar
[23:10:09] <enebo[m]> It literally says this field is also an instance_variable
[23:10:35] <enebo[m]> So I do not find the verb will help and it will definitely not be easier to remember that + verb
[23:11:51] <enebo[m]> as for 'convert' I am not sure I like that or 'to_java'/'to_ruby'
[23:11:56] <enebo[m]> well I like convert more than any other word
[23:12:43] <enebo[m]> I do have a question...the field itself declares a type
[23:13:01] <enebo[m]> if nothing is provided I assume it "converts" to the declared field type?
[23:13:30] <enebo[m]> unless it is false or false is the default but it needs to really be that type then
[23:14:04] <enebo[m]> java_field "java.lang.Object foo", instance_variable: true, convert: false
[23:14:25] <enebo[m]> I was going to start with this but I think this is a bad example because Object
[23:14:37] <headius> yeah the default is JI conversion like java_field without any modifiers
[23:14:51] <enebo[m]> java_field "java.lang.String address", instance_variable: true, convert: false
[23:15:10] <enebo[m]> In this case I have to basically @address = {an actual Java instance of j.l.String}
[23:15:17] <headius> right so that would produce wrapped Java String objects rather than converting to RubyString
[23:16:00] <enebo[m]> if convert is true (let's pretend there is a true value) then it knows it should be j.l.String so it shoudl try to convert to that automatically
[23:16:15] <enebo[m]> So a specific convert: some.Type is for which case?
[23:16:38] <headius> hmm what'
[23:16:41] <headius> what's a good example
[23:16:45] <headius> maybe numerics
[23:16:48] <enebo[m]> Maybe a base type in Swing?
[23:17:05] <enebo[m]> JComponent is field type but we want to force it to a narrower type?
[23:17:31] <lopex[m]> I wonder if this would simplify any openssl gem bits https://github.com/Hakky54/sslcontext-kickstart
[23:17:32] <enebo[m]> Or perhaps the opposite contravariant
[23:17:46] <headius> I think it may be for expressing a specific type when the field is a more generic one
[23:17:57] <lopex[m]> also there's this http://www.jdeploy.com/
[23:18:27] <headius> java_field "java.lang.Numeric quotient", convert: java.lang.Double
[23:18:30] <enebo[m]> headius: but if it is a subtype stored as a less specific type I am not sure it does anything unless our convert itself has special logic
[23:18:46] <headius> so any assigns to that field would be asked to convert to a Double
[23:18:53] <enebo[m]> ok so Numeric could be Integer or Double
[23:19:07] <headius> there may be a better example as part of jrubyfx
[23:19:18] <enebo[m]> but I assume convertign RubyFloat to numeric will just do the right thing there won't it?
[23:19:57] <enebo[m]> yeah I am curious to see a concrete example here.  I believe there may be one but right now true/false with one being the default feels ok
[23:20:13] <headius> lopex: hmm yeah that could be useful... cc kares 
[23:20:40] <headius> the ssl thing
[23:20:49] <lopex[m]> pems, pfx, p12 all supported
[23:20:54] <headius> jdeploy would be worth playing around with to see if we can produce a smaller faster-starting JRuby bundle
[23:21:27] <enebo[m]> headius: our rubyToJava logic is unwrapping but it may also be creating something new.  So convert is ok.  I was thinking about coerce or cast.  cast is not good
[23:22:41] <enebo[m]> My only other pondering is this actually something which is bi-directional?
[23:22:41] <headius> your point about the verb is a good one... the entire call is a declaration of some binding already
[23:22:50] <enebo[m]> In java you need it to at least conform to the field type
[23:22:55] <headius> bind this java field, with these extra characteristics
[23:23:16] <enebo[m]> so ruby->java could be no coercion because you know it is really a java instance being pushed to the ivar
[23:23:30] <enebo[m]> but there may be a need to do more which is outstanding question
[23:24:02] <enebo[m]> but if you do want RubyString -> Java String and the Java String -> Ruby String cool...it is bi-directional
[23:24:23] <enebo[m]> It maybe is too complicated to specify more bindings
[23:25:53] <enebo[m]> Spamming to myself.  Our existing JI allows us to access the field and it will java2ruby and ruby2java that route
[23:26:35] <enebo[m]> That technically means convert: true could be eliminated but that would be bad ergonomics since @address is just a nicer syntax
[23:31:20] <enebo[m]> convert is an action/verb
[23:33:49] <enebo[m]> headius: I added a comment and I think Patrick said he is very busy today so I will not ping his handle :)
[23:35:09] <headius> ok
[23:35:25] <enebo[m]> The specific convert bugs me...since I cannot visualize why if it is accessed from an ivar you need a specific type but at the class level you need a more general type
[23:35:47] <enebo[m]> All I can think of is there is another path into that field where java will set the more generic type
[23:36:03] <enebo[m]> but then if it is not the more specific type you will crash trying to access it from the ivar
[23:36:16] <headius> yeah maybe that could use some clarification
[23:36:39] <enebo[m]> and I am not saying it isn't needed I just cannot see how the mismatch works
[23:36:40] <headius> we do have a few types that can be expressed in a number of ways like Time, but it's not clear to me why the actual Java field type would be the wrong target
[23:37:04] <headius> Time can convert to a Java Time, Date, Joda DateTime, etc
[23:37:17] <enebo[m]> yeah if you have one Ruby type which can be 3 Java types this would allow you to specify but then why not make the field that
[23:37:19] <headius> but you wouldn't expect a target field to have a generic supertype of those
[23:37:31] <enebo[m]> yeah that's also true 
[23:37:44] <enebo[m]> ok well it sounds like we both want to see this example then
[23:38:17] <enebo[m]> I am guessing convert: true is the default
[23:38:35] <headius> yeah should be
[23:38:50] <enebo[m]> seems like most people would expect java2ruby
[23:38:55] <enebo[m]> ok
[23:39:27] <enebo[m]> So I am on board with the name choices you came up with and I think we just need to get more info about whether convert needs more than true/false
[23:43:01] <headius> Ok
[23:43:13] <headius> So back to the define method rewriting for a sec
[23:43:38] <headius> I was looking through the logic you have and it doesn't clone the IR, it actually recompiles it from the original AST
[23:44:08] <headius> There's logic to check that the AST is still available, which would be a bit of a concern for me because I need to be able to do this super target rewriting in all cases
[23:44:40] <headius> Would cloneForInlining be appropriate for cloning the whole IR scope?
[23:46:15] <enebo[m]> cloneForInlining does a lot more than just clone
[23:46:17] <enebo[m]> err wait let me look at something
[23:48:06] <enebo[m]> headius: cloneForInlining will work for closures but you need to pass SimpleInlineInfo
[23:50:12] <enebo[m]> Err SimpleCloneInfo()
[23:55:09] <headius> Yeah I don't need to change anything for inlining so I just really want a copy
[23:56:01] <enebo[m]> The entry is a little weird but I think closure.cloneForInlining(SimpleCloneInfo(closyure)) should do it
