[00:09:03] *** Joins: sts-q (~sts-q@91.200.108.206)
[00:15:47] *** Joins: shka (~herr@109.231.0.226)
[00:23:19] *** bremner` is now known as bremner
[00:36:53] *** Quits: artchad`` (~user@public-gprs233196.centertel.pl) (Read error: Connection reset by peer)
[00:44:49] *** Quits: st_iron (uid370243@id-370243.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[00:46:31] *** Joins: Gnuxie (~gnuxie@user/gnuxie)
[01:03:02] *** Joins: sepanko (~sepanko@user/sepanko)
[01:03:47] *** Joins: Duuqnd (~duuqnd@2001:470:69fc:105::e9c0)
[01:04:16] *** Quits: random-nick (~random-ni@87.116.167.125) (Quit: quit)
[01:15:57] *** Quits: shka (~herr@109.231.0.226) (Ping timeout: 240 seconds)
[01:18:45] *** Joins: random-nick (~random-ni@87.116.180.98)
[01:18:54] *** Quits: Duuqnd (~duuqnd@2001:470:69fc:105::e9c0) (Read error: Connection reset by peer)
[01:18:55] *** Quits: sepanko (~sepanko@user/sepanko) (Read error: Connection reset by peer)
[01:18:59] *** Quits: Gnuxie (~gnuxie@user/gnuxie) (Write error: Connection reset by peer)
[01:21:30] *** Joins: Duuqnd (~duuqnd@2001:470:69fc:105::e9c0)
[01:46:24] *** Quits: Duuqnd (~duuqnd@2001:470:69fc:105::e9c0) (Quit: Client limit exceeded: 20000)
[01:46:49] *** Joins: CodeBitCookie[m] (~code-bit-@2001:470:69fc:105::a2f)
[01:47:02] *** Joins: Gnuxie (~gnuxie@user/gnuxie)
[01:47:02] *** Joins: sepanko (~sepanko@user/sepanko)
[01:47:02] *** Joins: etimmons (~etimmons@2001:470:69fc:105::5d5)
[01:49:01] *** Quits: CodeBitCookie[m] (~code-bit-@2001:470:69fc:105::a2f) (Quit: Client limit exceeded: 20000)
[03:46:53] *** Quits: random-nick (~random-ni@87.116.180.98) (Ping timeout: 256 seconds)
[04:01:06] *** Quits: pjb (~pjb@user/pjb) (Read error: Connection reset by peer)
[05:32:58] *** Joins: Kyuvi (~Kyuvi@dsl-hkibng31-58c38d-219.dhcp.inet.fi)
[05:55:58] *** Quits: rotateq (~user@p200300e787097300818cd04b4ea1a4f3.dip0.t-ipconnect.de) (Quit: ERC (IRC client for Emacs 27.2))
[06:40:37] *** Quits: sts-q (~sts-q@91.200.108.206) (Ping timeout: 240 seconds)
[06:53:57] *** Quits: Kyuvi (~Kyuvi@dsl-hkibng31-58c38d-219.dhcp.inet.fi) (Quit: Client closed)
[06:54:48] *** Joins: sjl (~sjl@cpe-66-66-5-59.rochester.res.rr.com)
[06:55:57] *** Joins: sts-q (~sts-q@91.200.108.152)
[07:07:44] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 252 seconds)
[07:25:02] *** Joins: lottaquestions (~nick@2607:fa49:5041:a200:b0a0:2acf:d5f8:7b92)
[07:26:02] *** Quits: lottaquestions_ (~nick@2607:fa49:5041:a200:b0a0:2acf:d5f8:7b92) (Ping timeout: 240 seconds)
[07:36:35] <beach> Good morning everyone! 
[07:36:35] *** Joins: Duuqnd (~duuqnd@2001:470:69fc:105::e9c0)
[07:36:35] *** Joins: CodeBitCookie[m] (~code-bit-@2001:470:69fc:105::a2f)
[07:49:44] *** Quits: tyson2``` (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[08:30:09] *** Joins: nij- (~jin@2001-48F8-9021-806-0-0-0-63DA-dynamic.midco.net)
[08:30:15] <nij-> (defvar *x* 0) (let ((x *x*)) (setf (car x) 3)) *x* ; => (3)
[08:30:37] <nij-> Is this behavior expected? Why should setf escape the local binding..?
[08:32:08] <nij-> I'm on sbcl. (setf (car x) 3) macroexpands to (sb-kernel:%rplaca x 3)
[08:35:06] <beach> Are you sure you initialize *x* to 0?
[08:35:51] <beach> 'cause that's an error. 
[08:36:02] <beach> You are trying to set the CAR of an integer.
[08:36:31] <nij-> Ah that was a mistake. Sorry.
[08:36:45] <nij-> FIXED> (defvar *x* '(0)) (let ((x *x*)) (setf (car x) 3)) *x* ; => (3)
[08:36:55] <beach> Oh, that's undefined behavior.
[08:37:01] <beach> You are not allowed to modify literal data.
[08:37:14] <beach> But yes, that is expected otherwise.
[08:37:18] <nij-> I'm not sure I understand LET then.
[08:37:31] <nij-> I thought *x* gets evaluated, and the value is assigned to x.
[08:37:38] <beach> Yes.
[08:37:43] <nij-> In the local env, x should evaluate to that value.
[08:37:49] <beach> Correct.
[08:37:53] <beach> It does.
[08:38:49] <beach> OK, so *X* contains a pointer to a CONS cell.  When you do (LET ((X *X*))...) you make X point to that same CONS cell.  Then you set the CAR of that CONS cell.  Since there is only one single CONS cell, that's the one that gets modified.
[08:39:19] <beach> I call this behavior "uniform reference semantics".  Common Lisp behaves as if every object is manipulated through a reference.
[08:39:45] <nij-> I see.
[08:40:14] <nij-> I wish there's an option for the repl to warn if any UBs.
[08:40:46] <beach> The reason it is undefined behavior in the standard, is that it is hard or impossible for an implementation to detect it.
[08:41:01] <beach> In this case, it is undecidable. 
[08:41:19] <nij-> Interesting. I will give a thought about it.
[08:42:19] <beach> This semantics is absolutely essential to understand.  It is very different from that of (say) C++ which copies things by default.  What Common Lisp does is a way simpler model, but it requires automatic memory management.  
[08:42:19] <nij-> thanks!
[08:42:33] <nij-> Oh
[08:42:46] <beach> So the reason C++ doesn't do that, is that they decided from day 1 that it should not have automatic memory management.
[08:43:07] <beach> And that is partly why C++ is so incredibly complicated and Common Lisp is relatively simple.
[08:44:14] <beach> Were you under the impression that the LET would copy the CONS cell?
[08:44:22] <nij-> Yeah.
[08:44:39] <beach> It is absolutely essential to realize that nothing is ever implicitly copied in Common Lisp.
[08:44:45] <nij-> Are there other Lisps that do copy?
[08:45:05] <mfiano> Clojure, but we don't speak that word.
[08:45:13] <nij-> ;)
[08:45:42] <beach> There is no widespread agreement about the definition of "Lisp", but I think uniform reference semantics is absolutely fundamental to what makes Lisp Lisp.
[08:46:01] <nij-> What is "uniform reference semantics"?
[08:46:07] <beach> I just told you.
[08:46:14] <mfiano> Also by the way, Go (language) copies everything, _and_ has automatic memory management.
[08:46:24] <nij-> Oh oh yes.
[08:46:28] <beach> It is as if every object is manipulated through a reference to it.
[08:46:50] <beach> mfiano: Interesting.  But that doesn't contradict what I said.
[08:47:14] <beach> Purely functional languages can get away with copying because they don't have side effects to check whether there is sharing or not.
[08:47:42] <nij-> Is this also UB?
[08:47:45] <nij-> (defparameter *y* 1) (let ((y *y*)) (setf y 2)) *y* ; 1
[08:47:57] <beach> No, that's fine.
[08:48:30] <beach> The SETF changes the association between Y and what it refers to, so that Y and *Y* no longer refer to the same object.
[08:49:06] <nij-> Oh
[08:49:25] <beach> nij-: With uniform reference semantics, an assignment usually becomes a register-to-register operation, which is very fast.  In C++, memory has to be copied.  And this is why it is impossible to write a C++ program that is both fast and modular.
[08:50:25] <nij-> Very nice.
[08:51:16] <beach> The register-to-register operation is possible because every object has the same size, i.e., the size of a pointer, which fits in a register. 
[08:51:44] <beach> s/every object/every (reference to an) object/
[08:52:01] <nij-> Gotcha. 
[08:52:11] <nij-> Thankfully, elisp behaves the same in this case.
[08:52:19] <beach> Of course.
[08:52:31] <nij-> I realize that there might be many nuances to embed elisp into CL.
[08:52:37] <beach> So did Lisp 1.5, Maclisp, Interlisp, Scheme, ...
[08:52:53] <nij-> How about MAL? https://github.com/kanaka/mal/
[08:52:54] <mfiano> For a language that wanted to be distinct from CL to a fault initially, it sure has accumulated a lot of familiarity over the years.
[08:53:34] <beach> nij-: Weren't you the one that was going to convince some friends/colleagues to use Common Lisp?
[08:53:54] <nij-> beach: Yeah. What about it?
[08:53:56] <beach> I strongly advise you to put that off until you understand the semantics a bit more. 
[08:54:10] <nij-> Sure..
[08:54:27] <beach> nij-: You will get questions you can not answer, and you will not understand to give the right arguments, like the one about register-to-register.
[08:55:05] <nij-> Is this also addressed in Cltl2?
[08:55:21] <nij-> Or is there somewhere i can read more about. I mean, to make my understanding more comprehensive?
[08:55:24] <mfiano> What beach speaks of is more implementation than language.
[08:57:36] <nij-> (I have to leave for a while. Will be back in a few hours. Thanks for both of your help!)
[09:00:53] *** Joins: Kyuvi (~Kyuvi@dsl-hkibng31-58c38d-219.dhcp.inet.fi)
[09:02:51] <beach> mfiano: Not quite.  The semantics of the example of (SETF (CAR X) ...) is well defined.  No implementation can choose to copy the CONS cell.
[09:04:11] <mfiano> I was referring to the assumption of register moves, or that the compiler is targetting physical hardware.
[09:04:32] <beach> Sure.
[09:05:25] <beach> I abbreviated my argument a bit.  It was short for "it is possible for a good compiler to turn an assignment into a register-to-register operation, whereas in C++, with copy semantics it is not even possible".
[09:06:18] <beach> Better?
[09:07:02] <mfiano> Much. Though I am sorry you wasted your time researching C++ to even know that. I stay as far away as I can.
[09:07:54] <beach> Oh, that's part of my job.  As a researcher and teacher, I think I must know these things so that I can give the correct arguments and answers to my students. 
[09:08:22] <beach> And here in #clschool I very much wear my "teacher" hat. 
[09:09:29] <beach> Of course, most of my colleagues (anywhere in the world) don't think like I do which is why CS teaching mostly sucks everywhere. 
[09:11:24] <mfiano> You are a notable "exception" to the infamous fallacy, "Those that can't do, teach".
[09:11:54] <beach> I think that's true, yes.
[09:14:20] <beach> As a punishment for that, I was promoted much later than colleagues of mine who did the minimum required in their teaching, and concentrated on their research. 
[09:14:39] <beach> And this is why CS teaching mostly sucks. 
[09:15:01] <mfiano> Getting off-topic, but my English-ambiguity-bothered self is irked by "infamous" being practically synonymous with "famous", just used in different contexts.
[09:16:14] <beach> I am not a native speaking of English, and I am often told that I am wrong in #sicl and #commonlisp, so I won't comment. 
[09:18:59] <mfiano> Are you planning on ever retiring? (I have no idea of your age, just wondering)
[09:26:54] <beach> Technically, I retire in a bit more than 2 months, but I don't plan to change my behavior in any way. 
[09:27:29] <beach> I am a civil servant, and I am not allowed to work longer than that.
[09:27:50] <mfiano> Does that mean you will still teach, or continue your research personally?
[09:27:56] <beach> The latter.
[09:28:29] <beach> I occasionally give talks to industry which is much more fun that undergraduate teaching, so I will continue doing that if I am invited.
[09:28:37] <mfiano> Great, and congratulations. That sounds exciting to have time to research on your own.
[09:28:53] <beach> Yes, thanks.
[09:29:48] <beach> I give talks to industry if they pay my transportation and hotel room.  I don't charge any additional money. 
[09:30:49] <mfiano> I see.
[09:31:24] <beach> I am preparing a talk that should be fun: "psychological phenomena that can have a negative impact on productivity in software development". 
[09:31:36] <mfiano> So will you more time for SICL, or about the same? I have no idea how much you currently allocate to it. I am just curious what your other priority projects are I suppose.
[09:31:42] <mfiano> will you have*
[09:31:48] <beach> About the same.
[09:32:10] <beach> I haven't had any teaching lately, so I have been working on SICL almost exclusively.
[09:32:44] <mfiano> Good. I think you put a lot of effort into it currently, and getting burnt out on an ambitious project is no fun.
[09:33:02] <beach> Oh, that won't happen.  I am very lazy actually.
[09:33:31] <beach> The problem is that there are lots of things to do around the house and related administration, so SICL doesn't get 100% anyway.
[09:33:45] <mfiano> I speak from experience. I think I wasted a good part of my amateur life spending too much time on a couple projects to the point where it no longer became fun, hence the waste.
[09:34:01] <beach> Yes, I see.
[09:35:38] <beach> Today is Monday, and Monday mornings are chaotic around here.  I'll be on and off for the next two hours.
[09:36:10] <mfiano> As such, I have been doing light programming, and mostly researching other programming languages for the last year, and intermittently before that.
[09:39:20] <mfiano> I find resarching programming languages interesting. I am currently evaluating Go, which while not Lisp, is likewise fairly simple, almost to a fault, but makes some rather interesting design choices that, while seem strange individually, work well with the gestault of it all.
[09:48:50] <beach> Sounds good.
[09:53:03] <mfiano> It was invented by some key figures in CS, if you weren't aware.
[09:53:26] <beach> I was not aware of that.  
[09:54:25] <mfiano> Notably Rob Pike and Ken Thompson, famous for co-authoring UTF-8, while the former was involved in the creation of UNIX at Bell Labs, Plan 9, and others.
[09:55:09] <beach> Yes, I know about those two.
[09:55:56] <mfiano> Oh I suppose Ken was also involved in the creation of UNIX while working at Bell, and invented B, the predecessor of C.
[09:56:00] <beach> They are responsible for brainwashing several generations of programmers into thinking that Unix is the best thing that we could every hope to have.
[09:56:09] <mfiano> I didn't know much about him so just had to look him up.
[09:56:24] <mfiano> Yes, I know your stance on UNIX.
[09:59:10] <mfiano> Apparently Ken is recognized as the first person to put regular expressions to programming use.
[09:59:16] <mfiano> Interesting.
[09:59:28] <beach> Yes, I agree, that's interesting. 
[10:01:16] <mfiano> Anyway, Go is a very simple language with automatic memory management, that sets out to be an alternative to C for those accustomed to it, avoiding especially the uniprocessor model of execution.
[10:04:16] *** Joins: spiaggia (~user@2a01:cb19:150:3400:60b7:49a0:2099:f48d)
[10:05:05] <mfiano> I am glad they didn't try to include macros, like the terrible attempts of non-homoiconic languages of late. It does borrow a bit from Lisp however.
[10:05:39] <spiaggia> What aspects does it borrow?
[10:06:10] <mfiano> It has a construct like UNWIND-PROTECT as one example.
[10:07:21] <spiaggia> Interesting.  Does it also separate non-local control transfer from exception handling? 
[10:07:36] <mfiano> The language can't really be compared with CL, as it is strongly/statically typed.
[10:07:58] <mfiano> It has no exception handling. It propagates errors through multiple return values, by convention, as the last return value.
[10:08:10] <mfiano> So, nothing like exceptions, or conditions for that matter.
[10:10:59] <spiaggia> Then I don't see what purpose UNWIND-PROTECT might have. 
[10:11:28] <spiaggia> And that kind of error handling is totally unacceptable.
[10:12:01] <spiaggia> I have seen C programs written by people who did not know about setjmp/longjmp ad something like 80% of the code was about error handling.
[10:12:13] <mfiano> The construct is called defer, and it takes a function/closure that is executed after the function returns, but before the caller receives the result.
[10:12:14] <spiaggia> It totally drowned out the application logic
[10:12:33] <spiaggia> I see.
[10:13:00] <mfiano> The defer can appear anywhere in the lexical environment of the function, so it helps with readability, for example closing a file descriptor right next to opening it.
[10:13:34] <mfiano> and multple forms are executed LIFO
[10:14:32] <mfiano> The language's main selling point is "goroutines" which are an implementation of Hoare's CSP. But I think that their implcitly satisfied interfaces are what makes it interesting to me (which I haven't seen done before).
[10:23:00] <mfiano> There is no OOP or inheritance, only structs which can be included (or as they call "embedded") into other structs (much like :include in CL:DEFSTRUCT). Methods are on types, which is strange, because a function has a type that is it's signature, so you can actually define methods on functions, which is apparently very useful, but I'm still trying to wrap my head around that.
[10:24:24] <spiaggia> I count on you to give a full report from the Common Lisp perspective once you have wrapped enough.
[10:25:52] <mfiano> But, like CL, methods are not contained within any form, like class-centric languages. Unlike CL, they are still singly-dispatched though.
[10:26:54] <mfiano> Yeah I will bore you with the details for now. I might do a full write-up when I've fully digested enough of it. I can say that it is different enough to be interesting, but I'm not sure how interesting it would be to use yet :)
[10:27:11] <mfiano> spare you the boredom*
[10:28:38] <spiaggia> Heh.  I am not bored.  Reading it with interest.  Why would they have automatic memory management and no non-local control transfer nor exception handling?  Why single dispatch only, unless you are ignorant of efficient techniques for multiple dispatch, etc, etc.
[10:30:13] <mfiano> Well it is hard for me to put into words right now, but functions can take interfaces as parameters, which is what initiates dynamic runtime dispatch, so technically you could dispatch on multiple arguments, if a function were to accept multiple interfaces.
[10:30:40] <spiaggia> I kind of see.
[10:31:01] <mfiano> As for the control transfer, I am not sure. I will try to get an answer in my continued research.
[10:31:17] <spiaggia> Looking forward to the report. :)
[10:31:20] <mfiano> I don't understand the simplistic error handling very well yet, coming from the power of CL.
[10:31:26] <mfiano> I might be missing something
[10:33:56] <spiaggia> Speaking of which, I was amused to learn that C++ exceptions are basically useless, I think because they can either leak memory or being prematurely deallocated.  What is amusing is that they included this mechanism without seeing the consequences. 
[10:34:16] <mfiano> The language technically doesn't have methods. They are purely syntactic sugar that rewrites them into the equivalent function definition.
[10:34:44] <spiaggia> Hmm.  Compile-time dispatch then?
[10:34:45] <mfiano> It's just for syntax to highlight the single receiver, I think.
[10:36:32] <mfiano> That is difficult to answer. Yes and no I would say. Yes, because they are just functions. But no, because an interface specifies a set of methods, and those "methods" are looked up at runtime for the applicable type passed in to an interface parameter.
[10:36:44] <mfiano> If that makes any sense at all. I am a bit tired :-)
[10:40:00] *** Joins: shka (~herr@109.231.0.226)
[10:42:12] *** Joins: st_iron (uid370243@id-370243.uxbridge.irccloud.com)
[10:42:14] <mfiano> An variable of an interface type can be thought of as a cons containing the concrete value assigned to the variable, and that value's type descriptor. The value is the underlying concrete data that implements the interface, and the type describes the full type of that data. So, through reflection, the compiler, or the user manually, can obtain the actual type of an interface variable dynamically.
[10:43:09] <mfiano> (interfaces are first class values)
[10:46:51] <mfiano> A parameter that is the empty interface effectively means "any type", since for an interface to be implicitly satisfied, all of the methods it is associated with, must be implemented on that type.
[10:47:22] <mfiano> There is nothing like Java or C# interfaces where you must explicitly state that something implements an interface.
[10:48:07] <mfiano> As such interfaces are usually small (1 or 2 methods associated with them are common), because like structs, they can be embedded into other interfaces to compose new ones.
[10:48:57] <mfiano> This composition and implicit satisfaction makes them especially flexible and helpful in decoupling architectural layers.
[10:49:14] <mfiano> Was that enough for you to be bored yet? :)
[10:50:49] *** Quits: shka (~herr@109.231.0.226) (Quit: Konversation terminated!)
[10:51:10] *** Joins: shka (~herr@109.231.0.226)
[10:52:34] <spiaggia> Just busy with other tasks
[10:52:36] *** Joins: ilmu1 (~ilmu@176.76.242.254)
[10:52:59] <mfiano> I know, you mentioned. I got carried away with the above book though.
[10:54:34] <mfiano> It was hard for me to grasp how powerful interfaces were, after not enjoying them in other languages before. But it finally clicked yesterday, and this is pretty much the only thing that makes the language interesting to me.
[10:54:55] <mfiano> Go's interfaces being powerful that is, not so for other languages'.
[10:55:43] *** Quits: ilmu (~ilmu@176.76.243.242) (Ping timeout: 256 seconds)
[11:00:31] <mfiano> I find it a fascinating language, given how simple it is, but I don't expect any lispers reading this to be converted. It's just one of my hobbies, to explore other garbage-collected languages, so please excuse the off-topic ramblings :)
[11:00:54] <mfiano> On that note, I am going to go to sleep. Enjoy
[11:01:55] <spiaggia> Sleep well!
[11:07:14] *** Joins: Jing (~hedgehog@2604:a840:3::1013)
[11:17:49] *** Quits: shka (~herr@109.231.0.226) (Read error: Connection reset by peer)
[11:21:34] *** Joins: shka (~herr@109.231.0.226)
[11:42:05] *** Quits: spiaggia (~user@2a01:cb19:150:3400:60b7:49a0:2099:f48d) (Quit: ERC (IRC client for Emacs 26.3))
[11:48:06] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[12:29:47] *** Quits: Kyuvi (~Kyuvi@dsl-hkibng31-58c38d-219.dhcp.inet.fi) (Ping timeout: 256 seconds)
[12:58:31] *** Joins: mrmr1 (~mrmr@user/mrmr)
[13:00:11] *** Quits: mrmr (~mrmr@user/mrmr) (Ping timeout: 268 seconds)
[13:00:11] *** mrmr1 is now known as mrmr
[13:08:57] *** Quits: Jing (~hedgehog@2604:a840:3::1013) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[13:14:06] *** Joins: pjb (~pjb@user/pjb)
[13:25:48] *** Joins: Jing (~hedgehog@2604:a840:3::1013)
[13:41:17] *** Quits: ilmu1 (~ilmu@176.76.242.254) (Ping timeout: 240 seconds)
[13:48:07] *** Quits: mrmr (~mrmr@user/mrmr) (Ping timeout: 256 seconds)
[13:49:36] *** Joins: mrmr (~mrmr@user/mrmr)
[14:42:27] *** Quits: Jing (~hedgehog@2604:a840:3::1013) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[14:51:12] *** Joins: Jing (~hedgehog@2604:a840:3::1013)
[14:58:57] *** Quits: mrmr (~mrmr@user/mrmr) (Ping timeout: 240 seconds)
[15:02:51] <nij-> Related to a question I asked a few hours ago: Why wasn't the setf method for NTH defined so that during (setf (nth k list) blah) a new list is created, whose kth 'slot' points to what blah evaluates to, and whose other 'slot's points to the original copy of values?
[15:03:49] <nij-> (I'm still bothered by the non-lexical behavior in (let ((x *x*)) (setf (nth 0 x) blah)))..)
[15:04:29] <beach> Again, Common Lisp is defined so that uniform reference semantics is used.  Nothing is implicitly copied.
[15:05:11] <beach> It is not a violation of lexical scope.  It has to do with the semantics.
[15:07:00] <beach> In a functional language, they would go to a lot of trouble to avoid side affects on shared objects, but Common Lisp is not a function language in that sense.
[15:07:55] <nij-> Gotcha. Just curious, why would you call that trouble?
[15:08:09] <beach> Because it is slow if you are not careful.
[15:08:17] <nij-> Isn't avoiding side effects good? I mean.. when you code is too large, it gets harder to debug.
[15:08:22] <nij-> Ah see.
[15:08:24] <beach> And sometimes it is slow even when you are careful.
[15:09:03] *** Joins: mrmr (~mrmr@user/mrmr)
[15:09:05] <nij-> Yes. I remember the moment I "broke up" with haskell was when I tried studying a book teaching how to analyze algorithm in it.
[15:09:11] <beach> nij-: Avoiding side effects is good if you are into functional programming.  But if you are into functional programming, you should probably use a language other than Common Lisp.  And you would pay a price for the duplication.
[15:09:16] <nij-> Very complicated. And I gotta be very careful.
[15:09:49] <nij-> I learned a lot from this conversation. Thank you, beach.
[15:09:59] <beach> In Common Lisp, object identity is crucial, in particular for object-oriented programming. 
[15:11:20] <nij-> Sure. I see it now.
[15:11:31] <beach> For example, imagine you have an object NIJ that is the member of several data structures, say dinner guests and IRC participants.  Suppose now you want to update the address of NIJ.  In Common Lisp, you just find NIJ and update.
[15:11:42] <nij-> What can I do to make my understanding about CL more comprehensive, if not complete?
[15:11:58] <beach> But if doing so would update only one copy, then you would have to work hard to find the others.
[15:12:09] <beach> Keep asking questions.
[15:13:17] *** Quits: kuao (uid504326@id-504326.helmsley.irccloud.com) (Quit: Connection closed for inactivity)
[15:13:56] <nij-> I want to stick with CL, but also want to reduce side-effects, if not eliminate. Is it ok to use (let ((x (copy-list *x*))) ..)) from now on? It doesn't seem to be too complicated on complexity.
[15:14:09] <beach> Uniform reference semantics is a much simpler model than any others I know, so in fact, now when I program in C, I always use pointers rather than objects themselves. 
[15:14:44] <beach> nij-: That would be a very strange style for Common Lisp.  What are your reasons for avoiding side effects?
[15:15:27] <nij-> Easier to debug. 
[15:15:28] <beach> And you would turn your O(1) operations into O(n) operations.
[15:15:51] <nij-> Err oh.
[15:16:00] <beach> Imagine (PUSH X LIST) if LIST has many elements.
[15:16:03] <mfiano> Side effects don't make code harder to debug. Global state does.
[15:16:25] <beach> In Common Lisp this is an O(1) operation with a single CONS cell allocated.
[15:16:36] <mfiano> In languages like C with tons of global state, side effects make code hard to debug, and introduce subtle, hard to find errors.
[15:16:47] <beach> nij-: If you copy LIST to avoid the side effect, you now have an O(n) operations with LOTS of memory allocation.
[15:17:04] <mfiano> In Common Lisp, we have excellent debugging support built into the language, too.
[15:18:31] <beach> nij-: Common Lisp was defined to be efficient, or rather to make it possible for someone to write an efficient implementation.  And modern Common Lisp systems are very efficient.  You can write code that is more efficient than the equivalent C++ code if you want your application to be modular too.
[15:19:11] <beach> nij-: But if you start using Common Lisp as you would use a purely functional language, then you lose a lot of the performance. 
[15:19:42] <beach> nij-: Let me guess; you told your friends/colleagues that Common Lisp is a functional programming language? 
[15:19:46] <nij-> I see. This is something new to me. Tbh I've never be bothered with performance. But I know I should.
[15:19:53] <nij-> beach: nope.
[15:19:58] <beach> Good.
[15:20:21] <nij-> I told them that it's not true. And I'm still learning. It has a wonderful spec that's barely going to change. I will grow with it for my life.
[15:21:11] <beach> Well, if performance is not important for your applications, you can do whatever you want.  But your code would look very strange to someone else, and you would be told to change it if you were to expose it.
[15:21:12] <nij-> I dunno but while doing research I find it useful to have peers. Sometimes we run into something we don't understand, but that's fine. I think my peer and I have an ok mindset for that.
[15:21:23] <nij-> beach sure
[15:22:04] <nij-> mfiano: I see. That makes sense. The trouble here is *x*, not the side-effects.
[15:22:18] <nij-> But sometimes inevitably we need global states.. right?
[15:22:21] <mfiano> Not in particular.
[15:25:26] <beach> nij-: You were talking about Emacs/Climacs before.  I carefully designed the buffer data structure of Second Climacs to allow for efficient incremental updates, typical for editing.  If I were to do it without side effects, that would be strange, and for each character, a lot of copying would have to be done.
[15:26:21] <mfiano> It is much better to pass a context object around, than to use a global variable. But then again, Common Lisp doesn't have true global variables; instead special variables have a stack of bindings, and typically the "root binding" is not mutated.
[15:27:07] <mfiano> Therefor it is usually easy to mentally trace the value bound to those dynamic variables.
[15:27:30] <nij-> mfiano: What is a context object? // beach: that's a nice example. Thanks.
[15:28:40] <mfiano> Instead of (defparameter *my-app-instance* (make-instance 'my-app)), just invoke your toplevel function with the instance, and pass it around to whoever needs access to it.
[15:28:41] <nij-> I wonder how then do those functional programmers argue about their complexity. 
[15:30:11] <mfiano> This also makes it possible to specialize behavior based on the class of that instance. For example, client code can subclass 'my-app, and define methods on your generic function protocol.
[15:30:37] <beach> nij-: I think their argument is not mainly about performance. 
[15:31:11] <bremner> there are also some relatively cheap ways to simulate mutation
[15:35:00] <mfiano> nij-: In my opinion, Common Lisp is a language for getting things done quickly, such as prototyping quick ideas, without the need to worry too much about performance as you would in other languages, due to uniform reference semantics.
[15:35:17] <mfiano> (and garbage collection)
[15:35:59] *** Quits: Jing (~hedgehog@2604:a840:3::1013) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[15:36:53] <mfiano> If you value immutability at the cost of unnecessary copying of memory, then you might enjoy another C-word Lisp
[15:37:19] <nij-> xD
[15:38:51] <mfiano> Common Lisp is designed so that a good compiler can often times be even faster than C or C++ for large, modular applications.
[15:39:29] <mfiano> Infact, here is a (admittedly small, unmodular) war going on, where Common Lisp was at the top for a long while (but still beats every instance of C): https://programming-language-benchmarks.vercel.app/problem/spectral-norm
[15:54:55] *** Quits: mrmr (~mrmr@user/mrmr) (Ping timeout: 256 seconds)
[15:59:24] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[15:59:33] *** Joins: rotateq (~user@p200300e787097300818cd04b4ea1a4f3.dip0.t-ipconnect.de)
[16:00:07] *** Quits: shka (~herr@109.231.0.226) (Remote host closed the connection)
[16:08:17] *** Joins: shka (~herr@109.231.0.226)
[16:16:55] *** Joins: random-nick (~random-ni@87.116.180.98)
[17:10:16] *** Joins: ns12 (~ns12@user/ns12)
[17:31:58] *** Quits: st_iron (uid370243@id-370243.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[17:41:17] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[17:42:23] *** Parts: ns12 (~ns12@user/ns12) (bye)
[17:46:24] <pjb> nij-: you can indeed easily avoid mutating arguments ("side-effects"), but not using operators that do mutate the arguments. Ie. don't use (setf nth).
[17:48:30] <pjb> nij-: on the other hand, as beach mentionned, you can often implement a more efficient algorithm if you can mutate some data structure.  Ie. you don't want to avoid all mutations, but only the mutations on arguments.  So a COPY-LIST could be in order, but once you copy, you could even increase efficiency, by copying the sequence into a vector. Then space, locality and (setf aref) will be more efficient on your temporary data, than with
[17:48:30] <pjb> a list.
[17:50:07] <pjb> nij-: in general, a good lisp style is to use mutation on data your function just allocated, and to avoid it on arguments, considering the later as immutable.  So not 100% functional, but avoiding external side effects. You can still test those functions as if they were functional.
[18:07:41] *** Joins: Jing (~hedgehog@2604:a840:3::1013)
[18:21:11] *** Quits: rotateq (~user@p200300e787097300818cd04b4ea1a4f3.dip0.t-ipconnect.de) (Quit: ERC (IRC client for Emacs 27.2))
[18:28:29] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[18:33:01] *** Joins: jeffrey (~jeffrey@2001:1c00:b1c:4100::ff16)
[18:34:45] *** Joins: cranium (~cranium@user/cranium)
[18:53:31] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[18:58:08] <nij-> Nice tips too. Thank you pjb :)
[19:15:58] *** Quits: cranium (~cranium@user/cranium) (Quit: Leaving)
[19:27:18] *** Quits: lagash_ (lagash@lagash.shelltalk.net) (Quit: ZNC - https://znc.in)
[19:30:35] *** Joins: lagash (lagash@lagash.shelltalk.net)
[19:46:35] *** Quits: nij- (~jin@2001-48F8-9021-806-0-0-0-63DA-dynamic.midco.net) (Remote host closed the connection)
[20:01:31] *** Quits: etimmons (~etimmons@2001:470:69fc:105::5d5) (Quit: issued !quit command)
[20:19:46] *** Joins: rotateq (~user@p200300e787097300818cd04b4ea1a4f3.dip0.t-ipconnect.de)
[20:22:52] *** Quits: Jing (~hedgehog@2604:a840:3::1013) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[20:45:30] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[21:08:36] *** Joins: artchad (~user@public-gprs233196.centertel.pl)
[21:11:28] *** Joins: st_iron (uid370243@id-370243.uxbridge.irccloud.com)
[21:11:43] <artchad> ok, I've learned that threads (also called "processes" in lisp) are not part of the specification, so there will probably be differences in how you use them between implementations and Operating Systems. I found the package "bordeaux-threads", which I would now naively start to learn. Is there some de facto standard package for threads that's used?
[21:12:17] <White_Flame> yes, bordeaux-threads :)
[21:12:39] <White_Flame> it's basically a compatibility layer on top of all the various implementations' custom threading extensions
[21:13:08] *** Joins: nexeq (~nexeq@user/nexeq)
[21:13:14] <artchad> thanks for the answer, White_Flame.
[21:15:21] <edgar-rft> I think bordeaux-threads *is* a de-facto standard. Threads are meanwhile supported by all Common Lisp implementations (except a few extremely bitrotten ones) and howto use thraeds should be documented in the manual of the respective CL implementation.
[21:21:28] *** Joins: rain3 (~rain3___@86.127.204.59)
[21:21:29] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[22:21:01] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[22:21:17] *** ec_ is now known as ec
[22:43:40] *** Joins: lisp123 (~lisp123@5.30.23.247)
[23:08:17] *** Quits: rain3 (~rain3___@86.127.204.59) (Ping timeout: 240 seconds)
[23:18:03] *** Quits: nexeq (~nexeq@user/nexeq) (Ping timeout: 256 seconds)
[23:27:48] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[23:42:55] *** Joins: Oladon (~olad@98.43.81.226)
[23:49:43] *** Joins: lisp123 (~lisp123@5.30.23.247)
[23:59:30] *** Joins: Kyuvi (~Kyuvi@dsl-hkibng31-58c38d-219.dhcp.inet.fi)
