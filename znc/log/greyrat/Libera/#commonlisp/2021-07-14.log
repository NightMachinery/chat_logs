[00:00:25] *** Quits: akanouras (~akanouras@user/akanouras) (Remote host closed the connection)
[00:00:25] *** Quits: JooTvora[m] (~joaotavor@2001:470:69fc:105::b9ad) (Remote host closed the connection)
[00:00:26] *** Quits: happy-dude (~happy-dud@2001:470:69fc:105::b4d7) (Read error: Connection reset by peer)
[00:00:26] *** Quits: etimmons (~etimmons@2001:470:69fc:105::5d5) (Remote host closed the connection)
[00:00:27] *** Quits: Gnuxie (~gnuxie@user/gnuxie) (Write error: Connection reset by peer)
[00:00:28] *** Quits: loke[m] (~loke@2001:470:69fc:105::237) (Remote host closed the connection)
[00:00:28] *** Quits: dieggsy (~dieggsy@2001:470:69fc:105::91f) (Read error: Connection reset by peer)
[00:00:29] *** Quits: katco (~katco@2001:470:69fc:105::2b8) (Read error: Connection reset by peer)
[00:05:40] *** Quits: kpoeck (~kpoeck@87.140.193.0) (Quit: Client closed)
[00:25:52] *** Quits: tfb (~tfb@88.98.95.237) (Ping timeout: 256 seconds)
[00:26:30] *** Joins: tfb (~tfb@88.98.95.237)
[00:28:50] *** Joins: karlosz (~karlosz@router.cloyne.org)
[00:32:03] *** Quits: cage (~cage@dynamic-adsl-78-15-46-179.clienti.tiscali.it) (Quit: rcirc on GNU Emacs 27.1)
[00:38:02] *** Quits: mingus (~jan-magnu@ti0135a400-2471.bb.online.no) (Ping timeout: 272 seconds)
[00:39:28] *** Joins: dsk (~dsk@user/dsk)
[00:50:08] *** Joins: kakuhen (~kakuhen@user/kakuhen)
[00:55:19] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[00:55:57] *** Quits: amb007 (~a_bakic@171.107.23.93.rev.sfr.net) (Ping timeout: 255 seconds)
[00:57:01] *** Joins: amb007 (~a_bakic@130.106.23.93.rev.sfr.net)
[01:02:40] *** Quits: tfb (~tfb@88.98.95.237) (Quit: died)
[01:06:10] *** Joins: tophullyte (tophullyte@gateway/vpn/protonvpn/tophullyte)
[01:12:20] *** Quits: Alfr (~Alfr@user/alfr) (Ping timeout: 256 seconds)
[01:13:28] *** Quits: IAmRasputin (~ryan.gann@50-207-73-195-static.hfc.comcastbusiness.net) (Ping timeout: 256 seconds)
[01:13:28] <moon-child> scymtym: that's impressive!  What's the latency like?
[01:13:57] *** Quits: shka (~herr@109.231.62.239) (Ping timeout: 255 seconds)
[01:16:40] <scymtym> moon-child: it feels ok locally. i haven't tried anything else. i assume latency is fine for all cases in which GTK Broadway is fine
[01:17:27] <scymtym> since the architecture and much of the javascript side is equivalent
[01:22:28] *** Joins: loke[m] (~loke@2001:470:69fc:105::237)
[01:22:46] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-10-70-54-112-49.dsl.bell.ca)
[01:29:37] *** Joins: Gnuxie (~gnuxie@user/gnuxie)
[01:29:37] *** Joins: katco (~katco@2001:470:69fc:105::2b8)
[01:29:37] *** Joins: akanouras (~akanouras@user/akanouras)
[01:29:37] *** Joins: dieggsy (~dieggsy@2001:470:69fc:105::91f)
[01:29:37] *** Joins: etimmons (~etimmons@2001:470:69fc:105::5d5)
[01:29:37] *** Joins: luis` (~luismboma@2001:470:69fc:105::cc7)
[01:29:37] *** Joins: Mrtn[m] (~mrtn@2001:470:69fc:105::1f44)
[01:29:37] *** Joins: happy-dude (~happy-dud@2001:470:69fc:105::b4d7)
[01:29:49] *** Joins: JooTvora[m] (~joaotavor@2001:470:69fc:105::b9ad)
[01:33:45] *** Quits: tophullyte (tophullyte@gateway/vpn/protonvpn/tophullyte) (Quit: Leaving)
[01:38:49] *** Joins: Patternmaster (~georg@li1192-118.members.linode.com)
[01:44:31] *** Quits: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431) (Quit: Leaving)
[01:50:57] *** Quits: attila_lendvai (~alendvai@catv-86-101-74-70.catv.broadband.hu) (Ping timeout: 245 seconds)
[01:52:52] *** Joins: pegaso (~reis-r@131.72.121.184)
[01:54:05] *** Joins: lisp123 (~lisp123@5.30.23.247)
[01:58:27] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 245 seconds)
[02:03:04] *** Joins: Lycurgus (~juan@cpe-45-46-140-49.buffalo.res.rr.com)
[02:12:46] *** Quits: vats (~vats@42.111.14.169) (Ping timeout: 252 seconds)
[02:13:09] *** Joins: vats (~vats@42.111.23.145)
[02:19:12] *** Quits: paulapatience (~paul@23-233-104-4.cpe.pppoe.ca) (Ping timeout: 255 seconds)
[02:20:03] *** Joins: selwyn (~selwyn@user/selwyn)
[02:22:00] *** Joins: Alfr (~Alfr@user/alfr)
[02:40:08] *** Quits: frgo (~frgo@p200300deef181d00618e54d37c639cfa.dip0.t-ipconnect.de) (Remote host closed the connection)
[02:40:36] *** Joins: frgo (~frgo@p200300deef181d00618e54d37c639cfa.dip0.t-ipconnect.de)
[02:46:35] *** Quits: pve (~pve@87-93-131-24.bb.dnainternet.fi) (Quit: leaving)
[02:51:42] *** Quits: pegaso (~reis-r@131.72.121.184) (Quit: Leaving)
[02:57:15] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[02:57:33] *** Quits: makomo (~makomo@user/makomo) (Quit: WeeChat 3.0.1)
[03:01:29] *** Quits: Lycurgus (~juan@cpe-45-46-140-49.buffalo.res.rr.com) (Quit: Exeunt)
[03:02:24] *** Quits: varjag (~user@ti0040a400-5479.bb.online.no) (Ping timeout: 276 seconds)
[03:09:24] *** Quits: sm2n (~sm2n@user/sm2n) (Ping timeout: 272 seconds)
[03:12:54] *** Quits: scymtym (~user@ip-88-153-154-183.hsi04.unitymediagroup.de) (Ping timeout: 252 seconds)
[03:13:12] *** Quits: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de) (Ping timeout: 272 seconds)
[03:14:57] *** Joins: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de)
[03:16:44] *** Joins: scymtym (~user@ip-88-153-154-183.hsi04.unitymediagroup.de)
[03:19:16] *** Quits: luna-is-here (~quassel@2a02:908:f761:2a3c::a) (Ping timeout: 256 seconds)
[03:22:39] *** Joins: luna-is-here (~quassel@2a02:908:f761:2a3c::a)
[03:27:08] *** Joins: selwyn (~selwyn@user/selwyn)
[03:30:28] *** Quits: yitzi (~yitzi@173-27-106-188.client.mchsi.com) (Quit: Leaving)
[03:30:43] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[03:37:20] *** Joins: derelict (~derelict@user/derelict)
[03:40:36] *** Joins: char (~Srain@cpe-76-186-124-165.tx.res.rr.com)
[03:42:30] *** Quits: random-nick (~random-ni@87.116.177.50) (Ping timeout: 256 seconds)
[03:43:22] *** Joins: pillton (~user@58-6-235-32.tpgi.com.au)
[03:52:00] *** Quits: Alfr (~Alfr@user/alfr) (Killed (sodium.libera.chat (Nickname regained by services)))
[03:52:05] *** Joins: Alfr (~Alfr@user/alfr)
[03:52:49] *** Quits: dsk (~dsk@user/dsk) (Ping timeout: 246 seconds)
[03:59:27] *** Quits: karlosz (~karlosz@router.cloyne.org) (Quit: karlosz)
[04:22:37] *** Joins: recordgroovy (~recordgro@c-67-185-152-122.hsd1.wa.comcast.net)
[04:22:59] *** Joins: cjb (~cjb@user/cjb)
[04:24:57] *** Joins: paulapatience (~paul@23-233-104-4.cpe.pppoe.ca)
[04:28:48] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Ping timeout: 255 seconds)
[04:30:42] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 272 seconds)
[04:33:00] *** Quits: char (~Srain@cpe-76-186-124-165.tx.res.rr.com) (Ping timeout: 272 seconds)
[04:33:43] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 244 seconds)
[04:35:06] *** Joins: taiju (~taiju@240b:253:ec40:2400:654f:7566:b735:5f06)
[04:35:15] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[05:46:32] *** Joins: notzmv (~zmv@user/notzmv)
[05:55:49] *** Joins: lisp123 (~lisp123@5.30.23.247)
[05:57:25] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 244 seconds)
[06:00:42] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[06:01:44] *** Quits: pjb (~pjb@user/pjb) (Remote host closed the connection)
[06:13:39] *** Quits: vats (~vats@42.111.23.145) (Ping timeout: 255 seconds)
[06:13:50] *** Joins: vats (~vats@42.111.15.104)
[06:21:57] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 276 seconds)
[06:24:57] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-10-70-54-112-49.dsl.bell.ca) (Remote host closed the connection)
[06:25:57] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[06:26:05] *** Quits: sp41 (~spal@64.253.214.14) (Remote host closed the connection)
[06:26:43] <mariari> I wonder if nyxt can do anything with it
[06:28:54] *** Quits: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 272 seconds)
[06:41:34] *** Quits: thonkpod (~thonkpod@user/thonkpod) (Ping timeout: 256 seconds)
[06:42:33] *** Quits: paulapatience (~paul@23-233-104-4.cpe.pppoe.ca) (Remote host closed the connection)
[07:01:17] *** Joins: lisp123 (~lisp123@5.30.23.247)
[07:06:38] *** Joins: thonkpod (~thonkpod@user/thonkpod)
[07:09:00] *** Quits: Alfr (~Alfr@user/alfr) (Quit: Leaving)
[07:32:52] <beach> Good morning everyone!
[07:34:39] *** Quits: taiju (~taiju@240b:253:ec40:2400:654f:7566:b735:5f06) (Ping timeout: 255 seconds)
[07:55:22] *** Quits: derelict (~derelict@user/derelict) (Ping timeout: 246 seconds)
[08:00:16] *** Joins: taiju (~taiju@240b:253:ec40:2400:654f:7566:b735:5f06)
[08:02:13] *** Parts: akoana (~ah@user/akoana) (Leaving)
[08:03:54] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 272 seconds)
[08:13:07] *** Joins: wilfred (uid159@id-159.highgate.irccloud.com)
[08:16:15] *** Joins: cmack (~charlie@2600:1700:5d51:26ff:cbb3:85ab:6d4c:3f62)
[08:16:16] <etimmons> beach: https://plaster.tymoon.eu/view/2554
[08:16:28] <etimmons> That one is more interesting. Some non-type-errors in there
[08:18:11] *** Joins: char (~Srain@cpe-76-186-124-165.tx.res.rr.com)
[08:18:52] <beach> Thanks.  Not yet sure what I am looking at.  I haven't finished my morning coffee yet.
[08:19:38] <etimmons> Tests for the aref-accessor-dimension-error issue on a bunch of implementations
[08:20:01] <beach> That much I got.  I need to study the format of the output.
[08:20:44] <etimmons> ah. Sorry, my format foo is a bit weak so it's not as pretty as I wanted.
[08:21:05] <beach> Mine is probably even weaker.
[08:21:42] *** Quits: vats (~vats@42.111.15.104) (Remote host closed the connection)
[08:22:56] <etimmons> Long story short: each of those impls signals an error. But ccl and cmucl are just simple-error
[08:24:22] <beach> I am slowly understanding it.  Thank you very much!
[08:40:05] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Remote host closed the connection)
[08:40:29] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[08:51:47] *** Quits: isekaijin (~pyon@user/pyon) (Ping timeout: 255 seconds)
[08:54:05] *** Joins: isekaijin (~pyon@user/pyon)
[09:14:26] *** Quits: Bike (~Glossina@71.69.170.70) (Quit: Lost terminal)
[09:30:27] *** Quits: peterhil (~peterhil@dsl-hkibng32-54f849-252.dhcp.inet.fi) (Ping timeout: 276 seconds)
[09:33:46] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[09:37:03] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 255 seconds)
[09:47:22] *** Joins: mayuresh (~mayuresh@49.32.235.104)
[09:47:31] <mayuresh> hello everybody. :)
[09:51:29] <beach> Hello mayuresh.
[09:57:50] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[10:00:52] *** Joins: dsk (~dsk@user/dsk)
[10:00:54] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 255 seconds)
[10:05:29] <susam> Good morning, everyone!
[10:05:39] <susam> Hello mayuresh! Hello beach!
[10:05:40] <mayuresh> good morning susam. :)
[10:05:46] <beach> Hello susam.
[10:05:55] <mayuresh> susam, what time is it out there?
[10:06:03] <mayuresh> out here it's 11:05.
[10:06:25] <beach> etimmons: I am going to consult with scymtym with respect to the format of the particular section in the issues before I integrate your work.
[10:06:46] <mayuresh> anyone has any idea why "clisp" has stagnated?
[10:07:00] <beach> mayuresh: It happens.
[10:07:03] <mayuresh> or is there only no public releases for a while now??
[10:07:13] <beach> Lack of funding, people get busy with other stuff, etc.
[10:07:21] <mayuresh> ah, okay.
[10:07:30] <beach> I mean, those are just examples.
[10:07:36] <mayuresh> how does clisp compare with sbcl?
[10:07:49] <beach> Much slower, but more portable.
[10:08:04] <beach> But recently, I have seen bhaible here, so maybe he is working on CLISP again.
[10:08:25] <mayuresh> is bhaible, bruno?
[10:08:40] <beach> I am assuming that, yes.
[10:10:24] <mayuresh> cool. i think he's based out of germany (at last known point in time).
[10:10:25] <beach> Also, since there has been less work on CLISP than on SBCL, it means SBCL is more close to being conforming.
[10:10:54] <mayuresh> i am quite gung-ho about working under "clear linux" (clearlinux.org)
[10:11:18] <mayuresh> and they requested a simple configure, make, make install like build process.
[10:11:24] <beach> There was a lot of excitement generated when SBCL was forked from CMUCL and several very smart and very knowledgeable people worked on it for quite some time.
[10:11:44] <mayuresh> so clisp is the only option i could recommend to the clear linux team.
[10:12:01] <beach> mayuresh: Oh, but that's so oriented toward Unix static languages like C.
[10:12:29] <mayuresh> beach: clear linux is highly optimised by intel for intel's processors.
[10:12:39] <beach> Writing a Common Lisp implementation in C or C++ is unnecessarily difficult.
[10:12:50] <mayuresh> beach: that's why they want natively configurable and buildable systems.
[10:12:54] *** Joins: treflip (~user@95.79.32.99)
[10:13:01] <mayuresh> hi treflip. :)
[10:13:25] <beach> mayuresh: Don't greet people who do not speak please, or else there will be nothing but greetings in this channel.
[10:13:28] <mayuresh> beach: clisp shows that building implementations in c/c++ is just okay.
[10:14:00] <beach> mayuresh: CLISP shows that if you do it that way, you run the risk of ending up with a very slow resulting system.
[10:14:02] <treflip> hi
[10:14:03] <moon-child> mayuresh: abcl may be a better choice; it has a simple build process afaik, and is likely to have better compatibility
[10:14:39] <mayuresh> beach: clisp was fast enough for paul graham to build his commercial portal.
[10:14:44] <moon-child> and java is very popular; I assume they already package other java applications
[10:15:39] <beach> mayuresh: Look, there are tons of people who aren't using Common Lisp because they think it is slow, and they think that because they think it is "interpreted".  It is important that we have implementations that generate fast code so that we can point these people to those implementations.
[10:15:51] <beach> mayuresh: If you can live with slow code, that's fine.
[10:16:26] <mayuresh> beach: you are confused because you seem to be too involved in your own train of thoughts.
[10:16:43] <mayuresh> beach: clisp has a compiler too.
[10:16:58] <beach> I see.  Thank you for pointing that out.
[10:17:12] <moon-child> he has a point.  If the point of clear linux is to have fast code (optimized for intel processors), then it's not a great look to package only one of the slowest cl implementations
[10:17:15] <mayuresh> i don't know how to "pm", thanks for the note from mysterious. :)
[10:17:19] <moon-child> (beach has a point, I mean)
[10:18:00] <mayuresh> moon-child: you are missing the point, clisp might be interpreted, but it has a compiler too.
[10:18:00] *** Quits: char (~Srain@cpe-76-186-124-165.tx.res.rr.com) (Ping timeout: 255 seconds)
[10:18:13] *** Quits: xsperry (~as@user/xsperry) ()
[10:18:18] <beach> Common Lisp implementations that generate fast code (like SBCL) run just fine on Intel processors.
[10:18:33] <moon-child> mayuresh: clisp does not generate highly performant code.  Sbcl does
[10:18:57] <beach> mayuresh: Nobody denies that CLISP has a compiler.  We only mentioned the speed of the resulting code.
[10:18:57] <mayuresh> beach: sbcl just can't have the optimisations that intel has introduced with native binaries under "clear linux".
[10:19:26] <susam> mayuresh: You appear to be using ircII (the original or perhaps close-to-original IRC client). Wow! I believe /msg <nick> Hello should work but I don't know for sure. It has been a long time since I used ircII.
[10:19:29] <mayuresh> beach: sbcl will always play catch-up with native code.
[10:19:31] <beach> mayuresh: What is a "native binary"?
[10:20:12] <beach> mayuresh: And what is "native code", if that is not what SBCL is generating?
[10:20:39] <mayuresh> beach: a native binary in my terms is one which uses all the optimisations provided by a compiler build chain which is well supported by the processor's vendor.
[10:20:48] <mayuresh> beach: in the case of clear linux it is intel.
[10:20:57] *** Joins: susam_ (~susam@user/susam)
[10:21:00] <beach> Oh, so it's tied to a commercial company?
[10:21:13] <susam_> Joined via ircII just for nostalgia's sake
[10:21:15] <mayuresh> beach: yes, but clear linux is fully open source.
[10:21:34] <susam_> Joined via ircII just for nostalgia's sake
[10:21:39] <mayuresh> beach: and intel has a large team dedicated to working on gnu build tools.
[10:21:45] <susam_> Oops! Sorry for the spam.
[10:22:03] *** Quits: cmack (~charlie@2600:1700:5d51:26ff:cbb3:85ab:6d4c:3f62) (Ping timeout: 255 seconds)
[10:22:09] <mayuresh> susam: it's okay, i love ircii. :)
[10:22:44] <mayuresh> beach: intel's has a dedicated large team to improve the gnu toolchain for intel's processors.
[10:22:52] *** Quits: wilfred (uid159@id-159.highgate.irccloud.com) (Quit: Connection closed for inactivity)
[10:23:15] <mayuresh> beach: in fact, intel brings out newer contributions to gnu toolchain in tandem with every release of their newer processors.
[10:23:27] <mayuresh> beach: it's bloody marvellous. :)
[10:23:56] <beach> mayuresh: I am indeed confused.  You simultaneously claim that it is fine to have a Common Lisp implementation that generates slow code, because Graham got rich doing so, and you also claim that CLISP is the best alternative because it uses "native code".  Yet, the code generated by CLISP is significantly slower than that generated by SBCL.  Can you help me out here?
[10:24:43] <mayuresh> beach: i looked around on google, and it seems clisp is working on improving their performance, just not making a loud noise.
[10:25:01] <beach> I see, so it's an investment in the future.
[10:25:16] <mayuresh> beach: paul graham chose clisp, only and only because it was faster than every other open source option when he worked on his commercial portal.
[10:25:23] *** Quits: susam_ (~susam@user/susam) (Client Quit)
[10:25:38] *** Joins: susam_ (~susam@user/susam)
[10:26:04] <susam_> mayuresh: So checked again with this alternate nick. Both "/msg susam Hello" and "/query susam" work for private messages in ircII too.
[10:26:48] <beach> mayuresh: I am looking forward to the day when CLISP is both more conforming and generates faster code than SBCL does.
[10:27:01] <mayuresh> beach: same here. :)
[10:27:15] <mayuresh> beach: and i think that day isn't far away. :)
[10:27:22] <beach> Good to know.
[10:27:47] <mayuresh> does anyone know if "rob warnock" hangs out around here?
[10:28:26] <susam> Why the fondness for CLISP this morning? Why care about it when there is SBCL?
[10:28:58] <susam> I like CLISP though for nostalgia reasons but these days SBCL is all I need.
[10:29:03] <beach> susam: That was explained.
[10:29:14] <beach> susam: Check the logs.
[10:29:20] <susam> Okay. I have missed it then. Let me scroll up.
[10:29:37] <mayuresh> susam: because it's difficult to build sbcl using automated systems without using a previous cl implementation.
[10:29:45] <beach> susam: It is the only implementation that is good for "clear linux".
[10:30:10] <mayuresh> susam and beach: and i'm really keen on working under clear linux. :)
[10:30:24] <beach> mayuresh: Oh, but that's not the argument you gave before.
[10:30:38] <beach> mayuresh: If that is the argument, you might consider our BOCL project.
[10:30:40] <mayuresh> i tested it out and the performance under my machine is mind blowing.
[10:30:52] <mayuresh> "bocl"?
[10:31:24] <susam> Okay, that makes sense. I agree it is a good attribute to have.
[10:31:31] <beach> Yes, Bootstrap Common Lisp.  The idea is to have a slow Common Lisp implementation written in C, but the only purpose is to use it to build other Common Lisp implementations.
[10:31:50] <mayuresh> beach: that's bloody brilliant.
[10:32:02] <mayuresh> beach: i'll investigate this further.
[10:32:11] <mayuresh> beach: thanks a million for that tip. :)
[10:32:11] <beach> mayuresh: Then you can build everything using Make, but the main Common Lisp implementation is written in Common Lisp as it should be.
[10:32:52] <mayuresh> beach: but still the main common lisp wouldn't have the optimizations provided by intel's team for the gnu toolchain, isn't it?
[10:33:10] <beach> mayuresh: But, again, that's not the argument you first gave.  That argument was that a Common Lisp compiler written in Common Lisp can never keep up with what Intel is doing, and BOCL won't fix that.
[10:33:35] <mayuresh> beach: that's exactly what i have mentioned in the previous note.
[10:33:46] <susam> As a thought experiment I wonder what it would take to build a usable computer from scratch. If hardware is given, I would probably write a Forth. Do away with the whole C-based computing infrastructure that is prevalent. If there is no hardware, then get Morris Mano's book, build a Mano CPU with NAND gates, then build a Forth.
[10:34:06] <mayuresh> beach: intel's optimizations for the gnu toolchain would never get carried forward into sbcl, but will under clisp's interpreter.
[10:34:21] <beach> mayuresh: I am not convinced that the GNU toolchain (and what Intel is doing) is good enough for a language that is so much more complex than C.
[10:35:00] <beach> mayuresh: "interpreter"?  I thought you said that CLISP used a compiler.
[10:35:19] <mayuresh> beach: i think i'll take that up as an exercise in the future, to evaluate the difference between gnu toolchain built cl systems and sbcl-like systems.
[10:35:29] <beach> mayuresh: Or are you saying that a bytecode interpreter can be faster than the native code generated by SBCL?
[10:35:37] <mayuresh> beach: clisp is primarily interpreted, and also has a compiler.
[10:35:51] <beach> But the compiler generates bytecodes, right?
[10:36:10] <beach> Maybe it has a native compiler these days.
[10:36:14] <mayuresh> beach: i think the clisp compiler outputs native binaries.
[10:36:48] <beach> mayuresh: Oh, I mean when you type (defun ...) to the prompt.  What kind of code is generated then.
[10:36:52] *** Quits: susam_ (~susam@user/susam) (Quit: Leaving)
[10:36:59] <beach> mayuresh: I was not talking about the system build.
[10:37:10] <mayuresh> beach: i am "pm"-ng you my email address, will you "pm" me yours?
[10:37:24] *** Quits: ^[ (~user@user//x-8473491) (Ping timeout: 276 seconds)
[10:37:30] <beach> I prefer to discuss things here.
[10:37:44] <mayuresh> okay.
[10:37:56] <beach> I think it is important for others to see and comment on the arguments.
[10:37:58] <mayuresh> i just wanted to be in close touch regarding the evaluation.
[10:38:42] <beach> So does CLISP generate native code when you type a DEFUN form at the top level?  And if so, how does it take advantage of the GNU toolchain when it does that?
[10:39:02] <susam> Yes, this is a good discussion. Keep the discussion here so that I and others curious about it can see it here. :)
[10:39:29] <jackdaniel> clisp may generate native code with lightning jit, that said the compiler outputs a bytecode
[10:39:39] <beach> Or, I guess, it would be good enough if COMPILE-FILE generates native code.
[10:39:43] <jackdaniel> so clisp won't benefit from "highly optimized gnu toolchain"
[10:39:49] <mayuresh> beach: they way i've understood it, clisp's interpreter is what gets optimised during the system build process, everything else is from within common lisp environment, so not the same optimisations might apply.
[10:40:11] <beach> mayuresh: Oh, but that's very important.
[10:40:11] <jackdaniel> ecl could partially benefit from it, because it compiles to c, and then the resulting c file is compiled with the c compiler
[10:41:02] <mayuresh> hey, i'm a totally newbie to common lisp, yet i'm understanding most things pretty well.
[10:41:14] <mayuresh> i'm in love with this group. :)
[10:41:24] <beach> mayuresh: Common Lisp is a dynamic language, so code is generated as a result of user interactions.  Not just when the system is built.
[10:41:28] <mayuresh> pretty good people, and noble too. :)
[10:42:00] <mayuresh> beach: the interpreter of clisp is statically built, that's what runs the common lisp environment for it.
[10:42:18] <beach> mayuresh: So you can generate a very fast interpreter at build time, but it won't beat the native code generated as a result of user interactions in a system like SBCL.
[10:42:19] <mayuresh> beach: including the common lisp compiler from within.
[10:42:35] <mayuresh> beach: yes, you are correct.
[10:43:00] <mayuresh> beach: but the clisp team *might* bring in the optimisation techniques from sbcl to clisp
[10:43:17] <mayuresh> beach: for the compiler that is.
[10:43:25] <susam> mayuresh: Curious. What attracted you to Common Lisp? Paul Graham's work and writings?
[10:43:31] *** Joins: attila_lendvai (~alendvai@catv-86-101-74-70.catv.broadband.hu)
[10:43:52] <mayuresh> susam: i worked with autolisp as an engineering intern at larsen & toubro ltd.
[10:43:53] <beach> mayuresh: I think I now have a much better idea about the foundation of your opinions and convictions.
[10:44:14] <mayuresh> beach: sure, that's great. :)
[10:44:15] *** Joins: shka (~herr@109.231.62.239)
[10:44:45] <susam> mayuresh: Oh yes. I remember you mentioning that the last time we talked on this channel. It is great to know that L&T was using AutoLisp.
[10:45:01] <mayuresh> susam: then i forgot about lisp till i worked for cleartrip, where i initiated the formation of the lisp developer team.
[10:45:19] <mayuresh> susam: then off-late i read the introduction of "on lisp" and i was sold.
[10:45:40] <susam> mayuresh: Are you saying you established a Lisp development team in ClearTrip? Did that work out well for you? Were others skeptical?
[10:46:09] <mayuresh> susam: my first interview got pretty involved because i mentioned lisp.
[10:46:11] <contrapunctus> mayuresh: hello from Delhi :)
[10:46:31] <pranavats> There's also a former ClearTrip employee who started a startup called deftask.
[10:46:33] <mayuresh> susam: cleartrip hired me primarily because i was only person who had even heard about lisp.
[10:46:37] <pranavats> Chaitanya Gupt
[10:47:04] <mayuresh> pranavats: i am the ghengis khan of the technology group at cleartrip.
[10:47:09] <mayuresh> :D
[10:47:43] <pranavats> mayuresh: Haha. Awesome. Why did they drop Common Lisp though? If you can shed light on that.
[10:47:46] <susam> mayuresh: Oh, wow! I had no idea ClearTrip was using Lisp. And which Lisp do they use? Common Lisp? What percentage of the code base is in Lisp (roughly), if you don't mind sharing.
[10:48:33] <mayuresh> susam, pranavats: cleartrip's investors forced them to hire a team of java developers from another company that was funded by the investors.
[10:49:02] <pranavats> I see.
[10:49:07] <mayuresh> susam, pranavats: cleartrip's 'cto' sequence was hardcore java oriented.
[10:49:20] <mayuresh> i left out of disgust.
[10:49:45] <mayuresh> and then the whole lisp group just collapsed like a house of cards.
[10:50:10] <pranavats> Sad.
[10:50:46] <mayuresh> there were good guys like "baishampayan ghose", "vihang pande", "abhijit rao", etc.
[10:51:20] <mayuresh> in fact, i was responsible for abhijit rao and prashant acharekar's hiring.
[10:51:35] <mayuresh> and then it was just a long line of developers waiting to join in. :)
[10:52:15] <mayuresh> contrapunctus: hello from mumbai. :)
[10:54:26] *** d4ryus1 is now known as d4ryus
[10:54:33] *** Joins: selwyn (~selwyn@user/selwyn)
[10:54:46] <pranavats> mayuresh: I wonder what percentage of the code base was in CL, too. (susam's question)
[10:55:55] <mayuresh> pranavats: when we started off, 100%, then down to 80% (rest was ruby+python).
[10:56:14] <mayuresh> pranavats: then one fine day, 0% because java happened.
[10:57:22] <susam> Sounds like the story of Reddit. It was 100% Common Lisp. The old source code is archived somewhere on GitHub. Then they decided to switch to Python for various reasons.
[10:57:41] <mayuresh> pranavats: thinking back, i should not have left. if you run away, they'll keep chasing you away.
[10:58:13] <susam> Meanwhile I have been moving all my personal scripts and tools from Python to Common Lisp. Primiarly because I cannot deal with my tools breaking everytime I upgrade a version of a dependency. This backward-incompatibility culture really bothers me now.
[10:58:16] <pranavats> Naughty Dog's founder mentioned getting pressure from Sony (who bought them), to take their codebase off Lisp (GOAL), in one of the interviews iirc.
[10:58:19] <mayuresh> better to stand your ground and fight back.
[10:58:50] <susam> s/Primiarly/Primarily/
[10:59:07] <pranavats> But they still used GOAL in The Last of Us for scripting. So I guess they haven't given up entirely.
[10:59:26] *** Joins: ^[ (~user@user//x-8473491)
[11:01:17] <pranavats> mayuresh: I guess. I wonder if there are more closeted Common Lisp devs in Software Industry here (India).
[11:01:32] <beach> mayuresh: So here is the thing.  Common Lisp is a language that is sufficiently different from C and C++ that generating fast code for languages like C and C++ is not good enough for Common Lisp.
[11:01:36] <beach> For example, those languages don't have generic functions, so a good Common Lisp system must optimize generic dispatch.  Another aspect is that Common Lisp has a much more sophisticated function-call protocol with optional and keyword arguments.
[11:01:37] <beach> It is not enough to generate fast code for those things.  You also have to take into account optimizations specific to Common Lisp, and that I bet Intel is not working on.
[11:01:38] <pranavats> I'm looking up the names you mentioned.
[11:02:39] <beach> Furthermore, in Common Lisp you can redefine functions at run time, so you can't statically optimize callers the way you can in a language with at compile/link/run development cycle.
[11:02:56] <moon-child> beach: the problem with function calls is not complexity but dynamism
[11:03:13] <beach> moon-child: Fair enough.  Thanks.
[11:04:06] <mayuresh> beach: someone would have to specifically work on the common lisp compilers to produce optimised binaries as per the latest cpu architecture changes/improvements.
[11:04:52] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[11:04:54] <beach> mayuresh: I often remark on many industrial projects I have seen that choose C++ because "it is known that the compiler generates fast code", but then they completely blow it, because what they need is really automatic memory management, and the stuff they do to compensate makes their code slower, and impossible to maintain.
[11:04:55] <moon-child> well, no, I guess it's both
[11:05:04] <mayuresh> beach: i have been studying 'bdi' based intent oriented compilation approaches, will probably use it for common lisp here on.
[11:05:16] <moon-child> beach: yeah, gc can frequently be faster than naive manual memory management schemes
[11:05:33] <beach> moon-child: Indeed.
[11:06:01] *** Joins: pjb (~pjb@user/pjb)
[11:06:21] <moon-child> (and where it's not, you can generally implement the same strategies in a language with automatic memory management at no cost)
[11:06:40] <moon-child> (I mean, where gc is slower than sophisticated manual memory management schemes)
[11:06:54] <beach> Yes, good remark.
[11:07:05] <mayuresh> moon-child: good one.
[11:09:21] <mayuresh> moon-child: can you recommend good books to help me go deeper into those techniques?
[11:09:22] <beach> mayuresh: So, unless Intel addresses these issues (generic dispatch, non-trivial lambda lists, dynamic redefinitions, etc.) I don't see how what they do is every going to be good enough for a Common Lisp implementation.
[11:10:07] <moon-child> mayuresh: I don't know of any, sorry.  Perhaps other people in the channel do, though?
[11:10:17] <mayuresh> beach: intel will never address those issues by themselves, they'll just produce processor manuals, and it would be upto 'cl' compiler developers to work things out for themselves and their implementations.
[11:11:04] <beach> mayuresh: But that is precisely what the SBCL maintainers are doing.
[11:11:47] <beach> mayuresh: I thought your argument for clear linux was that we could take advantage of Intel's contributions to the GNU toolchain to avoid this work.
[11:11:48] <beach> No?
[11:11:56] <mayuresh> beach: i hadn't known about that bootstrapping 'cl' you'd mentioned, else i would have suggested sbcl with that to the clear linux team.
[11:12:13] <mayuresh> beach: no, that was not my argument.
[11:12:28] <beach> OK.
[11:12:29] <mayuresh> beach: sorry if i misconveyed my thoughts and position.
[11:14:04] <beach> Well, BOCL is not finished, but either CLISP or ECL can serve the same purpose, thereby making it possible to build something like SBCL from C and Make.
[11:14:43] <mayuresh> beach: i don't think the "clear linux" team would agree to having more than 1 full fledged 'cl' system on their distribution.
[11:15:03] <beach> Ah, more constraints.
[11:15:06] <mayuresh> beach: but i'll try suggesting sbcl to them.
[11:16:15] <beach> I can tell that it's risky that I come across as being an SBCL fanatic.  That is not the case.  I am merely using SBCL as an example of a Common Lisp implementation written (mostly) in Common Lisp, which to me is the sane way of doing it.
[11:16:39] *** Joins: Krystof (~user@81.174.155.115)
[11:16:54] <mayuresh> nothing risky. everybody is entitled to have their preferences and opinions.
[11:17:25] <mayuresh> the same way that i believe in the "clisp" way more than the way of "sbcl".
[11:18:37] <beach> Well, if you are right about the "clear linux" team, I think it is very sad, because that means that they only accept ways of creating software that forces us to be way less productive than we can be.
[11:18:59] <beach> But that seems to be the state of the software world, so I am not surprised.
[11:19:23] <mayuresh> no, the "clear linux" team doesn't want unnecessary hand tuning and manual intervention. they want as much automation as possible.
[11:19:53] <beach> How does that prevent "more than 1 full fledged 'cl' system on their distribution"?
[11:19:55] <mayuresh> as i said, i'll definitely ask the "clear linux" team regarding "sbcl".
[11:20:42] <mayuresh> for "sbcl" to be buildable, they'll also need to have "clisp", so they *might* choose to run with "clisp" _only_.
[11:20:49] <mayuresh> that's my point.
[11:20:52] <mayuresh> not theirs.
[11:20:58] <beach> I think I am not expressing myself very well.
[11:21:01] <mayuresh> i might have not understood them fully.
[11:21:44] <mayuresh> beach, are you requesting more than 1 "common lisp" system under clear linux?
[11:22:03] <mayuresh> if yes, as i said, they *might* consider.
[11:22:04] <beach> Suppose SBCL secretly includes CLISP or ECL in its distribution, so that when you type `make', what really happens is that CLISP or ECL is first built using the C compiler, and then SBCL is built using CLISP or ECL.  Why would the clear linux team care?
[11:22:07] <mayuresh> just not sure.
[11:22:44] <mayuresh> beach: if sbcl does that, then yes, there would be no issues with the "clear linux" team accepting sbcl.
[11:23:15] <mayuresh> beach: understand that the "clear linux" team wants as much automation as possible. or rather as little manual intervention as possible.
[11:23:43] <mayuresh> beach: bocl would be a good idea once it's done.
[11:24:01] <mayuresh> beach: is bocl using anything from sicl?
[11:24:08] <beach> No.
[11:24:27] <pjb> mayuresh: all CL implementations can be compiled automatically, once you've gathered all the required dependencies.  Perhaps some are lacking some packaging on some distribution, but there are enough CL implementations that can be built with configure && make install.
[11:24:28] <mayuresh> so bocl is building it's own stuff up from scratch!
[11:24:58] <mayuresh> pjb: can you point out a few which are as automated as clisp?
[11:25:00] <pjb> Well, I've copy-pasted and adapted some code from sicl and probably will some more into my bocl ;-)
[11:25:20] <pjb> mayuresh: clisp, ecl, sbcl, abcl.
[11:25:22] <beach> BOCL is going to be a pure C implementation of a conforming, but perhaps horribly slow, Common Lisp system.
[11:25:51] <pjb> beach: well, "pure C" only for some kernel.  A lot will be written in lisp…
[11:25:52] <beach> mayuresh: The idea is that it would not be written for speed, but for simplicity and maintainability.
[11:25:56] <mayuresh> pjb: sbcl requires a lot of manual intervention.
[11:26:08] <pjb> You'd have to be terribly masochistic to write everything in C.
[11:26:10] <beach> pjb: Right, but that's just data input to the rest of the system.
[11:26:21] <pjb> Even the C I have is already partly generated from a lisp script!
[11:26:25] <pjb> Yes.
[11:26:40] <beach> Ouch, that last thing is not a good idea.
[11:26:52] <beach> It means it is not "source code" as the FSF defines it.
[11:27:28] <pjb> Now, about linux and lisp integration, it should be possible to write a linux module that would implement all the linux syscalls using lisp (tagged) data types. Some definition (kind of the CL POSIX definition) would have to be specified, because this could lead to some simplification of the syscall API.
[11:27:43] <pjb> It is also quite possible that this would lead to more efficiency (for lisp processes).
[11:27:46] <moon-child> yeah, it sounds like you're making a self-hosting lisp implementation part of which is compiled to c :)
[11:27:50] <shka> yes, it would also be possible on windows
[11:28:03] <shka> not quite on the OSX
[11:28:51] <beach> pjb: I have an embryonic specification of a POSIX API for Common Lisp.
[11:28:53] <pjb> beach: well, it's generated at "edit-time". The generated C code is commited into the repository.
[11:29:07] *** Quits: mayuresh (~mayuresh@49.32.235.104) (Quit: Leaving)
[11:29:21] <beach> Not sure I understand that, but I take your word for it.
[11:29:34] <shka> honestly, not being glibc dependent would be benefit in itself
[11:30:20] <pjb> shka: some C programmers also do that, using directly linux syscalls and bypassing the libc.
[11:30:29] <moon-child> there was some work done to make sbcl binaries that were statically linked with musl
[11:30:30] <pjb> shka: we would only need to define the FFI for syscalls.
[11:34:44] *** Quits: cjb (~cjb@user/cjb) (Quit: rcirc on GNU Emacs 28.0.50)
[11:41:51] <beach> pjb: Have you seen my suggested POSIX interface?>
[11:43:12] <beach> http://metamodular.com/POSIX-API/
[12:19:26] <pjb> beach: indeed. I also started working on something like that even earlier.  We talked about that then.
[12:20:59] <beach> I see.  Sorry about my bad memory. :(
[12:21:27] *** Joins: pve (~pve@178-55-194-162.bb.dnainternet.fi)
[12:30:08] <pjb> No problem, it was a long time ago!
[12:30:24] <beach> Whew! :)
[12:30:37] <pjb> I started lisping seriously with CL in 1996, 25 years ago.
[12:31:24] <beach> I guess we started roughly at the same time then.  I did Scheme before that.
[12:32:07] <pjb> Yes. But scheme didn't stick, each time I tried, it was a different implementation and even perhaps a different N of rNrs…
[12:32:48] <beach> Yeah, same here.  And I found myself implementing (bad) object systems.
[12:33:01] <pjb> Yep.
[12:33:34] <beach> I tried it in teaching too, but I didn't believe my own words: "Sure, it's slow, but, you see, it is *possible* to write a good Scheme compiler; I just don't know how...".
[12:33:47] <pjb> Which is nice for students. I call scheme a pedagogical programming language. Sophisticated,  but incomplete enough so that students have a lot of learning exercises.
[12:34:07] <beach> Sure.
[12:34:12] *** Joins: rgherdt (~rgherdt@ip5f5af43c.dynamic.kabel-deutschland.de)
[12:34:35] <shka> that was the initial point of the design IIRC
[12:34:44] <shka> so it completes the goal
[12:34:56] <pjb> Definitely. This may change with r7rs/big.
[12:35:55] <moon-child> apparently r7rs large is getting predicate-based dynamic dispatch
[12:36:15] *** Joins: hendursa1 (~weechat@user/hendursaga)
[12:38:52] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 244 seconds)
[12:39:52] *** Joins: lisp123 (~lisp123@5.30.23.247)
[12:39:52] *** Joins: Th30n (~Th30n@cpe-188-252-158-220.zg5.cable.xnet.hr)
[12:44:21] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 258 seconds)
[12:48:10] <beach> Good for them.
[12:50:48] <shka> eh, i don't know
[12:51:08] <shka> it may hurt the educational angle scheme had going
[12:51:23] <shka> but i guess you can use the older standard version of scheme for this purpose still
[12:51:57] *** Joins: peterhil (~peterhil@dsl-hkibng32-54f849-252.dhcp.inet.fi)
[12:51:57] <moon-child> or the 'small' variant, which will (afaik) continue to be maintained
[12:55:58] *** Joins: Lord_of_Life_ (~Lord@user/lord-of-life/x-2819915)
[12:56:44] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 272 seconds)
[12:57:11] *** Lord_of_Life_ is now known as Lord_of_Life
[12:58:12] *** Joins: heisig (~heisig@p57942813.dip0.t-ipconnect.de)
[12:58:33] *** Joins: Tomte (~th@p200300db9f0f0f005ca17ba2dabfdd7d.dip0.t-ipconnect.de)
[13:08:50] *** Joins: IAmRasputin (~ryan.gann@c-71-192-113-162.hsd1.ma.comcast.net)
[13:10:40] *** Quits: svillemot (~sebastien@rama.villemot.name) (Quit: WeeChat 3.0)
[13:13:29] *** Quits: IAmRasputin (~ryan.gann@c-71-192-113-162.hsd1.ma.comcast.net) (Ping timeout: 258 seconds)
[13:14:48] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[13:15:18] *** Quits: Patternmaster (~georg@li1192-118.members.linode.com) (Remote host closed the connection)
[13:15:45] *** Quits: etiago (~etiago@user/etiago) (Ping timeout: 255 seconds)
[13:16:54] *** Joins: etiago (~etiago@user/etiago)
[13:21:18] *** Joins: Patternmaster (~georg@li1192-118.members.linode.com)
[13:25:56] *** Joins: svillemot (~sebastien@rama.villemot.name)
[13:35:03] *** Quits: manicennui (uid349235@id-349235.tinside.irccloud.com) (Quit: Connection closed for inactivity)
[13:40:13] *** Joins: selwyn (~selwyn@user/selwyn)
[13:44:06] *** Quits: taiju (~taiju@240b:253:ec40:2400:654f:7566:b735:5f06) (Ping timeout: 255 seconds)
[13:48:20] <gin> While typing code with paredit-mode, whenever I type #p"/foo", paredit changes it to #p "/foo" (note the extra space after #p added by paredit). Is that a correct convention being followed by Paredit?
[13:48:43] <gin> I see most CL code has #p"/foo" (not #p "/foo"). how to stop Paredit from inserting the extra space between #p and the string?
[13:50:14] *** Joins: taiju (~taiju@240b:253:ec40:2400:654f:7566:b735:5f06)
[13:52:53] <ck_> are you sure that it is Paredit doing the inserting?
[13:54:31] *** Joins: elf_fortrez (~elf_fortr@adsl-72-50-4-50.prtc.net)
[14:00:06] <gin> ck_: Yes, if I disable paredit-mode, this issue no longer occurs
[14:00:07] <ck_> oh, I was checking with the wrong buffer, sorry. I've only ever seen no space between the hash-p and the string
[14:00:51] <gin> ck_: do you have paredit-mode enabled now? What happens if you type #p"foo"? Does it insert a space between #p and "foo"?
[14:01:39] *** Joins: Equill (~Equill@1.red-83-37-200.dynamicip.rima-tde.net)
[14:03:58] <ck_> gin: yes, it does. Also between #2A and ((1)) for example.
[14:04:07] <ck_> I wonder if I've simply never noticed
[14:04:22] <jdz> gin: I have some code for this, sec.
[14:04:47] <clintm> I get that with paredit as well and just end up C-b'ing back and taking out the space.  Still annoying though.  I've never gotten around to figuring out what was going on.
[14:04:48] <gin> ck_: maybe you just remove the space manually by habit. i have been doing that everytime I have to do that I feel the inconvenience
[14:07:30] <jdz> gin: https://gist.github.com/jdz/bdcd4e20066ab7d743d81b115310d229 There's more code than necessary, but Emacs' `looking-back' is just wrong, so I tried to get around it.  I've found what needs to be done on some wiki or paredit documentation itself.
[14:08:36] <clintm> Hmmm...  I'll try that.  Thanks, jdz!
[14:09:59] <jdz> clintm: Code not using my personal `usr:looking-back-at-p' should be available somewhere on the interwebs, you probably only need the last two forms.
[14:13:51] *** Quits: Th30n (~Th30n@cpe-188-252-158-220.zg5.cable.xnet.hr) (Ping timeout: 268 seconds)
[14:14:36] *** Joins: lisp123 (~lisp123@5.30.23.247)
[14:15:08] *** Joins: Th30n (~Th30n@cpe-188-252-156-252.zg5.cable.xnet.hr)
[14:17:13] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[14:20:07] *** Joins: lisp123 (~lisp123@5.30.23.247)
[14:24:38] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[14:31:28] *** Joins: varjag (~user@ti0040a400-5479.bb.online.no)
[14:35:03] *** Joins: tfb (~tfb@88.98.95.237)
[14:40:05] *** Quits: frgo (~frgo@p200300deef181d00618e54d37c639cfa.dip0.t-ipconnect.de) (Remote host closed the connection)
[14:40:33] *** Joins: frgo (~frgo@p200300deef181d00acae8e9a594b53e3.dip0.t-ipconnect.de)
[14:43:07] *** Quits: elf_fortrez (~elf_fortr@adsl-72-50-4-50.prtc.net) (Ping timeout: 246 seconds)
[14:46:49] *** Quits: pillton (~user@58-6-235-32.tpgi.com.au) (Quit: ERC (IRC client for Emacs 27.2))
[14:54:38] <pjb> gin: #p"foo" doesn't insert a space for me…
[14:55:05] <gin> pjb: Paredit enabled for you?
[14:55:10] <pjb> yes.
[14:55:39] <pjb> #2A() no space either.
[14:56:18] <pjb> #2A are self-insert-command and ( is paredit-open-round and " is paredit-doublequote.
[14:56:35] <pjb> gin:  type C-h k ( to see your own binding in the paredit buffer.
[14:58:50] *** Joins: lisp123 (~lisp123@5.30.23.247)
[14:59:44] <gin> pjb: ( is to (paredit-open-round &optional N)
[15:00:05] <pjb> gin:  perhaps https://github.com/informatimago/rc/blob/master/emacs-paredit.el is relevant. I'm not sure to understand paredit-space-for-delimiter-predicates  anymore. I have: paredit-space-for-delimiter-predicates --> (pjb-paredit-space-for-delimiter-p/predicates)
[15:00:06] <gin> pjb: " runs the command paredit-doublequote (found in paredit-mode-map),
[15:01:39] <pjb> But it seems that paredit-space-for-delimiter-predicates indeed is what you want to customize.
[15:13:25] *** Quits: kakuhen (~kakuhen@user/kakuhen) (Quit: Leaving...)
[15:14:36] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[15:21:45] *** Quits: dsk (~dsk@user/dsk) (Ping timeout: 255 seconds)
[15:23:06] *** Joins: random-nick (~random-ni@87.116.177.72)
[15:23:48] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 268 seconds)
[15:26:58] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-10-70-54-112-49.dsl.bell.ca)
[15:33:52] *** Quits: taiju (~taiju@240b:253:ec40:2400:654f:7566:b735:5f06) (Ping timeout: 246 seconds)
[15:35:14] *** Joins: taiju (~taiju@240b:253:ec40:2400:654f:7566:b735:5f06)
[15:37:52] *** Quits: treflip (~user@95.79.32.99) (Remote host closed the connection)
[15:38:15] *** Joins: treflip (~user@95.79.32.99)
[15:40:42] *** Joins: karlosz (~karlosz@router.cloyne.org)
[15:49:10] *** Joins: yitzi (~yitzi@173-27-106-188.client.mchsi.com)
[15:53:22] *** Quits: treflip (~user@95.79.32.99) (Ping timeout: 252 seconds)
[15:56:49] *** Quits: karlosz (~karlosz@router.cloyne.org) (Quit: karlosz)
[16:01:51] *** Joins: kciN (~zaba@77-92-254-44.dsl.utg.ge)
[16:02:35] <kciN> Hey, guys! Where can I find core common lisp specification, without the whole standard library bloat?
[16:04:16] <pranavats> kciN: Not sure what you mean. You want just the special forms?
[16:04:24] *** Quits: Th30n (~Th30n@cpe-188-252-156-252.zg5.cable.xnet.hr) (Quit: WeeChat 3.2)
[16:04:36] *** Joins: Th30n (~Th30n@cpe-188-252-156-252.zg5.cable.xnet.hr)
[16:05:20] <jackdaniel> kciN: the common lisp standard covers all symbols found in the common-lisp package
[16:05:37] <jackdaniel> i.e a function remove-if-not is part of the "core common lisp specification" as you put it - that is, the ansi standard
[16:06:37] <jackdaniel> if you want to read online the document that is based on the final draft of the standard (and does not differ from the standard in any important way), you may use this website: http://www.lispworks.com/documentation/HyperSpec/Front/index.htm
[16:07:14] <jackdaniel> most notably http://www.lispworks.com/documentation/HyperSpec/Front/Contents.htm
[16:15:18] *** Quits: kciN (~zaba@77-92-254-44.dsl.utg.ge) (Ping timeout: 255 seconds)
[16:19:17] *** Joins: lisp123 (~lisp123@5.30.23.247)
[16:21:00] *** Joins: lotuseater (~user@p200300e787091b00387e7f8a32e5e786.dip0.t-ipconnect.de)
[16:23:48] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[16:24:18] *** Quits: scymtym (~user@ip-88-153-154-183.hsi04.unitymediagroup.de) (Ping timeout: 255 seconds)
[16:39:42] *** Joins: cranium (~cranium@user/cranium)
[16:41:28] *** Joins: mayuresh (~mayuresh@182.58.227.139)
[16:41:41] <mayuresh> hello! :)
[16:49:01] *** Joins: Bike (~Glossina@71.69.170.70)
[16:49:01] *** ChanServ sets mode: +o Bike
[16:49:07] <jcowan> beach: Is the idea of BOCL to write all of it in C, with no CL source at all?
[16:55:13] *** Joins: treflip (~user@95.79.32.99)
[17:07:56] <beach> jcowan: No, not quite.  The idea is to write a Common Lisp implementation so that it can be built with only a C compiler and some minimal build tools available.  It can consist of a C "core" and additional Common Lisp code on top.
[17:08:46] *** Joins: IPmonger (~IPmonger@c-69-242-83-226.hsd1.pa.comcast.net)
[17:08:46] <jcowan> So equivalent in that sense (AFAIU) to CLISP and ECL.
[17:09:01] *** Quits: IPmonger (~IPmonger@c-69-242-83-226.hsd1.pa.comcast.net) (Remote host closed the connection)
[17:09:10] <jcowan> but presumably easier to maintain
[17:09:25] <beach> jcowan: If you like.  But the point is to have it written for best maintenance and simplicity.  Not for speed.
[17:09:28] <beach> Yes.
[17:12:43] <jcowan> So one way to get at least partway to BOCL would be to replace the C in ECL (say) with equivalent but slower/more maintainable code.
[17:14:16] <beach> That sounds plausible.  I haven't looked at the code enough to be sure, but it sounds likely.  The Common Lisp code in ECL might of course also contain "compromises" in the name of performance.
[17:18:26] *** Quits: mayuresh (~mayuresh@182.58.227.139) (Ping timeout: 258 seconds)
[17:19:31] *** Joins: dsk (~dsk@user/dsk)
[17:20:10] <jcowan> Yes, that's why I say "partway"; once you have the C, you can "deoptimize" the CL parts at leisure.
[17:20:24] <jackdaniel> ignoring the c compiler (using only the bytecodes interpreter), removing threading and the interrupt handling should give a fairly maintainable code
[17:20:25] <beach> Yes, that makes sense.
[17:21:25] <jackdaniel> (of course these things are also maintainable, but would be unnecessary from bocl perspectie)
[17:21:50] <beach> It is an amusing exercise to think through the design decisions this way.  One is (or at least I am) usually so focused on performance that it is hard to unthink such thoughts.
[17:22:07] <jcowan> Good to know.  Still, the maintainer isn't always the best judge of maintainability.  :-)
[17:23:15] <jackdaniel> sure, bystanders always know better
[17:24:11] <jackdaniel> because, you know, their opinion is not clouded by knowing /anything/ about the subject ,)
[17:24:18] <beach> Heh!
[17:25:00] *** Joins: lisp123 (~lisp123@5.30.23.247)
[17:25:06] <beach> jackdaniel: I am sure ECL is quite maintainable.  But I recommend the mental exercise I mentioned above.  At least I am often surprised by the consequences.
[17:25:43] <beach> Like immediate fixnums not being necessary, and getting rid of them greatly simplifies things.
[17:26:47] <beach> Or having bitvectors having Common Lisp pointers as elements.
[17:26:54] <jackdaniel> I think that immediate fixnums do not impose /much/; I've mentioned the c compiler, threading and interrupts because (most notably the latter two) impose greater complexity (imho of course)
[17:27:33] <beach> Sounds plausible.
[17:29:53] <beach> I will still amuse myself by this mental exercise from time to time.  I'll leave the programming to pjb who is actively working on it, using the result of his own design decisions of course.
[17:29:57] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 268 seconds)
[17:34:21] <jackdaniel> re bystanders, that reminded me of this: https://daniel.haxx.se/blog/2021/05/20/i-could-rewrite-curl/ :)
[17:34:24] <jcowan> "Sure it's maintainable.  That bug you mention, it's right *here*."  Meanwhile I am searching the entire codebase for it...
[17:35:46] <jcowan> $BOSS is chronically annoyed with me because it takes me two weeks to fix something he could fix in two days (and that's his estimate for it).  Sure, *he* could fix it in two days.
[17:36:45] <jackdaniel> jcowan: I don't buy into a notion that a maintainable code is the code that is understood by everyone from the start. that's not a possible feat for a reasonably complex abstractions
[17:37:17] <jcowan> Sure.  But it needs to be in that case well roadmapped.  Which this @#$* tangle of JavaScript is not.
[17:39:02] * jackdaniel doesn't understand the javascript reference; re "good roadmaps" - you may pour any number of hours into documentation and people will still complain. case in point - ecl has in the manual a description of file modules and their content
[17:39:14] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-10-70-54-112-49.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[17:39:30] <jackdaniel> even more, internal structures are briefly documented too
[17:39:48] <jackdaniel> so I guess it is time to write a "documentation roadmap"
[17:40:10] <jcowan> I'm talking about $EMPLOYER's JavaScript
[17:40:22] <jackdaniel> I still don't understand, but be as it may
[17:54:09] *** Quits: hendursa1 (~weechat@user/hendursaga) (Quit: hendursa1)
[17:54:29] *** Joins: hendursaga (~weechat@user/hendursaga)
[17:56:27] *** Quits: hendursaga (~weechat@user/hendursaga) (Client Quit)
[17:56:52] *** Joins: hendursaga (~weechat@user/hendursaga)
[18:04:28] *** Quits: peterhil (~peterhil@dsl-hkibng32-54f849-252.dhcp.inet.fi) (Read error: Connection reset by peer)
[18:05:19] *** Joins: peterhil (~peterhil@dsl-hkibng32-54f849-252.dhcp.inet.fi)
[18:07:49] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[18:09:19] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-08-70-29-36-156.dsl.bell.ca)
[18:11:24] *** Joins: IAmRasputin (~ryan.gann@50-207-73-195-static.hfc.comcastbusiness.net)
[18:12:43] *** Quits: IAmRasputin (~ryan.gann@50-207-73-195-static.hfc.comcastbusiness.net) (Client Quit)
[18:18:33] <beach> Since jmercouris did not seem interested, I wrote this issue myself: https://github.com/s-expressionists/wscl/blob/main/wscl-issues/proposed/digit-char-p-type-error
[18:21:47] <jackdaniel> beach: shouldn't the new text include "in safe code"?
[18:24:17] <beach> jackdaniel: That's what "should signal..." means.
[18:24:24] <_death> does CL use character designators anywhere besides CHARACTER?
[18:24:31] <mfiano> That link reminds me of a cringy comparison between CL and Scheme I had the misfortune of reading (part of) recently, which I can't find the link to. It described DIGIT-CHAR-P as a coercion from a string to a number.
[18:24:32] <beach> clhs 1.3.2
[18:24:33] <specbot> Couldn't find anything for 1.3.2.
[18:24:36] <beach> Ah,
[18:24:42] <beach> clhs 1.4.2
[18:24:42] <specbot> Error Terminology: http://www.lispworks.com/reference/HyperSpec/Body/01_db.htm
[18:25:13] <jackdaniel> beach: ah, my bad. thanks for the link
[18:25:18] <beach> Sure.
[18:25:58] <beach> _death: It is in the glossary, so presumably, yes.
[18:26:33] *** Joins: Lycurgus (~juan@cpe-45-46-140-49.buffalo.res.rr.com)
[18:28:42] <_death> well, can't think of any other place
[18:28:47] *** Quits: treflip (~user@95.79.32.99) (Quit: ERC (IRC client for Emacs 27.2))
[18:29:07] *** Joins: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431)
[18:29:15] <beach> I am looking now...
[18:30:36] <_death> well, obviously COERCE
[18:30:37] <mfiano> beach: in dpANS3, those words only appear in the glossary and CHARACTER
[18:30:55] <beach> clhs character
[18:30:55] <specbot> http://www.lispworks.com/reference/HyperSpec/Body/a_ch.htm
[18:31:06] <beach> The function character takes a character designator.
[18:31:21] <mfiano> Isn't that what he asked about?
[18:31:31] <beach> Oh, sorry.
[18:31:36] <beach> Misunderstood.
[18:31:59] <beach> That seems to be the only one, yes.
[18:32:49] <beach> But there is a proposal to have some functions take a character designator.
[18:33:22] <beach> Or so I thought.  :(
[18:34:02] <_death> functions like STRING< take string designators, but functions like CHAR< do not take designators.. maybe it's an oversight, or a performance thing.. maybe the concept of character designators was not born out of practicality
[18:34:43] <beach> Yeah, good question.  Performance sounds plausible.
[18:35:06] <beach> Nah, I take that back.
[18:35:49] <beach> In safe code, the type would need to be checked anyway, and it would almost always be a character, which is typically an immediate object.
[18:35:50] <_death> why? remember that characters are kinda like fixnums
[18:37:08] <beach> _death: Is that what you mean?  So we agree?
[18:37:40] <_death> agree on what? I think "performance reasons" is a good guess
[18:37:54] <beach> Ah, OK.
[18:38:30] <mfiano> Why woiuld a character be like a fixnum?
[18:38:48] <_death> but it's just a guess, I don't know that performance was ever considered in that context
[18:38:50] <beach> I think _death means that it is an immediate object.
[18:38:53] <mfiano> Doesn't extended-char not have an upper bound? Come to think of it, I don't even think base-char does
[18:39:22] <beach> But in safe code, it would look like (cond ((characterp object) <do the thing>) ((and (stringp object...))...) (t (error...))) So the test would almost always succeed.
[18:40:08] <beach> And the CHARACTERP test would be a tag-bit test, so very fast.
[18:40:24] <beach> ... plus, in safe code it would have to be checked anyway.
[18:40:42] <beach> So it is possible that performance was an argument, but I don't think it is a valid one.
[18:41:18] *** Joins: mingus (~jan-magnu@ti0135a400-2471.bb.online.no)
[18:41:41] <mfiano> It's also possible it was just overlooked, or not finalized due to time or other resources.
[18:41:49] <beach> Indeed.
[18:47:37] *** Joins: tfeb (~tfb@88.98.95.237)
[18:49:54] *** Quits: tfb (~tfb@88.98.95.237) (Ping timeout: 272 seconds)
[18:51:08] <_death> beach: btw note that the symbol X is also a character designators (by way of string designators ;)
[18:51:16] <_death> *designator
[18:51:58] *** Joins: lisp123 (~lisp123@5.30.23.247)
[18:55:56] <beach> Good point.  Doesn't change the performance issue much though.
[18:57:05] <_death> right.. for performance I initially thought about type derivation.. but it could be that in actual cases it doesn't make the deductions easy
[18:57:34] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 246 seconds)
[18:59:38] *** Quits: Th30n (~Th30n@cpe-188-252-156-252.zg5.cable.xnet.hr) (Quit: WeeChat 3.2)
[19:00:54] *** Quits: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431) (Quit: Leaving)
[19:02:19] *** Joins: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431)
[19:08:29] <beach> Though I think having those functions use character designators is outside the scope of WSCL.
[19:09:06] *** Joins: derelict (~derelict@user/derelict)
[19:10:27] <_death> I agree, it'd be too controversial
[19:25:45] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[19:25:50] *** Joins: lisp123 (~lisp123@5.30.23.247)
[19:29:35] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 268 seconds)
[19:30:07] *** Joins: char (~Srain@cpe-76-186-124-165.tx.res.rr.com)
[19:32:00] *** Joins: cage (~cage@dynamic-adsl-78-15-46-179.clienti.tiscali.it)
[19:34:01] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[19:36:26] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 258 seconds)
[19:36:37] <_death> what about something like saying (defstruct foo a) (foo-a (make-foo)) => NIL .. I'd also want the &aux story to be the same, but expect disagreement there ;)
[19:37:54] <Bike> that gets kind of weird if the slot has a type specified, but that's sort of already the case with array element types
[19:38:26] <_death> Bike: right, I'm not talking about that case..
[19:38:41] <Bike> what case are you talking about? when there's no :type specified?
[19:39:01] <_death> when there's no :type or even initial value.. (defstruct foo a)
[19:39:31] <Bike> that makes specifying :type t have different behavior from not specifying a type, which is a little weird
[19:39:44] <Bike> but i guess you have to specify an initial value to specify a type anyway... right
[19:39:45] <_death> well, if you specify :type, you have to give an initform
[19:45:49] <_death> another thing is allowing (loop repeat 5 for x = (foo) collect x) ... basically CL conformance pitfalls that implementations (even SBCL :) tend to be lenient about..
[19:48:18] *** Quits: jeosol (~jeosol@76-238-186-228.lightspeed.hstntx.sbcglobal.net) (Quit: Connection closed)
[19:50:47] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[19:52:21] <beach> _death: What is the issue with the loop?
[19:52:22] *** Quits: Lycurgus (~juan@cpe-45-46-140-49.buffalo.res.rr.com) (Quit: Exeunt)
[19:52:36] *** Quits: char (~Srain@cpe-76-186-124-165.tx.res.rr.com) (Ping timeout: 272 seconds)
[19:52:37] <_death> can't have repeat before for according to loop grammar
[19:53:13] <beach> Right.  Heh, I catch that in SICL loop, but I often don't see it.
[19:53:53] <beach> So Xach has been known to load SICL LOOP into SBCL to check systems in Quicklisp.
[19:54:30] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 272 seconds)
[19:54:41] <_death> when #lisp alerted me to that fact I went through much of my code and changed it.. it's not always a trivial change :/
[19:55:38] <beach> I agree, it complicates the code.
[19:55:56] <mfiano> That's not just repeat though iirc
[19:57:02] <_death> right, variable clauses before main clauses
[19:57:08] <mfiano> (loop for x = 42 then (1+ x) while (< x 48) for y = (+ x (random 10)) collect (list x y))
[19:57:18] <mfiano> or something would be unconforming
[19:59:02] <_death> there are other cases of obvious non-conformance in wild
[19:59:22] <mfiano> And I agree it's not always a trivial change. I remember when I first discovered that, which was several years into Lisp, it took me close to a week to comb through all my code and fix it
[19:59:47] <mfiano> and I probably have to go do that again soon, because most implementations are derived from MIT-LOOP...
[20:00:05] <_death> for example when people define print-object methods that don't return the object (and print-unreadable-object not being helpful there..)
[20:00:27] <Bike> eh? print-unreadable-object doesn't return the object? shit, you're right
[20:00:30] <Bike> well that's just hostile
[20:03:33] <_death> but that kind of proposal (about p-u-o) may be too "innovative"
[20:03:46] *** Parts: pranavats (3fba1d1b34@jabberfr.org) (Error from remote client)
[20:04:06] <_death> it contradicts the existing standard
[20:04:14] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 244 seconds)
[20:05:32] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[20:06:17] <beach> _death: It sounds like you should start another project, similar to WSCL, but with a slightly higher level of ambition.
[20:07:52] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-08-70-29-36-156.dsl.bell.ca) (Ping timeout: 258 seconds)
[20:07:54] <_death> beach: heh.. I accept these things.. CL isn't perfect, but it's good enough that I'd prefer not to change anything like that (WSCL is a good idea)
[20:09:20] <_death> besides, I am not an implementer or a company or language designer.. a mere user :)
[20:09:45] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[20:10:01] <beach> You are being too modest.
[20:12:58] *** Joins: azimut_ (~azimut@gateway/tor-sasl/azimut)
[20:16:38] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Ping timeout: 244 seconds)
[20:16:59] <pjb> Damned, I always wrote repeat first…
[20:21:00] <_death> so I think defstruct/loop proposals may belong to wscl's scope, because implementations cannot make different decisions without breaking lots of code already
[20:25:06] <beach> So you mean for instance that an error must be signaled when the loop clauses are in the wrong order?
[20:25:19] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Remote host closed the connection)
[20:25:31] *** Joins: scymtym (~user@ip-88-153-154-183.hsi04.unitymediagroup.de)
[20:25:44] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[20:25:47] <jackdaniel> I think that he meant it the other way around
[20:25:57] <mfiano> Is it within focus for WSCL to include additional functionality, such as #'mappend, or is it strictly limited to removing un-necessary freedoms and fixing errors?
[20:26:00] <jackdaniel> that is: require the implementation to handle these orders (which are right now incorrect)
[20:26:06] <_death> that could be one proposal (that has cost to users..).. another may be to propose to change the grammar so as to allow it (that may have cost to future implementers)
[20:26:27] <beach> That would be within the scope, but I want to start with practices that are widely agreed upon.
[20:26:52] <beach> Yes, I see.
[20:28:20] <pjb> beach: at least a warning.  There's a reason for the order.
[20:29:48] <_death> beach: as far as I can tell, that practice (allowing it) is widely implemented
[20:29:59] <beach> OK.  That one won't be as trivial to get consensus about as the others. :)
[20:30:18] <beach> _death: Only because everyone is using MIT LOOP by default.
[20:30:29] <jackdaniel> does ccl loop derive from mit?
[20:30:37] <_death> right.. SICL's clean room loop doesn't, I suppose
[20:30:45] <beach> _death: Correct.
[20:31:01] <beach> jackdaniel: I don't know.  I should not have said "everyone".
[20:31:23] <mfiano> It would be nice if WSCL could be an extension like PLN, and pushing :WSCL to *FEATURES* would most definitely signal an error condition.
[20:31:34] <mfiano> For supporting implementations
[20:32:16] <_death> jackdaniel: looks that way
[20:32:24] <jackdaniel> thanks
[20:32:45] <mfiano> The loop order thing has been one thing that really bothered me over the years.
[20:33:03] <jackdaniel> mfiano: calling (push :wscl *features*) would signal a condition? or after pushing wscl invalid order in loop would cause the condition?
[20:33:10] <mfiano> The latter
[20:33:18] <mfiano> It's a strict conformance problem, not undefined behavior, iirc
[20:33:41] <jackdaniel> I think that this would be bad for maintanance - pushing to features changing the implementation behavior
[20:33:52] *** Quits: cranium (~cranium@user/cranium) (Quit: Leaving)
[20:34:23] <mfiano> The alternative is users continue to take on that burden.
[20:35:11] <beach> It's an interesting idea though.  Worth thinking about.
[20:35:45] <_death> but I'd support proposal ALLOW.. so SICL implementers will have to pay the cost ;)
[20:35:52] <jackdaniel> there are other alternatives. One is to embrace any order, another is to add a build flag to the implementation, or even have a function that changes the loop behavior
[20:36:11] <jackdaniel> but changing a features list by a user affecting the macroexpansion sounds like a terrible kludge
[20:36:24] <mfiano> That's fair.
[20:37:05] *** Quits: OlCe (~user@lfbn-nic-1-123-149.w2-15.abo.wanadoo.fr) (Ping timeout: 252 seconds)
[20:38:32] <mfiano> I do agree we do have to be careful about implementor maintenance cost; the cost could outweigh the benefit, especially in small CL-land...I just wish for something better from a user-standpoint, and not limited to loop order of course
[20:40:02] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-10-70-54-112-49.dsl.bell.ca)
[20:40:50] <jackdaniel> (defmacro loop (&rest args) `(do ,@args)) ;)
[20:41:47] <_death> did you push :loop-di-doop into *features*?
[20:45:22] *** Joins: elf_fortrez (~elf_fortr@adsl-72-50-4-118.prtc.net)
[20:48:55] *** Joins: lisp123 (~lisp123@5.30.23.247)
[20:50:13] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 244 seconds)
[20:53:18] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[20:58:10] *** Quits: heisig (~heisig@p57942813.dip0.t-ipconnect.de) (Quit: Leaving)
[21:01:11] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[21:01:35] *** Joins: lad (~lad@user/lad)
[21:13:39] *** Quits: derelict (~derelict@user/derelict) (Ping timeout: 255 seconds)
[21:18:17] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[21:21:18] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 255 seconds)
[21:21:23] *** Quits: Tomte (~th@p200300db9f0f0f005ca17ba2dabfdd7d.dip0.t-ipconnect.de) (Quit: Leaving)
[21:23:56] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[21:24:13] *** Joins: mister_m` (~user@c-73-110-154-209.hsd1.il.comcast.net)
[21:30:54] *** Quits: Equill (~Equill@1.red-83-37-200.dynamicip.rima-tde.net) (Quit: KVIrc 5.0.0 Aria http://www.kvirc.net/)
[21:40:33] *** Joins: lisp123 (~lisp123@5.30.23.247)
[21:45:07] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 245 seconds)
[22:01:00] *** Quits: tfeb (~tfb@88.98.95.237) (Quit: died)
[22:15:19] *** Quits: elf_fortrez (~elf_fortr@adsl-72-50-4-118.prtc.net) (Ping timeout: 246 seconds)
[22:30:50] *** Joins: Alfr (~Alfr@user/alfr)
[22:32:09] *** Joins: lisp123 (~lisp123@5.30.23.247)
[22:33:14] *** Quits: theBlackDragon (~dragon@fvwm/admin) (Quit: Boom.)
[22:36:43] *** Joins: char (~Srain@cpe-76-186-124-165.tx.res.rr.com)
[22:40:57] *** Quits: char (~Srain@cpe-76-186-124-165.tx.res.rr.com) (Ping timeout: 255 seconds)
[22:44:27] *** Joins: char (~Srain@cpe-76-186-124-165.tx.res.rr.com)
[22:51:00] *** Quits: yitzi (~yitzi@173-27-106-188.client.mchsi.com) (Quit: Leaving)
[23:03:00] *** Quits: char (~Srain@cpe-76-186-124-165.tx.res.rr.com) (Ping timeout: 255 seconds)
[23:22:19] *** Joins: theBlackDragon (~dragon@fvwm/admin)
[23:24:07] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[23:25:50] *** Quits: shka (~herr@109.231.62.239) (Ping timeout: 252 seconds)
[23:25:59] *** Joins: lisp123 (~lisp123@5.30.23.247)
[23:30:30] *** Quits: lisp123 (~lisp123@5.30.23.247) (Client Quit)
[23:39:24] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-10-70-54-112-49.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[23:40:55] *** Joins: manicennui (uid349235@id-349235.tinside.irccloud.com)
[23:41:21] *** Quits: Oddity (Oddity@user/oddity) (Remote host closed the connection)
[23:48:56] *** Joins: lisp123 (~lisp123@5.30.23.247)
[23:58:30] *** Joins: karlosz (~karlosz@router.cloyne.org)
