[00:08:59] *** Quits: rgrinberg (~textual@2806:101e:7:6bed:d154:b93f:c8:b39) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[00:28:38] *** Quits: olle (~olle@i5E866D80.versanet.de) (Ping timeout: 250 seconds)
[00:33:37] *** Joins: jlrnick (~josephler@2a01cb040a15940040c925505f5c78b2.ipv6.abo.wanadoo.fr)
[01:00:36] <d_bot> <Et7f3> which kind of symlink ? a real one or a shortcut
[01:01:46] *** Joins: rgrinberg (~textual@2806:101e:7:6bed:d154:b93f:c8:b39)
[01:02:02] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[01:04:22] *** Quits: jlrnick (~josephler@2a01cb040a15940040c925505f5c78b2.ipv6.abo.wanadoo.fr) (Ping timeout: 260 seconds)
[01:06:49] *** Joins: sheb (~sheb@31.223.228.71)
[01:11:03] *** Quits: bartholin (~bartholin@109.53.6.15) (Ping timeout: 256 seconds)
[01:24:35] *** Joins: bartholin (~bartholin@109.53.1.3)
[01:25:10] *** Joins: pgeorgi (~pgeorgi@2001:470:69fc:105::54)
[01:41:57] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Remote host closed the connection)
[01:42:06] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[02:11:56] *** Joins: oriba (~oriba@dynamic-077-183-110-253.77.183.pool.telefonica.de)
[02:31:07] *** Quits: rgrinberg (~textual@2806:101e:7:6bed:d154:b93f:c8:b39) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[02:33:47] <lyxia> A real symlink
[02:35:33] <d_bot> <Et7f3> What is full error ? Try the open_process_full_args also
[02:54:44] *** Quits: bartholin (~bartholin@109.53.1.3) (Quit: Leaving)
[03:03:57] *** Quits: Tuplanolla (~Tuplanoll@91-159-68-166.elisa-laajakaista.fi) (Ping timeout: 240 seconds)
[03:20:03] <lyxia> "The system cannot execute the specified program." on stderr of the process
[03:20:59] <lyxia> open_process_full_args gives me an exception Unix_error(_, "create_process", "path/to/a.native")
[03:38:29] *** Quits: Soni (~quassel@autistic.space) (Ping timeout: 256 seconds)
[03:52:15] *** Joins: rgrinberg (~textual@187.223.115.137)
[04:10:23] *** Joins: Soni (~quassel@autistic.space)
[04:20:25] *** Quits: Soni (~quassel@autistic.space) (Ping timeout: 256 seconds)
[04:24:41] *** Joins: Soni (~quassel@autistic.space)
[04:48:03] *** Joins: spip (~bobo@37.170.83.19)
[04:49:19] *** Quits: bobo_ (~bobo@37.168.31.206) (Ping timeout: 256 seconds)
[05:02:16] *** Quits: oriba (~oriba@dynamic-077-183-110-253.77.183.pool.telefonica.de) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
[06:25:39] *** Quits: chrisz (txw14upu4t@55d470b9.access.ecotel.net) (Ping timeout: 256 seconds)
[06:27:02] *** Joins: chrisz (grzd2shihf@55d401d7.access.ecotel.net)
[07:13:02] *** Quits: rgrinberg (~textual@187.223.115.137) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[07:32:57] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 276 seconds)
[07:38:44] *** Joins: gravicappa (~gravicapp@145.255.1.142)
[07:39:13] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[07:48:28] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 250 seconds)
[08:00:50] *** Joins: mbuf (~Shakthi@171.61.147.232)
[08:02:10] *** Joins: rgrinberg (~textual@2806:101e:7:6bed:540b:bd79:8d25:836)
[08:24:40] <ns12> Hello, is there a downloadable version of the OCaml API documentation? https://ocaml.org/api/index.html
[08:36:39] *** Quits: szkl (uid110435@id-110435.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[08:37:31] <lyxia> There are man pages that come with an OCaml installation.   man Stdlib
[08:40:20] <ns12> lyxia: Thanks. Section "3o" has all the OCaml library documentation.
[08:40:20] <ns12> Is there a HTML version?
[10:06:57] *** Quits: zebrag (~chris@user/zebrag) (Quit: Konversation terminated!)
[10:20:00] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 276 seconds)
[10:26:11] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[10:40:12] *** Quits: rgrinberg (~textual@2806:101e:7:6bed:540b:bd79:8d25:836) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[10:44:43] <williewillus> ns12: you could try cloning the ocaml/ocaml.org repo and running `make`
[10:45:25] *** Joins: Everything (~Everythin@37.115.210.35)
[10:46:15] <williewillus> ns12: oh actually, it's already prepackaged. See the top of this page https://ocaml.org/releases/4.13/htmlman/index.html
[11:01:29] <d_bot> <antron> ns12: a slightly different option is to install ocp-browser, which gives you a neat way to find most of the docs for your whole switch in the terminal
[11:01:44] *** Parts: Everything (~Everythin@37.115.210.35) ()
[11:08:35] *** Joins: szkl (uid110435@id-110435.uxbridge.irccloud.com)
[11:15:28] *** Quits: salkin-mada (~salkin@84.212.156.62) (Quit: salkin-mada)
[11:31:48] <ns12> williewillus: I don't think that download includes https://ocaml.org/api/index.html
[11:32:42] <d_bot> <NULL> https://ocaml.org/releases/4.13/api/index.html ?
[11:33:36] <ns12> NULL: Yeah, but where's the download button for that?
[11:34:14] <ns12> antron: Thanks for the suggestion. I am already using ocp-browser. I am looking for a HTML version that I can carry around in a thumbdrive.
[11:34:59] <ns12> NULL: https://ocaml.org/releases/4.13/ocaml-4.13-refman-html.tar.gz does not seem to include https://ocaml.org/releases/4.13/api/index.html
[11:35:50] <d_bot> <NULL> /htmlman/libref/index.html ?
[11:39:10] *** Joins: Tuplanolla (~Tuplanoll@91-159-68-166.elisa-laajakaista.fi)
[11:40:19] <ns12> NULL: Ah okay. Thank you.
[11:41:14] <d_bot> <NULL> Why it isn't located at the same relative path is a good question
[11:42:30] <ns12> I guess I got confused by (1) the different design between the online version and the download version (e.g. lack of sidebar navigation), (2) the different relative path.
[13:19:37] *** Joins: mro (~mro@port-92-195-128-234.dynamic.as20676.net)
[13:36:23] *** Joins: jlrnick (~josephler@gw.lipn.univ-paris13.fr)
[13:57:53] *** Quits: mro (~mro@port-92-195-128-234.dynamic.as20676.net) (Remote host closed the connection)
[13:58:27] *** Joins: mro (~mro@port-92-195-128-234.dynamic.as20676.net)
[14:14:54] *** Joins: olle (~olle@i5E866D87.versanet.de)
[14:15:21] *** Quits: mro (~mro@port-92-195-128-234.dynamic.as20676.net) (Remote host closed the connection)
[14:15:33] *** Joins: mro (~mro@port-92-195-128-234.dynamic.as20676.net)
[14:18:55] <ns12> Hello, in OCaml, is it possible to limit a integer within a range? For example, value "x" should be an integer between 0 and 10 inclusive. "x : int" is not appropriate because it also includes integers outside the range (e.g. -2, -1, 11, 12, etc.).
[14:19:47] <ns12> Of course, I could try to do something like "type n = One | Two | Three | Four | Five | ...", but this quickly becomes tedious when the range is larger.
[14:20:17] <ns12> Besides, this would be wholly impractical for ranges of real numbers.
[14:21:13] <octachron> You can define a private int type that can only be constructed through a smart constructor that enforces that invariant.
[14:22:21] <ns12> octachron: What is a "smart constructor"? Does it only enforce the invariant at runtime?
[14:23:05] <olle> ns12: Type-level Peano numbers, if you're "that" kind of person :)
[14:23:27] <olle> ns12: But in general, no. See F* lang for comparison.
[14:23:59] <ns12> olle: Does this require a more sophisticated type system? What is the name of the type system that can do this?
[14:24:40] <olle> ns12: Multiple different type systems can do it.
[14:25:09] <olle> ns12: One name is "type refinement"
[14:25:33] <olle> Since "int" is refined to "int between x and y"
[14:25:42] <ns12> octachron:  https://wiki.haskell.org/Smart_constructors Is that the "smart constructor" you are referring to? Looks like it only enforces the invariants at runtime, not at compile time.
[14:25:44] <olle> But then you have to carry around a proof in one way or the other, I think
[14:27:09] <ns12> Besides F*, are there any other languages that can do this?
[14:27:58] <olle> ns12: Yes, multiple. Agda, Idris, Coq, to name some.
[14:29:54] <olle> "OCaml with its module system is more or less system Fomega. The fun keyword is the lambda and the functor keyword is the big lambda"
[14:30:03] <olle> Hm
[14:30:31] <d_bot> <NULL> This has some serious caveats
[14:30:42] <olle> https://www.tweag.io/blog/2021-02-05-refinement-types/
[14:30:55] <olle> "Integrating refinement and dependent types: a fellowship report"
[14:30:58] <olle> Etc etc
[14:33:53] <ns12> Thank you for the information.
[14:40:42] <olle> np
[14:58:25] *** Joins: bartholin (~bartholin@158.110.70.210)
[15:21:06] *** Quits: mro (~mro@port-92-195-128-234.dynamic.as20676.net) (Remote host closed the connection)
[15:25:55] *** Quits: xgqt (~xgqt@gentoo/developer/xgqt) (Ping timeout: 256 seconds)
[15:26:22] *** Joins: xgqt (~xgqt@gentoo/developer/xgqt)
[15:27:52] *** Joins: mro (~mro@2002:5cc3:80ea:0:d68:158b:dd6e:9a2d)
[15:29:56] *** Joins: foo303 (~foo303@212.252.83.133)
[15:31:47] <octachron> ns12, yes but with private types, OCaml can at least enforce that you can only construct values through the smart constructors.
[15:32:39] <ns12> Thanks octachron for the practical advice.
[15:34:55] <octachron> In some very very specific case, it might be useful to use GADTs or private type with type-level integer as phantom parameter, but the complexity cost is sharp.
[15:43:23] *** Quits: mro (~mro@2002:5cc3:80ea:0:d68:158b:dd6e:9a2d) (Remote host closed the connection)
[15:56:07] *** Quits: infinity0 (~infinity0@occupy.ecodis.net) (Ping timeout: 268 seconds)
[16:01:19] *** Joins: infinity0 (~infinity0@occupy.ecodis.net)
[16:04:27] *** Quits: bartholin (~bartholin@158.110.70.210) (Ping timeout: 256 seconds)
[16:12:57] *** Quits: jlrnick (~josephler@gw.lipn.univ-paris13.fr) (Ping timeout: 256 seconds)
[16:16:10] *** Joins: bartholin (~bartholin@158.110.70.210)
[16:16:12] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 276 seconds)
[16:46:37] *** Quits: bartholin (~bartholin@158.110.70.210) (Ping timeout: 256 seconds)
[16:47:55] *** Joins: bartholin (~bartholin@158.110.70.210)
[16:48:51] *** Joins: bobo_ (~bobo@37.165.25.142)
[16:49:13] *** Quits: spip (~bobo@37.170.83.19) (Ping timeout: 256 seconds)
[16:56:20] <d_bot> <EduardoRFS> Hmmm would changing OCaml ABI so that return tuples are not allocated lead to any performance regression?
[17:22:05] *** Quits: bartholin (~bartholin@158.110.70.210) (Ping timeout: 256 seconds)
[17:30:30] <olle> I had an idea on how to extend the function core, when it's not possible to easily lift out side-effects
[17:30:41] <olle> That is, side-effects are tangled in business logic
[17:30:41] <zozozo> EduardoRFS : that'd depend on how the tuples are used: if they are deconstructed instantly upon return, then it would help, but if the tuple is sued as a value, you'd need to allocate it anyway, so it's not clear it's useful to do that in all cases
[17:30:50] <olle> functional core*
[17:31:01] <zozozo> see https://github.com/ocaml/RFCs/blob/unboxed-types/rfcs/unboxed-types.md for a nicer way of controlling that for programmers
[17:32:02] <olle> E.g., for some side-effecst, you don't need to see the result, and it's safe to delay them. So you can put them in a queue to be executed later in the imperative shell (so called).
[17:32:41] <olle> Is the OCaml effect system merged? So you can jump back and forth, like with yield/generator?
[17:33:46] *** Joins: bartholin (~bartholin@158.110.70.210)
[17:36:32] <d_bot> <Bluddy> yes but only via a library. the language doesn't include the constructs yet.
[17:44:23] *** Quits: _tjr_ (~tjr@233.ip-144-217-92.net) (Quit: quitting)
[17:45:32] <olle> OK, thanks Bluddy
[17:45:38] *** Joins: _tjr_ (~tjr@233.ip-144-217-92.net)
[17:49:01] <sadiq> olle, it's merged to trunk but not part of a release yet (it'll come with 5.0)
[17:56:22] <d_bot> <VPhantom> zozozo: Has there been any actual work done on unboxed types or is it just the RFC so far?
[17:57:40] <sadiq> if you're interested in any of this stuff I highly recommend listening to Stephen Dolan's episode on Signals and Threads.
[17:57:59] <sadiq> (is also covers the work happening on local allocation and unboxed types)
[17:58:21] *** Quits: gravicappa (~gravicapp@145.255.1.142) (Ping timeout: 256 seconds)
[17:58:45] <zozozo> Vphantom : mainly the RFC I think, but actually, most of the backend of the compiler is already more or less able to handle unboxed types, the main hurdle is having a user interface to control that, or adding heuristics in flambda to automatically do that, but it's not easy to do
[17:59:19] <zozozo> (well, unboxed records, not the unboxed types and packing suggested in the RFC)
[17:59:49] *** Quits: bartholin (~bartholin@158.110.70.210) (Ping timeout: 256 seconds)
[18:01:11] *** Parts: lyxia (~lyxia@poisson.chat) (WeeChat 3.3)
[18:03:29] *** Joins: bartholin (~bartholin@158.110.70.210)
[18:04:30] <d_bot> <VPhantom> I see. I just like to see those kinds of milestones which make OCaml's run-time performance inch closer and closer to C++/Rust over the years.
[18:06:26] *** Quits: foo303 (~foo303@212.252.83.133) (Quit: Leaving)
[18:09:03] <companion_cube> yeah good luck with that
[18:09:16] *** Joins: gwizon (~gwizon@ool-45798d64.dyn.optonline.net)
[18:15:07] *** Joins: salkin (~salkin@138.251.92.62.static.cust.telenor.com)
[18:34:43] *** Joins: mro (~mro@port-92-195-128-234.dynamic.as20676.net)
[18:37:10] *** Quits: bartholin (~bartholin@158.110.70.210) (Ping timeout: 260 seconds)
[18:45:01] <olle> :D
[18:45:39] <olle> Like C# is a more realistic target
[18:49:05] *** Joins: bartholin (~bartholin@158.110.70.210)
[18:51:29] <d_bot> <VPhantom> For real-life work (i.e. not synthetic benchmarks for algorithm X, but stuff that includes some amount of I/O) I suspect that OCaml is already pretty darn close.
[18:55:30] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[18:55:37] <Corbin> olle: Like monads?
[18:57:25] *** Joins: AeroNotix (~xeno@185.107.67.252)
[18:57:41] <companion_cube> yeah depends what, really
[18:57:48] <companion_cube> for application stuff, probably good enough
[18:59:48] <olle> Corbin: Monads what? Wrapping side-effects? Something like it, but in a more imperative fashion.
[19:00:11] <olle> Assuming there is already a legacy code base that neeeds to be made more "functional core"
[19:01:03] <companion_cube> I never understood that
[19:01:10] <companion_cube> for me it's imperative core, functional sheel :D
[19:01:13] <olle> I figured there are three use-cases. 1) Side-effects can be delayed in a queue; 2) Side-effects depend on each other's success; 3) You need to get the result of the side-effect at once.
[19:01:22] <olle> companion_cube: Sheel? Pun?
[19:01:26] <companion_cube> no
[19:01:47] <companion_cube> write the details in imperative, but limit side effects in scope
[19:01:57] <companion_cube> so that the larger picture is mostly made of immutable values
[19:01:59] <olle> companion_cube: It's related to unit testing and mocking.
[19:02:11] <companion_cube> I do neithe
[19:02:13] <companion_cube> r
[19:02:14] <olle> You do integrity tests for the shell and unit tests for the core
[19:02:17] <olle> :D
[19:04:31] <companion_cube> zozozo: I have an idea of a nice showcase for unboxed records :p
[19:04:36] <companion_cube> it's called slices
[19:06:13] <zozozo> haha
[19:06:30] <zozozo> that'd be nice indeed
[19:07:28] <olle> What's a slice?
[19:08:18] *** Joins: jlrnick (~josephler@gw.lipn.univ-paris13.fr)
[19:08:28] <companion_cube> a slice of array/bytes
[19:08:31] <zozozo> olle: a pointer/ref to a buffer/array/indexable thing + a start offset + a length/end offset
[19:09:26] <companion_cube> in other languages you can typically just point in the middle and store the length, bypassing the pointer to the beginning
[19:09:31] <companion_cube> but that wouldn't work with the GC
[19:10:54] <d_bot> <VPhantom> @companion_cube For basically anything I've been doing for my client so far, OCaml beats the sh*t out of Perl, that's for sure. An order of magnitude here, up to two there… Heck, even `ocaml-protoc` how it was 2 years ago was already 2.5x faster than `Google::ProtocolBuffers::Dynamic` in my tests, and that's despite the latter making judicious use of Google's C++ parser for the IDL and the uPB library for encoding/decoding.
[19:11:58] <companion_cube> I mean, sure, but perl isn't exactly the fastest :D
[19:12:16] <companion_cube> we should compare with Go, java, etc. rather
[19:12:25] <olle> Is Perl even compiled...?
[19:12:28] <companion_cube> nope
[19:12:30] <d_bot> <VPhantom> (`ocaml-protoc` was also a tad faster than `protobuf.js` which, interestingly, was still twice as fast as NodeJS's built-in JSON module for comparable JSON structures.)
[19:12:37] <olle> Can't compare scripting lang with compiled lang, that's silly. :)
[19:12:37] <companion_cube> :D
[19:13:40] <d_bot> <VPhantom> For sure. But my point is that for business use at least, compared to the other popular options (Ruby, Perl, PHP, JavaScript), OCaml performs admirably already.
[19:13:54] <companion_cube> still forgetting java :p
[19:14:09] <companion_cube> (and C#)
[19:14:20] <d_bot> <VPhantom> Java I put in the same bin as C++ and Rust nowadays because it _finally_ has decent performance at run-time.
[19:14:34] <d_bot> <VPhantom> …and .NET is dead to me. 😛
[19:14:42] <companion_cube> I'd argue that there's a bin in between the dynamic langs, and C++/rust
[19:15:03] <companion_cube> like {C++,rust} < {java,go,OCaml,Haskell} < {python,perl,ruby,php}
[19:15:06] <d_bot> <VPhantom> I know that F# outperforms OCaml but I'm willing to live with that in order to avoid .NET, Windows and Microsoft in general. 😛
[19:15:09] <companion_cube> JS between somewhere in the middle
[19:15:34] <d_bot> <VPhantom> JS sometimes performs in that middle bin.
[19:16:29] <olle> lol @ java + performance, just don't collect?
[19:16:32] <companion_cube> exactly, depends on a lot of things
[19:16:56] <olle> Koka 2 is the interesting case
[19:17:40] <Corbin> Y'all aren't serious, right? Hopefully y'all want to compare specific implementations and runtimes, not languages. Otherwise ECMAScript (browser) < Raku < ECMAScript (Rhino) < Perl 5!?
[19:18:59] <Corbin> (Perl 5 and Raku are difficult to compile for the same reason: arity is undecideable until runtime!! But otherwise they are not intrinsically slow.)
[19:19:16] <d_bot> <VPhantom> I just wish more people realized that a compiled language doesn't have to mean "twice as expensive to develop with". (i.e. OCaml is a joy to use for the most part.) I had to deal with so many things written in scripting languages and grinding to a crawl under low to moderate load, it's not even funny. It's one of the reasons I'm scrapping our Perl stuff instead of just trying to improve it.
[19:19:36] <companion_cube> Corbin: in general I'd consider the main implementations
[19:19:41] <companion_cube> or bastest
[19:19:47] <companion_cube> so, "JS" here mostly means V8
[19:20:02] <Corbin> companion_cube: So it's a popularity contest, not an actual quest for quality? It's important to be crisp about this sort of thing.
[19:20:14] <companion_cube> no, it's also a contest where you consider the realistic options
[19:20:31] *** Quits: mro (~mro@port-92-195-128-234.dynamic.as20676.net) (Remote host closed the connection)
[19:20:33] <companion_cube> if you write JS in the browser, well, you also have to account for other browsers, so perf claims are weaker
[19:20:40] <companion_cube> outside the browser it's almost all V8
[19:20:46] <companion_cube> so you can approximate to V8
[19:20:48] <AeroNotix> attempting to bring in OCaml to an organization would be a pretty difficult thing these days
[19:21:05] <Corbin> That's the game-console/PC dichotomy. This does indeed sound like popularity-contest logic.
[19:21:22] <AeroNotix> if the organization has already coalesced around some other platform, OCaml would be a hard-sell. There are plenty of trendier platforms most organizations would prefer to evaluate over OCaml.
[19:21:32] <d_bot> <VPhantom> In my case we're small enough that I was able to sell OCaml on the promise that the result would be an order of magnitude easier to maintain than our current Perl ball of strings.
[19:21:48] <AeroNotix> entirely depends on the number and quality of developers
[19:21:58] <d_bot> <VPhantom> Just one for now, in our case. 😎
[19:22:16] <companion_cube> Corbin: what's the issue with PC/console?
[19:22:35] <companion_cube> if you write a game and aim at many platforms, you still have to consider the weakest ones
[19:22:56] <d_bot> <VPhantom> Can you not just do less in the weaker ones, instead of leveling by the base?
[19:23:09] <Corbin> companion_cube: When people make a video game, they can either target a console first, or PC first. PC has more horsepower overall, but has very diverse target machines, so that it's easy to guarantee maximum performance (with a nice video card) but hard to guarantee a minimum.
[19:23:23] <companion_cube> unless you ask for a minimum requirement
[19:23:31] <companion_cube> which has been done for decades
[19:23:39] <Corbin> Targeting console first flips this around; the console is typically weak, but mass-produced. Easy to get a performance floor, hard to reach the ceiling.
[19:24:36] <Corbin> ...It's common knowledge that minimum requirements for PCs do not provide a playable experience. To the point where "minimum" and "playable" are sometimes distinct sets of requirements. "minimum" usually means WRT some sort of testing or certification programme; could be as simple as "has no viruses" and "boots".
[19:25:08] <Armael> 🤔
[19:25:14] *** Joins: gravicappa (~gravicapp@145.255.1.142)
[19:25:14] <d_bot> <darrenldl> "It has to terminate"
[19:25:46] <companion_cube> I've played with the minimum requirements in the past
[19:25:52] <companion_cube> for some games it works, but with lower settings (ofc)
[19:26:19] <companion_cube> anyway, what's the relation to what we were saying?
[19:26:48] <d_bot> <VPhantom> …and that's why I haven't played a PC game since Grand Prix III in the late 1990s. Keeping up with requirements seems difficult (on a budget, anyway), plus most titles require a certain operating system, although I've been surprised to take a peek at Steam and find that many titles did have a Linux version these days.
[19:26:49] <Corbin> It's a continuation of the software-engineering discussion.
[19:27:25] *** Joins: mro (~mro@port-92-195-128-234.dynamic.as20676.net)
[19:27:29] <companion_cube> but how does it relate to language performance?
[19:28:06] <Corbin> "language performance" is meaningless and I was hoping to illustrate the depth of the incorrectness of this sort of memetic thinking with a real-world example.
[19:28:11] <d_bot> <VPhantom> I think it relates to how in our use case, OCaml is basically as performant as C++ or Rust, compared to what we had before.
[19:28:21] <Corbin> Because, as you surely know, some games use *the exact same codebase* on both PC and console.
[19:28:59] <olle> "meaningless" is a bit strong
[19:29:18] <Corbin> VPhantom: I bet you can be more specific; by "basically as performant", you mean that a series of chosen benchmarks didn't change much, and those benchmarks were chosen relative to your actual operations?
[19:29:52] <companion_cube> language performance is very much meaningful
[19:30:23] <d_bot> <VPhantom> I haven't done more than scratching the surface yet but the difference is pretty obvious in what I've dealt with so far. The whole premise of "use any scripting language you want, hardware improves faster than the time you would've wasted using a compiled language" is garbage in my experience.
[19:30:33] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[19:30:40] <Corbin> companion_cube: Provide one (1) metric on formal languages which is a correspondence/projection of performance, please. I'd love to hear how this works.
[19:30:42] <companion_cube> every language generally has at most a handful of implementations, so you already get a performance ceiling for them
[19:31:13] <companion_cube> and given how modern machines work, there's no way in hell a normal python program will be as fast as a normal rust or C++ program
[19:31:21] <Corbin> Sure, when using Somebody Else's Code. But that's not the only mode of software engineering, and it sounds like most of y'all are talking about corporate contexts...
[19:31:25] <companion_cube> you can contrieve some weird counter-example but that's just fact
[19:31:44] <companion_cube> no, about real programmers writing real code using existing languages' implementations
[19:31:49] *** Quits: mro (~mro@port-92-195-128-234.dynamic.as20676.net) (Remote host closed the connection)
[19:31:57] <companion_cube> I'm not saying there's a maximum theoretical performance
[19:32:02] <companion_cube> but very much a concrete one
[19:32:10] <companion_cube> and even then, python is slow by design
[19:32:21] <companion_cube> JS is, too, but a ton of efforts has been spent to make it less slow
[19:32:42] <Corbin> In the real world, employers typically have custom toolchains and languages which are internal to their operations. I had to learn like three DSLs at Google. I wrote a compiler at HPE. We are not in a world where corporations only use third-party code; they write their own tools.
[19:32:58] <d_bot> <VPhantom> The "use whatever language, performance is fine" premise is how you get startups like `rally.io` which are sluggish to use from day one. It's clear they probably use JS end-to-end, lots of flavor-of-the-month frameworks piled on top of each other, etc.
[19:33:19] <companion_cube> yeah and did google manage to make python fast?
[19:33:21] <companion_cube> the answer is: no :D
[19:33:26] <d_bot> <VPhantom> 😛
[19:33:27] <d_bot> <froyo> "language overhead" is very much real
[19:33:35] <companion_cube> and they *tried*
[19:33:36] *** Joins: mro (~mro@port-92-195-128-234.dynamic.as20676.net)
[19:33:37] <companion_cube> several times
[19:33:54] <d_bot> <VPhantom> Wasn't there stuff like "cpython" or something, which compiled Python to binary?
[19:33:58] <d_bot> <darrenldl> good try(?) ig
[19:34:01] <companion_cube> similarly, for OCaml, we have good perf. But we have a ceiling
[19:34:09] <companion_cube> the compiler won't emit SIMD, so we just can't do it
[19:34:25] <companion_cube> so in some cases C++ or rust will be 8 or 16 times faster, unavoidably
[19:34:27] *** Quits: mro (~mro@port-92-195-128-234.dynamic.as20676.net) (Remote host closed the connection)
[19:34:49] <Corbin> companion_cube: PyPy is fast. CPython has political obstacles to becoming fast; what were you going to blame architectually?
[19:34:52] <d_bot> <VPhantom> The GC bit and the boxing are definitely an unavoidable overhead. Very thin compared to the abstractions in scripting language runtimes though.
[19:35:03] <d_bot> <froyo> companion_cube: i remember there was a talk on discuss about that
[19:35:16] <d_bot> <froyo> simd I mean
[19:35:38] <d_bot> <darrenldl> 8 - 16x speed up usually is in data encoding signal processing stuff fortunately, so not the most common thing fortunately
[19:35:48] <d_bot> <VPhantom> I forgot about those kinds of extensions. I guess for some very specific uses cases they can really help.
[19:35:53] <companion_cube> pypy is not fast
[19:35:58] <companion_cube> pypy is less slow than cpython
[19:36:28] <companion_cube> @darrenldl https://simdjson.org/
[19:36:31] *** Joins: Anarchos (~Anarchos@88.168.112.216)
[19:36:34] <companion_cube> it's an arcane art, but it exists
[19:36:57] <d_bot> <darrenldl> python was "fast enough" for youtube, do pretty much music to ears
[19:37:04] *** Joins: rgrinberg (~textual@2806:101e:7:6bed:540b:bd79:8d25:836)
[19:37:16] <d_bot> <monk> Why can’t OCaml leverage simd optimization
[19:37:22] <d_bot> <monk> ?
[19:37:22] *** Quits: mbuf (~Shakthi@171.61.147.232) (Quit: Leaving)
[19:37:31] <d_bot> <darrenldl> companion_cube: ah, simdjson...
[19:38:18] <companion_cube> @monk because the compiler doesn't produce simd instructions
[19:38:20] <companion_cube> 🤷
[19:38:29] <companion_cube> which is a valid choice, it's horribly complicated
[19:38:56] <d_bot> <darrenldl> or be go, and have go asm : D
[19:40:43] <olle> companion_cube: That's why you should compile to C :D
[19:41:16] <Corbin> companion_cube: So, here's the problem with that logic: Cammy in RPython is much faster than Cammy in OCaml. If I were to confuse implementations with languages, I would have to conclude that RPython's faster than OCaml.
[19:41:31] <d_bot> <darrenldl> afaict the GB/s type of simd code has always been crafted by experts
[19:41:42] <Corbin> Since PyPy is just Python in Python, and CPython is Python in C, I'd similarly have to conclude that Python's faster than C.
[19:41:47] <companion_cube> Corbin: possibly?
[19:42:01] <companion_cube> but you can't conclude from one sample point
[19:42:44] <companion_cube> you can also argue that pypy and cpython aren't doing the same thing
[19:43:04] <Anarchos> what is the autotools command to rebuild the configure script from configure.ac ? I tried autoconf, but i get some errors like «error: possibly undefined macro: AC_MSG_NOTICE»
[19:45:54] *** Joins: mro (~mro@2002:5cc3:80ea:0:d68:158b:dd6e:9a2d)
[19:50:16] <Corbin> companion_cube: Well, such an argument would have to be architectural. PyPy and CPython do the same sort of bytecode compilation, both have GCs, etc. (Also counterexamples *are* usually argued from just one point?)
[19:53:59] <companion_cube> doesn't pypy have a JIT? 🤔
[19:54:16] <companion_cube> well "A is faster than B" is not a rigid forall, grr
[19:54:24] <companion_cube> nothing in life really is (including this statement)
[19:55:40] <Corbin> companion_cube: PyPy is written in RPython. RPython's toolchain can automatically turn interpreter-shaped functions into JITs, but this is not part of the architecture of the interpreter itself.
[19:56:24] <Corbin> And yes, my point is that "A is faster than B" is a bogus belief with A and B are formal languages. We can prove things formally, but this belief seems too facile to actually be made formal.
[19:56:29] <companion_cube> so pypy+rpython is a JIT
[19:56:43] <companion_cube> yes, and we don't implement in formal languages
[19:57:03] <Corbin> So stop saying "language"! Say "platform", "framework", "system", or "environment".
[19:57:28] <companion_cube> that's incredibly vague
[19:57:37] <companion_cube> OCaml is a language, not a "system"
[19:57:49] <Corbin> RPython provides JITs, but the JIT isn't why Cammy is faster in RPython than in OCaml. *That* is entirely due to how OCaml's compiler (doesn't) handle eta-expansion.
[19:58:08] <Corbin> ...Do you implement in OCaml?
[19:58:47] <companion_cube> I do, yes
[19:59:03] <Corbin> Then OCaml isn't a language, because "we don't implement in formal languages".
[19:59:13] <companion_cube> you just added "formal"
[19:59:25] <companion_cube> I mean, you ignored the "formal"
[20:00:20] <Corbin> What, OCaml isn't a formal language!? It clearly has syntax generated from a grammar, and it clearly has semantics (relative to which the compiler is implemented -- unless the compiler doesn't try to be correct!?)
[20:00:31] <companion_cube> the semantics is what the compiler does
[20:00:58] <companion_cube> but if you want to go to languages with specs, sure, there's SML, C++, for example
[20:01:09] <companion_cube> some people try to stay in the standard C++
[20:01:24] <companion_cube> and I'd argue it's generally faster than standard SML
[20:01:43] <companion_cube> you can find programs that will more easily be fast in SML, but not on average
[20:02:46] <olle> Then what happened?
[20:04:45] <companion_cube> no one uses SML :D
[20:04:49] <olle> :)
[20:04:49] <companion_cube> (well, barely anyone)
[20:04:57] <olle> So it's a tragedy?
[20:05:02] <companion_cube> maybe, yeah
[20:05:12] <Corbin> companion_cube: Sorry, I guess this is irreconcilable. https://www.dreamsongs.com/Files/Incommensurability.pdf might be a good read, but I'm not going to argue this further.
[20:07:25] <olle> Isn't this just semantics? Again?
[20:07:57] <olle> Or, like Platonism vs that other thing
[20:08:05] <Corbin> olle: This is about how much software engineers are allowed to ignore formal issues when making claims about how software works.
[20:08:05] <olle> Materialism, perhaps
[20:08:22] <olle> Allowed by whom?
[20:08:31] <Corbin> My position is merely that, since software is fully abstract and symbolic, it *only* has formal issues.
[20:08:36] *** Quits: rgrinberg (~textual@2806:101e:7:6bed:540b:bd79:8d25:836) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[20:09:02] <olle> Sounds idealistic, indeed.
[20:09:48] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[20:09:57] *** Quits: mro (~mro@2002:5cc3:80ea:0:d68:158b:dd6e:9a2d) (Remote host closed the connection)
[20:10:28] <Corbin> (Also I am tired of tribal positions, where people insist that languages are "good" or "fast" or "beautiful" or "readable" or other empty judgements.)
[20:11:01] <olle> It can be fast on average in a certain domain
[20:11:11] <companion_cube> I'll try to read this… thing
[20:11:13] <olle> Assuming normally distributed skill
[20:11:24] <companion_cube> it's a bad start because it doesn't define what the heck it is talking about, but well
[20:12:05] *** Quits: bartholin (~bartholin@158.110.70.210) (Ping timeout: 256 seconds)
[20:12:08] <Corbin> companion_cube: It's about how people have trouble communicating across paradigm shifts. It's also about a paradigm shift in how we talk about languages vs. systems.
[20:12:14] <d_bot> <froyo> if you don't put a forall qualifier and try to be pedantic, if you just account for the general case, I think it's safe to say that as long as the language enforces elementary abstractions over the platform it runs on, it'll have a ceiling over how fast programs produced by it go compared to how fast they can go if written in a language with lower level of control.
[20:12:29] <companion_cube> ^
[20:12:41] <Corbin> olle, froyo: This is a fine intuition! Doesn't work for Turing-complete languages.
[20:12:52] *** Joins: mro (~mro@port-92-195-128-234.dynamic.as20676.net)
[20:12:58] <companion_cube> w h o   g i v e s   a   s h i t
[20:13:15] <Armael> Corbin: why?
[20:13:16] <companion_cube> software isn't fully abstract
[20:13:19] <companion_cube> software runs on real machines
[20:13:29] <olle> froyo, not sure that's true, since you don't know how "magic" the compiler is, right?
[20:13:29] <companion_cube> otherwise it's math (which is a fine thing, too!)
[20:14:10] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Client Quit)
[20:14:11] <d_bot> <froyo> olle: compiler magic is opportunistic, kinda like jit magic :P
[20:14:38] <olle> A super-smart compiler could be faster on average than (normally distributed) skilled devs.
[20:14:50] <olle> [in a certaint domain]
[20:15:37] <companion_cube> that's what pushed people to use C instead of asm :
[20:15:39] <companion_cube> ;0
[20:15:50] <olle> Sure
[20:16:20] <Corbin> Armael: In short, (1) optimizers fail unpredictably on pathological non-terminating inputs, and (2) Gödel and Kolmogorov showed that we can't predict whether a program is pathological just by looking at it.
[20:16:21] <olle> We'll all be replaced by AI soon enough, so nothing to worry about ^^
[20:16:54] <d_bot> <froyo> yea ocaml is fine and performant enough even tho it doesn't have c++ level of control, it's your limits that you should know well
[20:18:23] <companion_cube> Corbin: but unoptimized (or barely optimized) C++ still beats the crap out of cpython
[20:19:29] <olle> companion_cube: On average? :)
[20:19:30] <Corbin> companion_cube: What are you holding constant and what are you varying when you make that claim? I have personally experienced counterexamples, so what fact do you believe you're communicating and defending?
[20:20:02] <companion_cube> :D
[20:20:14] <companion_cube> the fact that C++ will have good cache locality and compile directly to assembly
[20:20:24] <companion_cube> as opposed to, erm, pretty basic bytecode
[20:20:41] <companion_cube> I'm assuming a decent C++ programmer, ofc.
[20:21:08] <companion_cube> but it's clear that the same loop in C++ (with even -O0) and in python, is… well…
[20:21:13] <companion_cube> a major win for C++
[20:21:51] <Corbin> The "same"? The same types, the same exception handling, the same resource management? Also I know the word "vtable", you can't fool me with that "directly to assembly" claim.
[20:22:55] <Corbin> companion_cube: What I'm getting at is that the underlying motive for this statement wasn't a fact, but a tribal meme: "C++ better than Python, because the performance tribe says so"
[20:23:49] <d_bot> <Et7f3> Vtable is only used with virtual keyword
[20:24:18] <d_bot> <Et7f3> So good all struct can still be direct assembly
[20:24:39] <companion_cube> Corbin: or, knowing how computers work, and using both C++ and python programs
[20:24:41] <companion_cube> your choice
[20:24:54] *** Joins: bartholin (~bartholin@158.110.70.210)
[20:25:03] <companion_cube> like Et7f3 says. Besides, a vtables just means a few more asm instructions
[20:25:12] <companion_cube> chase pointer, find offset, jump
[20:25:21] <Corbin> Ah, so you mean *a chosen subset of C++ which doesn't include "slow" constructions* is "fast"?
[20:25:21] <companion_cube> in python: a hashtable lookup using a string :D
[20:25:27] <companion_cube> no, vtables are fast
[20:25:31] <companion_cube> much faster than a python method  call
[20:25:39] <Corbin> Hm, so "directly to assembly" isn't what provides "fast".
[20:25:50] <companion_cube> no, the design of C++ also makes things fast
[20:26:21] <companion_cube> offsets are known (or a vtable lookup away, ie an array lookup, not a hashmap lookup)
[20:26:48] <d_bot> <froyo> Corbin: I think I get the point you're trying to make, and I agree that synthetic benchmarks don't reflect something inherent about the language in a formal sense.
[20:26:49] <d_bot> <froyo> I just don't want to dismiss the fact that a language runtime exists, and the semantics a language chooses to omit are all chances to make things go faster, or costs you have to pay because they have to be general and not tailored to your application. I can use an int knowing its value will never exceed 10, but I have to pay for a whole object in cpython, along with methods and checks and implicit conversions to bigints etc..
[20:27:08] <Corbin> Since the design of C++ was to desugar to C, there are no constructions in C++ that aren't also in C. Is C++ faster than C? Why or why not?
[20:27:37] *** Quits: jlrnick (~josephler@gw.lipn.univ-paris13.fr) (Ping timeout: 240 seconds)
[20:27:43] <Corbin> froyo: Sure. Also, CPython sucks. Also also, Python is just another programming language. *But also*, OCaml sucks and OCaml is just another programming language. And etc.
[20:27:44] <d_bot> <Et7f3> C++ with all features is about 2-3% slower
[20:29:06] <d_bot> <Et7f3> than C
[20:29:21] <d_bot> <froyo> if it weren't for the cosmic effort it'd take to gather a representative sample of all programs in all languages, then run it, and create a scatter plot of performance, memory usage, energy usage, and code size, I'd love to see what such plot would look like
[20:31:05] <companion_cube> Corbin: C and C++ are pretty close
[20:31:21] <companion_cube> I'd argue C++ is probably a bit faster in practice, because it makes it easier to use better algorithms
[20:31:58] <Corbin> companion_cube: Sure. Do you see how, with your framing, you just shifted the goalposts from "fast" to "fast in a relatively small amount of code"?
[20:32:59] *** Joins: rgrinberg (~textual@187.223.115.137)
[20:34:40] <d_bot> <darrenldl> i mean if one must be pedantic, then the more precise phrasing i guess would be that different designs yield different "natural" implementations wrt state of the art at the time and budget, and we argue based on said natural implementations
[20:35:34] <companion_cube> Corbin: well, we moved from C++ vs python, to C++ vs C
[20:35:36] <companion_cube> so…
[20:35:46] <companion_cube> and yes, "fast in code people will actually write"
[20:37:23] <companion_cube> (which is why one could argue rust is even faster :p)
[20:37:47] <olle> OT, but in my book on physiology, the electron is a particle, and light is described as waves. Can you imagine?
[20:39:12] <Corbin> companion_cube: I'm not sure how to communicate the concept that which systems are efficient is not an absolute, but always relative to what our society has made efficient. Different tools are all that's required.
[20:40:09] <olle> Agree to disagree :D
[20:41:38] <companion_cube> sure, never said the word "absolute"
[20:42:05] <companion_cube> (and yes, performance is relative to hardware… news at 11?)
[20:42:15] <olle> Lisp machine anyone?
[20:42:24] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[20:42:25] <d_bot> <froyo> love that pdf you shared btw
[20:43:19] <d_bot> <froyo> may sound silly, but the way its laid out is so beautiful
[20:46:41] <Corbin> companion_cube: "language X is faster than language Y" *is* an absolute. You might think it's relative to "the real world", but there is no single absolute real world; it's relative depending on the observer. Endorsing one relative view as the absolute state of the world is tribal.
[20:47:23] <olle> Corbin: I think there's an implied "on average" in there :)
[20:50:08] <Corbin> olle: Which probability distribution? I agree that it's implied, but I disagree that it's an argument-saving nuance.
[20:50:58] <olle> Corbin: E.g., making a web app, Java is on average faster than PHP
[20:51:17] <olle> But that's the system Java and PHP
[20:51:53] <olle> Well, you can argue that static typing in the formal language open possibilities of optimizations in the language system.
[20:52:30] <olle> Which is why you can't separate the two completely
[20:54:22] *** Quits: salkin (~salkin@138.251.92.62.static.cust.telenor.com) (Ping timeout: 260 seconds)
[20:54:32] *** Quits: bartholin (~bartholin@158.110.70.210) (Ping timeout: 250 seconds)
[20:56:06] <companion_cube> Corbin: a formula 1 is faster than a bicycle
[20:56:30] <companion_cube> sure, you can argue that if the formula one doesn't have fuel, it's actually slower, blabla, but the statement remains true
[20:56:38] *** Joins: bartholin (~bartholin@158.110.70.210)
[20:57:39] *** Quits: bartholin (~bartholin@158.110.70.210) (Client Quit)
[20:59:30] <Corbin> companion_cube: Note that there's a dominating principle: There's some minimum distance where the car is faster than the bicycle, *and* every longer distance reduces to that case, *and* distance is a measurable metric for every trip. This principle doesn't transfer to TC languages except in special cases like the desugaring case with C++ and C; compilers need not be linear.
[20:59:59] <Corbin> ("linear"!? That's not the right word at all.)
[21:04:09] <companion_cube> oh well
[21:04:22] <companion_cube> we probably cannot say anything about anything
[21:13:44] <d_bot> <RegularSpatula> I’m confused…is there something wrong with saying something like “oh I will write this genome assembler in C++ rather than python. It will be faster.”?
[21:14:02] *** Quits: mro (~mro@port-92-195-128-234.dynamic.as20676.net) (Quit: Leaving...)
[21:14:34] <companion_cube> apparently yes
[21:16:08] <d_bot> <RegularSpatula> I don’t have formal CS training so I feel as I’m missing the point of Corbin’s argument (that’s not supposed to be a slight against their argument)
[21:18:02] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[21:19:06] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[21:19:34] <olle> Imagine you're in a cave. You see only shadows. :)
[21:19:46] <olle> The shadows are the implementation.
[21:19:52] <olle> Outside is the sun, the real world.
[21:19:56] <olle> That's System F :D
[21:21:21] <olle> OOP is kind of the Demiurg.
[21:22:01] *** Quits: gravicappa (~gravicapp@145.255.1.142) (Ping timeout: 250 seconds)
[21:22:33] <olle> Corbin is Plato and companion_cube kind of Jesus
[21:27:41] *** Quits: olle (~olle@i5E866D87.versanet.de) (Ping timeout: 256 seconds)
[21:38:41] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[21:38:47] *** Quits: Anarchos (~Anarchos@88.168.112.216) (Ping timeout: 256 seconds)
[21:41:49] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[21:43:22] *** Joins: Anarchos (~Anarchos@88.168.112.216)
[21:51:27] <Corbin> RegularSpatula: *Will* it be faster? In my experience, only sometimes. That's all that's wrong.
[21:52:50] <companion_cube> then you probably write crappy C++
[21:54:31] <d_bot> <cemerick> Say I have a module type that declares some abstract type; is there any way to allow the concrete type declared by implementing modules to be visible without adding duplicative `with` constraints to each implementing module's type declaration?
[21:55:03] <d_bot> <cemerick> It's _fine_ if there's just one abstract type, but pretty laborious IMO past two
[21:55:34] <companion_cube> I can't think of a way :/
[21:55:59] <companion_cube> well, you can pack stuff in a sub-module, and say `: S with module A=A`
[21:56:05] <companion_cube> that can alias a whole bunch of types
[21:56:09] <companion_cube> but it can also be tricky
[21:57:30] <d_bot> <cemerick> ocamllsp suggested `type t = private ..` in the signature, which apparently typechecks, but I don't know what that really means or how to match it in the implementations
[21:59:31] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[22:00:35] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[22:00:54] <d_bot> <cemerick> oh, `..` is the extensible variants
[22:02:11] <d_bot> <orbitz> Is case refutation something you use to fix code that isn't compiling or is it something you voluntarily do to help the compiler?
[22:03:55] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Client Quit)
[22:04:44] <octachron> Case refutation is here to help the exhautiveness pattern matching analyzer.
[22:05:43] <octachron> It is required for compiling if you are promoting the inexhaustive pattern matching warning to an error.
[22:14:29] <d_bot> <cemerick> companion_cube: not sure what you mean re: the sub-module suggestion
[22:15:39] <d_bot> <cemerick> like, have the module type actually require that everything be within an inner module, and then use that to have the compiler implicitly derive the narrower module type?
[22:18:07] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[22:18:25] <companion_cube> https://paste.isomorphis.me/zZH
[22:18:34] <companion_cube> with TYPES you can carry n type aliases at once
[22:19:45] *** Joins: olle (~olle@i5E866D87.versanet.de)
[22:21:00] *** Joins: def (~def@ks35179.kimsufi.com)
[22:21:31] <def> et vice versa
[22:22:03] *** Quits: rgrinberg (~textual@187.223.115.137) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[22:24:31] <d_bot> <cemerick> oh, I see
[22:24:54] <companion_cube> do that at scale though, and your eyes will bleed
[22:25:02] <companion_cube> source: I have been doing that
[22:25:16] <companion_cube> and my _build/log is all covered in blood now
[22:25:57] <d_bot> <cemerick> feels like just pushing a blob of complexity around
[22:27:36] <Fardale>  /topic
[22:27:40] <d_bot> <Président daren le pétrolier> how idiomatic is using the `let ... and ...` syntax when several assignments follow each other without being mutually recursive?
[22:39:36] *** Joins: zebrag (~chris@user/zebrag)
[22:40:00] <d_bot> <Et7f3> I think it depend `let x = ... and y = ...` seem idiomatic enough and can be more readable than `let x, y = ..., ...`
[22:42:51] <d_bot> <froyo> oh here's a little neat observation: last year ocaml hello world executable was ~700kb, and a little less than 300 stripped, right now with trunk it's ~2.5 mb, and a little less than 900 kb stripped
[22:43:21] <d_bot> <froyo> looks like there have been some substantial additions to the runtime
[22:58:00] <d_bot> <froyo> https://cdn.discordapp.com/attachments/436568060288172044/940328058617991188/unknown.png
[23:00:34] *** Joins: hyphen (~hyphen@156.208.229.222)
[23:07:52] *** Quits: jackhill (~jackhill@kalessin.dragonsnail.net) (*.net *.split)
[23:07:52] *** Quits: pgiarrusso (sid258222@id-258222.hampstead.irccloud.com) (*.net *.split)
[23:07:52] *** Quits: thizanne (~thibault@2001:41d0:a:f682::1) (*.net *.split)
[23:07:52] *** Quits: theblatte (~theblatte@82-71-49-100.dsl.in-addr.zen.co.uk) (*.net *.split)
[23:07:52] *** Quits: Putonlalla (~sapekiis@it-cyan.it.jyu.fi) (*.net *.split)
[23:07:52] *** Quits: Enjolras (~enjolras@139.99.101.27) (*.net *.split)
[23:08:52] *** Joins: theblatte (~theblatte@82-71-49-100.dsl.in-addr.zen.co.uk)
[23:10:51] *** Quits: Anarchos (~Anarchos@88.168.112.216) (Quit: Vision[]: i've been blurred!)
[23:11:59] <d_bot> <cemerick> companion_cube: that actually worked out for me pretty nicely, thanks 🙃
[23:12:08] <companion_cube> :)
[23:12:10] <d_bot> <cemerick> gah, 🙂
[23:12:12] <d_bot> <cemerick> I was able to segment off all of the operations that depended upon the parameterized types to a single functor, and then include the results in the forward-facing modules, so the API remained unchanged
[23:12:26] *** Joins: jackhill (~jackhill@kalessin.dragonsnail.net)
[23:12:26] *** Joins: pgiarrusso (sid258222@id-258222.hampstead.irccloud.com)
[23:12:26] *** Joins: thizanne (~thibault@2001:41d0:a:f682::1)
[23:12:26] *** Joins: Putonlalla (~sapekiis@it-cyan.it.jyu.fi)
[23:12:26] *** Joins: Enjolras (~enjolras@139.99.101.27)
[23:16:32] *** Quits: saltrocklamp[m] (~hexology@user/hexology) (Ping timeout: 240 seconds)
[23:16:48] *** Joins: salkin (~salkin@84.212.156.62)
[23:17:26] *** Quits: mclovin (~zapashcan@2001:470:69fc:105::43) (Ping timeout: 245 seconds)
[23:18:45] <d_bot> <Président daren le pétrolier> I see, ty!
[23:19:01] *** Quits: smondet[m] (~smondetma@2001:470:69fc:105::b33) (Ping timeout: 250 seconds)
[23:19:01] *** Quits: JosEduardo[m] (~joseemdsm@2001:470:69fc:105::ce1d) (Ping timeout: 250 seconds)
[23:19:02] *** Quits: CodeBitCookie[m] (~code-bit-@2001:470:69fc:105::a2f) (Ping timeout: 240 seconds)
[23:19:06] *** Quits: Sofi (~sofi@2001:470:69fc:105::1:44cc) (Ping timeout: 245 seconds)
[23:19:25] *** Quits: pgeorgi (~pgeorgi@2001:470:69fc:105::54) (Ping timeout: 256 seconds)
[23:19:30] *** Quits: OCamlPro[m] (~ocamlprom@2001:470:69fc:105::1:70d1) (Ping timeout: 268 seconds)
[23:45:21] *** Joins: spip (~bobo@37.165.25.142)
[23:45:29] *** Quits: bobo_ (~bobo@37.165.25.142) (Ping timeout: 256 seconds)
[23:53:52] *** Parts: def (~def@ks35179.kimsufi.com) ()
