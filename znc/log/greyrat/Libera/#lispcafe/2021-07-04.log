[00:11:49] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[00:25:42] *** Quits: treflip (~user@95.79.32.99) (Quit: good night)
[00:26:45] *** Joins: kevingal (~quassel@2a02:8084:4140:f300:247e:ee97:5a1f:c15a)
[01:45:43] *** Quits: Alfr (~Alfr@user/alfr) (Quit: Leaving)
[01:52:46] *** Quits: mariari (~mariari@user/mariari) (Quit: WeeChat 3.1)
[02:07:23] *** Joins: GreaseMonkey (greaser@user/greasemonkey)
[03:27:27] <hayley> https://www.youtube.com/watch?v=_BZRO3FToDo
[03:27:27] -ixelp- Pink Floyd - Green Is The Colour (An Hour With Pink Floyd, KQED) - YouTube
[03:33:39] *** Joins: pjb (~pjb@user/pjb)
[03:46:40] *** Quits: gilberth (~gilberth@p54bfef57.dip0.t-ipconnect.de) (Ping timeout: 272 seconds)
[03:58:54] <aeth> Wow, GitHub Copilot is a bad idea. e.g. https://news.ycombinator.com/item?id=27710287
[03:58:55] -ixelp- Copilot regurgitating Quake code, including sweary comments | Hacker News
[03:59:30] <Aurora_v_kosmose> lol
[03:59:42] <aeth> (1) It gives you things that absolutely should be library functions instead of copied and pasted into all code, (2) it might be verbatim GPL, and (3) it might comment the wrong license next to it
[03:59:51] <hayley> I recall it threw up someone's API keys and also GPLed code under the wrong license.
[04:00:01] <Aurora_v_kosmose> > So this makes it official... this post[0] and the comments on the announcement[1] concerned about licensing issues were absolutely correct... and this product has the possibility of getting you sued if you use it.
[04:00:02] <aeth> Why the heck does copilot even let you write dozens of lines
[04:00:49] <aeth> sure autocomplete 3 line API boilerplate, that's not even new
[04:01:14] <aeth> But anything large enough is probably just stealing a library function, but with subtle inaccuracies, license violations, etc., and without tests, being updated when the library is updated, etc.
[04:09:21] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 256 seconds)
[04:11:38] <Aurora_v_kosmose> So what we all expected to happen happened.
[04:12:16] <aeth> I mean it's just programming by copy and paste, except (1) with unknown license and origin since it could be verbatim from the training material or it could be some magically made up function
[04:12:33] <aeth> (2) Lispers of course hate that sort of style more than anything else
[04:12:59] <Aurora_v_kosmose> It's also very brittle and error-prone.
[04:13:05] <hayley> https://www.youtube.com/watch?v=sy_dMLfJT7g
[04:13:05] -ixelp- YTP ElectroBOOM discovers oscilloscopes - YouTube
[04:14:24] *** Quits: random-nick (~random-ni@87.116.165.220) (Ping timeout: 252 seconds)
[04:16:22] <aeth> anything filled in more than a few lines (or a few lines if particularly complicated, like the regex in its demos) is going to be brittle and error-prone
[04:16:32] <aeth> Because you need to put it in a separate library function with dozens of tests on edge cases
[04:23:48] <GreaseMonkey> a glorious thing about that twitter thread is someone @'d Microsoft and they got hit by an automated bot reply from @AzureDevOps talking about Windows 11
[04:24:04] <derelict> lmfao i saw that GreaseMonkey 
[04:26:24] <GreaseMonkey> and someone going "Ideas, mathematical functions, algorithms, etc cannot be copyrighted." which while it's true, implementations of algorithms are indeed copyrightable
[04:26:58] *** Quits: {`_`} (~gilbert@p54bfef57.dip0.t-ipconnect.de) (Ping timeout: 272 seconds)
[04:29:02] *** Quits: easye (~user@oxi.slack.net) (Read error: Connection reset by peer)
[04:33:08] *** Joins: happy-dude (~happy-dud@2001:470:69fc:105::b4d7)
[04:45:05] *** Joins: gilberth (~gilberth@p54bfef57.dip0.t-ipconnect.de)
[04:45:05] *** ChanServ sets mode: +o gilberth
[04:45:19] <hayley> Good morning everyone!
[04:45:45] <gilberth> hayley: Good morning!
[04:46:55] *** Quits: kevingal (~quassel@2a02:8084:4140:f300:247e:ee97:5a1f:c15a) (Remote host closed the connection)
[04:47:12] <gilberth> I found the MOP LaTeX sources. On common-lisp.net, which is embarrassing in a way.
[04:47:19] <hayley> What would a mostly scientific way of measuring mutator CPU usage be? I am currently thinking to set a bit when we enter GC and clear when we leave, and periodically clear when we leave. Then another thread would record either the times for transitions or a full log.
[04:48:33] <gilberth> Use your scope!
[04:48:43] <hayley> Then we would use that to compute a minimum mutator utilisation graph.
[04:49:09] <hayley> Funny, my desktop does not have any GPIO. And if I rent out server hardware with userspace MMU hooks, then I'm not recording that either.
[04:49:19] <gilberth> You could toggle a pin on the printer port or the serial port.
[04:49:32] <hayley> Also, what happens if I return from a SIGSEGV handler? Does it try to run the instruction again?
[04:49:49] <gilberth> The printer port makes for pretty good GPIO. It's bidirectional most of the time even.
[04:50:29] <gilberth> hayley: Sure.
[04:50:56] <hayley> I heard it is UB generally on POSIX but Linux lets you do it?
[04:51:41] <gilberth> I would pretty much guess so.
[04:52:17] <hayley> I heard you can "portably" continue using libsigsegv but I can't find documentation on it.
[04:52:21] <gilberth> IDE also is just part of the ISA bus. And then there is the speaker. Plenty of options for GPIO.
[04:54:20] <hayley> I guess my experiment should go STW serial Immix -> STW parallel Immix -> concurrent-sans-evacuation parallel Immix -> fully concurrent w. read barriers parallel Immix
[04:56:06] <hayley> The nice thing is that it's basically mark-sweep unless it needs to defragment.
[04:56:29] <hayley> Can they put a button on the university library site that says "View GC handbook"? That is the only reason I use it.
[05:01:02] <gilberth> You don't have a copy? And they have it online?
[05:01:58] <hayley> Yep.
[05:03:04] <hayley> Excellent, the Handbook does have Immix in "Other partitioned schemes"
[05:03:28] <hayley> And damn G1 as well. /me never read Chapter 10
[05:06:03] <gilberth> That handbook is on my reading list, unfortunately my copy sits on a shelf at the evil house.
[05:06:33] <gilberth> Anyhow, returning from SIGSEGV/SIGBUS works for both Linux and Macos.
[05:06:42] <hayley> Nice.
[05:07:17] <hayley> Do you have any interesting programs in your Lisp-in-C interpreter?
[05:09:16] <gilberth> https://termbin.com/yk9eÂ  <- SIGSEGV test
[05:09:41] <gilberth> hayley: No, I don't have any interesting programs.
[05:10:11] <gilberth> Didn't work. :(
[05:10:41] <hayley> Works here.
[05:11:12] <gilberth> My own IRC client inserted an NBSP and took it as part of the URL. :(
[05:11:14] * hayley guessed the IP of the Pi and pressed C-c just after the MOTD was printed out
[05:11:40] <hayley> Also works on the Pi, no surprise I suppose.
[05:12:27] <gilberth> That is good news. However the address mmap()ed is just a guess, could as well fail.
[05:13:08] <hayley> Appears that the Handbook is also unaware of JIT, saying that static analysis of shared or thread-local objects can break if you can load classes at runtime.
[05:14:57] <gilberth> hayley: You could try one of the Gabriel benchmarks. Should be easy enough to get them working with my toy lisp.
[05:15:55] <hayley> Ah, yeah. Off the top of your head, do any do mutation? Non-compacting runs would need a write barrier, compacting would need read and write.
[05:16:01] <gilberth> Reminds me, that I should write a kind of spec for toy lisp. Another version has 1/2 of CLtL1 written in it.
[05:16:47] <gilberth> hayley: No. All I remember is that some were stated as being GC benchmarks.
[05:17:07] <hayley> That said, I'm not sure whether to use the MMU or make the compiler insert write barriers. Those would be rarer, and doing stuff page-by-page works fine for read barriers for copying as you fix up everything anyway.
[05:17:17] <gilberth> hayley: There also is lisp500.
[05:18:29] <hayley> Aha, so https://common-lisp.net/project/cl-bench/ includes the Gabriel benchmarks which Baker also fixed up.
[05:18:29] -ixelp- cl-bench
[05:18:34] <gilberth> hayley: That reminds me, I should brush up my long mode stuff, since I would guess that without context switches page faults won't be too expensive.
[05:18:44] <hayley> A star-studded benchmark suite.
[05:19:38] <gilberth> Call me the Unfinished Projects Man, if you wish.
[05:19:50] *** Joins: cond (~example@user/aeth/bot/cond)
[05:20:05] <hayley> https://gitlab.common-lisp.net/ansi-test/cl-bench/-/blob/master/files/gabriel.lisp
[05:20:06] -ixelp- files/gabriel.lisp Â· master Â· ansi-test / cl-bench Â· GitLab
[05:20:27] <gilberth> The book itself also is online somewhere.
[05:20:46] <hayley> Yes, I had a copy once.
[05:22:26] <hayley> ";;; DESTRU -- Destructive operation benchmark" Aha.
[05:22:28] *** Quits: pjb (~pjb@user/pjb) (Remote host closed the connection)
[05:23:24] <gilberth> A dead tree copy is also sitting on by bookshelf. Guess my tiny library has everything one needs. :)
[05:23:37] <gilberth> I should move the books.
[05:25:38] <hayley> So we have the destructive test and the derivative test at least. 
[05:28:14] <hayley> Should ask, what's the URL for your interpreter again?
[05:29:47] <gilberth> http://clim.rocks/gilbert/ulisp/
[05:29:48] -ixelp- /gilbert/ulisp/
[05:30:38] <gilberth> It's primitive, but you'll get along.
[05:30:58] <hayley> Thanks!
[05:36:54] <hayley> Are all assignments going through rplaca/rplacd here? If so making a write barrier would be damn easy.
[05:37:25] <gilberth> They do.
[05:37:34] <hayley> NEAT!
[05:39:16] <gilberth> I first Greenspun a little and once the data types are set, all other code should use that API. But: There are those control stack frames for CATCH/THROW.
[05:41:02] <hayley> Those live on the stack so I think we are safe. 
[05:41:40] <gilberth> Let me check, if this is the version where environments also live on the stack.
[05:43:05] <gilberth> No, environments are consed. If you wish I find the other much faster / less consing version, which allocates environments on the stack and copies them on demand, that is when closed over.
[05:43:17] <hayley> The more consing, the merrier.
[05:43:32] <gilberth> Heh, nice.
[05:44:04] <gilberth> Do we have some more coffee?
[05:44:55] * hayley does not know how to measure the mutator utilization of Boehm still. Perhaps assume that we are in GC in GC_malloc and any explicit GC call and that we are not otherwise? That wouldn't handle write barriers still.
[05:48:04] <hayley> And I guess I have to include the MPS as another mostly-copying mostly-precise GC.
[05:50:14] <gilberth> hayley: Thanks for the coffee.
[05:51:57] <hayley> I suppose a MMU (the GC meaning, I cannot be bugged to write minimum mutator utiliz--oh shit not again) would also be hard to get for MPS. Guess I have something to go off if I just record MMU for my own collectors.
[05:55:07] <hayley> Forgive my ignorance, but for anything larger than a page what is my best bet at allocation? Not that your Lisp has anything larger than a CONS IIRC.
[05:57:21] <gilberth> This is the old version where even closures are cons cells, and I have no strings. On purpose.
[05:58:31] <gilberth> The only thing larger is symbol names.
[06:00:03] <hayley> Okay, still not larger than a page though.
[06:00:52] <gilberth> There is struct symbol_more though, which I kinda regret now.
[06:02:47] <gilberth> I could have made these into struct node too. That is: put (<value> <name> . <plist>) on a more slot. So that everything is just a struct node.
[06:03:34] <hayley> Yes, I admit I am not looking forward to handling those. I would inline it into struct node but then every object will be larger. Unless there's some careful way to allocate the exact size?
[06:05:21] <hayley> Or I could put a type tag on symbol_more and pray that the padding ends up the same, which is likely IIRC.
[06:06:18] <gilberth> Milady, my initial idea was to make every node the same size. Just a type plus two pointers. Hence my suggestion to say struct node { ... union { struct struct symbol { T function, more; } .. } and have, as I said more pointing to (<value> <name> . <plist>); Name could be a either a list of code points or a new T_STRING node with just a char*.
[06:06:24] <hayley> Wait, what the actual fuck?
[06:06:28] <hayley> Why does https://github.com/no-defun-allowed/wasm2ps have 28 stars
[06:06:28] -ixelp- GitHub - no-defun-allowed/wasm2ps: ruin the sanctity of your printer with ONE WEIRD TRICK
[06:07:27] <gilberth> Nice, a pity that I still cannot run it. I'd like to have arrays, too. Could port my ulisp over :-)
[06:08:04] <hayley> Never going to happen.
[06:09:12] *** Quits: wheelsucker (~user@2600:8801:8c11:4c00::707) (Remote host closed the connection)
[06:09:26] *** Joins: wheelsucker (~user@2600:8801:8c11:4c00::707)
[06:09:33] <hayley> https://news.ycombinator.com/item?id=27709002 AAAAAAAAAAAAAAAAAAAAAa
[06:09:34] -ixelp- WASM to PS Compiler | Hacker News
[06:15:58] <sm2n> huh, I'm kind of surprised tedu uses HN, and apparently actively at that
[06:22:53] <gilberth> hayley: Here you go: http://clim.rocks/gilbert/ulisp/ulisp2.c
[06:23:12] <hayley> Strings too now. Fancy.
[06:23:34] <gilberth> Only for symbols, no SUBRs for them. And I could add a length.
[06:24:10] <gilberth> I just wanted to make any node be just a struct node. And rplaca, rplacd, putd should now be the only writers.
[06:25:54] <gilberth> makunbound, fmakunbound
[06:26:56] <gilberth> No, makunbdound also uses rplaca.
[06:27:19] <hayley> Seems I can't escape having a string type on the heap though. But I could hypothetically have my own GC_strdup allocate the string as a tagged object, then return a pointer to the string part. Then scanning a symbol with string S requires scanning the object at S - offsetof(node, string)?
[06:28:30] <gilberth> It's already tagged as T_STRING :-)
[06:28:56] <gilberth> Should I make the symbol name into a list of code points? To be really low-level?
[06:29:01] <hayley> Right, right.
[06:29:17] <hayley> My change would be to make char *string; into char[0] string; so that the string is inline I guess.
[06:30:24] <gilberth> Would that be any easier? I mean: then objects are of variable size. You could just malloc/free the names. And there are no real GENSYMs IIRC.
[06:31:00] <hayley> Yes, a real GC would handle variable size objects, and freeing is hard when you are trying to keep roughly O(live).
[06:33:39] <gilberth> Well, MAKE-SYMBOL (subr_make_symbol) already takes a list of code points, could as well make symbol name be just that. Won't hurt performance much.
[06:33:45] <gilberth> Dammit.
[06:34:05] *** Joins: dave0 (~davezero@069.d.003.ncl.iprimus.net.au)
[06:34:44] <gilberth> Did you get my message twice? Guess not.
[06:35:10] <gilberth> $ cp ulisp.c ulisp.c.2 # we get more primitive now
[06:35:13] <dave0> maw
[06:42:46] <hayley> Hey dave0
[06:43:19] <dave0> hi hayley 
[06:43:24] <dave0> how are you?
[06:43:35] <hayley> Alright, you?
[06:44:48] <dave0> eh i'm doing laundry
[06:45:37] <dave0> like household chores, it never ends
[06:48:32] <hayley> https://www.youtube.com/watch?v=bXJdoosrIiQ
[06:48:32] -ixelp- King Crimson - Red (Live, 1981) - YouTube
[07:01:38] <gilberth> Hmm. Now Boehm somehow throws a SIGSEGV. :(
[07:11:48] <hayley> Ouch.
[07:12:48] <hayley> Huh, I have a port of your ulisp + bespoke GC which has methods for the MPS.
[07:20:28] *** Quits: dave0 (~davezero@069.d.003.ncl.iprimus.net.au) (Quit: dave's not here)
[07:21:16] <hayley> Hm, perhaps I should just use compiling init.lisp as a benchmark too :)
[07:23:38] <hayley> real	0m8.731s user	0m32.341s sys	0m2.888s
[07:23:47] <hayley> Boehm doing a lot of parallel GC?
[07:38:47] <hayley> ulisp.c:50:3: warning: âstrcpyâ offset 40 from the object at âstartâ is out of the bounds of referenced subobject âvalueâ with type âchar[0]â at offset 40 [-Warray-bounds] Why 40?
[07:42:33] <hayley> gilberth: If I change the GC calls to merely bump a pointer, make init.fasl runs 3.3x as fast.
[07:43:59] <hayley> You do need an 8GB heap to have it complete though :)
[07:44:05] <hayley> Total:       8,589,934,592 bytes Free:        1,753,309,040 bytes Used:        6,836,625,552 bytes
[07:47:39] <gilberth> hayley: Yes, all environments are consed. So every function call conses.
[07:47:53] <gilberth> http://clim.rocks/gilbert/ulisp/ulisp-list-strings.c
[07:48:41] <gilberth> hayley: What about the error above? A bug of mine?
[07:48:52] <hayley> I dunno, didn't catch it.
[07:49:02] *** Joins: speskk (~user@ool-44c57707.dyn.optonline.net)
[07:49:22] <gilberth> The ulisp.c:50.3 ? Was that a compiler warning?
[07:49:35] <hayley> Oh, that was mine.
[07:49:59] <hayley> I wrote something like struct allocation { size_t size; char value[0] };
[07:50:12] <gilberth> Ah! I see.
[07:50:25] <hayley> Still, why did it pick 40?
[07:51:00] <gilberth> Anyhow, I'll continue my work on just using conses, numbers, and symbol.
[07:51:52] <gilberth> hayley: Offset of the name slot? But that would be a bit large.
[07:52:04] <hayley> Exactly.
[07:52:46] <gilberth> Did it infer the length of the string to be copied [from]?
[07:52:53] <hayley> Doubt it.
[07:52:59] <hayley> That was my implementation of GC_strdup
[07:53:18] <gilberth> Inlinemania?
[07:53:41] <gilberth> But then: I don't have such long strings, do I?
[07:53:45] <hayley> I'm not sure.
[07:53:53] <hayley> Though I do want to inline the write barriers for rplaca and rplacd.
[07:55:56] <gilberth> Sure. GCC could do that. I pretty much depend on that. E.g. I also use eq() instead of ==. There is ENCAPSULATE_NODE to enforce that T is a struct and thus can't be handled as a pointer.
[07:56:20] <gilberth> But: GCC generates inferior code with that. Don't know why.
[07:57:27] <hayley> 259,423,385 cache-misses with Boehm. I didn't bother to count for pointer bumping over an 8GB heap because the number is surely "a lot".
[08:00:36] <hayley> I wonder what happens if I play it really lazily and don't bother with Immix's line stuff, only dealing with copying pages every so often. Probably would end up copying too much.
[08:01:15] <gilberth> Well, milady, this ulisp is hard core as it conses like crazy.
[08:01:40] <hayley> Oh, I also should do a MPS port too.
[08:02:22] *** Parts: speskk (~user@ool-44c57707.dyn.optonline.net) (ERC (IRC client for Emacs 27.2))
[08:03:26] <gilberth> I fixed the ENCAPSULATE_NODE stuff, now I could have NIL being 42, if I wish.
[08:03:39] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Quit: brb)
[08:04:02] <hayley> BITMAP_WORD_TYPE object_start_table[PAGE_SIZE / OBJECT_ALIGNMENT / BITS_PER_WORD];
[08:04:03] <gilberth> This also is to support tagging, as NODE() is used to turn a T into a pointer.
[08:04:08] <hayley> Thankyou for the bit arrays.
[08:04:19] <gilberth> Heh.
[08:04:19] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[08:04:54] * hayley reads the MPS tutorial. Despite having ported it to ARM, she doesn't know how to use it.
[08:10:02] <gilberth> hayley: Oh, there also is the file table, which of course could use just malloc/realloc or be of static size.
[08:10:29] <hayley> Yes, I needed to store a "header" so I could realloc.
[08:10:54] <gilberth> Ok. so you support variable sized objects?
[08:11:31] <gilberth> We could also have SAPs, I guess.
[08:11:32] <hayley> In the dumb bump allocator, yes. I will have to in Immix on a Plane too.
[08:12:45] <gilberth> Anyhow, I want a "pure" version.
[08:21:26] <gilberth> hayley: You really want '#define times my_times'
[08:22:32] * hayley is still writing MPS glue code.
[08:31:48] <hayley> Okay, done with the object formats finally.
[08:33:49] <gilberth> Don't we want everything under GC control in struct node with a type header?
[08:35:15] <gilberth> Heh, could be a generic header stating number of Ts, number of just octets.
[08:35:35] <hayley> Yes, that is what I did to the string type.
[08:37:55] <gilberth> Well, I am just think about how to get the interface to GC as small as possible. I mean objects could be type plus length fields. And then there are no CAR and CDR fields, just say uref(node, index) and set_uref(node, index, value).
[08:40:07] <gilberth> When space is a concern, a generic describe_node(T) function returning the number of Ts found plus total size or number of "binary" data.
[08:40:49] <gilberth> This way the ulisp could be extented without touching the GC implementation.
[08:42:30] <gilberth> That would be terrific, as I could extend ulisp for strings and vectors, and possibly DEFSTRUCT.
[08:43:15] <hayley> Last thing to do is find all the global roots.
[08:50:53] <hayley> Think I got them all hopefully.
[08:59:06] <hayley> Right, now mps-noise.c compiles but I need to write new consing functions.
[08:59:41] *** Joins: pjb (~pjb@user/pjb)
[09:04:36] *** Quits: Mandus (~aasmundo@0.51-175-33.customer.lyse.net) (Ping timeout: 272 seconds)
[09:05:00] *** Joins: Mandus (~aasmundo@85.112.154.250)
[09:08:54] <gilberth> hayley: Yes, and this is where I would like to have as small as possible API, thus my suggestion wrt the describe_node(T) function.
[09:09:17] <hayley> Ah yeah, I think Clasp ends up generating something like that from C++ code.
[09:15:06] *** Quits: pjb (~pjb@user/pjb) (Ping timeout: 240 seconds)
[09:17:28] *** Quits: Mandus (~aasmundo@85.112.154.250) (Ping timeout: 265 seconds)
[09:19:18] * gilberth thinks.
[09:19:19] *** Joins: Mandus (~aasmundo@0.51-175-33.customer.lyse.net)
[09:19:36] *** Joins: pjb (~pjb@user/pjb)
[09:20:01] <gilberth> I like this generic uref/uset idea. Hmm.
[09:20:10] * gilberth tries with more coffee.
[09:22:19] * hayley reads how to clone GC_get_heap_size
[09:25:21] <hayley> mps_arena_committed sounds what's used and mps_arena_reserved is the heap size.
[09:30:49] <gilberth> Do we need mixed Ts/octet objects?
[09:32:15] <hayley> They could exist. Sure.
[09:32:26] * hayley wonders where the other definition of GC_init is.
[09:34:49] <hayley> Apparently it's in ulisp.o but I can't find it?
[09:37:32] * hayley changes to gc_setup() and it's still there somehow.
[09:38:33] <gilberth> Definition? I use GC_init once in init().
[09:39:19] <hayley> The definition in mps-noise.c is, well, MPS noise, but there shouldn't be one in ulisp.c
[09:39:33] <gilberth> hayley: Do you need to know about writes to "binary" parts of an object?
[09:40:11] <hayley> Okay, which moron put { } after the extern void gc_setup() and how is that legal?
[09:40:14] <hayley> gilberth: Nope.
[09:40:38] <gilberth> hayley: Sure that is legal.
[09:41:31] <gilberth> hayley: Hmm, but shouldn't a generic interface also be prepared to handle forwarding pointers?
[09:42:52] <hayley> Appel's read barrier ensures that all pointers the mutator sees are to tospace, i.e. having no forwarding pointers.
[09:46:28] * hayley runs ./ulisp
[09:46:42] *** Quits: pjb (~pjb@user/pjb) (Ping timeout: 240 seconds)
[09:46:49] <hayley> The MPS detected a problem! /home/hayley/Downloads/mps/code/lockix.c:126: MPS ASSERTION FAILED: res == 0
[09:48:34] * hayley uses the "cool" build for more tests and gets the same error and an abort()
[09:53:25] <gilberth> hayley: Ok. But that can only work, when the GC could also update my registers and the stack.
[09:54:23] * gilberth now wants a just BC virtual machine with its own stack.
[09:54:31] *** Joins: dave0 (~davezero@069.d.003.ncl.iprimus.net.au)
[09:54:59] <dave0> maw
[09:55:12] <hayley> Not exactly; my old incremental copier just wouldn't copy pinned objects. So we say that those objects are in "tospace" even though they're not.
[09:55:25] <gilberth> Hello dave0!
[09:55:30] <dave0> maw gilberth!
[09:55:33] <gilberth> hayley: I see.
[09:56:04] <hayley> And in the context of Immix, copying is the edge case where there is too much fragmentation. So we can always disable the rule for that too.
[09:56:05] <gilberth> dave0: You better hide. She is playing with my primitive ulisp.
[09:56:31] <hayley> I don't think even drmeister knows how to handle the MPS saying some random assertion failed.
[09:56:51] * dave0 disappears in a puff of ()'s
[09:56:58] <hayley> With my apologies to gilberth, I might just hack the pre-packaged Scheme interpreter to run on my GC.
[09:57:00] <gilberth> Random? assert (rand ());?
[09:57:27] <hayley> "Random" as in "how the hell did I make mps/code/lockix.c:126: MPS ASSERTION FAILED: res == 0 happen"
[09:57:51] <gilberth> hayley: pre-packaged?
[09:57:58] <hayley> And then I guess I won't get in licensing problems with gilberth if I use the MPS toy Scheme.
[09:58:35] <gilberth> hayley: Heh. You could always ask for an MIT license.
[10:02:42] <hayley> gilberth: https://github.com/no-defun-allowed/mps/blob/master/example/scheme/scheme.c
[10:02:43] -ixelp- mps/scheme.c at master Â· no-defun-allowed/mps Â· GitHub
[10:02:47] <hayley> It comes with malloc, Boehm and MPS variants too.
[10:05:02] <hayley> Hey, and another benchmark. Neat.
[10:06:29] <hayley> Dammit, Ravenbrook added ARM64 support a month ago. Guess I still had it before it was cool.
[10:09:12] <gilberth> hayley: I spot this do{ }while (mps_commit(...)); there.
[10:09:26] <hayley> Yes, it is asynchronous and so you have to do two phase commit.
[10:10:14] <gilberth> Would passing data to init an object with as the GC API entry point help?
[10:10:48] <hayley> Perhaps, but you could also just set everything to NULL without breaking the MPS.
[10:12:10] <gilberth> Then I don't see the point of this do{}while loop. And: NULL might not be NULL as /me also wants to play with tagging schemes. Especially using NaNs for pointers.
[10:12:46] <hayley> I think the aim is that you initialize it properly and save some bogus writes.
[10:16:10] <gilberth> ok. So an API wants to have an initial value.
[10:19:05] <hayley> Probably yes.
[10:20:32] <hayley> So Boehm had 744k page faults, malloc had 549k minor page faults, and the MPS had 1912.
[10:22:51] <hayley> The MPS thinks the benchmark needs 9MB of memory, Boehm 2.5MB and malloc 2.2GB.
[10:26:01] <hayley> Though if I do a parallel GC, it'd have thread-local allocation buffers and would only enter GC after the object is initialized, so no loop would be needed.
[10:39:20] *** Joins: [deleted] (~livoreno@user/notzmv)
[10:42:37] *** Quits: livoreno (~livoreno@user/notzmv) (Ping timeout: 256 seconds)
[10:44:28] <gilberth> hayley: "Your" scheme makes bets on struct alignment, which I don't like.
[10:49:39] <gilberth> layout, rather.
[10:50:41] <dave0> the kids nextdoor are having fun and giggling.. i hope someone drops a safe on them :-/
[10:57:47] <gilberth> dave0: You like children, don't you?
[10:58:25] <dave0> i believe that children are the future... unless we stop them now ;->
[10:59:16] <gilberth> dave0: Wait for hayley's GC on the fly to drop some heavy cons cells mid-fly.
[11:00:35] <gilberth> I hate C, as it cannot cope with forward references. Not for types.
[11:02:52] *** Quits: lad (~lad@user/lad) (Ping timeout: 268 seconds)
[11:02:57] <gilberth> Hence back to macros.
[11:06:11] <dave0> you know what would be corking? extensible c
[11:07:37] <gilberth> Extensible? In what way?
[11:08:30] <GreaseMonkey> honestly if you hate C, try Zig
[11:08:43] <dave0> being able to redefine it's syntax
[11:09:42] <dave0> can't lisp do that? forth can
[11:11:25] <gilberth> The syntax? Could I teach infix to forth? Make it grok #\a as a char?
[11:12:11] <dave0> yup
[11:12:18] <gilberth> dave0: For April I plan playing with just that: Augment the grammar by new productions.
[11:12:31] <gilberth> dave0: Do I get an AST? At compile time?
[11:13:43] <dave0> no but you can redefine the reader
[11:14:23] <gilberth> Like statement ::= "with_blah" "(" expression ")" statement => ... some code that returns a new AST ...
[11:14:43] <dave0> i'm not fluent with forth but it's very interesting.. it mingles interpret, compile, and run time
[11:15:33] <gilberth> Does it still have this screen idea and just being 16-bit?
[11:17:13] <dave0> i think i know what you mean by screen and yes... but the 16-bit thing has been relaxed in the 2012 standard
[11:17:36] <gilberth> In theory it should be possible to update an LALR(1) table at runtime. But I would need my books. I really should move them unless hayley needs them, when she moves.
[11:18:01] <gilberth> dave0: ok
[11:24:22] <hayley> gilberth: I am pretty sure that struct { blah; T foo[0]; } is supposed to behave.
[11:24:51] <hayley> https://stackoverflow.com/questions/11733981/what-is-the-purpose-of-a-zero-length-array-in-a-struct Oh, I am supposed to write T foo[] since C99.
[11:24:52] -ixelp- c - What is the purpose of a zero length array in a struct? - Stack Overflow
[11:31:30] <hayley> https://www.felixcloutier.com/x86/bextr x86-64 LDB instruction
[11:31:31] -ixelp- BEXTR â Bit Field Extract
[11:32:13] <dave0> it's called a flexible array member (fam) and it is standardizing a trick with malloc where you allocate a struct, plus space after the struct that you treat as an array (eg. array of char or a string)
[11:39:05] <gilberth> hayley: Yes, it's [] now, [0] was a hack.
[11:39:47] <gilberth> Do we have DPB too?
[11:40:51] <hayley> Good question.
[11:41:37] <hayley> No DPB but there is some other depositing thing https://en.wikipedia.org/wiki/X86_Bit_manipulation_instruction_set#Parallel_bit_deposit_and_extract
[11:52:12] <gilberth> hayley: BTW [old] clang-6.0 is quite clever when I need to expand octets to 32-bit words. I have not benchmarked it yet. <https://termbin.com/4o3e>
[11:52:34] * gilberth wants a fast UTF-8 decoder for CCL.
[11:53:52] <gilberth> That is 8 characters per loop iteration.
[11:57:58] <gilberth> Heh, don't try to outsmart your compiler. <https://termbin.com/e87a> :-)
[11:59:01] <hayley> -march=native -mtune=native
[11:59:16] <hayley> https://www.youtube.com/watch?v=8TEAMHgrxi0
[11:59:16] -ixelp- JJ Burnel - Crabs - YouTube
[12:01:40] <gilberth> Gets me this: https://termbin.com/c3yrk
[12:02:04] <gilberth> Though that is not 100% fair as it lacks the check for the MSB being unlit.
[12:02:43] <dave0> that's a lot of code
[12:02:58] <gilberth> dave0: Unrolled quite a bit.
[12:03:47] <gilberth> And it isn't too much, don't be mistaken by the long comments.
[12:07:49] <gilberth> I see eight instructions for 128 bytes produced, that is 32 characters.
[12:08:28] <gilberth> But this is just ISO-8859-1 to UCS-4.
[12:09:22] <hayley> https://twitter.com/zanaamedii/status/1411445448515244032 A "passport to paradise" from ISIS
[12:09:27] <dave0> utf-8 is variable length which probably makes things difficult
[12:09:37] <gilberth> Unfortunatly iconv(3) isn't too fast, otherwise I would just use that.
[12:11:01] <dave0> but the 1st byte in a utf-8 (sequence?) handily gives you the length of that (sequence?)
[12:11:26] <gilberth> dave0: Yes, but most of the time you only see 7-bit characters, so my idea is to test as many characters for that in one go and then copy/widen them. I don't care about the variable length part, that could remain slow.
[12:12:01] <gilberth> * as many as possible.
[12:12:09] *** Quits: derelict (~derelict@user/derelict) (Ping timeout: 256 seconds)
[12:13:14] <gilberth> World is slowly adopting UTF-8, yet protocols, programming languages, markup languages, etc are still 7-bit chars for the most part.
[12:13:39] <dave0> ascii has been around a lot longer than unicode :-)
[12:13:45] <dave0> unicode seems nice
[12:14:27] <gilberth> dave0: English does not need more than 7-bits. UTF-8 is nice as it is somewhat compatible.
[12:14:49] <gilberth> But: You hardly find any non 7-bit chars in say Lisp source code.
[12:15:04] <dave0> gilberth: but, like i like to often point out... you're german :-)
[12:15:38] <gilberth> And? That doesn't change the kind of data I want to scan and/or parse.
[12:15:55] <dave0> Ã· is a good one
[12:15:58] <dave0> instead of /
[12:16:53] <dave0> gilberth: you could write your variable names in german with umlats and other things i don't know about the german language
[12:17:23] <gilberth> How about â¤ and â¥ then? Still today programming languages stick to ASCII. But: I keep my files UTF-8 encoded never the less.
[12:18:01] <dave0> oh they're good ones too
[12:18:04] <gilberth> dave0: Fine, could you read them then? And understand what they mean?
[12:18:28] <dave0> â 
[12:18:29] * hayley ponders about what bitmaps are needed to make the damn GC.
[12:18:44] <dave0> gilberth: no way!
[12:18:45] <gilberth> And it would mix German and English unless there is a fully German CL with German symbol names.
[12:19:08] <dave0> how did english become the standard for source code?
[12:19:45] <gilberth> dave0: I setup every machine, even my phone and my car to English. Otherwise I would get "Are you sure? [Ja] [Nein] [Vielleicht]"
[12:20:13] <hayley> To handle interior pointers we have one bitmap with the starts of objects. Then we have another for marking. Either takes one bit per eight bytes, so a 1/32 overhead so far. Then to reuse lines we end up computing free bits per 128 bytes, which is pretty small.
[12:20:25] <gilberth> dave0: The US dominating CS. And it is a good thing, as everyone can read that.
[12:21:52] <gilberth> dave0: Actually any universially adopted lingua franca would de. It used to be German for physics before the war.
[12:23:03] <dave0> it would be interesting if the entire world spoke the same language
[12:23:12] <dave0> that's in the bible
[12:23:23] <hayley> I suppose compared to dlmalloc the overhead is pretty low.
[12:24:50] *** Joins: treflip (~user@95.79.32.99)
[12:27:16] <gilberth> dave0: I would giggle at a German programming language. (mit-geÃ¶ffneter-datei (ausgabe "foo.txt" :richtung :schreiben :externes-format :din-66303 :wenn-nicht-existent :erzeuge :wenn-existent :Ã¼berschreibe) (schleife fÃ¼r x in zeilen tue (schreibe-zeile x) endgÃ¼ltig (gebezurÃ¼ck w))) Brrrrrrrrrrr
[12:27:53] <dave0> that means about as much to me as the equivalent in english :-p
[12:28:12] <gilberth> dave0: I don't think that will ever happen. The whole world could be bilingual though, speak your local language and the lingua franca.
[12:30:04] <gilberth> And that happened before. What is standard German now once was a lingua franca in Germany. Not everyone spoke that.
[12:31:39] <gilberth> dave0: But there is a German Visual Basic!
[12:32:09] <dave0> ugh
[12:32:22] <gilberth> Yep. Ugly.
[12:33:45] <gilberth> I always found it very funny that CLISP has i18n for German and French error messages. I mean: How could you hardly be a hacker, when you cannot read English?
[12:34:35] <gilberth> In fact, I didn't really learned English in school, the teacher was just bad. I taught it to myself as I started to read CS literature.
[12:45:29] <gilberth> dave0: BTW, I never got where ":" did came from for division. I really don't use that.
[12:46:28] <dave0> Ã·
[12:46:42] <dave0> we had to write it like that in little school
[12:46:50] <dave0> but OTOH fractions was different
[13:19:07] <hayley> https://www.youtube.com/watch?v=c29AD5OJPNI
[13:19:07] -ixelp- 1984 / Dodo (2003 Remaster) - YouTube
[13:20:54] <hayley> GitHub says 2,699 poor souls have looked at wasm2ps and 7 have cloned it.
[13:24:50] <hayley> Crap, in a proper mark-sweep I would need either an auxiliary stack of arbitrary size (perhaps not going to happen) or a limited "cache" stack with another grey bitmap, right?
[13:26:36] <hayley> I could get the Handbook in dead tree format from the city.
[13:39:33] <hayley> The Handbook says one should look for objects which were marked but reference non-marked objects. But that seems like it would absolutely crap on one's cache so I may consider another bitmap for gray objects.
[13:41:30] *** Joins: kevingal (~quassel@2a02:8084:4140:f300:4c87:4e7b:4c37:18d7)
[14:11:44] *** Quits: [deleted] (~livoreno@user/notzmv) (Read error: Connection reset by peer)
[14:12:03] *** Joins: livoreno (~livoreno@user/notzmv)
[14:19:45] *** Joins: shka (~herr@109.231.62.239)
[14:20:37] *** Quits: kevingal (~quassel@2a02:8084:4140:f300:4c87:4e7b:4c37:18d7) (Remote host closed the connection)
[14:46:14] <hayley> gilberth: On my machine I see something like 2.91Âµs per trap + unprotect + return + protect cycle with gcc but then 134ns with gcc -O3. Knowing my luck it folded something stupid.
[14:52:04] *** Joins: pjb (~pjb@user/pjb)
[14:53:21] <hayley> 748ns on the Pi with -O3 which is also about right.
[14:54:22] <hayley> Oh, no, it's more like 1.2Âµs on the Pi, as I neglected the system time which is quite large.
[14:55:02] <hayley> Funny that on x86-64, it's something like 4:1 system:user but on ARM64 I see 1:2 system:user or so.
[14:58:19] <hayley> Also my GC would rather have a trap + unprotect + return loop which unprotects different parts. Hmm.
[15:20:45] *** Joins: domovod (~domovod@176.196.122.197)
[15:22:38] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Ping timeout: 244 seconds)
[15:23:54] <hayley> Oh, GCC folded out the loads from X in a loop.
[15:24:28] <hayley> 2.79Âµs on -O3
[15:26:50] <hayley> ...when I use volatile int* addr instead.
[15:27:55] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[15:32:27] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Ping timeout: 244 seconds)
[15:41:17] *** Joins: random-nick (~random-ni@87.116.179.138)
[15:51:27] <hayley> gilberth: https://plaster.tymoon.eu/view/2538#2538 runs in 3 seconds, i.e. 3.2Âµs per page unprotected.
[16:08:10] <gilberth> hayley: That is pretty slow.
[16:09:25] <hayley> I _could_ work with it. Fixing up pointers would probably take microseconds per page. And then https://sci-hub.st/https://dl.acm.org/doi/10.1145/1029873.1029877 agrees with my guess that increasing the "page" size to fix up leads to fewer but slower traps.
[16:09:25] -ixelp- Sci-Hub | Mostly concurrent compaction for mark-sweep GC. Proceedings of the 4th International Symposium on Memory Manag [...]
[16:10:36] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[16:11:06] <gilberth> Yes, but I bet we could do better with no kernel in between. And no context switches.
[16:12:13] <hayley> Sure, but I am already playing with knives w.r.t protecting random memory and GCC optimisation.
[16:13:14] <gilberth> Well, all of the optimizations GCC does are valid.
[16:13:51] * hayley reads the Pauseless paper. They rather protect the pages to relocate, but I am pretty sure they propagate fixed up pointers which is hard here.
[16:15:18] <hayley> "These trap handlers can be entered and left in a handful of clock cycles (4-10, depending) and are frequently used by the GC algorithm; fast traps are key."
[16:16:16] <hayley> They suggest you can emulate the trap with standard page protection would you always generate a bogus load instruction.
[16:17:38] <gilberth> What would that buy you?
[16:18:13] <hayley> That would be your read barrier without doing any real comparisons or branches on the fast path.
[16:18:27] <hayley> Not that a load is going to be faster.
[16:20:52] <gilberth> ok.
[16:21:50] <gilberth> I wonder how hard it'll be to fire up a second CPU^Wcore in bare metal.
[16:22:42] <dave0> sorry if i missed this before, but your wasm to ps compiler is on hacker news
[16:22:50] <gilberth> I mean: I would also enable alignment checks and use alignment faults for typechecks.
[16:22:56] <hayley> dave0: Yes, loke posted it.
[16:23:15] *** Quits: treflip (~user@95.79.32.99) (Remote host closed the connection)
[16:24:12] <gilberth> What I really want though is to use NaNs for pointers.
[16:25:01] <gilberth> I ought to figure out how to mmap negative addresses, or play tricks with segment registers.
[16:25:37] <hayley> Is it really necessary to STW to copy out objects in a consistent state? I guess so, as you have to ensure that the mutator doesn't do anything dumb while you're copying. Oh well.
[16:25:43] <gilberth> When Virtual Box or QEMU can do that, then I could too.
[16:26:32] <hayley> So our cycle looks like 1. scan for roots (STW or on the fly, idk take your pick) 2. concurrent marking 3. copy victim pages 4. fix up incrementally and concurrently
[16:27:52] <hayley> For what it's worth, we could reduce the damage by 4. if we segregate pointer-free objects into their own pages so they don't have to be pointlessly protected.
[16:33:55] *** Quits: elflng (~elflng@5.28.137.182) (Ping timeout: 265 seconds)
[16:42:33] <hayley> gilberth: Doesn't the kernel snarf higher addresses still?
[16:43:25] <gilberth> hayley: It does. But there must be an API besides mmap() that I don't know.
[16:44:05] <hayley> Now my name "Immix on a plane" is misleading as we don't have an on the fly GC.
[16:44:37] <gilberth> hayley: I mean: QEMU works after all.
[16:44:55] *** Joins: Alfr (~Alfr@user/alfr)
[16:44:58] <hayley> Also n.b. if we copy after marking, then we act conservative only then, as we can't copy objects that are ambiguously referenced.
[16:45:44] <hayley> QEMU either does dynamic recompilation or hardware emulation stuff though?
[16:45:58] <Alfr> Good morning.
[16:46:25] <gilberth> hayley: How would it recompile my pointers?
[16:47:27] <gilberth> Or Virtual Box, or Parallels, but the latter is Macos, which also doesn't let me mmap negative addresses.
[16:47:31] <hayley> gilberth: It couldn't fix up your register and stack, so it is conservative there. But if the heap is precise then we update that concurrently, with a read barrier if the mutator gets to a page quicker.
[16:47:39] <hayley> Oh, right, emulation.
[16:48:10] <hayley> I don't know, but it could do whatever. It has to handle emulated memory mapped IO too, right?
[16:48:31] <gilberth> Well, that is easy.
[16:49:51] <gilberth> But: People would complain when their Linux in a virtual PC would all of a sudden run slow.
[16:51:11] <gilberth> And I bet I have spotted negative addresses with an %fs prefix in Go too. I don't even know how to set up segments. And as Google does not work anymore, I didn't find anything => Use the source.
[16:52:27] <gilberth> Aren't segments back to what they once were? An offset to add to addresses?
[16:52:56] <gilberth> I'll figure out.
[16:54:15] *** Joins: derelict (~derelict@user/derelict)
[16:54:16] <gilberth> It can't be too obvious though since otherwise JS would use that.
[16:56:42] <gilberth> Or they just don't want to play any MMU tricks to be pretty portable and being hurt by random libc changes.
[16:57:18] <gilberth> Heck, even when using aligment traps, you better don't forget to switch those off, when entering libc.
[17:00:10] <hayley> In a paper, would you rather call the minimum mutator utilisation or the memory management unit the MMU?
[17:08:36] <gilberth> The latter.
[17:10:52] <hayley> Looking up "gc mmu" suggests the former is more common though
[17:14:19] <hayley> But I guess no one mentions hardware, only abstract memory operations.
[17:19:15] <dave0> nite all
[17:19:37] *** Quits: dave0 (~davezero@069.d.003.ncl.iprimus.net.au) (Quit: dave's not here)
[17:22:07] <gilberth> I haven't read many GC papers recently.
[17:24:20] <hayley> beach asked twice what's wrong with the SICL design. I mean, nothing, but I want to test this one out.
[17:25:11] <gilberth> Ok. The rest of ulisp compiles with just <https://termbin.com/3sij> Good. It was planed that way.
[17:27:25] <gilberth> But I'd really would like to have my own stack, at least as an option. I wonder, if some pre-processor could do that for me.
[17:29:09] <gilberth> It doesn't need to be a full C parser, It would only need to recognize arguments and lexical variables. And I could well live with everything in just one file.
[17:29:47] <hayley> Hmm...
[17:30:24] <hayley> LLVM has a crappy shadow stack so you can implement a GC. Post process the IR so that it has the shadow stack and rooting calls enabled?
[17:31:00] <gilberth> Sounds easy. Not.
[17:32:17] *** Joins: [deleted] (~livoreno@user/notzmv)
[17:32:32] <hayley> Sorry.
[17:32:39] <gilberth> I would need the stack for Ts only. I mean CLISP also has it, but manages it manually.
[17:33:34] *** Joins: brainfunnel (~quassel@176.128.208.46.dyn.plus.net)
[17:34:15] <hayley> Should I conservatively pin objects or pages? Guess I can reuse the gray bitmap for pinning when it is time to move.
[17:34:26] *** Quits: livoreno (~livoreno@user/notzmv) (Ping timeout: 272 seconds)
[17:35:39] <gilberth> I mean: Recognize any local variable. Alter the function body into { sp += n; /* clear, if you wish */ #define x sp[0] #define y sp[1] .... #undef x #undef y done: sp -= n; return res; } And make return x into do{ res = x; goto done; }while(0) shouldn't be too hard.
[17:37:35] <hayley> So there is the answer. Also, freeing can happen concurrently with both copying and fixing up the heap, not that it matters.
[17:38:04] <gilberth> Do the same for function arguments. make T foo (T x, T y) into #define foo(x,y) ( *++sp = x, *++sp = y, real_foo () )
[17:41:22] <gilberth> Or rather have linked frames on the stack, so that GCC still could have things in registers until the next transfer to another function.
[17:42:24] <hayley> In irrelevant news, I suppose my ex didn't listen to me unless it was necessary.
[17:43:05] <gilberth> Necessary?
[17:43:13] <hayley> She already heard about what that person did to me, then she decided I was too grumpy when I said they were an asshole.
[17:44:16] <hayley> gilberth: Like if I obviously wanted a response, e.g. asking a question. Otherwise I was ignored.
[17:44:55] <gilberth> What made you being together with her then?
[17:45:41] <hayley> I forgot.
[17:46:00] <gilberth> Then, my dear, it was not important. :)
[17:46:50] * hayley sighs
[17:49:09] <gilberth> Well, I am hardly an expert in relationship related issues, I didn't have many. Only two or three relevant ones. Depends on how you count.
[17:54:30] <gilberth> But all of them lasted pretty long. *shrug*
[17:56:04] <gilberth> I am still kinda in love with my last GF, but she wouldn't do me good in the long run, so I quit early.
[17:56:26] <gilberth> Anyhow, would I write that pre-processor in C or in Lisp?
[17:59:02] <gilberth> PostScript?
[17:59:50] *** Joins: cammie (~cammie@pa49-181-189-8.pa.nsw.optusnet.com.au)
[18:05:58] * hayley uploaded an image: (129KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/IaxxBOmGuviqQiWBPQcdGxie/producer-consumer.png >
[18:06:43] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 265 seconds)
[18:07:18] <gilberth> Bored?
[18:08:14] <hayley> Yes.
[18:08:27] * hayley still needs to write about terminal boredom.
[18:08:49] <shka> gilberth: how do make object in clim move from one side to the other smoothly?
[18:09:15] <gilberth> hayley: Boredom from sitting at the terminal?
[18:09:34] <hayley> Something like that.
[18:09:39] <gilberth> shka: With McCLIM? You don't.
[18:09:56] <shka> oh
[18:10:30] <shka> that's kinda bad
[18:10:36] <hayley> I did this in my shitty Sketchpad once. Have another thread repeatedly send a redraw event and have the handler redraw.
[18:10:38] <gilberth> I mean, does McCLIM have proper double buffering yet? I doubt.
[18:10:46] <shka> i don't think it does
[18:10:59] <shka> but it was a WIP, irc?
[18:11:00] <gilberth> hayley: Yep, that's the way to go.
[18:11:26] <gilberth> shka: WIP = ?
[18:11:35] <hayley> https://github.com/no-defun-allowed/Sketchpad/blob/master/Code/CLIM/sketchpad.lisp#L53
[18:11:35] <shka> work in progress
[18:11:35] -ixelp- Sketchpad/sketchpad.lisp at master Â· no-defun-allowed/Sketchpad Â· GitHub
[18:13:41] <gilberth> With my CLIM, I would just queue a redraw and/or modify the dirty region. Then in the repaint handler queue another. It'll syncronize to your refresh rate under Macos. Can't synchronize in X11 though. There is nothing in X11 to do that.
[18:14:45] <gilberth> So with X11 it would synchronize to the drawing speed, but with double buffer. BTW it is a real pity that the otherwise very nice double buffering extension in X11 is broken.
[18:14:53] <pl> gilberth: NaNs for pointers are source of many bugs in Mozilla's JavaScript
[18:15:01] <pl> not sure if V8 does it the same way
[18:15:26] <shka> ok, so i can't do smooth animation of points sliding around the map
[18:15:40] <gilberth> pl: Well, only because they have bugs, does not imply that I would have those too.
[18:16:12] <pl> gilberth: I'm pretty sure X11 the protocol has the necessary stuff, it's the XFree86/X.Org's lowest common denominator code that can't do that
[18:16:37] <gilberth> shka: Well hayley pointed you the way. Have a thread triggering repaints every so often and make the repaint handler then read the wall clock to compute the new position.
[18:16:44] <hayley> Funny, my UI did fairly smooth animation of points under gravity and spring forces.
[18:17:14] <shka> gilberth: that's what i will do
[18:17:27] <shka> but boy, this will look so dated
[18:17:28] <gilberth> pl: Yes, that would be news to me. I have not yet found anything that would do vsync'ed buffer flips and "interrupt" me.
[18:18:24] <gilberth> Aside from OpenGL that is.
[18:19:36] <gilberth> And GLX doesn't really mix with the rest of X11.
[18:21:20] <gilberth> pl: Anyhow, the double buffering extension is almost there. It's only that the shitty implementation resizes the backbuffer each time the window is resized, which is really slow and not how you would do that, you'd rather have one single back buffer the size of the screen and be set.
[18:22:43] <gilberth> I have seen attempts in McCLIM, which would allocate a back buffer pixmap per window^Wsheet and this won't work. I have a back buffer per top level sheet, shared by [sub] sheets.
[18:23:20] <gilberth> But then my sheets are non-mirrored.
[18:25:00] <gilberth> And I resize with a damn hysteresis on top level sheet resizes.
[18:26:59] <gilberth> However I plan to invoke the trick Cocoa uses for scrolling: It would keep a back buffer for a scrolled paned a bit larger than the viewport, so that on small scrolls the redraw is just a bitblt. The repaint handler then is called ahead to render parts not yet visible for when the user scrolls further.
[18:28:24] <gilberth> It's all a question of proper buffer handling.
[18:28:46] <gilberth> Damn, I can't hack all at once. :(
[18:42:50] <shka> gilberth: relax man
[18:59:05] <gilberth> shka: http://bauhh.de/clim-animation.mp4
[18:59:22] <shka> gilberth: you just wrote this?
[18:59:47] <gilberth> Yep, for you. This is X11 btw.
[19:00:02] <shka> oh, wow, thanks!
[19:00:14] <shka> i love this <3
[19:00:22] <gilberth> Most simple demo. You're welcome.
[19:00:28] <shka> yes
[19:00:31] <gilberth> Should work with McCLIM too.
[19:00:31] <shka> pretty simple
[19:01:46] <gilberth> What I really love with CL is that you could hack the repaint handler while the animation is running.
[19:03:23] <shka> yeah, i know
[19:05:34] <gilberth> It is embarrassing to see how slow I type. :(
[19:06:10] <shka> it is ok, ma
[19:06:11] <shka> n
[19:10:13] <gilberth> Unless someone managed to break McCLIM, it should merge queued repaint events in case the timer loop overruns actual repaint speed.
[19:37:17] *** Quits: pjb (~pjb@user/pjb) (Ping timeout: 258 seconds)
[19:52:53] *** Quits: trn (jhj@2600:3c00::f03c:92ff:feb2:b9ef) (Changing host)
[19:52:53] *** Joins: trn (jhj@sourcehut/user/trn)
[20:01:48] <gilberth> shka: With output records: <http://clim.rocks/gilbert/clim-animation-with-output-records.lisp> <http://bauhh.de/clim-animation-with-output-records.mp4>
[20:02:24] <shka> gilberth: sorry, but i am not fluent in clim
[20:02:30] <gilberth> I wanted to get a bit more fancy, but most of time was wasted to figure out how avconv could scale a movie.
[20:02:33] <shka> what are the output records?
[20:03:01] <gilberth> shka: The display lists behind output recording streams.
[20:03:44] <gilberth> As in an interactor the interactor has to remember the output done. This is the output record [history].
[20:04:27] <shka> hmmm
[20:04:35] <gilberth> Here the FOO pane is an APPLICATION-PANE, which records drawing to it, so that it could repaint itself.
[20:05:13] <shka> i think i will go offline 
[20:05:23] <shka> gilberth: thanks for the the code
[20:05:26] <gilberth> DOIT is not the repaint handler. But just draws something and then in a loop moves the one output record with the two circles in it.
[20:05:58] <gilberth> shka: You're welcome. I was curious whether it would work with said output records too.
[20:07:22] *** Joins: notzmv (~zmv@user/notzmv)
[20:08:32] <gilberth> Heh, this poor 80s shadow effect makes me wanting to write an Oxyd clone in CLIM. :-)
[20:09:10] <gilberth> I could borrow the levels and graphics from Enigma.
[20:13:11] <shka> what is oxyd?
[20:13:43] <gilberth> A pretty cool game I once played on an Atari ST.
[20:15:01] <shka> games for atari st?
[20:15:11] <gilberth> Yes.
[20:15:20] <shka> atari st was rather expensive system back in the day
[20:17:25] <gilberth> You naviagte a marble with your mouse and it bounces off walls and stuff. Your goal is to find matching "oxyd" stones and open them. There would be different grounds like sand, smooth surfaces, etc. The physics simulation felt pretty good. You perhaps find game play videos on YT or try Enigma, which is a bad clone as they got physics wrong.
[20:18:05] <gilberth> shka: I "borrowed" one from the company.
[20:18:32] <shka> aah, makes sense :-)
[20:19:00] <shka> wiki says that there was amiga port, but i've never seen it
[20:20:31] <gilberth> https://www.youtube.com/watch?v=tm6ZgMKBL38 skip the first 3+ minutes. My version was B/W, as I had no colour monitor for the ST.
[20:20:32] -ixelp- Oxyd - Atari ST (1992) - YouTube
[20:21:25] <gilberth> https://www.youtube.com/watch?v=bYZe6t-gjsUÂ Â  <-- This is the version I had.
[20:21:25] -ixelp- Oxyd Magnum (Atari ST) Level 1-27 - YouTube
[20:23:03] <gilberth> Deutsche Wertarbeit :-)
[20:26:09] <gilberth> I'd love to play it again, the puzzles get really challenging with time.
[20:32:47] *** Joins: kevingal (~quassel@2a02:8084:4140:f300:983c:267:434:16fb)
[20:32:50] *** Joins: elflng (~elflng@5.28.137.182)
[22:00:59] *** Joins: greyrat (~greyrat@ip202.ip-51-178-215.eu)
[22:01:18] *** Joins: lucerne (~lucerne@ip202.ip-51-178-215.eu)
[22:02:26] *** Server sets mode: +nrt 
[22:17:01] *** Joins: treflip (~user@95.79.32.99)
[22:30:01] *** Joins: derelict (~derelict@user/derelict)
[22:45:35] *** Quits: domovod (~domovod@176.196.122.197) (Quit: WeeChat 3.2)
[23:05:25] *** Quits: treflip (~user@95.79.32.99) (Remote host closed the connection)
[23:12:06] *** Quits: cammie (~cammie@pa49-181-189-8.pa.nsw.optusnet.com.au) (Quit: Quit)
[23:22:57] *** Joins: cammie (~cammie@pa49-181-189-8.pa.nsw.optusnet.com.au)
[23:30:48] *** Quits: emacsomancer (~emacsoman@c-174-52-88-123.hsd1.ut.comcast.net) (Quit: WeeChat 3.2)
[23:31:53] *** Joins: emacsomancer (~emacsoman@c-174-52-88-123.hsd1.ut.comcast.net)
[23:46:04] *** Quits: cond (~example@user/aeth/bot/cond) (Ping timeout: 258 seconds)
[23:57:04] <aeth> Huh, that's weird. My bot lost its connection to here (it doesn't autoreconnect because idk what to check to determine a disconnection yet) and my irssi lost its connection to oftc and that's it.
[23:57:58] <aeth> I'm guessing switch/router/modem/ISP issue that sometimes kills long-lived TCP connections or something
[23:58:04] <aeth> (one or more of the four)
