[00:04:15] *** Quits: ardon (~user@user/ardon) (Remote host closed the connection)
[00:56:57] *** Quits: aartaka (aartaka@gateway/vpn/protonvpn/aartaka) (Ping timeout: 240 seconds)
[01:04:44] *** Joins: aartaka (aartaka@gateway/vpn/protonvpn/aartaka)
[01:09:19] *** Quits: aartaka (aartaka@gateway/vpn/protonvpn/aartaka) (Ping timeout: 256 seconds)
[03:35:29] *** Quits: ano (~ano@user/ano) (Remote host closed the connection)
[03:35:55] *** Joins: ano (~ano@user/ano)
[03:54:45] <qhong> jmercouris: IMO because category is just re-formulating logic in a different (maybe more esoretic) language, but the underlying things and complexities are fundamentally the same. Sometimes reformulating makes them easier to work with, but will never makes them go away
[03:55:11] <qhong> jmercouris: The "reformulating logic" notion is itself formualized by "internal language"
[03:57:06] <qhong> jmercouris: Also type-free lambda calculus is formally more expressive than any of those logic, and most Lisps are formally more expressive than type-free lc, so we can almost always embed whatever stuff Haskeller come up with in Lisps. Sometimes this does not happen because there's already a better way, or just because there's no enough interest
[03:58:19] <mariari> jmercouris: monads are being phased out in due time. but even Lispers use monads, see mapcan
[03:58:24] <mariari> mapcan is a monad for lists
[03:59:02] <mariari> jmercouris: the main issue with monads is how they compose, they are actually quite neat at explaining some amount of computational effects
[03:59:43] <mariari> jmercouris: lens typically are disliked for how heavy their signatures are, but you can view them as functional getters and setters for data, something that is missing from the CL standard, and I always have to define myself
[04:13:22] <qhong> mariari: Have you tried modf?
[04:14:35] <mariari> modf?
[04:15:16] <qhong> it's a common lisp library for non-destructively setter
[04:15:34] <mariari> oh that sounds really helpful
[04:15:52] <mariari> does it plug in nicely with defsturct
[04:15:56] <mariari> I find I use defstruct a lot
[04:19:20] <qhong> mariari: Yes, just use modf:defstruct instead of cl:defstruct
[04:21:02] <qhong> In fact I think the wisedom is already there, inside cl:setf -- it knows how to *compose* setters. modef simply makes a non-destructive clone
[04:21:15] <qhong> modef -> modf
[04:21:15] <mariari> yeah setf is a neat system
[04:21:24] <mariari> I just wished it did that for non mutable setters as well
[04:21:40] <mariari> I will say I wish defsturct had a deriving system
[04:21:54] <mariari> when I worked in clojure I made a defadt abstraction that gave me exhasution in pattern matching
[04:57:59] <lagash> mariari: uh, monads being phased out? in Haskell? CL? CS in general?
[04:58:13] <mariari> lagash: in general
[04:58:17] <mariari> same with haskell and the like
[04:58:22] <mariari> monads as an idea won't go away
[04:58:25] <mariari> but the overuse of them will
[04:58:33] <mariari> as monads do not compose well, and we have better models that are faster now
[04:58:40] <mariari> but moands liek CL mapcan won't go out of style
[04:59:17] <lagash> so that's a better model then?
[04:59:35] <lagash> *what's
[05:00:15] *** Joins: pedro-delfino_ (sid507296@id-507296.helmsley.irccloud.com)
[05:00:47] <mariari> algebraic effect systems
[05:00:56] <mariari> you can see an untyped slower version in the CL condition system
[05:01:00] <mariari> it's just now hitting ocaml
[05:01:17] <mariari> haskell will get it in time, but it's a proepr way to compose typed or untyped effects in a way that is fast
[05:01:29] <mariari> fun fact fx-87 was the first language to play with it, a scheme derivative on I think a lisp machine
[05:01:39] <mariari> can't find any implementations of the FX languages adly
[05:01:42] <mariari> sadly*
[05:01:57] <lagash> what languages are at the forefront of this new and shiny idea?
[05:02:04] <mariari> ML's
[05:02:13] *** Joins: sochotnicky (~w0rm@redhat/sochotnicky)
[05:02:19] <mariari> so the family of ocaml, haskell, F*, etc.
[05:02:26] <lagash> figured as much
[05:02:30] *** Joins: ogamita`` (~t@hubble.informatimago.com)
[05:02:34] <mariari> OCaml's multicore version has it now, but it's more untyped due to backwards compatability reasons
[05:02:47] <lagash> I take it they're even more harder to explain than monads? :P
[05:02:50] <qhong> mariari: isn't they all just inventing different ways to call exactly the same thing?
[05:02:52] *** Joins: dragestil_ (~znc@user/dragestil)
[05:03:00] <mariari> no qhong
[05:03:02] <qhong> algebraic effect = delimited continuation = layered monad
[05:03:07] <qhong> (monadic reflection)
[05:03:17] <mariari> they aren't just deliminited continatuions
[05:03:24] *** Joins: mydraal_ (~mydraal@2a02:a03f:e856:ba00:e65f:1ff:fe0b:a1d4)
[05:03:25] <mariari> they aren't any monad system either
[05:03:32] <qhong> what's the difference?
[05:03:35] <mariari> IIRC ocaml was playing with using stacks to implement their system
[05:03:43] <qhong> I'm specifically referring to monadic reflection
[05:03:49] <qhong> oh so you mean impl. strategy
[05:03:55] <mariari> it's in the specifics of how they compose, and how they extend
[05:04:05] <mariari> also LISPERS were at the start of algebraic effects
[05:04:09] <qhong> from language aspect, they're exactly the same thing
[05:04:19] <mariari> not really, monads compose horribly
[05:04:30] <mariari> and exhibit horrible behavior when you try to extned or use them properly in that sense
[05:04:43] <mariari> usually end up in transformer hell
[05:04:54] <mariari> many haskell libraries have tried to get around it
[05:05:07] <mariari> what I use at work, binds around it, giving 1 flat monad stack even though we have many "effects"
[05:05:26] <mariari> the idea is old though, it's just now fast enough to be used everywhere
[05:05:29] *** Joins: drakonis1 (drakonis@user/drakonis)
[05:05:52] <qhong> If you're refering to monad in haskell, well it isn't even a proper monadic reflection system
[05:06:01] <lagash> mariari: what do you use at work now? something proprietary?
[05:06:05] <mariari> no
[05:06:12] <mariari> it's an open source library I think it's called capability
[05:06:25] <lagash> written in? CL?
[05:06:30] <mariari> https://www.tweag.io/blog/2018-10-04-capability/
[05:06:35] <mariari> no I use haskell for work
[05:06:40] <mariari> I prototype work stuff in lisp though
[05:06:40] <qhong> mariari: I'm referring to: Filinski, Andrzej. "Representing layered monads." Proceedings of the 26th ACM SIGPLAN-SIGACT symposium on Principles of programming languages. 1999.
[05:06:58] <mariari> qhong: I'd have to read it, but I suspect it's either 1. slow, or 2. doesn't compose too well
[05:07:15] <qhong> it's not an implementation so there's no slow or fast problem
[05:07:24] <mariari> or maybe on the way to the road of algebraic effects, I'm not too sure
[05:07:50] <qhong> it's same thing as alg eff, from language aspect. Also same as delimited continuation
[05:08:26] <qhong> Also ppl tend to associate a specific implementation trick to a term referring to a language feature, but they're really orthogonal
[05:09:05] *** Quits: pedro-delfino (sid507296@id-507296.helmsley.irccloud.com) (Ping timeout: 240 seconds)
[05:09:05] *** Quits: mydraal (~mydraal@2a02:a03f:e856:ba00:e65f:1ff:fe0b:a1d4) (Ping timeout: 240 seconds)
[05:09:06] *** pedro-delfino_ is now known as pedro-delfino
[05:09:06] *** Quits: MetaYan (~MetaYan@c-7b5d235c.07-84-7462671.bbcust.telenor.se) (Ping timeout: 240 seconds)
[05:09:07] *** Quits: ogamita` (~t@hubble.informatimago.com) (Ping timeout: 240 seconds)
[05:09:07] *** Quits: dragestil (~znc@user/dragestil) (Ping timeout: 240 seconds)
[05:09:07] *** Quits: w0rm (~w0rm@redhat/sochotnicky) (Ping timeout: 240 seconds)
[05:09:07] *** Quits: drakonis (drakonis@user/drakonis) (Ping timeout: 240 seconds)
[05:09:07] *** dragestil_ is now known as dragestil
[05:09:37] <mariari> sure, I understand that, but it depends what this represents
[05:09:51] <mariari> I know for example F* has an "effect system" but it's not really algebraic effects, and thus it's hacky at the seams
[05:10:03] <mariari> they use some monad, I forget the specific one to represent it, and it turns out not to work the best in practice
[05:11:06] <mariari> but yeah I'd have to read this paper
[05:12:12] <mariari> I just wish ML's were lisps
[05:12:15] *** Quits: ecocode (~ecocode@ks39550.kimsufi.com) (Ping timeout: 256 seconds)
[05:12:15] <mariari> would save me a lot of time
[05:14:16] *** Joins: ecocode (~ecocode@2001:41d0:1:6a74::1)
[05:14:39] <lagash> mariari: and what of lenses?
[05:15:01] <mariari> I use lenses, though with the newest haskell you can get it out of record syntax now
[05:15:05] *** drakonis1 is now known as drakonis
[05:15:20] <mariari> i mostly only use ^. and set and modify
[05:15:49] <mariari> ^. is get kind of like foo.bar.baz
[05:15:56] <mariari> but you have to write foo^.bar.baz
[05:16:16] *** Joins: MetaYan (~MetaYan@c-7b5d235c.07-84-7462671.bbcust.telenor.se)
[05:16:49] <mariari> or do you mean what will happen to lenses?
[05:17:01] <lagash> OK, say I wanted to write some sort of RSS/Atom feed "proxy" which grabbed feeds, modified the XML in different ways for different feeds, then serve them.. what am I looking for?
[05:17:42] <lagash> It's been bugging me for a few years and I really want to write some software to accomplish this but so far, no tomato.
[05:17:43] <mariari> something to either 1. work over the XML fast as is, or 2. is able to put it in a data structure you can quickly modify
[05:18:35] <qhong> mariari: I just wish ML's were lisps -> Not gonna happen as long as ML is statically typed :/
[05:19:01] <mariari> qhong: lisps could easily be statically typed, macros are just a syntax to syntax transformation
[05:19:04] <mariari> I don't see what stops them
[05:19:13] <lagash> I don't care too much about performance, I just want to read and write XML in the same data structure, and manipulate said structure in particular, composable, ways
[05:19:27] <mariari> by quick I mean quick to manipulate in code, not speed per say
[05:19:31] *** Joins: Jing (~hedgehog@115.207.57.60)
[05:20:07] *** Quits: Jing (~hedgehog@115.207.57.60) (Client Quit)
[05:20:31] <mariari> qhong: type theory is just logic, meta programming in essence
[05:20:47] <mariari> esp as you get to dependent types, their type theory has a core which can extend itself on the type level
[05:21:04] <qhong> mariari: In terms of flexibility. Static type will always prevent you from writing something you want to write
[05:21:05] <mariari> just add a way to get syntactic extensions and you'd be golden
[05:21:17] <qhong> mariari: Because human's mind are not built well-typed
[05:21:21] <lagash> So far I've been using Clojure and one or two different lens libraries but every feed library has some issue like it cannot write feeds back, or it doesn't handle CDATA, or some other dumb thing
[05:21:50] <mariari> qhong: you can always cheat the typer, after all dependently typed languages have admit for a reason
[05:22:25] <mariari> qhong: I think most processing of things can be done in subset of of dependently types, let's says standard HM types, you can drop out for architectural concerns as those are hard to type
[05:22:29] <mariari> and get some proof where you care for
[05:22:58] <qhong> HM types -> you're refering to Hindler Miller types? They're not dependent types
[05:23:06] <mariari> correct
[05:23:09] <qhong> But I admit it looks like some sort of sweetspot
[05:23:15] <mariari> I'm saying a lot of processing can be done in that
[05:23:25] <mariari> there are type theories which allow you to limit the power of your system, so you can regain inference
[05:23:46] <mariari> you can probably try out lattices for nice anonymous unions while preserving inference
[05:23:52] <qhong> I remember there's a special theoretical property associated with System F, but I can't recall immediately. Something like a special class of program property are exactly captured by System F
[05:24:30] <mariari> I'm not sure of the name, most ML's are some superset of system F omega
[05:24:43] <qhong> I still think being able to do it =/= good at doing it
[05:24:59] <qhong> One important property is flexibility
[05:25:05] <mariari> I think for a lot of basic logic it can easily be typed
[05:25:12] <mariari> I think the issues start to appear in architectural concerns
[05:25:52] <mariari> like often if I'm building a language processor, the layer I'm working on can typically be typed, when I start combining layers, I break down to sexps and deal with that untyped
[05:25:57] <qhong> I agree. IMO the philosophical difference is whether to build system out of rigid well-behaved components, or "autonomous" DWIM components
[05:26:19] <mariari> I just think you can type those autonmous DWIM components for the parts you care about
[05:26:32] <mariari> it's very hard to argue against types at work, at least I always feel on the losing end when I argue against it
[05:26:39] <mariari> but I think for examples lisps can better type themselves than an ML
[05:26:48] <mariari> see micropass compilers in scheme which are able to type their passes
[05:27:14] <mariari> being able to meta program, means being able to extend your type theory in a sense, and since ML's typically lack it they aren't able to properly extend, even if their type theory allows it
[05:27:23] <qhong> The cool thing about DWIM components is that the system can still function when you change the functionality of some components, even if formally the type become completely different
[05:27:33] <mariari> See many thesis's about adding good module semantics to agda but having to build a new language for it even though it is derivabel
[05:27:46] <qhong> I guess it can be alleviated by a fully automatic type inference system, but usually this means the type system has to be weak enough
[05:27:49] <mariari> you still have some similar interface they are calling are you not?
[05:27:51] <qhong> and it ends up sort of like SBCL
[05:28:08] <mariari> like you have some sort of function apis you are respecting when you do that kind of transformation
[05:28:29] <mariari> also have you seen unison? They have an image and are an ML, offer some nice tricks for updating the image
[05:29:02] <qhong> offer some nice tricks for updating the image => interesting, I'll take a look
[05:29:04] <mariari> I also think you can really abuse dependent types and effect typing with lisp style images
[05:29:12] <mariari> I really think they aid each other quite well
[05:29:17] <mariari> types and macros are similar in many regards
[05:29:21] <qhong> what I worry the most is when you change the type of a component
[05:29:41] <mariari> well what cases break in lisp, I suspect it's similar
[05:30:02] <qhong> Either your type system is weak enough so you can do full inference to update descendent components, or you have to propagate change to annotations manually
[05:30:34] <qhong> It doesn't break that much in lisp, if components always do reasonable things for somewhat reasonable inputs
[05:30:51] <mariari> yeah I think that's because the ultimate interface of what you're going to hasn't changed in a sense
[05:31:14] <mariari> I think automated tools can help you update type signatures as well, if extneral changes do happen
[05:31:30] <qhong> mariari: If type system is weak enough
[05:31:31] <mariari> but I'd argue if you add a field to a record, not much bad happens, we can even do it in CLOS, and it's mostly fine
[05:31:50] <mariari> I'd argue even if the type system isn't weak enough, depending on the class of change we are talking about
[05:32:33] <mariari> a closed type adding a new option, that should be fine, a record adding a new field, that should be fine. A record removing a field, will propgate type errors for functions which use said field
[05:32:57] <mariari> if you are changing out big api of types and how they work, things will break, but I suspect that'll be for lisp programs as well
[05:33:05] <mariari> unison has interesting features to push all those changes at once
[05:33:13] <mariari> so you don't brick your running program while trying this out
[05:33:18] <mariari> or at least from what I recall
[05:33:26] <mariari> I think first class images would help here as well
[05:36:02] <mariari> I think another major failing with ML languages is that their type universes (ML sum types) are almost always closed
[05:36:22] <mariari> and getting open types is a pain. Scheme compilers end up representing this a lot better due to what meta programming allows them to do
[05:39:45] <lagash> mariari: so, concerning my XML question, what would you recommend? am I looking for something other than lenses to read & modify deeply nested structures?
[05:40:11] <lagash> also I assume there's more than one type of lens - I heard of profunctory lenses, I believe
[05:43:00] *** Quits: ano (~ano@user/ano) (Ping timeout: 276 seconds)
[05:43:21] *** Joins: ano (~ano@user/ano)
[05:48:36] <mariari> lenses are fine for that kind of work lagash, yeah just because you want to compose a bunch of transfomrations over some data easily
[05:51:27] *** Quits: ano (~ano@user/ano) (Ping timeout: 276 seconds)
[05:57:32] <lagash> anything else come to mind?
[05:59:15] <mariari> not particularly, I'm sorry
[06:05:06] *** Joins: ano (~ano@user/ano)
[06:27:57] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 240 seconds)
[06:40:12] *** Quits: ano (~ano@user/ano) (Ping timeout: 276 seconds)
[06:42:02] *** Joins: ano (~ano@user/ano)
[07:23:05] *** Quits: geyaeb3 (~geyaeb@gateway/tor-sasl/geyaeb) (Remote host closed the connection)
[07:23:40] *** Joins: geyaeb3 (~geyaeb@gateway/tor-sasl/geyaeb)
[09:40:06] *** Joins: rullie (~rullie@dhcp-108-168-108-199.cable.user.start.ca)
[09:47:02] *** Joins: aartaka (aartaka@gateway/vpn/protonvpn/aartaka)
[11:20:12] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Quit: brb)
[11:44:44] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[13:13:25] *** Joins: tekakutli (~user@201.141.28.4)
[13:15:47] *** Joins: ardon (~user@user/ardon)
[13:30:44] *** Joins: Jing (~hedgehog@240e:390:7c53:a7e1:dc72:6181:1705:c2cc)
[13:58:55] *** Quits: tekakutli (~user@201.141.28.4) (Read error: Connection reset by peer)
[14:06:19] *** Joins: tekakutli (~user@201.141.28.4)
[14:24:18] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Ping timeout: 276 seconds)
[14:36:33] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[16:36:13] *** Joins: taiju (~taiju@240b:253:ec40:2400:5cec:b035:3bed:59cc)
[17:25:06] *** Quits: tekakutli (~user@201.141.28.4) (Read error: Connection reset by peer)
[17:33:38] *** Joins: tekakutli (~user@201.141.28.4)
[17:49:57] *** Quits: taiju (~taiju@240b:253:ec40:2400:5cec:b035:3bed:59cc) (Ping timeout: 240 seconds)
[17:52:51] *** Joins: taiju (~taiju@240b:253:ec40:2400:5cec:b035:3bed:59cc)
[19:30:43] *** Quits: tekakutli (~user@201.141.28.4) (Read error: Connection reset by peer)
[19:44:49] *** Parts: rullie (~rullie@dhcp-108-168-108-199.cable.user.start.ca) ()
[20:23:09] *** Joins: rotateq (~user@p200300e787097300818cd04b4ea1a4f3.dip0.t-ipconnect.de)
[21:02:25] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[21:02:39] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[21:25:10] *** Quits: Jing (~hedgehog@240e:390:7c53:a7e1:dc72:6181:1705:c2cc) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[21:25:40] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[21:52:15] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[21:55:16] <rotateq> lel it seems to me the newer firefox tab policy is like "when this tab wasn't touched some minutes, then dump it" so it must be reloaded. what a shame, how can i rely on that if I'm on the ride?
[21:55:25] <rotateq> with using nyxt :)
[22:19:15] *** Parts: pranavats (3fba1d1b34@jabberfr.org) (Error from remote client)
[22:19:43] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[22:25:30] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[22:44:36] <aartaka> rotateq: Yeah, it's even documented, at least in WebExtensions docs :)
[22:45:13] <rotateq> lel. Mozilla, what have you become?
[23:00:52] <Aurora_v_kosmose> I actually would like to have that feature, but tabs should be pinnable for load-maintain too.
[23:01:01] * Aurora_v_kosmose is stuck with old Debian versions
[23:01:19] <Aurora_v_kosmose> Incidentally doing such a modification on Nyxt would be very simple.
[23:07:27] <rotateq> hehe
[23:07:49] <rotateq> and yes of course, i like it for itself too, but not just for everything here by default
[23:08:24] <rotateq> but ok, maybe firefox is more configurable, never really looked into it seriously, just some add-ons and such
