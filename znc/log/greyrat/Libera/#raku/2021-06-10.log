[21:34:22] *** Joins: greyrat (~greyrat@ip202.ip-51-178-215.eu)
[21:34:22] *** Server sets mode: +nt 
[21:35:04] <greyrat> Is the perf of raku better than perl?
[21:45:48] <moritz> it always depends on what you do
[21:46:17] <moritz> there are cases where rakudo is faster than perl 5 (like tight loops with natively typed variables), and things where perl5 wins out hands down, like regexes
[21:54:32] <greyrat> I was thinking of simple one-liners for data processing (`perl -lpe`)
[21:54:45] <greyrat> It seems perl5 is still best there?
[22:04:46] <MasterDuke34> probably, raku's startup time is a bit slower than perl's
[22:04:51] <Altreus> I would expect (he says, carefully) that you are more likely to run across unoptimised Raku than unoptimised Perl5 given an arbitrary thing
[22:05:00] <Altreus> program
[22:09:49] *** Joins: Raycat|Work (~RaycatWho@2601:241:8f80:5250:d4:8062:fb99:2fc4)
[22:22:24] *** Quits: monkey_ (~user@190.104.116.134) (Ping timeout: 252 seconds)
[22:23:35] *** Quits: ufobat__ (~martin@dynamic-095-117-092-027.95.117.pool.telefonica.de) (Ping timeout: 252 seconds)
[22:24:39] *** Joins: monkey_ (~user@190.104.116.134)
[22:25:32] <jdv> compilation and relatedly regexes tend to be slow
[22:26:51] *** Joins: ufobat__ (~martin@dynamic-095-117-092-027.95.117.pool.telefonica.de)
[22:32:23] <m6locks> https://www.youtube.com/watch?v=Kba9HqqBopA
[22:32:46] *** Quits: reportable6 (rep-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[22:35:38] *** Joins: reportable6 (~rep-able@ns306169.ip-94-23-219.eu)
[22:53:52] *** Joins: Doc_Holliwood (~holli@ipservice-092-218-232-220.092.218.pools.vodafone-ip.de)
[23:00:03] *** Joins: sono (~sono@107-209-210-210.lightspeed.sntcca.sbcglobal.net)
[23:02:53] *** Joins: colomon (~colomon@097-095-165-088.res.spectrum.com)
[23:03:22] <colomon> o/
[23:03:48] <colomon> hi gang, I’m trying to figure out if the behavior I’m seeing in Hash.append is intentional or a bug
[23:05:44] <colomon> m: my %a = a => [1, 2, 3]; my %b = a => [4, 5, 6], b => [7, 8, 9]; %a.append(%b); say %a; %b<a>.push: 100; %b<b>.push: 200; say %a;
[23:05:44] <camelia> rakudo-moar 919fe7b85: OUTPUT: «{a => [1 2 3 4 5 6], b => [7 8 9]}␤{a => [1 2 3 4 5 6], b => [7 8 9 200]}␤»
[23:07:49] <colomon> basically, when you do the append, if the original hash already has a member, then the values from the appended version are just pushed onto the existing array in the original.  But if the original doesn’t have a member, the new member you get is just the original array.
[23:08:47] <colomon> I think I can work around it by prestaging, just wondering if I should have to or not; to me, the current behavior feels very inconsistent.
[23:09:44] <Altreus> I guess the worst part of that is that the b array is copied by ref
[23:10:51] <codesections> I'm not sure I followed, but aren't you describing the difference between .push and .append?
[23:11:05] <colomon> @codesections nope
[23:11:39] <codesections> m: say ^10 .grep: (:is-prime)
[23:11:40] <camelia> rakudo-moar 919fe7b85: OUTPUT: «(2 3 5 7)␤»
[23:11:41] <colomon> well, actually I think with push it would explicitly be a ref in both cases?
[23:11:45] <codesections> rw
[23:12:25] <Altreus> colomon: I guess I'm not sure what you want it to do
[23:13:36] <colomon> I don’t want to have some of the arrays add their values and others a ref to the array
[23:14:08] <Altreus> so the ref thing is the problem, not the recursive append?
[23:14:21] <colomon> I don’t think it’s recursive?
[23:14:35] <colomon> Let me see if I can make a gist example which is clearer.
[23:15:04] <colomon> (we can still use evalbot with gists, right?)
[23:16:05] <colomon> m: https://gist.github.com
[23:16:06] <camelia> rakudo-moar 919fe7b85: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Confused␤at <tmp>:1␤------> 3https:7⏏5//gist.github.com␤    expecting any of:␤        colon pair␤»
[23:16:16] <colomon> m: https://gist.github.com/colomon/1588c66596f21cfb7d827583ab135fdf
[23:16:17] <camelia> rakudo-moar 919fe7b85: OUTPUT: «{a => [1 2 3 4 5 6], b => [7 8 9]}␤{a => [1 2 3 4 5 6], b => [7 8 9 200]}␤»
[23:17:32] *** Joins: Shaeto (~Shaeto@94.25.234.141)
[23:17:47] <colomon> The point being, even though I’ve done apparently the samy thing to %b<a> and %b<b>, only the change to %b<b> is reflected in %a, because %b<a> is added by values to %a, while %b<b> is added by ref.
[23:18:32] <colomon> obviously can be worked around by getting all the keys from %b and making sure they are also there in %a
[23:19:24] <colomon> but I can’t think of why you’d ever want append to behave the way it does?
[23:22:26] *** Quits: monkey_ (~user@190.104.116.134) (Ping timeout: 268 seconds)
[23:31:53] <codesections> Interesting; I see what you mean
[23:34:00] *** Quits: kylese (~kylese@p5483550e.dip0.t-ipconnect.de) (Quit: Leaving)
[23:37:01] <lizmat> colomon: I think that qualifies as a bug
[23:44:57] <nine> I think the displayed behaviour is consistent both internally and with the specification
