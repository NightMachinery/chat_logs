[00:04:43] *** Quits: coot (~coot@213.134.190.95) (Quit: coot)
[01:23:48] *** Quits: quantumelf (~quantumel@2610:148:1f00:1000:efbb:3dde:39fc:ec30) (Ping timeout: 240 seconds)
[02:05:57] *** Quits: __monty__ (~toonn@user/toonn) (Quit: leaving)
[02:07:21] *** Joins: quantumelf (~quantumel@2610:148:1f00:1000:efbb:3dde:39fc:ec30)
[04:03:01] *** Quits: quantumelf (~quantumel@2610:148:1f00:1000:efbb:3dde:39fc:ec30) (Ping timeout: 240 seconds)
[06:18:00] *** Joins: quantumelf (~quantumel@host-144-28.gaatcat.atlanta.ga.us.clients.pavlovmedia.net)
[08:50:40] *** Quits: quantumelf (~quantumel@host-144-28.gaatcat.atlanta.ga.us.clients.pavlovmedia.net) (Ping timeout: 256 seconds)
[10:29:22] *** Joins: coot (~coot@213.134.190.95)
[12:29:37] *** Joins: yauhsien (~Yau-Hsien@61-231-19-150.dynamic-ip.hinet.net)
[13:45:46] *** Quits: tzh (~tzh@c-24-21-73-154.hsd1.wa.comcast.net) (Quit: zzz)
[17:08:07] <f-a> ManofLetters[m]: how do you handle switching from a part to the game to another (from a menu to ingame, etc.)? It it something I am thinking about — how to do that elegantly, that is — but have not reached a solution yet
[17:08:16] <f-a> 9> inb4 Allure is strictly monomodal
[17:23:43] <ManofLetters[m]> hmm, let me check
[17:25:10] <ManofLetters[m]> yes, it certainly doesn't have any minigames
[17:25:33] <ManofLetters[m]> only the main map or a menu, which can take a part of the screen or all
[17:26:36] <ManofLetters[m]> and actually the "map" is also a menu, but with no text, waiting for a keypress just like a menu, but interpreting it differently
[17:27:05] <f-a> thanks
[17:27:32] <f-a> and how do you handle «go back to menu»?
[17:27:52] <f-a> well, if it is another menu/map, it should not be difficult at all…
[17:27:55] <ManofLetters[m]> and how to interpret a keypress is not even a part of menu code --- it returns a keypress and the rest of the code does stuff with it
[17:28:07] <ManofLetters[m]> basically
[17:28:08] <f-a> ah I see
[17:28:30] <ManofLetters[m]> there are UI commands for moving, shooting, openning menus, closing the game
[17:28:58] <ManofLetters[m]> any keypress, depending on a context, is interpreted as one of the commands
[17:29:13] <f-a> who decides which context is which
[17:29:15] <f-a> so to speak
[17:29:17] <ManofLetters[m]> in fact, the user can tweak in config file which keypress does what, including opening menus, etc.
[17:29:35] <f-a> is the last action of a menu/map «switch context»? (I hope my question was clear)
[17:29:56] <ManofLetters[m]> the code opens a menu, gets the keypress, interprets it, which involves running a command, which may open a menu, get a key, etc.
[17:30:04] <f-a> I see
[17:30:06] <f-a> clear
[17:30:13] <ManofLetters[m]> so the "context" is the frames on the call stack
[17:30:17] <ManofLetters[m]> never too many, in fact
[17:31:20] <ManofLetters[m]> BTW, I'm not proud of the UI code and it's being partially rewritten by a contributor (who seems to be busy with other stuff)
[17:31:37] <ManofLetters[m]> in particular, some menu are going to be defined declaratively
[17:32:10] <ManofLetters[m]> so the display/get keypress/interpret will not not be manual code in their case, but will dispatch on menu name and get the "context" from a table
[17:32:38] <ManofLetters[m]> but it's just a way to structure the same stuff and make it even easier for players and modders to invoke from config/content
[17:34:56] <ManofLetters[m]> anyway, the "context" being frames on the call stack is sound thanks to tail call optimization which means you don't accumulate frames --- the calls are optimized to jumps
[17:36:04] <ManofLetters[m]> the side effect is that I can't "return" from a menu to the one from which I opened it and so recursively to 100 menus earlier
[17:36:19] <ManofLetters[m]> as I said, the nesting is small, perhaps 1 or 2 is how much I can go "back"
[17:36:26] <ManofLetters[m]> usually 0
[17:37:24] <ManofLetters[m]> the "go back to playing" command at the end of most menus is in fact the command "show map" and not any real going back to anything that was rememered
[17:38:05] <f-a> thanks
[17:38:07] <f-a> that was super useful
[17:38:27] <f-a> I had an idea to structure my game like a tree
[17:38:42] <f-a> where you play your «minigame» and then «go back»
[17:38:51] <icrbow[m]> f-a: I'm using stage objects, that handle lifecycle events and stage manager tracks a stack of them, creating, suspending, resuming and releasing as needed. Each stage can signal a stage change as push/pop/replace event.
[17:38:55] <f-a> where the leaves of a rosetree are «possible minigame in game y»
[17:38:59] <icrbow[m]> s/,//
[17:39:35] <ManofLetters[m]> yeah, both your approaches make sense; it's a game design decision to a large extent, not a purely technical one
[17:41:10] <f-a> mine does not ManofLetters[m] , I would like some kind of type safety and rosetree offers none in the leaves (if you handle them with  case + a type like data IndexMiniGame = AMenu | AFoot | ABombingAction is better but so much to write by hand)
[17:41:16] <f-a> sorry icrbow[m] , what is a stage object
[17:41:45] <f-a> some kind of Command to be put in a shared stack?
[17:42:47] <icrbow[m]> A bunch of procedures to manage resources and draw stuff.
[17:42:57] <icrbow[m]> * draw stuff packed into a tuple-like object.
[17:43:55] <icrbow[m]> https://gitlab.com/keid/engine/-/blob/main/core/src/Engine/Types.hs#L101
[17:45:28] <f-a> oh so they are sort of commands
[17:46:02] <icrbow[m]> The details aren't important. It's just a bunch of procedures typical for every "minigame" that engine loop knows when to call.
[17:46:14] <icrbow[m]> * "minigame" that the engine loop
[17:47:43] <icrbow[m]> Previously I just used an ADT of stage enums and dispatched events, rendering, and stuff on them.
[17:48:49] <icrbow[m]> Then someone on github made a stack of those enums and dispatched on head of it. Simple and efficient.
[17:49:13] <icrbow[m]> In my case I have to handle nested resources and state, so this grown into the monster you can see in there.
[18:29:58] *** Quits: coot (~coot@213.134.190.95) (Quit: coot)
[18:31:39] *** Joins: coot (~coot@213.134.190.95)
[18:47:20] *** Quits: coot (~coot@213.134.190.95) (Quit: coot)
[18:50:48] *** Joins: coot (~coot@213.134.190.95)
[19:23:39] *** Joins: quantumelf (~quantumel@2610:148:1f00:1000:efbb:3dde:39fc:ec30)
[19:30:06] *** Quits: sig[m] (~sigrdrifa@2001:470:69fc:105::1:7148) (Quit: You have been kicked for being idle)
[19:40:58] *** Quits: coot (~coot@213.134.190.95) (Ping timeout: 272 seconds)
[20:48:33] <sm> hledger-ui saves a stack (not a tree) of screen states as you drill down, somas to be in the same place when you exit back up
[20:50:20] <sm> there is some generic outer code  and some hacky switching of record types to activate the right input/state/render handlers for the currently active screen. It's a bit mind bending and I'm not very happy with it.
[20:50:42] <f-a> and some hacky switching of record types to activate the right input/state/render handlers for the
[20:50:48] <f-a> I am interested in this ↑
[20:51:20] <f-a> as now I have a case and an “Index” type (case index of; IMinigame -> …; IMenu -> …;)
[20:55:54] <sm> f-a: see https://github.com/simonmichael/hledger/blob/master/hledger-ui/Hledger/UI/UITypes.hs and the Screen type
[21:03:06] <f-a> thanks
[21:42:44] *** Quits: szkl (uid110435@id-110435.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[22:14:01] <f-a> thanks sm , your idea of a stack of states seems pretty smart
[22:16:41] <sm> as you see, in addition to screen-specific handlers, within each screen there are modes, and mode-specific cases within the handlers
[22:17:16] <sm> I'm not sure if that's best, it just seemed expedient
[22:18:37] <sm> screens can behave totally differently (except for the common drill down/back up/exit app logic); modes of a screen are just a little different, sharing most code
[22:20:48] <sm> the screen switching and history maintenance is a big source of bugs and was hard to get right
[22:22:02] <sm> (saving/propagating state in all the right ways)
[22:22:29] <f-a> ;_;
[22:22:35] <f-a> it seems a common problem
[22:22:42] <f-a> there has to be a paper with a solution!
[22:22:47] <f-a> One True God
[22:23:34] <sm> yeah.. so the less state you can get away with the better. I was not using lenses from the start, perhaps that would help a bit (though I've heard failing lenses are quiet and can mask problems)
[22:34:37] *** Quits: quantumelf (~quantumel@2610:148:1f00:1000:efbb:3dde:39fc:ec30) (Ping timeout: 240 seconds)
[22:35:42] *** Joins: quantumelf (~quantumel@2610:148:1f00:1000:efbb:3dde:39fc:ec30)
[22:58:26] <EvanR> in most games the exploitation of some abstraction of "game modes, sub apps, menus" seems pretty low
[22:59:00] <EvanR> I wouldn't be surprised if they just hacked something together to support 1 game, 1 menu at a time
[23:00:43] <f-a> How *dare* you Evan?
[23:01:00] <sm> lol
[23:01:03] <f-a> are you telling me that game devs are just tight on budget and on dead lines and ha- https://thedailywtf.com/articles/swwwitch
[23:01:19] <f-a> [trigger warning: the longest `case` you will ever see]
[23:32:06] *** Joins: coot (~coot@213.134.190.95)
