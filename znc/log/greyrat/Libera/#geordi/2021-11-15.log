[00:26:27] *** Joins: badone (~badone@209.132.189.136)
[01:03:20] *** Quits: X-Scale (~ARM@83.223.243.66) (Ping timeout: 256 seconds)
[01:03:24] *** Joins: X-Scale` (~ARM@165.201.137.78.rev.vodafone.pt)
[01:05:00] *** X-Scale` is now known as X-Scale
[01:09:15] *** Parts: LangerJan (~jan@user/langerjan) ()
[05:00:11] *** Quits: X-Scale (~ARM@165.201.137.78.rev.vodafone.pt) (Ping timeout: 268 seconds)
[05:00:49] *** Joins: X-Scale` (~ARM@31.22.167.45)
[05:02:29] *** X-Scale` is now known as X-Scale
[05:58:52] *** Quits: badone (~badone@209.132.189.136) (Quit: ZNC 1.7.5 - https://znc.in)
[06:47:58] *** Joins: Guest95 (~Guest95@c-73-252-184-107.hsd1.ca.comcast.net)
[06:48:07] <Guest95> { if (int n = f(); __builtin_expect(static_cast<bool>(n), true)) { cout << "ok: " << n; } } int f() { return 42; }
[06:48:07] <geordi> ok: 42
[06:48:15] *** Quits: Guest95 (~Guest95@c-73-252-184-107.hsd1.ca.comcast.net) (Client Quit)
[10:28:40] *** Quits: enrico (~enrico@debian/enrico) (*.net *.split)
[10:28:54] *** Joins: enrico (~enrico@gandi.enricozini.org)
[10:28:58] *** Quits: enrico (~enrico@gandi.enricozini.org) (Changing host)
[10:28:58] *** Joins: enrico (~enrico@debian/enrico)
[14:43:42] *** Quits: Cyp (~cyp@192038135092.mbb.telenor.dk) (Remote host closed the connection)
[14:44:11] *** Joins: Cyp (~cyp@192038135092.mbb.telenor.dk)
[15:49:36] *** Quits: Cyp (~cyp@192038135092.mbb.telenor.dk) (Ping timeout: 256 seconds)
[15:50:54] *** Joins: Cyp (~cyp@192038135092.mbb.telenor.dk)
[19:40:27] *** Quits: Cyp (~cyp@192038135092.mbb.telenor.dk) (Remote host closed the connection)
[19:40:55] *** Joins: Cyp (~cyp@192038135092.mbb.telenor.dk)
[19:45:05] *** Joins: great_taste (~great_tas@190.32.235.20)
[21:09:46] <CarloWood> { cout << in; } using Gt = vector<vector<int>>; Gt in = {{4,3,1},{3,2,4},{3},{4},{1}};
[21:09:47] <geordi> {{4, 3, 1}, {3, 2, 4}, {3}, {4}, {1}}
[21:12:18] <CarloWood> { cout << solve(0, in); } using Gt = vector<vector<int>>; Gt in = {{4,3,1},{3,2,4},{3},{4},{1}}; Gt solve(int s, Gt const& g) { Gt r(in.size()); return r; }
[21:12:19] <geordi> {{}, {}, {}, {}, {}}
[21:13:25] <CarloWood> { cout << solve(0, in); } using Gt = vector<vector<int>>; Gt in = {{4,3,1},{3,2,4},{3},{4},{1}}; Gt solve(int s, Gt const& g) { Gt r; return r; }
[21:13:25] <geordi> {}
[21:16:45] <CarloWood> { cout << solve(0, in); } using Gt = vector<vector<int>>; Gt in = {{4,3,1},{3,2,4},{3},{4},{1}}; Gt solve(int s, Gt const& g) { Gt r; if (s == in.size() - 1) return {s}; for (int n : g[s]) { Gt p = solve(n, g); }; return r; }
[21:16:45] <geordi> error: converting to 'Gt' {aka 'vector<vector<int> >'} from initializer list would use explicit constructor 'vector<_Tp, _Allocator>::vector(vector<_Tp, _Allocator>::size_type, const _Allocator&) [with _Tp = vector<int>; _Allocator = allocator<vector<int> >; vector<_Tp, _Allocator>::size_type = long unsigned int]'
[21:17:16] <CarloWood> { cout << solve(0, in); } using Gt = vector<vector<int>>; Gt in = {{4,3,1},{3,2,4},{3},{4},{1}}; Gt solve(int s, Gt const& g) { Gt r; if (s == in.size() - 1) return {{s}}; for (int n : g[s]) { Gt p = solve(n, g); }; return r; }
[21:17:17] <geordi> warning: comparison of integer expressions of different signedness: 'int' and 'vector<vector<int>>::size_type' {aka 'long unsigned int'}
[21:18:07] <CarloWood> { cout << solve(0, in); } using Gt = vector<vector<int>>; Gt in = {{4,3,1},{3,2,4},{3},{4},{1}}; constexpr int e = in.size() - 1; Gt solve(int s, Gt const& g) { Gt r; if (s == e) return {{s}}; for (int n : g[s]) { Gt p = solve(n, g); }; return r; }
[21:18:07] <geordi> error: call to non-'constexpr' function 'vector<_Tp, _Alloc>::size_type vector<_Tp, _Alloc>::size() const [with _Tp = vector<int>; _Alloc = allocator<vector<int> >; vector<_Tp, _Alloc>::size_type = long unsigned int]'
[21:18:29] <CarloWood> { cout << solve(0, in); } using Gt = vector<vector<int>>; Gt in = {{4,3,1},{3,2,4},{3},{4},{1}}; int const e = in.size() - 1; Gt solve(int s, Gt const& g) { Gt r; if (s == e) return {{s}}; for (int n : g[s]) { Gt p = solve(n, g); }; return r; }
[21:18:30] <geordi> {}
[21:21:25] <CarloWood> { cout << solve(0, in); } using Gt = vector<vector<int>>; Gt in = {{4,3,1},{3,2,4},{3},{4},{1}}; int const e = in.size() - 1; Gt solve(int s, Gt const& g) { Gt r; if (s == e) return {{s}}; for (int n : g[s]) { Gt p = solve(n, g); if (!p.empty()) { for (auto& o : p) o.push_front(s); } }; return r; }
[21:21:25] <geordi> error: 'class vector<int>' has no member named 'push_front'
[21:22:22] <CarloWood> { cout << solve(0, in); } using Gt = vector<vector<int>>; Gt in = {{4,3,1},{3,2,4},{3},{4},{1}}; int const e = in.size() - 1; Gt solve(int s, Gt const& g) { Gt r; if (s == e) return {{s}}; for (int n : g[s]) { Gt p = solve(n, g); if (!p.empty()) { for (auto&& o : p) { r.push_back(s); r.back() += o; } } }; return r; }
[21:22:22] <geordi> error: no matching function for call to 'vector<vector<int> >::push_back(int&)'
[21:23:03] <CarloWood> { cout << solve(0, in); } using Gt = vector<vector<int>>; Gt in = {{4,3,1},{3,2,4},{3},{4},{1}}; int const e = in.size() - 1; Gt solve(int s, Gt const& g) { Gt r; if (s == e) return {{s}}; for (int n : g[s]) { Gt p = solve(n, g); if (!p.empty()) { for (auto&& o : p) { r.push_back({s}); r.back() += o; } } }; return r; }
[21:23:03] <geordi> error: no match for 'operator+=' in 'r.vector<vector<int> >::back() += o' (operand types are '__alloc_traits<allocator<vector<int> >, vector<int> >::value_type' {aka 'vector<int>'} and 'vector<int>')
[21:23:28] <CarloWood> { cout << solve(0, in); } using Gt = vector<vector<int>>; Gt in = {{4,3,1},{3,2,4},{3},{4},{1}}; int const e = in.size() - 1; Gt solve(int s, Gt const& g) { Gt r; if (s == e) return {{s}}; for (int n : g[s]) { Gt p = solve(n, g); if (!p.empty()) { for (auto&& o : p) { r.push_back({s}); r.back().append(o); } } }; return r; }
[21:23:29] <geordi> error: '__alloc_traits<allocator<vector<int> >, vector<int> >::value_type' {aka 'class vector<int>'} has no member named 'append'
[21:24:54] <CarloWood> { cout << solve(0, in); } using Gt = vector<vector<int>>; Gt in = {{4,3,1},{3,2,4},{3},{4},{1}}; int const e = in.size() - 1; Gt solve(int s, Gt const& g) { Gt r; if (s == e) return {{s}}; for (int n : g[s]) { Gt p = solve(n, g); if (!p.empty()) { for (auto&& o : p) { r.push_back({s}); r.back().insert(r.back().end(), o.begin(), o.end()); } } }; return r; }
[21:24:55] <geordi> {{0, 4}, {0, 3, 4}, {0, 1, 3, 4}, {0, 1, 2, 3, 4}, {0, 1, 4}}
