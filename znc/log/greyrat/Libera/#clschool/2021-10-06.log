[00:01:46] *** Quits: lottaquestions (~nick@2607:fa49:503e:3000:cd5:c174:4b11:9477) (Ping timeout: 260 seconds)
[00:02:06] *** Joins: CptKirk (~CptKirk@70-57-27-195.hlrn.qwest.net)
[00:02:42] *** Joins: abrante95 (~abrantesa@177.79.123.227)
[00:09:43] <mfiano> I used to use structs for gamedev
[00:09:50] <mfiano> I think it's a foolish idea now
[00:14:04] <White_Flame> I wonder why :type vector would be advantageous there.  The footprint would be larger than a struct, but I guess if it needs to iterate the slots of an object, that would be one way of doing it
[00:14:52] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Quit: ec)
[00:21:11] *** Quits: abrante95 (~abrantesa@177.79.123.227) (Read error: Connection reset by peer)
[00:21:53] <pjb> White_Flame: why would :type vector be larger than a struct? It'd depend on the implementation really.  For a struct, :type vector will give you a simple-vector and there's no need for sophisticated metadata.
[00:22:41] <White_Flame> struct only has to hold a type.  vector has to hold type + length
[00:23:17] <White_Flame> s/type/class/ to taste
[00:23:50] <White_Flame> of course, if it's not a simple-vector, then the vector has to hold element type and other stuff as well
[00:24:19] <White_Flame> fill pointer, etc etc
[00:24:39] <White_Flame> but yeah, :type vector at the very least has to hold a length
[00:24:41] <mfiano> It would be advantageous because _arrays_ are uploaded to the GPU, preventing a level of indirection, and also because mathematical vectors typically name their elements, so you get the benefit of struct accessors with the assembly no different than SVREF
[00:25:16] *** Joins: abrantesasf (~abrantesa@187.36.170.211)
[00:25:30] <aeth> the reason why I never use :type vector in DEFSTRUCT is because what I want more than anything else defined is a type, via DEFTYPE or similar, and if you do :type vector in your DEFSTRUCT, then it no longer defines a type
[00:25:49] <aeth> and if I'm going to have to generate a DEFTYPE via my own macro, I might as well write my own code since the shortcut of DEFSTRUCT is now not much of a shortcut at all
[00:26:31] <mfiano> (on SBCL)
[00:26:33] <pjb> aeth: indeed. On the other hand, in games, you may want to manage storage, and this can be done with vectors.
[00:26:37] <aeth> I find structs to be useful for gamedev because all they need to do, for the most part, is hold arrays, of a specified type, the type that I generate elsewhere.
[00:27:04] <aeth> DEFSTRUCT in that sense is just a way for SBCL and similarly-optimized implementations (although afaik only SBCL cares) to preserve the type information (and the optimizations) across function and file boundaries
[00:27:25] <mfiano> I find redefinition, generic functions over packages, and multiple inheritance far more important in gamedev.
[00:28:12] <mfiano> redefinition, especially. A game is a very interactive piece of software. Using structs is one step closer to slowing me down with Blub language.
[00:28:54] <aeth> I don't find the need for any of those in the core of an optimized game engine except redefinition, and there are ways to redefine structs, like e.g. deleting the package they're in and then recompiling that whole section of code.
[00:29:13] <mfiano> An optimized game engine assumes you already have a game.
[00:29:28] <mfiano> Unless you never want a game, that is
[00:29:41] <aeth> Not true.
[00:29:42] <pjb> but granted, again, it's better to define one's own macro.
[00:30:01] <aeth> Some optimizations can be done later. Some optimizations have to be done up front or you have to rewrite the entire thing. The core of your game engine architecture is the latter.
[00:30:28] <aeth> You cannot bolt in an efficient representation later on. For instance, you might rely on generics, which... I mean, now you're going to have to write a whole inline CLOS system (since afaik the only preexisting library is GPL or something) and so on
[00:31:13] <aeth> Now, maybe it's better for motivational purposes to first write an entire game on top of the wrong-architecture game engine and then throw away the core and replace it.
[00:31:25] <aeth> But the style of every step along the way is probably going to be written too improperly.
[00:32:53] <aeth> The approach I take is to write things as if it's C, and then to hide it with macros later on. Sure, it's not great for immediate results, but I know exactly what kind of abstractions I can get away with building.
[00:33:43] <mfiano> Tell me what works when you release a game.
[00:34:23] <aeth> Again, you can build an entire mountain of technical debt, release a game on top of that mountain, and then literally rewrite every single line of code to work on those assets, or you can slowly build up the mountain, even if it will take a very long time. Which approach is better? Who knows.
[00:35:47] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[00:36:07] <aeth> But the "proper" game engine architecture requires a style of code that literally would require rewriting every last piece of code if you don't go into it with the mindset of efficiency at the start. C or C++ for the most part forces you to think efficiently, so most game engines, written in those languages, never really face those issues.
[00:38:43] <aeth> But Common Lisp gives you the freedom to writen in a dozen styles that literally will never scale beyond a certain point.
[00:39:14] <aeth> And if you're making yet another low-budget indie 2D game, sure, you can make that in any style or in any programming language.
[00:42:17] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[00:42:48] *** Joins: lisp123 (~lisp123@5.30.23.247)
[00:47:54] <aeth> But writing an efficient 3D architecture isn't "blub". The same pattern exists in effectively any language. It's language-agnostic. The distinction that exists with Common Lisp is that you can write enough macros so it looks like the engine's core was a part of the language in the first place.
[00:54:13] <aeth> I could probably release a 2D game in about a month, maybe two, and next to none of that rushed code would be reusable for a longer term project. So I don't spend time on that.
[01:03:14] *** Quits: shka (~herr@109.231.6.176) (Ping timeout: 245 seconds)
[01:22:58] *** Joins: _abrantesasf_ (~abrantesa@187.36.170.211)
[01:23:38] *** Quits: _abrantesasf_ (~abrantesa@187.36.170.211) (Remote host closed the connection)
[01:23:54] *** Quits: abrantesasf (~abrantesa@187.36.170.211) (Quit: -a- IRC for Android 2.1.59)
[01:24:31] *** Joins: abrantesasf (~abrantesa@187.36.170.211)
[01:31:00] <White_Flame> and of course a big part in gamedev is avoiding GC pauses and doing fairly manual memory management, too
[01:31:36] <White_Flame> are there any that force a (non-full) GC per frame and still maintain 60fps?
[01:36:56] <copec> It's something I would certainly like to study
[02:03:48] *** Quits: macaw (~macaw@176.221.120.196) (Quit: Client closed)
[02:04:07] *** Joins: macaw (~macaw@176.221.120.196)
[02:10:16] *** Quits: macaw (~macaw@176.221.120.196) (Ping timeout: 256 seconds)
[02:20:57] <White_Flame> I think it's relatively common for javascript to do that every 'frame'
[02:30:57] *** Joins: zazzerino (~user@2600:1700:6004:8470::43)
[03:13:53] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[03:57:10] <aeth> White_Flame: If you preallocate everything, then you shouldn't get a GC because potential GCs trigger on allocations, afaik.
[03:57:27] <aeth> Which would encourage recycling preallocations.
[03:57:38] <aeth> You might not be able to avoid it for e.g. streaming level loading on an open world, though.
[03:58:22] *** Quits: random-nick (~random-ni@87.116.183.117) (Ping timeout: 250 seconds)
[04:02:03] <aeth> White_Flame: Due to the domain, most of the data by KB/MB are just giant arrays, though. If specialized (so, all implementations except CLISP, which doesn't really have many upgraded-array-element-types) it should be trivial for GCs to skip huge sections of memory
[04:17:56] *** Quits: makomo_ (~makomo@user/makomo) (Ping timeout: 246 seconds)
[04:19:17] *** Quits: makomo (~makomo@user/makomo) (Ping timeout: 264 seconds)
[04:45:31] *** Quits: CptKirk (~CptKirk@70-57-27-195.hlrn.qwest.net) (Ping timeout: 256 seconds)
[05:08:47] *** Quits: abrantesasf (~abrantesa@187.36.170.211) (Remote host closed the connection)
[05:18:41] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[05:57:16] *** Quits: sts-q (~sts-q@212.53.219.168) (Ping timeout: 268 seconds)
[06:04:34] *** Joins: sts-q (~sts-q@212.53.219.154)
[06:43:28] *** Quits: zazzerino (~user@2600:1700:6004:8470::43) (Ping timeout: 250 seconds)
[06:46:14] *** Quits: derwolf (~DerWolf@2a01:4f8:c0c:554a::1) (Quit: Bye)
[06:46:33] *** Joins: derwolf (~DerWolf@2a01:4f8:c0c:554a::1)
[06:48:08] *** Quits: Duuqnd (~duuqnd@2001:470:69fc:105::e9c0) (Ping timeout: 265 seconds)
[06:48:08] *** Quits: CodeBitCookie[m] (~code-bit-@2001:470:69fc:105::a2f) (Ping timeout: 265 seconds)
[06:48:08] *** Quits: Arcsech (~arcsechma@2001:470:69fc:105::1:797) (Ping timeout: 265 seconds)
[06:50:18] *** rdrg109_ is now known as rdrg109
[06:55:29] *** Quits: Josh_2 (~user@37.25.47.130) (Remote host closed the connection)
[06:59:41] *** Joins: Arcsech (~arcsechma@2001:470:69fc:105::1:797)
[07:00:29] *** Joins: CodeBitCookie[m] (~code-bit-@2001:470:69fc:105::a2f)
[07:01:00] *** Joins: Duuqnd (~duuqnd@2001:470:69fc:105::e9c0)
[07:24:32] *** Quits: Psybur (~Psybur@mobile-166-170-32-197.mycingular.net) (Remote host closed the connection)
[07:39:32] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 246 seconds)
[09:41:30] *** Joins: makomo (~makomo@user/makomo)
[09:44:41] <lisp123> Hello all
[09:45:36] <beach> Hello lisp123.
[09:45:48] <lisp123> beach: Hope you are having a good day?
[09:46:03] <beach> Yes, thank you.  You too I hope.
[09:46:19] <lisp123> Indeed, so far so good
[09:53:57] *** Joins: Cymew (~ante@c-e989225c.023-1144-7570702.bbcust.telenor.se)
[10:07:13] <lisp123> I have two different types of lists, (+ a b) and (+ 1 2) for example, where the first is in "variable-form" and the second is in "numerical-form". Is there a way to specialise on them within generic functions? I want to be able to use list functions on them in most instances, but for certain methods I want to treat variable-form different from numeric-form
[10:07:21] *** Joins: shka (~herr@83.175.151.96.piasta.pl)
[10:08:25] <lisp123> I was thinking (defclass variable-form (list) ...) but then I got stuck on what the slots should be. Then I also thought of deftype (never used it before), but I'm not sure how to set the type of an object
[10:08:32] <beach> The AMOP uses the preposition "to" for specialization.  Specialized "to" (say) the class C.
[10:08:56] <lisp123> beach: Thanks
[10:08:59] <beach> And, no, both are instances of the class CONS, so you can't specialize to one or the other.
[10:09:31] <beach> But sometimes, I take things apart, like if you can specialize to the second element, then you have SYMBOL or NUMBER.
[10:10:19] <beach> Oh, sure, if you define your own classes then it works as usual.
[10:10:39] <beach> You can then just have a single slot, which is the form.
[10:11:27] <beach> (defclass form () ((%form ...))) (defclass variable-form (form) ()) (defclass numeric-form (form) ())
[10:13:49] <lisp123> Is there a way to treat "form" as a list? (so that (car form) is the same as (car (accessor %form))?
[10:14:41] <beach> No, but that's not typically what you want either.
[10:15:10] <beach> If you define an abstract data type like FORM, you usually want to define protocol functions, such as OPERATOR and ARGUMENTS.
[10:15:45] <beach> Otherwise, the concrete representation will propagate all over your code, and you get stuck with it.
[10:16:35] <lisp123> Thanks, that's a good point --> whatever time is saved at the start is considerably wasted in rewriting it afterwards
[10:17:29] <beach> Right.  We have been through this before as I recall.  Design your abstract data types as a CLOS protocol with protocol classes and protocol generic functions. 
[10:18:50] <lisp123> Will try to do it more
[10:19:17] <beach> Surely, you must know this way of working from programming in other languages, no?
[10:19:20] <lisp123> Is there much purpose to using DEFTYPE?
[10:20:00] <lisp123> A lot of people like to prototype using lists, so I was wondering if it was possible to have my cake and eat it too
[10:20:00] <beach> I don't use it much, because most of the time what I want is a new class, but there are cases for it.
[10:20:43] <beach> Sometimes I define types for "designators", like FUNCTION-DESIGNATOR etc.
[10:20:43] <lisp123> I was thinking, would you say using classes & generic functions is akin to static typing (even though it happens at runtime)?
[10:20:54] <beach> That way I can use CHECK-TYPE and such.
[10:21:15] <lisp123> I see, I will try that too
[10:21:52] <beach> I see no relation to static typing.  Static typing has to do with assigning or inferring the types of variables at compile time.
[10:23:11] <lisp123> I see
[10:34:22] *** Joins: makomo_ (~makomo@user/makomo)
[10:35:21] *** Quits: makomo_ (~makomo@user/makomo) (Client Quit)
[10:35:30] *** Joins: makomo_ (~makomo@user/makomo)
[10:38:06] <lisp123> beach: In SICL, are all the 'standard' functions like CAR, LIST, CONS, etc. generic functions?
[10:38:16] <beach> No.
[10:38:27] <beach> But many more are than what the standard requires. 
[10:39:34] <beach> For certain functions like CONS, it doesn't make sense for it to be generic, because it works the same no matter what the argument types are.
[10:40:00] <lisp123> I see
[10:40:07] <lisp123> What about something like MEMBER?
[10:40:48] <beach> I forget about MEMBER but all the sequence functions are generic.
[10:41:04] <lisp123> Nice
[10:42:19] <lisp123> And they can be specialised by users too?
[10:42:29] <beach> That's reasonable, because a sequence can be either a list or a vector, plus, there are often extensions to sequences.
[10:42:34] <beach> Sure.
[10:43:06] <lisp123> Nice!
[10:43:28] <beach> And, in SICL, we have separate classes for specialized vectors, so there is a method for each such class.
[10:44:26] <lisp123> Sounds good
[10:44:30] <beach> We developed a small DSL for expressing the most common traversal categories.
[10:45:10] <lisp123> That will be very useful - is that useable now or waiting for the full project?
[10:45:25] <beach> https://github.com/robert-strandh/SICL/blob/master/Code/Sequence/find.lisp for instance.
[10:45:45] <beach> The sequence functions work in SBCL, so you can use them now.
[10:45:49] <beach> SICL doesn't exist yet.
[10:46:27] <lisp123> Thanks, I will have a look at them
[10:47:32] <beach> heisig wrote them, and he says performance is comparable to, and sometimes better than, the native SBCL functions. 
[10:47:46] <lisp123> So stuff like (cl:in-package #:sicl-sequence)...(defmethod copy-seq ...), are you shadowing copy-seq within sicl-sequence?
[10:48:51] <beach> You should never do IN-PACKAGE with a third-party library.
[10:49:10] <beach> (defmethod sicl-sequence:copy-seq ....)
[10:49:34] <beach> The names are shadowed in the "extrinsic" version of the library.  
[10:49:50] <beach> Obviously not in the SICL 'intrinsic" version.
[10:49:56] <lisp123> Yep makes sense
[10:51:38] <lisp123> Ok this great, I'm going to re-use all these functions from now
[10:51:50] <beach> Please let us know how they perform.
[10:52:02] <beach> There is a very interesting way of organizing the packages of a large body of code with a main interface package.
[10:52:38] <beach> The main interface package is defined using :EXPORT of the protocol symbols, but no code is written with (in-package <that-package>)
[10:53:22] <lisp123> Sorry, bit confused
[10:53:38] <beach> Instead, each individual module has its own package, and it is defined as (defpackage <module-package> (:USE #:common-lisp <protocol-package>)...)
[10:54:07] <lisp123> I see
[10:54:22] <lisp123> That's pretty smart
[10:54:26] <beach> As a result, the protocol package contains only the protocol symbols, and all other spurious symbols like X, and Y, are in individual module packages.
[10:54:44] <beach> And there is much less risk of clashes between modules.
[10:54:47] <lisp123> Very clean solution
[10:54:51] <beach> Yes.
[10:55:04] <beach> SICL is organized that way, and also CLIM.
[10:55:18] <beach> And other libraries of mine like Cluffer.
[10:55:38] <lisp123> Yes, it took me 5 seconds to figure out out copy-seq was working, because it was very clear from the file
[10:56:03] <beach> Right.  With the DSL, the code is perfectly clear.
[10:56:47] <lisp123> Yep
[10:58:16] <beach> And those DSL macros optimize special cases too, like IDENTITY is not called when KEY is not given.
[10:59:15] <beach> And there is no (FUNCALL TEST ...) when the test is EQL.  Instead it becomes (EQL ...).
[10:59:18] <beach> Stuff like that.
[11:00:57] <lisp123> Interesting - do you compare how SICL works vs. SBCL and others?
[11:01:30] <lisp123> Or is their approach hidden behind complex code whereas its easier to see in SICL with your DSL macros?
[11:01:36] <beach> I don't.  Others do.  I am fairly confident that SICL is very very different, given when the other implementations were initially written.
[11:01:52] <lisp123> Makes sense
[11:02:22] <lisp123> You should write a full book on it too :-) Like The Tex Program
[11:02:51] <beach> The main difference I think is that implementation details are typically scattered all over the code, and since they have lots of micro-optimizations, then there are lots of those special cases all over.
[11:03:44] <beach> Take SBCL NIL.  It has the structure of a CONS cell, so that (CAR NIL) is no longer a special case.  But then, instead NIL is special all over.
[11:04:08] <beach> And now, in every loop over a list, you have two tests in each iteration.
[11:04:26] <lisp123> lol that is true :-)
[11:05:00] <beach> And I believe they went to great trouble to make NIL a fixed value.  But in SICL, we are able to make every literal a fixed value automatically without any special cases.
[11:05:04] <beach> Stuff like that.
[11:05:24] <lisp123> Nice
[11:05:32] <beach> Thanks.
[11:35:57] *** Joins: hendursa1 (~weechat@user/hendursaga)
[11:39:06] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[11:58:26] *** Joins: selwyn (~selwyn@user/selwyn)
[12:18:32] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[12:21:54] *** Quits: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 250 seconds)
[12:35:56] *** Quits: makomo_ (~makomo@user/makomo) (Ping timeout: 245 seconds)
[12:39:59] *** Joins: macaw (~macaw@176.221.120.196)
[13:25:15] <lisp123> If I want to define a class with one slot, is this an acceptable way? (defclass form () ((#:form :initarg :value :accessor form)))?
[13:25:52] <lisp123> I read from my notes (thanks beach & mfiano) that slot names are meant to be an implementation detail, so I thought its meant to be uninterned?
[13:39:27] *** Joins: random-nick (~random-ni@87.116.183.117)
[13:51:15] *** Joins: makomo_ (~makomo@user/makomo)
[13:54:59] <mfiano> interned, but not external
[13:55:23] <mfiano> a common convention is to prefix slot names with %
[13:55:33] <mfiano> and never export those symbols
[13:57:08] <lisp123> (defclass form () ((%form :initarg :initial-value :accessor form)))?
[13:58:49] <lisp123> perhaps, (defclass form () ((%form :initarg :initial-value :accessor form-value))) and then write a function (defun form ...) to create them
[13:58:55] <CodeBitCookie[m]> Good Morning Everyone!
[14:00:54] <CodeBitCookie[m]> Good Morning Everyone!
[14:02:07] <CodeBitCookie[m]> I got to a point where I had to pass a list of `nil`s and `t`s to `and`. If I use `apply` or `mapcar`, It complains about `and` being a `macro` and not a `function`.
[14:02:46] <CodeBitCookie[m]> Maybe there is a way to just turn `'(1 2 3)` -> `1 2 3`
[14:03:23] <CodeBitCookie[m]> Even if I try it with the `loop` macro, it has `:collect`, but that also returns a string and not like `values` does
[14:04:11] <CodeBitCookie[m]> TLDR; how do I do: `(apply #'and '(t nil t t))`
[14:08:36] <CodeBitCookie[m]> I could do it with: (defmacro paddahh (n)
[14:08:36] <CodeBitCookie[m]>   `(and ,@(tmpp n)))
[14:08:49] <CodeBitCookie[m]> but that doesn't seem right...
[14:11:16] <lisp123> (loop for item in '(t nil t t) always item)
[14:12:05] <lisp123> I'm sure there's a better way...
[14:18:14] <CodeBitCookie[m]> So the root of the problem is from euler's project https://projecteuler.net/problem=5
[14:18:29] <CodeBitCookie[m]> I was solving the 5th problem in common lisp
[14:20:01] <CodeBitCookie[m]> and got to this solution: https://github.com/hamzashahid-blit/project-euler-common-lisp
[14:43:11] <Cymew> Are you using APPLY for Euler#5?
[14:48:18] <Cymew> Also, your quoting above looks odd.
[14:56:26] *** Joins: cranium (~cranium@user/cranium)
[14:57:40] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[15:02:29] <CodeBitCookie[m]> sorry Cymew I had not updated the github link, please check it now
[15:04:57] <CodeBitCookie[m]> I want to shorten the p5 function
[15:05:17] <CodeBitCookie[m]> from all of the `(= (mod x y) 0)`s
[15:05:34] <beach> CodeBitCookie[m]: You can use EVERY and SOME.
[15:05:48] <CodeBitCookie[m]> with the loop macro?
[15:06:32] <beach> No, just the functions.
[15:07:05] <CodeBitCookie[m]> oooh, I didn't know that existed. Will try to learn it
[15:07:28] <beach> Macros are used at compile time, so you don't use AND at run time like that.
[15:07:52] *** Quits: minion (~minion@common-lisp.net) (Remote host closed the connection)
[15:08:14] <beach> If you have a list of Booleans and want to check that they are all true, you can do (every #'identity <list>)
[15:09:07] <beach> But if you created that list using a predicate, you can stick the predicate in the call, so if you want to check that (say) every element of a list is a number, you can do (every #'numberp <list>).
[15:09:12] *** Joins: minion (~minion@common-lisp.net)
[15:12:25] <CodeBitCookie[m]> aaahhh
[15:12:34] <CodeBitCookie[m]> I am trying to implement it now
[15:33:11] <CodeBitCookie[m]> Doneeee
[15:33:17] <CodeBitCookie[m]> Except, its too slow...
[15:39:22] <CodeBitCookie[m]> I loveeeeee how loop is a macro
[15:39:27] <CodeBitCookie[m]> I wonder why its still slow though...
[15:43:18] <beach> LOOP expands into TAGBODY and GO.  You can't be faster than that.
[15:44:50] <beach> Your implementation could have a crappy LOOP macro implementation of course, but that would be strange, especially since most implementations probably use some variation of the MIT LOOP macro.
[15:47:05] <CodeBitCookie[m]> True, I use SBCL. I think the point of Project Euler's problems is to make it work, then make the algorithm faster instead of the programming language
[15:47:23] <beach> I take your word for it.  
[15:56:09] <lisp123> beach: https://github.com/robert-strandh/SICL/blob/53fcc065551f66b1034197a865a86258cec39a22/Code/Documentation/documentation.lisp#L16 --> Was there a reason to use different names for slots for single-slot class (vs. defclass word () ((%word...
[15:57:53] <lisp123> It looks readability is a bit better ("word characters" "paragraph contents"), but wondering if there was any other reason
[15:57:54] <beach> It would indicate to the person reading the code that the class contains an instance of itself.
[15:58:07] <lisp123> Ah I see, thanks
[15:58:14] <beach> Sure.
[16:08:36] *** Joins: st_iron (uid370243@id-370243.uxbridge.irccloud.com)
[16:16:22] <CodeBitCookie[m]> Turns out I just needed to take the lcm :)
[16:16:37] <CodeBitCookie[m]> which has a built in function... yayyyyyyyyyyyy!
[16:26:02] *** Joins: Psybur (~Psybur@mobile-166-170-32-197.mycingular.net)
[16:34:29] *** Quits: random-nick (~random-ni@87.116.183.117) (Ping timeout: 245 seconds)
[16:39:52] *** Joins: anxt_ (~anxt@dynamic-acs-24-154-157-73.zoominternet.net)
[16:39:54] *** anxt_ is now known as anxt
[16:55:23] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[16:58:11] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[17:01:41] *** Joins: Josh_2 (~user@37.25.47.130)
[17:15:26] *** Joins: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca)
[17:18:08] <CodeBitCookie[m]> Hey, again. I updated my repo: https://github.com/hamzashahid-blit/project-euler-common-lisp. Is the `p6-all-in-one` function or `p6` w/ the rest of the functions better?
[17:18:13] <CodeBitCookie[m]> in real life that is.
[17:20:51] <beach> You need to use slime-indentation for correct indentation, and you should respect the conventions for the number of semicolons to use in comments.
[17:22:21] <beach> And there is no reason to have a newline after (-
[17:24:05] <macaw> What are the situations where one would need to write a single-slotted class (containing an instance of itself in the slot)?
[17:25:15] <beach> I don't see any such situations, other than perhaps if the class were a protocol class, and the real information were supplied by subclasses. 
[17:32:54] <macaw> Yes, makes sense.
[17:44:10] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[18:00:39] *** Joins: rain3 (~rain3___@2a02:2f09:d003:5800:b41c:c37:1705:91bc)
[18:31:05] *** Quits: cranium (~cranium@user/cranium) (Quit: Leaving)
[18:34:05] *** Joins: lottaquestions (~nick@2607:fa49:503e:3000:254f:a774:c45b:8133)
[18:36:45] *** Joins: thrig (~thrig@65.113.153.50)
[18:41:12] *** Quits: lisp123 (~lisp123@5.30.23.247) (Quit: Leaving...)
[19:09:09] *** Quits: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[19:10:06] *** Quits: lottaquestions (~nick@2607:fa49:503e:3000:254f:a774:c45b:8133) (Ping timeout: 245 seconds)
[19:12:43] *** Joins: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca)
[19:12:49] *** Quits: makomo_ (~makomo@user/makomo) (Ping timeout: 265 seconds)
[19:24:48] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[19:33:10] *** Quits: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[19:43:53] *** Quits: Cymew (~ante@c-e989225c.023-1144-7570702.bbcust.telenor.se) (Ping timeout: 265 seconds)
[19:47:15] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[19:48:24] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[19:48:31] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[19:57:00] *** Quits: hendursa1 (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[20:05:29] *** Joins: hendursaga (~weechat@user/hendursaga)
[20:12:16] *** Joins: lisp123 (~lisp123@5.30.23.247)
[20:12:18] *** Parts: lisp123 (~lisp123@5.30.23.247) ()
[20:18:27] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[20:46:32] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[20:48:14] *** Quits: sts-q (~sts-q@212.53.219.154) (Ping timeout: 245 seconds)
[20:59:23] *** Quits: anxt (~anxt@dynamic-acs-24-154-157-73.zoominternet.net) (Remote host closed the connection)
[21:04:18] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Quit: WeeChat 3.3)
[21:06:47] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[21:08:24] *** Quits: st_iron (uid370243@id-370243.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[21:08:44] *** Joins: sts-q (~sts-q@212.53.219.239)
[21:15:39] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[21:21:05] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[21:37:49] *** Quits: sts-q (~sts-q@212.53.219.239) (Ping timeout: 265 seconds)
[21:49:34] *** Joins: selwyn (~selwyn@user/selwyn)
[21:49:50] *** Quits: selwyn (~selwyn@user/selwyn) (Remote host closed the connection)
[21:50:06] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[21:50:14] *** Joins: selwyn (~selwyn@user/selwyn)
[21:50:23] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[21:55:00] *** Joins: sts-q (~sts-q@212.53.219.139)
[21:57:54] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[22:14:59] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[22:17:06] *** Quits: rain3 (~rain3___@2a02:2f09:d003:5800:b41c:c37:1705:91bc) (Ping timeout: 265 seconds)
[22:22:32] *** Quits: thrig (~thrig@65.113.153.50) (Remote host closed the connection)
[22:25:16] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[22:50:38] *** Joins: lottaquestions (~nick@2607:fa49:503e:3000:322e:8bf4:aff1:3553)
[23:00:44] *** Quits: selwyn (~selwyn@user/selwyn) (Ping timeout: 245 seconds)
[23:00:57] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[23:03:14] *** Joins: selwyn (~selwyn@user/selwyn)
[23:04:08] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[23:18:40] *** Joins: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca)
[23:25:11] *** Quits: hendursaga (~weechat@user/hendursaga) (Remote host closed the connection)
[23:25:34] *** Joins: hendursaga (~weechat@user/hendursaga)
[23:40:16] *** Joins: random-nick (~random-ni@87.116.183.117)
[23:43:41] *** Quits: macaw (~macaw@176.221.120.196) (Quit: Client closed)
[23:43:56] *** Joins: macaw (~macaw@176.221.120.196)
[23:45:09] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[23:48:18] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[23:52:55] *** Quits: lottaquestions (~nick@2607:fa49:503e:3000:322e:8bf4:aff1:3553) (Quit: Konversation terminated!)
[23:53:16] *** Joins: lottaquestions (~nick@2607:fa49:503e:3000:df6f:9927:833b:d516)
[23:59:41] *** Quits: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
