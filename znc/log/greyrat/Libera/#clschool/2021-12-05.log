[00:04:55] *** Joins: lisp123 (~lisp123@5.30.23.247)
[00:11:09] *** Quits: rotateq (~user@p200300e787097300818cd04b4ea1a4f3.dip0.t-ipconnect.de) (Ping timeout: 268 seconds)
[00:13:44] *** Joins: lisp123_ (~lisp123@5.30.23.247)
[00:15:27] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[00:15:27] *** Quits: anddam (~anddam@user/anddam) (Ping timeout: 256 seconds)
[00:15:45] *** Joins: anddam (~anddam@user/anddam)
[00:31:18] *** Quits: lisp123_ (~lisp123@5.30.23.247) (Remote host closed the connection)
[00:59:23] *** Quits: shka (~herr@83.175.151.96.piasta.pl) (Ping timeout: 252 seconds)
[01:08:56] *** Joins: lisp123 (~lisp123@5.30.23.247)
[01:14:03] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 268 seconds)
[01:55:54] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[02:05:46] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[02:54:38] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[03:07:15] *** Joins: Oladon (~olad@98.43.81.226)
[03:08:38] *** Quits: makomo (~makomo@user/makomo) (Ping timeout: 252 seconds)
[03:15:52] *** Joins: Schnouki (e7aa4cfb39@user/schnouki)
[04:27:22] *** Quits: jeffrey (~jeffrey@80-115-60-193.cable.dynamic.v4.ziggo.nl) (Quit: Client quit)
[05:08:43] *** Quits: random-nick (~random-ni@87.116.165.83) (Ping timeout: 252 seconds)
[05:16:50] *** Joins: abrantesasf (~abrantesa@187.36.170.211)
[06:01:41] *** Quits: abrantesasf (~abrantesa@187.36.170.211) (Remote host closed the connection)
[06:10:33] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[06:57:42] *** Joins: Oladon (~olad@98.43.81.226)
[07:18:53] *** Quits: sts-q (~sts-q@91.200.108.232) (Ping timeout: 252 seconds)
[07:23:46] *** Joins: sts-q (~sts-q@212.53.219.215)
[07:40:46] *** Joins: lisp123 (~lisp123@5.30.23.247)
[08:09:03] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[08:23:44] *** Joins: lisp123 (~lisp123@5.30.23.247)
[08:24:20] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 252 seconds)
[08:28:44] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[08:29:36] *** Quits: seok (~Seok@n114-73-75-18.bla3.nsw.optusnet.com.au) (Read error: Connection reset by peer)
[08:31:21] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[08:43:21] *** Joins: makomo (~makomo@user/makomo)
[09:20:34] *** Joins: lisp123 (~lisp123@5.30.23.247)
[09:25:01] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[10:20:56] *** Quits: makomo (~makomo@user/makomo) (Ping timeout: 252 seconds)
[10:48:07] *** Joins: treflip (~user@95.79.32.99)
[11:22:24] *** Joins: lisp123 (~lisp123@5.30.23.247)
[11:27:01] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[12:43:04] *** Joins: shka (~herr@83.175.151.96.piasta.pl)
[12:52:30] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[12:52:59] *** Joins: lisp123 (~lisp123@5.30.23.247)
[12:57:37] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[13:52:46] *** Joins: lisp123 (~lisp123@5.30.23.247)
[13:54:04] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[14:26:09] *** Joins: empwilli (~empwilli@faui48e.informatik.uni-erlangen.de)
[14:34:55] <empwilli> hi folks :). common lisp beginner here. I'm currently trying to find my way around with slime and there are some things that I currently find cumbersome and believe that there is probably a better way, maybe so. can helb
[14:35:13] <beach> Go ahead.
[14:35:28] <empwilli> First off: I have some defvars but slime-compile-and-load-file doesn't seem to reeval them
[14:35:43] <empwilli> (in my case these are arrays and I modify them later on the repl)
[14:36:06] <beach> DEFVAR does not re-evaluate the form if the variable already has a value.
[14:36:12] <beach> For that you need DEFPARAMETER.
[14:36:18] <empwilli> ah, that was easy
[14:36:21] <empwilli> thanks :)
[14:36:27] <beach> Pleasure.
[14:36:41] <empwilli> Secondly: I have my project defined with asdf and I'd like to somehow get my slime session to automatically load the dependencies defined there, as well? 
[14:37:28] <beach> They will be loaded when you do a load-system of your own system, no?
[14:37:43] <empwilli> hmm I'll give it a try
[14:39:50] <empwilli> hm, slime complains that it doesn't know the system yet, do I have to launch slime from the asd file? (I wonder how it would know about the locatin of the system definition in the first place)
[14:40:37] <beach> The typical trick is to use Quiclisp, and still a link in your ~/quicklisp/local-projects (I think that's the path).
[14:40:56] <beach> There are tricks you can do with ASDF without Quicklisp, but I don't remember them now.
[14:41:05] <beach> s/still/stick/
[14:42:00] <beach> For your own project then, and projects that it depends on, but that are not in Quicklisp, you will have a symbolic link in that directory to the top directory of each project.
[14:45:19] <beach> Each time you add a new such symbolic link, you have to run (ql:register-local-projects), but only once.  Next time you start your Common Lisp system, everything will be recognized. 
[14:46:00] <pjb> Symbolic links don't work on all implementations (even if the implementation supports them, quicklisp choose not to allow them for some implementations).
[14:46:16] <beach> Good point.
[14:46:30] <pjb> Instead, use ql:*local-project-directories*
[14:46:33] <beach> I'll let others help with the rest.  I am off for my lunch break.
[14:47:02] <pjb> (push #P"/directory/where/your/asd-file/is/stored/" ql:*local-project-directories*)  then:   (ql:quickload "your-system")
[14:47:14] <beach> And set it in your ~/.<implementation>rc?
[14:48:04] <pjb> I prefer to do that in a file I call loader.lisp in the my project directory, and I put  (define-symbol-macro ll (load "loader.lisp")) in the rc file.
[14:48:23] <pjb> So I only have to cd the project directory and type ll to load the project.
[14:48:33] <beach> I don't think it has to be the directory where the .asd file is stored.  Just the directory that has the .asd in some subdirectory, no?
[14:49:21] <pjb> I'm not sure. For asdf:*central-registry* it has to be the directory where it's stored. Perhaps quicklisp looks in the subdirectories, I don't know.
[14:49:30] <beach> OK.
[14:49:59] <beach> I have 50 or so .asd file in the SICL project.  It could become quite tedious to link each one.
[14:50:12] <pjb> each directory, at least.
[14:50:34] <beach> Same, same.  I have mostly one .asd file in each subdirectory.
[14:51:12] <beach> But in ~/quicklisp/local-projects I have a single symbolic link to the top directory.
[14:52:26] <pjb> I have code in my rc file to search those directories: (defun find-directories-with-asd-files (root-pathname)
[14:52:47] <pjb> yes. symlinks don't work anymore with quicklisp on ccl.
[14:53:17] <pjb> I have code in my rc file to search those directories: https://github.com/informatimago/rc/blob/fab66603fd518b9588bfb8c4bdb8009657a1e45c/common.lisp#L398
[14:54:32] *** Joins: lisp123 (~lisp123@5.30.23.247)
[14:59:31] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[15:05:05] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[15:14:20] *** Joins: makomo (~makomo@user/makomo)
[15:30:04] *** Quits: treflip (~user@95.79.32.99) (Quit: time to work)
[15:53:28] *** Joins: random-nick (~random-ni@87.116.165.83)
[15:56:52] <empwilli> pjb: beach: thanks I'll give it a shot
[16:25:14] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[16:52:08] *** Joins: st_iron (uid370243@id-370243.uxbridge.irccloud.com)
[16:56:40] *** Joins: lisp123 (~lisp123@5.30.23.247)
[17:01:09] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[18:11:37] *** Quits: makomo (~makomo@user/makomo) (Ping timeout: 256 seconds)
[18:48:53] *** Joins: lisp123 (~lisp123@5.30.23.247)
[18:58:25] *** Joins: makomo (~makomo@user/makomo)
[19:22:13] *** Joins: Oladon (~olad@98.43.81.226)
[19:50:20] *** Quits: sjl (~sjl@cpe-66-66-5-59.rochester.res.rr.com) (Quit: WeeChat 2.2-dev)
[20:00:55] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 256 seconds)
[20:02:36] *** Joins: aeth (~aeth@user/aeth)
[20:30:15] <empwilli> Back for another question :): I'm trying to get my head around what type functions like "car" actually returns and how lisp interprets these given the context. From the repl, it is evaluated to the value that the cons cell contains, right? However, I can do setf and set the value (I've read so far that setf does a lot of things behind the curtains) ultimately this means that car does not simply
[20:30:18] <empwilli> the value, does it? 
[20:30:54] <beach> Does not simply *what*? the value?
[20:30:58] <beach> Your question was cut off.
[20:31:10] <empwilli> oh... return
[20:31:12] <empwilli> :)
[20:31:25] <beach> CAR can return any value, and it is whatever is stored in the CONS cell.
[20:31:49] <beach> Common Lisp is a dynamically typed languages, so variables do not have types associated with them.  Objects do.
[20:32:35] <empwilli> but it surely differenciates between the actual value and the location, does it? (coming from C/C++ world I would think of pointers/references)
[20:33:01] <empwilli> at least it appears that it behaves that way, e.g. when I do (setf (car *my-list*) 5) ?
[20:33:28] <beach> Not sure what you mean here, but Common Lisp uses what I call "uniform reference semantics", meaning that it is as if every object is manipulated indirectly using a reference (or a pointer if you like).
[20:33:54] <empwilli> ah ok, that's what I thought
[20:33:59] <empwilli> thanks
[20:34:20] <beach> So if you say (setf (car *my-list*) "hello") it is actually a pointer to the string that is stored in the cell.
[20:34:23] <beach> Sure.
[20:35:00] <beach> Notice the "as if".  The compiler can optimize stuff as long as this illusion is preserved.
[20:35:10] <empwilli> of course
[20:35:52] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[20:35:53] <empwilli> what confused me is that from the outside the (car *my-list*) is (after your line) "hello" and not "pointer/reference to "hello"" 
[20:36:43] <beach> The language does not let the user see or manipulate the reference/pointer.  It is done automatically, and the user just "sees" the objects themselves.
[20:37:27] <beach> It simplifies many things compared to languages that are forced to make the distinction between an object and a pointer to that object.
[20:37:45] <beach> And that simplification is possible only because Common Lisp uses automatic memory management. 
[20:38:29] <empwilli> I think I understand the underlying model but having this c/c++ style burnt into my head it sort of unintuitive/difficult to get used to it
[20:39:35] <empwilli> hm, one further question though: can I now have sth. like a let binding to a non-object element of a list? i.e. (let ((head (car *my-list*))) (setf head (1+ head))) ?
[20:39:36] <beach> Well, I can sort of see that, but it is in fact the C/C++ model that is way too complex. 
[20:39:50] <beach> You can't.
[20:40:11] <beach> You can use a symbol macro for a similar effect.
[20:40:19] <empwilli> too bad, I would have hoped to evade some repetitions
[20:40:36] <beach> You can avoid repetitions by using a macro or a symbol macro.
[20:41:26] <empwilli> Ok, great, super helpful feedback here today! Back to hacking.
[20:42:23] <beach> Good luck!
[20:48:51] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 252 seconds)
[20:50:33] *** Joins: aeth (~aeth@user/aeth)
[20:52:31] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[21:01:55] *** Quits: st_iron (uid370243@id-370243.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[21:11:02] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 252 seconds)
[21:13:05] *** Joins: aeth (~aeth@user/aeth)
[21:36:20] *** Joins: lisp123 (~lisp123@5.30.23.247)
[21:41:45] *** Joins: treflip (~user@95.79.32.99)
[21:41:50] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 268 seconds)
[21:45:54] *** Joins: lisp123 (~lisp123@5.30.23.247)
[21:58:57] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[22:08:23] <lisp123> Quick question - can I have multiple :after methods with the same specialisation?
[22:08:31] *** Joins: rotateq (~user@p200300e787097300818cd04b4ea1a4f3.dip0.t-ipconnect.de)
[22:08:35] <lisp123> or do I need to have one, and have that call the others
[22:16:54] <rotateq> what's the topic/question right now?
[22:22:24] <lisp123> Quick question - can I have multiple :after methods with the same specialisation?
[22:22:41] <rotateq> I don't think so.
[22:22:55] <lisp123> (thanks rotateq)
[22:24:28] <rotateq> It must be clear what you want from CLOS. The last one compiled is then the one used for this specialization.
[22:24:53] <rotateq> But I don't now how it behaves if one argument has another specialization.
[22:26:58] *** Quits: treflip (~user@95.79.32.99) (Remote host closed the connection)
[22:27:07] <rotateq> I would say it goes linearly across the args and calls the method-combinations in this order.
[22:28:22] <lisp123> That's what I was thinking too
[22:29:01] <rotateq> As it is intended to make sense in itself and not just from what some people think. :)
[22:30:15] <rotateq> And another rule seems to be to call always the most specific first.
[22:30:39] <lisp123> yes true :)
[22:31:53] <rotateq> Simple example that you can try: (defmethod divide (_ (y (eql 0))) nil) and (defmethod divide ((x integer) (y integer)) (/ x y)) then call (divide 3 0) and see what happens
[22:32:57] <lisp123> Sounds good, i'll try it later :P
[22:33:23] <rotateq> but when you do (defmethod ((_ integer) (y (eql 0))) nil) this is superior
[22:33:36] <rotateq> ah okay, you'll see as i did some days ago too
[22:34:07] <lisp123> rotateq: Yeah, I learnt also the importance of order, as you noted just now
[22:34:15] <rotateq> and don't dispatch with eql-specializer on strings :D
[22:34:15] <lisp123> left to right and all that jazz
[22:34:27] *** Joins: dra (~dra@2a04:4540:6406:7f00:e129:4a92:f9f4:8dd4)
[22:34:43] <rotateq> it's important in terms of consistence
[22:35:41] <lisp123> Oh, I learnt something new - that makes sense too now that I think of it!
[22:36:02] <lisp123> I have been doing some EQL-specializer on :keywords, its quite nice
[22:36:03] <rotateq> good good
[22:36:29] <lisp123> I should probably create a class out of those keywords at some point, but for prototyping its nice and fast
[22:36:34] <rotateq> yes or on integer and quoted symbols
[22:36:47] <lisp123> True
[22:37:13] <rotateq> it's like the function EQL on two strings will mostly give NIL when they just have the same content
[22:37:27] <lisp123> yep
[22:38:19] <rotateq> but when you do #3("abc") it's different :P
[22:38:39] <rotateq> may be implementation dependent I'm not sure
[22:39:11] <pjb> lisp123: that said, you can use as many mixins you want.
[22:39:57] <pjb> lisp123: https://termbin.com/jbby
[22:42:01] <pjb> rotateq: if you don't call-next-method in primary methods, then the selected method will override the others.
[22:42:12] <rotateq> okay hmm
[22:43:58] <pjb> This is determined really by compute-applicable-methods, with a default standard algorithm, and it can be overriden for your meta-classes.
[22:44:16] <rotateq> sounds very advanced again
[22:44:47] <lisp123> pjb: Indeed! Mixins are great for that
[22:45:09] <pjb> lisp123: note the order in which the mixis are called, for before, around,  and after.
[22:45:45] <lisp123> pjb: Yep
[23:35:50] *** Joins: jeffrey (~jeffrey@80-115-60-193.cable.dynamic.v4.ziggo.nl)
[23:37:21] *** Joins: zos (~zos@ool-457a8044.dyn.optonline.net)
[23:41:32] *** Joins: Oladon (~olad@98.43.81.226)
[23:53:53] *** Joins: tyson2 (~user@cpe00fc8d34ff03-cm00fc8d34ff00.sdns.net.rogers.com)
[23:54:55] *** Quits: lisp123 (~lisp123@5.30.23.247) (Quit: Leaving...)
