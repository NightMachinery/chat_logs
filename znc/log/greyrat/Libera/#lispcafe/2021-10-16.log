[00:00:53] <selwyn> whats wrong with rm -r?
[00:01:30] <Qwnavery> the fact that you can easily sudo rm -r / and brick a system because you missed a . 
[00:01:41] <selwyn> right
[00:01:52] <Qwnavery> there's no confirmation that you want to rm -r /
[00:01:52] <selwyn> iirc i tried that once for fun and it warned me
[00:01:54] <selwyn> hm
[00:02:04] <selwyn> maybe i had another flag in there
[00:02:07] <pjb> -rf is better
[00:02:10] <Qwnavery> lol
[00:02:15] <pl> Coretools requires special flag to delete /
[00:02:26] <pl> It won't operate on it otherwise 
[00:02:29] <pjb> nowadays, rm refuses to delete some directories in /
[00:02:36] <pjb> or /
[00:02:45] <pjb> I had a patch that excluded some directories.
[00:03:17] <pl> Also, a bit of the problem is the use of -f which means "fuck it, do it anyway" sometimes shortened to "force" 
[00:04:09] *** Joins: dec0d3r (~dec0d3r@2001:8003:480a:e00:e07:e7c3:7efc:ed0f)
[00:04:40] <Qwnavery> well there you go. but that's besides the point. A javascript programmer may end up even defending their increased complexity simply from not having experienced anything else.
[00:05:52] <selwyn> a new guy at work wants to use julia
[00:06:23] <selwyn> √≠ nearly convinced him of the merits of lisp, but he was sceptical of its performance given some benchmarks he had found
[00:07:12] <Qwnavery> If he goes down that path, next it'll be C++ and then he'll think that templates are the best things since sliced bread.
[00:07:37] *** Quits: dec0d3r (~dec0d3r@2001:8003:480a:e00:e07:e7c3:7efc:ed0f) (Remote host closed the connection)
[00:07:44] * Qwnavery shudders
[00:08:12] <selwyn> tbh, if someone is really motivated enough to popularise lisp, they should publish a benchmark in which lisp does well, and ensure that it is on a website that is near first place for 'lisp benchmark' in a google search
[00:08:28] <selwyn> because i could not find this easily to make my point
[00:08:51] <selwyn> qwnavery: well, i think we agreed eventually that c++ is not fun/practical
[00:09:00] <gilberth> I definitely don't want Lisp to become popular.
[00:09:24] <selwyn> i want it to have maybe 3x - 10x the users it has now
[00:09:42] <selwyn> in order to make development of libraries/implementations easier/more secure
[00:10:05] <selwyn> how much stuff in lisp depends on like 1 person? i.e. quicklisp
[00:10:12] <gilberth> Fair enough.
[00:10:17] <Qwnavery> Hm, it's a difficult problem.
[00:10:36] <selwyn> but after that i couldn't care how many people use it
[00:10:42] <Qwnavery> If you increase the userbase by that much you'll have people that ask dumb questions all the time, and a lot of them.
[00:11:03] <selwyn> well, that is to be expected from beginners
[00:11:12] <gilberth> And people publishing dumb libraries.
[00:11:13] <semz> also much more mass to put behind dumb *ideas* rather than questions
[00:11:14] <Qwnavery> At the moment it's sort of a bubble where the quality control is the percieved complexity.
[00:11:33] <Qwnavery> Which is a good thing.
[00:11:53] <selwyn> yes
[00:12:01] <selwyn> though i think we could do with a few more hands on deck
[00:12:05] <Qwnavery> It means that you're not going to have fools who will defend their beloved NodeJS gobbletygook because they simply are unaware.
[00:12:07] <gilberth> Speaking of which, I consider C++ a more complex language than Common Lisp.
[00:13:17] <semz> I lowkey fear the complexity issue is an unresolvable thing. "a good programmer destroys 10 jobs, a bad one creates 100" or how did that one go
[00:13:22] <Qwnavery> gilberth: even C is, writing good C is another matter entirely. But it's that same phenomenon where they grow into it and know nothing better and become hardened in their ways.
[00:13:46] <semz> I really hope this is wrong, but it definitely feels like there are perverse incentives at work and a lot of programming work is... ultimately pointless, to put it nicely
[00:14:33] <Qwnavery> "Center this div element, you have 8 hours."
[00:14:55] <selwyn> hope i don't have to be a programmer lol
[00:16:14] <Qwnavery> "programmer" is equivalent to being called a corporate typemonkey
[00:17:48] <Qwnavery> https://www.youtube.com/watch?v=4B9Ev6fLfqY
[00:17:49] -ixelp- Button pusher - short movie - YouTube
[00:20:31] <gilberth> Qwnavery: Indeed, writing a good C program takes a lot of discipline. There is just too much visible rope waiting to harm you with C.
[00:24:08] <selwyn> qwertz typewriter spotted at 3:54 :)
[00:30:20] <Qwnavery> selwyn: When I saw this I swore I'm never going to end up in that position.
[00:33:51] <selwyn> tf are story points
[00:34:48] <Qwnavery> I have no idea.
[00:35:10] <Qwnavery> Measurement of time?
[00:35:15] <semz> an agile term iirc
[00:35:28] <semz> length it takes to complete something?
[00:36:25] <Qwnavery> It's truly dystopian.
[00:38:37] *** Joins: lisp123 (~lisp123@5.30.23.247)
[00:43:59] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[00:53:00] <selwyn> its a good film, but if he finds his work pointless, idg why he would be that devastated at having to redo it
[01:01:28] <Qwnavery> I think that he's devastated because he finally realizes that it's pointless.
[01:03:35] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[01:08:33] <pl> Qwnavery: well, isn't "typemonkey" how majority of managements sees programmers? :P
[01:14:02] <selwyn> being a coder is my backup plan
[01:14:10] <selwyn> hopefully its not that bad if you can wfh...?
[01:14:22] <Qwnavery> pl: I would argue that no-self respecting computer enthusiast would consider themselves a programmer.
[01:14:43] <Qwnavery> s/no-self /no self-/
[01:15:10] <pl> Qwnavery: I would argue that what "programmer" means in practice depends not just on specific (natural) language used but also on local environment
[01:16:19] <pl> just like some places might actually consider "analyst" as something that isn't lowest tier white collar, but in my experience the only lower-valued title is "unpaid intern"
[01:16:20] *** Joins: lisp123 (~lisp123@5.30.23.247)
[01:16:31] <Qwnavery> That makes sense
[01:17:04] <pl> (paid interns in my experience have higher position than analysts)
[01:17:22] <Qwnavery> lmao
[01:17:25] <selwyn> do they have higher salaries?
[01:17:33] <selwyn> as well
[01:17:46] <pl> possibly
[01:17:54] <selwyn> am going to apply for a paid internship but have no idea what to expect in terms of $
[01:17:58] <Qwnavery> But I do not believe that one should go around referring to themselves as 
[01:18:32] <pl> the time I was paid intern I was on government mandated pay scale limited by the fact that /legally/ I had no degree yet
[01:18:38] <Qwnavery> "software engineers" or "software developers" without at least 2 years of experience. There's too many interns that throw around that term.
[01:18:44] <selwyn> pl: i see
[01:19:45] <pl> well, "software engineer" has no meaningful difference from "software developer" in many countries
[01:19:59] <selwyn> found out recently that 'researcher' is a low title to have in the risk consultancy world, not respected
[01:20:46] <pl> the "analyst" is extra funny for me because of a discussion I still remember from primary school :D
[01:21:00] <pl> with another guy who wanted to go into IT
[01:21:11] <Qwnavery> But ultimately (feel free to disagree) it is my personal opinion that such titles are frivilous. Programming is a tool and an artform. Much like a wrench to a mechanic, you do not call a mechanic a "wrencher".
[01:21:37] <pl> because "wrencher" would be the guy who makes wrenches
[01:21:40] <pl> :P
[01:22:07] <selwyn> titles are often silly, but one rarely has any choice about which one you get assigned by $dayjob
[01:22:23] <semz> Digital Architecture Artisan‚Ñ¢
[01:22:34] <Qwnavery> Ah, so the true programmers would be compiler-writers.
[01:22:54] <pl> Qwnavery: or at least those that program programs that write programs
[01:23:04] <Qwnavery> a macro wizard?
[01:23:18] <selwyn> america seems to go in for the most inflated job titles
[01:23:26] <pl> though I guess it does overlap "those who didn't avoid/flunk compiler course in uni"
[01:23:29] <Qwnavery> semz: that's something to raise an eyebrow on the ol' resume.
[01:23:32] <selwyn> everyone can be a director
[01:23:58] * pl personally had acquired jobs when his CV openly called him a wizard
[01:24:01] <Qwnavery> s/director/dictator/
[01:24:27] <selwyn> lol
[01:24:52] <pl> selwyn: there are cynical but good reasons to insist on a VP title, no matter how stupid the area, when at an early stage startup, whether one is founder or not
[01:25:05] <Qwnavery> pl: A wizard is far more quaint that programmer. Maybe we should all be referred to as mages atop our tower of parentheses.
[01:25:14] <selwyn> why?
[01:25:39] <pl> Qwnavery: after all, we conjure the spirit of the computer with our spells
[01:25:56] <pl> selwyn: hacking Vulture Capital behaviours
[01:25:58] <selwyn> am going to apply for a startup that got unicorn status recently
[01:26:04] <pl> then it's way too late
[01:26:12] <pl> this is a trick for early employees
[01:26:24] <selwyn> yeah. definitely not expecting to become vp!
[01:26:37] <selwyn> i would be a 'quantum architecture intern'
[01:26:49] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[01:26:56] <pl> but generally, when it comes down to negotating table with vulture capitalists, it at least used to be useful to have VP somewhere in your title list
[01:27:12] <Qwnavery> Excuse my arrogance: what is a VP?
[01:27:27] <pl> Vice-President
[01:27:47] <Qwnavery> oh ok
[01:31:57] <selwyn> would they be inclined to parachute in a vp candidate of their own otherwise?
[01:32:36] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Quit: ec)
[01:32:45] <pl> selwyn: or less inclined to give an inch
[01:32:57] <pl> in case of any conflict or division of spoils
[01:33:07] <selwyn> right
[01:35:36] <selwyn> well, i find the titles tedious but sometimes amusing
[01:37:16] <selwyn> it is a bit silly to have 'quantum applications engineers' that design algorithms for a computer that doesn't exist yet
[01:43:17] <selwyn> suppose i could call myself a warlock or sth
[01:44:02] <Qwnavery> "Cyber Alchemist"
[01:45:08] <selwyn> startup world seems intoxicating
[01:45:11] <pl> when in NYC, call yourself wizard and say "it's not my fault" a lot :P
[01:45:23] <selwyn> such ridiculous sums of money floating around
[01:45:31] <pl> sorry, not NYC, Chicago
[01:46:34] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Quit: WeeChat 3.3)
[01:46:50] <selwyn> new zealand recently made a wizard redundant after some decades
[01:47:04] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[01:47:16] <selwyn> https://www.theguardian.com/world/2021/oct/15/new-zealand-council-ends-contract-with-wizard-after-two-decades-of-service
[01:47:17] -ixelp- New Zealand council ends contract with wizard after two decades of service | New Zealand | The Guardian
[01:47:29] <selwyn> > ‚ÄúIt‚Äôs just they don‚Äôt like me because they are boring old bureaucrats and everyone likes me and no one likes them,‚Äô‚Äô he said.
[01:53:13] <gilberth> *sigh* I cannot build Emacs 24.5. I mean I can build it, but the application gives me a blank window and then nothing. And "make install" installs in nowhere it seems.
[01:56:22] <gilberth> Emacs 26 still has this cursor bug, which makes it unusable for me and when I try to use X11, it complains of "-*-Source Code Pro-*-10-*....." not found and bails out. Hello?! Why not fall back on 6x13? And where is TrueType?
[01:57:16] * selwyn just uses portacle
[01:57:44] <pl> selwyn: > The fact that the man somehow convinced the government to pay him for something he was already doing strikes me as strong evidence for his efficacy as a wizard.
[01:58:01] <pl> honestly, it was a pretty cheap contract
[01:58:20] <gilberth> What ever. Does it have Emacs 24.5 build with X11 support?
[01:58:53] <selwyn> gilberth: those who don't believe in magic will never find it
[01:59:13] <gilberth> And Emacs 26's "make install" also is not working. WHAT HAVE THEY DONE?
[01:59:46] <gilberth> I am short of giving up and get a Linux box.
[02:00:17] <selwyn> pl: do you have any insight into how much equity a pre-public startup is likely to disperse to new employees?
[02:00:49] <gilberth> Trouble is: I just cannot use newer Emacs versions.
[02:01:12] <pl> selwyn: not really, except for "don't assume it's worth anything" 
[02:01:13] <selwyn> i am too dumb to understand it, but as the valuation increases, surely there is still lots of equity to distribute before the ipo
[02:01:23] <selwyn> pl: ok
[02:03:07] <selwyn> quantum excitement is justified but overhyped
[02:03:21] <selwyn> the valuations of some things is way too high
[02:09:09] <Qwnavery> pqcrypto.org
[02:10:00] <selwyn> well, post quantum crypto is legit
[02:14:51] <Qwnavery> It's too slow.
[02:15:42] <Qwnavery> We're not quite ready for a quantum breakthrough.
[02:17:13] *** Joins: lad (~lad@user/lad)
[02:19:34] *** Joins: lisp123 (~lisp123@5.30.23.247)
[02:29:58] <gilberth> Emacs is broken beyond repair: <http://clim.rocks/gilbert/emacs-br0ken.png> Why can't "-" be displayed, and why are bitmap fonts scaled to begin with? It obviously doesn't work, does it? Why should it be better with Linux?
[02:31:39] <pjb>  It's not emacs that's broken, it's  your font.
[02:32:58] <gilberth> Nope. There is no such font with broken glyphs that are unreadable. It's Emacs asking the font to be scaled.
[02:34:48] <gilberth> A common problem with X11 applications since X11 wants to be helpful and scales bitmap fonts instead of saying NET. Looking at the fonts available and picking one that is there, would help.
[02:40:00] <gilberth> * HET even
[02:40:22] <gilberth> Anyhow, this is why people used to say that Linux has ugly fonts.
[02:49:42] <gilberth> I just use 6x13 as there Emacs does not try to scale it somehow, as it is not an XLFD.
[02:50:39] <hayley> https://www.reddit.com/r/lisp/comments/q7zli2/selling_lisp_by_the_pound/hgs4ghp/ lol
[02:50:41] -ixelp- Selling Lisp by the Pound : lisp
[02:53:11] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 264 seconds)
[02:54:54] *** Joins: kevingal (~quassel@2a02:8084:4140:f300:81a9:fc65:4b6d:fdd2)
[03:01:30] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 260 seconds)
[03:05:27] <gilberth> I am very tired of those language wars.
[03:24:55] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[03:39:42] *** Quits: kevingal (~quassel@2a02:8084:4140:f300:81a9:fc65:4b6d:fdd2) (Remote host closed the connection)
[03:40:31] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 245 seconds)
[03:47:31] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[04:00:10] <hayley> Well, this article is about deconstructing the "Lisp family" more or less. Someone asked if it's pro- or anti-Lisp, and I guess I have to say it is anti-Lisp.
[04:16:21] *** Quits: pjb (~pjb@user/pjb) (Ping timeout: 245 seconds)
[04:20:31] <hayley> https://www.youtube.com/watch?v=nDXHtFw6Gm8
[04:20:31] -ixelp- Bela Lugosi Is Dead (Live @ Hammersmith Palais, London) - YouTube
[04:27:23] <Arcsech> That ‚Äúlisp by the pound‚Äù article falls into the very common trap of complecting ‚ÄúLisp (a language whose syntax trivially maps to the data structure used for the AST and whose AST can be easily manipulated in-language)‚Äù with ‚ÄúLisp (ANSI INCITS 226-1994 (S20018))‚Äù
[04:27:23] <Arcsech> There are good reasons to be passionate about both of those things, and a good way to get in big heated arguments is to talk about one to someone who thinks you‚Äôre talking about the other
[04:41:01] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 252 seconds)
[04:41:50] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[04:52:35] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 264 seconds)
[04:54:13] *** Joins: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se)
[04:54:49] *** Joins: pjb (~pjb@user/pjb)
[05:00:08] *** Joins: abrantesasf (~abrantesa@187.36.170.211)
[05:04:00] *** Quits: random-nick (~random-ni@87.116.165.220) (Ping timeout: 260 seconds)
[05:05:42] <Qwnavery> oh my god why is emacs so damn slow
[05:08:51] *** Quits: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se) (Ping timeout: 265 seconds)
[05:21:00] <gilberth> Qwnavery: Because it uses a simple byte code with dynamic variables?
[05:24:50] <Qwnavery> ;-; I'm literally trying to use emacs to edit climacs
[05:24:57] <Qwnavery> back to vim I go I guess.
[05:28:29] <gilberth> Curious, what is slow for you?
[05:29:14] <Qwnavery> opening buffers, sometimes randomly when I try to edit it'll hang
[05:29:32] <gilberth> Why would it hang?
[05:29:47] <Qwnavery> I don't know.
[05:29:52] <Qwnavery> I'm running spacemacs btw
[05:30:00] <Qwnavery> It's probably all the overhead from that.
[05:30:08] <gilberth> I mean, hang is not slow, hang is waiting for something. The file server perhaps?
[05:30:22] <Qwnavery> File server?
[05:30:50] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[05:30:57] <gilberth> Yep. You don't use one?
[05:31:38] <Qwnavery> Elaborate on what you mean by file server. Like ftp?
[05:31:59] <gilberth> NFS? Another machine that keeps your files.
[05:32:33] <gilberth> I was just asking. Because when it hangs it must be waiting for something.
[05:33:15] <Qwnavery> Nope, I even have an SSD that everything's running from.
[05:33:37] <gilberth> And I still don't get what Spacemacs is.
[05:34:01] <Qwnavery> Spacemacs is Emacs Evil mode so emacs with vim bindings
[05:34:09] <gilberth> So, a mere c-x c-f is slow?
[05:34:09] <Qwnavery> but it also has easier package management
[05:34:21] <gilberth> Or what ever that keybinding is for you.
[05:34:30] <Qwnavery> C-x C-f lists directory?
[05:34:41] <gilberth> Opens a file.
[05:34:45] <Qwnavery> oh
[05:35:17] <gilberth> Could be a directory, too. In which you land in dired.
[05:35:17] <Qwnavery> Not at the momemnt.
[05:35:21] <Qwnavery> Sometimes it is.
[05:35:29] <Qwnavery> It's super unpredictable.
[05:35:50] <gilberth> Which indicates that something strange is happening.
[05:35:56] <Qwnavery> and for some reason it's saying "selected deleted buffer" and then I have to try and open it again before it opens
[05:36:44] <gilberth> "selected deleted buffer"? Did you delete^Wkill a buffer?
[05:37:12] <Qwnavery> I'm working on climacs anyway. I'll just learn to use it.
[05:37:23] *** Quits: manicennui (uid349235@id-349235.tinside.irccloud.com) (Ping timeout: 250 seconds)
[05:37:25] <Qwnavery> It does it for files I haven't even opened yet.
[05:37:32] <Qwnavery> Even if I restart emacs it doesn't fix it.
[05:38:08] *** Quits: pl (sid98063@id-98063.helmsley.irccloud.com) (Ping timeout: 246 seconds)
[05:38:13] *** Quits: iisi (sid19824@id-19824.hampstead.irccloud.com) (Ping timeout: 252 seconds)
[05:38:15] <gilberth> With all those nice automatism, could it be that it wants to look some module from the internet?
[05:38:19] *** Quits: JSharp (sid4580@id-4580.lymington.irccloud.com) (Ping timeout: 252 seconds)
[05:38:28] <gilberth> * load
[05:38:31] <Qwnavery> I updated it yesterday.
[05:38:39] <Qwnavery> Wasn't doing it before I updated it.
[05:38:54] <gilberth> Ah, you downgraded it. Congrats!
[05:39:04] *** Joins: iisi (sid19824@hampstead.irccloud.com)
[05:39:07] * gilberth never does up^Wdowngrades. Never.
[05:39:14] <Qwnavery> That's not hard. It's a bloated mess anyway.
[05:39:17] *** Joins: JSharp (sid4580@lymington.irccloud.com)
[05:39:22] *** Joins: pl (sid98063@helmsley.irccloud.com)
[05:39:52] <gilberth> Still I never update, because updates will only break things and never improve them. I don't have patience for that.
[05:40:06] <Qwnavery> gilberth: let's be real here. Is emacs your operating system?
[05:40:18] *** Joins: manicennui (uid349235@tinside.irccloud.com)
[05:40:29] <gilberth> My operating system? Nope, it's my editor, I am not RMS.
[05:40:56] <Qwnavery> You had me worried for a second there...
[05:41:27] <Qwnavery> You use Debian though don't you?
[05:41:45] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[05:41:53] <gilberth> On my headless Linux machine, yes. Otherwise it's macOS.
[05:43:06] <Qwnavery> That's fair.
[05:43:21] <Qwnavery> Eh. I'm just going to work on climacs and see if I can get something usable.
[05:44:13] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 252 seconds)
[05:44:26] <gilberth> You're strange. You want to dive into Climacs, without even using real Emacs.
[05:45:19] <Qwnavery> Climacs is light enough that I can read the source in a day.
[05:45:40] <gilberth> There also is Hemlock, used by CMUCL and Lispworks, and after I freed it from CMUCL dependencies, also by CCL. Much faster than Emacs, but dated.
[05:46:58] <Qwnavery> gilberth: I can't find anything with a quick search on Hemlock, have you got some links?
[05:47:16] <Qwnavery> wait found it
[05:47:19] <Qwnavery> dw
[05:50:16] <Qwnavery> yeah nah
[05:51:00] <Qwnavery> gilberth: Second-Climacs has the benefit of Cluffer being seperated, this makes it practical for what I want to implement.
[06:12:19] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 252 seconds)
[06:14:23] *** Joins: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se)
[06:26:11] *** Quits: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se) (Ping timeout: 265 seconds)
[06:29:37] *** Joins: lisp123 (~lisp123@5.30.23.247)
[06:30:09] *** Joins: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se)
[06:34:24] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[06:39:59] *** Quits: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se) (Ping timeout: 264 seconds)
[06:41:51] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[06:42:42] *** Joins: kakuhen (~kakuhen@user/kakuhen)
[06:43:33] *** Quits: abrantesasf (~abrantesa@187.36.170.211) (Remote host closed the connection)
[06:47:13] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 268 seconds)
[06:50:06] *** Quits: lad (~lad@user/lad) (Ping timeout: 245 seconds)
[06:56:21] <gilberth> Is there still confusing in Linux whether to map the backspace key to backspace or to delete with X11?
[07:19:43] <hayley> > <@arcsech:matrix.org> That ‚Äúlisp by the pound‚Äù article falls into the very common trap of complecting ‚ÄúLisp (a language whose syntax trivially maps to the data structure used for the AST and whose AST can be easily manipulated in-language)‚Äù with ‚ÄúLisp (ANSI INCITS 226-1994 (S20018))‚Äù
[07:19:43] <hayley> > 
[07:19:43] <hayley> > There are good reasons to be passionate about both of those things, and a good way to get in big heated arguments is to talk about one to someone who thinks you‚Äôre talking about the other
[07:19:43] <hayley> No, I had separated the two, I said the former was pretty boring. Especially when you can't do anything with the AST, and moreso when you can't even have the AST cause your host (Lua, C, etc) makes it impossible.
[07:21:01] <gilberth> Well, but that standard JavaScript could be called a Lisp.
[07:21:34] <gilberth> And it is perhaps more so than some languages with parens that claim to be a Lisp.
[07:21:37] <hayley> But still, even macros with full access to the language do not make a useful programming environment for me. 
[07:22:02] <hayley> gilberth: "JS is Lisp!" "nah, it's Scheme" "JS is Scheme!" "nah, it's Self" "JS is Self!" "Fuck off, would ye?"
[07:22:11] <hayley> *"...er...fuck off, would ye?"
[07:22:18] <gilberth> Heh.
[07:22:56] <hayley> "Selling Lisp by the pound" is thus a misnomer, but a useful one for clickbait purposes.
[07:23:09] <gilberth> Well, a proper language with proper macros like Lisp has them, but funny syntax would be useful, though I would miss the syntax.
[07:23:32] <gilberth> hayley: The title is terrific.
[07:24:02] <hayley> FWIW there was a short-lived thing about teaching people half-Lisps like that one in Python as a "transition" state. But it's a bogus idea, because you don't lose the properties of Python, and you don't really get much Lisp other than (())()
[07:25:06] <gilberth> Yep. The idea code = data is at the very roots of Lisp. Take that away, it's not a Lisp anymore.
[07:25:59] <hayley> So if you go to CL or Scheme or whatever is a "true" Lisp, then you feel robbed of generators, the file = module system, whatever else is in Python. And I wouldn't mind generators in CL, to be honest, I just have no idea how to do them efficiently.
[07:26:54] <gilberth> Whatever a generator is. A coroutine?
[07:27:05] <hayley> Yeah.
[07:27:30] <gilberth> That is call/cc land. I don't like it there.
[07:27:56] <Arcsech> <hayley> "> <@arcsech:matrix.org> That ‚Äú..." <- If you can‚Äôt do anything with, or get at, the AST then I wouldn‚Äôt say the AST ‚Äúcan be easily manipulated‚Äù. And by the time you‚Äôre at the host layer you‚Äôre past macros anyway?
[07:28:00] <hayley> Hm, IIRC you don't need call/cc for it. They have to be delimited to YIELD anything back to the caller, after all.
[07:28:23] <Arcsech> Like, I agree with that JS isn‚Äôt a lisp, but Fennel is pretty lispy
[07:28:46] <gilberth> hayley: Sure, like Prolog and I once hacked for C to support my Prolog->C compiler. You can still do with a linear stack.
[07:28:48] <hayley> Nah, if you can't manipulate ASTs at runtime, you missed the point.
[07:29:08] <hayley> Do (list 1 2 3) in Fennel and the compiler complains you're not writing a macro.
[07:29:09] <gilberth> Runtime? Compile time!
[07:29:35] <hayley> gilberth: They should be the same thing, but that is orthogonal to "Lisp". Another reason why I don't like "Lisp".
[07:30:31] <gilberth> Well, they are not the same with CL.
[07:31:31] <hayley> I can compile at runtime still.
[07:31:43] <gilberth> That is sth different.
[07:32:37] *** Quits: semz (~none@user/semz) (Ping timeout: 252 seconds)
[07:32:43] <hayley> What's different then? EVAL-WHEN?
[07:32:43] <gilberth> Runtime would imply that you could write what a macro would do as a new FSUBR, with runtime access to the lexical environment.
[07:33:18] <hayley> Suppose so.
[07:34:03] <hayley> But FSUBR compilation is an "open" problem, though I read that the late John Schutt figured something out.
[07:34:30] <gilberth> It's a night mare and not needed at all.
[07:36:07] <gilberth> I just can't imagine how that would be useful.
[07:39:30] <Arcsech> Okay, I think I get what you‚Äôre saying now, but I don‚Äôt think the article communicates that very well - it pulls in a lot of things(eg MOP) that basically mean that Common Lisp is the only ‚Äúreal lisp‚Äù per the definition the post provides, which is a useless definition of Lisp IMO
[07:42:49] *** Joins: jmercouris (sid438340@hampstead.irccloud.com)
[07:42:59] <jmercouris> lmao: https://twitter.com/borodust/status/1442225677764280321?s=20
[07:46:11] *** Joins: semz (~none@user/semz)
[08:01:15] <hayley> Hm. I accuse most languages of "selling Lisp by the pound", but only by pulling the average "Lisp" down into this state of mediocrity.
[08:03:39] <gilberth> Is elisp is Lisp?
[08:03:49] <hayley> I guess? Do I look like I care?
[08:04:08] <mfiano> Morning
[08:04:13] <hayley> Any useful and less contentious definition of "Lisp" still permits very boring languages.
[08:04:15] <hayley> Hey mfiano
[08:04:28] <mfiano> Oh we are still weighing Lisp?
[08:04:32] <gilberth> hayley: You should when you write an article about what is a Lisp.
[08:04:42] <gilberth> mfiano: Hi there!
[08:04:55] <hayley> I don't try to define Lisp.
[08:05:19] <gilberth> Well.
[08:05:30] <mfiano> McCarthy once said a Lisp must have automatic memory management. So I guess we can automatically exclude Carp :)
[08:05:53] <gilberth> Did you misspell crap?
[08:06:05] <mfiano> No, although it is a garbage fish.
[08:06:36] <Mondenkind> it may have been mentioned already, but imo: the problem with 'selling lisp by the pound' is that it only means something to people who already agree with it
[08:06:53] <Mondenkind> gilberth: https://github.com/carp-lang/Carp  'statically typed lisp, without a GC'
[08:06:54] -ixelp- GitHub - carp-lang/Carp: A statically typed lisp, without a GC, for real-time applications.
[08:06:56] <hayley> My points are 1. A "Lisp family" makes as much sense as "ALGOL family", they can't be "dialects" cause they're mutually incomprehensible 2. Anything other than turtles-all-the-way-down is bad design 3. Holistic design is also good 4. Optimisations aren't as easy as "just use a language with machine-oriented types"
[08:07:14] <Mondenkind> oxymoronic in the extreme :P
[08:07:19] <hayley> "For "real-time", they would need a real-[time] OS, datastructures with forward guarantees, non-blocking IO and so on. GC is like the least of the problems." - a wise guy
[08:07:25] <gilberth> Statically typed too? How useful.
[08:07:44] <hayley> Also non-interactive of course.
[08:08:26] <gilberth> Wait. I'd call my PLZ language, which is B with s-expr syntax a Lisp then.
[08:08:43] <hayley> The REPL either runs compile-time-only functions, or generates and runs a program to run runtime-only functions, which of course can't touch any global values.
[08:08:48] <gilberth> It doesn't even have recursion like Fortran. But it has parens!
[08:09:03] <Mondenkind> I'm beginning to think that the use of square brackets for bindings and such is as great an indicator of mediocrity as e.g. parentheses on their own lines; just indicates slightly more sophistication.  It is not so inherently _bad_, but it is so completely useless that there is no reason to include it
[08:09:26] <hayley> I don't have anything to say about syntax, other than it is the least interesting part of a language to me.
[08:09:28] <mfiano> +1
[08:09:53] <contrapunctus> I don't understand why it's so important for people to try and hammer down a definition of "lisp".
[08:09:59] <hayley> ...so "Lisp is when parentheses" makes for a uninteresting definition of Lisp.
[08:10:29] <contrapunctus> * universal definition of
[08:10:57] <gilberth> contrapunctus: We have a brand to defend.
[08:11:04] <contrapunctus> lol
[08:11:17] <gilberth> That's actually not so funny.
[08:11:36] <contrapunctus> Oh, I thought you were being satirical :\
[08:11:46] <hayley> My brand is interactive languages, i.e. CL, Smalltalk, Erlang, etc.
[08:12:01] <hayley> From prior interactions (no pun intended) with Racket programmers, I'm fine with whatever happens to them.
[08:12:19] <gilberth> Look, I also hate when people were exposed to "Lisp" with Scheme at an educational setting and believe you have no iteration.
[08:13:12] <contrapunctus> I mean...it's not writing documentation, it's not writing libraries, it's not writing applications, it's not helping introduce Lisp to people...what's it achieving?
[08:13:25] <Mondenkind> gilberth: I ported sicl's LOOP implementation to scheme because it was too painful to go without!
[08:13:41] <Mondenkind> contrapunctus: semantics are interesting
[08:13:45] <Mondenkind> at least I think so
[08:13:47] <contrapunctus> gilberth: ah...now if only most of the "definition flamewars" I've seen actually talked about it at the level you just did.
[08:13:58] <Mondenkind> how are we to communicate if we do not establish what the words we use mean?
[08:14:01] <gilberth> I could survive with DO.
[08:14:26] <gilberth> Or PROG :-p That came very early.
[08:15:00] <hayley> If you have macros, you can make DO from tail recursion. Doesn't bother me.
[08:15:05] <Mondenkind> DO is not bad.  In terms of expressiveness for iterative problems, it is a small step up from recursion and a small step down from LOOP.  I mean, I could live with recursion too
[08:15:21] <Mondenkind> but prefer LOOP for LOOPy kinds of problems
[08:15:38] <gilberth> But that you can implement LOOP as this funny DSL seamlessly integrating with the rest is exactly what a Lisp is.
[08:16:14] <gilberth> Mondenkind: For a decade or so, I just had no LOOP.
[08:17:02] <gilberth> And my relationship with it is "complicated".
[08:17:03] <hayley> https://www.youtube.com/watch?v=UlKrH07au6E
[08:17:04] -ixelp- King Crimson - I Talk To The Wind - YouTube
[08:17:07] <contrapunctus> loop ftw
[08:17:17] <contrapunctus> (Well, I'm mostly `cl-loop` ing...)
[08:17:25] <hayley> mfiano: I take it you saw borodust thanking you for the shoutout FWIW.
[08:17:34] <gilberth> When MAPCAR, REMOVE, REDUCE, etc could do, I often prefer those.
[08:18:30] <mfiano> hayley: I just did the instant you mentioned that
[08:18:37] <contrapunctus> (Also, I recently discovered `loopy` ...[possibly easier] extensibility? destructuring with `pcase`/`seq-let`/`-let`? Sign me up!)
[08:18:42] <Mondenkind> I would probably use those more often if there was a better set of combinators built in.  COMPOSE, PARTIALLY-APPLY, etc.  I suppose I could make my own set, but
[08:19:01] <Mondenkind> ('those' being mapcar/remove/reduce.  Must learn to type/think faster)
[08:19:34] <gilberth> Either think slower or type faster. Not the other way around!
[08:21:00] <mfiano> hayley: I take it you saw the recent/only comment defending the article?
[08:21:14] <hayley> Don't think so.
[08:21:23] <mfiano> https://www.reddit.com/r/Common_Lisp/comments/q7zla0/selling_lisp_by_the_pound/hgtipe6/
[08:21:25] -ixelp- Selling Lisp by the Pound : Common_Lisp
[08:22:09] <hayley> Oh. I've seen that person on Twitter, and IIRC they read it before. So not exactly fair.
[08:28:00] <mfiano> Anyway, I think the was a fun experiment
[08:28:19] <gilberth> One quick note about FFI: At times you absolutely must FFI out to C to access your host environment. It's not always about speed.
[08:28:20] <mfiano> You should write more articles :)
[08:28:51] <mfiano> gilberth: Absolutely, until we have Lisp OS's
[08:29:11] <gilberth> mfiano: Dream on.
[08:29:11] <mfiano> As a game developer, I have to use something like SDL when interfacing with hardware.
[08:29:31] <mfiano> display driver, gpu driver, gamepad, etc
[08:29:43] <hayley> gilberth: Yes, but it doesn't stop one from being annoyed that they have to.
[08:29:54] <mfiano> +1
[08:30:37] <hayley> SICL gets to cheat and use syscalls on Linux, which is a bit amusing.
[08:30:42] <Mondenkind> mfiano: well, you do not _have_ to use SDL.  At least on linux
[08:31:12] <gilberth> I don't see a fundamental difference in using a random C API from using a random Lisp API. Although the latter may be much nicer.
[08:31:22] <mfiano> I do not, but also as a game developer, I'd obviously like to abstract the OS
[08:31:52] <Mondenkind> gilberth: in principle, c code is unsafe and may corrupt the image, in a way that cannot happen if you only run lisp code.  Though this is not really a problem in practice
[08:32:05] <hayley> Having interfaced with OpenCL a bunch, you have to deal with memory management sometimes, and the API library might or might not wrap C objects in Lisp objects.
[08:32:37] <gilberth> mfiano: Yes, something which also would want to do if your target OS was written in LISP.
[08:32:41] <hayley> You can write a good C interface library, but you have to write a good C interface to do it.
[08:33:29] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[08:33:32] <hayley> e.g. eazy-opencl used finalizers and didn't have a WITH-MEMORY-ON-GPU or whatever it was. So, as I don't cons in Lisp much, but I cons into the GPU, it'd run out of GPU memory.
[08:33:41] <mfiano> My code even has a shim to swap out SDL for glop2 or whatever should I need to
[08:33:47] <gilberth> Take OpenGL for instance, it's not any nicer to work with from Lisp than from C. The API is the same.
[08:33:55] <hayley> Reusing buffers fixed that, and is probably a good move anyway, but morally it shouldn't be necessary.
[08:34:08] <Mondenkind> opengl is a bit of a strawman, because the entire api is integers and float buffers
[08:34:43] <gilberth> Yep. But we have a GLX implementation in CLX.
[08:35:31] <mfiano> cl-opengl is a lot nicer to work with in Lisp
[08:35:42] <mfiano> With the GL package anyway, not the %GL package
[08:36:04] <hayley> mfiano: Still, now I have the burden of being (barely) associated with SICL and more my own libraries. So I don't write about such things anymore.
[08:36:26] <mfiano> That's good I suppose :)
[08:36:33] <gilberth> And the XKB extension, and Cairo alone may me wonder, if I really should still use CLX instead of just Xlib.
[08:36:44] <gilberth> * make
[08:36:56] <mfiano> Why xlib when you have xcb?
[08:36:58] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 252 seconds)
[08:37:15] <Mondenkind> hayley: to the contrary, being associated with sicl gives you extra ammunition and credibility!
[08:37:37] <gilberth> mfiano: Because Xcb still lacks proper support for XKB, from what I read. And: Why not?
[08:38:37] <mfiano> Well, xcb is closer to the protocol specification.
[08:38:40] <mfiano> It's lower level
[08:39:10] <gilberth> And both Cairo and XKB are crazy because they shifted everything to the X client. Keyboard mapping are now held at the client and I gave up on re-implementing all that.
[08:39:47] <gilberth> mfiano: The protocol is only half of the story. Cairo also is no protocol. Which is most silly.
[08:41:06] <gilberth> Only because you implement either the XKB protocol or the RENDER protocol (which I did for CLX) doesn't mean you could turn key events into characters typed or draw a damn anti-aliased line.
[08:41:14] <gilberth> Or draw any text.
[08:42:54] <gilberth> A pity because CLX is way nicer to work with than Xlib.
[08:42:56] <mfiano> Ok, back to Raku learning. You can blame Mondenkind 
[08:43:28] <Mondenkind> I admit nothing!
[08:43:49] <gilberth> Mondenkind: Are you moonchild?
[08:44:26] <Mondenkind> yes
[08:45:11] <contrapunctus> surprised-pikachu.png
[08:45:29] <gilberth> Mondenkind: Now you have multiple moons as parents? How did that happen?
[08:45:55] *** Joins: lisp123 (~lisp123@5.30.23.247)
[08:46:05] <Mondenkind> they were star-crossed lovers
[08:46:15] <gilberth> Heh.
[08:49:10] <gilberth> And btw Xt and Xaw are pretty nicely designed although they struggle with C having no object system and no dynamic typing.
[08:50:17] <gilberth> For Lisp there is CLUE and CLIO, IIRC CLIO is what Xt is, and it's pretty ok, while the toolkit is just buggy. A pity.
[08:50:58] <gilberth> It looks like unfinished work.
[08:52:30] <hayley> Mondenkind: For Don't BYOL, perhaps. For language bickering, it's perhaps more dangerous.
[08:53:54] <hayley> The reverse is that any shit I say could be associated with SICL, which isn't fair on anyone else.
[09:01:19] <Mondenkind> I was being somewhat flip.  But sure: there's a distinction between what you say vs how you say it.  Compare: 'I don't recommend following byol' vs 'byol is garbage and its author is clueless'.  If your goal is to convince people to behave a certain way such derision may not be appropriate anyways.  Else, there's always pseudonymity
[09:01:39] <mfiano> Mondenkind: So far my only complaint is the class definition structuring...I think it was a mistake to have methods belong to a class considering multiple dispatch and all.
[09:01:58] <Mondenkind> mfiano: yes, I agree
[09:01:58] <mfiano> What don't _you_ like about the language, now that I have a pretty good idea of it all?
[09:02:13] <Mondenkind> and there's a weird pitfall to do with methods that's not present with regular multis (https://redd.it/pz3y0z)
[09:05:11] <mfiano> I'll read that again when I finish with OOP...almost done
[09:05:16] <hayley> Well, I did write my first article under another name. But then I got no publicity.
[09:05:39] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[09:05:42] <mfiano> What I really like is the value constraints, aka custom dispatch predicates with the `where` keyword.
[09:05:53] *** Joins: lisp123 (~lisp123@5.30.23.247)
[09:06:11] <hayley> Worse, it was called a "psychological operation from 4chan" by the people I critiqued, and others went with that. 
[09:06:55] <Mondenkind> mfiano: there are many odd inconsistencies--I mentioned a few the other day, like how 5|6 != 6&8 doesn't do what you'd expect.  It is very complex.  There is a lack of good tools for point-free programming (I don't think anyone else is interested in this, however).  Performance is subpar.  Interactivity as you have mentioned.  'TIMTOWDTI' means some parts of the language are treaded more often
[09:06:57] <Mondenkind> than others; and those that don't see much traffic suffer.  E.G. 'assuming' (partially apply) is horribly slow, and there is an odd bug with declaring a multi in one module and then adding a candidate to it in another module (which is a somewhat obvious thing to do in cl, but apparently no one does it in raku)
[09:07:40] <Mondenkind> mfiano: yes, dispatch on arbitrary constraints is cool
[09:07:47] <Mondenkind> s/constraints/predicates/
[09:07:52] <mfiano> That's tacit programming right?
[09:08:31] <Mondenkind> point-free?  Yes
[09:08:49] *** Quits: Posterdati (~posterdat@host-87-7-175-125.retail.telecomitalia.it) (Ping timeout: 252 seconds)
[09:09:18] <mfiano> I am not very familiar with the actual definition of that, but I liken it to what "arrow macros" provide in some Lisps
[09:09:42] <Mondenkind> in general, it's writing functions which do not explicitly name their parameters
[09:10:09] <mfiano> What about Raku's placeholders?
[09:10:11] <Mondenkind> forth is tacit.  Modern APL is quite good at tacit programming
[09:10:15] <mfiano> Is that related?
[09:10:57] <Mondenkind> the whatever star?  That...ehh.  People call it 'tacit', but I think of it more as a name which happens to be predefined
[09:11:01] <mfiano> No...
[09:11:03] <mfiano> One sec
[09:11:45] <mfiano> the ^ twigil
[09:12:20] <Mondenkind> no, that's just a way to give names to parameters which doesn't require naming them twice
[09:12:33] <mfiano> sub subtract { $^b - $^a }; say subtract(10, 8) # -2
[09:12:47] <mfiano> ah ok
[09:13:17] <Mondenkind> imagine programming exclusively with combinators
[09:13:43] <mfiano> I use a tacit style (I was told) in my noise library via arrow macros
[09:14:04] <Mondenkind> I don't know what arrow macros are
[09:15:30] <mfiano> (-> foo (bar 1) (baz 2)) == (baz (bar foo 1) 2)
[09:16:05] <mfiano> or (->> foo (bar 1) (baz 2)) == (baz 2 (bar 1 foo))
[09:16:09] <mfiano> etc
[09:16:47] <gilberth> That's a weird mix of postfix and Currying.
[09:16:48] <Mondenkind> point-free would be more like: (-> (bar 1) (baz 2)) ‚Üê‚Üí (lambda (foo) (baz (bar foo 1) 2))
[09:17:44] <mfiano> ah
[09:18:39] <gilberth> How would you formulate a square function with that using *?
[09:19:24] <mfiano> arrow macros allow for describing a set of actions linearly...it flattens a tree of nested operations
[09:19:28] <mfiano> example: https://gist.github.com/mfiano/ef08813d0371c67e1d91b83104264f33
[09:19:29] -ixelp- 1.lisp ¬∑ GitHub
[09:19:39] <Mondenkind> gilberth: depends on the set of combinators you have available to you.  In j it would be '*~'; f~ y is the same as y f y, so *~ 5 becomes 5 * 5
[09:20:57] <gilberth> What if I need (lambda (x) (blah x 1 x))?
[09:22:03] <lisp123> If I want to define my own symbols to be used in place of standard CL symbols, I'm thinking of adding a % suffix to the end of them, e.g. defun%, gethash% --> Is there a standard prefix or suffix typically used?
[09:22:04] <Mondenkind> j only has functions of 1 and 2 parameters.  If you wanted to pass a list of x,1,x you might say something like: [: blah ] , 1 , ]
[09:22:28] <lisp123> Oops wrong chat
[09:23:00] *** Joins: Posterdati (~posterdat@host-82-49-184-109.retail.telecomitalia.it)
[09:23:37] <gilberth> lisp123: consider using a package and stick to the original names.
[09:25:42] <Mondenkind> (there is also a shorter solution which does not require the unsightly ], but it is not considered good style these days, unfortunately)
[09:26:56] <lisp123> gilberth: Thanks!
[09:27:28] <gilberth> lisp123: You know about shadowing symbols?
[09:27:52] <lisp123> gilberth: Yes :)
[09:27:56] <gilberth> Mondenkind: It still feels like needing to press my idea into a given scheme.
[09:29:17] <gilberth> Somehow my MacMini forgets at random times that it has a display port and refused to output a signal there, needing a reboot.
[09:30:12] <gilberth> Perhaps I down^Wupgrade the OS and see if that persists. Never had that trouble before.
[09:30:39] <Mondenkind> gilberth: well, two things.  First: it is an unfamiliar syntax, but given experience explicit functions in j can be trivially rewritten tacitly.  Second: yes, apl is like that (in other respects); somewhat diametrically opposed to lisp, so I am not surprised if no one here likes it
[09:31:06] <Mondenkind> (there is even a utility built-in which can perform such rewrites automatically)
[09:32:04] <gilberth> Well, it sure could be handy, but I don't alike a particular paradigm pushed on me.
[09:32:46] <Mondenkind> my experience is that tacit functions may be more difficult to write initially, but that once written they compose much better and can be read more easily without the burden of thinking about what is bound to what in some scope
[09:33:46] <Mondenkind> 'don't alike a particular paradigm pushed on me'  I am not pushing a paradigm on you!  Just describing why I like it
[09:34:11] <gilberth> Well, I can't see how some task that is inherently procedural could be written in a nice to follow way.
[09:34:29] *** Joins: dave0 (~davezero@069.d.003.ncl.iprimus.net.au)
[09:34:49] <gilberth> Mondenkind: Not you personally, I just discuss the idea with you and try to provoke a little.
[09:34:53] <Mondenkind> :)
[09:35:15] <dave0> maw gilberth 
[09:35:28] <gilberth> Hello dave0!
[09:35:33] <dave0> hey how are you?
[09:35:45] <gilberth> dave0: Came here for the coffee?
[09:36:01] <gilberth> dave0: I am pretty fine and about to crash.
[09:36:08] <dave0> gilberth: yep! top me up, hun!
[09:36:21] <dave0> gilberth: bedtime?
[09:36:21] <Mondenkind> re procedural task: you are right.  There have been some proposals made, but nothing very good.  Generally procedural algorithms are implimented as a sequence of assignments in terms of tacit programs, with no deep nesting, which I still find pretty satisfactory
[09:36:38] <gilberth> dave0: Yes, bedtime. Slept like nine hours each the last two nights, I needed that.
[09:37:00] <Mondenkind> gilberth: good night!
[09:37:14] <gilberth> I am still here.
[09:37:25] <dave0> gilberth: happy to hear that
[09:37:32] <Mondenkind> :)
[09:38:32] * gilberth as a last action for today prepares some coffee for dave0.
[09:38:38] <mfiano> Mondenkind: "but apparently no one does it in raku"
[09:38:40] <mfiano> !!!
[09:38:43] <mfiano> wut
[09:39:01] <dave0> gilberth: thanks mate! i take it black please
[09:39:51] <gilberth> dave0: I remember. A good barista remembers. And sorry for the badly shaped lambda, the foam to night isn't just stiff enough.
[09:39:55] <Mondenkind> mfiano: because if you can 'just' inherit the class and override the method it is 'superfluous'
[09:40:01] <Mondenkind> gilberth: :D
[09:40:08] <mfiano> Sigh. Old habits
[09:40:19] <dave0> lol stiff foam
[09:41:04] <Mondenkind> mfiano: I think a raku which had no methods--only multis--would be a better and more consistent one
[09:41:11] <mfiano> Mondenkind: You also mentioned performance being subpar. Is that overall? I thought some things were very fast from what people told me. Were they coming from Python? :)
[09:42:02] <gilberth> dave0: What's so funny about it?
[09:42:14] <dave0> gilberth: foam is usually soft and squishy
[09:42:34] <gilberth> Yes, but not waterish.
[09:43:18] <gilberth> So my lambda turned into a "b" quick. Sorry.
[09:43:36] <Mondenkind> well.  Compared with cl it's slow, compared with python it's fast.  There is also a subset (nqp) which is decently fast, but there tend to be performance pitfalls in the 'obvious code'
[09:44:20] <mfiano> Mondenkind: It sounds like you are losing interest in the language.
[09:44:53] <gilberth> dave0: I hope you enjoy your coffee nevertheless.
[09:45:22] <Mondenkind> recently the dispatch mechanism was completely rewritten, giving massive improvements on some benchmarks.  I made a dumb dispatch benchmark before that rewrite happened, and got 100x slower pace than sbcl
[09:45:25] <dave0> i will, thank you gilberth, have a space !
[09:45:44] <gilberth> Thanks!
[09:46:10] <Mondenkind> mfiano: 'losing interest'  not particularly.  Were I to build up the universe in the image of one language it would not be raku--too many imperfections--but I like it as much as I ever did for scripts and such
[09:46:27] <mfiano> Mondenkind: Isn't it hard to benchmark? I would assume the JIT has to warm up etc.
[09:47:44] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[09:48:05] <Mondenkind> I did run the benchmark in a loop.  It's certainly possible the benchmark was flawed, but two orders of magnitude is significant, even for cold code.  I would expect no more than a 10x difference between tcc and gcc -O2, for most code; probably usually less
[09:48:21] <mfiano> Yeah that is odd.
[09:48:25] <mfiano> Mondenkind: What language would that universe be in then, out of curiosity?
[09:49:48] <Mondenkind> I am not sure.  Mainly I cannot decide whether it is better to be referentially transparent or not
[09:50:52] <mfiano> I think that is a bit too encumbering on a user for a language to decide.
[09:51:18] <Mondenkind> you are a lisper, of course you would say that :)
[09:51:33] <mfiano> Ha fair enough.
[09:51:39] <Mondenkind> obviously it is more locally expressive to have pointers.  Yet, not having pointers allows you to abstract over computation in interesting ways
[09:52:04] <Mondenkind> want to make a snapshot?  Or have network transparency?  THese things become much easier
[09:52:31] <mfiano> Sure. I learned that the hard way recently.
[09:52:35] <hayley> With pointers, you can sorta ignore them. Without, you have to build pointers as you do in databases.
[09:53:12] <mfiano> Writing a propgation network with support for backtracking means I had to write specialized deep copiers for lots of objects, and use tons of memory.
[09:53:55] <Mondenkind> hayley: why should that be primitive which I can implement myself?  In apl, structures are flat and it is much more convenient to work with arrays of indices
[09:54:39] <Mondenkind> I did a lisp interpreter in j.  It was a toy, of course, but compacting GC was 6 lines of code
[09:54:51] <mfiano> Wow
[09:55:58] <hayley> You could, but machine pointers are handy, and you are out for in-place algorithms without the compiler doing some magic.
[09:56:00] <mfiano> J scares the shit out of me. I don't want that level of concision. I'm too old to distance myself that much from natlang.
[09:56:08] <gilberth> Well, if implement your own pointers, you wind up with just integers to be interpreted as indices into a particular array. Not any better than B really.
[09:57:04] <Mondenkind> gilberth: it is the 'dynamic-typing' version of pointers; more powerful, more dangerous
[09:57:06] <hayley> And getting unique pointers serializes with multiple threads, unless you are clever (and invent thread-local allocation buffers basically).
[09:57:17] <gilberth> TeX is written like that, it has a huge array of "words" all being integers and builds all kinds of data structures there. No dynamic typing, just addresses.
[09:57:49] <gilberth> Mondenkind: ok. So a pair of a type and an index?
[09:58:28] <gilberth> And the Lisp GC cannot garbage collect the TeX heap.
[09:59:01] <Mondenkind> the j GC can be much simpler because it does not have to chase so many pointers
[09:59:19] <Mondenkind> hayley: indeed!  This is why I am not sure where the balance lies
[09:59:31] <Mondenkind> gilberth: what do you mean 'pair of a type and index'?
[10:00:04] <gilberth> You said it would by dynamically typed, so you must carry a type around.
[10:00:51] <gilberth> However since Knuth has a single data type called just 'pointer', which is an integer, makes it very hard to untangle (pun intended) that mess.
[10:01:22] <Mondenkind> oh, I see.  Then, not dynamically typed, untyped.  However it is a different case from tex (from my recollection of scanning your lisp translation)
[10:01:41] <Mondenkind> in tex, the pointer is an index into a global array of unions, and does not contain a discriminant, yes?
[10:02:40] <gilberth> Yes. And it could point to all kind of objects, all allocated in that array at consecutive indices like a record.
[10:03:43] <gilberth> There even is a malloc/free. And those object are defined by macros like foo_x(p)==core[p+0] and foo_y(p)==core[p+1].
[10:03:59] <Mondenkind> in j all arrays are completely homogenous.  Typing is strong.  So you if you want to assign types you might say 'x is an array of indices to y', but this makes it very cumbersome to use.  What if, suddently, I decide that I would like to treat x as an array of indices into z, for some reason?  But I did not declare the type of x that way; and constructing a proof that all elements of x are valid
[10:04:01] <Mondenkind> indices into z could be very cumbersome or impossible
[10:04:36] <Mondenkind> moreover, even if one constructs such a proof, it does not demonstrate that indexing z with x means what I wanted it to mean.  SO it accomplishes no more than a runtime bounds check would, except that it happens at compile time
[10:04:51] <mfiano> Anyway, I have been thinking of branching out. CL will always be my language, but given I've been working on a graphical renderer with the abstractions I need for data visualization for about 10 years now, and nowhere near complete, I have been thinking of using something like Julia or Racket for dataviz. I am just hesitant to cut my losses given how invested I am.
[10:06:12] * mfiano has been on this fence for about 2 years
[10:06:38] <Mondenkind> mfiano: why do you want to branch out?  What do you think julia or racket will give you that cl does not?
[10:08:36] <mfiano> Hopefully, more batteries and less time managing/fixing/adding on to an in-house pile of libraries that are only a means for the ultimate end goal.
[10:08:49] <mfiano> I seem to be moving backwards still a decade later
[10:08:56] <mfiano> My back burner has back burners
[10:09:03] <Mondenkind> heh, that is fair
[10:13:22] <mfiano> I am probably being foolish for thinking that.
[10:13:39] <mfiano> I only recently, about a year ago, decided that I do not like game development too much, so have prioritized my work towards data visualization in my "game engine".
[10:14:37] <mfiano> I am more into visualizing algorithms, geometry, etc.
[10:15:05] <mfiano> I guess an example would be the kinds of simulations 3b1b does
[10:15:33] *** Joins: selwyn_ (~selwyn@user/selwyn)
[10:18:04] <mfiano> I like traditional AI, generative art algorithms, texture synthesis, cellular automata, etc.
[10:18:27] *** Quits: selwyn_ (~selwyn@user/selwyn) (Client Quit)
[10:19:36] <mfiano> I have wanted for example, something that could render a generative algorithm step-wise for debugging and demonstration purposes, but generative algorithm is pretty general, and a lot of abstractions over rendering need to be made.
[10:20:51] <mfiano> Or maybe I am just not a good programmer
[10:21:03] <mfiano> </rant>
[10:23:01] *** Quits: euandreh (~euandreh@2804:14c:33:9fe5:11fc:225b:3e1b:f83b) (Ping timeout: 245 seconds)
[10:24:12] *** Joins: euandreh (~euandreh@2804:14c:33:9fe5:8d5f:78c6:cd1:4a9b)
[10:27:18] *** Joins: lisp123 (~lisp123@5.30.23.247)
[10:27:31] *** Quits: jasom (~aidenn@2600:8802:7fa0:500:f833:278f:1567:d354) (Ping timeout: 265 seconds)
[10:38:59] <selwyn> mfiano: would you consider r for data visualisation?
[10:39:14] <mfiano> I wouldn't.
[10:39:26] <selwyn> but r is a lisp :o
[10:39:29] * selwyn hides
[10:39:35] <mfiano> R and MATLAB are incredibly slow
[10:39:38] <selwyn> yes
[10:40:10] <selwyn> i would like to port ggplot2 to common lisp some day
[10:40:17] *** Joins: jasom (~aidenn@2600:8802:7fa0:500:f833:278f:1567:d354)
[10:41:07] <selwyn> ime the only thing i have really missed in common lisp is a proper plotting library
[10:41:15] <selwyn> piping out to gnuplot is horrible
[10:42:59] <selwyn> 3blue1brown?
[10:43:11] <Mondenkind> youtube thingy
[10:43:17] <selwyn> right, that guy
[10:45:48] <selwyn> cl-vectors looks nice
[10:50:20] <kakuhen> wtf my mac just randomly killed my clozure cl repl that i kept open for more than 3 days 
[10:50:26] <kakuhen> "it just works, bro"
[10:50:30] <kakuhen> more like "it just fails"
[10:50:48] <kakuhen> i swear to god the sly repl was just fine even this morning
[10:51:04] <kakuhen> then i come back to my computer and I see "Process sly-pty-3-1 killed: 9"
[11:05:59] <hayley> Mondenkind: Methinks mark-compact is pretty simple. It gets messy when you need to go in place still.
[11:07:15] <Mondenkind> hayley: indeed.  My point was that working with pointers is not unnatural, even though they are not a primitive language feature
[11:17:07] <lisp123> kakuhen: lol
[11:18:44] * hayley nods
[11:22:54] *** Joins: MichaelRaskin (~MichaelRa@ipb21a9944.dynamic.kabel-deutschland.de)
[11:22:54] *** ChanServ sets mode: +o MichaelRaskin
[11:26:29] *** Quits: retropikzel (~retropikz@dsl-trebng22-54f932-93.dhcp.inet.fi) (Quit: Leaving)
[11:30:05] *** Quits: lisp123 (~lisp123@5.30.23.247) (Quit: Leaving...)
[11:36:31] *** Joins: hendursa1 (~weechat@user/hendursaga)
[11:38:03] *** Quits: chiselfuse (~chiselfus@user/chiselfuse) (Remote host closed the connection)
[11:38:30] *** Joins: chiselfuse (~chiselfus@user/chiselfuse)
[11:39:12] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[11:46:33] <mfiano> Mondenkind: Do you have a link to the bug about cross-module method candidates?
[11:47:29] <mfiano> I've been sitting here for an hour thinking about how big of a problem that is, and which languages I want to spend my time with...
[11:50:53] <Mondenkind> i never filed a bug report; actually, probably I should
[11:56:05] <mfiano> Still Raku is one of the most interesting languages I've come across. I am hesitant to invest too much into it though, because it has some of the same advantages and disadvantages as CL
[11:59:18] <mfiano> But I'll be honest. One reason I like it is because it is NOT interactive.
[11:59:46] <Mondenkind> heh, why is that?
[11:59:48] <mfiano> Which means I can be just as effective as anyone else using vim or any other editor :)
[11:59:48] * hayley uploaded an image: (11KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/OIhzhhinYxCVAxCQxCGdLuZa/bruhcha.jpg >
[11:59:52] <Mondenkind> hehe
[12:00:30] * Mondenkind uses emacs pretty much just for cl; vim for everything else
[12:00:50] <mfiano> I am a much happier person when I get to use my vim config. It runs well on old hardware etc
[12:00:59] <mfiano> Same
[12:02:09] <kakuhen> by the time i got my first computer, even the lowest end options would run emacs well
[12:02:43] <kakuhen> maybe once i dumpster dive and get older hardware i'll sing a different tune :3c 
[12:03:05] <kakuhen> I accidentally found a dozen or so desktop PCs just tossed outside of the back alley of some engineering  buildings at uni
[12:03:09] <mfiano> When I got my first computer, a web browser ran decent in 64MB of ram
[12:03:27] <mfiano> Doesnt say much about the stack of crap of today
[12:03:38] <hayley> When I got my first computer, my mum would use it to cheat on forum games as it'd run Flash very slowly.
[12:03:41] <kakuhen> (regarding the thrown out PCs, i didnt have my screwdriver with me, otherwise id have taken out all the hard drives and put them into my own storage, assuming good SMART results w)
[12:03:49] <Mondenkind> Eight Megabytes And Constantly Swapping :)
[12:03:59] <kakuhen> that was Emacs in 1980
[12:04:07] <kakuhen> emacs in 2080 will be Eight Gigabytes and Constantly Swapping
[12:04:42] <hayley> What's this, 75.5MB for GTK+ Emacs with SLIME loaded?
[12:05:09] <hayley> SBCL even has 98MB reserved already, can't complain.
[12:05:30] * mfiano remebers when he ran a full X11 desktop in 32M
[12:07:27] <mfiano> For a long while I refused to use an x86_64 OS, since I had approximately twice as much free ram for computations on x86
[12:08:22] <hayley> Hm, have I written anywhere that the Netfarm bunny is nicknamed Demeter?
[12:08:36] <hayley> ...as there is now https://nyxt.atlas.engineer/application/demeter.org
[12:08:49] <Mondenkind> what's the least combative way to say 'non sequitur'?  I came up with 'I'm not quite sure what you're getting at', but I worry that could be taken as sarcastic
[12:09:29] <hayley> "This doesn't seem to follow?"
[12:09:50] <hayley> "What does this have to do with that?"
[12:09:50] <selwyn> "wtf lol"
[12:10:18] <hayley> A: nope. Eh well, you get that.
[12:10:19] <kakuhen> my emacs is consooming 280 mb right now
[12:10:30] <kakuhen> but that's because its been up for nearly a week and i do not close any buffers
[12:10:36] <kakuhen> there's like 100 buffers active right now
[12:10:47] <kakuhen> and im only really using about a dozen of them
[12:10:51] <kakuhen> distributed across 4 frames
[12:11:27] <kakuhen> one is for commutative algebra notes, the other is for analysis homework, the other is for commutative algebra homework, and the last one is me wasting time with lisp.
[12:11:52] <kakuhen> pdf-tools is probably contributing to the bulk of the ram usage
[12:12:16] <selwyn> you do your homework in emacs?
[12:12:48] <mfiano> I am beginning to think Raku people don't know the first thing about proper IRC etiquette
[12:12:49] <selwyn> i don't view pdfs in emacs anymore because the memory was out of control
[12:13:24] <hayley> Are they bickering over time zones? Asking to ask questions?
[12:13:47] <mfiano> More like constantly flooding 20+ line copy/pastes
[12:14:29] <hayley> Ah yes, another classic.
[12:20:52] <mfiano> hayley: borodust says he isn't offended and glad there was a link to alien-works
[12:21:08] <hayley> Pff.
[12:27:39] <selwyn> am excited about his c++ ffi work
[12:27:54] <selwyn> would be great to use physx and such
[12:29:39] * hayley passes for a DFA inspector to other DFA hackers.
[12:30:23] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[12:30:27] * mfiano will stick to CA
[12:32:54] *** Joins: lisp123 (~lisp123@5.30.23.247)
[12:33:34] <contrapunctus> mfiano: CA?
[12:34:36] <mfiano> https://en.wikipedia.org/wiki/Cellular_automaton
[12:35:18] <lisp123> How does slime know how to intern symbols in particular files into the packages that they are meant to be in (e.g. (in-package ...) --> I'm talking not during a file load, but rather on the spot when recompiling functions
[12:35:53] <mfiano> It looks up in the file for the previous in-package
[12:36:19] <lisp123> mfiano: Thanks!
[12:36:21] <mfiano> The only thing it can do
[12:38:11] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 264 seconds)
[12:40:47] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[12:53:29] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 265 seconds)
[12:55:13] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[12:55:48] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Client Quit)
[12:59:13] *** Joins: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se)
[13:03:55] *** Quits: Qwnavery (~Qwnavery@user/qwnavery) (Quit: WeeChat 3.3)
[13:05:20] *** Quits: hendursa1 (~weechat@user/hendursaga) (Remote host closed the connection)
[13:05:49] <mfiano> Mondenkind: Still awake?
[13:07:51] <Mondenkind> probably not for long...
[13:07:53] <Mondenkind> wassup?
[13:07:59] <mfiano> Do you have any idea why this works?... my $scalar; push $scalar, 'foo' for 1..3; $scalar # [foo foo foo]
[13:08:18] <mfiano> I typod $ for @ and was expecting an error
[13:08:27] <Mondenkind> probably push takes its param as rw
[13:08:30] <Mondenkind> so it's allowed to modify it
[13:08:50] <mfiano> hmm
[13:12:15] *** Joins: hendursa1 (~weechat@user/hendursaga)
[13:12:22] <mfiano> Well that's confusing what I annotated to be a scalar gets transformed into an aggregate
[13:13:09] <mfiano> I will ignore that one for now...
[13:13:31] <Mondenkind> anything can be a scalar
[13:13:45] <Mondenkind> my $x = [1, 2, 3] #fine
[13:13:50] <mfiano> Maybe that's my confusion
[13:14:39] <mfiano> Yeah it must be my confusion, and then I question sigil usefulness
[13:14:55] <mfiano> Must have glossed over some important detail early in my reading
[13:15:42] <Mondenkind> sigil signals to a human how you primarily relate to a variable
[13:15:55] <Mondenkind> @ you primarily relate to as an ordered sequence of items
[13:16:05] <Mondenkind> $ you primarily relate to as a single item, which might happen to be an array
[13:17:53] <mfiano> Well it can't be just for a human
[13:19:46] <hayley> How would I tell if it's a good time to start compiling in a background thread? Watch the system load?
[13:21:25] <mfiano> my $a = 1 => 2; $a.WHAT # (Pair), my @a = 1 => 2; @a.WHAT # (Array), my %a = 1 => 2; %a.WHAT (Hash)
[13:23:07] *** Quits: hendursa1 (~weechat@user/hendursaga) (Remote host closed the connection)
[13:23:51] *** Joins: hendursa1 (~weechat@user/hendursaga)
[13:32:04] <selwyn> abc
[13:32:08] <selwyn> always be compiling
[13:32:37] <selwyn> https://www.youtube.com/watch?v=Yz246_Pjjkc
[13:32:37] -ixelp- ABC - Always Be Closing - YouTube
[13:37:00] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[13:38:09] *** Quits: hendursa1 (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[13:38:53] *** Joins: hendursa1 (~weechat@user/hendursaga)
[13:40:16] * hayley uploaded an image: (270KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/RpSLakqbjiUmKrMUHzUKDkXs/evil-leslie-lamport.jpg >
[13:42:04] *** Joins: lisp123 (~lisp123@5.30.23.247)
[13:46:35] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 264 seconds)
[13:54:54] *** Quits: White_Flame (~quassel@user/white-flame/x-6930243) (Remote host closed the connection)
[13:55:03] <pjb> lisp123: mfiano: note that slime is not too smart, it just scans for in-package, not for the code that would do the same: https://termbin.com/x386
[13:55:49] <mfiano> Right
[13:56:07] *** Joins: White_Flame (~quassel@user/white-flame/x-6930243)
[14:02:08] *** Joins: treflip (~user@95.79.32.99)
[14:19:54] <hayley> Evil beach be like "Bad evening everyone!"
[14:20:29] *** Joins: lisp123 (~lisp123@5.30.23.247)
[14:22:46] *** Joins: makomo_ (~makomo@user/makomo)
[14:28:00] *** Joins: random-nick (~random-ni@87.116.165.220)
[14:30:58] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[14:36:49] <hayley> https://www.jbowens.org/about "You can find this page again by searching the internet for this string: uidlamporttlahomepage. Please, no one else use this string on the internet. Especially not you Leslie Lamport."
[14:36:53] <hayley> Cheeky bastard
[14:43:11] <mfiano> whew...that was a lot to take in. regex in Raku is crazy powerful
[14:47:43] *** Quits: treflip (~user@95.79.32.99) (Quit: ERC (IRC client for Emacs 27.2))
[14:50:11] *** Quits: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se) (Ping timeout: 264 seconds)
[15:00:45] <selwyn> i read raku as ragu
[15:00:48] <selwyn> lisp bolognese
[15:01:21] * mfiano finished this really poorly-written 600-page Raku book with some of his hair still intact.
[15:01:36] <mfiano> Time to read the official documentation
[15:02:06] <hayley> https://www.youtube.com/watch?v=s37cUyTGRUM
[15:02:06] -ixelp- Firth Of Fifth (Remastered 2008) - YouTube
[15:14:00] <hayley> https://i.redd.it/cppd6tetbpt71.png
[15:14:51] *** Joins: dec0d3r (~dec0d3r@2001:8003:480a:e00:e07:e7c3:7efc:ed0f)
[15:20:35] <dave0> haha
[15:22:38] *** Joins: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se)
[16:06:46] *** Quits: pjb (~pjb@user/pjb) (Ping timeout: 245 seconds)
[16:13:02] *** Joins: sepanko (~sepanko@user/sepanko)
[16:21:08] *** Joins: humasect (~humasect@2001:1970:57e0:4100::141e)
[16:32:30] *** Joins: pjb (~pjb@user/pjb)
[16:36:01] <hayley> "We didn't pay for anal arm service...thanks autocorrect" - someone
[16:46:54] *** Quits: humasect (~humasect@2001:1970:57e0:4100::141e) (Quit: Leaving...)
[16:53:01] <dave0> nite all
[16:53:48] *** Quits: dave0 (~davezero@069.d.003.ncl.iprimus.net.au) (Quit: dave's not here)
[16:58:53] <gilberth> Good morning #lispcafe!
[16:59:32] *** Joins: lisp123 (~lisp123@5.30.23.247)
[17:01:26] <selwyn> good morning gilberth
[17:02:01] *** Joins: dra (~dra@2a04:4540:641a:ef00:f09a:5895:b098:1e62)
[17:02:05] <dra> Hello!
[17:04:04] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[17:11:31] <gilberth> Would I get into trouble, when I use UTF-8 in a source file? Is this still an issue?
[17:30:02] <pjb> No issue for most CL implementations.
[17:36:23] <gilberth> pjb: Yes, as long as LC_CTYPE is set to UTF-8.
[17:36:34] <semz> I think some implementations (CLISP and SBCL?) struggle with it if your locale isn't se-, ah sniped
[17:37:10] <semz> but there should be a variable to set the default encoding even if the locale isn't set correctly
[17:37:10] <gilberth> semz: Yes, SBCL is, again, the most picky one here.
[17:37:29] <gilberth> Which would be trouble for the potential user.
[17:38:54] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.3)
[17:39:03] <gilberth> Dammit, we have 2021 and not 1981, when someone loves 8-bit national character sets, so be it. I guess, I just go ahead.
[17:39:48] <gilberth> Heh, has ASDF an option to declare a projects external format?
[17:43:29] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[17:51:52] <pjb> gilberth: you can use https://github.com/informatimago/lisp/blob/master/tools/source.lisp  to read the metadata in the source files to set the right external-format.
[17:51:53] -ixelp- lisp/source.lisp at master ¬∑ informatimago/lisp ¬∑ GitHub
[17:54:14] <pjb> it uses com.informatimago.common-lisp.cesarum.file:safe-text-file-to-string-list
[18:00:19] <pjb> gilberth: for example: (getf (with-open-file (stream #P"~/src/public/lisp/tools/source.lisp") (com.informatimago.tools.source:read-source-header stream)) :|coding|) #| --> "utf-8" |# 
[18:01:42] <pjb> then you can use (COM.INFORMATIMAGO.CLEXT.CHARACTER-SETS:EMACS-ENCODING-TO-LISP-EXTERNAL-FORMAT "utf-8") to get an external-format usable in the current implementation.
[18:02:32] <pjb> so: (load source :external-format (com.informatimago.clext.character-sets:emacs-encoding-to-lisp-external-format (getf (with-open-file (stream source) (com.informatimago.tools.source:read-source-header stream)) :|coding|)))
[18:02:37] <pjb> and then you have no problem.
[18:03:14] *** Joins: Psybur (~Psybur@mobile-166-170-34-168.mycingular.net)
[18:03:31] <pjb> gilberth: there's   #+asdf-unicode :encoding #+asdf-unicode :utf-8 in the defsytem form.
[18:04:11] <pjb> Of course if you add an asd system to some source, one first step would be to iconv -f whatever -t utf-8 *
[18:04:31] <pjb> You can always do that when  you take change of some old sources.
[18:14:11] *** Quits: dec0d3r (~dec0d3r@2001:8003:480a:e00:e07:e7c3:7efc:ed0f) (Remote host closed the connection)
[18:14:56] <gilberth> Why would I want iconv in there?
[18:15:23] <pjb> to convert iso-8859 files into utf-8
[18:15:51] <gilberth> I don't have iso-8859-1 files and I don't want them.
[18:16:29] <pjb> If you only have utf-8 files, then you're all set.
[18:17:04] <gilberth> Well then. I am all UTF-8 since more than a decade.
[18:17:13] *** Quits: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se) (Ping timeout: 252 seconds)
[18:18:51] <gilberth> But if somebody wants to use my code, with not having set an UTF-8 locale, they would fail.
[18:22:25] <gilberth> BTW, I patched my emacs to recognize a "coding:" header ages ago. At a time, I still had some iso-8859-1 files left. I proposed to make CLISP recognize that, but that proposal was not accepted. Must have been some 20 years ago. Perhaps longer.
[18:22:45] <pjb> that's their problem. You can indicate my utilities in the readme.
[18:23:08] <selwyn> uk to set to fund 'mini nuclear reactors'
[18:23:11] *** Quits: makomo_ (~makomo@user/makomo) (Ping timeout: 264 seconds)
[18:23:12] <selwyn> i assume they mean modular
[18:23:33] <pjb> emacs natively recognizes buffer local variables, including coding in -*- ‚Ä¶ -*-  on the first two lines of a file.
[18:23:33] <selwyn> would be typical of this country to do chernobyl 2 and scare everyone off nuclear again lol
[18:23:42] <pjb> s/buffer local/file local/
[18:23:53] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[18:24:07] <gilberth> Well then again. pjb, I am depressed at times that file encoding still is an issue. The world should switch to UTF-8 and be set until the Unicode is used up emoji and needs to extended.
[18:24:43] <pjb> selwyn: mini nuclear reactors, notably based on liquid salts, are way safer than usual nuclear power plants, which are way safer than controlled atomic bombs like what they ran at Chernobyl.
[18:24:49] <selwyn> i know
[18:24:52] <gilberth> pjb: I patched my Emacs^WXEmacs at a time it would not by default.
[18:24:59] <selwyn> i am making a joke about britain
[18:25:28] <pjb> Hasn't quality of Made in Britain products increased lately?
[18:25:33] <gilberth> "controlled atomic bomb" lol But yes, that's true, depending on active cooling.
[18:25:40] <selwyn> has it?
[18:25:57] <selwyn> i have not noticed lol
[18:26:08] <pjb> Everybody use Raspberry Pis everywhere‚Ä¶
[18:26:35] <gilberth> Isn't ARM British, too?
[18:26:48] <pjb> Indeed.
[18:26:49] <selwyn> https://www.youtube.com/watch?v=WO1ebXqUFDw
[18:26:49] -ixelp- IT Crowd : Fire - YouTube
[18:27:04] <pjb> I know, and also Little Britain had something about it IIRC.
[18:27:24] <selwyn> arm was cleverly sold off to a japanese company and might go to nvidia
[18:27:48] <selwyn> raspberry pis are still made in wales which is cool
[18:36:28] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 252 seconds)
[18:38:23] <ck_> 7
[18:38:49] <ck_> sorry
[18:43:10] *** Joins: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se)
[18:57:14] <gilberth> Huh? No /usr/include on my system? This is getting ridiculous, Apple.
[19:02:14] *** Joins: lisp123 (~lisp123@5.30.23.247)
[19:09:23] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 264 seconds)
[19:10:20] *** Quits: pjb (~pjb@user/pjb) (Remote host closed the connection)
[19:11:54] *** Joins: pjb (~pjb@user/pjb)
[19:14:06] *** Quits: lonjil (~quassel@user/lonjil) (Quit: Quit.)
[19:16:13] *** Joins: lonjil (~quassel@user/lonjil)
[19:19:35] *** Quits: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se) (Ping timeout: 264 seconds)
[19:26:02] <contrapunctus> gilberth: reject UNIX, return to CLOSOS
[19:33:45] *** Joins: selwyn_ (~selwyn@user/selwyn)
[19:41:50] *** Joins: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se)
[19:44:33] *** Quits: selwyn_ (~selwyn@user/selwyn) (Quit: Leaving)
[19:52:35] *** Quits: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se) (Ping timeout: 264 seconds)
[20:33:33] <gilberth> contrapunctus: There is no CLOSOS and I like my file system, thanks. Bad marketing move as for CLIM. The latter I plan to correct.
[20:34:41] <gilberth> It's really like selling Lisp as functional language and people get the impression that you must use recursion to express iteration. No, you don't have to use presentation types to use CLIM.
[20:38:53] <contrapunctus> gilberth: CLOSOS exists...in the hearts and minds of the people working for it. And possibly one day on their test VMs üòè
[20:41:50] <gilberth> Well, it's centered around the idea to ditch the file system, which is something I don't like. Give me a Lisp based server OS with a file system that could talk to and integrate with the outside world, and I am in.
[20:42:46] <gilberth> Both the Lisp as an OS and not having a file system should be separate projects.
[20:43:55] <gilberth> When you can run circles around nginx, because you're not bound to the awkward UNIX API and select(2) not working on files, you already win.
[20:44:03] <pjb> contrapunctus: it's not rejecting unix, it's rejecting all the nice applications and services and device drivers there are around it.
[20:44:28] *** Joins: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se)
[20:44:47] <contrapunctus> pjb: tsk, I'm just trolling...
[20:44:50] <pjb> Already just using a system with 100% GPL software (or even open source) is hard enough. You don't get to use nice looking new devices and integrations.
[20:45:35] <pjb> Well, the point is that it should be easy enough to write a usable (and even useful) OS in CL or anything.  The difference between usable and useful in the 80s and usable and useful in the 2020s is the network effect‚Ä¶
[20:45:50] <gilberth> As I always said: Start headless, don't target the desktop, leverage on Linux for device drivers. I keep repeating myself for 25 years here.
[20:46:31] <pjb> If you can satisfy yourself of a system with limited networking (I mean, social networking, like, rejecting MS-Word documents, or using Microsoft Team for you remote work),  then you can use your own OS.
[20:47:15] <pjb> gilberth: Sure, but if we don't invest any time on it, it's because we know that it would be useless, until we have the resources to establish the required network effect or gateways.
[20:49:19] <gilberth> pjb: Well, my setup is working good enough for me, I see no point to invest the little time I have left for marginal returns.
[20:50:53] <gilberth> And in general it's getting harder and harder to compete with time. The set of features and applications Linux offers today is vastly larger than in the 90s. It's a lost cause.
[20:51:21] <gilberth> Even porting Emacs to CL, is a lost cause.
[20:51:53] <contrapunctus> gilberth: "No cause is lost if there is but one fool left to fight for it." üòè
[20:53:21] <contrapunctus> Personally I'll take a malleable, feature-incomplete system over a fully-featured, brittle one. I can switch back to the latter when I want something else done, until the time it is implemented.
[20:53:24] <pjb> gilberth: yes, porting. But compiling could still be doable.
[20:53:45] <pjb> A C compiler targetting CL could be useful for other things. Eg. using a library written in C, without having to use FFI.
[20:53:50] <gilberth> One fool is not enough, that's the point. I already failed with writing a web browser in ancient times. Heck, I was the first to pass the CSS acid test, but the W3C just invented stuff at a pace, a single person could not keep up with, and then there was the Netscape monopoly as it defined the standard by its very implementation.
[20:54:23] <pjb> Yes. :-/
[20:54:49] <contrapunctus> gilberth: enough for 'what' is the question. I'm not looking to replace Linux for every user out there.
[20:55:10] <contrapunctus> And I can switch back to Tor Browser/Firefox if necessary, which probably always will be.
[20:55:35] <MichaelRaskin> Actually, limiting the features to 90's could be in question, but then the amount of garbage in protocols/file formats/device drivers to get the _same_ features is horrifying now
[20:55:40] <contrapunctus> But a little malleable digital haven of one's own...
[20:56:13] <gilberth> pjb: I considered that. I even have a C to CL compiler. I once had a plan to first compile Emacs to CL, then use CL instead of elisp (or rather compile elisp to CL), and then gradually port the C parts to CL. This way it ought to be possible to have a working system, even when not fully done.
[20:57:47] <gilberth> MichaelRaskin: Well, I could only repeat myself, run a Lisp OS headless, telnet into it, or use X11 with CLIM, if you wish.
[20:59:20] <MichaelRaskin> I mean, I do manage a ton of system stuff with Common Lisp code. But then I found out that for me many things are simply more ergonomic via Bash than via Common Lisp REPL
[21:00:01] <gilberth> MichaelRaskin: I actually do sth like this with my Linux box, which is headless. I run Emacs locally on a Mac, but the Lisp then on said Linux. This would work well with a Lisp OS, that just has TCP/IP and knows how to access a disk. Even the latter could be optional, the file system could sit on an NFS server.
[21:00:28] *** Joins: selwyn_ (~selwyn@user/selwyn)
[21:00:54] <MichaelRaskin> Well, it needs to talk to a network card, which is less of a mess than a GPU, but still is a complicated beast nowadays
[21:00:56] <gilberth> Hence, would I start such a project, I would concentrate on one device driver: The network interface.
[21:01:52] <MichaelRaskin> Then you could limit yourself to a specific card, preferably one where the chip seller releases at least some code in C that happens to work with it
[21:02:05] *** Quits: selwyn_ (~selwyn@user/selwyn) (Client Quit)
[21:02:10] <gilberth> MichaelRaskin: Linux survived in early days with a limited set of supported network cards.
[21:02:11] *** Quits: Posterdati (~posterdat@host-82-49-184-109.retail.telecomitalia.it) (Ping timeout: 245 seconds)
[21:03:09] <MichaelRaskin> On the other hand, those were days when swapping a network card was practical on most systems in use
[21:03:28] <gilberth> You could still do that.
[21:03:29] <MichaelRaskin> Hm, not sure if network card driver is simpler in PCI or in USB case
[21:03:43] <gilberth> USB is an utter mess.
[21:03:57] <MichaelRaskin> What isn't nowadays‚Ä¶
[21:04:19] <gilberth> PCI is just a bus. No surprises there.
[21:05:10] <gilberth> MichaelRaskin: But, yes, it was somewhat easier in the early 90s. The mess was already there, but smaller.
[21:06:37] <gilberth> I mean, look at the early, early 30k LoC Linux. An ATA hard disk was an ATA hard disk. Linux even got away with using PIO for a long time. That's really trivial.
[21:07:27] <gilberth> You write a read or write command on some well known I/O port, wait for an interrupt and read the block from some other well known I/O port. Dead easy.
[21:07:54] <gilberth> In fact I plan an IDE interface for my TTL CPU.
[21:08:26] <gilberth> It's just an ISA bus essentially.
[21:10:27] <gilberth> Anyhow, talking about networking, I have no idea how complicated a TCP/IP stack would be.
[21:16:15] *** Joins: Posterdati (~posterdat@host-95-233-159-95.retail.telecomitalia.it)
[21:18:14] *** Quits: hendursa1 (~weechat@user/hendursaga) (Quit: hendursa1)
[21:18:28] <contrapunctus> gilberth: why headless?
[21:18:33] *** Joins: lisp123 (~lisp123@5.30.23.247)
[21:18:58] *** Joins: hendursaga (~weechat@user/hendursaga)
[21:20:19] <gilberth> contrapunctus: Why an extra display, keyboard and mouse for a very slow and limited GUI? I have very limited desk space here.
[21:21:56] <gilberth> And what for? Should I jump around all the time? Switching consoles when browsing the web to hacking and back? Inconvenient.
[21:23:15] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Remote host closed the connection)
[21:23:25] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 260 seconds)
[21:23:49] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[21:31:34] *** Joins: clothespin (~awolven@c-73-209-95-92.hsd1.il.comcast.net)
[21:31:44] <clothespin> good morning
[21:31:59] <clothespin> i need someone to lament to about c++ templates
[21:32:22] <dra> clothespin: Go ahead and lament.
[21:32:28] <gilberth> Hello clothespin!
[21:32:32] <clothespin> wtf
[21:32:44] <contrapunctus> clothespin: 'wtf'?
[21:32:52] <clothespin> c++ templates
[21:32:57] <dra> clothespin: Yes, that's how to describe C++ templates.
[21:33:21] <clothespin> i'm feeling better
[21:33:26] <dra> :D
[21:33:33] <gilberth> Already? That was quick.
[21:33:53] <clothespin> no i'm sure i have more, just don't want to flood the channel
[21:34:25] <gilberth> Well for one part C++ templates are needed because C++ has no dynamic typing.
[21:34:30] <clothespin> i beleive in self documenting code
[21:34:46] <contrapunctus> gilberth: oh...I sort of get what you mean.
[21:35:33] <contrapunctus> ¬´ i beleive in self documenting code ¬ª _readies the pitchforks_
[21:35:41] <contrapunctus> üòè
[21:36:26] <clothespin> i'm not like erik naggum or anything
[21:37:08] <contrapunctus> Me neither...me neither üòî
[21:37:16] <clothespin> adding templates to code seems to be as natural to some c++ programmers as indentation is to lisp programmers
[21:37:54] <clothespin> beatify it but add nothing
[21:38:12] *** Quits: hendursaga (~weechat@user/hendursaga) (Remote host closed the connection)
[21:38:49] *** Joins: hendursaga (~weechat@user/hendursaga)
[21:38:52] <contrapunctus> gilberth: my project aims to be more like Emacs or Smalltalk. A graphical environment running as an application in other [FOSS] OSes.
[21:40:54] <contrapunctus> Hopefully making it trivial to switch to the 'outer world'...or, god forbid, even interoperate with it üòÑ
[21:40:59] <clothespin> i just can't even understand templates, besides trying to make waht would otherwise be dynamic dispatch compile time dispatch
[21:42:10] <gilberth> Hmm? Could see them as a macro sort of.
[21:46:52] <clothespin> i use macros here and there
[21:46:58] <clothespin> not everywhere
[21:48:02] <clothespin> they seems to be macrotizing definitions of types in a way that you normally would use dynamic dispatch and multiple inheritance for
[21:48:35] <gilberth> Yep. And the code of a template gets duplicated.
[21:49:23] <clothespin> what about the algorithm?  a program should be read by people as well as preprocessors
[21:51:01] <dra> clothespin: You mean C/C++ macros?
[21:51:11] <clothespin> no, templates
[21:51:34] <dra> clothespin: What kind of macros do you "use here and there"?
[21:51:42] <clothespin> lisp macros
[21:52:52] <dra> Ah.
[21:53:27] <clothespin> C++ templates are a natural block from understanding the algorithm of the program
[21:54:39] <clothespin> you have to be a special kind of person to see why c++ templates are awesome
[21:54:46] <gilberth> Well, oversimplified sth like template<class T> struct list { T item; struct list<T> *link; }; is like #define list(T) struct list_##T { T item; struct list_##T *link; }; Only that later when you say e.g. template<T> T item (list<T> *p) { return p->item; } the T for that is inferred from the concrete use.
[21:56:52] <clothespin> that's completely unnecessary in lisp
[21:57:14] <clothespin> lists access can return objects of any type
[21:57:57] <clothespin> and on a lisp machine ...
[21:59:30] <clothespin> and you can use mixins to add features to objects
[22:00:03] <gilberth> Yes, I said that already.
[22:00:15] <dra> Well, you can use templates to avoid dynamic dispatch at the expense of (mostly) duplicate object code. And dynamic dispatch is "slow" because it "pollutes the icache."
[22:00:52] <clothespin> has anyone understood what lisp machine chips do?
[22:01:05] <gilberth> Sort of, yes.
[22:01:29] <clothespin> they make dynamic dispatch almost a zero overhead process
[22:01:30] <gilberth> I am somewhat familiar with the CADR CPU.
[22:01:42] <gilberth> clothespin: Nope.
[22:02:42] <gilberth> It's zero overhead only from the perspective of the byte^Wmacro code. The microcode still has work to do.
[22:03:28] <clothespin> so lets make the microcode do all the works and save precious human time
[22:04:01] <gilberth> The CADR really is a kind of RISC CPU with a few dozen k of RAM, running a byte code interpreter.
[22:04:05] <clothespin> what you loose by using templates is the anatomy of the algorithm
[22:04:41] <clothespin> unless you could invent an ide that hides the template layers
[22:04:46] <selwyn> i agree but not unique to templates
[22:05:24] <gilberth> Because the byte^Wmacro code is so slow, all kinds of routines are implemented in microcode. Not much different from say CLISP (although CLISP does way too much in microcode^WC).
[22:05:57] <gilberth> The design was not about speed, but about space.
[22:06:22] <clothespin> the lisp machine design in general?
[22:07:19] <gilberth> Yes. See https://tumbleweed.nu/r/lm-3/uv/paper.html
[22:07:48] <gilberth> They wanted to escape the time-shared 18-bit address space confinements of the PDP-10.
[22:08:16] <clothespin> and it also just so happens that this space saving design make it possible to read the algorithm clearly and make it right before you make it fast
[22:08:26] <gilberth> It's only Symbolics, which later added some actual HW support for tagging. The CADR handled tagging in microcode, not in HW.
[22:10:21] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[22:10:26] <clothespin> well lets implement a tag monster arm chip so lisp programmers cannot stop watching c++ beat themselves
[22:10:48] <gilberth> For a latter design, once I build my initial TTL cpu, I contemplate to add tagging support for the ALU, it would check for fixnums and overflow and should call into a generic ALU routine fast to handle bignums in SW.
[22:10:52] *** Joins: hendursaga (~weechat@user/hendursaga)
[22:11:57] <clothespin> as long as the fixnum bignum threshold is higher than it is for conventional lisps
[22:12:24] <gilberth> Higher?
[22:12:27] <clothespin> i would like a full 64bit fixnum
[22:13:05] <clothespin> so i can transfer over the ffi without conversion
[22:13:51] <clothespin> these C++ templates have been making my head and my eyes hurt
[22:14:49] <gilberth> That would imply >64 word width. You never win that, because given the byte-oriented designs of today, you want a word size, which is a power of two. Go 128-bit and you have 64-bit fixnums, but not those 128-bit fixnums, you want then. I mean in the area of 32-bit words, you wanted 32-bit because 'int' was 32-bit. Now you have those 32-bit fixnums and want 64-bit fixnums, because everybody else has 64-bit words now.
[22:15:06] <gilberth> Otherwise this 32-bit or 64-bit are arbitrary.
[22:15:59] <gilberth> clothespin: Exactly. It's the FFI to an untagged world.
[22:17:59] <gilberth> But the more fundamental issue is that we moved to those byte addresses, the PDP-11 had. Most prior designs were using word addresses. It's this byte addresses, which gave us C. On the PDP-7 K&R were happy with B and 'char' was a function to extract a 6-bit character from a vector of 18-bit words.
[22:18:28] <gilberth> My poor TTL design is word oriented though.
[22:19:14] <clothespin> so we've regressed
[22:19:16] <gilberth> And for FFI you want either 33-bit or 65-bit fixnums really. To cope with both 'int' and 'unsigned'.
[22:21:21] <gilberth> clothespin: Of course we regressed. B was derived from BCPL, which was an oversimplified variant of CPL, which was a proper language with types, garbage collection and all you would expect from a modern language. The rationale was: It should be trivial to compile and the programmer knows exactly was he is doing.
[22:22:41] <gilberth> For my TTL design, I implemented PLZ, which is like B, but with s-expr syntax and hence macros in CL. The compiler is trivial, and there are no data types. Everything is a word, either used as an integer, or an address.
[22:23:03] <gilberth> This is, like C, very short above an assembler.
[22:23:42] *** Joins: Qwnavery (~Qwnavery@user/qwnavery)
[22:24:15] <clothespin> so there is really no good reason for c++ templates in an ideal world
[22:24:40] <gilberth> I could only agree with that.
[22:25:58] <gilberth> The CADR is an inspiration for me, because although primitive by todays standards, it boots a whole environment with very little code.
[22:26:41] <gilberth> And you must consider the time, machines were realy, realy slow and tiny at that time compared to what we have today.
[22:27:51] <gilberth> And there still was experimentation with how to do a window system. For instance the CADR cannot output to a window, which is not completely visible.
[22:30:45] <gilberth> Windows rely on a save array to stash the contents, when "burried" that is made not fully visible. The window system lacks the ability to then draw to both that save array and to the screen with proper clipping. It's a whole overly complicated protocol around this, to notify users that a window wants to output, but cannot, etc.
[22:33:53] <gilberth> Some of those limitations spilled over to CLIM, if you read the spec by the letter, which I do not, but McCLIM likes to do. You do things differently these days.
[22:34:34] <selwyn> considering mcclim as a plotting backend
[22:35:01] <gilberth> What do you want to plot?
[22:35:07] <selwyn> otoh it might not be necessary and present more baggage to deal with
[22:35:36] <selwyn> gilberth: i want to port ggplot2 to common lisp https://ggplot2.tidyverse.org/
[22:36:03] <selwyn> it is a declarative plotting library
[22:36:30] <selwyn> idea would be to have switchable backends
[22:37:01] <selwyn> at a minimum: 1) vector (pdf) 2) bitmap (png) 3) an interactive plot, zoomable etc.
[22:37:35] <gilberth> Oh dear. I cannot hack everything at once. CLIM^WSilica should be enough. Do you need more than X11, Cocoa, Cairo, PDF, or SVG?
[22:38:08] <selwyn> not for now?
[22:39:29] <gilberth> This is why my secret plan is to promote Silica, when I am done. It's silly that we need to adopt new APIs, just because you want to generate, say, a PNG. The CLIM graphics API should be suffice and already is more powerful than everything else, although not having the common PS model.
[22:40:12] <selwyn> perhaps i ought to check out the clim graphics api then
[22:41:31] <gilberth> It's pretty easy to use. You could start with CLIM:MAKE-WINDOW-STREAM, no need to have a full application frame and command loop to experiment with it.
[22:42:44] <gilberth> Or use the Listener of McCLIM. And say e.g. (WITH-ROOM-FOR-GRAPHICS (*STANDARD-OUTPUT*) (DRAW-LINE *STANDARD-OUTPUT* 100 100 300 200 :INK +RED+)))
[22:43:58] <gilberth> Note to myself: I little set of examples like on the Cairo page for CLIM would be nice.
[22:44:01] <selwyn> am i right in understanding that mcclim can already output pdf and pngs?
[22:45:14] <gilberth> I don't know. It could do PostScript, which is partly mine. And it could do Cairo, which is mine. No idea of somebody used Cairo for either PNG or PDF (which would be poor then), or implemented it otherwise.
[22:45:29] * gilberth may not read McCLIM source code.
[22:45:34] *** Joins: lad (~lad@user/lad)
[22:45:34] <Qwnavery> mornin'
[22:45:53] <gilberth> Qwnavery: Hi over there!
[22:46:57] <Qwnavery> Been up for a bout 45 minutes, going to finish this essay I'm reading then smash out some code on climacs
[22:47:21] <gilberth> Sounds like plan.
[22:48:14] <gilberth> selwyn: I suggest you start with CLIM's graphics API, it's really nice to work with. But I am biased.
[22:48:29] <selwyn> thanks for the advice
[22:48:44] <selwyn> what's poor about cairo?
[22:49:34] <gilberth> The PDF Cairo generates is not particular good. It's fine for usual things, but get's huge when using general designs.
[22:49:43] <selwyn> hm ok
[22:49:55] <selwyn> gnuplot has so many backends
[22:51:24] <gilberth> Yep, what of those backends do you really need? SVG for online, PDF for TeX, you window system for interaction. What's missing? HPGL for your DIN A2 pen plotter perhaps?
[22:51:30] <selwyn> as i say
[22:52:00] <selwyn> minimum would be pdf, png, interactive, let's add svg as well
[22:52:41] <selwyn> would be great if you could ffi into gnuplot
[22:52:57] <gilberth> SVG would be really nice for online. For PNG you could get away with ghostscript, if McCLIM can't do that. Which I really don't know.
[22:56:40] <selwyn> am aiming it more towards scientific plotting/data visualisation
[22:56:58] <selwyn> but online can certainly be included within that
[22:57:17] <selwyn> as i've mentioned i hate piping out to gnuplot
[22:57:27] <selwyn> hopefully one day others won't have to share my pain
[22:58:12] <gilberth> That would be terrific!
[22:58:26] <selwyn> would have to read the literature on 'declarative grammar of graphics'
[22:59:31] <selwyn> before starting to design the system
[22:59:45] <selwyn> it would be a fun way of exploring clim
[23:33:53] <gilberth> Hmm, what does #lispcafe think? Should I go with <super>+<meta> to ungrab the mouse, or with just <esc>?
[23:34:16] <White_Flame> <super><cali><fragilistic><expi><ali><docious>
[23:34:51] *** Quits: lad (~lad@user/lad) (Remote host closed the connection)
[23:35:50] <gilberth> It is, also given that keymaps vary and default keymaps are often pretty screwed in that regard, like mapping both Alt and Meta to one modifier bit. But this is what most virtual PCs do.
[23:38:57] <ck_> or maybe banana fana fo fana and so on
[23:39:57] <White_Flame> hold on, fetching a USB adapter for my bananaphone
[23:40:21] <kakuhen> no mouse
[23:40:25] <gilberth> At times I wonder, are there really so few Emacs users out there, as it is a challange to get a working meta key.
[23:40:40] <kakuhen> M-x position-pointer then input a pair of two integers
[23:41:07] <kakuhen> then bind this to something like M-x C-p i
[23:41:56] <gilberth> kakuhen: This doesn't help me.
[23:42:00] <ck_> why is the flame white?
[23:42:15] <White_Flame> to get to the other side
[23:42:19] <kakuhen> gilberth: for a serious answer, escape is the simplest option, assuming it doesnt have other binds in other contexts
[23:42:32] <gilberth> And, I asked that already, is there still confusion about the backspace key being either the BackSpace or the Delete keysym?
[23:42:45] <kakuhen> or for now you can copy what qemu/vbox do, like super+L or C-M-g
[23:43:26] <gilberth> kakuhen: ESC would be ALT-MODE in to the CADR and it doesn't use it.
[23:44:05] <ck_> yes, and ck is actually an ode to consensus, you have to "see 'k'"
[23:44:53] <gilberth> kakuhen: Hugh? Last time I used qemu, it was super+meta. And when I could reliable tell c-m-g, I could also super+meta.
[23:45:38] <gilberth> ESC also is a common key these days to get out of full screen. So I'd go with ESC, I guess.
[23:46:04] <gilberth> Nothing is more frustating as an application that grabs the mouse and you can't get out of it.
[23:46:30] <gilberth> Happened to me with some VM and a misconfigured modmap.
[23:46:38] <kakuhen> https://litter.catbox.moe/sb19ve.png
[23:46:46] <kakuhen> i get the same keybind on fedora, too
[23:47:17] <gilberth> Hmm.
[23:47:23] * gilberth checks his qemu.
[23:50:57] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[23:52:33] <gilberth> Well, mine says "press Ctrl+Alt" and I have no Alt, I have a meta and super key, but no alt. Doomed, can't get out.
[23:53:52] <gilberth> I could have been more clever by looking at the modmap.
[23:54:15] <gilberth> So ctrl + alt + g won't work either.
[23:54:22] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 252 seconds)
[23:56:02] <gilberth> I would at least be clever enough to take whatever modifier is actually there. I plan to do that with the emulated <meta> key anyway. There is no meta configured, but there is an alt? Use that instead.
[23:56:32] <gilberth> Hence, ESC it is. Thanks, #lispcafe!
[23:59:06] <selwyn> already i am getting the impression that clim is very different
[23:59:26] <gilberth> Different from what?
[23:59:34] <selwyn> anything i saw before in graphics
[23:59:39] <gilberth> From PostScript?
