[00:33:06] *** Quits: Torr (~Torr@user/torr) (Quit: leaving)
[00:38:35] *** __jmcantrell__ is now known as jmcantrell
[00:49:21] *** Joins: xall (~xall@2600:8800:8c02:3600:e49d:4310:a3ee:6ade)
[01:08:07] <xall> I'm trying to filter out lines where the last column is duplicated; sample output https://dpaste.org/GEGw#. It's shell history output from a program called histdb.
[01:08:15] <xall> I'm aware of `sort | uniq` but I'd like to preserve the order (I want to see the most recent history first). I'm also aware of `sort --key`, but the first column output changes from date to current time for the current day, so that ruins the sort.
[01:08:20] <xall> Is there another way to do this using a simple shell pipeline?
[01:18:31] *** Joins: lgc (~lgc@user/lgc)
[01:19:34] <xall> looks like `histdb --sep 999 | awk -F'999' '!seen[$4]++' | awk -F'999' '{print $4}'` is working
[01:20:42] *** Quits: emanuele6 (~emanuele6@user/emanuele6) (Ping timeout: 255 seconds)
[01:28:18] <gnomon> xall, are you aware of the HISTTIMEFORMAT bash variable?
[01:29:55] <gnomon> Hmm, although maybe histdb doesn't honor it - I'm not familiar with that tool.
[01:30:09] <Nintendo> You might like "sort -s", xall.
[01:30:13] <xall> gnomon: hmm, no. i just grepped histdb and it doesn't show up so i'm not sure if it uses it
[01:30:53] <Nintendo> Also, you can always pipe a sort into another sort when you run into key limitations.
[01:31:59] <xall> i'm using zsh actually. the only reason i'm using this external history tool (uses sqlite to save hist) is because even though I set a large history amount, it kept getting deleted and I couldn't figure out why
[01:32:12] <xall> thanks
[01:32:19] <Nintendo> ... but maybe those aren't key limitations you describe.  It sounds like histdb uses two different time formats for its time field?  That could get annoying.
[01:32:52] <Nintendo> I recommend setting zsh's HISTFILE equivalent to something non-standard.
[01:33:40] <Nintendo> The standard HISTFILE location is soon overwritten by accident.
[01:33:45] *** Quits: donofrio (~donofrio@c-68-40-123-74.hsd1.mi.comcast.net) (Ping timeout: 255 seconds)
[01:35:59] *** Joins: emanuele6 (~emanuele6@user/emanuele6)
[01:36:50] <Nintendo> Also, I am confused as to why the command you shared is "working".  What does the sandwiched awk command accomplish?
[01:40:04] *** Quits: Jad (~Nashmi@user/jad) (Quit: Benefits I derive from freeÂ­dom are largely the result of the uses of freedom by others, and mostly of those uses of freedom that I could never avail myself of.)
[01:51:39] <xall> Nintendo: it removes duplicate cmds
[01:52:07] <xall> without changing the order
[02:15:36] *** Quits: emanuele6 (~emanuele6@user/emanuele6) (Ping timeout: 255 seconds)
[02:20:27] <zenema> xall: If I've understood your problem correctly, something like this should do what you want, given the correct record separator:
[02:20:30] <zenema> awk '{ if(NF >= 1 && ! ($NF == $(NF-1))) print }'
[02:21:55] <zenema> s/record/field/ :?
[02:27:41] *** Joins: donofrio (~donofrio@c-68-40-123-74.hsd1.mi.comcast.net)
[02:29:33] *** Quits: jmcantrell (~weechat@user/jmcantrell) (Ping timeout: 255 seconds)
[02:34:22] <Nintendo> xall, but why is it a separate command?  You could easily combine it with the other awk command.
[02:34:50] <Nintendo> Either way, zenema might have a good idea.
[02:34:56] <xall> why did I use 2 awks there? because I don't know awk
[02:35:01] <Nintendo> Ahh, hehe.
[02:35:11] <Nintendo> You came to the right place, then.
[02:35:56] <xall> how do I write that as one? I tried a few times and gave up
[02:36:43] <Nintendo> Something like '{ if (!seen[$4]++) { print } }' maybe.
[02:37:13] <Nintendo> Or "print $4" in your case.
[02:37:53] <xall> yeah, that works. thanks
[02:38:20] <xall> is there a meaningful difference in zenema's solution? 
[02:38:22] <Nintendo> I think even "seen[$4]++ { print $4 }" might work.
[02:39:01] <Nintendo> It looks to solve a different problem.
[02:39:57] <Nintendo> With zenema's solution, you would basically print every line in which the last two fields are equal.
[02:40:36] <xall> "seen[$4]++ { print $4 }" doesn't seem to work. i'll just go with the if
[02:41:03] <zenema> Actually, I may have missed the point, did you mean something more like this?
[02:41:06] <zenema> awk '{ if( ! (last == $NF)) { print ; last = $NF } }'
[02:41:08] <Nintendo> Thanks for the info.
[02:41:21] <earnestly> zenema: You mean, uniq?
[02:41:40] <earnestly> Heh, almost
[02:42:41] <zenema> earnestly: Well, only on the last field. Will uniq do that?
[02:43:06] <Nintendo> In this case, you might get away with "uniq -f".
[02:44:00] <earnestly> It's amusing to me how close so many awk scripts get to the old unix tools, but sometimes one just needs a little tweak that the tool doesn't expose
[02:45:06] <earnestly> Unfortunately uniq -f has no way to express 'last', so you'll need to know the "NF" according to: [[:blank:]]*[^[:blank:]]*
[02:46:10] <zenema> Yup, seems uniq is just short of what's required.
[02:49:17] *** Quits: lgc (~lgc@user/lgc) (Quit: WeeChat 3.2-dev)
[02:49:53] <xall> i'm trying to tell which is correct
[02:49:57] *** Quits: lavaball (~Melissa@31.204.155.215) (Remote host closed the connection)
[02:52:05] <earnestly> xall: uniq only considers duplicates that appear directly after the other.  The !seen example will remove all duplicates regardless of their position, and unlike sort -u, it doesn't sort the input
[02:52:15] <xall> zenema's had a bunch of blank lines for some reason
[02:52:42] <earnestly> Yeah it's not very good, but the idea is there
[02:54:10] <earnestly> xall: last != $NF {last = $NF; print}
[02:54:23] <earnestly> xall: This works like `uniq' except it only checks the last field
[02:55:17] <earnestly> xall: !seen[$NF]++ # this works like sort -u, except it's streaming and doesn't sort the input.
[02:55:36] <earnestly> (And only checks the last field)
[02:57:27] *** Joins: Torr (~Torr@user/torr)
[02:58:28] <earnestly> (seen is quite nice because it streams.  sort -u has to read all input before it can print the results, and it changes the order of inputs (if that matters))
[03:01:41] <xall> thanks
[03:02:33] <zenema> Ah yes, I really should have written that more concisely!
[03:02:48] <xall> i'm using this to seed fzf for ctrl-r history search
[03:03:10] <xall> really, I should all of this by figuring out why my zsh history gets messed up
[03:03:15] <xall> *avoid
[03:05:03] <zenema> Never used zsh myself, I'm trying to kick my openbsd pdksh habit for sh :)
[03:08:59] * zenema shakes his fist at |&
[03:27:51] *** Joins: gstaniak (~gstaniak@162.249.116.2)
[03:31:51] <gstaniak> Hi, I'm trying to modify a field before comparison but I can't get it right -- the goal is to catch large ms time values in the last column, but it has DDms form. I tried: awk '$7 ~ /condition/ {sub("ms", "", $NF); if ($NF > 100) print $7 " " $NF}', but it doesn't work, ie. I get lines with $NF lower than 100 (ie. all lines filtered by the condition). Shouldn't the value of $NF be changed after the sub call?
[03:52:11] *** Joins: phillbush (~phillbush@user/phillbush)
[03:57:27] <earnestly> gstaniak: $7 ~ /condition/ && t > 100 {print $7, $NF+0} {t = $NF+0}
[03:59:08] <earnestly> (The patternless action here may need to go first here)
[04:01:35] <gstaniak> earnestly: thank you! so the fix is to convert types?
[04:01:48] <earnestly> weak typing indeed
[04:03:29] <earnestly> # printf 42ms\\n | awk '{t = substr($NF, 0, 2); print t}'
[04:03:31] <shbot> earnestly: 42
[04:03:39] <earnestly> gstaniak: This seems better though if you want to avoid it
[04:03:50] <earnestly> No regex here
[04:04:53] <gstaniak> earnestly: thanks again
[04:05:38] <earnestly> gstaniak: And in general remember that patterns can have conditions in them too
[04:06:26] <earnestly> I still think understanding the awk program: !seen[$0]++ would be a good exercise because if you grok this, the rest of awk becomes quite clear
[04:07:21] <gstaniak> earnestly: looks like an awk koan :) I will try to meditate on it a bit
[04:24:42] *** Quits: gstaniak (~gstaniak@162.249.116.2) (Ping timeout: 245 seconds)
[04:33:05] *** Joins: gstaniak (~gstaniak@162.249.116.2)
[04:37:32] *** Joins: downunder (~downunder@110.151.19.142)
[04:40:38] *** Quits: gstaniak (~gstaniak@162.249.116.2) (Quit: Leaving)
[04:57:17] *** Joins: jmcantrell (~weechat@user/jmcantrell)
[05:00:20] *** Joins: nate1 (~nate@108-233-125-227.lightspeed.sntcca.sbcglobal.net)
[05:05:18] *** Quits: nate1 (~nate@108-233-125-227.lightspeed.sntcca.sbcglobal.net) (Ping timeout: 265 seconds)
[05:07:41] *** Quits: Torr (~Torr@user/torr) (Quit: leaving)
[05:29:44] *** Quits: phillbush (~phillbush@user/phillbush) (Remote host closed the connection)
[05:30:26] *** Quits: vlm (~vlm@user/vlm) (Quit: "")
[05:34:19] *** Joins: vlm (~vlm@user/vlm)
[05:53:38] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[05:57:01] *** Quits: jmcantrell (~weechat@user/jmcantrell) (Ping timeout: 265 seconds)
[06:45:43] <ttmrichter> earnestly: "seen"?
[06:46:52] <ttmrichter> Oh, just an arbitrary array name.  Never mind.
[06:52:09] *** __jmcantrell__ is now known as jmcantrell
[06:54:39] <Nintendo> It's a poem.
[07:28:56] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[07:31:57] *** Quits: jmcantrell (~weechat@user/jmcantrell) (Ping timeout: 255 seconds)
[07:35:32] *** __jmcantrell__ is now known as jmcantrell
[07:36:20] *** Quits: earnestly (~earnest@user/earnestly) (Ping timeout: 252 seconds)
[07:37:42] <yeti> !!!
[07:37:52] <nmz> its uhh an exercise in PEMDAS
[07:41:18] <yeti> # printf 42ms\\n | awk '{print 0+$0}'
[07:41:20] <shbot> yeti: 42
[07:41:57] <yeti> that surprised me...   or still does...  ...a bit...
[07:48:53] *** Joins: jetchisel (jetchisel@user/jetchisel)
[07:52:24] *** Quits: xall (~xall@2600:8800:8c02:3600:e49d:4310:a3ee:6ade) (Quit: Client closed)
[08:00:13] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[08:03:21] *** Quits: jmcantrell (~weechat@user/jmcantrell) (Ping timeout: 258 seconds)
[08:42:00] *** Joins: lgc (~lgc@user/lgc)
[09:10:00] *** Joins: be1m0nt (~be1m0nt@c-24-18-228-40.hsd1.wa.comcast.net)
[09:15:23] *** Quits: roarde (~roarde@user/roarde) (Quit: Leaving)
[09:15:55] *** Quits: be1m0nt (~be1m0nt@c-24-18-228-40.hsd1.wa.comcast.net) (Quit: leaving)
[09:34:02] *** Quits: __jmcantrell__ (~weechat@user/jmcantrell) (Ping timeout: 265 seconds)
[09:55:43] <Patsie> interesting indeed
[09:55:47] <Patsie> # printf "%s\n" 12str 12str34 str12 | mawk '{ print 0+$1 }'
[09:55:49] <shbot> Patsie: 12
[09:55:49] <shbot> Patsie: 12
[09:55:49] <shbot> Patsie: 0
[09:56:30] <Patsie> so awk just takes any digits before a non-digit string and considers that a number
[09:57:37] <Patsie> a new thing learned today, thanks yeti :)
[10:01:11] <yeti> lik sscanf stopping at the 1st ninbdigit
[10:01:40] <yeti> maybe that is even the explanation?  i didnt dig into sources
[10:32:39] *** Quits: Nintendo (~weechat@user/great) (Quit: Game over.)
[11:54:16] *** Joins: earnestly (~earnest@user/earnestly)
[12:42:25] *** Joins: lavaball (felix@31.204.155.215)
[12:57:36] <zenema> I've still not found a reason why the final "{}" might be needed in this more portable awk shebang:
[12:57:39] <zenema> #!/bin/sh
[12:57:41] <zenema> "exec" "awk" "-f" "$0" "$@" && 0 {}
[12:59:55] *** Quits: lavaball (felix@31.204.155.215) (Remote host closed the connection)
[13:00:48] *** Joins: lavaball (felix@31.204.155.215)
[13:17:48] <earnestly> Absurdism
[13:18:51] <earnestly> The entire thing is ridiculous even regarding its value.  "more portable", lol
[13:22:45] <zenema> earnestly: Oh! I see it as more portable than a path to an awk binary, and the unknowns of how env may handle positional parameters.
[13:22:58] <earnestly> Yes, don't dot hat
[13:23:06] <zenema> What are the problems with it?
[13:23:20] <earnestly> It relies on $0 for one, it's not necessary to make the world worse
[13:23:30] <earnestly> And I have no idea why each string is quoted
[13:24:56] <zenema> I figured that was so awk will only interpret them as strings, and then negate the truthiness of them with the && 0 to prevent the default print action.
[13:26:27] <earnestly> Yes, you have to consider how the program you exec will interpret that particular line
[13:26:59] <earnestly> But just don't do it
[13:29:44] <zenema> Is there anything I could use as an alternative that would improve the portability?
[13:30:59] <zenema> Is relying on $0 so bad, when it's just passing the name of the sh script to awk as the script name?
[13:33:21] <earnestly> No, use a normal shebang line
[13:33:35] <zenema> (I would just use env, but that's a no go with how different platform's envs handle the parameters).
[13:33:38] <earnestly> No
[13:33:42] <earnestly> Use a normal shebang line
[13:34:04] <earnestly> And in general you should never rely on the location of a script
[13:34:15] <earnestly> (Not least because it's possible that a script has no location)
[13:35:08] <earnestly> Just stop trying to be clever, do what it is expected, and if people roll derangeOS they can /much/ more easily adapt a well formed script to their needs
[13:35:39] <earnestly> zenema: See https://cr.yp.to/slashpackage/finding.html at the end
[13:36:11] <earnestly> Everything would be much better if people gave on this quixotic quest to be "beyond portable"
[13:36:16] <earnestly> gave up*
[13:36:22] <earnestly> See also autotools
[13:38:18] <earnestly> So write to the standards if you want to be portable, then let site admins/users deal with mapping them to their quirky systems if need be.  Trying to subvert users with trickery is just going to lead to hours of debugging fun
[13:43:38] <zenema> This is fair comment! Using this does feel a little like trying to hold onto a handful of sand.
[13:43:50] <zenema> earnestly: Thanks for the sensible slap :)
[14:45:15] *** Quits: downunder (~downunder@110.151.19.142) (Quit: WeeChat 3.2)
[14:51:20] <madprops> a|~|b|~|c|~|d|~|e
[14:51:32] <madprops> split($0, a, "|~|")
[14:51:55] <madprops> why is a[1]   "a|"   and not  just "a"   ?
[14:53:24] <izabera> split splits on a regex
[14:53:47] <Patsie> like izabera said, the separator is a regex
[14:54:04] <Patsie> https://www.gnu.org/software/gawk/manual/html_node/String-Functions.html#index-patsplit_0028_0029-function-_0028gawk_0029
[14:54:20] <madprops> oh I see
[14:54:24] <Patsie> The string value of the third argument, fieldsep, is a regexp describing where to split string (much as FS can be a regexp describing where to split input records).
[14:54:45] <izabera> tbh i just said it because i wanted to say "split splits"
[14:54:47] <madprops> is there a way to reuse a variable p="|~|" in the regex field?
[14:54:55] <izabera> madprops: escape it
[14:56:45] <Patsie> isabera: thplit thplithth  ? :P
[14:57:11] <madprops> like "/$p/" ?
[14:57:13] <izabera> thplitth
[14:57:45] <izabera> madprops: no, like     p = "[|]~[|]"; split($0, a, p)
[14:57:59] <Patsie> madprops: no: p="\|~\|"
[14:58:03] <Patsie> or what she said
[14:58:15] * izabera accidentally invented a new emoji:    "[|]~[|]"
[14:58:32] <Patsie> a robot with vertical eyes?
[14:58:39] <izabera> vertical eyes == cat
[14:58:52] <izabera> i thought it was like a cat with glasses or something idk
[14:58:56] <madprops> why [|] ?
[14:59:10] <izabera> madprops: it's a way to escape |
[14:59:13] <izabera> works with most things
[14:59:19] <Patsie> because that means 'a character in the range of'
[14:59:42] <izabera> i don't like \ because you end up with a million \\\\\\\ at some point
[14:59:53] <Patsie> true, sometimes
[15:00:01] <Patsie> but that is the true 'escape'
[15:00:08] <earnestly> The revenge of the toothpick
[15:00:14] <Patsie> [] is not really escaping, although it works nicely
[15:00:54] <earnestly> "It introduces a context in which the normal meaning of | is ignored"
[15:01:59] <madprops> im reusing the p variable to print text later
[15:02:02] <madprops> so I go with \
[15:02:08] <madprops> but p="\|\~\|" '{split($0, a, p) does not work
[15:02:33] <Patsie> # echo "a|~|b|~|c|~|d|~|e" | awk '{ p="\\|~\\|"; split($0, a, p); print a[1]; }'
[15:02:35] <shbot> Patsie: a
[15:02:43] <Patsie> so yeah, double escape
[15:03:01] <Patsie> that's where izabera's frustration comes from
[15:03:36] <Patsie> # echo "a|~|b|~|c|~|d|~|e" | awk '{ p="[|]~[|]"; split($0, a, p); print a[1]; }'
[15:03:37] <shbot> Patsie: a
[15:03:47] <Patsie> same number of characters
[15:03:55] <Patsie> so I'll leave the choice up to you
[15:04:00] <madprops> # echo "a|~|b|~|c|~|d|~|e" | awk -v p="\\|~\\|" '{ split($0, a, p); print a[1]; }'
[15:04:01] <shbot> madprops: awk: illegal primary in regular expression |~| at ~|
[15:04:01] <shbot> madprops:  input record number 1, file 
[15:04:01] <shbot> madprops:  source line number 1
[15:04:03] <Patsie> just know what both options do and mean
[15:04:07] <madprops> # echo "a|~|b|~|c|~|d|~|e" | awk -v p="\\|~\\|"  '{ split($0, a, p); print a[1]; }'
[15:04:09] <shbot> madprops: awk: illegal primary in regular expression |~| at ~|
[15:04:09] <shbot> madprops:  input record number 1, file 
[15:04:09] <shbot> madprops:  source line number 1
[15:05:40] <Patsie> # echo "a|~|b|~|c|~|d|~|e" | awk -v p=$'\\\\|~\\\\|'  '{ split($0, a, p); print a[1]; }'
[15:05:40] <madprops> I was trying to do it with -v p="..."
[15:05:42] <shbot> Patsie: a
[15:05:49] <madprops> o_O
[15:05:49] <izabera> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
[15:05:58] <izabera> fix all problems by adding a dozen \
[15:06:14] <Patsie> ohw shaddap! :)
[15:06:39] <izabera> this also helps for your future job security when nobody else will ever want to touch your code
[15:06:53] <Patsie> not even you yourself
[15:07:13] <izabera> job security backfired immediately
[15:07:25] <Patsie> :\
[15:07:37] <madprops> # echo "a|~|b|~|c|~|d|~|e" | awk '{ p="\\|~\\|"; split($0, a, p); print a[1] p; }'
[15:07:39] <shbot> madprops: a\|~\|
[15:07:47] <madprops> how do I avoid escape on print?
[15:08:04] <izabera> you do it in perl
[15:08:34] <Patsie> just stick with izabera's damn [] sollution
[15:08:34] <madprops> i wanted to just use awk
[15:08:51] <madprops> does the solution print unescaped p's ?
[15:09:04] <madprops> the part in the right
[15:09:18] <Patsie> because there is a lack of how regex wrk from some end :P
[15:09:23] <Patsie> you don't
[15:09:28] <Patsie> that's what escaping is and does
[15:09:36] <madprops> the escape works for split
[15:09:38] <madprops> but not when printing
[15:09:43] <Patsie> it does
[15:09:51] <Patsie> but it doesn't do what _you_ think it does
[15:09:51] <madprops> or it does and it shouldn't
[15:10:11] <madprops> or it should but i don't wanna
[15:10:39] <madprops> maybe printf..
[15:10:53] <Patsie> split received the exact same pattern as printf \|~\|
[15:11:26] <izabera> fwiw you can use index() to match an exact string rather than a regex 
[15:12:07] <madprops> I'm doing this btw https://stackoverflow.com/questions/68406613/awk-command-to-print-columns-with-colum-data/68407009#68407009
[15:12:09] <madprops> just for practice
[15:13:00] <izabera> # echo "a|~|b|~|c|~|d|~|e" | awk -v p='|~|' '{ print substr($0, 1, index($0, p)) }'
[15:13:02] <shbot> izabera: a|
[15:13:09] <izabera> # echo "a|~|b|~|c|~|d|~|e" | awk -v p='|~|' '{ print substr($0, 1, index($0, p)-1) }'
[15:13:11] <shbot> izabera: a
[15:13:12] <izabera> yeah there
[15:13:15] <izabera> ez
[15:13:45] <madprops> I would need to do that for the 3 fields, that's too long
[15:13:59] <izabera> 1 sec
[15:14:22] <madprops> oh wait
[15:14:25] <madprops> you don't use split
[15:18:05] <madprops> my approach was just split and join with p
[15:18:13] <madprops> a[1], a[2], and a[3]
[15:20:01] <izabera> https://termbin.com/fmni  how's this?
[15:20:10] <earnestly> Can a, b, c, etc. contain |~|?
[15:22:41] <Patsie> # echo "a|~|b|~|c|~|d|~|e" | awk 'BEGIN { FS="\\|~\\|"; OFS="|~|" } { $1=$1; print $1,$2,$3 }'
[15:22:43] <shbot> Patsie: a|~|b|~|c
[15:22:54] <Patsie> # echo "a|~|b|~|c|~|d|~|e" | awk 'BEGIN { FS="\\|~\\|"; OFS="|~|" } { print $1,$2,$3 }'
[15:22:55] <shbot> Patsie: a|~|b|~|c
[15:24:01] <Patsie> or use izabera's glasses wearing cat eyes instead
[15:24:30] <madprops> izabera's solution is hard to understand
[15:24:39] <madprops> Patsie, I didn't think of OFS, that makes sense
[15:25:29] <madprops> wow not even a split is needed
[15:25:36] <madprops> since you use FS
[15:25:45] <Patsie> why need split, if you can let awk handle it natively?
[15:25:49] <madprops> yeah
[15:25:50] <Patsie> that's what awk does
[15:25:54] <Patsie> split into records and fields
[15:26:14] <izabera> how can you say such things about cats with poor eyesight
[15:26:49] <Patsie> maybe they should get a job and pay for laser surgery themselves
[15:26:55] <Patsie> lazy catbastards!
[15:27:13] <Patsie> it's a cat-eat-cat world ot there
[15:27:37] <Patsie> (we have two cats ourselves, no animals were harmed in the making of these statements)
[15:31:12] <madprops> do your cats beg for food too?
[15:31:35] <Patsie> they just sit passively at their food station and look at you judgingly
[15:31:49] <Patsie> human food, not so much
[15:32:09] <Patsie> only when we have breakfast and there is some sliced kip there
[15:32:18] <Patsie> chicken
[15:32:35] <madprops> mine either comes all the way to find me and demand food
[15:32:46] *** Quits: lgc (~lgc@user/lgc) (Quit: WeeChat 3.2-dev)
[15:32:47] <madprops> or stay silent
[15:32:59] <madprops> not sure which method is more effective
[15:37:11] <madprops> I see some other user had the same answer on stackoverflow
[15:37:22] <madprops> but he also took into account the whitespace in the input
[15:39:14] <Patsie> you haven't supplied any whatespace in your example
[15:39:18] <Patsie> whitespace*
[15:39:31] <madprops> yeah 
[15:39:40] <madprops> thought it was just a typo
[15:39:49] <Patsie> so it's hard to take into account what we don't know about
[15:42:52] <madprops> sub(/^[[:blank:]]+/,""
[15:44:34] <madprops> didn't know about the [:blank:] keyword
[15:44:41] <madprops> "Blank characters: space and tab."
[15:46:54] <Patsie> a day not learned is a day not lived
[16:30:47] *** Quits: donofrio (~donofrio@c-68-40-123-74.hsd1.mi.comcast.net) (Read error: Connection reset by peer)
[16:31:00] *** Joins: donofrio (~donofrio@c-68-40-123-74.hsd1.mi.comcast.net)
[16:40:35] *** Quits: TanoMarcelo (~TanoMarce@179.63.242.126) (Quit: WeeChat 3.1)
[17:28:09] *** Joins: euandreh (~euandreh@191.181.59.160)
[17:42:07] *** Joins: vlm_ (~vlm@user/vlm)
[17:43:23] *** Joins: eoli3n_ (~eoli3n@162.38.105.222)
[17:43:54] *** Joins: Bossi_ (~quassel@p4fc22308.dip0.t-ipconnect.de)
[17:44:00] *** Joins: lesihctej (jetchisel@user/jetchisel)
[17:44:42] *** Joins: AnimalCl1 (~AnimalCla@208.66.176.26)
[17:46:16] *** Quits: lesihctej (jetchisel@user/jetchisel) (Client Quit)
[17:47:35] *** Quits: donofrio (~donofrio@c-68-40-123-74.hsd1.mi.comcast.net) (Killed (osmium.libera.chat (Nickname regained by services)))
[17:48:48] *** Quits: jetchisel (jetchisel@user/jetchisel) (*.net *.split)
[17:48:48] *** Quits: vlm (~vlm@user/vlm) (*.net *.split)
[17:48:48] *** Quits: ccx (~ccx@82.142.125.46) (*.net *.split)
[17:48:49] *** Quits: madprops (~hj8oijo@user/madprops) (*.net *.split)
[17:48:49] *** Quits: eoli3n (~eoli3n@162.38.105.222) (*.net *.split)
[17:48:49] *** Quits: AnimalClatter (~AnimalCla@208.66.176.26) (*.net *.split)
[17:48:49] *** Quits: Bossi (~quassel@p4fc22308.dip0.t-ipconnect.de) (*.net *.split)
[17:48:49] *** Quits: Nahra (~user@static.161.95.99.88.clients.your-server.de) (*.net *.split)
[17:48:52] *** vlm_ is now known as vlm
[17:49:24] *** Joins: ccx_ (~ccx@82.142.125.46)
[18:20:38] *** Joins: Jad (~Nashmi@user/jad)
[18:20:51] *** Quits: Jad (~Nashmi@user/jad) (Remote host closed the connection)
[18:20:55] *** Joins: phillbush (~phillbush@user/phillbush)
[18:21:18] *** Joins: Jad (~Nashmi@user/jad)
[18:52:39] *** Quits: nomn (nomn@user/nomn) (Quit: WeeChat 3.2)
[18:57:37] *** Joins: phillbush_ (~phillbush@user/phillbush)
[19:04:09] *** Quits: phillbush (~phillbush@user/phillbush) (Ping timeout: 272 seconds)
[19:04:22] *** Quits: Jad (~Nashmi@user/jad) (Ping timeout: 265 seconds)
[19:15:05] *** Joins: vinipsmaker (~vinipsmak@2804:14c:f427:a9bc::1001)
[19:26:56] *** Quits: AnimalCl1 (~AnimalCla@208.66.176.26) (Ping timeout: 252 seconds)
[19:28:03] *** Quits: euandreh (~euandreh@191.181.59.160) (Quit: WeeChat 3.2)
[19:44:43] *** Joins: AnimalCl1 (~AnimalCla@208.66.176.26)
[19:52:17] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[20:26:09] *** Quits: __jmcantrell__ (~weechat@user/jmcantrell) (Ping timeout: 268 seconds)
[20:33:58] *** Joins: Torr (~Torr@user/torr)
[20:41:38] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[20:44:18] *** Quits: simpl_e (~user@user/simpl-e/x-8589812) (Read error: Connection reset by peer)
[20:45:31] *** Joins: simpl_e (~user@user/simpl-e/x-8589812)
[20:50:53] *** Quits: __jmcantrell__ (~weechat@user/jmcantrell) (Ping timeout: 255 seconds)
[21:04:16] *** Joins: xall (~xall@2600:8800:8c02:3600:e49d:4310:a3ee:6ade)
[21:36:01] *** Quits: phillbush_ (~phillbush@user/phillbush) (Quit: Leaving)
[21:36:19] *** Joins: phillbush (~phillbush@user/phillbush)
[22:07:37] *** Quits: simpl_e (~user@user/simpl-e/x-8589812) (Read error: Connection reset by peer)
[22:11:03] *** Joins: simpl_e (~user@user/simpl-e/x-8589812)
[22:11:03] *** Quits: simpl_e (~user@user/simpl-e/x-8589812) (Read error: Connection reset by peer)
[22:12:17] *** Joins: simpl_e (~user@user/simpl-e/x-8589812)
[22:14:35] *** Quits: simpl_e (~user@user/simpl-e/x-8589812) (Read error: Connection reset by peer)
[22:19:49] *** Joins: simpl_e (~user@user/simpl-e/x-8589812)
[22:31:09] *** Joins: Jad (~Nashmi@user/jad)
[22:33:31] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[22:46:42] *** Quits: shbot (~shbot@37.139.2.101) (Killed (NickServ (GHOST command used by shbot3)))
[22:46:42] *** Joins: shbot3 (~shbot@37.139.2.101)
[22:48:30] *** Quits: xall (~xall@2600:8800:8c02:3600:e49d:4310:a3ee:6ade) (Quit: Client closed)
[22:57:46] *** Joins: jmcantrell (~weechat@user/jmcantrell)
[23:00:44] *** Quits: __jmcantrell__ (~weechat@user/jmcantrell) (Ping timeout: 258 seconds)
[23:13:26] *** shbot3 is now known as shbot
[23:23:53] *** Quits: jmcantrell (~weechat@user/jmcantrell) (Ping timeout: 255 seconds)
[23:45:07] *** Joins: roarde (~roarde@user/roarde)
