[08:59:58] *** Quits: basshelal[m] (~basshelal@2001:470:69fc:105::30e7) (*.net *.split)
[08:59:58] *** Quits: MatrixTravelerbo (~voyagert2@2001:470:69fc:105::22) (*.net *.split)
[08:59:58] *** Quits: subbu (~subbu@user/subbu) (*.net *.split)
[09:00:05] *** Joins: subbu (~subbu@user/subbu)
[09:04:05] *** Joins: basshelal[m] (~basshelal@2001:470:69fc:105::30e7)
[09:11:38] *** Quits: mattpatt[m] (~mattpattm@2001:470:69fc:105::315d) (*.net *.split)
[09:11:38] *** Quits: MattPattersonGit (~gitterfid@2001:470:69fc:105::3105) (*.net *.split)
[09:11:38] *** Quits: TimGitter[m] (~gittertim@2001:470:69fc:105::314b) (*.net *.split)
[09:13:12] *** Joins: MatrixTravelerbo (~voyagert2@2001:470:69fc:105::22)
[09:13:17] *** Joins: mattpatt[m] (~mattpattm@2001:470:69fc:105::315d)
[09:15:21] *** Joins: TimGitter[m] (~gittertim@2001:470:69fc:105::314b)
[09:21:11] *** Joins: MattPattersonGit (~gitterfid@2001:470:69fc:105::3105)
[21:12:47] <headius> Good morning
[22:00:36] *** Joins: jswenson[m] (~jswensonm@2001:470:69fc:105::fd45)
[22:05:55] <jswenson[m]> üëã I know its a little late in the process already, but I‚Äôm playing with 9.3.0.0 (using the most recent commit on master) with Looker. I‚Äôve run into two issues so far. I‚Äôm currently trying to reproduce and file tickets for them. Just thought I‚Äôd give you a heads up. 
[22:06:23] <headius> Hey great, got something you can file yet?
[22:07:07] <headius> We fully expect issues after this long a development cycle but we know people tend not to try release candidates. The plan is just to get the .0 release out and then work on bug reports for a few weeks
[22:07:19] <jswenson[m]> First one is pretty simple, I haven‚Äôt reproduced it outside of the rest of our system, but I THINK I can file it -- second one I don‚Äôt understand yet. was able to work around it though and boot on 9.3.0.0
[22:17:37] <enebo[m]> jswenson: what was the nature of the first one?
[22:18:04] <jswenson[m]> filed: https://github.com/jruby/jruby/issues/6845
[22:20:04] <enebo[m]> hmm looks like we removed helper methods for class/module references
[22:20:36] <enebo[m]> In the past that was us doing a def CompanionObjectName; ...
[22:21:04] <headius> I guess we need to pull the trigger on getting some Kotlin tests into the repo
[22:21:16] <jswenson[m]> might be that it needs a @JvmStatic annotation on it or something
[22:21:35] <headius> jswenson: if you can provide a trivial example or repo it should be easy to investigate
[22:21:35] <jswenson[m]> so very possible that we‚Äôre doing something that just happened to work 
[22:21:47] <jswenson[m]> yeah will try to do that. 
[22:21:49] <headius> I do remember that annotation making it easier for us because the name becomes predictable perhaps?
[22:22:05] <headius> it has been a bit since I looked at the Kotlin enhancements
[22:22:50] <enebo[m]> personally the :: feels more right
[22:22:50] <jswenson[m]> oh I supposed that would have been on the method
[22:23:28] <enebo[m]> not that we should be breaking stuff (although we do consider this a major release but I don't recall this as an intentional change)
[22:24:15] <enebo[m]> kares: Any thoughts on #6845
[22:24:59] <enebo[m]> jswenson: we might put a fix into 9.3.1.0 and we expect a quick point release since no doubt we will get some other reports
[22:25:05] <enebo[m]> unless this was intentional :)
[22:25:51] <headius> we should get some kotlin into core/src/test and at least try basic integration examples from JUnit
[22:25:54] <enebo[m]> com.foo.Constant1.Constant2 I think was some convenience in JI but it is a bit weird from a Ruby syntax perspective
[22:27:00] <enebo[m]> I am trying to think of what core Java API has this need?  Iterator?
[22:27:30] <jswenson[m]> We‚Äôre spending a little time ‚Äúhacking‚Äù this week and i figured I‚Äôd play with what ya‚Äôll did in https://github.com/jruby/jruby/pull/6590 and try out 9.3 at the same time
[22:31:57] <jswenson[m]> the other one I‚Äôm not quite sure what is happening, but we‚Äôre doing some dynamic work and depending on how something is called seems to be yielding a different stacktrace when use use the `caller` method
[22:32:43] <jswenson[m]> there‚Äôs a fair bit to untangle that I‚Äôve never explored yet, so I‚Äôm not quite ready to file that one yet. 
[22:34:11] <jswenson[m]> looks like we‚Äôre trying to work around something that changed with what we were doing something in 9.1 that may have changed again. 
[22:34:16] <headius> hmm that sounds interesting
[22:34:34] <headius> using caller output to do dynamic code stuff?
[22:34:42] <jswenson[m]> Yeah
[22:34:58] <jswenson[m]> Its only used in dev 
[22:35:01] <jswenson[m]> or in build
[22:35:28] <jswenson[m]> we‚Äôre trying to reject certain frames of caller. 
[22:35:28] <headius> if you can identify the traces that are different I can probably figure it out... the stack trace management is mostly my stuff
[22:38:35] <enebo[m]> This weekend I was studying localopt pass a bit more and pondering how conservative it is: https://gist.github.com/enebo/ac3cfa7f9bfcdaa8d0d89f1651fc1e26
[22:39:17] <enebo[m]> binding of caller is something we don't support or do we?
[22:39:46] <enebo[m]> It has been such a long time I thought about that 
[22:40:50] <enebo[m]> whoops updated gist to include after
[22:42:13] <enebo[m]> This took a bit more work than I expected too..the ir pass scheduler only allows a pass to run once which is a flaw in the design.  Otherwise I had to change call to only be a barrier if call can be eval or has a literal closure attached
[22:43:23] <headius> binding of caller only works in interpreter mode because it requires deopting an arbitrary number of calls up the stack
[22:43:48] <headius> it's not possible for us to fully support without direct JVM stack access, and even then it would be really hard
[22:44:14] <enebo[m]> headius: yeah I knew why it wouldn't work for all cases I was unsure if we supported it at all
[22:44:44] <enebo[m]> but interp will work is the answer
[22:45:03] <headius> yeah
[22:45:10] <enebo[m]> So I am trying to nail down what other conditions we need to consider
[22:45:15] <enebo[m]> binding, eval, literal block
[22:45:34] <headius> so many line numbers
[22:45:55] <enebo[m]> for JIT it does not matter
[22:46:07] <headius> not really a concern in bytecode but I think it does increase bytecode size a little
[22:46:18] <enebo[m]> full interp it does but we need a cheap mechanism to cull them
[22:46:42] <enebo[m]> I thought we kept track and only emitted last one
[22:46:53] <enebo[m]> oh maybe not
[22:47:05] <headius> hah I tried to test at command line but of course it's all line 1 then
[22:47:09] <enebo[m]> We do it for IRBuild but that is because it is free
[22:47:37] <enebo[m]> Perhaps we can do it in LocalOpt with a little extra state.  I would hate to make a pass for that
[22:48:09] <headius>   L0... (full message at https://libera.ems.host/_matrix/media/r0/download/libera.chat/4724fd55198aa5f26966826905c3fec22a268ee3)
[22:48:21] <enebo[m]> yeah I just got to skinnymethodadapter
[22:48:43] <enebo[m]> note that today it is unlikely you will see this very much
[22:48:53] <headius> I collapse consecutive line numbers that are the same number but not sure how I would detect this
[22:49:02] <enebo[m]> with my changes to localopt pass it will become more likely
[22:49:13] <headius> yeah this is a similar case, a = 1, b = 2, c = a + b etc
[22:49:16] <enebo[m]> I believe I can track this during optimizing instrs
[22:49:20] <headius> stuff people don't do
[22:49:33] <enebo[m]> yeah that is part of the problem with my example
[22:49:35] <enebo[m]> no one does that
[22:49:43] <headius> jswenson: reject for reporting reasons?
[22:49:56] <headius> like rspec mining stack trace to only print the relevant part
[22:49:56] <enebo[m]> but I was annoyed to not see the literals propagate
[22:50:07] <headius> mmm
[22:50:38] <headius> this code boils down to load 1, load 2, add, load 3, add (there's a d = c + 3 I did not show)
[22:50:47] <headius> so literals are propagating but it is honoring override of + and friends
[22:51:10] <enebo[m]> it also killed the need for the copy which is something the JIT will kill off for us but I am liking the idea of running localopt multiple times
[22:52:27] <enebo[m]> anyways...if you think of other boundaries where a call can access the parent's local variables
[22:53:24] <enebo[m]> reducing bytecode was a part of this but also thinking about inlining will make running multiple localopt passes pay off
[22:56:31] <jswenson[m]> headius: it looks like that ‚Äúcleanup‚Äù is not actually doing anything in this case. I think we were removing frames with negative line numbers. But none of those exist in this stack. Instead it looks like there is a missing / additional frame in some cases. 
[23:01:17] * jswenson[m] sent a code block: https://libera.ems.host/_matrix/media/r0/download/libera.chat/2c119dfab9f2e12732ab2605207ce415e425c5a3
[23:03:59] <enebo[m]> original line 9 looks wrong right?
[23:04:17] <headius> I may know why this is
[23:04:31] <headius> I did a patch to improve how we show line numbers when there's an arity mismatch
[23:04:55] <headius> it's supposed to drop the outer frame if the inner one is reached but maybe I missed something
[23:05:11] <headius> enebo: this was because the varargs wrapper method we generated did not set any line numbers and was not mined by the stack trace generator
[23:05:22] <headius> so arity errors showed up as being in the caller, not the callee
[23:06:35] <jswenson[m]> yeah line 9 is ‚Äúunexpected‚Äù 
[23:06:47] * headius sent a code block: https://libera.ems.host/_matrix/media/r0/download/libera.chat/0ee7e65d95ea724ba6f9b12f04976953bc96f3bc
[23:06:52] <headius> that is what I fixed
[23:07:12] <headius> but the varargs frame will just use the line number of the method def because no code has actually run yet other than the arguments
[23:07:17] <headius> that's what this looks like, that frame is getting in there
[23:07:40] <headius> strong suspect
[23:08:51] <headius> https://github.com/jruby/jruby/pull/6771
[23:09:27] <jswenson[m]> headius: want me to file (at least) the above info? 
[23:09:34] <headius> yes
[23:10:20] <headius> https://github.com/jruby/jruby/pull/6771/commits/9b7afc5186e706c61b62521e0f66e99446442d54#diff-13d0be77817edcb3c08171f843430f522b2d681757bde35d625c7069b7b9946dR97-R105
[23:10:20] <headius> this is the relevant bit of that diff (lots of other signature changes to suppose managing the line number better in JIT)
[23:11:27] <headius> huh yeah this broke or I did not test it right at the time
[23:11:28] <headius> $ jruby -e 'def foo(a); raise; end; def bar; a = [1]; foo(*a); end; bar'... (full message at https://libera.ems.host/_matrix/media/r0/download/libera.chat/f63c67932c531d32317a35229828579b3f31914b)
[23:11:38] <headius> two foos
[23:12:39] <headius> huh raw backtrace stopped actually being raw
[23:14:32] <jswenson[m]> filed https://github.com/jruby/jruby/issues/6846
[23:21:01] <headius> that one shouldn't be hard to fix... I need to match duplicate frames better
[23:26:13] <jswenson[m]> for a bit more detail in what we were doing before to ‚Äúsanitize‚Äù the stack trace this is the (modified) comment:... (full message at https://libera.ems.host/_matrix/media/r0/download/libera.chat/136ae38669e598a0390f66d601c0575b853375f7)
[23:26:47] <headius> -1 frames was likely fixed
[23:27:57] <jswenson[m]> yeah this was back in 2017 when we moved from 9.1.5.0 -> 9.1.7.0
[23:30:44] <headius> oh yeah
[23:31:16] <jswenson[m]> good to know we can probably clean that up now -- its probably been silently doing nothing for years
[23:32:36] <headius> Yeah once we get this fixed I'd love to have you just remove your stack scrubbing and we can fix anything else that's not right
[23:33:13] <headius> I am disappointed this is not removing the extra frame. I'm sure I tested it but perhaps I tweaked something at the last minute. Serves me right for not coming up with a test
[23:33:35] <jswenson[m]> what surprises me is that the get and the patch seem to work differently
[23:34:12] <jswenson[m]> one with and and one without that extra frame
[23:38:38] <headius> Is one getting called with a different number of arguments? The only way the extra frame could get in there is if it were called with a variable number of arguments
[23:38:50] <headius> If you call a method that takes two arguments and pass two arguments we don't go through this extra frame
[23:40:23] <jswenson[m]> they do look identical from what I‚Äôm looking at here, but I also wouldn‚Äôt be surprised if there is another layers of dynamic metaprogramming coming from sinatra 
[23:41:06] <jswenson[m]> or other hooks in our system for routing
[23:41:39] <jswenson[m]> they both are `verb ‚Äò/path/ do ; ... ; end` 
[23:42:46] <headius> You can call java.lang.Thread.dumpStack to see if the extra frame shows up in the raw trace. I need to fix printing the raw trace from JRuby
[23:43:15] <headius> I think I just botched the frame name comparison in that code I linked
[23:44:53] <jswenson[m]> yeah that looks right -- `patch` the one with the extra frame seems to have a VARARGS in there 
[23:47:06] <jswenson[m]> 	:<method_that_calls caller>(...)
[23:47:06] <jswenson[m]> 	$create_route$0(file.rb:10)
[23:47:06] <jswenson[m]> 	$create_route$0$__VARARGS__(file.rb:9)
[23:47:18] <jswenson[m]> really messed up and sanitized, but something like that
[23:47:30] <headius> I have to run an errand but take a look at the code I linked and you might see the problem. I probably missed a dollar sign or something when comparing the frames
[23:48:34] <jswenson[m]> yeah seems like you‚Äôve got a good handle on it. Will try to come up with a simple repro for the other bug. 
