[01:18:27] <MatthiasVance> Hm I have a TaskResult that returns a Result
[01:18:35] <MatthiasVance> That I have to bind to get the next TaskResult that I want to bind
[01:18:41] <MatthiasVance> But .. I don't know how to deal with that :D
[01:18:45] <MatthiasVance> In a pipeline
[01:19:26] <akronymus[m]> Couldn't you define a operator for that purpose?
[01:20:03] <MatthiasVance> I am using FsToolkit.ErrorHandling, which has plenty
[01:20:28] <MatthiasVance> Ah, I could make something specific for this, but I *think* that library should already have it
[01:20:32] <MatthiasVance> I just don't know :D
[01:20:42] <akronymus[m]> Try >>=
[01:20:50] <MatthiasVance> What is that?
[01:21:01] <MatthiasVance> Ah, bind
[01:21:24] <akronymus[m]> Haskells bind
[01:21:24] <MatthiasVance> I might just write TaskResult.bind then
[01:21:38] <akronymus[m]> Oh, thatd work as well
[01:21:54] <akronymus[m]> Or make it into a computation expression?
[01:22:06] <MatthiasVance> Which works to some degree, but I want to keep chaining stuff and because it returns Result<bla option, someError> and I need to deal with just the bla
[01:22:58] <akronymus[m]> Yeah, sounds like you want some computation expression/railway oriented programming.
[01:24:40] <MatthiasVance> akronymus[m]: Yes that's why I'm doing right now
[01:24:50] <MatthiasVance> Just need the right functions to deal with both TaskResult and Result
[01:27:19] <akronymus[m]> https://demystifyfp.gitbook.io/fstoolkit-errorhandling/taskresult/ce
[01:33:42] <MatthiasVance> Yeah thanks but not what I was looking for
[01:34:17] <MatthiasVance> What that readme DOESN'T mention.. but what I *WAS* looking for .. is a TaskResultOption
[01:34:20] <MatthiasVance> And the library has that! :D
[01:34:26] <MatthiasVance> So now I can do TaskResultOption.bind
[01:34:46] <MatthiasVance> fucking wonderful
[01:36:44] <MatthiasVance> Now I need to understand what the way is to bind .. but then not return the same type
[01:38:42] <akronymus[m]> can you search by signature?
[01:39:09] <akronymus[m]> found that to br useful
[01:41:21] <MatthiasVance> Kind of, but I find them pretty hard to read with all these Task<Result<'a option, exn>> there
[01:43:59] <MatthiasVance> val bind: f: ('a -> Threading.Tasks.Task<Result<'e option,'f>>) -> tro: Threading.Tasks.Task<Result<'a option,'f>> -> Threading.Tasks.Task<Result<'e option,'f>>
[01:44:01] <MatthiasVance> xD
[01:45:04] <MatthiasVance> I want to get rid of the option too
[01:45:44] <akronymus[m]> At that poinz id recommend writing a function for it yourself.
[01:46:24] <akronymus[m]> And you can probably then simplify things/make it easier to find the right functionality
[01:47:33] <MatthiasVance> You're right
[01:47:54] <MatthiasVance> I don't want to make it harder for people by writing non-idiomatic helper functions
[01:50:08] <akronymus[m]> Yeah, hence recommending it as an intermediary step
[01:50:18] <MatthiasVance> Uhuh good point, thanks
[04:44:26] *** Joins: azimut_ (~azimut@gateway/tor-sasl/azimut)
[04:46:15] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Ping timeout: 240 seconds)
[12:32:26] <MatthiasVance> What if you use Option.bind with a function that returns another Option, resulting in Option<Option<T>>?
[12:32:33] <MatthiasVance> And another one and another one
[12:33:00] <MatthiasVance> (my use case is Task<Result<T, E>>
[23:28:24] *** Joins: rond_ (~rond_@90.254.208.190)
