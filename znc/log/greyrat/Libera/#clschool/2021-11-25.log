[00:06:40] *** Quits: vats (~vats@103.158.91.123) (Ping timeout: 260 seconds)
[00:15:40] *** Quits: sjl (~sjl@cpe-66-66-5-59.rochester.res.rr.com) (Quit: WeeChat 2.2-dev)
[00:17:14] *** Joins: tyson2 (~user@cpe00fc8d34ff03-cm00fc8d34ff00.sdns.net.rogers.com)
[00:40:25] *** Quits: tyson2 (~user@cpe00fc8d34ff03-cm00fc8d34ff00.sdns.net.rogers.com) (Remote host closed the connection)
[00:40:34] *** Quits: shka (~herr@83.175.151.96.piasta.pl) (Ping timeout: 260 seconds)
[01:26:07] *** Quits: abrantesasf (~abrantesa@187.36.170.211) (Remote host closed the connection)
[01:33:09] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[01:42:36] *** Quits: st_iron (uid370243@id-370243.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[02:28:47] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[02:57:12] *** Joins: dra (~dra@2a04:4540:6403:9d00:b54c:f686:ecb1:2f13)
[03:00:46] *** Quits: pjb (~pjb@user/pjb) (Remote host closed the connection)
[03:17:02] *** Quits: Jing (~hedgehog@2604:a840:3::105f) (Remote host closed the connection)
[03:18:13] *** Joins: Jing (~hedgehog@2604:a840:3::105f)
[03:22:44] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[03:41:33] *** Joins: Oladon (~olad@98.43.81.226)
[03:42:25] *** Quits: dra (~dra@2a04:4540:6403:9d00:b54c:f686:ecb1:2f13) (Quit: Leaving)
[04:00:20] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[04:21:11] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 250 seconds)
[04:22:53] *** Joins: aeth (~aeth@user/aeth)
[04:49:25] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[05:50:54] *** Quits: Josh_2 (~user@37.25.47.130) (Ping timeout: 260 seconds)
[06:06:41] *** Quits: random-nick (~random-ni@87.116.180.220) (Ping timeout: 256 seconds)
[06:21:41] <lisp123_> pjb: :D
[06:23:48] *** Quits: kuao (uid504326@id-504326.helmsley.irccloud.com) (Quit: Connection closed for inactivity)
[06:50:46] *** Joins: paule32_ (~paule32@user/paule32)
[06:52:46] *** Joins: paule32__ (~paule32@user/paule32)
[06:54:06] *** Quits: paule32 (~paule32@user/paule32) (Ping timeout: 245 seconds)
[06:56:06] *** Quits: paule32_ (~paule32@user/paule32) (Ping timeout: 265 seconds)
[06:57:13] *** Joins: paule32 (~paule32@user/paule32)
[06:59:06] *** Quits: paule32__ (~paule32@user/paule32) (Ping timeout: 245 seconds)
[07:03:50] *** Quits: dtman34 (~dtman34@c-73-62-246-247.hsd1.mn.comcast.net) (Ping timeout: 265 seconds)
[07:09:28] *** Quits: sts-q (~sts-q@212.53.219.220) (Ping timeout: 268 seconds)
[07:11:43] *** Joins: sts-q (~sts-q@212.53.219.239)
[07:12:42] *** Joins: dtman34 (~dtman34@c-73-62-246-247.hsd1.mn.comcast.net)
[07:14:30] *** beach` is now known as beach
[07:14:39] *** ChanServ sets mode: +o beach
[07:18:51] *** beach sets mode: -o beach
[07:56:49] *** Quits: waleee (~waleee@h-82-196-111-63.NA.cust.bahnhof.se) (Quit: WeeChat 3.3)
[08:01:24] *** Quits: lisp123_ (~lisp123@5.30.23.247) (Quit: Leaving...)
[08:13:38] *** Joins: sjl (~sjl@cpe-66-66-5-59.rochester.res.rr.com)
[08:54:57] *** Joins: lisp123w (~user@80.227.170.170)
[09:23:56] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[09:40:20] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[09:51:26] <CodeBitCookie[m]> Hello Everyone!
[09:51:54] <CodeBitCookie[m]> I have a small problem, I want to use loop but with pairs. The problem will be explained after an exmaple:
[09:52:14] <CodeBitCookie[m]> Lets say I want to loop over a list with pairs and cons them in reverse:
[09:52:45] <beach> So from (a b c d e f) you want (b a d c f e)?
[09:53:41] <CodeBitCookie[m]> (loop :for (a b) :on '(1 2 3 4 5) :while b
[09:53:41] <CodeBitCookie[m]>             :collect (cons b a))
[09:53:46] <CodeBitCookie[m]> this gives:
[09:53:51] <CodeBitCookie[m]> ((2 . 1) (3 . 2) (4 . 3) (5 . 4))
[09:54:17] <CodeBitCookie[m]> Now lets suppose I have a thousand elements and want to loop in pairs of 13!
[09:54:36] <CodeBitCookie[m]> (For context, this is for euler's project problem 8)
[09:54:49] <CodeBitCookie[m]> This works but looks like I am doing something wrong:
[09:54:51] <CodeBitCookie[m]> (apply #'max
[09:54:52] <CodeBitCookie[m]>   (loop :for (a b c d e f g h i j k l m) :on digits :while m
[09:54:52] <CodeBitCookie[m]>     :collect (* a b c d e f g h i j k l m)))))
[09:55:28] <beach> Indeed.  You are better off using SUBSEQ and APPLY.
[09:55:34] <CodeBitCookie[m]> Is there a way (maybe a macro with gensym?) to generate N number of pairs
[09:56:05] <CodeBitCookie[m]> beach: Can you give me an example? Thanks.
[09:56:37] <beach> Hold on...
[09:57:10] <CodeBitCookie[m]> Sure! Also, I am moving from loop -> iterate & GTWIWTG. Maybe there is an easy function in that?
[09:57:32] <CodeBitCookie[m]> From the documentation I couldn't find anything I could use for this problem.
[10:00:05] <beach> (loop for stuff = list then (nthcdr 13 stuff) until (null stuff) collect (apply #'* (subseq stuff (min 13 (length stuff)))))
[10:01:04] * beach vanishes for 20 minutes or so.
[10:01:29] *** Joins: st_iron (uid370243@id-370243.uxbridge.irccloud.com)
[10:29:45] <beach> CodeBitCookie[m]: Is that solution acceptable. 
[10:31:38] *** Joins: shka (~herr@83.175.151.96.piasta.pl)
[10:33:26] *** Joins: treflip (~user@95.79.32.99)
[10:41:11] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 245 seconds)
[10:43:18] *** Joins: aeth (~aeth@user/aeth)
[10:49:17] <beach> Oh, well.
[10:54:38] <CodeBitCookie[m]> beach: Oh so sorry, I had to go. I am checking it now.
[10:55:21] *** Joins: Oladon (~olad@98.43.81.226)
[10:56:42] *** Quits: Jing (~hedgehog@2604:a840:3::105f) (Remote host closed the connection)
[10:57:22] *** Joins: Jing (~hedgehog@115.207.50.95)
[10:58:44] <CodeBitCookie[m]> beach: nope.
[10:58:55] <CodeBitCookie[m]> doesn't work that way. Let me send you the function.
[11:00:48] <CodeBitCookie[m]> http://ix.io/3G3i
[11:10:31] <beach> I can't tell from that code what it is supposed to do.
[11:14:43] <CodeBitCookie[m]> <CodeBitCookie[m]> "(For context, this is for euler..." <- ^
[11:14:57] <CodeBitCookie[m]> let me link it
[11:15:18] <CodeBitCookie[m]> https://projecteuler.net/problem=8
[11:15:58] <CodeBitCookie[m]> my solution to that problem is:
[11:16:08] <beach> Oh, I see.  Let me try again then...
[11:16:16] <CodeBitCookie[m]> 1. turn the huuuuuge number into a string without newlines
[11:16:39] <CodeBitCookie[m]> 2. turn the string into a list of digits as characters
[11:16:47] <CodeBitCookie[m]> 3. turn that into a list of digits
[11:17:14] <CodeBitCookie[m]> 4. take pairs of 13 and move right by 1 digit each time finding the product of the 13 numbers
[11:17:59] <beach> Right
[11:18:09] <CodeBitCookie[m]> 5. I collect that into a list and find the biggest (max) product of 13 digits
[11:18:14] <CodeBitCookie[m]> and thats it.
[11:19:00] <beach> (loop for stuff = list then (cdr stuff) until (< (length stuff) 13) maximize (apply #'* (subseq stuff 13)))
[11:19:31] <beach> But that's a very inefficient solution.  I don't know whether the Euler problems are supposed to be solved efficiently.
[11:21:15] <CodeBitCookie[m]> still wrong answer,
[11:21:18] <beach> Oops, (subseq stuff 0 13)
[11:21:19] <CodeBitCookie[m]> gives me 1
[11:21:32] <beach> OK, you need to think a bit by yourself.
[11:21:39] <CodeBitCookie[m]> yeahhhhhhhhh
[11:21:55] <CodeBitCookie[m]> let me understand the loop 
[11:23:27] <CodeBitCookie[m]> so it works,.
[11:23:59] <CodeBitCookie[m]> beach: i mean, is it more ineffeceint than my a b c d... loop?
[11:24:41] <beach> A bit maybe.
[11:25:19] <beach> But it can be made a lot more efficient if you avoid multiplying the same numbers 13 times.
[11:26:53] <beach> Making it more efficient will complicate the code, of course, so if efficiency is not an objective, simplicity is better.
[11:27:11] <CodeBitCookie[m]> yeah, although just as food for though.
[11:27:29] <CodeBitCookie[m]> to avoid multiplication: we could do this in iteration:
[11:27:41] <CodeBitCookie[m]> 1. (* a b c d ....)
[11:28:23] <CodeBitCookie[m]> 2. (* (/ previous-element a) n)
[11:28:45] <beach> Unless a is 0.
[11:29:49] <CodeBitCookie[m]> true. In fact since a 0 currpots the whole number we could just check if the pewvious-element is 0.
[11:30:37] *** Quits: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de) (Quit: Leaving)
[11:30:51] <beach> If the previous element is 0, then you don't really know what the product of the remaining elements is.
[11:32:00] <CodeBitCookie[m]> hmmmm. true. i will just check if a is 0
[11:32:39] <beach> And in fact, if the distribution of digits is "rectangular" (I forget the term), then most products are going to be 0.
[11:33:57] <CodeBitCookie[m]> wait why?
[11:34:50] <beach> The probability that there is a 0 in a random sequences of 13 digits, each between 0 and 9, is very high. 
[11:35:05] <CodeBitCookie[m]> yeah.
[11:36:09] <CodeBitCookie[m]> also now that i think about it, it wont work. this is because the 0 will eat the rest if our products.
[11:36:41] <beach> That's what I said.  If a is 0 you don't know the product of the others.
[11:36:49] <CodeBitCookie[m]> yeah.
[11:36:56] <CodeBitCookie[m]> you're right
[11:37:03] <CodeBitCookie[m]> thanks again!
[11:37:29] <beach> Sure, good luck.  Again, if the goal is simplicity, my solution should work.
[11:37:41] <beach> But if you want performance, you need to think harder.
[11:37:42] <CodeBitCookie[m]> also as for how efficient the solutions should be? it should take less than a minute to run... soooo yeah.
[11:37:57] <beach> Oh, that's easy.  It takes no time at all.
[11:38:02] <CodeBitCookie[m]> yeah
[11:38:29] <CodeBitCookie[m]> I am learning a lot of lisp from project euler.
[11:38:47] <beach> It takes 4ms here.
[11:39:00] <beach> I bit more if you add the conversion from a string to a list.
[11:40:16] <beach> You can be sneaky and add an epsilon, like 0.001 to each "digit", and then truncate the result.  Then you have no 0s.
[11:40:46] <beach> But if 1 minute is good enough, then there is no reason to optimize.
[11:41:49] <CodeBitCookie[m]> beach: fun and learning could be reasons.
[11:41:56] <CodeBitCookie[m]> thats a really samrt solution.
[11:41:58] <beach> Absolutely. 
[11:41:59] <CodeBitCookie[m]> smart*
[11:42:07] <beach> Thanks. 
[11:42:51] <CodeBitCookie[m]> but wouldn't that still ruin the rest of our products?
[11:42:52] <beach> Do they state the type of the input?  A string?  A file?
[11:43:11] <CodeBitCookie[m]> just an integer we need to type in
[11:43:19] <beach> I think not.  Let me experiment. 
[11:43:25] <CodeBitCookie[m]> ... to a checkbox on the problem page after we login
[11:43:33] <beach> An integer?  That won't be possible to represent in most languages. 
[11:43:49] <CodeBitCookie[m]> i mean on problem 8
[11:44:11] <CodeBitCookie[m]> and the problems before that. They just need a number.
[11:44:39] <CodeBitCookie[m]> beach: meaning the numbers on your keyboard. i accidentally said integer
[11:44:41] <beach> So you have to type in the 1000 digits yourself?  Or copy the characters?
[11:45:04] * CodeBitCookie[m] uploaded an image: (139KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/kKwOANaGBVoEHGttwFvJONyU/image.png >
[11:45:15] <beach> OK, there is a difference between numbers and digits.
[11:45:48] <CodeBitCookie[m]> beach: in the answer box? You need to type in the result in problem 8: 23514624000
[11:46:11] <beach> Wow, so they don't even want code?  How can they check that it took less than a minute then?
[11:46:15] <CodeBitCookie[m]> but obviously you could copy anything on that site.
[11:46:33] <CodeBitCookie[m]> beach: they just want you to not lie to yourself.
[11:46:45] <beach> Hmm.  OK.
[11:47:01] <CodeBitCookie[m]> the solutions are usually very very easy to make under a minute (as you might have guessed) its hard to cheat.
[11:47:28] <beach> I think I understand.
[11:48:02] <CodeBitCookie[m]> like: for problem 3, instead of looping and checking upto every n you could loop to sqrt(n).
[11:48:11] <CodeBitCookie[m]> brb
[12:01:03] <CodeBitCookie[m]> im back.
[12:02:05] <CodeBitCookie[m]> <CodeBitCookie[m]> "like: for problem 3, instead..." <- for clarity, if you didn't do that, the solution would take more than a minute verses a few seconds
[12:02:29] <CodeBitCookie[m]> and this is checking for all prime factors ":upto" in the loop 
[12:54:47] *** Joins: rotateq (~user@p200300e7871bd300c158d62dc7544d08.dip0.t-ipconnect.de)
[13:38:39] <lisp123w> I've reduced my loop usage considerably in the last 2 weeks
[13:39:00] <lisp123w> More of a fan of mapc / mapcar now
[13:39:40] <lisp123w> But I heard loop is highly efficient, so probably good for 'production' code
[13:39:45] *** Joins: pjb (~pjb@user/pjb)
[13:42:07] <rotateq> oha
[13:42:21] <lisp123w> hey rotateq :) how are you
[13:43:08] <rotateq> hey, I'm fine and you?
[13:43:33] <rotateq> maybe often you can use REDUCE too
[13:44:48] <lisp123w> I'm good. Just ran some code and it worked for the first time
[13:45:15] <rotateq> piece by piece :)
[13:45:20] <lisp123w> Yeah I should start using REDUCE more too :)
[13:46:07] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[13:47:53] <rotateq> and yes LOOP can not just be efficient but also you can have combined much in one without loosing the intention what it does
[13:48:25] <lisp123w> Indeed
[13:49:49] <rotateq> but it needs time, like with FORMAT
[13:51:14] <lisp123w> Urgh format
[13:51:27] <rotateq> very powerful :)
[13:51:27] <lisp123w> LOOP I always enjoyed. FORMAT...
[13:51:39] <beach> Mapping functions are fine if you already have the function you want to map.  But if if you need to create an anonymous function just for the call, then a loop is often clearer. 
[13:52:11] <lisp123w> On FORMAT, is there a directive to do percentages? e.g. 5.5% (when the value is 0.055)
[13:52:52] <lisp123w> beach: Makes sense
[13:53:15] <rotateq> I don't know, but the FORMAT in SICL will be extensible afaik. You can have monetary printouts with ~$.
[13:55:56] <lisp123w> I see
[13:58:02] <lisp123w> I guess I don't appreciate FORMAT enough. For basic use cases, its relatively good
[13:58:36] <rotateq> and even more for the advanced ones, with training :)
[13:59:07] <lisp123w> Black Belt in Format
[13:59:23] <rotateq> haha maybe one day this too
[13:59:43] <lisp123w> So by extensible, one can create their own directives? Are we allowed to do multi-letter, e.g. ~pprint
[14:00:52] <rotateq> yesterday i was waiting 10min for the bus and played a game with myself if i can tell all 25 special operators from memory, but had just 17
[14:01:28] <rotateq> lisp123w: it must be absolutely clear
[14:01:55] <lisp123w> 17/25 is very good!
[14:02:22] <rotateq> ah hm, this evening I'm at a friend's house and he shall question me again
[14:03:02] <lisp123w> its like the periodic table
[14:03:15] <lisp123w> good luck!
[14:03:29] <rotateq> but I thought one can have an extension for example ~r to give the numbers in another language than english
[14:03:53] <rotateq> do you know the periodic table of LOOP? :P
[14:04:52] <lisp123w> No, i'm still stuck on the primitives :P
[14:05:58] <rotateq> https://trash.randomerror.de/r8rtd/loop-periodic-table.pdf
[14:06:35] <rotateq> and in PAIP Norvig shows in the end how it can be written (without the extensions that came later)
[14:06:44] <lisp123w> Thanks for the link
[14:06:58] <lisp123w> Have you finished PAIP?
[14:07:55] <rotateq> nooo xD still many stuff to re(work) on
[14:09:11] <rotateq> or no, (re)work
[14:09:46] <lisp123w> Yeah its a big book!
[14:11:22] <rotateq> it's like when you for example want to know how backquote can be written, it is given in the end of Steele's CLtL2
[14:11:42] <rotateq> surely also not trivial
[14:14:30] <lisp123w> Yes I saw that one
[14:14:41] <rotateq> "with sweat and steele ..."
[14:14:45] <lisp123w> I kinda get backquote, been fortunate on that one
[14:15:09] <rotateq> first getting to know using it is totally enough :)
[14:15:32] <lisp123w> And its useful in many places outside of macros!
[14:15:40] <rotateq> of course
[14:24:39] <pjb> lisp123w: https://termbin.com/zkeql
[14:25:22] <rotateq> pjb has things in petto for everything ^^
[14:25:56] <pjb> All functions always exist from all eternity. This is maths :-)
[14:26:03] <pjb> You only have to find their names. 
[14:26:05] <lisp123w> pjb: Thanks! That's straight going into the utils library
[14:26:23] <lisp123w> rotateq: COM.INFORMATIMAGO.LISP is basically CL++ :)
[14:26:51] <rotateq> i thought CL is in itself as many plusses as one needs :P
[14:27:01] <pjb> other examples: Format self-incrementing indices. http://paste.lisp.org/display/163695   Justify: https://termbin.com/sonx
[14:27:01] <pjb>  
[14:28:09] <pjb> An alternative to putting them in CL-USER, is to define a FMT (or F) package and put them there ~/FMT:%/  ~/FMT:JUSTIFY/ ~/FMT:INDEX/
[14:28:34] <lisp123w> Awesome, thanks! Will save once I get back to my main machine
[14:29:13] <lisp123w> Justify definitely sounds like it would have taken some time to implement!
[14:30:04] <CodeBitCookie[m]> rotateq: Wow, that's really useful! Thanks.
[14:30:12] <pjb> Not really, the algo is very simple. split the lines, compute length, and add spaces before after or around.
[14:30:18] <CodeBitCookie[m]> the periodic table I mean
[14:30:20] <rotateq> what did i do?!
[14:30:46] <rotateq> ahh that, it is from Land of Lisp
[14:32:24] <rotateq> lisp123w: https://trash.randomerror.de/931nm/morpeus.jpg
[14:32:39] <rotateq> i should name the file correctly
[14:35:34] <lisp123w> pjb: True, when you put it that way
[14:37:50] *** Quits: seok (~Seok@n114-73-75-18.bla3.nsw.optusnet.com.au) (Ping timeout: 256 seconds)
[14:58:49] *** Joins: seok (~Seok@n114-73-75-18.bla3.nsw.optusnet.com.au)
[15:55:14] *** Joins: random-nick (~random-ni@87.116.180.220)
[16:07:49] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[16:16:16] <CodeBitCookie[m]> I had a more in-depth look at Format reading all of the directives in our beloved common lisp hyperspec and this random website: https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node200.html, I used to love it, but... now I love it even more!
[16:16:31] <CodeBitCookie[m]> by it ofcourse, I mean Format
[16:16:56] <antoszka> CodeBitCookie[m]: Did you look at the CLQR?
[16:17:02] <antoszka> You'll love it even more ;)
[16:18:02] <CodeBitCookie[m]> antoszka: What's that?
[16:18:13] <CodeBitCookie[m]> let me search it...
[16:19:40] <rotateq> i should print that out for me ^^
[16:20:17] <rotateq> even with TeX source, wonderful
[16:21:06] <antoszka> Yeah, I print it out every now and then
[16:21:33] <antoszka> CodeBitCookie[m]: http://clqr.boundp.org
[16:27:01] <CodeBitCookie[m]> Wow, I will try to understand the typographic conventions more but its flaberghasting how small the reference is.
[16:32:12] <rotateq> on page 22 another more clear table for LOOP how its keywords interact
[16:33:19] <CodeBitCookie[m]> rotateq: Will have to thank
[16:33:23] <CodeBitCookie[m]> Zathura for this one
[16:34:13] <rotateq> oh yes, zathura is great
[16:56:52] <CodeBitCookie[m]> beach: Isn't it interesting that the solution you provided which was simpler (arguably) than writing out the 13 letters by hand is actually slower than the old annoying one. I think this is mostly because of how much loop tries to make effecient code. Yours ran in (avg): 0.002s, while the annoying one: 0.000207. Ofcourse we are not aiming for performance, but I was just giving you my results for what it's worth.
[16:57:49] <CodeBitCookie[m]> Also, anyone prefer Loop over iterate?
[17:01:37] <CodeBitCookie[m]> or is that a more #commonlisp question.
[17:27:27] <pjb> probably
[17:54:00] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[18:03:31] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[18:25:33] *** Joins: tyson2 (~user@cpe688f2ec1f9b3-cm688f2ec1f9b0.cpe.net.cable.rogers.com)
[18:59:05] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[19:07:43] *** Joins: Oladon (~olad@98.43.81.226)
[19:28:46] *** Joins: lisp123 (~lisp123@5.30.23.247)
[19:36:53] <beach> CodeBitCookie[m]: Not surprising.  There is a lot of consing in my solution.
[19:37:05] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[20:12:48] <White_Flame> CodeBitCookie[m]: just to roll back to your first question, you can loop & collect "in pairs"
[20:13:16] <White_Flame> (loop for (a b) on list by #'cddr ... ) will destructure the first 2 elements out of your list, then advance by 2 elements
[20:13:44] <White_Flame> then you can do (.. collect b collect a ..) to shove 2 things onto the output list every iteration
[20:13:46] <White_Flame> in that order
[20:14:48] <White_Flame> If the input list is of an odd length, you'll get a NIL for B, so you might need to do more checking
[20:15:00] <White_Flame> *NIL for B on the last iteration
[20:15:21] *** Quits: tyson2 (~user@cpe688f2ec1f9b3-cm688f2ec1f9b0.cpe.net.cable.rogers.com) (Ping timeout: 245 seconds)
[20:19:00] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[20:23:58] *** Quits: rotateq (~user@p200300e7871bd300c158d62dc7544d08.dip0.t-ipconnect.de) (Ping timeout: 260 seconds)
[20:25:09] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[20:29:31] *** Joins: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de)
[20:32:01] *** Quits: lisp123 (~lisp123@5.30.23.247) (Quit: Leaving...)
[20:41:18] *** Joins: lisp123 (~lisp123@5.30.23.247)
[21:07:12] *** Joins: lisp123_ (~lisp123@45.86.202.18)
[21:10:32] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[21:19:35] *** Joins: lisp123 (~lisp123@5.30.23.247)
[21:22:26] *** Quits: lisp123_ (~lisp123@45.86.202.18) (Ping timeout: 245 seconds)
[21:33:00] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[21:44:58] <treflip> > *NIL for B on the last iteration
[21:44:58] <treflip> a perfect case for :finally in a loop
[21:47:23] <White_Flame> or while (cdr list)
[21:47:51] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[21:48:37] <White_Flame> not sure what FINALLY is supposed to do here, as it doesn't have access to the return list that COLLECT is building
[21:51:46] *** Quits: treflip (~user@95.79.32.99) (Remote host closed the connection)
[22:51:15] *** Quits: st_iron (uid370243@id-370243.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[22:53:39] *** Joins: Oladon (~olad@98.43.81.226)
[22:59:03] *** Joins: tyson2 (~user@cpe00fc8d34ff03-cm00fc8d34ff00.sdns.net.rogers.com)
[23:30:39] <pjb> White_Flame: it could have side effects.
[23:30:58] <pjb> White_Flame: alternatively, if you want to post-process the collected elements, you can collect them into a named variable.
[23:33:34] *** Joins: lisp123 (~lisp123@5.30.23.247)
[23:38:34] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 260 seconds)
