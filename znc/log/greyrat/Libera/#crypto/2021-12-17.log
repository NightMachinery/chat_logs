[00:11:28] *** Joins: Everything (~Everythin@37.115.210.35)
[00:14:44] *** Quits: semisimple (~semisimpl@77.23.31.76) (Ping timeout: 252 seconds)
[00:16:27] *** Joins: semisimple (~semisimpl@77.23.31.76)
[00:20:51] *** Joins: kish` (~sid742412@user/aqua)
[00:50:43] *** Joins: sdfgsdfg (~sdfgsdfg@user/sdfgsdfg)
[00:51:01] *** Joins: son0p (~ff@2800:484:1d81:b700:d40b:900:b387:320)
[01:02:20] *** Quits: Ivii (~Ivyy@2001:a62:4c3:8e01:226:6685:3dd4:7093) (Quit: Leaving)
[01:10:57] *** Joins: System_Error (~SystemErr@user/systemerror)
[01:20:59] *** Quits: Everything (~Everythin@37.115.210.35) (Quit: leaving)
[01:22:55] *** Quits: lord| (~lordpipe@user/lordpipe) (Ping timeout: 256 seconds)
[01:24:46] *** Quits: kristijonas (~kristijon@81-7-103-234.static.zebra.lt) (Quit: Client closed)
[01:28:45] *** Joins: bsdbandit01 (~bsdbandit@2607:fb91:1492:eb5c:8136:9529:69d1:919e)
[01:32:02] *** cryptonull is now known as eck
[01:36:25] *** Quits: bsdbandit01 (~bsdbandit@2607:fb91:1492:eb5c:8136:9529:69d1:919e) (Read error: Connection reset by peer)
[01:40:40] *** Quits: gproto23 (~gproto23@user/gproto23) (Remote host closed the connection)
[01:50:41] *** Quits: inlight (~inlight@user/inlight) (Remote host closed the connection)
[01:55:38] *** Joins: lord| (~lordpipe@user/lordpipe)
[01:57:03] *** Joins: bsdbandit01 (~bsdbandit@2607:fb91:1492:eb5c:8136:9529:69d1:919e)
[01:58:07] *** Quits: bsdbandit01 (~bsdbandit@2607:fb91:1492:eb5c:8136:9529:69d1:919e) (Read error: Connection reset by peer)
[02:03:12] *** Quits: Itaru (~Itaru@ro2.flokinet.is) (Remote host closed the connection)
[02:03:37] *** Joins: Itaru (~Itaru@ro2.flokinet.is)
[02:04:10] <maroon> thanks yawkat, im not familiar with all the syntax used in crypto docs, usually i saw concatenation as like hash(string1||string2), so i thought this was some other kind of interaction between the 2 strings
[02:12:02] *** Quits: Itaru (~Itaru@ro2.flokinet.is) (Remote host closed the connection)
[02:12:17] *** Joins: Itaru (~Itaru@ro2.flokinet.is)
[02:12:35] *** Parts: evidlo (~evidlo@2001:470:69fc:105::7fc) ()
[02:15:31] *** Joins: bsdbandit01 (~bsdbandit@2607:fb91:1492:eb5c:8136:9529:69d1:919e)
[02:16:25] <rk4> is there something about hashids that makes it non-trivial, the effort put into hashids.org for mapping integers into hex seems...excessive
[02:16:58] <rk4> [s/hex/arbitrary base/]
[02:17:58] <rk4> there is a salt in there, but i'm not sure what guarantees that provides
[02:21:46] *** Quits: CryptoDavid (uid14990@id-14990.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[02:22:35] <Alipha> rk4: i assume the salt is actually like a key--you need the salt so that an attacker can't just reverse the IDs themselves. and so the salt really should be like a random 20 characters so that the salt isn't guessable
[02:23:36] <rk4> yeah i think you're right, though it does make it feel pretty mediocre, could use a legit cipher rather than whatever they're doing
[02:23:59] <Alipha> rk4: well, they say so themselves: Do you have a question or comment that involves "security" and "hashids" in the same sentence? Don't use Hashids.
[02:26:06] <rk4> which makes me feel...it's just meh, you have some sort of keyed invertable transformation that isn't named, it's kind of like someone invented a cipher but knows it sucks so tells us so
[02:27:50] <Alipha> rk4: i have a java implementation of "Triple-Speck32"
[02:28:35] <rk4> this makes far more sense to me^
[02:32:16] *** Quits: chomwitt (~chomwitt@2a02:587:dc19:a500:12c3:7bff:fe6d:d374) (Remote host closed the connection)
[02:35:03] *** Quits: Guyver2 (~Guyver@guyver2.xs4all.nl) (Quit: Going offline, see ya! (www.adiirc.com))
[02:38:30] *** Joins: WarpedAI (~Warped@user/warped)
[02:41:07] *** Quits: Warped (~Warped@user/warped) (Ping timeout: 256 seconds)
[02:45:39] *** Quits: machinedgod (~machinedg@24.105.81.50) (Ping timeout: 256 seconds)
[02:50:45] *** Quits: igemnace (~ian@user/igemnace) (Ping timeout: 256 seconds)
[02:54:47] *** Joins: boxframes (~Saloframe@2607:9000:2000:15::a45d)
[03:03:28] <Alipha> rk4: i grabbed my Speck32 code and made a little example: https://gist.github.com/alipha/10a6241ab8f33fd02dc9f847106a969c
[03:04:50] *** Quits: son0p (~ff@2800:484:1d81:b700:d40b:900:b387:320) (Ping timeout: 260 seconds)
[03:07:45] *** Quits: CryptoClub (~fafs@88.red-83-34-81.dynamicip.rima-tde.net) (Ping timeout: 256 seconds)
[03:07:58] <TimMc> rk4: It feels vaguely like base64-plus-rot13.
[03:08:11] <TimMc> which was the super secure cipher I came up with as a teenager
[03:08:45] <TimMc> (That's really what it is, right? Base64 with a scrambled alphabet?)
[03:10:06] <ioxzev1z> As long as noone knows how your security system works you'll be fine with base64-plus-rot13
[03:11:28] <rk4> Alipha: now time to register "betterhashit.org" ;)
[03:12:27] *** Joins: igemnace (~ian@user/igemnace)
[03:15:55] *** Joins: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani)
[03:17:49] *** Joins: machinedgod (~machinedg@24.105.81.50)
[03:23:48] <maroon> am i reading this right that encrypt is 3 passes of encrypt with separat 64bit chunks of the hash as the key? i thought 3des was encrypt-key1/decrypt-key2/encrypt-key3
[03:24:36] <snappy> maroon: usually 3DES is EDE
[03:25:59] <maroon> thanks snappy, is there a way to handle the case where key1=key2 or key2=key3 to avoid them canceling out, or is just considered low risk?
[03:26:35] <snappy> I thought to support DES compatibility, key1=key2 is usually allowed
[03:27:10] <snappy> if you don't want that though, i guess you can raise some kind of error when the keys are not distinct
[03:30:28] *** Quits: bsdbandit01 (~bsdbandit@2607:fb91:1492:eb5c:8136:9529:69d1:919e) (Read error: Connection reset by peer)
[03:31:23] <MacGyver> snappy, maroon: key1 = key3.
[03:31:26] <ioxzev1z> Why was Speck removed from the Linux kernel if there are no clear weaknesses? I get that it's probably backdoored somehow
[03:31:37] <maroon> i guess the simplest handler that lowers the chance to 1 in 2^(3*keysize) is to simply have: if key2==key1 then swap key2,key3
[03:32:00] <MacGyver> TDEA with that optimization is = e_k1(d_k2(e_k1(m)))
[03:32:38] <snappy> ohh, so it's not 3 distinct keys, which makes sense, because usually the security level of 3DES is 112 bits
[03:33:08] <MacGyver> snappy: The security level of the 3-key version is still 112 bits.
[03:33:17] <maroon> im guessing 3DES does that to have compatibility with things giving a 128-bit key to AES?
[03:33:18] <MacGyver> Even though the key is then 168 bits in length.
[03:33:20] <snappy> ah yeah, because of meet in the middle
[03:36:14] <maroon> so is it better for the 3SPECK to do EEE with 3 keys?
[03:36:30] <MacGyver> Having unrelated keys does follow the principle of least surprise.
[03:37:55] <MacGyver> maroon: Iirc there's no reason other than "We can set k1 = k2 = k3 and do EDE and then it's compatible with DES" for TDEA's EDE construction, but I could be wrong.
[03:38:17] <MacGyver> maroon: I don't think there's any difference between EEE and EDE though, if you use unrelated keys.
[03:40:47] <maroon> MacGyver, EEE with 3 unrelated keys with speck32, is that security level up to 3*64 or still at 2*64?
[03:41:22] <Alipha> 2*64 time + 64 space for a meet in the middle attack
[03:42:09] <MacGyver> I'm pretty sure the MITM attack generalizes across all such constructions.
[03:42:14] <MacGyver> So yes, 2*64, not 3.
[03:43:41] <maroon> how does the MITM security scale if he did EEEE with all 4 quarters of the sha256 hash?
[03:44:16] <MacGyver> 128 bits not enough for you?
[03:44:32] <maroon> i'm greedy :)
[03:44:56] *** Joins: bsdbandit01 (~bsdbandit@172.58.189.41)
[03:44:57] *** Quits: Itaru (~Itaru@ro2.flokinet.is) (Ping timeout: 240 seconds)
[03:44:57] *** Quits: Wulf (~Wulf@user/wulf) (Ping timeout: 240 seconds)
[03:45:43] <maroon> and supposedly when the quantum boogeyman comes, all keylengths are cut in half
[03:46:08] *** Quits: Klotz (~Klotzoman@gateway/tor-sasl/klotz) (Quit: Klotz)
[03:47:04] *** Joins: Wulf (~Wulf@user/wulf)
[03:48:11] *** Quits: Seirdy (~Seirdy@sourcehut/user/seirdy) (Quit: exiting 3.3)
[03:48:43] *** Joins: Seirdy (~Seirdy@sourcehut/user/seirdy)
[03:50:01] <MacGyver> I'm not gonna hazard a computation here.
[03:50:12] <MacGyver> You'll need to read up on https://en.wikipedia.org/wiki/Meet-in-the-middle_attack#Multidimensional_MITM_(MD-MITM)
[03:52:25] *** Joins: Warped (~Warped@user/warped)
[03:53:11] *** Joins: infosecgnu (~fletc@cpc160499-chfd4-2-0-cust41.12-3.cable.virginm.net)
[03:53:38] *** Quits: infosecgnu (~fletc@cpc160499-chfd4-2-0-cust41.12-3.cable.virginm.net) (Read error: Connection reset by peer)
[03:54:23] *** Joins: newbie|2 (~Warped@user/warped)
[03:54:47] *** Quits: WarpedAI (~Warped@user/warped) (Ping timeout: 256 seconds)
[03:55:06] *** Quits: bsdbandit01 (~bsdbandit@172.58.189.41) (Read error: Connection reset by peer)
[03:55:33] *** Joins: infosecgnu (~fletc@cpc160499-chfd4-2-0-cust41.12-3.cable.virginm.net)
[03:57:42] *** Quits: Warped (~Warped@user/warped) (Ping timeout: 268 seconds)
[03:58:17] *** Joins: bsdbandit01 (~bsdbandit@172.58.189.41)
[04:00:01] *** Joins: haskal (~haskal@tilde.town)
[04:00:09] *** Joins: Warped (~Warped@user/warped)
[04:02:43] *** Quits: newbie|2 (~Warped@user/warped) (Ping timeout: 256 seconds)
[04:06:44] *** Quits: igemnace (~ian@user/igemnace) (Remote host closed the connection)
[04:07:51] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Remote host closed the connection)
[04:11:13] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[04:13:27] *** Quits: Pythayr (~pither195@64.42.181.51) (Quit: Leaving)
[04:14:14] *** Joins: Pythayr (~pither195@64.42.181.51)
[04:16:53] *** Quits: blyat-73 (~hjgkjhgkj@46.235.96.249) (Ping timeout: 256 seconds)
[04:18:17] *** Quits: machinedgod (~machinedg@24.105.81.50) (Ping timeout: 240 seconds)
[04:19:36] *** Quits: bsdbandit01 (~bsdbandit@172.58.189.41) (Read error: Connection reset by peer)
[04:23:49] *** Quits: ioxzev1z (~ioxzev1z@user/ioxzev1z) (Quit: Leaving)
[04:25:05] *** Quits: tusko (~yeurt@copyfree/advocate/tusko) (Remote host closed the connection)
[04:25:21] *** Joins: tusko (~yeurt@copyfree/advocate/tusko)
[04:27:07] *** Joins: bsdbandit01 (~bsdbandit@172.58.189.41)
[04:30:17] *** Quits: ses (uid38151@id-38151.hampstead.irccloud.com) (Quit: Connection closed for inactivity)
[04:33:20] *** Joins: asa22 (~asa22@84.125.126.149.dyn.user.ono.com)
[04:33:22] <asa22> hello
[04:33:39] *** Quits: bsdbandit01 (~bsdbandit@172.58.189.41) (Read error: Connection reset by peer)
[04:34:23] <asa22> I was wondering if it would be possible to implement a One Time Pad encryption/decryption system using bits instead of the alphabet translated into decimal numbers
[04:34:48] <asa22> so I already made a program in python that uses ASCII characters mapped to numbers 0 to 98
[04:35:01] <asa22> now I want to make it so that it would work with any byte data
[04:35:22] <asa22> so both the file and the key would be something like 1001010010001000001111100010010010101
[04:35:27] <asa22> is this even possible
[04:35:53] <asa22> how do I sum it
[04:37:07] <asa22> maybe I can make it so that 1 + 1 = 2 instead of 1
[04:37:21] <asa22> so say the file is 10110
[04:37:33] <asa22> and the key is 10011
[04:37:47] <ms7821> you probably want bitwise xor
[04:37:50] <asa22> the encrypted file would be 20121
[04:38:14] <ms7821> so 1 ^ 1 = 0
[04:39:01] <maroon> your alphabet has 99 characters? i'm guessing space + 0x21-0x7e + carriage return + linefeed + something?
[04:39:40] <maroon> you're wanting your output to be one of those 99 characters instead of being binary?
[04:39:46] <asa22> maroon I added a bunch of symbols and the space and stuff yes
[04:40:16] <asa22> maroon no, I want the output to be binary but I dont know if this breaks the encryption
[04:40:28] *** Joins: llorllale (~llorllale@2607:9880:3a18:69:c959:9e8d:b7ca:4f4d)
[04:41:18] <maroon> if using bitwise xor, it would, because not all binary characters have a mapping to all 99's. bitwise xor assumes the alphabet size is 2^integer
[04:41:37] <ms7821> so instead of translating your ascii characters into numbers between 0 and 98, you convert them to a binary stream of 8 bits per byte
[04:41:47] <asa22> forget about the 99 thing that was the previous program I made
[04:41:52] <ms7821> and then xor those with your key
[04:41:56] <asa22> this is completely knew and its just gonna use bit data
[04:42:00] <ms7821> bitwise xor is how stream ciphers work (which are a cryptographic building block, and actually used, unlike one-time pad, which is an incomplete cryptosystem)
[04:42:19] <ms7821> have a look at https://en.wikipedia.org/wiki/XOR_cipher
[04:42:47] <maroon> OTP is like a stream cipher using a random key whose length matches the stream's length - but doesnt define how to create/transport that key
[04:42:52] <ms7821> the nice thing about the ^ operator is it also works on bytes so you can just do a ^ b in python and it'll do all 8 bits
[04:43:22] <asa22> oh awesome, so it does work then
[04:43:34] <asa22> and its not called OTP but XOR cipher
[04:43:38] <asa22> great
[04:44:15] <maroon> but if you're xor'ing against a stream cipher, you need some authentication, to defend against someone who knows what the plaintext is, which allows them to create an xor value to change it to something else
[04:44:15] <tusko> xor isn't very good
[04:44:56] *** Joins: bsdbandit01 (~bsdbandit@2607:fb91:1492:eb5c:8136:9529:69d1:919e)
[04:44:58] <MacGyver> asa22: Conceptualize: Just how you can make *words* by combining the 99 letters you're using into strings, you're now dealing with an alphabet with only 2 characters, 0 and 1. And you can make letters by combining those characters into bitstrings. So nothing changes, except now you get to use a simpler addition, defined as 0+0 = 0, 0+1 = 1, 1+0 = 1, 1+1 = 0
[04:45:00] <tusko> if you xor many times with the same key eventually you'd just reveal your key
[04:45:01] <maroon> ie, if you xor a byte in ciphertext by 0x01, that's also xor'ing the decrypted plaintext by that same 0x01
[04:45:19] *** Quits: bsdbandit01 (~bsdbandit@2607:fb91:1492:eb5c:8136:9529:69d1:919e) (Read error: Connection reset by peer)
[04:45:58] <asa22> tusko same with OTP right? so XOR has perfect secrecy just like OTP?
[04:46:12] <asa22> if the key is of equal lenght to the encrypted text and the key is only used once
[04:46:31] <MacGyver> asa22: That being said, what both maroon and tusko are trying to convey is that plain XOR ciphers suck. Even OTP, the best XOR cipher, is bad.
[04:46:42] <MacGyver> "Perfect secrecy" is a terrible security guarantee.
[04:46:54] <tusko> with OTP you change the key all the time, randomly. I was speaking about xor with the same key, several times,
[04:46:59] *** Quits: PJBoy (~PJBoy@user/pjboy) (Ping timeout: 252 seconds)
[04:46:59] <MacGyver> Because it completely ignores authentication.
[04:47:10] <asa22> idk what authentication means
[04:47:33] <asa22> so my OTP program generates a random key, a encrypted file and a checksum
[04:47:47] <asa22> you keep the key safe, you make sure the file is not corrupted by checking against the checksum
[04:47:48] <tusko> how do you generate randomness?
[04:48:06] <asa22> with the best option that computers allow
[04:48:16] <MacGyver> Then you shouldn't be using plain xor.
[04:48:33] <asa22> why not?
[04:48:47] <asa22> what makes OTP different from plain xor in relation to this
[04:48:51] <MacGyver> Because you just told us you'll be using a keyed stream cipher.
[04:49:01] <MacGyver> That's the best option that computers allow.
[04:49:10] <asa22> it has enough entropy
[04:49:14] <tusko> I believe MacGuyver was indicating there is not good integrity
[04:49:16] <maroon> without authentication, if i know the plaintext is transfering money to your bank account number, i could alter that portion of ciphertext to be xor(your account, my account) and the money goes to me
[04:49:18] <ms7821> have a read of https://en.wikipedia.org/wiki/Message_authentication_code
[04:49:47] <MacGyver> Also, your "checksum" is not part of OTP, and you'll need to take extra care to actually create something resistant to attack.
[04:49:56] <sarnold> maroon: oo flip some of those digits to make it ten times more, too!
[04:50:09] <asa22> its sha512
[04:50:31] <MacGyver> I can generate an unkeyed SHA512 over whatever I decide to change your ciphertext into.
[04:50:42] <maroon> sarnold, only if i know that wouldn't make the transfer bounce because it's too much
[04:50:42] <MacGyver> Read the link ms7821 provided.
[04:50:50] <asa22> ok
[04:50:57] <sarnold> maroon: oh good call
[04:51:48] <MacGyver> But the main point is, usually when someone's asking about OTP it's because they've heard or read that it's "the ultimate encryption scheme" that "cannot be broken" because it has "perfect secrecy".
[04:51:56] <MacGyver> We're telling you that that is bullshit.
[04:52:02] <asa22> ok so it doesnt have authentication
[04:52:35] <MacGyver> Fine for a toy project, but for *anything* you want to *really* use, use actual modern cryptography.
[04:52:46] *** Joins: bsdbandit01 (~bsdbandit@2607:fb91:1492:eb5c:8136:9529:69d1:919e)
[04:52:48] <asa22> I understand the pros and cons of OTP Im just implementing it to practice programming
[04:52:59] <MacGyver> That's fine then, then we're back to what I said initially.
[04:53:03] <asa22> because it is the simplest algorithm thats actually somewhat useful in some cases
[04:53:03] *** Quits: bsdbandit01 (~bsdbandit@2607:fb91:1492:eb5c:8136:9529:69d1:919e) (Read error: Connection reset by peer)
[04:53:12] <asa22> I dont wanna do caesarÂ  cipher is too boring and useless
[04:54:00] <MacGyver> Caesar is actually quite fun to mess with, because having a working caesar implementation also allows you to run attacks against it.
[04:54:12] <tusko> do Goldwasser-Micali PKC
[04:54:15] <MacGyver> Like, letter frequency finding and seeing how far you get.
[04:55:26] <MacGyver> As a programming practice project, I'd highly recommend it :)
[04:57:19] <asa22> I'll try that after Im done with the XOR one
[04:58:38] <asa22> btw MacGyver what did you mean by "OTP is the best XOR cipher"
[04:58:42] <asa22> shouldnt they all be the same
[04:59:39] <asa22> assuming the keys are used once, are pre-shared safely, and the message maintains integrity when transfered
[05:00:33] <MacGyver> That's a one-time pad.
[05:00:51] <MacGyver> Your assumptions aren't pre-assumed for the concept "xor cipher".
[05:00:56] <asa22> oh ok
[05:01:00] <MacGyver> In particular, key length may be shorter than the message.
[05:01:11] <asa22> I see I see
[05:01:47] <MacGyver> Or generated using any kind of cryptographically secure random number generator.
[05:01:56] <MacGyver> Rather than a "true" random number generator.
[05:02:34] * sarnold tunnels MacGyver's electrons
[05:02:52] <asa22> so I use the secrets.SystemRandom() functions in python
[05:03:12] <asa22> which accesses the most "random" randomness from the kernel of the OS
[05:03:17] <MacGyver> Only the one-time pad has this concept of "information-theoretic secrecy", which basically means that given infinite computational power, an attacker will still not be able to break it.
[05:03:47] <asa22> which I believe takes a pseudo random generator and feeds it things like user key presses, mouse movements, speeds of disk access
[05:03:56] <MacGyver> But that's a very particular definition of "break".
[05:03:59] <asa22> how are those things not random enough, who is gonna predict that
[05:04:29] *** Joins: bsdbandit01 (~bsdbandit@172.58.189.41)
[05:04:31] <MacGyver> Somebody who can bruteforce through all the possible internal states of that random number generator.
[05:04:40] <MacGyver> Which, *in practice*, is nobody.
[05:04:51] <MacGyver> Because the bounds are like 2^256 for stuff like that.
[05:04:58] <MacGyver> But it is *not* a one-time pad.
[05:05:00] <asa22> so in practice it is random enough for cryptographic purposes
[05:05:05] <asa22> I see
[05:05:19] <MacGyver> Well, except for the whole "It's malleable" part.
[05:05:20] *** Quits: bsdbandit01 (~bsdbandit@172.58.189.41) (Read error: Connection reset by peer)
[05:05:36] <MacGyver> And that we have much, much better ways of doing this, called "stream ciphers".
[05:06:31] <MacGyver> Which allow you to share only the 256 bits of key instead of this RNG output that's at least as long as the message.
[05:08:10] <MacGyver> (Also the system random number generators have been known to exhibit particular weaknesses in the past, such as when a whole buttload of routers generated pretty much the same ... I think it was SSH keys)
[05:08:30] <MacGyver> (Because they did so before the system RNG was properly initialized with 256 bits of "collected randomness".
[05:08:32] <MacGyver> )
[05:09:50] <asa22> yes that is because it will rather give bad randomness than freeze until it has enough entropy
[05:10:35] <asa22> for some reason it starts from zero each time the PC boots up
[05:10:44] <asa22> it should save some from the last time
[05:11:54] <asa22> ok so a stream cipher is the same as OTP but the key is a seed for a pseudo random generator
[05:12:04] <asa22> so its a short key
[05:12:12] <asa22> and there is no perfect secrecy
[05:13:12] <MacGyver> Yeah. Instead there is cryptographic security with a security bound usually pretty much exactly the key length, because at least when introduced the best attack against a cipher is "bruteforce the key". Any other kind of attack and the cipher never makes it to standard.
[05:13:17] <MacGyver> And don't get me wrong:
[05:13:41] <MacGyver> The security bounds of all modern cryptography are pretty much beyond the realm of *physical* possibility.
[05:14:29] <MacGyver> But an adversary with *infinite* computing power could break it in no time at all.
[05:14:50] <MacGyver> (And this is why we don't really care about the one-time pad. It doesn't give us anything useful, only headaches.)
[05:15:43] <asa22> well
[05:15:48] <asa22> I cant implement AES by myself
[05:15:49] <asa22> lol
[05:16:15] <rk4> i thought OTP has had critically important useful real world implementations
[05:16:49] <asa22> the navy probably uses it
[05:17:00] <MacGyver> rk4: Operative word: had.
[05:17:25] <MacGyver> I'd be amazed if the US still flies OTP key material around, but even then, it's not interesting.
[05:17:43] <rk4> https://en.wikipedia.org/wiki/One-time_pad#Historical_uses hmm more than i knew
[05:18:40] <rk4> OTP still seems a useful concept to me
[05:18:53] <MacGyver> Useful in what sense?
[05:18:54] <rk4> i would be amazed if it wasn't still in use somewhere :P
[05:19:04] <MacGyver> Because if it's anything other than "a teaching tool", sorry, but no.
[05:19:29] <MacGyver> The realization of the past two decades that we like our encrypted stuff to not be tampered with pretty much ended that.
[05:19:53] <asa22> I know NATO uses standard encryption for most confidential stuff except the very secret stuff thats also wrapped in another encryption on top which could be OTP
[05:20:11] <rk4> why can't there be tamper proof OTP systems? :)
[05:20:22] <rk4> resistent, i suppose i should say
[05:22:19] <asa22> ok how about this
[05:22:30] <asa22> you use some system that has authentication to send the data
[05:22:39] <asa22> and then, OTP
[05:22:55] <asa22> so like you encrypt it with OTP and then with something else on top
[05:22:59] <MacGyver> In *theory*, you can have that if you use universal hashing.
[05:23:15] <MacGyver> In *practice*, anything you do has a "modern cryptography sensible" security bound like 2^256.
[05:23:33] <MacGyver> So if you have that anyway, using a modern stream cipher is easier.
[05:24:30] <rk4> i think you are assuming the rest of the world thinks as you do, and would do things as you would
[05:24:40] <rk4> it's a big world ;)
[05:25:23] <MacGyver> Oh I *know* there are plenty of people who think they want to use a one-time pad and who think they've implemented a one-time pad securely.
[05:25:32] <MacGyver> They're wrong 99 out of 100 times.
[05:26:34] <rk4> there are plenty of people who make up symmetric ciphers and think they're secure, they're also wrong $N/$M times
[05:27:30] <MacGyver> Yes, which is why the actual ciphers you use have gone through an extensive peer review (and nowadays competition) process.
[05:28:07] <asa22> yall are welcome to try to break my OTP :P
[05:28:10] <rk4> anyway, i'm not speaking to people trying to implement something and doing something else instead
[05:28:43] <rk4> sure, lots of people claim to have an unbreakable OTP implementation, often it turns out to just be a contrived stream cipher, i don't really care about those people
[05:31:53] <rk4> my position is just that OTPs have use cases, i'm not saying it's a tool for every job, or even a common tool. but it's a thing, you should know about it. some might even wish for the properties it offers
[05:35:44] <rk4> this is all kind of a bullshit discussion though, because if either of use were using OTPs in a situation where it was a prudent and practical choice, we would not be the sorts to talk about it on IRC!
[05:36:36] <asa22> unless you were a soviet spy using reverse psychology
[05:37:03] * rk4 coughs *comrade stfu*
[05:38:08] *** Quits: asa22 (~asa22@84.125.126.149.dyn.user.ono.com) (Quit: Client closed)
[05:47:40] <rk4> i'm sure he'll be fine, the soviets have a good human rights record
[05:49:30] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Remote host closed the connection)
[05:50:39] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[05:57:17] *** Quits: rardiol (~quassel@user/rardiol) (Ping timeout: 240 seconds)
[06:02:26] *** Quits: TonyStone (~TonyStone@2603-7080-8607-c36a-9cdb-69bc-753b-1e50.res6.spectrum.com) (Remote host closed the connection)
[06:04:06] *** Joins: bsdbandit01 (~bsdbandit@2607:fb91:1492:eb5c:8136:9529:69d1:919e)
[06:05:03] *** Quits: bsdbandit01 (~bsdbandit@2607:fb91:1492:eb5c:8136:9529:69d1:919e) (Read error: Connection reset by peer)
[06:06:38] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Remote host closed the connection)
[06:07:01] *** Joins: TonyStone (~TonyStone@cpe-74-76-51-197.nycap.res.rr.com)
[06:08:54] *** Quits: DefiantN (~DefiantN@user/defiantn) (Quit: Leaving)
[06:09:06] *** Joins: bsdbandit01 (~bsdbandit@2607:fb91:1492:eb5c:8136:9529:69d1:919e)
[06:12:54] *** Quits: bsdbandit01 (~bsdbandit@2607:fb91:1492:eb5c:8136:9529:69d1:919e) (Read error: Connection reset by peer)
[06:14:11] *** Malvolio is now known as Guest9006
[06:14:11] *** Quits: Guest9006 (~Malvolio@user/malvolio) (Killed (molybdenum.libera.chat (Nickname regained by services)))
[06:14:55] *** Joins: Malvolio (~Malvolio@user/malvolio)
[06:23:08] *** Joins: bsdbandit01 (~bsdbandit@172.58.189.41)
[06:24:29] *** Quits: sdfgsdfg (~sdfgsdfg@user/sdfgsdfg) (Quit: ZzzZ)
[06:26:10] *** Quits: peterhil (~peterhil@dsl-hkibng32-54fb56-2.dhcp.inet.fi) (Remote host closed the connection)
[06:26:19] *** Quits: hlieberman__ (sid17492@id-17492.tinside.irccloud.com) (Ping timeout: 250 seconds)
[06:26:51] *** Quits: Mutsuhito (sid13530@id-13530.ilkley.irccloud.com) (Ping timeout: 264 seconds)
[06:27:01] *** Joins: peterhil (~peterhil@dsl-hkibng32-54fb56-2.dhcp.inet.fi)
[06:27:42] *** Quits: peterhil (~peterhil@dsl-hkibng32-54fb56-2.dhcp.inet.fi) (Remote host closed the connection)
[06:28:33] *** Joins: Mutsuhito (sid13530@id-13530.ilkley.irccloud.com)
[06:28:45] *** Joins: peterhil (~peterhil@dsl-hkibng32-54fb56-2.dhcp.inet.fi)
[06:29:30] *** Joins: hlieberman__ (sid17492@id-17492.tinside.irccloud.com)
[06:31:19] *** Quits: bsdbandit01 (~bsdbandit@172.58.189.41) (Read error: Connection reset by peer)
[06:43:02] *** Quits: Tom (~Tom@82-64-144-132.subs.proxad.net) (Read error: Connection reset by peer)
[06:58:15] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[06:58:26] *** Joins: bsdbandit01 (~bsdbandit@2607:fb91:1492:eb5c:8136:9529:69d1:919e)
[07:04:16] *** Quits: bsdbandit01 (~bsdbandit@2607:fb91:1492:eb5c:8136:9529:69d1:919e) (Read error: Connection reset by peer)
[07:16:00] *** Joins: frost (~frost@user/frost)
[07:32:45] <Alipha> I wrote an "authenticated OTP", where each bit is transformed into 128 bits. Which means to flip a bit, you have to correctly guess the 128 bits that corresponds to the opposite but value. This also means the key is 256x larger than the plaintext. https://github.com/alipha/aotp
[07:32:59] <Alipha> *opposite bit value
[07:58:08] <rk4> haha
[08:02:05] *** Joins: dude12312414 (~test@gateway/tor-sasl/dude12312414)
[08:03:05] *** Quits: dude12312414 (~test@gateway/tor-sasl/dude12312414) (Remote host closed the connection)
[08:33:15] *** Joins: blyat-73 (~hjgkjhgkj@46.235.96.249)
[08:35:54] *** Joins: riksteri (d20812115c@2604:bf00:561:2000::1e6)
[08:58:06] *** Quits: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani) (Ping timeout: 276 seconds)
[09:13:19] *** Joins: HifiKuno (~HifiKuno@167-179-170-202.a7b3aa.bne.nbn.aussiebb.net)
[09:24:28] *** Joins: drathir87 (~drathir@wireguard/tunneler/drathir)
[09:24:34] *** Joins: sdfgsdfg (~sdfgsdfg@user/sdfgsdfg)
[09:25:13] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Remote host closed the connection)
[09:25:16] *** drathir87 is now known as drathir_tor
[09:36:50] *** Joins: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani)
[09:38:47] *** Joins: BOKALDO (~BOKALDO@user/bokaldo)
[09:39:58] *** Joins: WarpedAI (~Warped@user/warped)
[09:42:17] *** Quits: hqdruxn08_ (~hqdruxn08@cpe-66-68-166-214.austin.res.rr.com) (Ping timeout: 240 seconds)
[09:42:43] *** Quits: Warped (~Warped@user/warped) (Ping timeout: 256 seconds)
[10:01:48] *** Quits: Sofia (~sofia@gateway/tor-sasl/sofia) (Ping timeout: 276 seconds)
[10:03:47] *** Quits: sdfgsdfg (~sdfgsdfg@user/sdfgsdfg) (Quit: ZzzZ)
[10:05:50] *** Joins: Sofia (~sofia@gateway/tor-sasl/sofia)
[10:28:41] *** Joins: sdfgsdfg (~sdfgsdfg@user/sdfgsdfg)
[10:29:09] *** Joins: Douwd (~douwd@crux.bsdpro.net)
[10:41:26] *** Quits: kish` (~sid742412@user/aqua) (Remote host closed the connection)
[10:41:47] *** Joins: kish` (~sid742412@user/aqua)
[10:51:17] *** Quits: ravan (~ravan@user/ravan) (Ping timeout: 256 seconds)
[10:54:53] *** Quits: electr0n (~electr0n@about/security/founder/electr0n) (Quit: WeeChat 3.3)
[10:57:39] *** Quits: tusko (~yeurt@copyfree/advocate/tusko) (Remote host closed the connection)
[10:58:00] *** Joins: tusko (~yeurt@copyfree/advocate/tusko)
[11:00:23] *** Quits: Deknos (~someone@user/menace) (Quit: Deknos)
[11:01:37] *** Joins: CryptoClub (~fafs@88.red-83-34-81.dynamicip.rima-tde.net)
[11:04:44] *** Joins: hqdruxn08 (~hqdruxn08@cpe-66-68-166-214.austin.res.rr.com)
[11:10:17] *** Quits: sdfgsdfg (~sdfgsdfg@user/sdfgsdfg) (Quit: ZzzZ)
[11:16:43] *** Joins: powftw (uid448161@id-448161.lymington.irccloud.com)
[11:35:00] *** Joins: andreasbuhr (~quassel@p549db299.dip0.t-ipconnect.de)
[11:35:00] *** Quits: andreasbuhr (~quassel@p549db299.dip0.t-ipconnect.de) (Client Quit)
[11:41:12] *** Joins: sdfgsdfg (~sdfgsdfg@user/sdfgsdfg)
[12:05:01] *** Quits: somlis (~somlis@user/somlis) (Read error: Connection reset by peer)
[12:07:18] *** Joins: Haohmaru (~Haohmaru@195.24.53.110)
[12:14:13] *** Joins: Guyver2 (~Guyver@guyver2.xs4all.nl)
[12:15:17] *** Joins: inlight (~inlight@157.35.62.139)
[12:15:17] *** Quits: inlight (~inlight@157.35.62.139) (Changing host)
[12:15:17] *** Joins: inlight (~inlight@user/inlight)
[12:16:21] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Ping timeout: 276 seconds)
[12:22:00] *** Joins: machinedgod (~machinedg@24.105.81.50)
[12:23:05] *** Joins: menace (~someone@ppp-93-104-175-20.dynamic.mnet-online.de)
[12:23:21] *** Quits: menace (~someone@ppp-93-104-175-20.dynamic.mnet-online.de) (Changing host)
[12:23:21] *** Joins: menace (~someone@user/menace)
[12:23:25] *** menace is now known as Deknos
[12:46:34] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[13:15:29] *** Joins: son0p (~ff@2800:484:1d81:b700:d40b:900:b387:320)
[13:19:29] *** Joins: PJBoy (~PJBoy@user/pjboy)
[13:23:58] *** Joins: etolier (~somewhere@122-199-43-68.ip4.superloop.com)
[13:24:21] *** etolier is now known as Guest9799
[13:25:23] *** Joins: gproto23 (~gproto23@user/gproto23)
[13:25:25] *** Quits: AsenMx (~AsenMx@user/asenmx) (Ping timeout: 240 seconds)
[13:26:23] *** Joins: AsenMx (~AsenMx@user/asenmx)
[13:46:39] *** Joins: Lord_of_Life_ (~Lord@user/lord-of-life/x-2819915)
[13:47:17] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 240 seconds)
[13:49:29] *** Lord_of_Life_ is now known as Lord_of_Life
[13:50:00] *** Joins: madagest (~madage@user/madage)
[13:53:51] *** Quits: madage (~madage@user/madage) (Ping timeout: 276 seconds)
[14:05:47] *** Joins: rardiol (~quassel@user/rardiol)
[14:09:45] *** Joins: rustycl0ck (~ircuser@gateway/tor-sasl/rustycl0ck)
[14:12:08] *** Joins: Nimrodel (~Nimrodel@athedsl-59422.home.otenet.gr)
[14:27:38] *** Quits: sdfgsdfg (~sdfgsdfg@user/sdfgsdfg) (Quit: ZzzZ)
[15:01:40] *** Joins: sdfgsdfg (~sdfgsdfg@user/sdfgsdfg)
[15:02:03] *** Joins: somlis (~somlis@user/somlis)
[15:16:45] *** Quits: dez (uid92154@user/dez) (Quit: Connection closed for inactivity)
[15:22:31] *** Joins: ioxzev1z (~ioxzev1z@user/ioxzev1z)
[15:26:22] *** Quits: powftw (uid448161@id-448161.lymington.irccloud.com) (Quit: Connection closed for inactivity)
[15:35:25] *** Quits: Nimrodel (~Nimrodel@athedsl-59422.home.otenet.gr) (Quit: Leaving)
[15:41:25] *** Quits: Hash (~Hash@hashsecurity.org) (Quit: https://hashsecurity.org)
[15:45:43] *** Joins: Everything (~Everythin@37.115.210.35)
[15:52:09] *** Quits: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani) (Ping timeout: 276 seconds)
[15:55:57] *** Quits: inlight (~inlight@user/inlight) (Ping timeout: 240 seconds)
[15:58:16] *** Quits: Guest9799 (~somewhere@122-199-43-68.ip4.superloop.com) (Quit: No Ping reply in 180 seconds.)
[15:59:38] *** Joins: etolier (~somewhere@122-199-43-68.ip4.superloop.com)
[15:59:48] *** Joins: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani)
[16:00:02] *** etolier is now known as Guest4472
[16:11:36] *** Joins: dez (uid92154@user/dez)
[16:23:10] *** Joins: inlight (~inlight@157.35.62.139)
[16:23:10] *** Quits: inlight (~inlight@157.35.62.139) (Changing host)
[16:23:10] *** Joins: inlight (~inlight@user/inlight)
[16:29:55] *** Quits: caveman (~caveman@gateway/tor-sasl/caveman) (Remote host closed the connection)
[16:30:48] *** Joins: caveman (~caveman@gateway/tor-sasl/caveman)
[16:31:23] *** Quits: Guyver2 (~Guyver@guyver2.xs4all.nl) (Quit: Going offline, see ya! (www.adiirc.com))
[16:34:05] *** Joins: Klotz (~Klotzoman@gateway/tor-sasl/klotz)
[16:34:17] *** Quits: inlight (~inlight@user/inlight) (Ping timeout: 252 seconds)
[16:54:30] <MacGyver> Alipha: But still only 2^128 security margin, right? :P
[16:54:43] *** Quits: machinedgod (~machinedg@24.105.81.50) (Ping timeout: 268 seconds)
[16:57:49] *** Quits: llorllale (~llorllale@2607:9880:3a18:69:c959:9e8d:b7ca:4f4d) (Ping timeout: 240 seconds)
[16:58:08] <maroon> and the entire alpha centauri solar system as the storage space?
[16:58:42] *** Quits: blyat-73 (~hjgkjhgkj@46.235.96.249) (Remote host closed the connection)
[16:58:50] <MacGyver> maroon: Nah, the key is a simple *256, not ^256.
[16:58:58] <MacGyver> It's tractable.
[16:59:13] <MacGyver> Just send over 256 planes with key material instead of one.
[17:00:06] *** Joins: blyat-73 (~hjgkjhgkj@46.235.96.249)
[17:00:30] *** Quits: blyat-73 (~hjgkjhgkj@46.235.96.249) (Remote host closed the connection)
[17:00:52] *** Joins: blyat-73 (~hjgkjhgkj@46.235.96.249)
[17:00:58] *** Joins: powftw (uid448161@id-448161.lymington.irccloud.com)
[17:03:06] *** Joins: inlight (~inlight@157.35.62.139)
[17:03:06] *** Quits: inlight (~inlight@157.35.62.139) (Changing host)
[17:03:06] *** Joins: inlight (~inlight@user/inlight)
[17:09:37] *** Quits: inlight (~inlight@user/inlight) (Ping timeout: 240 seconds)
[17:10:11] *** Joins: inlight (~inlight@user/inlight)
[17:12:23] *** Joins: namkeleser (~namkelese@101.179.128.103)
[17:13:57] *** Quits: gproto23 (~gproto23@user/gproto23) (Ping timeout: 240 seconds)
[17:14:44] *** Joins: ses (uid38151@id-38151.hampstead.irccloud.com)
[17:24:05] *** Quits: namkeleser (~namkelese@101.179.128.103) (Quit: Client closed)
[17:27:26] *** Quits: frost (~frost@user/frost) (Ping timeout: 245 seconds)
[17:29:24] *** Joins: Hash (~Hash@2001:470:f0b6::5)
[17:33:11] *** Joins: gproto23 (~gproto23@user/gproto23)
[17:37:54] *** Joins: zer0bitz (~zer0bitz@dsl-hkibng32-54fbfb-173.dhcp.inet.fi)
[17:49:24] *** Quits: sdfgsdfg (~sdfgsdfg@user/sdfgsdfg) (Read error: Connection reset by peer)
[17:50:31] *** Quits: cwebber (~user@user/cwebber) (Remote host closed the connection)
[17:50:40] *** Joins: sdfgsdfg (~sdfgsdfg@user/sdfgsdfg)
[18:00:57] *** Quits: inlight (~inlight@user/inlight) (Ping timeout: 240 seconds)
[18:02:10] *** Joins: inlight (~inlight@157.35.65.219)
[18:02:10] *** Quits: inlight (~inlight@157.35.65.219) (Changing host)
[18:02:10] *** Joins: inlight (~inlight@user/inlight)
[18:07:21] *** Quits: rustycl0ck (~ircuser@gateway/tor-sasl/rustycl0ck) (Ping timeout: 276 seconds)
[18:09:39] <Alipha> MacGyver: indeed. But it's super simple and plainly obvious that it's impossible to get under that 2^128 security margin (assuminga source of true randomness), both properties that I'm sure the "OTP enthusiasts" would love
[18:09:53] *** Joins: namkeleser (~namkelese@101.179.128.103)
[18:11:18] *** Parts: Everything (~Everythin@37.115.210.35) ()
[18:11:18] <MacGyver> Well there is an easy way to get under that security margin, but it involves lots of guns.
[18:11:33] <MacGyver> Also 256 planes to intercept undetected instead of one, I guess.
[18:11:43] <MacGyver> But still, less work than 2^128.
[18:12:28] <Alipha> Lol
[18:17:45] *** Quits: sdfgsdfg (~sdfgsdfg@user/sdfgsdfg) (Quit: ZzzZ)
[18:19:40] <Alipha> MacGyver: and recently, I came up with a very similar technique to create an authentication tag using only a symmetric cipher: for each bit in the message to authenticate, generate two 128-bit blocks of keystream. If the message bit is a 0, select the first 128-bit block. If 1, select the other. Then xor all the selected 128-bit blocks together as your auth tag
[18:20:00] <Alipha> I wrote code for this. I should find it.
[18:20:01] <ms7821> https://github.com/alipha/aotp/blob/master/aotp-dec.c#L99 is this not functionally the same as word_0 = encrypted_words[0] ^ otp_words[0]... word_1 = encrypted_words[0] ^ otp_words[4]...
[18:20:03] <MacGyver> Alipha: That sounds an *awful* lot like hash-based signatures.
[18:20:53] *** Joins: Guyver2 (Guyver@guyver2.xs4all.nl)
[18:21:04] <Alipha> MacGyver: oh, really? I feel a little proud now to come up with that, because I have no idea how hash-based signatures work ;-)
[18:22:38] <ms7821> also I think nonzero_count logic is wrong
[18:22:53] <MacGyver> Alipha: Read "signing the message" on https://en.wikipedia.org/wiki/Lamport_signature
[18:22:57] <ms7821> (I get that this is a toy cipher but it's not super clear how it works)
[18:24:23] <MacGyver> Funny how you can just stumble upon a near-adjacent construction :)
[18:26:51] *** Quits: Klotz (~Klotzoman@gateway/tor-sasl/klotz) (Ping timeout: 276 seconds)
[18:26:56] *** Quits: namkeleser (~namkelese@101.179.128.103) (Quit: Client closed)
[18:29:25] *** Joins: Klotz (~Klotzoman@gateway/tor-sasl/klotz)
[18:33:56] *** Joins: igemnace (~ian@user/igemnace)
[18:42:38] <Alipha> ms7821: do you understand how the encryption works? And yes, it's hard to follow because I tried to make it as time constant as possible. Indeed, it would have been simpler to have otp_words[0..3] correspond to a 0 bit in the plaintext and otp_words[4..7] correspond to the 1 bit. But then during encrypting, that would have caused a memory access pattern that would be dependent upon the plaintext (you'd access
[18:42:40] <Alipha> the first 4 words if the plaintext is 0 or the second 4 if the plaintext is 1). And so, instead, I opted to interleave the words together on a bit level, so that you're always accessing all of otp_words[0..7], with the odd numbered bits corresponding to the 0 bit in the plaintext and the even numbered corresponding to a 1 bit in the plaintext
[18:46:08] *** Joins: shayr (shayr@ip62.ip-91-134-189.eu)
[18:47:31] <ms7821> Alipha: ahh, that could have done with a comment, makes sense
[18:49:18] <Alipha> What? Comment my own personal code??? ;-)
[18:49:22] <ms7821> heh
[18:49:49] <ms7821> and thinking about it, the nonzero_count is only an issue if the attacker can guess the full key for a chunk
[18:49:57] <ms7821> which is probably unlikely
[18:50:13] <Alipha> Indeed, I should transform what I just wrote into a comment.
[18:52:02] <Alipha> My TODO comment is probably referring more so to the if statement under it
[18:53:29] <Alipha> As that if statement tells you if the plaintext bit is 0 or 1
[19:25:54] *** Joins: lithiumpt (~lithiumpt@217.138.203.167)
[19:37:43] *** Quits: ionface (~ionface@user/ionface) (Ping timeout: 256 seconds)
[19:38:06] *** Joins: ionface (~ionface@user/ionface)
[19:39:18] *** Joins: arjun (~arjun@user/arjun)
[19:42:15] *** Quits: lord| (~lordpipe@user/lordpipe) (Ping timeout: 256 seconds)
[19:48:48] *** Joins: Guyver2_ (~Guyver@guyver2.xs4all.nl)
[19:49:17] *** Quits: Guyver2 (Guyver@guyver2.xs4all.nl) (Ping timeout: 240 seconds)
[19:49:20] *** Guyver2_ is now known as Guyver2
[19:59:09] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Ping timeout: 276 seconds)
[20:04:47] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[20:10:38] <Alipha> btw, here's my code that uses AES-CBC to both encrypt and create an auth tag (without using CBC-MAC, but instead the algorithm i described above): https://gist.github.com/alipha/2cd77bfd1a7a46f38341617019c7b652
[20:14:05] *** Quits: arjun (~arjun@user/arjun) (Quit: Leaving)
[20:30:41] *** Quits: powftw (uid448161@id-448161.lymington.irccloud.com) (Quit: Connection closed for inactivity)
[20:35:18] *** Joins: zxrqmz88 (~private@2603-7000-1302-b6f3-99b9-c40f-27d9-40cb.res6.spectrum.com)
[20:38:48] *** Quits: Sofia (~sofia@gateway/tor-sasl/sofia) (Ping timeout: 276 seconds)
[20:52:02] *** Joins: Sofia (~sofia@gateway/tor-sasl/sofia)
[21:00:04] *** Joins: Swemole (~Swemole@meta.ros.sgsnet.se)
[21:05:05] *** Quits: Haohmaru (~Haohmaru@195.24.53.110) ()
[21:10:01] *** Joins: tradar (~tradar@user/tradar)
[21:21:20] *** Joins: byteskeptical (~amnesia@user/byteskeptical)
[21:24:18] *** Quits: tradar (~tradar@user/tradar) (Ping timeout: 276 seconds)
[21:24:39] *** Joins: tradar (~tradar@user/tradar)
[21:28:57] *** Quits: Deknos (~someone@user/menace) (Quit: Deknos)
[21:29:30] *** Quits: tradar (~tradar@user/tradar) (Client Quit)
[21:31:17] *** Quits: inlight (~inlight@user/inlight) (Ping timeout: 252 seconds)
[21:37:06] *** Joins: aleck (~aleck@user/aleck)
[21:38:16] *** Quits: aleck1 (~aleck@user/aleck) (Ping timeout: 245 seconds)
[21:40:16] *** Joins: lord| (~lordpipe@user/lordpipe)
[21:40:35] <ioxzev1z> Alipha, just curious why you're doing it like that when iirc OTP is just for(size_t i = 0; i < message_size; ++i) { ciphertext[i] = message[i] ^ pad[i]; } ?
[21:41:39] <ioxzev1z> Isn't anything other than that a non-OTP?
[21:43:12] <ioxzev1z> Or am I missing something here?
[21:44:10] <ioxzev1z> OTP is perfect because there is no information in the ciphertext to know whether you've decrypted it correctly, but if you use any other cipher there is then enough information to know whether the key (pad in this case) used is correct, no?
[21:45:24] *** Quits: Gallomimia (~Gallomimi@2001:56a:fa4b:ca00:170c:6dc2:644f:5237) (Remote host closed the connection)
[21:45:55] <iz> well, if you don't know what the plaintext is suppose to be, no
[21:46:29] *** Joins: Gallomimia (~Gallomimi@node-1w7jra2a2gqpwv1vq8pvi9z7l.ipv6.telus.net)
[21:46:50] <iz> there are a huge number of incorrect keys that would give you every possible sane message of the same length
[21:46:52] <ioxzev1z> iz, sure, but given ciphertext C, and you decrypt with key K to the word "Hello", theres a good chance that K is correct. Given OTP C, it can be decrypted to any 5 letter word with absolutely no clue whether it's correct
[21:47:03] <iz> yeah
[21:48:19] <iz> it also might be the word "Later"  or "gerbil"  or "Bye!!"
[21:48:23] <ioxzev1z> Right
[21:48:36] <ioxzev1z> Not gerbil, that's 6 letters xD
[21:48:41] <iz> heh oh yeah
[21:48:54] <iz> mouse
[21:54:06] <Alipha> ioxzev1z: are you referring to my c++ code or my java code?
[21:54:30] <ioxzev1z> The one discussing otp, can't remember which language it was
[21:55:50] <Alipha> ioxzev1z: https://github.com/alipha/aotp i assume then. and the traditional OTP construct isn't authenticated, so that's why mine is different
[21:57:16] <ioxzev1z> Alipha, but OTP only works because there is no information. When you start adding information to check whether the ciphertext is correct you lose the benefits of OTP
[21:58:05] <ioxzev1z> Given C as a OTP, you have no information about M or P.
[21:58:20] *** Quits: gproto23 (~gproto23@user/gproto23) (Remote host closed the connection)
[21:58:54] <MacGyver> ioxzev1z: That's not *entirely* true; iirc if you do universal hashing you retain the information-theoretic security of the secrecy but your authenticity bound is finite.
[21:59:15] <MacGyver> But it's probably true for Alipha's construction -- but we already established that that has a 2^128 security bound.
[21:59:51] *** Quits: kulak (~kulak@user/kulak) (Quit: kulak)
[22:00:00] <ioxzev1z> I'd have to ask why mess wtih existing OTP when you can just use something like AES or ChaCha20 for encryption, considering that they are deemed secure enough to not be breakable
[22:00:25] <MacGyver> I assumed it was to prove the point that all this is OTP-fanboy-wank.
[22:01:01] <ioxzev1z> what point?
[22:01:26] <MacGyver> Why use modern cryptography if you can achieve the same thing with keys that are 256 times the size of your message?
[22:01:31] <MacGyver> That point.
[22:01:31] <ioxzev1z> oic
[22:02:57] <ioxzev1z> Alipha, when you add any extra information to OTP it becomes the weakest link in the chain. You're not making anything more secure
[22:04:11] <Alipha> ioxzev1z: OTP is malleable. Mine is not (with 2^128 security margin)
[22:05:04] <Alipha> So, yes, I reduce the confidentiality from "infinite" to 2^128, but I add authentication
[22:05:05] *** PJBoy is now known as Guest8573
[22:05:05] *** Quits: Guest8573 (~PJBoy@user/pjboy) (Killed (tungsten.libera.chat (Nickname regained by services)))
[22:05:18] <ioxzev1z> ...
[22:05:24] *** Joins: PJBoy (~PJBoy@user/pjboy)
[22:05:56] <ioxzev1z> That makes no sense. why not just c = m ^ p; h = h(c), then use h to determine if the message has been tampered with
[22:06:17] <Alipha> What's h?
[22:06:28] <ioxzev1z> h = H(c), where H is some hash function
[22:06:40] <ioxzev1z> No matter what you do, when you add information to OTP you weaken it
[22:08:03] <Alipha> But "some hash function" is complex and scary and simple minds (ie, OTP enthusiasts) don't understand how it works
[22:08:12] <ioxzev1z> ( ._.) wat.
[22:08:17] <MacGyver> ioxzev1z: You still don't seem to see.
[22:08:26] <MacGyver> Alipha: Based on your earlier comment that it has properties that "OTP enthusiasts" would love I assume that these are mostly ironic toys to throw in the face of OTP-fanboys, right.
[22:08:40] <MacGyver> ioxzev1z: ^ Irony. They're not *meant* to make sense.
[22:09:02] <MacGyver> ioxzev1z: Hence, "Why use modern cryptography if you can achieve the same thing with keys that are 256 times the size of your message?"
[22:09:03] <ioxzev1z> Also not sure if that's at me but I'm not a OTP fanboy
[22:09:37] <MacGyver> ioxzev1z: And I'm not saying you are, but you're misinterpreting the "purpose" of these things.
[22:09:45] <ioxzev1z> MacGyver, what is the purpose?
[22:10:06] <MacGyver> I just told you.
[22:10:22] <Alipha> ioxzev1z: the point of this TOY cipher is to appeal to the same people who say "OTP is the greatest"
[22:11:30] <ioxzev1z> Alipha, OTP is actually the greatest if you don't care about pad length
[22:11:51] <MacGyver> Well no.
[22:11:53] <ioxzev1z> If you don't want a 4GiB pad for a 4GiB message then go with AES or something
[22:11:57] <MacGyver> Because we care about malleability.
[22:12:49] <Alipha> OTP is the greatest if you don't care about malleability. which means, it actually completely sucks
[22:13:37] <iz> and ignore the part about how the key gets transfered
[22:13:57] <MacGyver> iz: Nothing wrong with a good old Boeing key negotiation protocol.
[22:13:58] <iz> and if you have a secure way to do that, why not just send the message that way
[22:14:54] <MacGyver> Though I guess you could stuff more key material in an Airbus.
[22:38:24] *** eck is now known as tiktoknull
[22:43:08] *** Joins: electr0n (~electr0n@about/security/founder/electr0n)
[22:43:15] *** Joins: gildasio (~gildasio@gateway/tor-sasl/gildasio)
[22:50:37] *** Quits: gildasio (~gildasio@gateway/tor-sasl/gildasio) (Remote host closed the connection)
[22:51:00] *** Joins: gildasio (~gildasio@gateway/tor-sasl/gildasio)
[22:53:22] <Swemole> Noticed you guys mentioning malleability: For anyone who hasn't: Read up on HMAC and "sufficiently indepent keys".
[22:58:19] <Swemole> That is the standard solution to prevent malleability.
[23:00:31] <maroon> you mean keyed hmac using a key unrelated to the cipher key?
[23:01:59] <Swemole> maroon: Yes, sort of.
[23:02:53] <Swemole> But with a "sufficiently unrelated key" I mean you make a key for both the cipher and the HMAC from one key, but you can fairly easily make the two produce keys "sufficiently unrelated".
[23:03:05] <Swemole> So you only need to have one key from the beginning.
[23:03:27] <Swemole> *produced keys
[23:03:47] <Swemole> I noticed over the years that many people don't know about these methods.
[23:04:16] <maroon> with HKDF, you can start with a master key and then turn the output into something like an XOF, then use part of the output string as the cipherkey and another portion as the MAC key
[23:04:43] <Swemole> exactly.
[23:05:50] <yawkat> or just use gcm
[23:07:22] <maroon> when using gcm, is the length of the ciphertext still increased by the length of a MAC? i.e. message length is salt||ciphertext||MAC ?
[23:08:12] <Alipha> maroon: yes
[23:09:55] <Swemole> I just took a quick look at GCM. It looks similar to a authenticated encryption mode I designed many ears ago. :)
[23:11:12] <Swemole> But I usually prefer to use stream ciphers. And then of course use HMAC with them.
[23:12:01] <yawkat> or just use poly1305
[23:13:17] <MacGyver> For all intents and purposes, GCM *is* a stream cipher.
[23:13:55] <Swemole> Och, now I looked closer. And remember why I made my own design. I had forgot: GCM is a bit inefficient.
[23:13:55] <MacGyver> It just hides it from you.
[23:14:00] <ioxzev1z> MacGyver, curious but does AES-GCM use the same size blocks as AES? iirc ChaCha20 works on bytes, but AES works on 16 byte blocks?
[23:14:16] <ioxzev1z> Maybe I misunderstood
[23:14:44] <yawkat> AES-GCM works like CTR mode for encryption which is a lot like a stream cipher.
[23:15:15] <MacGyver> ioxzev1z: Chacha20 also generates its keystream in blocks of 512 bits.
[23:15:20] <Swemole> I agree it sort of is a stream cipher, since it sort of is a CTR mode.
[23:15:22] <maroon> chacha seems like a hybrid block cipher that behaves like a stream. the 512-bit internal state for chacha makes it look a lot like a 512-bit block cipher
[23:15:45] <Swemole> (I meant GCM mode in my last comment.)
[23:15:59] <ioxzev1z> MacGyver, ah, thanks. Always assumed that stream ciphers worked via m ^ c, where m and c are then incremented in bytes
[23:16:00] <MacGyver> The distinction between block and stream ciphers has become a bit muddy in the era of AEAD.
[23:16:29] <MacGyver> ioxzev1z: They do, so it works on bytes.
[23:16:38] <MacGyver> ioxzev1z: But it generates the keystream in blocks of 512 bits.
[23:16:48] <ioxzev1z> Thanks
[23:16:51] <MacGyver> ioxzev1z: But that's also the reason why I say that AES-GCM is a stream cipher.
[23:17:01] <MacGyver> ioxzev1z: And so is CTR mode for any block cipher.
[23:17:22] <MacGyver> The difference being that you don't run *message* blocks through the cipher algorithm.
[23:17:31] <Swemole> Well, stream ciphers have always come in many weird variants. Some mix in the crypto text too, and some are not byte sized but are bit sized or other "block" size.
[23:18:41] <ioxzev1z> MacGyver, so AES-GCM isn't some frankencipher that was adapted after AES became widespread, but it's a mode that's easy to add to AES?
[23:19:09] <MacGyver> ioxzev1z: For relative interpretations of "easy", but yes, it's probably the most well-known authenticated mode of operation.
[23:19:20] <ioxzev1z> I assumed stream ciphers didn't need padding if they worked on octets at a time, e.g. 7 byte message doesn't have to be padded
[23:19:38] <ioxzev1z> uh, s/7/17
[23:19:48] <ioxzev1z> With AES you probably need to pad a plaintext of 17 bytes
[23:20:11] <Swemole> ioxzev1z: Correct, jag is usually true, most stream ciphers don't need padding.
[23:20:24] <yawkat> you dont need padding for AES-GCM
[23:20:30] <Swemole> And that is why CTR mode is so popular since it means also a block cipher doesn't need padding.
[23:20:32] <MacGyver> ioxzev1z: Well no, GCM doesn't pad the plaintext for encryption.
[23:20:46] <Swemole> * Correct, that is
[23:20:54] <maroon> your decryptor needs a way to 100% identify the amount of padding to remove, so you need to have at least 1 byte of padding to convey that info, unless you have a situation like utf8 text which can't have any 0x00's, so your padding could be 0-(blocksize-1) 0x00 bytes
[23:20:55] <MacGyver> It *does* pad the associated data and the ciphertext because it has to run them through the GHASH.
[23:20:58] <ioxzev1z> MacGyver, but using plain AES-CBC, etc would need padding for 17 byte plaintext
[23:21:30] <MacGyver> Yes.
[23:22:08] <MacGyver> Though there are tricks you can do to avoid that.
[23:22:22] <MacGyver> But tricks are complexity.
[23:22:45] *** Joins: machinedgod (~machinedg@173.231.123.211)
[23:23:56] <MacGyver> (Ciphertext stealing is one)
[23:23:58] <maroon> with cbc without padding, you can either use ciphertext stealing, which i dont completely understand, and especially how to do it when the message itself is shorter than 1 block - or mebbe you can switch to CFB mode for the final block if it's not a full blocksize
[23:27:23] <Swemole> Yeah, "ciphertext stealing" is a bit tricky to understand.
[23:29:28] *** Quits: BOKALDO (~BOKALDO@user/bokaldo) (Quit: Leaving)
[23:29:35] <Swemole> But many block ciphers have to small block sizes for good authentication anyway. So CTR mode or a stream cipher and then HMAC is better and simpler in the end.
[23:30:43] <maroon> for a normal mac that's not baked into the encryption like AEAD, it doesn't know and doesnt care what the cipher is, or what the block length is - it just mac's the data
[23:31:02] *** Quits: byteskeptical (~amnesia@user/byteskeptical) (Remote host closed the connection)
[23:31:24] <Swemole> And especially if you use layered ciphers (I am not sure I remember the name right). That is, put two or more ciphers on top of each other with no meta data in between.
[23:32:03] <Swemole> maroon: Exactly.
[23:34:35] <maroon> i assume because of MITM, that doing multiple encryptions with 3 different ciphers of the same blocksize would be no different than 3 layers using the same cipher
[23:35:39] <Swemole> maroon: Almost true: But if one of cipher turns out to be week, it is better to use different ciphers for the different layers.
[23:36:10] <Swemole> * weak
[23:36:29] *** Joins: byteskeptical (~amnesia@user/byteskeptical)
[23:36:49] <Swemole> Wait, what do you mane MITM has to do with it? (Man in the middle?)
[23:36:53] <Swemole> * mean
[23:37:02] <maroon> meet in the middle
[23:37:10] <Swemole> Ah.
[23:38:22] <Swemole> Well, still, using different ciphers are better in case on is broken. Also, means brute forcing a somewhat broken cipher on special hardware becomes more expensive since then the attacker needs special hardware for both ciphers.
[23:38:38] *** Quits: gildasio (~gildasio@gateway/tor-sasl/gildasio) (Quit: WeeChat 3.3)
[23:40:18] <Swemole> I have the habit of using one layer with some well known cipher that the customer likes, and another layer with some cipher that I like. :)
[23:40:44] <Alipha> maroon: oh, so, to answer your meet in the middle attack question from yesterday, using 4 64-bit keys would be either 2^128 time with 2^128 space, or 2^192 time with 2^64 space.
[23:41:08] *** Joins: inlight (~inlight@157.35.69.112)
[23:41:08] *** Quits: inlight (~inlight@157.35.69.112) (Changing host)
[23:41:08] *** Joins: inlight (~inlight@user/inlight)
[23:41:30] <Alipha> actually, i believe you can do any of "2^(256-n) time and 2^n space" for 0 <= n <= 128
[23:42:00] <MacGyver> Alipha: The formula on the multi-dimensional MITM attack looked a bit more complex than that to me.
[23:42:06] <maroon> what's the 'space' for all storage space on earth, in relation to 2^128?
[23:42:38] <MacGyver> Looked like there was some kind of diminishing returns going on.
[23:43:48] <maroon> yeah, it had 2 formulas, and the 2nd one is the max resistance to MITM, which caps out at something like 2x 2^128 complexity for infinite layers of a 128-bit cipher
[23:44:24] <maroon> that doesnt sound right, maybe it was 2x 2^256
[23:45:22] <Alipha> maroon: https://www.quora.com/How-many-gigabytes-of-storage-are-in-the-whole-world estimates to be around 2^70 combined drive space in the world
[23:46:28] <maroon> so 2^64 space is unrealistic for an attacker
[23:47:15] *** Joins: CryptoDavid (uid14990@id-14990.uxbridge.irccloud.com)
