[00:12:45] *** Quits: burnsidesLlama (~burnsides@dhcp168-031.wadham.ox.ac.uk) (Remote host closed the connection)
[00:50:44] *** Joins: burnsidesLlama (~burnsides@dhcp168-031.wadham.ox.ac.uk)
[00:55:50] *** Quits: burnsidesLlama (~burnsides@dhcp168-031.wadham.ox.ac.uk) (Ping timeout: 272 seconds)
[01:29:21] *** Joins: burnsidesLlama (~burnsides@dhcp168-031.wadham.ox.ac.uk)
[01:36:22] *** Quits: burnsidesLlama (~burnsides@dhcp168-031.wadham.ox.ac.uk) (Ping timeout: 272 seconds)
[01:46:19] *** Joins: coot_ (~coot@2a02:a310:e241:1b00:ec1a:e9df:79ac:66ba)
[01:48:36] *** Quits: coot (~coot@213.134.190.95) (Ping timeout: 240 seconds)
[02:14:35] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Quit: ec)
[02:39:04] *** Quits: __monty__ (~toonn@user/toonn) (Quit: leaving)
[02:47:36] *** Quits: coot_ (~coot@2a02:a310:e241:1b00:ec1a:e9df:79ac:66ba) (Quit: coot_)
[02:51:28] *** Quits: lambdabot (~lambdabot@haskell/bot/lambdabot) (*.net *.split)
[02:53:46] *** Joins: lambdabot (~lambdabot@haskell/bot/lambdabot)
[02:58:37] *** Joins: burnsidesLlama (~burnsides@dhcp168-031.wadham.ox.ac.uk)
[03:03:00] *** Quits: burnsidesLlama (~burnsides@dhcp168-031.wadham.ox.ac.uk) (Ping timeout: 240 seconds)
[03:14:54] *** Joins: burnsidesLlama (~burnsides@dhcp168-031.wadham.ox.ac.uk)
[03:50:24] *** Quits: shapr (~user@pool-173-73-44-186.washdc.fios.verizon.net) (Remote host closed the connection)
[03:50:38] *** Joins: shapr (~user@pool-173-73-44-186.washdc.fios.verizon.net)
[04:01:19] *** Quits: geekosaur (~geekosaur@xmonad/geekosaur) (Remote host closed the connection)
[04:03:11] *** Joins: geekosaur (~geekosaur@xmonad/geekosaur)
[05:10:15] <shapr> Anyone using nixpkgs-unstable and postgresql-query?
[05:52:27] <shapr> I got it working
[05:53:06] <shapr> Is there a table for postgresql-simple that has "suggested postgresql column type for defined ToField instances" ?
[08:14:09] *** Joins: burnside_ (~burnsides@client-8-91.eduroam.oxuni.org.uk)
[08:14:10] *** Quits: burnsidesLlama (~burnsides@dhcp168-031.wadham.ox.ac.uk) (Remote host closed the connection)
[08:18:12] *** Quits: burnside_ (~burnsides@client-8-91.eduroam.oxuni.org.uk) (Ping timeout: 240 seconds)
[10:27:35] *** Joins: coot (~coot@213.134.190.95)
[11:42:11] *** Quits: vglfr (~vglfr@coupling.penchant.volia.net) (Read error: Connection reset by peer)
[11:42:43] *** Joins: vglfr (~vglfr@coupling.penchant.volia.net)
[12:15:25] *** Quits: vglfr (~vglfr@coupling.penchant.volia.net) (Read error: Connection reset by peer)
[12:16:22] *** Joins: vglfr (~vglfr@coupling.penchant.volia.net)
[12:25:24] *** Quits: vglfr (~vglfr@coupling.penchant.volia.net) (Read error: Connection reset by peer)
[12:26:13] *** Joins: vglfr (~vglfr@coupling.penchant.volia.net)
[12:30:23] *** Quits: vglfr (~vglfr@coupling.penchant.volia.net) (Read error: Connection reset by peer)
[12:30:35] *** Joins: vglfr (~vglfr@coupling.penchant.volia.net)
[12:46:37] *** Quits: vglfr (~vglfr@coupling.penchant.volia.net) (Read error: Connection reset by peer)
[12:47:17] *** Joins: vglfr (~vglfr@coupling.penchant.volia.net)
[12:49:24] *** Quits: vglfr (~vglfr@coupling.penchant.volia.net) (Read error: Connection reset by peer)
[12:50:05] *** Joins: vglfr (~vglfr@coupling.penchant.volia.net)
[12:57:03] *** Quits: vglfr (~vglfr@coupling.penchant.volia.net) (Read error: Connection reset by peer)
[12:57:10] *** Joins: vglfr (~vglfr@coupling.penchant.volia.net)
[13:03:24] *** Quits: vglfr (~vglfr@coupling.penchant.volia.net) (Read error: Connection reset by peer)
[13:04:32] *** Joins: vglfr (~vglfr@coupling.penchant.volia.net)
[13:37:42] *** Joins: __monty__ (~toonn@user/toonn)
[19:40:15] *** Quits: coot (~coot@213.134.190.95) (Quit: coot)
[19:44:16] *** Joins: burnsidesLlama (~burnsides@dhcp168-021.wadham.ox.ac.uk)
[19:44:21] *** Quits: burnsidesLlama (~burnsides@dhcp168-021.wadham.ox.ac.uk) (Remote host closed the connection)
[19:44:28] *** Joins: burnsidesLlama (~burnsides@dhcp168-021.wadham.ox.ac.uk)
[19:44:51] *** Quits: burnsidesLlama (~burnsides@dhcp168-021.wadham.ox.ac.uk) (Remote host closed the connection)
[19:45:30] *** Joins: burnsidesLlama (~burnsides@dhcp168-021.wadham.ox.ac.uk)
[20:52:50] *** Quits: burnsidesLlama (~burnsides@dhcp168-021.wadham.ox.ac.uk) (Remote host closed the connection)
[20:53:17] *** Joins: burnsidesLlama (~burnsides@dhcp168-021.wadham.ox.ac.uk)
[20:57:24] *** Quits: burnsidesLlama (~burnsides@dhcp168-021.wadham.ox.ac.uk) (Ping timeout: 240 seconds)
[21:13:50] <shapr> postgresql-simple lessons learned so far: if you fill values into defaultConnectInfo, use the new value you produced, because defaultConnectInfo still does not know how to talk to your database :facepalm:
[21:14:21] <shapr> most of the snags I've hit so far were accidental complexity
[21:15:03] <shapr> I still haven't found a table that matches types for Haskell <-> PostgreSQL
[21:16:26] <shapr> best I've found is from https://hackage.haskell.org/package/postgresql-simple-0.6.4/docs/Database-PostgreSQL-Simple-FromField.html where it says things like "A Haskell numeric type is considered to be compatible with all PostgreSQL numeric types that are less accurate than it"
[21:18:02] *** Joins: janus (janus@anubis.0x90.dk)
[21:18:05] <shapr> hi janus !
[21:18:08] * shapr hugs janus 
[21:18:53] <shapr> I've been grumbling about postgresql-simple for days in here
[21:18:57] * janus hugs everyone, ripping his arms out of his torso, trying to make them stretch far enough
[21:19:01] <shapr> argh!
[21:19:15] <janus> oops :P
[21:19:46] *** Joins: dsal (sid13060@id-13060.lymington.irccloud.com)
[21:19:47] *** Joins: dminuoso (~dminuoso@user/dminuoso)
[21:19:53] <shapr> o hi dminuoso !
[21:19:57] <dminuoso> Hiya!
[21:20:00] <janus> shapr: at flipstone, we're rewriting orville such that it will use libpq directly, bypassing HDBC
[21:20:10] <janus> https://github.com/flipstone/orville
[21:20:23] <janus> (not publicly announced yet, since it is still missing a few things)
[21:20:27] <shapr> binary protocol?
[21:20:41] <shapr> cause some of that is happening at my workplace too
[21:21:09] <dminuoso> What was the initial question with respect to postgresql-simple?
[21:21:11] <janus> shapr: i don't know, it's using the 'postgresql-libpq' hackage package
[21:21:35] <shapr> dminuoso: oh, just trying to figure out how to use the dang thing from "the ground up"
[21:21:43] <shapr> We use it a bunch at work, and I've cargo-culted lots of code
[21:21:49] <shapr> but realized I don't have a deep understanding
[21:22:08] <dminuoso> Mmm, you dont need a deep understanding I think
[21:22:16] <shapr> Yeah, but I *want* a deep understanding
[21:22:29] <shapr> then I can fold it into semantic knowledge and mostly not worry about it
[21:22:43] <dminuoso> I've been at Haskell for around 3 years and I think I've developed an in-depth understanding in a lot of places. I can just freely customize servant code without spending much time
[21:22:52] <shapr> that's good! I want that too!
[21:22:53] <dminuoso> But I find for scalable and maintainable code simple beats smart.
[21:22:58] <shapr> yeah, agreed
[21:23:01] <dminuoso> Mostly GHC inspired to me to do that
[21:23:06] <dminuoso> GHC is written in such dumb simple style
[21:23:22] <shapr> Right now we have a thing at work where I need to save a deeply nested datatype in postgres, but I also need to ignore one field of the deepest record
[21:23:37] <dminuoso> I mean yeah, the logic and theory behind large parts are very complicated, but the actual code.. pick any page of GHC and you can understand, operationally, what it does at a glance
[21:23:53] <shapr> I realized I've been doing "deriving (Generic, FromRow, ToRow)" so far, and didn't know how to hand write an instance that ignores a single field
[21:25:10] <janus> we don't use DeriveGeneric because it is too much magic and the instances are slow to derive
[21:25:54] <janus> it's nice being able to rename fields without worrying about whether somebody is depending on the literal name for serializing somewhere
[21:26:37] <dminuoso> Heh, we actually use Generic for aeson quite a bit. With a few simple helpers it helps reduce the boiler plate at least.
[21:26:50] <dminuoso> But for postgresql simple, it's much easier to use queryWith
[21:26:55] <dsal> I think we do all that stuff in TH
[21:26:55] <dminuoso> Rather than tying things to instances
[21:27:02] *** Quits: shapr (~user@pool-173-73-44-186.washdc.fios.verizon.net) (Read error: Connection reset by peer)
[21:27:10] <dsal> Tons of TH.  Our codebase is kind of big and compiling is annoyingly slow.
[21:27:18] <dminuoso> dsal: Yeah, we probably should too. In our largest project GHC spends like 4-5 minutes on the largest module.
[21:27:29] <dminuoso> Which is just because of all the aeson generics
[21:27:39] <dminuoso> But oh well, we rarely modify that file so its not a big deal
[21:27:41] <dsal> Wow.  I don't know what this codebase did before all the speedups.
[21:27:45] *** Joins: burnsidesLlama (~burnsides@dhcp168-021.wadham.ox.ac.uk)
[21:28:19] *** Joins: shapr (~user@pool-173-73-44-186.washdc.fios.verizon.net)
[21:31:48] *** Quits: burnsidesLlama (~burnsides@dhcp168-021.wadham.ox.ac.uk) (Ping timeout: 240 seconds)
[21:33:25] <janus> for aeson, we have a closed source version of something like autodocodec. it also allows for attaching documentation on fields
[21:34:30] <janus> where would you put the docs if you use DeriveGeneric? as haddock? you'd need a separate build process then, hmm
[21:35:20] <dminuoso> janus: We use openapi
[21:35:43] <dminuoso> Gets the job done well enough
[21:35:55] <janus> right, it's the new name for swagger. but how do you generate the OpenAPI from the haskell sources?
[21:36:00] <dminuoso> It's certainly not ideal because we have some duplication of information
[21:36:15] <dminuoso> https://hackage.haskell.org/package/openapi3
[21:36:17] <dminuoso> With this
[21:37:02] <dminuoso> (Well strictly speaking we're still on swagger2, but we have a branch ready with openapi for when the python client can migrate to different tools)
[21:37:30] <dminuoso> Overall I think all of this is a terrible incorrect approach
[21:37:44] <janus> hmm i think i like the autodecodec approach more
[21:37:58] <dminuoso> We should probably start with an OpenAPI specification, then have a code generator pump out the data types, haddock comments and aeson instances
[21:38:13] <dminuoso> What is autodecodec?
[21:38:20] <janus> this one https://github.com/NorfairKing/autodocodec
[21:38:26] <janus> (oops i spelt it wrong)
[21:38:36] <dminuoso> Ah yeah
[21:39:02] <dminuoso> Does this have any support for handwritten parser, should you need them?
[21:39:33] *** Joins: burnsidesLlama (~burnsides@dhcp168-021.wadham.ox.ac.uk)
[21:40:05] <janus> what is a handwritten parser? a HasSchema instance subsumes that, i'd say?
[21:40:47] <janus> if you don't have a deserializer you wouldn't be able to make a roundtrip test that ensures that no information is lost
[21:41:14] <janus> anyway, in our in-house autodocodec-like library, the schema is a value, not an instance
[21:41:23] <janus> so you could have any amount of schemas for a type
[21:41:23] <dminuoso> Well say a handrolled parser because a particular haskell field doesnt quite map to a database field/json field directly anymore
[21:41:55] <dminuoso> janus: How does your fork differ from the upstreak?
[21:42:10] <dminuoso> Or is it just that the schema moves from typeclass instance into a value?
[21:42:27] <dminuoso> And presumably you do a value-level encoder/decoder that follows the schema?
[21:42:32] <dminuoso> (How well does GHC optimize here?)
[21:42:46] <janus> dminuoso: it's not a fork, it is much older than autodocodec. the main difference is that it is more value based and less typeclass driven. things are generally like that at flipstone, orville is also more value-driven
[21:43:01] <dminuoso> I reckon even with inlining, the GHC doesnt stand much chance to generate high performance aeson parsers.
[21:43:37] <janus> i don't know how performance is but my coworker made some c++ bindings for simplejson: https://github.com/velveteer/hermes
[21:43:47] <janus> so i guess if performance gets really bad, we could use that
[21:43:56] <janus> it wasn't a problem yet, i guess
[21:46:24] <janus> regarding the type that doesn't map to a db field, i'd say that is quite normal, the database has almost no types available. a deserializer will always need to be able to fail
[21:48:35] <janus> i don't know autodocodec too well, but they ought to have an analogue to 'requiredField' where you can supply your own serializer and deserializer functions
[21:55:14] <janus> (just made a issue asking for this)
[22:03:20] <janus> s/simplejson/simdjson/
[22:20:58] *** Joins: Sqaure (~a@user/square)
[22:29:11] <shapr> yarr
[22:54:42] <janus> shapr: did you want somebody in the room to tell you how to write a manual FromSql/ToSql instance? or was it just a reflection
[22:54:52] <janus> FromRow/ToRow
[23:01:03] <shapr> I'm working my way through figuring out how to write manual instances, but if you could point me to some existing instances, that would be lovely :-)
[23:01:28] <shapr> my specific problem is that one field in this record is of type "IO ()" and I need to ignore that on load and save
[23:14:28] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[23:18:17] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Remote host closed the connection)
[23:18:39] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[23:25:23] *** Joins: coot (~coot@213.134.190.95)
