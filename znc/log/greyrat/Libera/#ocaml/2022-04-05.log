[00:16:16] *** Joins: rgrinberg (~textual@177.248.158.166)
[00:18:55] *** Joins: rawley (~rawley@142.99.241.242)
[00:28:38] <d_bot> <faderazor> It is low
[00:31:17] *** Joins: Anarchos (~Anarchos@88.168.112.216)
[00:35:13] *** Quits: olle (~olle@i5E866D8F.versanet.de) (Ping timeout: 248 seconds)
[01:21:45] *** Joins: wingsorc (~wingsorc@user/wingsorc)
[01:43:16] *** Quits: rawley (~rawley@142.99.241.242) (Remote host closed the connection)
[01:48:15] <d_bot> <ec> Is there an existing name for a function of type required by `Applicative_syntax`? In particular, operating on `result`,
[01:48:16] <d_bot> <ec>
[01:48:17] <d_bot> <ec> ```ocaml
[01:48:19] <d_bot> <ec> val blah :
[01:48:20] <d_bot> <ec>    ('a, 'e) result ->
[01:48:21] <d_bot> <ec>    ('b, 'e) result ->
[01:48:23] <d_bot> <ec>    (('a * 'b), 'e) result
[01:48:24] <d_bot> <ec> ```
[01:48:25] <d_bot> <ec>
[01:48:27] <d_bot> <ec> Something like `both` or `and` comes to mind, but I want to make sure I'm being idiomatic in my naming …
[01:50:17] *** Quits: rgrinberg (~textual@177.248.158.166) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[01:52:31] *** Quits: Anarchos (~Anarchos@88.168.112.216) (Quit: Vision[]: i've been blurred!)
[01:58:50] *** Joins: kaph (~kaph@dynamic-adsl-78-12-162-98.clienti.tiscali.it)
[02:07:30] <d_bot> <Alistair> both would be the function name, `and` would be it's binding operator
[02:12:07] *** Joins: vicfred (~vicfred@user/vicfred)
[02:12:55] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 240 seconds)
[02:19:57] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[02:51:52] *** Joins: rgrinberg (~textual@177.248.158.166)
[02:56:53] *** Joins: Tuplanolla (~Tuplanoll@91-159-69-98.elisa-laajakaista.fi)
[02:59:02] *** Quits: rgrinberg (~textual@177.248.158.166) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[03:12:38] *** Quits: dextaa_5 (~dextaa@user/dextaa) (Read error: Connection reset by peer)
[03:16:26] *** Joins: dextaa_5 (~dextaa@user/dextaa)
[03:29:18] *** Quits: dextaa_5 (~dextaa@user/dextaa) (Read error: Connection reset by peer)
[03:31:03] *** Joins: dextaa_5 (~dextaa@user/dextaa)
[04:03:45] *** Quits: Haudegen (~quassel@178.115.237.87.static.drei.at) (Ping timeout: 248 seconds)
[04:31:53] *** Quits: vicfred (~vicfred@user/vicfred) (Quit: Leaving)
[04:37:33] *** Quits: CalimeroTeknik (~calimero@user/calimeroteknik) (Ping timeout: 256 seconds)
[04:37:40] *** Joins: omni_ (~user@shellbox.hack.org)
[04:37:40] *** Joins: quernd8 (~quernd@boethin.uberspace.de)
[04:37:54] *** Joins: ralu1 (~ralu@static.211.245.203.116.clients.your-server.de)
[04:38:01] *** Quits: omni (~user@shellbox.hack.org) (Read error: Connection reset by peer)
[04:38:06] *** Quits: ebb (ebb@user/ebb) (Remote host closed the connection)
[04:38:15] *** Joins: SquidDev1 (~SquidDev@autoclave.squiddev.cc)
[04:39:15] *** Quits: ralu (~ralu@static.211.245.203.116.clients.your-server.de) (Ping timeout: 256 seconds)
[04:39:15] *** Quits: SquidDev (~SquidDev@autoclave.squiddev.cc) (Ping timeout: 256 seconds)
[04:39:15] *** SquidDev1 is now known as SquidDev
[04:39:15] *** ralu1 is now known as ralu
[04:39:49] *** Quits: quernd (~quernd@boethin.uberspace.de) (Ping timeout: 256 seconds)
[04:39:49] *** quernd8 is now known as quernd
[04:41:13] *** Joins: rgrinberg (~textual@177.248.158.166)
[04:41:45] *** Joins: ebb (ebb@user/ebb)
[04:42:39] *** Quits: mal`` (~mal``@static.38.6.217.95.clients.your-server.de) (Ping timeout: 256 seconds)
[04:42:42] *** Joins: hannes__ (~hannes@193.30.40.133)
[04:43:13] *** Quits: daimrod2 (~daimrod@loire.omecha.info) (Ping timeout: 256 seconds)
[04:43:13] *** Quits: theblatte (~theblatte@82-71-49-100.dsl.in-addr.zen.co.uk) (Ping timeout: 256 seconds)
[04:43:20] *** Joins: theblatte (~theblatte@82-71-49-100.dsl.in-addr.zen.co.uk)
[04:43:47] *** Quits: tomku (~tomku@user/tomku) (Ping timeout: 256 seconds)
[04:43:47] *** Quits: hannes (~hannes@193.30.40.133) (Ping timeout: 256 seconds)
[04:43:47] *** Quits: Ekho (~Ekho@user/ekho) (Ping timeout: 256 seconds)
[04:44:49] *** Joins: mal`` (~mal``@static.38.6.217.95.clients.your-server.de)
[04:45:00] *** Quits: Tuplanolla (~Tuplanoll@91-159-69-98.elisa-laajakaista.fi) (Quit: Leaving.)
[04:45:29] *** Joins: tomku (~tomku@user/tomku)
[04:47:06] *** Joins: Ekho (~Ekho@user/ekho)
[04:47:06] *** Joins: CalimeroTeknik (~calimero@ctkarch.org)
[04:49:12] *** Joins: daimrod2 (~daimrod@loire.omecha.info)
[05:02:12] *** Quits: rgrinberg (~textual@177.248.158.166) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[05:18:42] *** Joins: rgrinberg (~textual@177.248.158.166)
[05:40:02] *** Joins: mbuf (~Shakthi@122.173.67.210)
[06:03:27] *** Quits: rgrinberg (~textual@177.248.158.166) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[06:05:14] *** Quits: bronsen (~bronsen@2a04:d480:0:1::3) (Ping timeout: 252 seconds)
[06:12:58] *** Quits: kaph (~kaph@dynamic-adsl-78-12-162-98.clienti.tiscali.it) (Ping timeout: 260 seconds)
[06:39:06] *** Joins: dextaa_54 (~dextaa@user/dextaa)
[06:39:23] *** Quits: towel_ (~towel@user/towel) (Ping timeout: 256 seconds)
[06:40:46] *** Joins: towel (~towel@user/towel)
[06:41:05] *** Quits: dextaa_5 (~dextaa@user/dextaa) (Ping timeout: 256 seconds)
[06:41:05] *** dextaa_54 is now known as dextaa_5
[06:41:29] *** Joins: grobe0ba_ (~grobe0ba@mars.pulpie.xyz)
[06:42:47] *** Quits: grobe0ba (~grobe0ba@mars.pulpie.xyz) (Ping timeout: 256 seconds)
[06:42:47] *** grobe0ba_ is now known as grobe0ba
[06:54:25] *** Joins: rgrinberg (~textual@177.248.158.166)
[07:12:54] *** Quits: terrorjack (~terrorjac@2a01:4f8:1c1e:509a::1) (Quit: The Lounge - https://thelounge.chat)
[07:14:56] *** Joins: terrorjack (~terrorjac@2a01:4f8:1c1e:509a::1)
[07:47:19] *** Joins: bobo (~bobo@37.164.126.161)
[07:47:26] *** Quits: spip (~bobo@37.170.147.88) (Ping timeout: 245 seconds)
[07:48:41] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 245 seconds)
[08:31:00] *** Joins: gravicappa (~gravicapp@46.191.232.8)
[08:47:32] *** Quits: gravicappa (~gravicapp@46.191.232.8) (Ping timeout: 260 seconds)
[09:05:43] *** Quits: rgrinberg (~textual@177.248.158.166) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[09:45:48] *** Quits: zebrag (~chris@user/zebrag) (Read error: Connection reset by peer)
[10:30:01] *** Joins: gravicappa (~gravicapp@46.191.232.8)
[10:42:40] *** Joins: mro (~mro@port-92-195-183-73.dynamic.as20676.net)
[10:53:14] *** Quits: mro (~mro@port-92-195-183-73.dynamic.as20676.net) (Remote host closed the connection)
[10:53:57] *** Joins: mro (~mro@port-92-195-183-73.dynamic.as20676.net)
[10:59:37] *** Quits: gravicappa (~gravicapp@46.191.232.8) (Ping timeout: 268 seconds)
[11:03:32] *** Quits: epony (epony@user/epony) (Quit: QUIT)
[11:25:19] *** Joins: kaph (~kaph@dynamic-adsl-78-12-162-98.clienti.tiscali.it)
[11:37:03] *** Joins: random-jellyfish (~random-je@user/random-jellyfish)
[12:07:09] *** Joins: olle (~olle@i5E866D89.versanet.de)
[12:11:12] *** Quits: dextaa_5 (~dextaa@user/dextaa) (Remote host closed the connection)
[12:20:45] *** Joins: epony (epony@user/epony)
[12:37:39] *** Joins: dextaa_54 (~dextaa@user/dextaa)
[13:06:33] *** Quits: CalimeroTeknik (~calimero@ctkarch.org) (Changing host)
[13:06:33] *** Joins: CalimeroTeknik (~calimero@user/calimeroteknik)
[13:17:38] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Ping timeout: 260 seconds)
[13:17:50] <ns12> Hello, if I find myself occasionally struggling with the type system, is there a book I can read to learn more about the type system?
[13:18:16] <ns12> I am thinking of reading "Types and Programming Languages" by Benjamin C. Pierce, but I don't know if that would help.
[13:18:30] <d_bot> <orbitz> What sort of issues do you run into?
[13:19:23] <ns12> I write programs that are not correctly typed ...
[13:19:33] <d_bot> <orbitz> I figured that part out
[13:19:40] <ns12> because I don't know the limitations of the type system.
[13:19:51] <d_bot> <orbitz> Is there a pattern in the issues you run into?
[13:22:29] <ns12> Hard to say ...
[13:22:29] <ns12> I guess I just want to learn the type system so that I can design APIs in my head without encountering type errors when I actually implement them.
[13:23:21] <d_bot> <orbitz> I don't know of a book or any resource other than just trying to implement things
[13:23:40] <d_bot> <orbitz> But getting errors from the type system isn't bad, not understanding how to resolve the errors is an issue
[13:23:47] <ns12> I use too much Lisp, and some Lisp-like ways of expressing things is impossible in OCaml.
[13:24:52] <ns12> "not understanding how to resolve the errors is an issue" - That is my issue, unfortunately.
[13:25:27] <d_bot> <orbitz> Practice practice practice
[13:26:13] <ns12> Often, when implementing library functions in OCaml, there is a non-type-safe way to do it and a type-safe way. But designing the type-safe implementation seems to require some understanding of the type system ...
[13:26:37] <octachron> "Types and Programming Languages" would be useful to learn how type system are designed, but it not necessarily a fast path in learning how to write correctly typed programs.
[13:28:37] <ns12> For example, https://github.com/anuragsoni/routes (a type-safe URL router). I actually have no idea how the API is implemented. I have tried for a few days now to make a clean room implementation.
[13:29:34] <d_bot> <orbitz> Something like that is probably using some more advanced concepts
[13:29:43] <ns12> octachron: Is that the slow way? I don't mind slow methods.
[13:29:45] <d_bot> <orbitz> I implemented a type safe router by studying other ones and then just building it up slowly and asking qusetiosn
[13:30:13] <octachron> That is a GADT-heavy library.
[13:32:03] *** Quits: mro (~mro@port-92-195-183-73.dynamic.as20676.net) (Remote host closed the connection)
[13:32:07] <octachron> That's the the slow way, but also one that doesn't preclude practice. Typically, GADTs are not-that-complicated from the type system perspective, but they require a copious amount of practice before become intuitive
[13:32:22] <ns12> "Something like that is probably using some more advanced concepts" - What are those "advanced concepts" and how do I learn them>
[13:32:26] <ns12> s/>/?/
[13:32:42] <d_bot> <orbitz> Yeah.  I find GADTs really fascinating in that the actual change from an ADT is relatively minor, but the consequences are astounding
[13:33:09] <d_bot> <orbitz> ns12: for example, GADTs
[13:34:05] <octachron> And yes, GADTs do become intuitive at some point. To such way, that an important step in learning GADTs is to relearn "how to not use GADTs".
[13:35:19] *** Quits: olle (~olle@i5E866D89.versanet.de) (Quit: leaving)
[13:35:32] *** Joins: olle (~olle@i5E866D89.versanet.de)
[13:35:50] *** Quits: kaph (~kaph@dynamic-adsl-78-12-162-98.clienti.tiscali.it) (Ping timeout: 246 seconds)
[13:38:40] <ns12> How do I learn that?
[13:39:02] <d_bot> <orbitz> Practice
[13:39:49] <ns12> Is practice alone enough to fully appreciate these kinds of things?
[13:40:19] <ns12> octachron: "That is a GADT-heavy library." - Thank you for the tip.
[13:40:36] <d_bot> <orbitz> Depends on how good of a practicer you are
[13:42:35] <octachron> Some canonical examples of GADTs: a shallow embedded interpreter for a small DSL, lists with statistically known lengths, heterogeneous lists
[13:43:54] <d_bot> <orbitz> ns12: https://www.cl.cam.ac.uk/teaching/1415/L28/gadts.pdf -- I found pretty helpful
[13:44:00] <octachron> writing your own version of Printf is a good exercice (which is also an example of typed interpreter for a small DSL)
[13:45:36] <ns12> octachron: Is Printf implemented using GADTs? Can it be implemented in other ways?
[13:46:15] <ns12> orbitz: What book does that chapter come from?
[13:46:22] <octachron> Printf is implemented with GADTs and a bit of syntactic magic to have format strings look lile strings
[13:47:25] *** Joins: bartholin (~bartholin@158.110.71.83)
[13:47:40] *** Joins: mro (~mro@port-92-195-183-73.dynamic.as20676.net)
[13:47:55] <octachron> It cannot really be implemented with an user-friendly interface without GADTs.
[13:49:00] <d_bot> <orbitz> Pre-GADTs is was mostly a bunch of compiler-specific code, right?
[13:49:06] <ns12> octachron: "syntactic magic" - Does that mean that I cannot implement an interface exactly like Printf.printf ?
[13:51:04] <d_bot> <orbitz> ns12: Might be interesting to you: https://blog.tail.moe/2021/01/13/format6.html
[13:51:36] <octachron> Not exactly, but it is still possible to have a readable format GADTs.
[13:52:13] <octachron> For instance "Hello %s" is essentially syntactic sugar for String_literal ("Hello ", String (No_padding, End_of_format))
[13:54:22] *** Quits: mro (~mro@port-92-195-183-73.dynamic.as20676.net) (Remote host closed the connection)
[13:57:38] *** Joins: mro (~mro@port-92-195-183-73.dynamic.as20676.net)
[14:00:58] <ns12> So, it's not possible for me to implement `myprintf "Name: %s Age: %d" "Alice" 123` ?
[14:05:26] <octachron> Yes, but you can implement `myprintf [Lit "Name: "; String; Lit "Age: "; Int] "Alice" 123`
[14:05:32] <ns12> octachron: Is the Printf.printf function handled specially by OCaml?
[14:06:32] <octachron> and then use a ppx to get to `myprintf {%fmt|Name: %s Age: %d|} "Alice" 123`
[14:07:28] <octachron> The `Printf.printf` is an ordinary function. It is "Name: %s Age: %d" which is not a string because its type is _ format6
[14:08:08] <octachron> Ah, slight correction, you can reuse the Format GADTs to really immplement `myprintf "Name: %s Age: %d" "Alice" 123`
[14:09:22] <octachron> It is just that Format/Printf cover a large API which is a bit unwieldy to reuse in a learning project.
[14:09:39] <octachron> (And there is the issue of the "%{...}" specifier)
[14:13:38] *** Joins: gravicappa (~gravicapp@46.191.232.8)
[14:15:33] <ns12> octachron: So, it's possible to create `myprintf [Lit "Name: "; String; Lit "Age: "; Int]` which has type `string -> int -> 'a` in OCaml by using GADTs? Is it possible to implement such a thing without GADTs?
[14:17:13] <d_bot> <orbitz> Depending on the API you can accomplish some similar things with closures
[14:17:27] <d_bot> <orbitz> The API would probably not look like that, though (lists)
[14:17:54] <octachron> Also note that this is not a stdlib's list but a heterogeneous list.
[14:19:50] <octachron> Also the type would not be "string -> int -> 'a" but "string -> int -> t" for some t.
[14:20:32] <octachron> But yes, it is otherwise possible with GADTs, or with some complex use of closures, but not with simple ADTs.
[14:21:37] <ns12> orbitz: "What sort of issues do you run into?" - One of them is how to define a function `myprintf` that when used like `myprintf [Lit "Name: "; String; Lit "Age: "; Int]` results in something with type `string -> int -> t`.
[14:21:37] <ns12> I guess GADT is the answer, which I have not learned about before.
[14:37:47] <d_bot> <orbitz> ns12: IME, writing such functions is fairly uncommon.
[14:40:43] <ns12> octachron: "But yes, it is otherwise possible with GADTs, or with some complex use of closures ... " - Really? It's possible with closures?
[14:43:50] *** Quits: random-jellyfish (~random-je@user/random-jellyfish) (Quit: Client closed)
[14:46:39] <ns12> Hmm ... I guess something like this could work:
[14:46:39] <ns12> let lit s = fun k -> k
[14:46:39] <ns12> let str = fun k (s : string) -> k
[14:46:39] <ns12> let int = fun k (i : int) -> k
[14:46:39] <ns12> let (/+) a b = fun k -> a (b k)
[14:47:46] <ns12> Then, `lit "Name: " /+ str /+ lit "Age: " /+ int` will have type `t -> string -> int -> t`.
[14:57:53] *** Quits: mro (~mro@port-92-195-183-73.dynamic.as20676.net) (Remote host closed the connection)
[14:59:24] *** Joins: mro (~mro@port-92-195-183-73.dynamic.as20676.net)
[15:06:43] *** Quits: mro (~mro@port-92-195-183-73.dynamic.as20676.net) (Remote host closed the connection)
[15:07:09] *** Joins: mro (~mro@port-92-195-183-73.dynamic.as20676.net)
[15:19:53] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[15:30:28] *** Joins: Haudegen (~quassel@178.115.237.87.static.drei.at)
[15:47:45] *** Quits: bartholin (~bartholin@158.110.71.83) (Ping timeout: 248 seconds)
[16:00:41] *** Joins: bartholin (~bartholin@158.110.71.83)
[16:06:35] *** Quits: dextaa_54 (~dextaa@user/dextaa) (Read error: Connection reset by peer)
[16:08:46] *** Joins: dextaa_54 (~dextaa@user/dextaa)
[16:32:02] *** Joins: kaph (~kaph@dynamic-adsl-78-12-162-98.clienti.tiscali.it)
[16:33:17] *** Quits: mro (~mro@port-92-195-183-73.dynamic.as20676.net) (Ping timeout: 246 seconds)
[16:48:13] *** hannes__ is now known as hannes
[16:57:05] *** Quits: bartholin (~bartholin@158.110.71.83) (Ping timeout: 246 seconds)
[17:09:10] *** Joins: bartholin (~bartholin@158.110.71.83)
[17:21:31] *** Joins: mro (~mro@port-92-195-183-73.dynamic.as20676.net)
[17:22:30] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Ping timeout: 272 seconds)
[17:43:32] *** Quits: mro (~mro@port-92-195-183-73.dynamic.as20676.net) (Remote host closed the connection)
[17:44:34] *** Joins: mro (~mro@port-92-195-183-73.dynamic.as20676.net)
[17:49:23] *** Quits: mro (~mro@port-92-195-183-73.dynamic.as20676.net) (Ping timeout: 260 seconds)
[18:00:35] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[18:07:47] *** Quits: kaph (~kaph@dynamic-adsl-78-12-162-98.clienti.tiscali.it) (Ping timeout: 246 seconds)
[18:15:52] *** Joins: mro (~mro@port-92-195-183-73.dynamic.as20676.net)
[18:18:07] *** Joins: kaph (~kaph@dynamic-adsl-78-12-162-98.clienti.tiscali.it)
[18:33:17] *** Joins: Anarchos (~Anarchos@88.168.112.216)
[18:36:36] *** Quits: bartholin (~bartholin@158.110.71.83) (Ping timeout: 240 seconds)
[18:48:24] *** Quits: mro (~mro@port-92-195-183-73.dynamic.as20676.net) (Remote host closed the connection)
[18:49:17] *** Joins: bartholin (~bartholin@158.110.71.83)
[18:59:00] *** Joins: mro (~mro@port-92-195-183-73.dynamic.as20676.net)
[19:04:07] *** Quits: mro (~mro@port-92-195-183-73.dynamic.as20676.net) (Remote host closed the connection)
[19:04:16] *** Joins: mro (~mro@port-92-195-183-73.dynamic.as20676.net)
[19:14:36] *** Quits: bartholin (~bartholin@158.110.71.83) (Ping timeout: 272 seconds)
[19:19:31] *** Joins: rgrinberg (~textual@177.248.158.166)
[19:26:33] *** Joins: bronsen (~bronsen@2a04:d480:0:1::3)
[19:27:04] *** Joins: bartholin (~bartholin@158.110.71.83)
[19:35:36] <d_bot> <ec> Is there a codemod library, something like `jscodeshift`, to simplify and speed up writing small codemods for OCaml source-code?
[19:35:37] <d_bot> <ec>
[19:35:38] <d_bot> <ec> https://github.com/facebook/jscodeshift
[19:36:17] <d_bot> <ec> in particular, the fact it depends on a parser/lexer that intentionally *do not* throw away information, in the hopes of reconstituting the original code with the least-possible changes, seems like something I've not come across in the ML ecosystems …
[19:46:38] *** Joins: spip (~bobo@37.170.27.67)
[19:46:41] *** Quits: bobo (~bobo@37.164.126.161) (Ping timeout: 248 seconds)
[19:49:33] *** Quits: dextaa_54 (~dextaa@user/dextaa) (Read error: Connection reset by peer)
[19:51:44] *** Joins: dextaa_54 (~dextaa@user/dextaa)
[19:51:48] <d_bot> <VPhantom> I never dealt with "codemods" (had to look up the word just now) but in my experience with OCaml the type system is all I have needed when refactoring. I haven't maintained large code bases yet though.
[19:52:41] <companion_cube> oh hey @VPhantom
[19:56:02] <d_bot> <VPhantom> Bonjour! 😃
[20:06:10] <d_bot> <bikachuu> Hello
[20:06:25] *** Joins: neilthereildeil (~neilthere@149.8.13.204)
[20:06:33] <neilthereildeil> hey guys
[20:06:37] <neilthereildeil> what does this code do?
[20:06:38] <neilthereildeil> List.iter (add_event (fun x -> x.read <- true)) in_fds;
[20:07:08] <neilthereildeil> can someone please break it down into peices?
[20:07:20] <neilthereildeil> i think this is an anonymous function: fun x -> x.read <- true
[20:07:24] <neilthereildeil> but i dunno what it does
[20:07:33] <d_bot> <VPhantom> Useful reference: <https://ocaml.org/api/List.html#1_Iterators>
[20:07:48] <d_bot> <bikachuu> x is a record that has a mutable field `read : bool`, and this anonymous function sets that field to `true`
[20:07:50] *** Joins: zebrag (~chris@user/zebrag)
[20:07:52] <d_bot> <VPhantom> I guess `add_event` takes more than one argument and is curried here.
[20:09:25] <d_bot> <ec> A big part of the point is to have the changes stored, historically — it's also really helpful to have a branch be not just a set of changes and a *human* ability to rebase those changes on top of others' work when they're ready … but to also have the ability to *mechanically* apply those changes to any rebasing branches.
[20:10:00] <d_bot> <VPhantom> Hence why it's higher-level than a mere commit. I see.
[20:10:16] <d_bot> <ec> idk if i explained that well, not very awake. tl;dr "human following type-system" + "lots of contributors" == "that human having to make those changes all over again every couple of days/weeks";
[20:10:18] <d_bot> <ec> but "machine making changes" + "lots of contributors" == "machine re-making those changes for each contributor"
[20:10:56] <d_bot> <ec> it also has a couple nice side-effects w.r.t. debugging down the road, and w.r.t. bikeshedding — it's a bit like an autoformatter in that respect.
[20:13:28] <neilthereildeil> so do we evaluate the code from the most nested expression, outwards?
[20:13:49] <neilthereildeil> in this case, do we read the "fun x -> x.read <- true" first?
[20:14:03] <d_bot> <ec> it's eager evaluation, so (mostly) yes
[20:14:36] <neilthereildeil> so frm the documentation, it looks like it executes that function on each element of the list, right?
[20:14:40] <d_bot> <ec> if you're unfamiliar with currying, it's important to note that there's effectively a second anonymous function in there as well
[20:15:09] <d_bot> <ec> List.iter (fun y -> add_event (fun x -> x.read <- true) y) in_fds
[20:16:00] <d_bot> <ec> this is because (I'm assuming, from looking at the code) `add_event` must be partially applied — it needs more arguments than just that first `fun x ...` lambda.
[20:17:46] <d_bot> <VPhantom> Exactly.
[20:18:08] <d_bot> <Ambika E.> I'm trying to organize a dune library in a way such that I have a top-level module, call it `Node`, with some top-level values, e.g. `Node.create`, but I want it to have sub-modules as well, e.g. `Node.Server` and I want those modules to exist in their own files. Is this possible? I know I can do this in one file quite easily, but I'm not sure how splitting it into several works if i want those top-level values
[20:26:03] *** Quits: bartholin (~bartholin@158.110.71.83) (Quit: Leaving)
[20:27:04] <d_bot> <ec> You want `(wrapped false)`. https://dune.readthedocs.io/en/stable/dune-files.html?highlight=wrap#library-1
[20:27:26] <d_bot> <ec> Can explain in more detail if the docs don't cover it, feel free to ask! (=
[20:27:28] <d_bot> <octachron> Yes, if you have a library called `lib` and a module `Lib`, `dune` will consider that the module `Lib` is the main entry point of the library. Then, you just have to re-export the other modules in the library with `Module Sub = Sub`.
[20:27:55] <neilthereildeil> i just read about currying
[20:28:46] <neilthereildeil> so it seems the function format myFunc a b c is "curryed"
[20:29:00] <d_bot> <octachron> @ec : `(wrapped false)` is not that much of a good advice because it exposes the non-qualified names `Sub` and thus it increases the risk of name collisions.
[20:29:39] <neilthereildeil> are you only thinking its curried because its partially applied?
[20:29:40] <d_bot> <ec> Oh, I didn't know about the matching-name-single-export functionality
[20:29:53] <d_bot> <ec> I thought you'd just end up with `Lib.Lib.create`, which is what he's trying to avoid. Cool1
[20:30:15] <d_bot> <Ambika E.> wrapped false is not exactly what i want
[20:30:27] <d_bot> <Ambika E.> that would expose _every_ module in my library directly
[20:30:57] <neilthereildeil> also how do you knoiw the function is partially applied?
[20:31:21] *** Quits: mro (~mro@port-92-195-183-73.dynamic.as20676.net) (Remote host closed the connection)
[20:31:46] <d_bot> <Ambika E.> it's partially applied because the second argument to `List.iter` is a function, meaning that the application of `add_event` returned a function rather than a non-function value. This implies partial application to some extent.
[20:32:04] <d_bot> <ec> `List.iter` takes a function as its first argument; and based on the name `add_event`, I'm guessing that second clause doesn't return a function when it's fully-applied. Just a guess, though. ¯\_(ツ)_/¯
[20:32:13] <d_bot> <Ambika E.> first argument, my bad
[20:34:23] <d_bot> <Ambika E.> the structure i want to mimic with dune is something like
[20:34:24] <d_bot> <Ambika E.>
[20:34:25] <d_bot> <Ambika E.> node.ml
[20:34:26] <d_bot> <Ambika E.> ```ocaml
[20:34:28] <d_bot> <Ambika E.> let create ... = ...
[20:34:29] <d_bot> <Ambika E.>
[20:34:30] <d_bot> <Ambika E.> module Server = struct
[20:34:31] <d_bot> <Ambika E.>   let init ... = ...
[20:34:33] <d_bot> <Ambika E.>   ...
[20:34:34] <d_bot> <Ambika E.> end
[20:34:35] <d_bot> <Ambika E.> ```
[20:34:37] <d_bot> <Ambika E.>
[20:34:38] <d_bot> <Ambika E.> such that the consumer of this library could run `Node.create` or `Node.Server.init`.
[20:34:46] <neilthereildeil> heres the signature of iterator:
[20:34:46] <neilthereildeil> val iter : ('a -> unit) -> 'a list -> unit
[20:34:48] <d_bot> <Ambika E.> `wrapped false` just means that the consumer can directly run `Node.create` or `Server.init`
[20:34:55] <d_bot> <Ambika E.> not necessarily what i'm looking for
[20:34:57] <neilthereildeil> the () means that the first argument is a function, right?
[20:35:33] <d_bot> <Ambika E.> yeah, that's what it's signifying
[20:36:27] <neilthereildeil> in
[20:36:28] <neilthereildeil> List.iter (add_event (fun x -> x.read <- true)) in_fds;
[20:36:37] <neilthereildeil> it looks like in_fds is the second argument
[20:36:39] <neilthereildeil> right?
[20:36:41] <d_bot> <Ambika E.> yes
[20:36:49] <neilthereildeil> so then how is it partially applied?
[20:37:02] <neilthereildeil> i see it as List.iter () in_fds
[20:37:07] <neilthereildeil> where the () is the function
[20:37:12] <d_bot> <ec> you'll have to ask @octachron about it — but it sounds like that's only possible if the *library* is also named `node`? hrm.
[20:37:35] <d_bot> <Ambika E.> even if it were, i don't think my problem is solved, it doesn't seem like you can expose top-level values with dune libraries that way
[20:37:47] <d_bot> <Ambika E.> i basically want something like python's `__init__.py`
[20:38:05] <d_bot> <octachron> You can add any toplevel values that you want in `node.ml`.
[20:38:09] <d_bot> <Ambika E.> really?
[20:38:23] <neilthereildeil> also, what does "<- true" do?
[20:38:30] <d_bot> <Ambika E.> that's assignment to a mutable record field
[20:38:38] <d_bot> <octachron> Yes, the only constraint is that you also need to export the submodules of the library
[20:39:03] <d_bot> <ec> `<-` is OCaml's weird-ass syntax for "mutating assignment." Depending on the language you're coming from, it's probably best read something like `=`. :P
[20:39:35] <d_bot> <Ambika E.> i see, i'll give this a try, i appreciate it a lot
[20:39:45] <d_bot> <ec> for instance, JavaScript `an_object.some_key = 123` becomes OCaml's `a_record.some_mutable_key <- 123`.
[20:41:58] <d_bot> <Ambika E.> check the signature of add_event
[20:43:21] <neilthereildeil> heres the code: https://paste.debian.net/1236903/
[20:43:38] <d_bot> <Ambika E.> yeah, see, add_event takes 2 arguments, not one
[20:43:40] <neilthereildeil> add_event looks like it returns e
[20:43:47] *** Quits: rgrinberg (~textual@177.248.158.166) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[20:43:47] <d_bot> <Ambika E.> the fact that you only pass it one argument means it's being applied partially
[20:43:58] <neilthereildeil> wow thats confusing
[20:44:05] <d_bot> <Ambika E.> not once you get used to it
[20:44:08] <d_bot> <Ambika E.> it's a common pattern
[20:44:20] <neilthereildeil> ok so add_event is partially applied
[20:44:31] <neilthereildeil> because we dont pass enough parameters?
[20:44:40] <d_bot> <ec> Partial application is super-important. If you're coming from a non-functional background, it's best to think of it as "every function *defaults* to returning another function, if you don't give it everything it needs."
[20:44:49] <d_bot> <Ambika E.> yeah, you pass the first parameter, so the result is a function that's still waiting for the second param
[20:45:07] <neilthereildeil> lol wow so its liike partially executed??
[20:45:18] <d_bot> <ec> i.e. `let mult a b = a * b`, if you only give it `a`, becomes `let mult a = (fun b -> a * b)` automatically.
[20:45:24] <d_bot> <Ambika E.> sure, except nothing actually runs
[20:45:34] *** Joins: rgrinberg (~textual@177.248.158.166)
[20:45:45] <neilthereildeil> ohhh i get it
[20:45:59] <d_bot> <Ambika E.> the function won't actually get called until it gets all its inputs
[20:46:11] <d_bot> <Ambika E.> it kind of creates a half-filled shell of a function call
[20:46:16] <neilthereildeil> wow cool
[20:46:21] <d_bot> <Ambika E.> it is really cool
[20:46:44] <d_bot> <ec> it's very helpful for all sorts of things.
[20:47:05] <d_bot> <ec> 1. you can explicitly use that to create specialized, helper functions: `let triple = mult 3`
[20:47:12] <neilthereildeil> so then when is add_event actually executed?
[20:47:18] <neilthereildeil> when does it have enough params?
[20:47:29] <d_bot> <Ambika E.> in the execution of List.iter
[20:47:35] <d_bot> <ec> 2. And in situations like the above, you don't have to waste a bunch of space typing out a lambda; you can just pass it an unfinished function, as long as the "last" argument to the function is the operable item
[20:47:41] <d_bot> <Ambika E.> List.iter plugs each file descriptor in `in_fds` into the partially applied function
[20:48:26] <neilthereildeil> so is in_fds an argument to List.iter or add_event?
[20:48:54] <d_bot> <Ambika E.> `in_fds` is a list of arguments to `add_event`, and thus it is an argument to `List.iter` 😎
[20:49:08] <d_bot> <Ambika E.> that's how list iter works
[20:49:20] <d_bot> <Ambika E.> it takes a function and a list of things you want to apply the function to
[20:49:23] <d_bot> <Ambika E.> and it does just that
[20:49:34] <d_bot> <Ambika E.> it's like a specialized for loop condensed into one line
[20:49:38] <neilthereildeil> damn
[20:49:44] <neilthereildeil> very dense
[20:50:27] <neilthereildeil> so is in_fds passed to List.iter first, and List.iter passes it as a parameter to add_event interally?
[20:51:18] <d_bot> <Ambika E.> let me show you a simpler example of how List.iter is used
[20:51:29] <neilthereildeil> thx
[20:53:03] <d_bot> <ec> It might help to break that function down a tiny bit: https://gist.github.com/ELLIOTTCABLE/d52790220e22dcd83b6ec147d5d0bf79
[20:53:35] <d_bot> <ec> er, @help-ee-dude
[20:54:03] <d_bot> <Ambika E.> ```ocaml
[20:54:04] <d_bot> <Ambika E.> let numbers = [1; 2; 3; 4; 5; 6 ; 7; 8; 9; 10]
[20:54:05] <d_bot> <Ambika E.>
[20:54:07] <d_bot> <Ambika E.> let multiply a b = a * b
[20:54:08] <d_bot> <Ambika E.>
[20:54:09] <d_bot> <Ambika E.> (* Print out every multiple of 2 from 1 to 10 *)
[20:54:11] <d_bot> <Ambika E.> List.iter (fun x > print_int (multiply 2 x)) numbers
[20:54:12] <d_bot> <Ambika E.> ```
[20:54:13] <d_bot> <Ambika E.>
[20:54:14] <d_bot> <Ambika E.> there's no partial application here, but you can kind of see that the argument to `List.iter` is obviously not the argument to `multiply`
[20:56:55] <d_bot> <ec> I also added a JavaScript equivalent (if you let me know what language you're most familiar with, neil, I can possibly use that instead?)
[20:58:43] *** Quits: mbuf (~Shakthi@122.173.67.210) (Quit: Leaving)
[21:01:49] <neilthereildeil> ec: ok, it took like 8 minutes but i understand ur code
[21:02:01] <d_bot> <ec> ❤️
[21:02:24] <neilthereildeil> thax so much. im a C guy, so i think in a totally different
[21:02:24] <neilthereildeil> way
[21:02:36] <d_bot> <ec> ahhahhah, oof, that's a *big* transition. good luck!
[21:03:11] <d_bot> <ec> don't be afraid of grabbing any code you are confused by, dropping it into `utop` or a text-editor with LSP support, and starting to add a bunch of explicit anonymous-functions everywhere. if you screw something up, the type-system will tell you. it's a good stretch if you're not familiar with partial-application and such.
[21:03:58] <neilthereildeil> Ambika: thanks for the code
[21:04:02] <d_bot> <ec> I'm surprised this Discord doesn't have a #menhir or #parsing channel for Menhir / Sedlex stuff
[21:04:35] <neilthereildeil> ec: im just trynna fix 1 bug, and im (re)learning ocaml for this! haha
[21:05:37] <neilthereildeil> also, that anonymous function:
[21:05:38] <neilthereildeil> fun x -> x.read <- true
[21:05:38] <neilthereildeil> unconditionally sets "read" field to true, correct? what if no read field exists in the object?
[21:06:45] <d_bot> <ec> impossible, all constrained by the type-system. `x` has a very specific type. I really hope you're reading this inside an editor with `ocaml-lsp` or similar, by the way — I'm a pretty deft hand with OCaml, and I'd be *totally* incompetent without a 'what's the type of this value' hotkey :P
[21:06:45] <octachron> Records are nominal and statistically typed. The field is guaranteed to exist in the record.
[21:07:16] <d_bot> <ec> even just for fixing one bug, it's worth quickly installing whatever editor-plugin is relevant.
[21:07:45] <neilthereildeil> im using VIsualStudio code
[21:08:02] <d_bot> <ec> I just set this up yesterday! It's nice and quick. https://github.com/ocamllabs/vscode-ocaml-platform
[21:08:13] <neilthereildeil> the type of x is not explicitly listed in the code
[21:08:47] <d_bot> <ec> yep, we very very rarely type out types manually — mostly only as a form of comments/documentation, honestly. OCaml is really heavy on the type-inferrence.
[21:09:09] <d_bot> <ec> Was just about to suggest we move this to #beginners, but ah. you're over the IRC bridge.
[21:10:24] *** Quits: rgrinberg (~textual@177.248.158.166) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[21:12:08] <neilthereildeil> also, one thing i didnt understand in the compact form:
[21:12:09] <neilthereildeil> List.iter (add_event (fun x -> x.read <- true)) in_fds;
[21:12:09] <neilthereildeil> is in_fds first passed to iter, which then passes it to add_event?
[21:13:08] <d_bot> <ec> half-yes — `in_fds` is indeed an argument to `iter`, but only *one* `in_fd` is passed to `add_event`.
[21:13:17] <d_bot> <ec> that being the entire purpose of `iter`
[21:13:31] <neilthereildeil> ok cool. i just wanted to make sure i understood the order of parameter passing
[21:14:00] <neilthereildeil> also, since fun unconditionally sets x.read=true, where are we guaranteed that x has a read field?
[21:14:14] <d_bot> <ec> by that code existing, basically.
[21:14:32] <d_bot> <NULL> compiling*
[21:14:59] <d_bot> <ec> the compiler will infer from that code _that_ `x` is a value with a record-type that looks like `{ mut read: bool; … }`, and then it'll explode if the values in `in_fds` don't match that expectation.
[21:15:11] <neilthereildeil> okay compile time. thats better than python where the server could be running for 2 days and then throws an error that an attribute doesnt exist!
[21:15:34] <d_bot> <NULL> OCaml is pretty much as statically typed as you get
[21:27:57] *** Quits: Anarchos (~Anarchos@88.168.112.216) (Quit: Vision[]: i've been blurred!)
[21:28:47] *** Joins: rgrinberg (~textual@177.248.158.166)
[21:36:59] *** Joins: szkl (uid110435@id-110435.uxbridge.irccloud.com)
[21:40:39] <olle> Hmmm
[21:40:46] <olle> No refined typed tho :))
[21:40:53] <olle> Or dependent, etc etc
[21:40:58] <olle> Or even kinds?
[21:41:23] <d_bot> <NULL> I didn't say it has the most types
[21:41:26] <d_bot> <NULL> had*
[21:41:43] <d_bot> <ec> i may be being crotchety, but … in real-world development, most of OCaml's *existing* complicated type-features don't really get used much. Honestly, it's often "best avoided".
[21:42:15] <d_bot> <ec> Not saying gaining those features would be a net loss, but I *am* saying that not having them isn't a significant drawback, at least for pragmatic production codebases. :P
[21:42:56] <d_bot> <ec> "Good code can be understood by an intern; better code is that-but-less-of-it; and the best code is none at all." and all that
[21:46:10] <d_bot> <octachron> I don't completely agree, GADTs are not completely trivial, and tend to spread to code base pretty fast.
[21:57:00] *** Quits: dextaa_54 (~dextaa@user/dextaa) (Read error: Connection reset by peer)
[21:59:02] *** Joins: dextaa_54 (~dextaa@user/dextaa)
[22:02:12] <d_bot> <Ambika E.> any idea what's going on here?
[22:02:13] <d_bot> <Ambika E.> https://i.imgur.com/N5gYIXV.png
[22:02:49] <companion_cube> ah, well, Mutex.t doens't have type arguments
[22:02:51] <companion_cube> sadly
[22:03:01] <d_bot> <Ambika E.> but clearly it does? no?
[22:03:10] <companion_cube> ah wait, you may be using a library that hides it
[22:03:19] <companion_cube> and esy doesn't pick it up
[22:03:29] <d_bot> <Ambika E.> it is exposed in the mli
[22:04:07] <d_bot> <Ambika E.> to what extent more could it be hidden?
[22:04:20] <companion_cube> I mean.
[22:04:28] <companion_cube> you may be using a library that defines `'a Mutex.t`
[22:04:35] <companion_cube> instead of the standard Mutex.t which has no argument
[22:04:42] <companion_cube> and esy doesn't know about that library maybe
[22:04:47] <d_bot> <Ambika E.> oh wow
[22:04:55] <d_bot> <Ambika E.> didn't realize OCaml had a built-in Mutex module
[22:05:03] <companion_cube> it does, it's in the threads library :)
[22:05:09] <d_bot> <Ambika E.> interesting
[22:05:17] <companion_cube> https://ocaml.org/manual/libthreads.html
[22:05:24] <companion_cube> https://ocaml.org/api/Mutex.html even
[22:21:03] *** Joins: Tuplanolla (~Tuplanoll@91-159-69-98.elisa-laajakaista.fi)
[22:27:31] <neilthereildeil> what does this code do? https://paste.debian.net/1236908/
[22:32:00] <d_bot> <NULL> A triple filter in one go
[22:33:32] <neilthereildeil> what is it applying fold_right to?
[22:33:48] <neilthereildeil> the r and then the a?
[22:34:31] <d_bot> <NULL> It's folding over a with base value r
[22:34:43] <d_bot> <ec> https://ocaml.org/api/Array.html#VALfold_right, if you didn't already find that.
[22:37:06] <neilthereildeil> that signature definition language is just as confusing as the code itself, so i looked elsewhere! LOL
[22:37:13] * d_bot <ec> laughs
[22:37:41] <d_bot> <ec> I can relate, I've struggled with Haskell's syntax for *years*. Unfortunately it's used absolutely everywhere in fp and strong-typing spaces.
[22:38:06] <d_bot> <ec> The important part in the definition is the `'blah` type-variables, with a single-quote before them. Any two sharing a letter are the same type.
[22:39:21] <d_bot> <ec> I personally cannot fathom why so many in the FP space (including other OCamleers) struggle to type more than a single letter for typevar names. If it helps:
[22:39:22] <d_bot> <ec>
[22:39:23] <d_bot> <ec> ```ocaml
[22:39:25] <d_bot> <ec> val fold_right : ('thing -> 'result -> 'result) -> 'thing array -> 'result -> 'result
[22:39:26] <d_bot> <ec> ```
[22:41:30] <d_bot> <octachron> Partially because `'result` and `'thing` are not much more informative than `'a` and `'b`:
[22:41:31] <d_bot> <octachron> val fold_right: ('elt -> 'acc -> 'acc) -> 'elt array -> 'acc -> 'acc
[22:41:32] <d_bot> <octachron> is a bit better.
[22:41:59] *** Joins: mro (~mro@port-92-195-183-73.dynamic.as20676.net)
[22:45:00] *** Quits: mro (~mro@port-92-195-183-73.dynamic.as20676.net) (Remote host closed the connection)
[22:45:09] *** Joins: mro (~mro@port-92-195-183-73.dynamic.as20676.net)
[22:45:13] *** Joins: vicfred (~vicfred@user/vicfred)
[22:49:01] <neilthereildeil> so whats the "operation" thats being used to fold?
[22:49:50] *** Quits: mro (~mro@port-92-195-183-73.dynamic.as20676.net) (Remote host closed the connection)
[22:51:15] *** Joins: mro (~mro@port-92-195-183-73.dynamic.as20676.net)
[22:51:35] <companion_cube> whatever you want it to be
[22:52:25] <octachron> The first argument is a function that takes an array element ('elt) and an accumulator and returns the next accumulator
[22:52:36] <neilthereildeil> i "want it to be" something i understand :(
[22:53:10] <companion_cube> well, fold is a function to which you pass a function
[22:53:26] <companion_cube> e.g. `fun l -> List.fold_left (+) 0 l` is summing over the list
[22:53:34] <companion_cube> you, the caller, choose the operation
[22:53:45] <neilthereildeil> what is  'acc -> 'acc?
[22:53:52] <neilthereildeil> why are there 2 acc?
[22:53:58] <octachron> You can think of it as a way to specify a for-loop over the array where each turn of the loop is computed as `state = f(array[i], state)`
[22:54:10] <companion_cube> there's the one you pass as the initial value, and the one returned at the end
[22:54:33] <neilthereildeil> val fold_right: ('elt -> 'acc -> 'acc) -> 'elt array -> 'acc -> 'acc
[22:54:44] <neilthereildeil> both the function and the last 2 args are acc
[22:54:50] <companion_cube> fun l -> fold_right (+) l 0
[22:54:51] <neilthereildeil> what does that signify?
[22:54:54] <companion_cube> 'acc is just a type
[22:55:16] <neilthereildeil> so we know it takes a function because of the ()
[22:55:16] <companion_cube> the type of the accumulator that is passed to the function, along with each element of the list
[22:55:19] <neilthereildeil> right?
[22:55:59] <neilthereildeil> can someone please break down step by step how to evaluate this?
[22:56:00] <neilthereildeil> val fold_right: ('elt -> 'acc -> 'acc) -> 'elt array -> 'acc -> 'acc
[22:56:04] <neilthereildeil> where do you start from?
[22:56:21] <companion_cube> you mean to read the type?
[22:56:35] <neilthereildeil> the function signature i think...
[22:56:40] <companion_cube> same thing
[22:56:52] <companion_cube> well, everything on the left of `-> ` is a function argument
[22:57:04] <companion_cube> here: ('elt -> 'acc -> 'acc) is an argument
[22:57:07] <companion_cube> 'elt array too
[22:57:11] <companion_cube> and 'acc too
[22:57:22] *** Quits: neilthereildeil (~neilthere@149.8.13.204) (Quit: Client closed)
[22:57:25] <companion_cube> ahah fuck
[22:57:45] *** Joins: neilthereildeil (~neilthere@149.8.13.204)
[22:58:16] <neilthereildeil> so ('elt -> 'acc -> 'acc) is the argument to fold_right?
[22:58:24] <companion_cube> it's one of the arguments
[22:58:31] <companion_cube> and it's itself a function
[22:59:23] <neilthereildeil> im confused
[22:59:45] <neilthereildeil> i thought all the arguments are inside the ()
[22:59:51] <companion_cube> no :)
[23:00:01] <neilthereildeil> so what does () mean here?
[23:00:11] <companion_cube> it's used to delimit a type
[23:00:19] <neilthereildeil> like a tuple?
[23:00:23] <neilthereildeil> since theres 3?
[23:00:25] <companion_cube> like in `a * (b + c)` it is used to delimit a sub-expression
[23:00:34] <companion_cube> here it's used to delimit a type
[23:00:50] <neilthereildeil> whats the type thats delimited here?
[23:00:58] <companion_cube> 'elt -> 'acc -> 'acc
[23:01:07] <neilthereildeil> looks like 3 types to me...
[23:01:08] <companion_cube> I think you need to read about simpler types than that first
[23:01:14] <companion_cube> no, it's a function type because of the ->
[23:01:20] <companion_cube> `Array.set : 'a array -> int -> 'a -> unit` for example
[23:01:36] <companion_cube> that's the function to set an array slot by its index
[23:02:14] <neilthereildeil> ok, so if i have -> between types then its a function?
[23:09:35] <d_bot> <NULL> The way you read these types is related to the currying we talked about above
[23:10:39] <d_bot> <NULL> Here, `Array.set` takes 3 arguments: one array, an int, a value (with type 'a, the types of values on the array) and returns unit
[23:11:31] <d_bot> <NULL> You can also see it as a function that takes an array and returns a function that then takes an int and returns a function that then takes a value and returns unit
[23:11:46] <d_bot> <NULL> `'a array -> (int -> ('a -> unit))`
[23:11:51] <d_bot> <NULL> Those types are equal
[23:12:04] <d_bot> <NULL> Do you follow until now ?
[23:15:11] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[23:16:21] *** Quits: rgrinberg (~textual@177.248.158.166) (Quit: My MacBook has gone to sleep. ZZZzzz…)
