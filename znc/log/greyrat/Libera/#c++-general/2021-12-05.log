[00:12:17] <manuels> what is this -MF parameter in clang?
[00:14:40] *** Quits: elemongw (~elemongw@20.107.36.50) (Ping timeout: 256 seconds)
[00:14:46] *** Joins: Ivii (~Ivyy@2001:a62:4c3:8e01:dac0:2a17:49d5:efcf)
[00:14:53] *** Quits: smeso (~smeso@user/smeso) (Ping timeout: 256 seconds)
[00:15:13] *** Quits: pulse (~pulse@user/pulse) (Quit: Join a community of jedi masters at https://indiedevs.net/)
[00:16:40] *** Joins: smeso (~smeso@user/smeso)
[00:17:10] *** Joins: elemongw (~elemongw@20.107.36.50)
[00:18:25] *** Joins: philip (~philip@210.16.81.112)
[00:19:17] *** Joins: WarauSalesman (~sjw@69.206.48.64)
[00:19:59] *** Quits: SuperNintendoSUX (~sjw@69.206.48.64) (Ping timeout: 256 seconds)
[00:23:34] <ville> output filename for dependency files would be a use for it
[00:24:24] <manuels> i just realized that it is produced not consumed
[00:24:52] <manuels> can we somehow debug c++ (the compiler) commands?
[00:25:07] <manuels> I'd like to know where it gets its includes from
[00:25:39] *** Quits: proller (~p@80.240.216.69) (Ping timeout: 252 seconds)
[00:25:40] <manuels> since the error i get is outside the includes specified with -I
[00:26:02] *** Joins: proller (~p@2a02:6b8:b081:a424::1:1e)
[00:27:19] <ville> build systems sometimes have a flag to print out the raw commands they use to compile with rather than abbreviated ones or even completely hiding them
[00:27:28] <manuels> sure
[00:27:35] <manuels> I executed the raw command
[00:27:37] <manuels> cd /Users/manuel/albert/test/plugins/widgetboxmodel && /Library/Developer/CommandLineTools/usr/bin/c++ -DQT_CORE_LIB -DQT_GUI_LIB -DQT_NO_DEBUG -DQT_SVG_LIB -DQT_WIDGETS_LIB -Dwidgetboxmodel_EXPORTS -I/Users/manuel/albert/test/plugins/widgetboxmodel -I/Users/manuel/albert/plugins/widgetboxmodel
[00:27:37] <manuels> -I/Users/manuel/albert/test/plugins/widgetboxmodel/widgetboxmodel_autogen/include -I/Users/manuel/albert/plugins/widgetboxmodel/include -I/Users/manuel/albert/plugins/widgetboxmodel/src -I/Users/manuel/albert/include -iframework /opt/homebrew/Cellar/qt@5/5.15.2_1/lib -isystem /opt/homebrew/Cellar/qt@5/5.15.2_1/lib/QtSvg.framework/Headers -isystem
[00:27:37] <manuels> /opt/homebrew/Cellar/qt@5/5.15.2_1/lib/QtWidgets.framework/Headers -isystem /opt/homebrew/Cellar/qt@5/5.15.2_1/lib/QtGui.framework/Headers -isystem /Library/Developer/CommandLineTools/SDKs/MacOSX11.3.sdk/System/Library/Frameworks/OpenGL.framework/Headers -isystem /opt/homebrew/Cellar/qt@5/5.15.2_1/lib/QtCore.framework/Headers -isystem
[00:27:37] <manuels> /opt/homebrew/Cellar/qt@5/5.15.2_1/./mkspecs/macx-clang-arm64 -Wall -Wextra -Wshadow -Wstrict-aliasing -pedantic -arch arm64 -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX11.3.sdk -fPIC -fvisibility=hidden -fvisibility-inlines-hidden -fPIC -std=c++17 -MD -MT plugins/widgetboxmodel/CMakeFiles/widgetboxmodel.dir/src/plugin.cpp.o -MF
[00:27:37] <manuels> CMakeFiles/widgetboxmodel.dir/src/plugin.cpp.o.d -o CMakeFiles/widgetboxmodel.dir/src/plugin.cpp.o -c /Users/manuel/albert/plugins/widgetboxmodel/src/plugin.cpp
[00:28:03] <ville> aiee!
[00:28:26] <manuels> but I get the error: In file included from /Users/manuel/albert/plugins/widgetboxmodel/src/plugin.cpp:6:
[00:28:43] *** Quits: Hello71 (~Hello71@wireguard/contributor/hello71) (Remote host closed the connection)
[00:28:43] *** Quits: Kebianizao (~Kebianiza@188.127.172.253) (Read error: Connection reset by peer)
[00:28:47] <ville> in general never paste to irc
[00:28:50] <manuels> this file is not! in the includes
[00:28:54] *** Joins: Kebianizao (~Kebianiza@188.127.172.253)
[00:28:58] *** Joins: Hello71 (~Hello71@wireguard/contributor/hello71)
[00:29:01] <manuels> sorry
[00:29:18] <ville> the message is saying that's the file which is doing the including
[00:29:27] <ville> it's not a file that is being included
[00:30:19] <ville> it's probably more lines that that as a result of an include chain but anyways
[00:31:47] <manuels> https://stackoverflow.com/questions/70229248/cmake-imports-files-from-other-subdir
[00:31:53] <manuels> more formatted info
[00:32:33] <manuels> it says In file included from /Users/manuel/Documents/projects/albert/plugins/widgetboxmodel/src/plugin.cpp:6:
[00:33:05] <manuels> irc is filtering some messages here sorry
[00:33:15] <manuels> Unknown command
[00:33:17] <manuels> whatever
[00:34:00] <manuels>  In file included from plugins/widgetboxmodel/src/plugin.cpp:  widgetboxmodel/src/../../chromium/src/plugin.h: error: redefinition of 'Plugin'
[00:34:09] *** Quits: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net) (Ping timeout: 256 seconds)
[00:34:09] <ville> irc isn't filtering them, your client interprets lines starting with / as commands
[00:34:26] <manuels> widgetboxmodel/src/plugin.cpp does not include widgetboxmodel/src/../../chromium/src/plugin.h
[00:34:36] <manuels> got to know
[00:34:39] <manuels> :D ty
[00:34:53] *** Quits: WarauSalesman (~sjw@69.206.48.64) (Remote host closed the connection)
[00:35:32] <ville> it doesn't have to explicitly include it by that name, presumably it does something like: #include "plugin.h"?
[00:35:54] *** Joins: SuperNintendoSUX (~sjw@69.206.48.64)
[00:35:57] <manuels> oh wo
[00:36:02] <manuels> OH WOW
[00:36:06] <manuels> I hate IDEs
[00:36:56] <manuels> I search for like half a day for this. CLion must have put this line there. Because I know I did not put it there I did not check
[00:36:58] <manuels> fml
[00:37:16] <manuels> ty ville for forcing me to check this
[00:38:06] <hnOsmium0001[m]> I
[00:38:19] <hnOsmium0001[m]> I'm surprised clang's error message didn't canoincalize the file paths
[00:58:31] *** Quits: luizfrds (~Luiz@152.250.243.147) (Ping timeout: 256 seconds)
[01:09:06] *** Quits: kenanmarasli (~kenanmara@user/kenanmarasli) (Quit: Leaving)
[01:18:23] *** Joins: magla (~gelignite@55d48eca.access.ecotel.net)
[01:18:30] *** Quits: xkuru (~xkuru@user/xkuru) (Read error: Connection reset by peer)
[01:21:56] *** Quits: proller (~p@2a02:6b8:b081:a424::1:1e) (Ping timeout: 252 seconds)
[01:27:40] *** Quits: magla (~gelignite@55d48eca.access.ecotel.net) (Quit: Stay safe!)
[01:35:33] *** Joins: proller (~p@80.240.216.69)
[01:37:10] *** Joins: Simplar (~Simplar@188.163.93.76)
[01:38:12] *** Quits: robod34 (Username@79.113.195.239) (Quit: Goe offline! ( http://marius.sucan.ro/ ))
[01:38:23] <Simplar> Please have a look at these 15 lines of code: https://wandbox.org/permlink/Bgka4NFaR1xsE8Vc | I wanted to know if there exists a better way (performance-wise) to implement this set of actions. Thank you!
[01:39:02] *** Quits: npaperbot (~npaperbot@dodecahedron.m-ou.se) (Remote host closed the connection)
[01:39:10] *** Joins: npaperbot (~npaperbot@dodecahedron.m-ou.se)
[01:39:10] *** ChanServ sets mode: +v npaperbot
[01:42:21] *** Joins: ferdna (~ferdna@user/ferdna)
[01:42:39] <johnny> you're hardly doing anything at all though, so i don't think it makes much of a difference
[01:44:00] *** Quits: philip (~philip@210.16.81.112) (Read error: Connection reset by peer)
[01:44:40] <Simplar> johnny: honestly, I am only bugged by 'double' conversion
[01:45:26] <johnny> why though?
[01:49:16] <Simplar> Preference I guess
[01:49:19] *** Quits: Simplar (~Simplar@188.163.93.76) (Quit: Going offline, see ya! (www.adiirc.com))
[01:50:20] <johnny> so not performance
[01:50:52] <johnny> the function takes a double, so you're telling it its getting a double
[01:56:55] *** Quits: Serpent7776 (~Serpent77@90-156-31-193.internetia.net.pl) (Quit: leaving)
[01:58:05] <RandomReader> Guest19 - there's also the book option, Templates: The Complete Guide has been recommended by folks, from this list:
[01:58:06] <RandomReader> !books
[01:58:08] <nolyc> A nice C++ book guide and list can be found at http://stackoverflow.com/q/388242/1090079
[01:59:43] <Guest19> Iah RandomReader, nice seeing you again. Thanks for the recommendation
[01:59:53] *** Quits: tesuji (~quassel@2a02:908:180:9500:dd45:c2b0:8a98:8612) (Ping timeout: 252 seconds)
[02:00:19] <RandomReader> (it's been on my list to read, I've been picking up templates pretty slowly on my own, but I haven't gotten around to it yet)
[02:00:55] *** Joins: markong (~kvirc@213.146.188.203)
[02:01:42] <Guest19> alright
[02:05:13] *** Quits: spaceangel (~spaceange@ip-78-102-216-202.net.upcbroadband.cz) (Remote host closed the connection)
[02:18:09] *** Quits: Juliu (~Juliu@2a02:810b:c640:3ec0:2129:7998:3c7b:2425) (Quit: Leaving)
[02:26:35] *** Quits: blyat-73 (~hjgkjhgkj@46.235.96.249) (Remote host closed the connection)
[02:29:16] *** Joins: blyat-73 (~hjgkjhgkj@46.235.96.249)
[02:29:42] *** Quits: blyat-73 (~hjgkjhgkj@46.235.96.249) (Client Quit)
[02:29:57] *** Joins: blyat-73 (~hjgkjhgkj@46.235.96.249)
[02:31:57] *** Quits: blyat-73 (~hjgkjhgkj@46.235.96.249) (Remote host closed the connection)
[02:32:56] *** Quits: ferdna (~ferdna@user/ferdna) (Quit: Leaving)
[02:33:41] *** Joins: blyat-73 (~hjgkjhgkj@46.235.96.249)
[02:52:39] *** Quits: dextercd (~dexter@2a02-a450-f25d-1-76d4-35ff-fefe-34c.fixed6.kpn.net) (Quit: WeeChat 3.3)
[03:04:45] *** Joins: aegon (~mike@174.127.249.180)
[03:05:09] <aegon> how come with a std::unique_ptr you have to change the template parameters when using a custom deleter, but with a shared_ptr it is not needed?
[03:05:38] *** Joins: freakazoid12345 (~matt@2603:9000:cf0f:80e3:346b:8ef4:4433:cb30)
[03:07:09] <aegon> `std::shared_ptr<T>(new T, [](auto x) { delete T; });` but unique needs more verbose info `std::unique_ptr<T, function<void(T*)>>(new T, [](auto x) { delete T; });`
[03:12:30] *** Quits: ss4 (~wootehfoo@user/wootehfoot) (Quit: Leaving)
[03:19:19] *** Joins: seninha (~seninha@user/seninha)
[03:26:05] <PJBoy> the rationale is a bit handwavy
[03:26:35] <PJBoy> shared_ptr stores its deleter type erased, so it doesn't need to be part of the type
[03:26:50] <PJBoy> but in exchange there's some unnecessary overhead in calling the deleter
[03:26:58] <PJBoy> and storing it
[03:27:05] *** Quits: ezzieyguywuf (~Unknown@user/ezzieyguywuf) (Read error: No route to host)
[03:27:13] <PJBoy> unique_ptr is designed to be zero overhead, so it doesn't do this
[03:27:35] *** Joins: ezzieyguywuf (~Unknown@user/ezzieyguywuf)
[03:27:53] <PJBoy> but for shared_ptr, it already allocates stuff and does other slow things, so it's considered a fine tradeoff to make the deleter type erased for the convenience it offers
[03:29:04] <PJBoy> that said, when constructing a shared_ptr, you either need to know the complete type of the pointer you're constructing it with, or you need to specify the deleter
[03:31:00] <aegon> oh interesting, i might be in ub land then
[03:32:06] <PJBoy> the paper for it has some details http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1450.html
[03:32:17] <aegon> i need to type erase some data and i have put it in a std::shared_ptr<void> with the expactation that the portion of the code base that knows and cares about its type will initialize a shared_ptr with the apropriate deleter
[03:32:26] <RandomReader> it's also required for some other traits of shared_ptr, e.g. the aliasing constructor
[03:32:55] <RandomReader> it boils down to shared_ptr having dynamic polymorphism with respect to the owned object, and unique_ptr not
[03:33:43] *** Joins: blackout69 (~blackout6@net-31-156-121-187.cust.vodafonedsl.it)
[03:33:51] <aegon> thats probably why i can do the shared_ptr<void> thing at all
[03:34:17] <RandomReader> exactly
[03:34:23] <aegon> where would you all suggest starting for understanding type erasure better in c++
[03:35:00] *** Parts: freakazoid12345 (~matt@2603:9000:cf0f:80e3:346b:8ef4:4433:cb30) (Leaving)
[03:35:20] *** Quits: wootehfoot (~wootehfoo@user/wootehfoot) (Read error: Connection reset by peer)
[03:35:35] <RandomReader> hm, maybe https://akrzemi1.wordpress.com/2013/11/18/type-erasure-part-i/ ?
[03:35:57] <RandomReader> it's a conceptual name rather than something concrete, so a variety of ways to achieve it
[03:36:33] *** Quits: blackout69 (~blackout6@net-31-156-121-187.cust.vodafonedsl.it) (Client Quit)
[03:36:41] *** Quits: very_sneaky (~very_snea@user/very-sneaky/x-7432109) (Ping timeout: 256 seconds)
[03:37:00] <RandomReader> in your case, what's the underlying purpose of this?
[03:37:12] <aegon> yeah last time i looked i read a couple different ways to do it that got mixed together and forgotten. That post looks good
[03:37:16] <RandomReader> e.g. is it really shared ownership, or do you just need to store "a thing" on behalf of client code?
[03:38:18] <aegon> in this case I have to store it, but this whole part needs clean up. I think i'm doing some logic that should be wrapped up in the library in the host code at the moment. Theres not enough runway to fix it for the next deadline though
[03:38:24] *** Joins: very_sneaky (~very_snea@user/very-sneaky/x-7432109)
[03:38:32] <RandomReader> ah
[03:38:45] <RandomReader> std::any might be a future option, if it fits
[03:39:36] <aegon> the library maintains network state with extra tagging and such for the host, the host does mutation on that state. and that needs to be passed back to the host for determining events against the state and rendering, most likely in a different thread
[03:40:45] <aegon> i could ask the client to make sure to move the cached bits around but at the start i thought it would "nicer" / more opqaue to work with if the lib just handed a cached thing to use for input / rendering
[03:41:44] <RandomReader> I've used it for that kind of separation before, provide a   std::any& context   to the host on events, and let it store whatever it wants there
[03:41:56] <aegon> less possible synchronization issues for a client to worry about or get wrong
[03:43:43] <aegon> whoa, how does it make sure std::swap matches type with std::any
[03:44:05] <aegon> oh i guess it doesn't matter
[03:45:02] <RandomReader> right, it would just exchange the two types and their contents as one bundle
[03:45:16] <aegon> thats cool
[03:46:10] <RandomReader> on first association the host would do  context.emplace<Foo>(...);  and subsequently   auto& foo = std::any_cast<Foo&>(context);   and do its thing
[03:46:45] <RandomReader> the any_cast interface is slightly more subtle than I'd like, since you're explicitly choosing a reference type .. but still less boilerplate-y than shared_ptr, if storage is the only goal
[03:48:21] <RandomReader> anyway, it's one option .. sounds like you do know the type specifically in some cases, so there might be something better when you get to reworking it
[04:00:34] *** Quits: RoKenn (~RoKenn@user/rokenn) (Quit: NSA proxy service interrupted)
[04:04:14] *** Joins: blackout69 (~blackout6@net-31-156-121-187.cust.vodafonedsl.it)
[04:07:22] *** Parts: blackout69 (~blackout6@net-31-156-121-187.cust.vodafonedsl.it) ()
[04:11:53] *** Quits: Burgundy (~yomon@79.115.213.171) (Ping timeout: 252 seconds)
[04:19:40] *** Quits: zen_coder (~zen_coder@2a02:8109:a280:2d8d:c0df:1ba6:10f2:5481) (Ping timeout: 268 seconds)
[04:25:50] *** Quits: TheHermann (~TheHerman@gateway/tor-sasl/thehermann) (Quit: Leaving)
[04:28:56] *** Quits: m_tadeu (~quassel@bl11-135-102.dsl.telepac.pt) (Ping timeout: 252 seconds)
[04:40:21] *** Joins: m_tadeu (~quassel@bl11-135-102.dsl.telepac.pt)
[04:44:48] *** Quits: SrainUser (~Srain@cpe-108-167-11-88.neb.res.rr.com) (Remote host closed the connection)
[05:08:57] <Alipha> aegon: why do you think you're doing UB? <aegon> oh interesting, i might be in ub land then
[05:10:44] <aegon> Alipha: wasn't sure if std::shared_ptr<void> was abuse given the info that shared_ptr needs to know the deleter on creation. I thought / am working off of the assumption that as long as someone does a .reset() on it and supplies a custom deleter thats appropriate for whatever type the put in there things will be good
[05:11:13] <aegon> i think if a client where to supply something with no custom deleter it might be UB because i'm not sure what kind of deleter would be reasonable for a void*
[05:14:16] <aegon> i thought std::shared_ptr<void>(reinterpret_cast<void*>(new int(1))); would be UB when it goes out of scope
[05:17:09] <aegon> just tried it though and it looks like at least gcc wont let you create or reset one with void* so maybe its impossible to get in that state.
[05:19:47] <Alipha> aegon: yeah, the default deleter does `delete p;` which is not legal if p is a void*
[05:20:16] <Alipha> { void* p = new int; delete p;}
[05:20:17] <geordi> warning: deleting 'void*' is undefined
[05:20:26] *** Joins: blackout69 (~blackout6@net-31-156-121-187.cust.vodafonedsl.it)
[05:21:18] <Alipha> aegon: also, use static_cast<void*> instead of reinterpret_cast, or simply not cast at all
[05:22:21] <aegon> why static instead of reinterpret? I thought static_casts have the potential to rearrange or reinterpret memory when going between pointer types
[05:22:49] <aegon> er, just rearrange or somehow modify
[05:23:09] <Alipha> There's no effective difference for casting to/from void*, but reinterpret_cast screams "I'M DOJNG SOMETHING I SHOULDN'T", which I wouldn't qualify casting to/from void* as that
[05:23:23] *** Quits: m_tadeu (~quassel@bl11-135-102.dsl.telepac.pt) (Ping timeout: 252 seconds)
[05:23:29] <aegon> i'm doing a bunch of reinterpret_casts between unsigned char *, std::byte* and types i want to send over the wire as bytes
[05:23:55] *** Joins: ferdna (~ferdna@user/ferdna)
[05:24:42] <aegon> by types being sent over the wire i mean contigous memory chunks that are arrays of word64's or whatever else
[05:25:07] <Alipha> Perfect use of reinterpret_cast, since that's a rather questionable or at least platform-specific thing to do :-p
[05:26:22] <Alipha> ... static_cast may adjust the pointer value then casting between pointer types in a class hierarchy, which is what you want to do in those cases
[05:28:35] *** Joins: luizfrds (~Luiz@152.250.243.147)
[05:31:46] <hnOsmium0001[m]> <rant> this bug https://bugs.llvm.org/show_bug.cgi?id=36684 is very annoying when you extensively utilize the technique of `struct Options { int option = 0; }; void foo(const Options& options& = {})` </rant>
[05:32:17] <hnOsmium0001[m]> I have to liter helper functions like `static Option makeDefaultOptions() { return {}; }` all over the place and write `void foo(const Options& options = makeDefaultOptions())`
[05:35:07] *** Quits: markong (~kvirc@213.146.188.203) (Ping timeout: 252 seconds)
[05:36:00] <PJBoy> sad face
[05:39:02] *** Quits: npaperbot (~npaperbot@dodecahedron.m-ou.se) (Remote host closed the connection)
[05:39:11] *** Joins: npaperbot (~npaperbot@dodecahedron.m-ou.se)
[05:39:11] *** ChanServ sets mode: +v npaperbot
[05:39:34] <RandomReader> note reinterpret_cast is not guaranteed to change representation, so don't use that as rationale: https://eel.is/c++draft/expr.reinterpret.cast#3
[05:39:46] <RandomReader> guaranteed to not change*
[05:40:02] *** Parts: blackout69 (~blackout6@net-31-156-121-187.cust.vodafonedsl.it) ()
[05:40:14] <RandomReader> hmm, many negatives .. "is not guaranteed to keep"
[05:42:00] <RandomReader> reinterpret_cast is essentially just standard language for doing implementation-specific things, sort of like #pragma
[05:43:46] <aegon> Alipha: interesting, didn't think about pointer values changing when going up / down a heirarchy
[05:44:07] <RandomReader> that's an interesting llvm bug
[05:45:14] <hnOsmium0001[m]> https://gcc.gnu.org/bugzilla/show_bug.cgi?id=88165 it's actually also a gcc bug (and surprisingly, msvc got it right)
[05:47:20] <aegon> RandomReader: reading that, maybe i'm still in trouble? I'm trying to send a uuid over the wire. I know its stored in ieee standard form and represented as struct { uint64_t ab, uint64_t cd }
[05:49:57] <aegon> to send it over the wire i'm doing const auto& Contigous = [ ab, cd ]; then network_func(reinterpret_cast<std::byte*>(Contigous), reinterpret_cast<std::byte*>(Contigous) + 16);
[05:53:33] *** Joins: Terminus (~null@user/terminus)
[05:54:56] <aegon> minimu snippit https://godbolt.org/z/Ea7zWxa5d
[05:56:48] <RandomReader> what's "ieee standard form" in this context?
[05:57:38] <aegon> https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.2
[05:58:22] <aegon> i'm trusting the uuid library creator on that but it seems widely used. using https://github.com/r-lyeh-archived/sole/blob/master/sole.hpp
[05:58:24] <RandomReader> a pair of uint64_ts would definitely not be that, so .. yeah, I'd say this approach does not accomplish the goal :P
[06:03:11] <RandomReader> that sole thing is some strange code
[06:04:03] <RandomReader> the .str() output is probably consistent (it'd take me a while to actually verify that), but the internal representation is not directly in UUID form and would not be serializable straight
[06:04:26] <RandomReader> at a high level, what you're doing is just a "serialization" problem
[06:04:49] <aegon> it looks like this is doing the right thing. https://github.com/r-lyeh-archived/sole/blob/master/sole.hpp#L651-L664
[06:04:50] <RandomReader> and in general, the most maintainable approach is to treat the in-memory and transport formats as separate, because in the vast majority of cases they are
[06:05:07] *** Quits: seninha (~seninha@user/seninha) (Quit: Leaving)
[06:05:11] <RandomReader> and so the process is a conversion between them, same as if you were dealing with CSV or any other format
[06:05:43] <RandomReader> it's only doing the right thing with respect to its internal value representation
[06:05:50] <RandomReader> it's *not* the same as the UUID byte-level format
[06:05:59] <aegon> maybe i was being naive in trusting whatever sole generates. Yeah, for the most part i'm sending network byte order uint8 / uint64 /uint16s around, i'm sending a string literal in one place, the only "compound" think i'm trying to send is the uuid
[06:06:18] *** Joins: seninha (~seninha@user/seninha)
[06:07:21] <RandomReader> sole doesn't appear to provide a UUID byte format
[06:07:37] <RandomReader> so not naive in terms of what it generates, just ignoring the fact that it doesn't have an API for what you want :P
[06:07:43] <RandomReader> it has a string API, and that's about it
[06:08:52] <aegon> welp, i'm reading rfc4122 and writing an adaptor tonight it seems :P
[06:09:56] <RandomReader> to break this down, let's assume the the first uint64_t ab is the time low/mid/hi components of the UUID byte form
[06:10:54] <RandomReader> the RFC specifies that "low" is the first part, as a 32bit value (4 bytes), stored in big endian (MSB first) .. then the mid component as a 16bit unit (2 bytes)
[06:11:04] <Alipha> aliases::Bytes b(16); uint64_to_be(x.ab, b.data()); uint64_to_be(x.cd, b.data() + 8); return b; // https://github.com/alipha/cpp/blob/master/endian/endian.hpp
[06:11:23] <RandomReader> uint64_t on the other hand is a single value, so the host is going to store that value in whatever its native endian format is
[06:12:07] <RandomReader> now if the native format is little endian (LSB first), then the first byte in sequence is actually the low byte of the "hi" component .. so completely opposite
[06:13:02] <RandomReader> sorry, first byte in sequence is the low byte of the "low" component, when the RFC wants the high byte of that component
[06:13:38] <RandomReader> if the native format is big endian, then the first byte in sequence is the high byte of the "hi" component, when the RFC doesn't even want that component
[06:14:16] <RandomReader> in this case you want a specific format, so you need to serialize the values into the correct byte order .. casting and reading is extra work because that means you need to care about host byte order
[06:14:16] *** Quits: blyat-73 (~hjgkjhgkj@46.235.96.249) (Remote host closed the connection)
[06:14:39] *** Joins: blyat-73 (~hjgkjhgkj@46.235.96.249)
[06:14:49] <RandomReader> but there's no reason to do that, because the real problem is like I said earlier, just about converting values .. so Alipha's functions can help with that, taking the plain values and outputing the bytes you want from them
[06:15:09] <RandomReader> (same logic as printing digits in CSV or whatever, these are just base256 digits)
[06:15:12] *** Quits: blyat-73 (~hjgkjhgkj@46.235.96.249) (Remote host closed the connection)
[06:15:27] *** Joins: blyat-73 (~hjgkjhgkj@46.235.96.249)
[06:16:05] <RandomReader> but first you need to have those values as separated as they are in the RFC, meaning the storage format needs to be uint32_t, uint16_t, uint16_t, uint8_t, uint8_t, and a nonexistent uint48_t
[06:16:33] <RandomReader> the OS UUID libraries usually break it up accordingly and have some helper functions to translate
[06:16:37] <RandomReader> this sole thing doesn't do that
[06:17:28] <RandomReader> so .. to use sole, you'll need to figure out what component is where, and write the math yourself to extract each value and serialize it accordingly
[06:17:48] *** Joins: tesuji (~quassel@2a02:908:180:9500:cd73:72f7:9168:fa9d)
[06:17:52] <RandomReader> or find another library .. this one using $ for identifiers is already nonstandard, and the code style is questionable
[06:18:21] <RandomReader> (I'm still assuming it actually does UUIDs correctly, it'd take a lot more time for me to verify that)
[06:19:37] <aegon> sorry I was trying to parse Alipha's header, why does it seem to not consider the hosts byte order / how does that work?
[06:19:56] <RandomReader> have you ever explored how to manually print an integer digit by digit?
[06:20:32] <aegon> RandomReader, whoa, thats a huge help and info dump.
[06:21:36] <aegon> no, i'm not sure how you'd do that accurately though, its stored in base 2 and your trying to print in base 10. that sounds super messy to me
[06:21:56] <RandomReader> ok, let's start with   int v = 123;
[06:22:34] <RandomReader> and I want to split this into separate values that represent each decimal (base 10) digit .. how would I get "3" from that, mathematically?
[06:23:18] <aegon>  % 10
[06:23:51] <RandomReader> right .. and then divide v by 10, which leaves 12, and repeat for the next digit
[06:24:25] <RandomReader> I don't need to know or care how v is stored to do that, it's just math
[06:24:33] <RandomReader> bytes are exactly the same, just base 256
[06:25:22] <RandomReader> and since 256 is a power of two, bitshifting produces the same results as division
[06:25:36] <RandomReader> if necessary I could also mask (& 0xff) to produce the same result as the remainder
[06:26:13] <RandomReader> Alipha's code is doing exactly that, just dividing, and then assigning each digit in the desired format order
[06:26:53] <RandomReader> (the remainder/mask is implicit, automatically truncated because of the assignment to a uint8_t/char/byte-sized type)
[06:27:43] <Alipha> "little endian" means the least significant byte is stored first. The least significant byte is `x & 0xff`
[06:27:49] <Alipha> https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html?m=1
[06:28:35] *** Joins: m_tadeu (~quassel@bl11-135-102.dsl.telepac.pt)
[06:29:45] <RandomReader> (the messy part with actually printing decimals is that you have to do it in reverse order, and the number of digits varies and doesn't directly match the base2 storage .. but for bytes, it's already an even division from the raw value anyway, so the number of digits is fixed and makes it simpler)
[06:30:31] <RandomReader> e.g. uint32_t is 4 digits in base256, always
[06:31:02] *** Quits: emerent (~quassel@p200300cd571578eaba27ebfffed28a59.dip0.t-ipconnect.de) (Ping timeout: 252 seconds)
[06:31:31] *** Joins: emerent (~quassel@p200300cd571645bfba27ebfffed28a59.dip0.t-ipconnect.de)
[06:31:46] <RandomReader> well that and we usually don't want leading zeroes for decimals .. also not a problem for this case
[06:33:09] <aegon> heh, sorry I'm quiet because i'm processing. I have some mental block around converting between le / be and the shift operators. C++ always treats values logically as big endian right?
[06:33:31] <aegon> ie, >> 8 shifts off the most significant byte regaurdless of host byte order
[06:33:55] <RandomReader> yes .. to it, it's a value made up of continuous bits, highest bit first
[06:34:20] <RandomReader> so if it's a 32 bit value, then you just pulled down the high 24 bits of it, regardless of how it's really stored underneath
[06:35:11] <RandomReader> hm, I guess that would be "shifts off the least significant byte" then? that's the part of the value that was removed
[06:35:45] <RandomReader> so if the value is originally 0x12345678, the new value is 0x00123456
[06:36:11] *** Quits: Terminus (~null@user/terminus) (Quit: ZNC 1.8.2 - https://znc.in)
[06:36:30] <RandomReader> 0x78 being the least significant 8 bits
[06:36:40] *** Quits: Roughy (~mdaw45ns@user/roughy) (Quit: Meadow Fresh milk)
[06:36:47] <aegon> so thats little endian right?
[06:37:07] *** Quits: aleios (~aleios@user/aleios) (Quit: WeeChat 3.3)
[06:37:37] <RandomReader> big endian storage form would be 0x12 0x34 0x56 0x78 .. little endian storage form would be 0x78 0x56 0x34 0x12
[06:37:51] *** Quits: m_tadeu (~quassel@bl11-135-102.dsl.telepac.pt) (Ping timeout: 245 seconds)
[06:38:03] <aegon> ok, thats backwards from the way i had it in my head
[06:38:04] <RandomReader> most significant -> largest magnitude part of th evalue
[06:38:07] <RandomReader> the value*
[06:38:22] <RandomReader> and big endian is "most significant first"
[06:38:52] <RandomReader> which happens to match how we write numbers, at least in Arabic writing forms
[06:39:10] <aegon> ok, and c++ semantically is big endian all the time
[06:40:04] *** Joins: Terminus (~null@user/terminus)
[06:40:10] <RandomReader> that's one way of looking at it .. I'd be careful not to take that too far, since people usually equate "endian" to "storage", but yes I'd agree as far as the mathematical operators go .. that's certainly how it thinks of bits, otherwise left/right shift would make no sense
[06:40:43] <RandomReader> I wonder what the etymology of that is actually .. why didn't we call it "down shift" or "up shift"
[06:42:17] <aegon> ok i think i'm getting it, and based on waht Alipha said, the & operator semantically starts from the "right" end of the value
[06:42:47] <aegon> so 0xFF FF FF FF & 0xFF is kinda like 0x00 00 00 FF
[06:42:58] *** Joins: great_taste (~great_tas@user/great-taste/x-5798414)
[06:43:15] <RandomReader> it's exactly like that, the 0xFF is promoted to the same size value, then the operation is performed
[06:47:29] <aegon> for whatever reason that is mental backflips for me. Hopefully it gets easier over time. So i need to break this struct up from a semantically be representation that has been masked for the the right values into a network byt order (big endian) version that is chunked into the right values according to rfc4122
[06:47:38] <aegon> Alipha: is it alright if i grab that header?
[06:48:09] <RandomReader> right
[06:48:14] *** Quits: plastico (~plastico@neomutt/plastico) (Quit: WeeChat 3.3)
[06:48:33] <RandomReader> if you look at part of it like the uuid1() function, it shows the components and how it shifts them for storage
[06:48:45] *** Joins: m_tadeu (~quassel@bl11-135-102.dsl.telepac.pt)
[06:48:53] <RandomReader> (actually looks like the time components are stored opposite of what I assumed earlier)
[06:49:32] <RandomReader> so you can tell where they end up, logically/mathematically, in the uint64_t pair
[06:52:28] <RandomReader> and given the way str() is written, you might actually be able to do this in sequence .. just as a sequence of math rather than a cast
[07:01:02] <aegon> got a mnemonic , C++ is big endian just like the C is big endian in the name. makes no sense but i bet i'll remember better :P
[07:01:26] <johnny> huh?
[07:01:43] <RandomReader> hehe
[07:02:17] <johnny> i only deal with endianess when it comes to network stuff, so i still think about network byte order
[07:02:36] <johnny> i've never messed with big endian hardware
[07:03:26] <johnny> everything i mess with is LE there
[07:03:30] <aegon> i've been trying to figure out why this was working between client and server. I double checked. The peers make their own uuid's, pass em off to the host, and the host treats them as opaque bits and resends them when it wants to identify a peer
[07:04:02] <aegon> the same holds for the host so even though I've been messing up serialization, its messed up the same way on each end and all the peers are the same type of client in the tests so far so it "jsut works"
[07:04:31] <johnny> been there, done that
[07:05:10] <aegon> i can't figure out what source of info is reliable on this topic, but it seems most hardware supports both big and little endian ops these days?
[07:05:43] <johnny> depends on what you mean by operation..
[07:05:53] <johnny> harwdare is native to one or the other usually
[07:06:08] <johnny> arm stuff and x86 is all LE
[07:06:18] <johnny> or almost all anyways
[07:06:44] <johnny> hmm.. i can't remember if avr is
[07:08:32] <aegon> ok, so the state of the world is... when binary is written its usually in little endian form, semantically in c++ its in big endian, hardware usually operates in little endian, and bit masks can look little endian but they actually get padded and are also semantically big endian
[07:08:51] <aegon> @_@
[07:09:01] <johnny> huh?
[07:09:32] *** Quits: m_tadeu (~quassel@bl11-135-102.dsl.telepac.pt) (Ping timeout: 252 seconds)
[07:09:40] <johnny> well i guess i don't see anybody talking about how the number 1234 has an endianness
[07:09:55] <johnny> since that's just how numbers work
[07:10:04] <johnny> or at least the way we talking about them
[07:10:38] <aegon> this is way off topic now but i wonder if there are any civilizations that did it the other way around
[07:10:55] <johnny> such that 1234 would be 4321 to them?
[07:11:01] <aegon> math was first "thoguht up" in arabaic derived civilizations right?
[07:11:04] <aegon> yeah
[07:11:16] <aegon> "formalized"
[07:11:20] <johnny> well 'm sure it's not hard to find out
[07:11:35] *** Joins: nightstrike (uid487@id-487.uxbridge.irccloud.com)
[07:11:42] <johnny> well they are indeed arabic numerals, but even roman numerals follow that order
[07:13:50] <johnny> if you're saying semnatically in $LANG" the value of $LANG would be most of the well known programming languages
[07:18:44] *** Joins: m_tadeu (~quassel@bl11-135-102.dsl.telepac.pt)
[07:22:32] <Alipha> aegon: yes, you can have the header. I'd appreciate credit, but not required
[07:23:25] <aegon> awesome, do you want to be credited as Alipha? or should i point to git account? whats the best id
[07:23:50] <Alipha> aegon: link to the github is best
[07:24:03] <Alipha> Or, yes, Alipha
[07:24:21] <aegon> yeah, i'm not complaining, i'm sure the origin of the semantics has a war story behind it. I feel like there must be a story behind that as well
[07:24:53] <aegon> .data() was not required to be null terminated until 11? then it was and is the same as c_str() with a padded null byte, but the size doesn't reflect this extra byte
[07:26:18] <aegon> so memcpy from a std::string to a passed in c_str looks like somethings wrong :P memcpy(dest, str.data(), str.size() + 1)
[07:26:56] *** Quits: seninha (~seninha@user/seninha) (Remote host closed the connection)
[07:27:47] <aegon> Alipha: did both :), thanks for letting me use it.
[07:29:35] <aegon> by that i meant std::string and data / c_str ops
[07:30:41] <johnny> fill a vector from a std::string and you don't get the null byte
[07:30:48] <johnny> i know that for sure :(
[07:31:36] <johnny> i don't quite know why that's the case, but it so
[07:32:45] <RandomReader> string is just a container of chars, so it's completely consistent from that standpoint .. the null byte is an extra for C-string compatibility, so only those interfaces deal with it
[07:32:45] <johnny> i guess it's not specialized for std::string, just generic range, so you wouldn't end up with double nul for a string from a string
[07:33:10] <johnny> well i'm not even use C compat, so i have to keep pushing back the extra nul  later
[07:33:34] <RandomReader> what do you mean? without needing the C compatibility, there's no need for a null
[07:33:52] <johnny> ah, i guess in reality it probably is for C compat.. just not from my side
[07:34:18] <johnny> i don't actually know how they implement it in their scripting engine
[07:36:39] <johnny> if nothing else it's a convenient record separator
[07:39:05] *** Joins: aleios (~aleios@user/aleios)
[07:39:30] *** Joins: ent58 (~ent58@rrcs-97-76-214-244.se.biz.rr.com)
[07:48:28] *** Quits: ent58 (~ent58@rrcs-97-76-214-244.se.biz.rr.com) (Quit: Client closed)
[07:52:38] *** Joins: ent58 (~ent58@rrcs-97-76-214-244.se.biz.rr.com)
[07:52:54] *** Joins: ravan (~ravan@user/ravan)
[07:56:50] *** Quits: m_tadeu (~quassel@bl11-135-102.dsl.telepac.pt) (Ping timeout: 252 seconds)
[08:05:31] *** Joins: lh_mouse (~lh_mouse@mingw-w64/developer/lhmouse)
[08:08:45] *** Quits: luizfrds (~Luiz@152.250.243.147) (Ping timeout: 252 seconds)
[08:13:32] *** Quits: CarloWood (~LdK13@212-127-230-18.cable.dynamic.v4.ziggo.nl) (Ping timeout: 240 seconds)
[08:14:15] *** Joins: m_tadeu (~quassel@bl11-135-102.dsl.telepac.pt)
[08:26:36] *** Quits: nightstrike (uid487@id-487.uxbridge.irccloud.com) ()
[08:33:22] *** Quits: AmR (~AmREiSa@156.199.223.24) (Quit: Konversation terminated!)
[08:52:56] *** Quits: unixpro1970 (~unixpro19@c-73-181-185-205.hsd1.wa.comcast.net) (Ping timeout: 252 seconds)
[09:02:56] *** Joins: unixpro1970 (~unixpro19@c-73-181-185-205.hsd1.wa.comcast.net)
[09:27:43] *** Quits: great_taste (~great_tas@user/great-taste/x-5798414) (Quit: Client closed)
[09:34:19] *** Joins: frost (~frost@user/frost)
[09:39:03] *** Quits: npaperbot (~npaperbot@dodecahedron.m-ou.se) (Remote host closed the connection)
[09:39:10] *** Joins: npaperbot (~npaperbot@dodecahedron.m-ou.se)
[09:39:10] *** ChanServ sets mode: +v npaperbot
[10:01:48] *** Quits: ferdna (~ferdna@user/ferdna) (Quit: Leaving)
[10:04:37] *** Quits: PJBoy (~PJBoy@user/pjboy) (Ping timeout: 252 seconds)
[10:18:24] *** Quits: shailangsa (~shailangs@host86-162-150-209.range86-162.btcentralplus.com) (Ping timeout: 265 seconds)
[10:22:28] *** Joins: CarloWood (~LdK13@212-127-230-18.cable.dynamic.v4.ziggo.nl)
[10:24:43] <very_sneaky> there's not much more frustrating than finding a really cool, small, open source project, that's actually useful in your day to day
[10:25:10] <very_sneaky> and then trying to contribute to it, just to find that the author is very unengaged and will leave PRs up for 6+ months without review
[10:25:29] <very_sneaky> or discussion on issues
[10:27:01] <ent58> fork! heh
[10:34:28] <very_sneaky> yeah, i mean that is the solution. it is nice to have a central place that it's maintained and discovered though
[10:44:49] *** Joins: shailangsa (~shailangs@host86-186-142-82.range86-186.btcentralplus.com)
[11:06:36] *** Joins: Juliu (~Juliu@2a02:810b:c640:3ec0:7515:120c:400a:3571)
[11:12:19] *** Joins: gggp (~gggp@60.10.194.46)
[11:16:07] <aegon> very_sneaky: you could ask for perms on the repo to maintain it
[11:16:47] *** Joins: meator (~meator@user/meator)
[11:18:53] <aegon> :D
[11:19:03] <very_sneaky> yeah, i'm considering it
[11:19:07] *** Quits: aleios (~aleios@user/aleios) (Quit: WeeChat 3.3)
[11:19:11] <very_sneaky> i think maintenance time would actually be pretty low
[11:20:02] <aegon> i have an open source project out there that gets questions on and its super time consuming to do. I'd be really happy if someone asked for that kinda thing
[11:20:04] <ville> aegon: what do you mean "in c++ it's in big endian"?
[11:20:40] <aegon> i end up neglecting it for 6 months + at a time just because its a coupld staggared weekends to try to take care of things and i get burnt out
[11:20:59] <very_sneaky> aegon: yeah, i get ya. I'm a bit like that with my blog
[11:21:20] <very_sneaky> I don't blame the author at all for this, it's just a bit frustrating being on the other side of it haha - i wish it were well maintained
[11:21:38] <very_sneaky> we only have so much time in the day to care about things
[11:21:55] <aegon> ville: i mean semantically, where >> is shifting the least significant bits first and << is shifting the most signifcant bits
[11:23:16] <Stryyker> I'm confused
[11:23:27] <ville> aegon: sure. that's just following the "standard" positional system used by most people on the planet where the multiplier of a higher power comes on left
[11:25:51] <aegon> I don't mean to critisize it. The whole thing with bigendian / littleendian is super confusing. whatever way things went it would have been confusing for one reason or the other
[11:26:01] <ville> the direction of the << being just a visual mnemonic to which way the binary digits are being shifted
[11:26:03] <aegon> I was super confused when learning it but I bet cppreference actually explains it
[11:27:20] <ville> even in binary 0b10100011 that's the same positional notation as you're used to in decimal 432409
[11:27:31] *** Quits: frost (~frost@user/frost) (Ping timeout: 256 seconds)
[11:27:59] <aegon> ok, cppreference is pretty long winded in its explanation but the examples are clear
[11:28:08] <ville> nothings changed except radix and the set of valid digits
[11:42:33] *** Joins: gggp_ (~gggp@60.10.23.170)
[11:44:32] *** Quits: gggp (~gggp@60.10.194.46) (Ping timeout: 252 seconds)
[11:45:38] *** Quits: blyat-73 (~hjgkjhgkj@46.235.96.249) (Ping timeout: 252 seconds)
[11:59:25] *** Quits: gggp_ (~gggp@60.10.23.170) (Remote host closed the connection)
[12:00:09] *** Joins: gggp (~gggp@120.245.40.131)
[12:05:13] *** Quits: skapata (~Skapata@user/skapata) (Remote host closed the connection)
[12:05:38] *** Joins: Serpent7776 (~Serpent77@90-156-31-193.internetia.net.pl)
[12:13:53] *** Joins: Burgundy (~yomon@79.115.213.171)
[12:14:59] *** Joins: DSpider (~DSpider@82.79.237.44)
[12:16:58] *** Quits: Tobbi (~Tobbi@2a02:8108:1240:48ec:f08c:4877:a491:d984) (Ping timeout: 268 seconds)
[12:20:50] <andi_> hello, can somebody help me improve my code? https://paste.xinu.at/6cp/ on the top there's a toy.fmi which should show the form. is there anything i can improve performance?
[12:24:25] <andi_> the file i'm going to read is ~3 GB and it takes arounc 34 seconds on my pc (compiled with clang or release)
[12:28:03] <very_sneaky> andi_: have you tried profiling it?
[12:29:15] <andi_> very_sneaky: with perf
[12:29:31] *** Joins: gggp_ (~gggp@60.10.194.46)
[12:29:55] <andi_> very_sneaky: but i think my algorithm is pretty straight forward, and i don't have any other idea on how to read a file like toy.fmo
[12:30:11] <very_sneaky> i mean it looks pretty minimal. not sure i love that input format though
[12:30:36] *** Joins: robod34 (Username@79.113.195.239)
[12:30:39] <andi_> well i can't change the input :-/ i don't like the input either
[12:30:55] *** Quits: gggp (~gggp@120.245.40.131) (Ping timeout: 252 seconds)
[12:32:37] <very_sneaky> where are you reading this data from?
[12:32:45] <very_sneaky> 34seconds indicates ~88MB/s
[12:33:02] <andi_> very_sneaky: a nvme
[12:33:36] <very_sneaky> sounds pretty slow then...
[12:33:53] <andi_> well that's why i ask
[12:34:35] <very_sneaky> i have no idea how efficient streams are
[12:34:47] <andi_> would you do something else?
[12:35:28] *** Joins: gggp (~gggp@120.245.46.84)
[12:36:22] <very_sneaky> my first instinct would be to use streams, but in the case of performance issues, perhaps i'd revert to the C api? - fgets etc. somebody else is probably better advising on this though
[12:36:28] <Alipha> andi_: why are you getting a line at a time and then putting them into stringstreams instead of using >> directly on the file stream?
[12:36:41] *** Quits: gggp_ (~gggp@60.10.194.46) (Remote host closed the connection)
[12:36:45] <andi_> Alipha: i don't know better
[12:37:41] <andi_> so i should remove the getline() and just use stringStream >> a >> b >> ..?
[12:38:36] <Alipha> inputStream >> a >> b >> ..
[12:39:04] <Alipha> Looks like the only getline you need is for removing the header
[12:39:46] <very_sneaky> yeah, creating that string stream object every loop is probably expensive
[12:40:00] <Alipha> very_sneaky: it's super expensive
[12:40:27] <andi_> so like this?
[12:40:28] <andi_> https://paste.xinu.at/wvGn/
[12:40:33] <andi_> that's ~ 9 seconds
[12:40:55] <very_sneaky> 333MB/s
[12:41:09] <andi_> that's probably i/o bound?
[12:41:39] <Alipha> Alright, I improved it by 277%. I'm done ;-)
[12:41:46] <andi_> :D
[12:41:56] <very_sneaky> run it in callgrind and see where your bottlenecks are
[12:42:35] <ville> ...or just write a program that simply reads the file, does no parsing, and see how fast that goes
[12:45:48] <very_sneaky> it might also be the drive you have. depending on what it is, the average read speed should be between ~350 and ~3300 MB/s - i'm assuming that's megabytes and not mibibytes
[12:46:10] <very_sneaky> pretty big range though
[12:46:38] <Alipha> Yeah, I'd fread into a 1MB buffer or something in a loop and read your file just to see how fast that is
[12:47:16] <andi_> reading the file takes ~ 1 sec
[12:47:39] <very_sneaky> so order of magnitude slow down for the parsing you're doing
[12:49:08] <RandomReader> also don't forget the unix "time" utility for something like this .. since it shows both real and cpu time, you can tell at a glance if it's cpu-bound (code) or waiting for something external (i/o)
[12:49:36] <very_sneaky> hmm, i haven't explored this question since using HDDs - does parallel reading of files get you an appreciable speedup? last time I thought about this the answer i landed on was no because the head still needs to seek to the read location, but in the case of an SSD, presumably this physical constraint doesn't exist in the same way?
[12:49:39] <Alipha> I'm curious how the fscanf would compare. And you are compiling with optimization, right?
[12:52:16] <andi_> Alipha: yeah clang on -DCMAKE_BUILD_TYPE:STRING=Release that's what i compile with
[12:52:45] <andi_> Alipha: if you want to test, you can download the file
[12:52:53] <very_sneaky> what does clang use in release by default - -O3?
[12:54:44] *** Joins: TheHermann (~TheHerman@gateway/tor-sasl/thehermann)
[12:55:55] <very_sneaky> hm, looks like that's what cmake does with release. -O3.
[13:13:02] <ville> i don't think the standard library implementations for float parsing are great either, so you could look for a win there if you've lot of floats in your original input
[13:21:00] <andi_> my fscanf() idea is also slower with ~ 19 sec https://paste.xinu.at/0wXG4/
[13:22:01] <andi_> Alipha: ^
[13:22:19] <ville> but now that you got rid of bunch of useless allocations it's probably a good time to look into real profiling tools
[13:22:56] <andi_> ville: perf for example?
[13:23:08] <ville> sure perf could be one
[13:24:28] <ville> if you want fancy ui then https://github.com/KDAB/hotspot could be worth investigating, and for memory: https://github.com/KDE/heaptrack
[13:24:57] <ville> still uses perf but perhaps represents some of the results in nicer ways
[13:27:48] *** Joins: blackout69 (~blackout6@net-31-156-121-187.cust.vodafonedsl.it)
[13:29:56] *** Joins: Tobbi (~Tobbi@2a02:8108:1240:48ec:904a:a72e:d737:8bb9)
[13:39:04] *** Quits: npaperbot (~npaperbot@dodecahedron.m-ou.se) (Remote host closed the connection)
[13:39:11] *** Joins: npaperbot (~npaperbot@dodecahedron.m-ou.se)
[13:39:11] *** ChanServ sets mode: +v npaperbot
[13:48:05] *** Quits: chozorho (~chozorho@2601:146:300:c30::71e1) (Quit: WeeChat 3.0)
[13:48:47] *** Joins: kenanmarasli (~kenanmara@user/kenanmarasli)
[13:50:30] *** Joins: magla (~gelignite@55d41880.access.ecotel.net)
[14:04:06] *** Quits: blackout69 (~blackout6@net-31-156-121-187.cust.vodafonedsl.it) (Quit: Leaving.)
[14:05:02] *** Quits: ent58 (~ent58@rrcs-97-76-214-244.se.biz.rr.com) (Quit: Client closed)
[14:10:58] *** Joins: gggp_ (~gggp@111.63.44.9)
[14:13:07] *** Joins: plastico (~plastico@neomutt/plastico)
[14:13:35] *** Quits: gggp (~gggp@120.245.46.84) (Ping timeout: 252 seconds)
[14:22:08] <ac_slater> hey guys, I'm mixing C and C++. I have this struct in C `struct foo { int whatever; void * cxx_thing; };`. I malloc sizeof(struct foo) for a foo, and the malloc sizeof my cxx class into cxx_thing. I use placement new to put the object in that malloc'd region
[14:22:36] <ac_slater> I manually call the dtor when I'm done. But freeing the `foo` makes leak sanitizer barf with heap-use-after-free
[14:22:57] *** Quits: gggp_ (~gggp@111.63.44.9) (Remote host closed the connection)
[14:23:06] *** Joins: gggp (~gggp@60.10.23.170)
[14:24:01] *** Joins: pulse (~pulse@user/pulse)
[14:24:02] <ac_slater> I'll make a paste
[14:30:45] *** Quits: AbleBacon (~AbleBacon@user/AbleBacon) (Read error: Connection reset by peer)
[14:33:51] *** Joins: zen_coder (~zen_coder@2a02:8109:a280:2d8d:308b:2fd2:efd1:89d)
[14:33:57] <ac_slater> well damn, a simple paste is OK.
[14:35:48] <ac_slater> https://coliru.stacked-crooked.com/a/ac0a593d17f278a5
[14:35:57] <ac_slater> anyway, maybe I'll have a clear head tomorrow. Night
[14:38:44] <ville> yes that looks fine
[15:00:11] *** Joins: undeclared (nullx@user/undeclared)
[15:18:40] *** Joins: spaceangel (~spaceange@ip-78-102-216-202.net.upcbroadband.cz)
[15:30:27] *** Joins: xkuru (~xkuru@user/xkuru)
[15:43:32] *** Joins: markong (~kvirc@213.146.188.203)
[15:53:40] *** Joins: Jupp_S (~quassel@ip-88-153-154-129.hsi04.unitymediagroup.de)
[15:55:53] *** Quits: Tobbi (~Tobbi@2a02:8108:1240:48ec:904a:a72e:d737:8bb9) (Ping timeout: 252 seconds)
[15:56:26] *** Joins: blackout69 (~blackout6@net-31-156-121-187.cust.vodafonedsl.it)
[15:56:28] *** Joins: paul424 (~tom@ip-37-248-157-200.multi.internet.cyfrowypolsat.pl)
[16:00:27] *** Joins: night_wulfe_ (~wulfe@cpe-174-103-156-213.cinci.res.rr.com)
[16:03:35] *** Quits: night_wulfe (~wulfe@cpe-174-103-156-213.cinci.res.rr.com) (Ping timeout: 252 seconds)
[16:15:45] *** Quits: zen_coder (~zen_coder@2a02:8109:a280:2d8d:308b:2fd2:efd1:89d) (Quit: Konversation terminated!)
[16:18:59] *** Joins: Roughy (~mdaw45ns@user/roughy)
[16:21:53] *** Quits: blackout69 (~blackout6@net-31-156-121-187.cust.vodafonedsl.it) (Quit: Leaving.)
[16:22:42] *** Quits: paul424 (~tom@ip-37-248-157-200.multi.internet.cyfrowypolsat.pl) (Remote host closed the connection)
[16:22:48] *** Joins: blackout69 (~blackout6@net-31-156-121-187.cust.vodafonedsl.it)
[16:24:19] *** Joins: PJBoy (~PJBoy@user/pjboy)
[16:35:12] *** Parts: blackout69 (~blackout6@net-31-156-121-187.cust.vodafonedsl.it) ()
[16:40:54] *** Quits: tesuji (~quassel@2a02:908:180:9500:cd73:72f7:9168:fa9d) (Ping timeout: 268 seconds)
[16:42:11] *** Quits: aegon (~mike@174.127.249.180) (Remote host closed the connection)
[16:46:43] *** Quits: xkuru (~xkuru@user/xkuru) (Read error: Connection reset by peer)
[17:04:07] *** Quits: mitch0 (~mitch@87-97-23-118.pool.digikabel.hu) (Ping timeout: 256 seconds)
[17:05:15] *** Quits: baltazar (~baltazar@87-97-23-118.pool.digikabel.hu) (Ping timeout: 256 seconds)
[17:09:36] *** Quits: radu242407 (~radu242@pool-96-250-79-242.nycmny.fios.verizon.net) (Quit: The Lounge - https://thelounge.chat)
[17:10:35] *** Joins: radu242407 (~radu242@pool-96-250-79-242.nycmny.fios.verizon.net)
[17:15:48] *** Parts: meator (~meator@user/meator) (Leaving)
[17:17:47] *** Quits: DSpider (~DSpider@82.79.237.44) (Quit: Leaving)
[17:17:55] *** Joins: callq (~callq@157.41.190.133)
[17:18:27] *** Joins: Tobbi (~Tobbi@2a02:8108:1240:48ec:39e5:2460:8e30:88af)
[17:39:04] *** Quits: npaperbot (~npaperbot@dodecahedron.m-ou.se) (Remote host closed the connection)
[17:39:11] *** Joins: npaperbot (~npaperbot@dodecahedron.m-ou.se)
[17:39:11] *** ChanServ sets mode: +v npaperbot
[17:40:21] *** Quits: HvszrStykp (~X@81.171.62.87) (Ping timeout: 245 seconds)
[17:41:29] *** Quits: Tobbi (~Tobbi@2a02:8108:1240:48ec:39e5:2460:8e30:88af) (Ping timeout: 252 seconds)
[17:43:06] *** Quits: Ivii (~Ivyy@2001:a62:4c3:8e01:dac0:2a17:49d5:efcf) (Remote host closed the connection)
[17:44:16] *** Joins: Ivii (~Ivyy@2001:a62:4c3:8e01:7af8:48a4:d785:9ce7)
[17:49:56] <PJBoy> !fact
[17:49:58] <nolyc> PJBoy: The complexity of basic_string_view member functions is O(1) unless otherwise specified.
[17:50:31] *** Joins: seninha (~seninha@user/seninha)
[17:56:49] *** Joins: mitch0 (~mitch@94-21-221-155.pool.digikabel.hu)
[17:58:13] *** Joins: AmR (~AmREiSa@156.199.223.24)
[17:58:18] *** Quits: vdamewood (~vdamewood@fedora/vdamewood) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[18:05:08] *** Quits: radu242407 (~radu242@pool-96-250-79-242.nycmny.fios.verizon.net) (Ping timeout: 252 seconds)
[18:10:06] *** Joins: blyat-73 (~hjgkjhgkj@46.235.96.249)
[18:22:11] *** Joins: jkaye (~jkaye@2601:281:8300:7530:5a4f:5910:1ea1:e61f)
[18:25:06] *** Quits: gggp (~gggp@60.10.23.170) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[18:27:10] *** Joins: tesuji (~quassel@2a02:908:180:9500:712e:1c30:1e5e:7145)
[18:27:29] *** Joins: baltazar (~baltazar@94-21-221-155.pool.digikabel.hu)
[18:32:08] *** Joins: Tobbi (~Tobbi@2a02:8108:1240:48ec:5052:6286:866e:fc49)
[18:33:23] *** Quits: unyu (~pyon@user/pyon) (Quit: WeeChat 3.3)
[18:34:35] *** Joins: unyu (~pyon@user/pyon)
[18:36:11] *** Joins: xkuru (~xkuru@user/xkuru)
[18:36:39] *** Joins: radu242407 (~radu242@pool-96-250-79-242.nycmny.fios.verizon.net)
[18:43:35] <pulse> !rq
[18:43:35] <nolyc> pulse: <rpav> let's all switch to perforce
[18:43:54] <pulse> Ugh
[18:50:31] <manuels> in the case of dreaded diamond. what happens if the virtual base accepts a value in the constuctor which the two base classes set?
[18:56:50] <manuels> okay
[18:56:50] <manuels> https://godbolt.org/z/jY5bo3Ghe
[18:57:31] <manuels> so i guess in this case we would have to explicitly init the virtual base
[19:08:17] *** Joins: artok (~azo@mobile-access-5672c9-83.dhcp.inet.fi)
[19:13:25] <PJBoy> yeah the most derived class is responsible for initialising virtual base classes
[19:14:06] <PJBoy> virtual base classes being initialised before all other base classes
[19:27:44] *** Joins: voltron (~voltrin_@ip4d16bdc6.dynamic.kabel-deutschland.de)
[19:33:30] *** Joins: Patcher (~hendrik@p200300d8ef064b003664a9fffed44247.dip0.t-ipconnect.de)
[19:33:36] <Patcher> Hello
[19:34:02] <Patcher> is c++ memory leaking? a friend of mine told me c++ is bad and memory leaking? Is this true?
[19:34:47] <artok> that
[19:34:52] <artok> really good friend?
[19:35:06] <Patcher> i really don't know
[19:35:13] <Patcher> is it true?
[19:36:05] <Patcher> @artok
[19:39:57] <artok> modern c++ memory allocation and pointers are quite safe, because freeing memory is done automatically
[19:43:08] <artok> if you want, you can make your program to leak memory by foolishly use expression new https://en.cppreference.com/w/cpp/language/new
[19:44:46] <pulse> "a friend of mine told me c++ is bad and memory leaking?"
[19:44:47] <pulse> Seems legit
[19:45:07] <artok> I'd say that your friend is just trolling
[19:45:14] <Patcher> thank you, i love c, i am probably gonna stay by c
[19:45:17] <Patcher> but still thanks
[19:45:18] <Patcher> yeah
[19:45:20] <Patcher> i agree
[19:45:33] <Patcher> thank you have a good day / night
[19:45:57] <artok> basically using malloc is same as new, so it's easier to leak memory with c than c++ =)
[19:46:06] <Patcher> yeah
[19:46:30] <Patcher> i know i like to manage malloc manually
[19:46:35] <Patcher> allocs*
[19:47:35] *** Joins: RoKenn (~RoKenn@2001:a61:3432:ab01:c2ec:6263:8e29:744a)
[19:47:36] *** Quits: RoKenn (~RoKenn@2001:a61:3432:ab01:c2ec:6263:8e29:744a) (Changing host)
[19:47:36] *** Joins: RoKenn (~RoKenn@user/rokenn)
[19:48:13] <Patcher> X)
[19:48:31] *** Joins: great_taste (~great_tas@user/great-taste/x-5798414)
[19:48:48] <artok> if you really want to have possibility for memory leak, sure, keep doing that =)
[19:49:13] <Patcher> why is it memory leaking when i allocate memory and then deallocate it?
[19:50:43] <PJBoy> probably the most common leak associated with manual memory management is due to lack of exception safety
[19:51:02] <PJBoy> if an exception gets thrown, your non-RAII deallocation strategy doesn't work
[19:51:24] <PJBoy> unless you actually catch all possible exceptions for every expression that might throw
[19:51:48] <Patcher> but why should it throw a exception when you test your program for "idiots safety"
[19:52:07] <PJBoy> exceptions exist
[19:52:12] <Patcher> sure they do
[19:52:12] <PJBoy> and they get thrown sometimes
[19:52:19] <Patcher> but not often
[19:52:22] <Patcher> but tell me
[19:52:25] <Patcher> when?
[19:52:32] <PJBoy> when a throw statement is executed
[19:52:41] <Patcher> wow
[19:52:42] <PJBoy> which happens under a wide variety of circumstances
[19:52:49] <Patcher> under which?
[19:52:52] <PJBoy> I couldn't possibly enumerate them all
[19:53:02] <Patcher> not a valid argument
[19:53:03] <PJBoy> nor do I think it's worth caring about
[19:53:08] <Patcher> ._.
[19:53:16] <PJBoy> you can get exception safety for free just by using RAII
[19:53:26] <PJBoy> that thing that C++ is designed around
[19:53:38] <PJBoy> also I'm not arguing anything
[19:53:48] <PJBoy> if an exception occurs and you don't handle it, you'll leak memory
[19:53:51] *** Parts: Patcher (~hendrik@p200300d8ef064b003664a9fffed44247.dip0.t-ipconnect.de) ()
[19:54:02] <PJBoy> if you decide you don't care about memory leaks or exception safety, then whatever
[19:54:05] *** Joins: paul424 (~tom@ip-37-248-155-189.multi.internet.cyfrowypolsat.pl)
[19:54:10] <PJBoy> but there's certainly no benefit to manual memory management
[19:54:15] <artok> aaand gone
[19:54:21] <PJBoy> oh
[19:54:52] <PJBoy> weird mentality
[19:55:12] <PJBoy> it's like he was offended by his own stubbornness
[19:55:37] <InPhase> I think that was someone looking for an excuse to not learn C++.  :)
[19:55:52] <PJBoy> ah right
[19:55:54] <PJBoy> yeah
[19:56:36] <InPhase> It is after all a whole lot of work, and easily avoided by making up some myths.
[19:56:57] <AmR> Any one work with ndk with command line ??
[20:02:24] *** Joins: ferdna (~ferdna@user/ferdna)
[20:09:57] *** Quits: thad_the_man (~tlophd_be@2600:1700:3051:4370:21d:9ff:fe33:51f4) (Quit: Leaving)
[20:29:20] *** Quits: TheHermann (~TheHerman@gateway/tor-sasl/thehermann) (Remote host closed the connection)
[20:29:48] *** Joins: TheHermann (~TheHerman@gateway/tor-sasl/thehermann)
[20:33:21] <ville> speaking of which is there a reasonable tutorial getting a qt widgets program built and deployed on an android device?
[20:33:47] *** Quits: johnny (~johnny@user/johnny) (Ping timeout: 256 seconds)
[20:33:51] <ville> looked at it couple(?) years ago and decided wasn't worth the effort at the time
[20:41:10] *** Joins: cm007magnum (~Rheanna@101.91.232.166)
[20:52:08] *** Quits: magla (~gelignite@55d41880.access.ecotel.net) (Quit: Stay safe!)
[20:55:25] *** Quits: Hello71 (~Hello71@wireguard/contributor/hello71) (Remote host closed the connection)
[20:55:49] *** Joins: Hello71 (~Hello71@wireguard/contributor/hello71)
[20:55:58] *** Quits: lh_mouse (~lh_mouse@mingw-w64/developer/lhmouse) (Read error: Connection reset by peer)
[21:09:27] *** Joins: Deneb (~johnch@30.125.7.51.dyn.plus.net)
[21:09:28] *** Sevalecan is now known as Maximus
[21:10:38] *** Quits: cm007magnum (~Rheanna@101.91.232.166) (Remote host closed the connection)
[21:13:02] *** Joins: cm007magnum (~Rheanna@218.78.67.149)
[21:14:32] *** Joins: CaCode (~CaCode@user/cacode)
[21:21:23] <artok> oh god why did I respond that patcher on msg
[21:23:00] *** Quits: Hello71 (~Hello71@wireguard/contributor/hello71) (Quit: Hello71)
[21:23:29] *** Joins: Hello71 (~Hello71@wireguard/contributor/hello71)
[21:24:53] <artok> ville: packt one?
[21:29:27] *** Joins: chris64 (~chris@user/chris64)
[21:33:59] *** Joins: meator (~meator@user/meator)
[21:37:54] *** Quits: chris64 (~chris@user/chris64) (Quit: leaving)
[21:39:04] *** Quits: npaperbot (~npaperbot@dodecahedron.m-ou.se) (Remote host closed the connection)
[21:39:14] *** Joins: npaperbot (~npaperbot@dodecahedron.m-ou.se)
[21:39:14] *** ChanServ sets mode: +v npaperbot
[21:39:59] *** Quits: Terminus (~null@user/terminus) (Ping timeout: 268 seconds)
[21:40:12] <ville> artok: packt publishing?
[21:40:47] <TinoDidriksen> It's still not really worth the effort as you have to do silly tricks to comply with LGPLv3 on mobile platforms.
[21:49:06] *** Quits: voltron (~voltrin_@ip4d16bdc6.dynamic.kabel-deutschland.de) (Remote host closed the connection)
[21:52:40] *** Joins: voltron (~voltrin_@ip4d16bdc6.dynamic.kabel-deutschland.de)
[21:57:00] *** Quits: blyat-73 (~hjgkjhgkj@46.235.96.249) (Quit: Leaving)
[21:57:05] *** Quits: ezzieyguywuf (~Unknown@user/ezzieyguywuf) (Ping timeout: 256 seconds)
[21:57:13] *** Joins: blyat-73 (~hjgkjhgkj@46.235.96.249)
[21:59:18] <ville> TinoDidriksen: what's the hitch there?
[22:00:10] *** Quits: cm007magnum (~Rheanna@218.78.67.149) (Remote host closed the connection)
[22:01:14] *** Quits: seninha (~seninha@user/seninha) (Quit: Leaving)
[22:02:31] *** Joins: cm007magnum (~Rheanna@218.78.99.237)
[22:08:00] *** Quits: Deneb (~johnch@30.125.7.51.dyn.plus.net) (Quit: Leaving)
[22:08:15] *** Joins: seninha (~seninha@user/seninha)
[22:12:41] *** Joins: gareppa (~gareppa@user/gareppa)
[22:13:42] *** Quits: gareppa (~gareppa@user/gareppa) (Remote host closed the connection)
[22:16:29] *** Quits: jkaye (~jkaye@2601:281:8300:7530:5a4f:5910:1ea1:e61f) (Ping timeout: 252 seconds)
[22:23:14] <AmR> I need some help to set Android sdk & ndk in command line. Any one Can help me ?
[22:31:13] *** Joins: AbleBacon (~AbleBacon@user/AbleBacon)
[22:33:21] *** Quits: markong (~kvirc@213.146.188.203) (Ping timeout: 256 seconds)
[22:34:57] *** Joins: wootehfoot (~wootehfoo@user/wootehfoot)
[22:36:24] *** Joins: skapata (~Skapata@2804:14c:87b0:a6f9:5086:3896:e0d0:f358)
[22:36:24] *** Quits: skapata (~Skapata@2804:14c:87b0:a6f9:5086:3896:e0d0:f358) (Changing host)
[22:36:24] *** Joins: skapata (~Skapata@user/skapata)
[22:38:05] *** Joins: joilerv (~joilerv@host86-191-93-41.range86-191.btcentralplus.com)
[22:39:21] *** Quits: cm007magnum (~Rheanna@218.78.99.237) (K-Lined)
[22:40:31] *** Joins: ss4 (~wootehfoo@user/wootehfoot)
[22:41:08] *** Joins: joilerv_ (~joilerv@host86-191-93-41.range86-191.btcentralplus.com)
[22:41:12] *** Joins: hgkjhgkjgkj (~hjgkjhgkj@46.235.96.249)
[22:41:13] *** Joins: CalamityToo (~CalamityB@cpe-108-185-144-94.socal.res.rr.com)
[22:42:59] *** Quits: joilerv (~joilerv@host86-191-93-41.range86-191.btcentralplus.com) (Ping timeout: 256 seconds)
[22:43:33] *** Quits: wootehfoot (~wootehfoo@user/wootehfoot) (Ping timeout: 256 seconds)
[22:44:26] *** Quits: blyat-73 (~hjgkjhgkj@46.235.96.249) (Ping timeout: 256 seconds)
[22:44:40] *** Quits: CalamityBlue (~CalamityB@cpe-108-185-144-94.socal.res.rr.com) (Ping timeout: 256 seconds)
[22:48:23] *** Joins: magla (~gelignite@55d41880.access.ecotel.net)
[22:48:27] *** Joins: chozorho (~chozorho@2601:146:300:c30::fae2)
[22:58:30] *** Quits: Cyp (~cyp@213.237.85.9) (Excess Flood)
[22:59:04] *** Joins: cm007magnum (~Rheanna@218.78.105.67)
[22:59:11] *** Joins: Cyp (~cyp@213.237.85.9)
[22:59:57] *** Quits: hgkjhgkjgkj (~hjgkjhgkj@46.235.96.249) (Read error: Connection reset by peer)
[23:00:20] *** Joins: hgkjhgkjgkj (~hjgkjhgkj@46.235.96.249)
[23:12:04] *** Joins: aegon (~mike@174.127.249.180)
[23:16:26] <aegon> RandomReader: Alipha: not sure if your interested but follow up to yesterdays uuid stuff. 1) I accidently wrote a 0 instead of o somewhere and spent 2 hours chasing nothing because I should have slept :P. 2) I think my / our understanding of the rfc is wrong. All the libs i tested when sending it over the network with functions that claim rfc4122 compatability take the uint64's and move them to be back
[23:16:32] <aegon> to back and call it a day
[23:18:22] <aegon> which as far as i know is not respecting the spec at all, it reads to me like it should be be uint32, be uint16, be uint16, uint8, uint8, be uint16, be uint_32
[23:18:29] *** Joins: jkaye (~jkaye@2601:281:8300:7530:3bdb:266b:f9cc:b3bc)
[23:18:46] <aegon> i went with what the other libs are doing, but either everyones wrong or I'm misunderstanding the rfc, i'm thinking the latter
[23:21:36] *** Joins: CalamityBlue (~CalamityB@cpe-108-185-144-94.socal.res.rr.com)
[23:22:56] <RandomReader> aegon - it looks like sole packs the values into the uint64_t in RFC field order, but you still need to extract the base256 digits individually, rather than casting
[23:23:13] *** Quits: CalamityToo (~CalamityB@cpe-108-185-144-94.socal.res.rr.com) (Ping timeout: 256 seconds)
[23:23:38] <RandomReader> (that's what I was getting at when talking about how uuid1() and str() looked)
[23:24:03] *** Quits: Leone (~Leo@216.154.50.172) ()
[23:24:16] <RandomReader> (and yes, that's different from my first assumption about it)
[23:26:23] <RandomReader> so like, instead of storing  uint32_t low, uint16_t mid, uint16_t hi  as individual values, it makes a single uint64_t arranged arithmetically as 0xLLLLLLLLMMMMHHHH
[23:28:52] <RandomReader> so each digit can be extracted from highest to lowest and end up in RFC field order
[23:29:16] <aegon> but per the spec, to put that over the network shouldn't the flos still be uint32_to_be(reinterpret_cast<std::byte*>(&x.ab)), uint16_to_be(...&x.ab + 8), ...&x.ab + 12
[23:29:43] <RandomReader> no, that's the original point Alipha and I were making: the reinterpret_cast is incorrect (and also unnecessary)
[23:29:43] <aegon> what i'm seeing libs do is uint64_to_be(reinterpret_cast<std::byte*>(&x.ab)), ...&x.cd
[23:30:18] <RandomReader> the correct approach is to do the math to extract each digit, like str() does in the sole library
[23:30:20] <manuels> Ire there some general rules on abstract classes an interfaces one should  know by heart? I followed the narrative to make pure interfaces since they are "clean" design. I just had to rethink a design in a multi inheritance scenario though. The problem was that I wanted to have plain interfaces, then provide some utility baseclass es in which I
[23:30:20] <manuels> used the interface and got stuck since I can't use it in the ctor because the subobjects are not initialized at that point. I think now I got the Java requirement to implement ifaces in an all or nothing fashion.
[23:30:41] <manuels> Raii is the "problem" here I guess
[23:30:54] <RandomReader> the reinterpret_cast approach requires the surrounding code to care about host byte order, and can run into aliasing / unaligned access issues if not done perfectly
[23:31:12] <aegon> hmm, i wanna understand that, but even with static_cast, isn't treating the whole first half. kk, i'll go look at the str function, why is reinterpret_cast specifically wrong here?
[23:31:19] <RandomReader> no casting, bitshifting
[23:31:56] <RandomReader> the original data is a *value*, not bytes .. you take each piece of the value and convert it into digits, which just happen to be base256 -> byte digits in this case
[23:32:28] <KombuchaKip> Changing the value of the pointer within a shared_ptr<T> by writing to its get() will not automatically invoke the deleter on the old value, correct?
[23:33:24] <kalven> how are you going to change the pointer with get?
[23:35:04] *** Joins: Leone (~Leo@216.154.50.172)
[23:35:27] <RandomReader> aegon - Alipha's uint32_to_be etc utility functions work to/from values, not sequences of bytes .. you can't take a uint32_t slice of the uint64_t by attempting to deal with its storage, without a lot more work and preexisting knowledge of the host (and a few violations of language rules in the process)
[23:35:42] <RandomReader> if you have a uint64_t, and want a uint32_t part of it, you get that mathematically, not with reinterpret_cast
[23:36:16] <RandomReader> those are two entirely separate kinds of value representations, so going between them is a conversion process
[23:36:45] <aegon> oh, i see. then double D = 8.0; uint64_to_be(reinterpret_cast<uint64_t*>(&D)) is not what i want either, oy
[23:36:59] <aegon> i'll get this some day
[23:36:59] *** Joins: sprout_ (~quassel@2a02:a467:ccd6:1:bde9:c3fb:c9c:3dee)
[23:37:35] <RandomReader> right
[23:38:11] <RandomReader> put another way, I think this was hinted at earlier, but: reinterpret_cast is a red flag, specifically because its valid usages are extremely rare
[23:38:11] <aegon> where do i look for rules on serializing doubles over the wire? do double representations change durastically between hosts?
[23:38:29] <artok> ville: yeah them
[23:38:57] <RandomReader> aegon - yes, in general floating point is a whole bundle of pain, don't deal with them at all if you can help it
[23:39:31] <RandomReader> if it's a requirement, then you also have to control both ends to ensure they use the same floating point representations .. otherwise you can't do it at all
[23:39:44] <RandomReader> floating point isn't a strict thing, it's an approximate form of representing data
[23:39:55] *** Quits: cm007magnum (~Rheanna@218.78.105.67) (Remote host closed the connection)
[23:40:06] <RandomReader> the IEEE 754 representations are at least *common*, but not guaranteed
[23:40:38] *** Quits: sprout (~quassel@2a02:a467:ccd6:1:ed9e:6da6:fee6:2db6) (Ping timeout: 252 seconds)
[23:41:54] <aegon> bleh, i was hoping the IEEE was respected everywhere, alright. so it seems i need to make platform specific conversions from native double to some unified 64 bit double representation and back and theres no way out of it there
[23:42:08] <RandomReader> a typical workaround (if applicable) is to just use smaller integer units
[23:42:26] <RandomReader> like send milliseconds instead of floating-point seconds, etc
[23:44:51] <RandomReader> in terms of platform specifics, if you need to get from e.g. double to a uint64_t, you can do that safely with memcpy
[23:45:49] <aegon> the reference space is in meters and these are quaternions etc so i think i gotta byte the bullet. I guess i could split 0-1 int uint64 and alias for the quaternion, for the positions i can switch to millimeters
[23:46:13] <RandomReader> double ov = 8.0;  uint64_t nv;  memcpy(&nv, &ov, 8);   will get you the 8 byte representation in uint64_t form
[23:46:29] <RandomReader> you can do the same to e.g. a std::byte array to just get the representation in that form
[23:46:48] <RandomReader> these approaches don't violate aliasing like reinterpret_cast can
[23:47:11] <RandomReader> (but they're still subject to whatever the platform representation details are, so you're stuck with that)
[23:47:41] <Alipha> aegon: I didn't look at rfc4122 until just now and I made some assumptions about how it's stored that's incorrect. It seems that the UUID representation is more complex than simply "two uint64_t stored as BE". The 48-bit node field is especially annoying.
[23:48:05] *** Joins: cm007magnum (~Rheanna@61.171.21.169)
[23:48:26] <RandomReader> C++20 has std::bit_cast() if your toolchain is new enough
[23:48:29] <aegon> i'm still not getting the reinterpret vs cast thing. why is uint16_t* x = reinterpret_cast<uint16_t*>(uint64_t(3)) different than uint64_t source = 3; uint16_t x = static_cast<uint16_t>(source >> 12);
[23:49:28] <RandomReader> reinterpret_cast's purpose is to say "take this address of one type, pretend it's an address of another type, and do that in some implementation-specific way, and also behind the compiler's back so it might break later"
[23:49:55] <RandomReader> none of those things accomplish the goal of getting part of the *value* out
[23:50:17] <ville> artok: your reinterpret_cast is on pointers while the static_cast is not. is that intentional?
[23:50:27] <aegon> well, thats the only option for sending a ansii c str over the wire, right?
[23:50:28] <RandomReader> the static_cast is unnecessary on the second example
[23:50:40] <RandomReader> what do you mean?
[23:51:34] <aegon> ville: yeah I"m trying to understand the difference between them. So am i close in saying that the reinterpret cast might not get me the least significant 16 bits on some platforms?
[23:52:21] <aegon> RandomReader: so i have a network function that takes std::byte, i make a std::string with ansii chars not null terminated, sending that over the wire i do reinterpret_cast on the .data() so the function that expects std::byte will be happy
[23:52:23] <RandomReader> it won't get you the least significant 16 bits on some platforms .. it may not get you any useful 16 bits on others
[23:52:47] <RandomReader> it's just not even remotely the right tool, I'm not sure how to break up the equivalence you're seeing there
[23:52:53] <RandomReader> e.g. it seems like you think it does things it doesn't do
[23:53:13] <aegon> so to do the above safely i should instead do
[23:53:23] <ville> aegon: umm, you lost me there
[23:53:37] <aegon> static_cast<std::byte*>(6std::string("blah").data())
[23:54:06] <RandomReader> aegon - in that scenario, no .. reinterpret_cast will work but only due to special exceptions for std::byte and char
[23:54:15] <RandomReader> it does not work or even make sense in general
[23:54:53] <aegon> so what is a valid use case of reinterpret_cast (aside from string to byte)
[23:54:54] <Alipha> uint64_t source = 3; uint16_t x = *reinterpret_cast<uint16_t*>(source); // x will most likely be the least significant 16 bits of source on little endian platforms and x will most likely be the most significant 16 bits on big endian platforms. Though this is all technically Undefined Behavior for breaking aliasing rules, and so "anything could happen"
[23:55:16] <RandomReader> the better option is to fix the interfaces, typically the lowest level ones accept void*
[23:55:43] <RandomReader> reinterpret_cast in that specific situation is an unfortunate compromise due to real-world interfaces that differ despite your best efforts
[23:55:52] <RandomReader> but it's limited to char, unsigned char, and std::byte
[23:56:20] <RandomReader> any other conversions run into potential problems, usually in the form of "it seems to work ok and then some years / platforms later BANG"
[23:56:27] <Guest19> /join #kernel
[23:57:35] <Guest19> ignore ^^
[23:58:02] <Alipha> reinterpret_cast is pretty useless as far as the c++ standard goes. But people use it and are accepting the risk that the behavior they see today with it will continue to be the same behavior in the future
[23:58:07] <RandomReader> I've mentioned "aliasing" before, the underlying theme there is that the compiler uses types to tell where data is used, so it knows how to juggle register allocation and caching
[23:58:26] <aegon> so it sounds like i should always static_cast even with pointers unless its between bytes / chars / unsigned chars
[23:58:34] <RandomReader> so if it has int* p1, and uint16_t* p2, it knows that p1 and p2 will never access the same data (by language rules)
[23:58:59] <aegon> what about uint8_t -> byte, is that a reinterpret cast of pointers or a static cast of pointers or a static cast of valuse
[23:59:19] <RandomReader> you can use reinterpret_cast to write code that tries to access the same data .. but that doesn't change the language rules or the compiler handling, so the results become unpredictable at best (Undefined Behavior)
