[00:10:23] *** Quits: sigma_ (~sigma@86.57.83.153) (Quit: Konversation terminated!)
[00:13:28] *** Joins: kariosfox (~kariosfox@176.221.122.35)
[00:25:48] *** Joins: PJBoy (~PJBoy@user/pjboy)
[00:34:19] *** Quits: Y4kuzi (~provision@85.159.233.183) (Remote host closed the connection)
[00:43:53] *** Quits: magla (~gelignite@55d4c150.access.ecotel.net) (Quit: Stay safe!)
[00:51:07] *** Quits: kariosfox (~kariosfox@176.221.122.35) (Read error: Connection reset by peer)
[01:45:40] *** Joins: ferdna (~ferdna@user/ferdna)
[01:46:14] *** Quits: spaceangel (~spaceange@ip-78-102-216-202.net.upcbroadband.cz) (Remote host closed the connection)
[02:51:38] *** Quits: TheHermann (~TheHerman@gateway/tor-sasl/thehermann) (Quit: Leaving)
[03:12:12] *** Quits: rmd (~rm@ec2-52-202-15-104.compute-1.amazonaws.com) (Ping timeout: 240 seconds)
[03:39:17] *** Quits: FuzzyBottom (~FuzzyBott@d207-6-38-95.bchsia.telus.net) (Remote host closed the connection)
[03:41:18] *** Joins: FuzzyBottom (~FuzzyBott@d207-6-38-95.bchsia.telus.net)
[03:57:06] *** Quits: DSpider (~DSpider@82.79.237.43) (Quit: Leaving)
[04:06:34] *** Joins: Karyon_ (~Karyon@user/karyon)
[04:06:42] *** Quits: va (~cargova@2a01:261:0:9::d285) (Ping timeout: 250 seconds)
[04:07:00] *** Joins: va (~cargova@2a01:261:0:9::d285)
[04:07:02] *** Quits: Karyon (~Karyon@user/karyon) (Ping timeout: 240 seconds)
[04:13:39] *** Quits: bebyx (~Thunderbi@user/bebyx) (Ping timeout: 256 seconds)
[04:26:14] <Alipha> archbish: i'm confused as to why you have both a and b, since they share the same memory. that is, assigning to a also sets b to the same value and vice versa (ignoring "active member" rules)
[04:26:17] <Alipha> { U u; u.a = 5; std::cout << u.b; }; struct Compound { uint32_t c; uint32_t d; }; union U { uint32_t a; uint32_t b; Compound compound; };
[04:26:17] <geordi> 5
[04:27:31] <Alipha> is a supposed to be the low 4 bytes and b the high 4 bytes or something?
[04:42:11] *** Joins: linext_ (~linext@pool-173-63-46-155.nwrknj.fios.verizon.net)
[04:44:10] *** Quits: linext (~linext@pool-173-63-46-155.nwrknj.fios.verizon.net) (Ping timeout: 272 seconds)
[04:56:27] *** Joins: ymwm (~yingmanwu@110.85.123.161)
[05:12:35] *** Quits: dgcampea (~dgc@user/dgcampea) (Remote host closed the connection)
[05:12:55] *** Joins: dgcampea (~dgc@user/dgcampea)
[05:22:51] *** Quits: PJBoy (~PJBoy@user/pjboy) (Ping timeout: 245 seconds)
[05:46:38] *** Quits: dgcampea (~dgc@user/dgcampea) (Killed (NickServ (Forcing logout dgcampea -> dgcampea)))
[05:46:38] *** Joins: dgcampea-2 (~dgc@user/dgcampea)
[05:46:38] *** dgcampea-2 is now known as dgcampea
[06:11:58] *** Joins: Inline__ (~Inline@p200300cd470cd6007b9a329b320e25d9.dip0.t-ipconnect.de)
[06:14:32] *** Quits: Inline (~Inline@p200300cd47082500eff0453775466c26.dip0.t-ipconnect.de) (Ping timeout: 250 seconds)
[07:08:12] *** Quits: geranim0 (~geranim0@modemcable242.171-178-173.mc.videotron.ca) (Ping timeout: 240 seconds)
[08:32:51] *** Quits: dgcampea (~dgc@user/dgcampea) (Remote host closed the connection)
[08:33:07] *** Joins: dgcampea (~dgc@user/dgcampea)
[09:02:43] *** Billiard_ is now known as Billiard
[09:05:21] *** Quits: ferdna (~ferdna@user/ferdna) (Quit: Leaving)
[09:38:03] *** Quits: unixpro1970 (~unixpro19@c-67-168-187-106.hsd1.wa.comcast.net) (Remote host closed the connection)
[09:48:59] *** Joins: unixpro1970 (~unixpro19@c-67-168-187-106.hsd1.wa.comcast.net)
[09:59:31] *** Quits: unixpro1970 (~unixpro19@c-67-168-187-106.hsd1.wa.comcast.net) (Remote host closed the connection)
[10:01:34] *** Joins: unixpro1970 (~unixpro19@c-67-168-187-106.hsd1.wa.comcast.net)
[10:48:50] *** Quits: davidlowryduda (~davidlowr@2601:197:600:1210:adfa:97b2:16e:b6e4) (Ping timeout: 250 seconds)
[10:50:52] *** Joins: davidlowryduda (~davidlowr@73.61.8.192)
[10:52:19] *** Quits: unixpro1970 (~unixpro19@c-67-168-187-106.hsd1.wa.comcast.net) (Remote host closed the connection)
[11:49:58] *** Joins: CaCode (~CaCode@user/cacode)
[11:56:12] *** Joins: Tazy (~Tazmainia@2001:1c02:170d:2600:514f:1369:b93d:f715)
[12:05:42] *** Joins: unixpro1970 (~unixpro19@c-67-168-187-106.hsd1.wa.comcast.net)
[12:15:28] *** Quits: CaCode (~CaCode@user/cacode) (Remote host closed the connection)
[12:35:00] *** Quits: indy (~indy@dsl-static-104.213-160-167.telecom.sk) (Ping timeout: 240 seconds)
[13:13:55] *** Joins: PJBoy (~PJBoy@user/pjboy)
[13:48:10] *** Joins: DSpider (~DSpider@82.79.237.72)
[13:48:10] *** Quits: DSpider (~DSpider@82.79.237.72) (Client Quit)
[13:54:30] *** Joins: Guest3718 (~Guest37@128.199.173.249)
[13:56:53] *** Joins: kaiseisei (~Thunderbi@user/kaiseisei)
[14:01:12] *** Quits: Guest3718 (~Guest37@128.199.173.249) (Quit: Client closed)
[14:05:47] *** Quits: kaiseisei (~Thunderbi@user/kaiseisei) (Ping timeout: 252 seconds)
[14:12:56] *** Joins: bebyx (~Thunderbi@user/bebyx)
[14:22:50] *** Joins: darkbit (~db@136.158.8.67)
[14:45:09] *** Joins: indy (~indy@dsl-static-104.213-160-167.telecom.sk)
[14:46:42] <meicceli> why can't i return an object of type T if T has a deleted copy ctor?
[14:47:37] <meicceli> I have function foo() which returns an object of type T with a deleted ctor -> my code wont compile
[14:47:54] *** Quits: Tazy (~Tazmainia@2001:1c02:170d:2600:514f:1369:b93d:f715) (Read error: Connection reset by peer)
[14:47:57] <meicceli> shouldnt everything be alright due to copy elision?
[14:53:32] <osse> meicceli: how do you assign it in the outer scope?
[14:53:59] <meicceli> i don't assign, only initialize
[14:55:10] <meicceli> and i'd like to initialize an instance of T with "T x = foo();"
[14:57:23] <osse> it works if you implement T::T(T&&) 
[14:57:33] <osse> not sure why
[14:57:46] <meicceli> apparently copy elision is only enforced in c++17
[14:58:12] <osse> I get the same compile error there 
[14:58:31] <meicceli> how'd you return an instance of T?
[14:58:47] <meicceli> it should work if you do "return T();"
[14:58:59] <meicceli> "T retValue; return retValue;" might not work
[14:59:37] <osse> https://godbolt.org/z/6e7a1Pcc6 - if you remove the comment on line 5 it compiles
[15:01:35] <meicceli> osse: replace "return s;" with "return S(i);"
[15:01:38] <meicceli> and it compiles
[15:01:58] <osse> hmm
[15:02:14] <meicceli> it compiles because C++17 standard forces compiler to do copy elision in that case
[15:33:36] *** Joins: geranim0 (~geranim0@modemcable242.171-178-173.mc.videotron.ca)
[16:19:17] *** Joins: Tazy (~Tazmainia@2001:1c02:170d:2600:7c05:7994:1a84:23ff)
[16:33:40] *** Joins: osfe_ (~lemaire@nanpc540.in2p3.fr)
[16:36:37] *** Joins: ymwm_ (~yingmanwu@110.85.123.64)
[16:38:58] *** Quits: ymwm (~yingmanwu@110.85.123.161) (Ping timeout: 250 seconds)
[16:42:38] *** Joins: sigma_ (~sigma@2.147.230.56)
[16:58:06] *** Quits: msim_ (~msim@2001:8003:d194:d000::d8d) (Read error: Connection reset by peer)
[16:58:48] *** Joins: msim_ (~msim@2001:8003:d194:d000::d8d)
[17:05:13] *** Quits: ymwm_ (~yingmanwu@110.85.123.64) (Remote host closed the connection)
[17:05:41] *** Joins: ymwm_ (~yingmanwu@110.85.123.64)
[17:06:16] *** Quits: ymwm_ (~yingmanwu@110.85.123.64) (Max SendQ exceeded)
[17:06:43] *** Joins: ymwm_ (~yingmanwu@110.85.123.64)
[17:31:25] *** Quits: ymwm_ (~yingmanwu@110.85.123.64) (Remote host closed the connection)
[17:37:11] *** Quits: davidlowryduda (~davidlowr@73.61.8.192) (Ping timeout: 256 seconds)
[17:39:18] *** Joins: davidlowryduda (~davidlowr@2601:197:600:1210:b19d:d8f1:1756:fb98)
[17:51:02] <osfe_> Hi there, I'm trying to do the following thing https://godbolt.org/z/GzYK49zc4
[17:51:12] <osfe_> I don't know if that's correct
[17:51:21] <osfe_> but it works. 
[17:51:56] <osfe_> Of course the problem here is the raw pointer that I'd live to replace with a smart pointer un the main
[17:52:05] <osfe_> though I can't find a way to do it 
[17:55:33] <cbreak> osfe_: you shouldn't nest vectors
[17:55:55] <osfe_> cbreak: what do you mean ?
[17:56:04] <Alipha> meicceli: yeah, so when you have `return S(i);`, the C++ standard defines that if the expression in the return statement is a prvalue ("pure rvalue"), then that expression is used to initialized the returned-to object. but if you have `return s;` then this is defined as doing a moved construction, and so S must have a move (or copy) constructor. the standard permits compilers to omit this move, but the
[17:56:06] <Alipha> move ctor still must be exist
[17:56:29] <cbreak> line 21 and 22 are redundant
[17:56:42] <cbreak> osfe_: putting vectors into vectors is a bit inefficient
[17:56:48] <meicceli> thanks Alipha 
[17:57:35] <osfe_> cbreak: ok, so how should I proceed ?
[17:57:44] <cbreak> I'd remove lines 21 and 22
[17:58:01] <Alipha> osfe_: raw pointers aren't taboo. this is appropriate use of raw pointers
[17:58:10] <osse> In this case the data is obviously owned by A, so handing out a raw pointer is fine, no? 
[17:58:12] <cbreak> I'd rewrite 23 to use if (i < size)
[17:58:16] <cbreak> that's the normal way to write it
[17:58:36] <cbreak> I'd not use at, since you already check boundary conditions
[17:58:57] <cbreak> I'd use size_t in the interface, not int
[17:59:39] <osfe_> Alipha: meaning I need to delete the pointer at the end of the main ?
[17:59:40] <cbreak> osfe_: and verify your constructor.
[17:59:50] <Alipha> osfe_: what smart pointers are for are for managing memory. in "modern c++", you should "never" have to use `delete` (or delete[]). in those situations, you should use smart pointers (or containers). in this case, std::vector is managing the memory for you, so your raw pointer doesn't "own" the memory
[17:59:57] <osfe_> cbreak: this is an exemple
[18:00:07] <osfe_> my point is about the pointer thing
[18:00:12] <cbreak> that's fine.
[18:00:40] <cbreak> you're basically returning an optional vector by pointer, without transfering ownership
[18:00:43] <osfe_> Alipha: this is non-owning pointer ?
[18:01:07] <cbreak> osfe_: but std::vector<std::vector<int>>(10) will not give you a vector containing 10 vectors with 10 ints
[18:01:11] <Alipha> osfe_: correct. the pointer is non-owning because it's pointing to memory owned by std::vector. std::vector will clean up the memory
[18:01:31] <Alipha> osfe_: you don't need to and should not "delete the pointer"
[18:02:00] <Alipha> (you're actually deleting the object(s) pointed to by the pointer, which, again, you shouldn't do because std::vector will do that)
[18:03:09] <cbreak> I don't see any delete.
[18:03:18] <cbreak> there must not be any delete either.
[18:03:37] <osfe_> Alipha: ok, so this is a decent way to do that and I'm not mistaking
[18:04:25] <Alipha> osfe_: correct. (though cbreak is objecting to having a vector of vectors because of performance reasons. it's more efficient to allocate a "one-dimensional vector" of size 100)
[18:04:35] <Alipha> !matrix
[18:04:36] <nolyc> template<typename T> struct matrix { matrix(unsigned m, unsigned n) : m(m), n(n), vs(m*n) {} T& operator ()(unsigned i, unsigned j) { return vs[i + m * j]; } private: unsigned m; unsigned n; std::vector<T> vs; }; /* column-major/opengl: vs[i + m * j], row-major/c++: vs[n * i + j] */
[18:04:54] <cbreak> not just performance reasons
[18:05:04] <osfe_> Alipha: cbreak: already heard about that
[18:05:07] <cbreak> nesting vectors is also confusing programmers, as we've seen from the bugs in the example
[18:05:12] <Alipha> osfe_: and as cbreak said, `: data{std::vector<std::vector<int>>(10)}` is incorrect
[18:05:25] <osfe_> it's on my todo list :)
[18:08:54] <osfe_> data = std::vector<std::vector<int>>(10, std::vector<int>(10))
[18:11:58] <osfe_> Alipha: cbreak what if my vector is 1e9 elements, 1D vector is still the right way to do it ?
[18:15:34] <Alipha> osfe_: yes. though there's nothing "wrong" with the way that you're doing it. it's just not optimal
[18:15:43] <osfe_> Alipha: cbreak: thank you to both of you for yuor help !!
[18:16:07] <Alipha> osfe_: and i think you actually want get_data to return a `const std::vector<int> &` and to remove the & from `return data.at(index);`
[18:16:51] <osfe_> Alipha: I understand, but my data sets are big, so any ms gained is good
[18:17:17] <osfe_> Alipha: the ref avoid the copy 
[18:18:27] <osfe_> the point is that with a reference I can't return a nullptr
[18:19:41] <osfe_> but I can catch an exception in that case
[18:19:51] <osfe_> with at()
[18:20:36] <osfe_> what's better... 
[18:25:09] <cbreak> osfe_: depends
[18:25:30] <cbreak> is asking for an index that is out of bounds an error? Then exceptions make sense. Is it allowed? Then returning nullptr makes sense
[18:30:51] <osfe_> cbreak: I understand...
[20:11:00] *** Quits: darkbit (~db@136.158.8.67) (Ping timeout: 252 seconds)
[20:34:16] *** Quits: osfe_ (~lemaire@nanpc540.in2p3.fr) (Ping timeout: 250 seconds)
[20:39:02] *** Joins: magla (~gelignite@d536591f.access.ecotel.net)
[20:52:20] <linext_> what's the difference between null and nullptr?
[20:52:30] <linext_> Node(int k, int val):prev(NULL),next(NULL),key(k),value(val){};
[20:53:26] <linext_> or should i say NULL and nullptr
[21:05:59] *** Quits: Jmtrix (~qed@user/jmtrix) (Ping timeout: 252 seconds)
[21:06:11] <andreyv> linext_: They both serve the same purpose to denote the null pointer, but NULL is an older construct that does not behave is expected in all situations. nullptr is the newer preferred replacement.
[21:06:53] *** Joins: Jmtrix (~qed@2604:180:2:72d::497d)
[21:06:53] *** Quits: Jmtrix (~qed@2604:180:2:72d::497d) (Changing host)
[21:06:53] *** Joins: Jmtrix (~qed@user/jmtrix)
[21:07:16] <andreyv> Technically, NULL is a macro that is often defined to just 0, while nullptr is an object of a special built-in type
[21:31:42] <Alipha> NULL is a macro and therefore is bad :-) And as andreyv said, it's either 0 or nullptr, which is also bad, because that could actually change behavior depending upon the platform. eg, if you had an overloaded function, `void foo(int); void foo(double*);` then foo(NULL); may call either foo(int) or foo(double*) depending upon how NULL is defined.
[21:37:16] *** Quits: sigma_ (~sigma@2.147.230.56) (Quit: Konversation terminated!)
[21:41:35] <linext_> i have a question about this doubly linked list
[21:41:37] <linext_> https://ideone.com/GLrTX7
[21:42:07] <linext_> can I delete the pointer n1 by passing it into the function deleteNode(Node *n){} ?
[21:42:42] <linext_> or do I need to set n1 = NULL after the deleteNode(n1);
[21:49:58] <linext_> i want the reference n1 to be null, not just the deleting the object
[21:54:57] *** Quits: jsbach (~jsbach@2a02:810a:1440:4cec:3af3:abff:fe57:23d5) (Ping timeout: 252 seconds)
[22:01:50] *** Joins: CoderCharmander (~CoderChar@54032703.catv.pool.telekom.hu)
[22:06:43] <cbreak> linext_: if you want a variable to contain null, you have to assign to it
[22:07:07] <cbreak> if you want to do that in the function, then your function must accept a reference, not a value
[22:07:59] <cbreak> linext_: your delete function is currently buggy
[22:08:13] <cbreak> it does not correctly unlink the node
[22:09:02] <cbreak> there are also several fundamental issues with your API design
[22:16:38] <linext_> i don't know how to pass an object created with "new" by reference
[22:17:15] *** Quits: hsv-2 (~weechat@gateway/tor-sasl/hsv-2) (Ping timeout: 240 seconds)
[22:21:59] *** Joins: teut (~teut@103.144.92.214)
[22:23:14] <linext_> https://ideone.com/S739vb
[22:23:29] <linext_> i want to combine lines 42 and 43
[22:30:00] <Alipha> linext_: so, looking at your original paste, `n = NULL;` didn't work because n is a copy of n1. if you want `n = NULL;` to modify n1, then n has to be a reference to n1. `void deleteNode(Node *&n){`
[22:31:03] <Alipha> alternatively, you can pass a pointer to a pointer, but that's uglier.
[22:39:08] *** Joins: spaceangel (~spaceange@ip-78-102-216-202.net.upcbroadband.cz)
[22:49:30] *** Joins: hsv-2 (~weechat@gateway/tor-sasl/hsv-2)
[22:50:37] <cbreak> linext_: lines 17 to 22 are kind of pointless
[22:50:39] *** Quits: hsv-2 (~weechat@gateway/tor-sasl/hsv-2) (Client Quit)
[22:50:46] <cbreak> same with 25 - 31
[22:51:22] <cbreak> you do not need to care what's inside the variable when you assign its value, only when you dereference it
[22:53:36] *** Joins: hsv-2 (~weechat@gateway/tor-sasl/hsv-2)
[22:53:48] *** Quits: teut (~teut@103.144.92.214) (Quit: Client closed)
[22:54:04] *** Joins: teut (~teut@103.144.92.237)
[22:58:46] <linext_> Alipha, what would be the argument to deleteNode(?);
[22:59:02] *** Joins: kariosfox (~kariosfox@176.221.122.80)
[22:59:35] <cbreak> linext_: a node pointer object
[22:59:48] <cbreak> but really, your design is quite qestionable
[22:59:52] <Alipha> linext_: the same. deleteNode(n1);
[23:00:12] <cbreak> the creation and destruction of nodes, all its ownership, should be managed by a container class
[23:00:29] <linext_> i would expect "from back to front" to not show anything
[23:00:30] <linext_> https://ideone.com/cuhpeo
[23:00:55] *** Quits: kariosfox (~kariosfox@176.221.122.80) (Remote host closed the connection)
[23:01:16] *** Joins: kariosfox (~kariosfox@176.221.122.80)
[23:01:26] <cbreak> linext_: you're not properly linking the list.
[23:01:32] <cbreak> it's a singly-linked list at the moment
[23:01:50] <cbreak> it should obviously show something
[23:01:58] <cbreak> since n3 is not null
[23:02:11] <linext_> it should start with n1, which is null
[23:02:19] <linext_> line 41: https://ideone.com/cuhpeo
[23:02:56] <linext_> n1 is now deleted on line 32, line 22
[23:03:44] <cbreak> linext_: you're accessing dangling objects
[23:03:58] <cbreak> you must not try to dereference n1 after deleting it
[23:06:38] <linext_> so something is not working, the object is not NULL
[23:07:17] <linext_> ah, i added n=NULL after "delete n;"
[23:07:23] <linext_> that worked
[23:07:27] <cbreak> delete doesn't change the pointer itself
[23:15:23] *** Quits: teut (~teut@103.144.92.237) (Quit: Client closed)
