[00:24:22] *** Joins: lisp123 (~lisp123@5.30.23.247)
[00:34:47] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 246 seconds)
[01:08:55] *** Quits: selwyn (~selwyn@user/selwyn) (Quit: Leaving)
[01:18:43] *** Joins: anxt_ (~anxt@dynamic-acs-24-154-157-73.zoominternet.net)
[01:24:05] *** Quits: shka (~herr@109.231.6.176) (Ping timeout: 252 seconds)
[01:38:39] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[01:51:11] <sgithens> Hi, I've poked around the hyperspec and a few books but I'm still not sure the 'correct' to compare 2 floats at a certain level of precision. For instance I want the following to return 't :
[01:51:14] <sgithens>  (some-sort-of-equal-that-looks-at-3-decimal-points 0.64705885 0.6470585) ; ie 0.647 and 0.647
[01:51:17] <sgithens> t
[01:52:02] <mfiano> comparing floats is tricky business
[01:52:15] <mfiano> for a robust solution you would want to pass in a relative and absolute tolerance
[01:52:46] <sgithens> I was thinking I should make 2 new numbers that just take the first 3 decimal points, but I realize I'm also not sure the correct way to do that!
[01:53:15] <mfiano> https://realtimecollisiondetection.net/blog/?p=89
[01:53:34] <sgithens> I've even thought of doing probably horrible things like using a format string that just takes the first 3 points and then comparing those string :p
[01:54:00] <White_Flame> same concept in any language, (< 0.001 (abs (- a b)))
[01:54:16] <sgithens> aha!
[01:54:20] <White_Flame> however, yeah that's not explicitly looking at the 3 digits being the same
[01:54:25] <mfiano> No
[01:54:29] <mfiano> That is not good to do
[01:54:39] <mfiano> That is only using the absolute tolerance!
[01:55:02] <White_Flame> well, this was for 3 decimal digits
[01:55:11] <White_Flame> which is a pretty absolute tolerance ;)
[01:55:28] <White_Flame> 0.000000000000003 and 0.000000000000009 should be "the same" under those terms
[01:55:41] <mfiano> It doesn't matter.
[01:56:17] <sgithens> I'm just comparing some RGB color values that have gotten saved differently in saved files.  So, if the two shades of orange are close enough that's really what I'm looking for. It's not for any sort of intense scientific application
[01:56:19] <White_Flame> but, 0.1119 and 0.1120 would pass the predicate, as their delta is within 0.001, but their 1st 3 fractional decimal digits differ
[01:56:25] <mfiano> The absolute tolerance test fails when A and B are large
[01:56:34] <White_Flame> so yes, you do need to convert it into decimals if you want to compare
[01:56:41] <mfiano> The relative test fails when A and B are small
[01:56:48] <mfiano> Combining the two will give you a better test
[01:56:53] <mfiano> I have lisp code for this somewhere...
[01:57:28] <White_Flame> If the float is so large that the .xxx digits are no longer in precision, then = suffices
[01:57:54] <sgithens> I had thought about decimals, but I don't think there is decimal type in the CL standard??
[01:57:54] <mfiano> (defun ~= (x y &key (rel 1d-7) (abs rel)) (< (abs (- x y)) (max abs (* rel (max (abs x) (abs y))))))
[01:57:54] <White_Flame> but, the abs delta check will also work
[01:58:06] <mfiano> there is an ~= function combining abs and rel testing
[01:58:10] <White_Flame> sgithens: multiply by 1000, take the int, compare
[01:58:38] <White_Flame> then you get the equivalent of comparing the decimal digits 3 past the point
[01:59:14] <White_Flame> (= (floor (* a 1000)) (floor (* b 1000)))
[01:59:29] <sgithens> Thanks White_Flame and mfiano ! This will get me through the day, I'll read that link you pasted for continuing education : p
[01:59:47] <sgithens> First time I've posted in this IRC channel, thanks a lot for the help!
[02:00:04] <White_Flame> np.  mfiano's is more correct for general float compares, but yours isn't very general
[02:00:40] <White_Flame> "close enough" would be < 0.001 tolerance, "has the 1st 3 digits the same" would be the float 1000 thing
[02:00:44] <White_Flame> *floor 1000
[02:01:09] <White_Flame> all assuming that your value range is 0.0 - 1.0, as per colors
[02:01:27] <sgithens> yeah, that's correct
[02:03:39] <White_Flame> technically, (floor (* x 256)) would compare what their 0-255 value would be, although that assumes the range is [0.0, 1.0)
[02:09:24] *** Quits: rotateq (~user@p200300e78715be00fdfeed040e17b750.dip0.t-ipconnect.de) (Quit: ERC (IRC client for Emacs 27.2))
[02:15:08] <sgithens> that makes sense, since yeah I'd like to assume the standard 0-255 range
[02:16:25] *** Joins: beach` (~user@2a01:cb19:150:3400:34da:254c:9f5b:12b2)
[02:16:50] <mfiano> np enjoy
[02:20:37] *** Quits: beach (~user@2a01:cb19:150:3400:2a6:806:3923:229) (Ping timeout: 252 seconds)
[03:10:42] *** Joins: lisp123 (~lisp123@5.30.23.247)
[03:13:39] <pjb> sgithens: (defun float-equal-to-precision (a b precision) (if (zerop a) (zerop b)  (< (abs (/ (- a b) a)) precision))) (float-equal-to-precision 0.64705885e10 0.6470585e10 0.001) #| --> t |# 
[03:15:08] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[03:26:01] *** Quits: random-nick (~random-ni@87.116.165.220) (Ping timeout: 252 seconds)
[03:57:59] <sgithens> cheers pjb for adding in the zero case!
[04:37:12] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[04:38:31] *** Quits: Josh_2 (~user@37.25.47.130) (Quit: ERC (IRC client for Emacs 27.1))
[05:03:37] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[05:57:08] *** Quits: sts-q (~sts-q@212.53.219.181) (Ping timeout: 246 seconds)
[05:59:16] *** Joins: sts-q (~sts-q@212.53.219.184)
[06:13:09] *** beach` is now known as beach
[06:13:19] *** ChanServ sets mode: +o beach
[06:15:49] *** beach sets mode: -o beach
[06:58:45] *** Joins: vats (~vats@103.70.83.52)
[07:21:08] *** Quits: ryanbw (~ryanbw@mab.sdf.org) (Quit: I'll be back.)
[07:33:01] *** Joins: CptKirk (~CptKirk@70-57-27-195.hlrn.qwest.net)
[07:54:09] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[07:55:15] *** Joins: hendursaga (~weechat@user/hendursaga)
[08:00:39] *** Joins: lisp123 (~lisp123@5.30.23.247)
[08:13:59] <anxt_> To get the value corresponding to a given key, you simply pass the result of ASSOC to CDR.
[08:14:22] <anxt_> that sentence kinda turns on a light in some dimly lit corner of my brain.
[08:15:29] <beach> How so?
[08:15:58] <anxt_> i use python dicts all day, once in a while i want to lookup a key based on a value
[08:16:29] <beach> Oh, that's different.  For that you need RASSOC.
[08:16:55] <anxt_> seeing how (surely oversimplified) a p-list can be a list of pointer to (key value) lists.  then the cdr is the value.
[08:17:11] <anxt_> i feel like i am confused but wiring up some abstract part of my brain.
[08:17:44] <beach> Hold on, these are association list (alists), not property plists (plists). 
[08:17:46] <anxt_> i took a couple uni math classes, I am OK with being confused its part of the process
[08:18:02] <anxt_> ahh, yes you are correct.
[08:18:30] <anxt_> I am beyond noob, just trying to get around the repl and parse some data that came from json
[08:18:36] <beach> And if an element is (key value), the CDR is not the value.  The CADR is the value.  For CDR to be the value, the element needs to be (key . value).
[08:19:21] <CptKirk> what is the "correct" way to define a recursive accumulator variable for a recursive function?
[08:19:25] <anxt_> it will be cool when i can quickly crank out useful cl code
[08:19:36] <CptKirk> do you use &optional (accum 'nil)
[08:19:41] <beach> CptKirk: Don't!
[08:19:43] <CptKirk> or do you define a recursion helper function?
[08:19:54] <beach> CptKirk: That's so Scheme-ish.  Use iteration instead.
[08:20:02] <CptKirk> :/
[08:20:11] <beach> And certainly, do not use artificial tail recursion. 
[08:20:14] <beach> It is unreadable.
[08:20:40] <beach> Common Lisp does not guarantee tail-call optimization anyway.
[08:21:43] <CptKirk> I guess I don't know how to write CL because I've spent so much more time in clojure and scheme more than CL
[08:21:53] <CptKirk> philosophically I mean
[08:22:02] <beach> Sounds plausible. 
[08:23:00] <beach> Your Common Lisp code would look like you "speak" Common Lisp with a "Scheme accent". 
[08:23:43] * beach vanishes for an hour or so.
[08:24:40] *** Joins: ryanbw (~ryanbw@mab.sdf.org)
[08:30:17] <White_Flame> anxt_: plist = (key val key val ...), (getf plist key) => value
[08:30:40] <White_Flame> alist = ((key . val) (key . val) ...), (assoc key alist) => (key . val)
[08:31:37] <White_Flame> an alist reifies an "entry" into a single object (a cons cell)
[08:47:07] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[08:47:20] *** Joins: lisp123 (~lisp123@5.30.23.247)
[08:50:23] <White_Flame> CptKirk: only use recursion in complex situations where an iterative one becomes hard to express
[08:50:50] <White_Flame> mapcar et al, dotimes, and loop serve most purposes
[08:51:27] <White_Flame> LOOP can be harder to learn, as it basically has its own non-sexpr sublanguage inside, but does a lot
[08:51:45] <White_Flame> these things compile down to very tight loops
[08:51:52] <White_Flame> and generally directly express what you want done
[09:22:59] *** Joins: paule32 (~paule32@user/paule32)
[09:23:05] <paule32> hello
[09:23:10] <paule32> and good morning
[09:23:25] <lisp123> Good Morning Paule :)
[09:24:12] <paule32> is clisp up to date ?
[09:24:25] <paule32> or should i stay at sbcl ?
[09:25:25] <lisp123> I've heard many good things about Clisp, was going to get it myself -> But both are equally good for day to day use, so I wouldn't spend too much time if you already have SBCL set up
[09:26:01] <mfiano> clisp is slow and very outdated, though it does has its uses in debugging Lisp code.
[09:26:19] <mfiano> It hasn't had a release in over a decade.
[09:26:29] <paule32> ok, thx
[09:26:44] <paule32> i still hang on exceptions
[09:26:56] <mfiano> Also, all software will have a dtae associated with its release.
[09:27:13] <mfiano> This is something that could easily be checked yourself.
[09:27:53] <mfiano> There are no exceptions in Common Lisp.
[09:28:10] <paule32> handler-case
[09:28:32] <mfiano> THat handles a condition, which are very much not exceptions found in other languages.
[09:28:57] <paule32> https://dpaste.com/69Z43JR36
[09:29:19] <mfiano> I don't care to read your code today if you are not using proper style.\
[09:29:24] <paule32> i would catch illegal function call
[09:29:55] <White_Flame> why do you keep wanting to catch these things?
[09:29:56] <mfiano> Of course you would
[09:30:03] <White_Flame> also, again, 1/1 is not a division operation.  It is a number; a ratio
[09:30:07] <mfiano> There is no operator called 1/1
[09:30:20] <White_Flame> that, too
[09:30:27] <paule32> but no change, to catch illegal function call ?
[09:30:30] <mfiano> This is why I don't want to read your code. You refuse to use interactive editing facilities.
[09:30:40] <mfiano> These problems go away with a proper environment
[09:30:58] <White_Flame> if you have an illegal function call, your code is likely broken, not much you can do to handle it that the normal debugger can't do better
[09:31:07] <lisp123> paule32: In Lisp, code is written in prefix-form (operator operands), so 1/1 should be (/ 1 1)
[09:31:39] <paule32> lisp123: thx, i know, the question is, how to handle exceptions or debugger faults
[09:32:20] <White_Flame> you have handled them with handler-case already (when you had your parens correct for a bit)
[09:32:24] <White_Flame> what other questions do you have?
[09:32:49] <paule32> nothing at the moment
[09:33:13] <lisp123> https://www.amazon.com/Common-Lisp-Condition-System-Mechanisms-ebook/dp/B08L8TTFZM/ref=sr_1_1?dchild=1&keywords=Common+Lisp+condition+system&qid=1633068184&s=digital-text&sr=1-1
[09:33:37] <lisp123> Since you are interested in handling conditions
[09:34:02] <lisp123> https://www.nhplace.com/kent/Papers/Exceptional-Situations-1990.html
[09:34:09] *** Joins: plexi_ (~orcabot@digital.sanctuary.org)
[09:34:20] <lisp123> https://lispcookbook.github.io/cl-cookbook/error_handling.html
[09:34:55] <lisp123> Those three resources will be useful, the last is a practical summary, the second is one of the best articles written in CL and the first is a book on the subject
[09:35:02] *** Joins: lucerne9 (~lucerne@ip202.ip-51-178-215.eu)
[09:35:30] <mfiano> Are there any resources for what goes into operator position of a form?
[09:35:43] *** Joins: madnificent_ (~madnifice@static.210.74.63.178.clients.your-server.de)
[09:35:45] <mfiano> I think he needs N steps backward from those.
[09:35:56] <mfiano> Where N is too large for me to figure out still, after 3 days.
[09:36:59] <mfiano> Particularly, why Notepad++ and a traditional compiler workflow is not suitable for effective Common Lisp development.
[09:38:12] <lisp123> mfiano: lol
[09:39:30] <lisp123> paule32: Try Portacle? https://portacle.github.io/#get-win 
[09:39:47] <CptKirk> What literature would you recommend reading for lisp "philosophy"? As many of the sources that I've read talk incessently about recursion and avoiding mutation, but these things seem to be anathema to the style of modern common lisp?
[09:40:24] <CptKirk> or maybe its just my imagination, or expectations that have lead me to believe those things, or perhaps my time in clojure / scheme land
[09:40:47] <CptKirk> but I don't really understand what tools I should be reaching for "idiomatic Common Lisp"
[09:40:52] <White_Flame> CL simply has powerful looping constructs, and going into manual mode with recursion is simply skipping part of the language
[09:41:10] <White_Flame> what sort of loop are you working on ?
[09:41:14] <CptKirk> (i did see the comment on mapcar/loop/dotimes, I mean in general)
[09:41:15] <lisp123> White_Flame: I love recursion
[09:41:28] <mfiano> Iteration often results in more human-readable code, and in CL, more efficient code.
[09:41:39] <mfiano> WEe have many iteration constructs.
[09:41:53] <White_Flame> sure, I use recursion quite a bit, but not for little loopy things
[09:42:06] <CptKirk> mfiano, I read and write APL/j/k/bqn, I find many things to be human readable that most programmers think comical 
[09:42:22] <mfiano> Scheme are derivatives have taken an opposite convention, due to the langage's history of simplicity.
[09:42:44] <lisp123> CptKirk: CL is considered multi paradigm so don't feel like you have to do one style or another. I am pro recursion so I come from the school of SICP / On Lisp / etc., others seem to be more "practical" and come from the school of Practical Common Lisp & CLOS (I'm generalising alot)
[09:43:34] <lisp123> White_Flame: Yeah for loops I wouldn't either, but otherwise I use a lot of recursion
[09:43:48] <CptKirk> re: history of simplicity, the reputation of "lisps" from lay-people who have not delved into the peculiarities between lisp/scheme implementations is purity, functional style, etc... although I do know that CL is not pure or functional, but support those patterns, I don't know what "effective common lisp" looks like, vs "ideological" or "naive"
[09:43:49] <CptKirk> lisp
[09:43:57] <lisp123> I love the loop macro but John McCarthy doesn't, so I guess I'm in the wrong
[09:44:18] *** Quits: madnificent (~madnifice@static.210.74.63.178.clients.your-server.de) (*.net *.split)
[09:44:19] *** Quits: nocturnal-one (~gilbert@p5492d8bb.dip0.t-ipconnect.de) (*.net *.split)
[09:44:19] *** Quits: plexi (~orcabot@digital.sanctuary.org) (*.net *.split)
[09:44:20] *** Quits: lucerne (~lucerne@ip202.ip-51-178-215.eu) (*.net *.split)
[09:44:20] *** Quits: MetaYan (~MetaYan@c-7b5d235c.07-84-7462671.bbcust.telenor.se) (*.net *.split)
[09:44:20] *** Quits: kagevf (~jfh@ip68-224-125-162.lv.lv.cox.net) (*.net *.split)
[09:44:20] *** plexi_ is now known as plexi
[09:44:20] *** lucerne9 is now known as lucerne
[09:44:36] <White_Flame> I wish the loop macro had better and more lispy semantics, though I still use it a lot.  In-order accumulation of lists is very handy
[09:44:56] <White_Flame> There's an iteration library out there that replaces LOOP that I haven't gotten into yet, that many people use instead
[09:45:24] *** Quits: minion (~minion@common-lisp.net) (Read error: Connection reset by peer)
[09:45:41] <lisp123> CptKirk: CL & Lisp are what you make of it. Be your own lisp :) Why not use the great ecosystem of CL for a more functional style vs. going to another lisp which may not be as well thought through (CL standards are very high quality) and don't have the tooling of CL (great implementations)?
[09:45:50] <CptKirk> White_Flame what is the name?
[09:46:08] *** Joins: minion (~minion@common-lisp.net)
[09:46:28] <White_Flame> CptKirk: I think "iterate"
[09:46:44] <White_Flame> https://common-lisp.net/project/iterate/
[09:48:13] <mfiano> White_Flame: You are not alone, which is why Iterate, for, and others exist. I have my own yet to be started on my back burner...along with similar form FORMAT. Not that I don't enjoy these very good DSLs, but sometimes you want to be a bit more declarative or generate the codes and there is no functional counterpart to them.
[09:48:30] *** Joins: kagevf (~jfh@ip68-224-125-162.lv.lv.cox.net)
[09:48:31] <beach> CptKirk: Modern Common Lisp uses CLOS a lot, as in generic functions and standard classes.  I know many people are put off by "object orientation", but CLOS-style "object orientation" is quite different from what they have experienced in the past.
[09:48:33] <mfiano> s/form/for/
[09:48:34] <CptKirk> I personally have never reached any edge cases for clojure I would find to discourage my enthusiasm. The main reason I'm sticking with common lisp at the moment is April, but if I'm going to be using April, I need to understand "idiomatic" CL, and learn how to use it effectively. I only ever solved toy problems with it and only using recursion and
[09:48:34] <CptKirk> lists, so I'm really trying to figure out "good" practices in CL, and avoid pitfalls where possible
[09:48:45] <White_Flame> yeah, FORMAT is another one that could use some sexprification
[09:49:08] <CptKirk> (i actually really like format, coming from k/apl)
[09:49:10] <White_Flame> CptKirk: it's really hard to get that sort of thing ahead of time
[09:49:20] <White_Flame> *that sort of knowledge
[09:49:43] <White_Flame> generally speaking, not just with CL
[09:50:11] <CptKirk> not so. I've done much of my learning by experimenting with recommendations, and avoiding notable pitfalls
[09:50:23] <mfiano> I prefer this over Iterate, but I just use LOOP until mine is started/complete :) https://shinmera.github.io/for/
[09:50:37] <White_Flame> CptKirk: I mean in a document
[09:50:53] *** Joins: MetaYan (~MetaYan@c-7b5d235c.07-84-7462671.bbcust.telenor.se)
[09:50:55] <White_Flame> you learn style by doing, and seeing what works better for yourself, and hearing what worked better for others
[09:51:05] <White_Flame> (as you have been)
[09:51:15] <mfiano> I would just read the LUV slides, and the rest by "doing"
[09:51:21] <CptKirk> LUV?
[09:51:29] <mfiano> minion: tell CptKirk about LUV
[09:51:29] <minion> Sorry, I couldn't find anything in the database for ``LUV''.
[09:51:33] <mfiano> really minion?
[09:52:04] <lisp123> mfiano: Good idea, its on my list to revisit a few times...I tried being contrarian before, but I'm more and more following it now
[09:52:20] <CptKirk> well its late. are there logs for this channel?
[09:52:23] <lisp123> CptKirk: Common Lisp guidelines written by two of the best CL programmers
[09:52:38] <mfiano> http://www.norvig.com/luv-slides.pdf
[09:52:59] <White_Flame> it also goes extremely conservative
[09:53:39] <White_Flame> CptKirk: no, I think only for the main one
[09:53:47] <CptKirk> The problem I find with Common Lisp or when I first came to APL is the number of options, and not really knowing basic "go-to" patterns look like, no clear goal for how to begin solving a problem. 
[09:54:04] <CptKirk> In APL I can now play around with a dozen approaches all at once and play with these ideas mentally
[09:54:14] <White_Flame> as they say, the best way to get an answer on the net is to post wrong code ;)
[09:54:33] <CptKirk> With CL really the only tools I can think with are recursion and lists, so anything to expand that toolset and aid that expansion in my thinking would be helpful
[09:54:55] <mfiano> And in CL, the best way to get wrong answers, is to post code :)
[09:55:38] <CptKirk> I was taken-aback earlier when I asked the "correct way to handle an accumulator" for a recursive function, and was told "don't"
[09:55:41] <beach> CptKirk: So what do you do when you have complicated data structures to represent?
[09:55:45] <beach> Nested lists?
[09:55:49] <beach> That's a very bad idea.
[09:55:51] <White_Flame> CptKirk: sure, and that's fine.  Intentionally dabble in the iteration constructs for simple things, and get used to them, and you'll end up using them more
[09:56:10] <CptKirk> Maybe its my APL background, but I loath iteration :/
[09:57:19] <mfiano> minion: LUV is Tutorial on Good Lisp Programming Style: http://www.norvig.com/luv-slides.pdf
[09:57:19] <minion> lisp is the glue that binds the variables together 
[09:57:33] <beach> minion: help
[09:57:33] <minion> There are multiple help modules. Try ``/msg minion help kind'', where kind is one of: "lookups", "helping others", "adding terms", "aliasing terms", "forgetting", "memos", "avoiding memos", "nicknames", "goodies", "eliza", "advice", "apropos", "acronyms".
[09:57:45] <beach> minion: Help adding terms
[09:57:45] <minion> To add a term, say something like ``minion: add "term" as: the definition''. I will remember the definition.
[09:57:53] <CptKirk> taking the need for step-wise analysis of problems is one of the great benefits of APL notation, and I find that I get the same clarity of thought from recursion rather than from iteration
[09:58:11] <beach> CptKirk: You didn't answer my question.
[09:58:23] <mfiano> minion: add LUV as: Tutorial on Good Lisp Programming Style: http://www.norvig.com/luv-slides.pdf
[09:58:24] <minion> OK, done.
[09:58:34] <mfiano> minion: tell beach about LUV
[09:58:34] <minion> beach: please look at LUV: Tutorial on Good Lisp Programming Style: http://www.norvig.com/luv-slides.pdf
[09:58:35] <CptKirk> yes in the past I've used a-lists, p-lists, and plain lists along with nested lists
[09:58:39] <mfiano> Yay
[09:58:44] <beach> minion: Thanks!
[09:58:45] <minion> you're welcome
[10:01:56] <lisp123> beach: Did you see Alfred Aho & Jeffrey Ullman won the Turing Award this year?
[10:02:29] <lisp123> Lucky I got a copy of their data structures book after you recommended it, taken a break from it for now, but it was a great read
[10:02:30] <beach> I did, yes. 
[10:02:49] <mfiano> Wow. I didn't. Their algorithm work is extensive.
[10:03:57] <lisp123> mfiano: The Design and Analysis of Computer Algorithms on Amazon, I don't think there is an electronic version, I bought a second hand copy
[10:04:17] *** Joins: shka (~herr@109.231.6.176)
[10:06:13] <mfiano> lisp123: Thanks. I only have their "dragon book"
[10:06:45] <beach> Their algorithms book is one of the few who get binary search right.  The others of the others should be spanked.
[10:06:59] <mfiano> even CLRS?
[10:07:09] <lisp123> mfiano: That one is too advanced for me. I expect to see an MCL (Mfiano Common Lisp) soon ;)
[10:07:20] <beach> mfiano: Which one is that?
[10:08:00] <White_Flame> Chattanooga Longshoremen Recovery Society, clearly
[10:08:03] <mfiano> Introduction to Algorithms, aka the bug huge book of algorithms most unis use
[10:08:18] <mfiano> It is named as such due to the 4 authors' last names, not anything to do with CL :)
[10:08:35] <beach> Let me check if I can find their binary search...
[10:08:36] <mfiano> s/bug/big/
[10:11:26] <beach> I don't have it and I can't find their algorithm.  But any binary-search algorithm that starts each iteration by testing for equality is twice as slow as it should be.
[10:13:22] <mfiano> I will take your word for it. I don't have the book handy myself.
[10:13:37] <mfiano> I haven't written a bisect algorithm in a long time
[10:13:52] <mfiano> Would you care to check mine in CL if I can dig up code that old?
[10:14:01] <beach> Sure.
[10:14:27] <beach> But it's simple.  Many algorithms start by checking for equality, and if it is not equal, they then check for < or >.
[10:14:37] <beach> That gives 2 tests per iteration instead of one.
[10:14:46] <beach> Checking for < or > is enough.
[10:14:58] <mfiano> A little domain specific but https://gist.github.com/f57f63bcf1e465aee7b54d3623e6d9dd
[10:15:05] <beach> You check for = only when there is a single element left.
[10:15:18] <mfiano> I see
[10:15:34] <beach> This looks correct.
[10:16:03] <mfiano> But is it slower than it needs to be as you pointed out?
[10:16:22] <mfiano> (I know it is correct)
[10:16:43] <beach> By "correct" I mean that it makes only one test per iteration which is as it should be.
[10:17:05] <mfiano> Oh yeah, I don't see why you would ever do otherwise
[10:17:30] <beach> Exactly, which is why authors who do that should be spanked.
[10:17:44] <mfiano> Well good to know I was thinking when I wrote that.
[10:17:52] <beach> Indeed.
[10:18:08] <mfiano> Thanks!
[10:18:15] <beach> Pleasure.
[10:20:48] <mfiano> Looks like CLRS doesn't even have this...it's talked about in prose in insertion sort, and has various BST types, but no bisect pseudo-code to compare.
[10:21:21] <beach> Hmm.  That's strange.  In most books, it's one of the first ones introduced. 
[10:21:26] *** Quits: vats (~vats@103.70.83.52) (Remote host closed the connection)
[10:21:33] <mfiano> That would be insertion sort in this book IIRC.
[10:21:52] <mfiano> and this is a well known book used in the industry.
[10:23:44] <mfiano> It could be the index is just not written very well. The book is rather huge and I have better things to do :)
[10:23:59] <beach> Absolutely.  Don't worry about it.
[10:24:23] <beach> It is not as though we can find the authors and spank them anyway.
[10:26:28] <lisp123> (((:G3 . 5) (:G4 . 5)) ((:G3 . 5) (:G4 . 6))) --> Nesting of lists gets hard to follow, so perhaps as a general rule I should not use a-lists if they are nested 2 levels in? E.g. ((:g3 . 5) (:g4 . 6)) is fine because it is a list of a-lists but the earlier example is harder to follow because its a list of lists of alists?
[10:27:15] <mfiano> beach: The main author I have emailed errata to several times. He is a professor at Dartmouth if you want to go spank him :) https://www.cs.dartmouth.edu/~thc/
[10:27:35] <beach> lisp123: You should start by designing the protocol ("interface", "api", etc.).  Only then can we give advice on representation.
[10:27:42] <mfiano> Ah, nevermind: "I taught my final course in Fall 2019"
[10:27:48] <beach> Heh.
[10:28:26] *** Joins: cranium (~cranium@user/cranium)
[10:29:05] <mfiano> lisp123: You are incorrect in your wording
[10:29:08] <beach> lisp123: Usually, an alist is an implementation of the abstract data type "dictionary".  And you would create protocol functions that take a key and return a value.  
[10:29:26] <mfiano> lisp123: The latter is an "alist" not a "list of alists"
[10:29:44] <mfiano> The first would be a "list of 1 alist"
[10:31:14] <lisp123> beach: Ok, I guess that makes sense once I move out of prototyping stage. So I will make it a point to review and adjust the data structures accordingly
[10:32:10] <lisp123> mfiano: Just to confirm, you mean a list of 2 alists for the former
[10:32:32] <mfiano> yes sorry
[10:32:40] <mfiano> lisp123: Also note that an "association list" need not have dotted conses as elements. '((a 1) (b 2)) is an alist, where the value is a list of 1 element. The same could be rewritten to express that as: '((a . (1)) (b . (2)))
[10:33:04] <lisp123> mfiano: Yes, of course :)
[10:33:43] <mfiano> Ok good. This is also a property list where the key is (a 1) and the value is (b 2), because there are an even number of root elements :)
[10:34:31] *** Joins: rotateq (~user@b2b-78-94-235-194.unitymedia.biz)
[10:34:33] <lisp123> My only issue with using non-list data structures is that they get a bit more idiosyncratic to work with later (list operations are very common so mentally easy to whip up)....but beach, I think that's a good idea re key & value, and then using generic functions accordingly to avoid having multiple function names for the same thing (key & value)
[10:35:37] <lisp123> mfiano: Yes, makes sense...lists lack so much structure at times - what makes them good for prototyping makes them bad for other things :)
[10:35:41] <mfiano> lisp123: I think you and CptKirk need to become familiar with non-list data structures, particularly standard-object representations.
[10:37:56] <lisp123> mfiano: I am, just trying to find the right balance that works for me
[10:38:46] <rotateq> lisp123: I remember some days ago you said you were learning about vectors and arrays :)
[10:38:50] <mfiano> He was asking about idiomatic Common Lisp, and gaining experience with standard objects and generic functions is the best advice I can give. 
[10:39:22] <mfiano> He mentioned it is difficult for him to grasp non-list, non-recursive data structures.
[10:39:26] <lisp123> rotateq: I ended up learning vectors a bit the other day :) Still a while to go before its second nature
[10:39:27] <mfiano> IIRC
[10:39:32] <beach> lisp123: It is usually a good idea to think about the protocol first, rather than as an afterthought. 
[10:39:48] <mfiano> ^
[10:39:58] <rotateq> yes and then something else the other day. go back to the recipes book chapter 5
[10:40:40] <lisp123> mfiano: I suspect it is because when doing recursion, one quickly defaults to (cond ((null ...) ...) (t ...(function (cdr ...)......
[10:41:23] <beach> lisp123: Another reason to avoid recursion for linear structures.
[10:41:51] <beach> lisp123: I reserve recursion for trees and more complicated graphs. 
[10:42:01] <White_Flame> granted, when dealing with potentially dotted lists, that sort of thing can be clearer.  However, general use is for proper lists
[10:42:02] <lisp123> beach: Agreed, depends on what one wants to do --> Yes, I only use it for trees & graphs atm
[10:42:25] <mfiano> beach: I still use iteration for trees of sophisticated depth. An in-order traversal could blow the stack otherwise
[10:42:51] <beach> mfiano: Yes, I have been known to do that too. 
[10:43:15] <beach> Cluffer used to blow the stack because the splay trees created were initially essentially linear lists.
[10:43:35] <mfiano> degenerate trees aside, but yeah
[10:46:08] *** Quits: sts-q (~sts-q@212.53.219.184) (Ping timeout: 252 seconds)
[10:46:33] <lisp123> Okay, so I have a related question now
[10:47:30] <lisp123> Actually never mind, its not theory related, I will figur esomething out
[10:49:45] <mfiano> I think the best way to design a program is to start defining the classes that participate, and a set of generic functions for the behaviors. Note that the generic functions are just protocols, with no implementation methods yet. This is sort of what beach was suggesting.
[10:50:05] <beach> Exactly. 
[10:50:16] <mfiano> Only when the protocol is sound do I begin with the implementation.
[10:50:35] <mfiano> Soundness also being architectural organization, like packaging and file layout.
[10:50:38] *** Quits: jeffrey (~jeffrey@80-115-60-193.cable.dynamic.v4.ziggo.nl) (Ping timeout: 250 seconds)
[10:51:39] <lisp123> One (not really an issue but I'll use that term) issue I'm facing right now with generic functions is that the specialisation is done by the machinery of Lisp, and not embedded in the function
[10:51:55] <mfiano> I don't understand.
[10:52:13] <beach> Moi non plus!
[10:52:14] *** Quits: bldr_ (~bull@185.117.72.168) (Ping timeout: 252 seconds)
[10:52:20] *** Joins: bldr (~bull@185.117.72.168)
[10:52:32] <lisp123> This is a bit specific (so not something for most people), but if I have two defmethods with the same symbol CL-FUNCTION-1
[10:52:45] <lisp123> CLOS / CL is able to know which one to use
[10:52:53] <mfiano> No, you do.
[10:52:59] <mfiano> CLOS just does what you specify
[10:53:20] <lisp123> Yes, but its within the machinery of generic functions, this is abstracted away vs. writing a huge COND table
[10:53:20] <mfiano> I don't think I am understanding the issue any better.
[10:53:36] <mfiano> Ok, and the issue with that is?
[10:54:17] <beach> lisp123: You can do that if you want, using the :METHOD option to DEFGENERIC, but that kind of defeats the purpose.
[10:54:22] *** Joins: rdrg109_ (~rdrg109@51.195.232.80)
[10:54:23] <mfiano> Your generic function forms (defgeneric) are explainers for how the method combinations work.
[10:54:38] <cranium> how so?
[10:55:11] <mfiano> (defgeneric foo (...) (:method-combination ...))
[10:55:20] <cranium> oh, yeah.
[10:55:30] <mfiano> standard method combination with most-specific-first precedence is the default
[10:55:53] <lisp123> I am trying to write my documentation in CL itself. So I am using IBCL where the source code for each function is attached to a hash table against the function's symbol (key)
[10:56:24] <mfiano> Well, there is no standard way to get the source code of a function.
[10:56:36] <mfiano> If there were, commerical Lisps would be out of business.
[10:56:38] <lisp123> But if I use generic functions, I would need to augment that key I guess with the specialisations applied in each DEFMETHOD
[10:56:58] <beach> lisp123: Then I thin you are doing things backwards.  You are using a tool that makes it necessary to avoid great programming tools.
[10:57:02] *** Quits: rdrg109 (~rdrg109@51.195.232.80) (Ping timeout: 252 seconds)
[10:57:06] <beach> *think
[10:57:25] <lisp123> Is there a way to access the dispatch table of generic functions?
[10:57:39] <mfiano> The dispatch table doesn't exist really.
[10:57:43] <mfiano> It is runtime dispatched
[10:58:39] <mfiano> Unless I'm misunderstanding the question.
[10:58:41] <lisp123> My dream would be to attach a unique identifier to each DEFMETHOD
[10:59:15] <mfiano> That doesn't make sense.
[10:59:21] <cranium> are you sure that is your dream?
[10:59:25] <lisp123> lol
[10:59:28] <beach> lisp123: You have very strange dreams apparently. 
[10:59:37] <mfiano> The generic function is the object that matters.
[10:59:45] <lisp123> beach: All of them lisp related ;)
[11:00:50] *** Joins: sts-q (~sts-q@212.53.219.184)
[11:01:49] <mfiano> I mean
[11:01:59] <mfiano> Did you veer use #'find-method?
[11:02:01] <mfiano> ever*
[11:02:30] <mfiano> If you continue down this design, it sounds like your hash table should be EQUAL tested.
[11:02:43] <lisp123> mfiano: Thanks, that helps. I think so too
[11:02:47] <mfiano> Even functions themselves are not always symbols
[11:02:57] *** Joins: sjl (~sjl@cpe-66-66-5-59.rochester.res.rr.com)
[11:03:12] <mfiano> For example a lambda expression denotes a function. So does (defun (setf foo) (...) ...)
[11:03:29] <lisp123> So basically my question is there a way for me to copy the mechanics of find-method for myself
[11:03:30] <pjb> lisp123: (generic-function method-qualifiers specializers) is the identifier of each method.
[11:03:37] <mfiano> and as does (defgeneric ... (:method ...)) or (defmethod ...)
[11:04:27] <cranium> does "it is runtime dispatched" mean there is no way for me to e.g. create a list of the called methods (in order) for a given call without actually running it and somehow recording it? 
[11:04:43] *** Quits: sjl_ (~sjl@cpe-66-66-5-59.rochester.res.rr.com) (Ping timeout: 252 seconds)
[11:05:23] <mfiano> cranium: Yes. In Common Lisp, the class of an object can change at runtime, and other very nice tools at our disposal. See #'change-class
[11:05:37] <lisp123> pjb: Thanks, worth adding to IBCL to allow source code tracking for generic functions (perhaps its already there)?
[11:05:58] <White_Flame> lisp123: the unique identifier of each defmethod is its lambda list specializations and any :before/:after/:around
[11:06:22] <White_Flame> oh, pjb basically answered that, too
[11:06:24] <lisp123> Was wondering if it was possible to rely upon the dispatch table somehow to do some of the heavy lifting
[11:06:32] <mfiano> lisp123: Using the MOP
[11:06:50] <mfiano> a generic function metaobject lists all of its associated methods
[11:07:07] <pjb> (apply (function find-method) (list (function print-object) '() '(point t))) #| --> #<standard-method print-object (point t)> |# 
[11:07:16] <cranium> mfiano: That means I can't even do it for an image in a given state? Because my code can have #'change-class in it?
[11:07:37] <mfiano> cranium: I don't understand
[11:08:34] <cranium> I'm not sure I do either.
[11:09:35] <mfiano> The best advice I can give is to read AMOP
[11:09:45] <lisp123> mfiano: "If you continue down this design, it sounds like your hash table should be EQUAL tested." --> Just thinking this through, so one issue is that even if the lambda list specialisations uniquely define a method, due to inheritance, one needs to know which method is applicable
[11:11:00] <lisp123> So after all this confusion, I can restate my question: Is there a way to supply a certain set of arguments and for CL to tell me which method applies to them? I guess that this is FIND-METHOD?
[11:11:37] <mfiano> True and with a dynamic dispatch system you can't know that in the general sense without recording it during a call.
[11:11:37] <mfiano> It sounds like you are trying to design a static type system
[11:11:37] <mfiano> I may be completely wrong though.
[11:11:41] <lisp123> And then we can use this as a key for looking up the source code stored in a hash table? pjb --> HOw does that sound?
[11:12:07] <beach> cranium: You can use COMPUTE-APPLICABLE-METHODS.
[11:12:34] <beach> lisp123: What "dispatch table" are you referring to?
[11:13:32] <mfiano> Only the runtime system can know which method is applicable, unless you dig into the MOP...at runtime, since the MOP and change-class etc can alter the result at any time.
[11:14:48] <cranium> do people do that?
[11:14:59] <beach> Do what?
[11:15:03] <Duuqnd> Use CHANGE-CLASS? Yes.
[11:15:07] <White_Flame> mfiano:  or even new runtime DEFMETHODs
[11:15:19] <mfiano> There might be restrictions on change-class...like i don't think it should be permitted to be done in the middle of an effective method, but i could be wrong and I'd have to check. maybe beach or someone knows
[11:15:39] <beach> cranium: Yes, we do that all the time in order to preserve the identity f object while still turning them into something different.
[11:16:01] <lisp123> beach: The one that tells instructs which DEFMETHOD to use. However, looks like I have an answer to what is needed to be done (FIND-METHOD)
[11:16:12] <beach> mfiano: Right, you are not allowed to change the applicability of methods during dispatch. 
[11:16:25] <pjb> lisp123: if you build the table yourself from the source, it's better to use the generic function name than the generic function itself.
[11:16:30] <mfiano> pretty sure the CPL must not be altered during an effective method computation, else you run into a possibly infinite method
[11:16:41] <cranium> CPL?
[11:16:43] <White_Flame> lisp123: there is a set of methods behind a generic function.  "table" implies some sort of indexing, and that's left up to the implementation to optimize
[11:16:45] <beach> lisp123: In general, several methods are applicable to some arguments. 
[11:16:58] <pjb> lisp123: so: (gethash '(print-object () (point t)) *method-source-positions*)
[11:18:09] <mfiano> cranium: Class precendence list
[11:18:23] <lisp123> pjb: Thanks, was thinking the same
[11:18:45] <lisp123> beach: Thanks, yes understood.
[11:19:25] <cranium> So I guess if one wanted to resaon about what one's program actually does, there is little other option than either grok the source or to run stuff and see what happens.
[11:20:21] <mfiano> Seriously though, AMOP makes CLOS a lot less magical
[11:20:30] <cranium> (as opposed to have a program aid in one's understanding. Like, in Java my IDE can produce sequence diagrams and such)
[11:20:36] <mfiano> Well in the sense that it is better understood. Still magical in the sense that it can do nearly anything :)
[11:21:19] <mfiano> cranium: That's undecidable
[11:24:13] <beach> cranium: The existence of CHANGE-CLASS does not affect the meaning of the program.
[11:24:43] <lisp123> I've finally converted to the full world of CLOS. My last remaining concern before hand was that the COND table was abstracted away so I couldn't readily inspect the source of a generic function, but now there is a solution :)
[11:25:31] <mfiano> I must go now. Good luck. And I will mention it a third time incase it wasn't emphasized enough: read AMOP :)
[11:25:53] <lisp123> mfiano: Yes I have a copy, but its too advanced for me. In due course :) Thanks and enjoy the rest of your day
[11:28:46] <cranium> beach: can you qualify that statement? if there's a CHANGE-CLASS call inside a method that changes the class of the methods arguments, that is not going to change the applicable-methods chain of the current call?
[11:29:14] <beach> cranium: That's undefined behavior, so don't do it.
[11:29:51] <beach> cranium: Like we said, method applicability is not allowed to change during the invocation of a method.
[11:30:03] <beach> er, during the invocation of a generic function.
[11:30:16] <cranium> The discussion so far has left me with the impression that this is what people do all the time.
[11:30:27] <beach> Not at all.
[11:30:42] <mfiano> This includes using #'call-next-method in a way that alters the dispatched method list
[11:31:00] <cranium> it was said "during dispatch" then I interpreted "CL finds the applicable methods first, then runs stuff" so during running you could modify stuff willy-nilly.
[11:31:03] <mfiano> IIRC there is different semantics in "safe code" here
[11:31:11] <cranium> that interpretation was wrong, I see.
[11:31:27] <beach> cranium: You could, but that's undefined behavior, so don't do it.
[11:31:34] <cranium> understood.
[11:32:12] <beach> Let me see if I can find the relevant phrase in the standard...
[11:33:09] <cranium> so I suppose "even new runtime DEFMETHODS" did not mean "people create methods inside method calls that change precedence for the given call" either.
[11:33:50] <White_Flame> more like people write new source code and load it into the running image
[11:34:33] <beach> cranium: What White_Flame says.  You would not add methods to a generic function currently being executed.  
[11:35:25] *** Joins: hendursa1 (~weechat@user/hendursaga)
[11:35:29] <cranium> I see. i.e. once the Method chain for a given call has been decided it is not to be tinkered with. That is what one would expect to count as best-practice.
[11:36:17] <beach> Not while the applicable methods are being applied, at least.
[11:36:19] <cranium> (from inside the call)
[11:36:25] <cranium> exactly.
[11:36:27] <beach> Right.
[11:36:58] <beach> I think the restrictions are somewhat less strict, but I can't find the relevant passage right now.
[11:38:24] <mfiano> "the ordered set of applicable methods for a changed set of arguments for call-next-method must be the same as the ordered set of applicable methods for the original arguments to the generic function."
[11:38:26] <mfiano> ?
[11:39:02] <beach> That sounds right.
[11:39:03] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[11:39:07] <cranium> my next question would have been whether the list of applicable methods is determined at the start of the call or by the individual call-next-methods ^^
[11:39:12] <mfiano> or an error of type error should be signaled"
[11:39:24] <mfiano> ::clhs 1.4.2
[11:39:35] <mfiano> gah bot consistency
[11:39:55] <beach> cranium: It is determined at the beginning, using compute-applicable-methods. 
[11:40:00] <mfiano> http://www.lispworks.com/documentation/HyperSpec/Body/01_db.htm
[11:40:09] <beach> cranium: In fact it is likely cached.
[11:40:28] <mfiano> Note what it says there about "should be signalled"
[11:40:46] <cranium> Am I correct that this does not make much of a difference for the user cause they have to be the same anyway as per the quoted section?
[11:40:58] <mfiano> SBCL does not error with default safety. CCL does (because their default safety levels differ)
[11:41:18] <mfiano> This could be a huge bug gone un-noticed if using SBCL without changing the compiler policy
[11:41:50] <beach> cranium: Yes, that sounds right.
[11:43:33] <cranium> thanks, this is all very interesting.
[11:45:20] <mfiano> Ok, I'm back to being gone :)
[11:45:23] <beach> I think it's allowed to change the class of an argument to a method, provided the object in question is not passed to other methods during the same call, as in CALL-NEXT-METHOD or the chain of :BEFORE and :AFTER methods.
[11:46:54] <beach> But that makes me wonder about an optimization I believe SBCL does.  Consider (defmethod foo ((x bar)) (baz x) (some-slot-accessor x))
[11:48:04] <beach> I believe that SBCL has an optimization where the call to SOME-SLOT-ACCESSOR is simplified according to the "known" class of X, namely BAR.  So then I wonder what happens if BAZ changes the class of X.
[11:48:41] <beach> One hopes they take this possibility into account by checking whether X can "escape" before its accessor is executed. 
[11:49:05] <White_Flame> I'd think that all it would need to do would be to check that the class is EQ as expected in the specialized some-slot-accessor
[11:49:26] <beach> Right, that would be enough.
[11:49:38] <White_Flame> but of course then also jump to a correct slow path
[11:49:42] <beach> But do they?
[11:49:52] <White_Flame> no clue, I rarely use this sort of stuff ;)
[11:50:34] <mfiano> beach: Please test this and file the proper bug ticket!
[11:50:50] <beach> Not sure how to test it.
[11:52:00] <mfiano> That could simply be explaining the possible problem in #sbcl
[11:52:37] <beach> I'll leave that to someone else.  I will instead contemplate how to do it in SICL.
[11:53:57] *** Joins: Cymew (~ante@c-e989225c.023-1144-7570702.bbcust.telenor.se)
[11:57:47] *** Joins: selwyn (~selwyn@user/selwyn)
[12:13:01] *** Quits: shka (~herr@109.231.6.176) (Remote host closed the connection)
[12:13:25] *** Joins: shka (~herr@109.231.6.176)
[12:13:28] *** Quits: GreaseMonkey (greaser@user/greasemonkey) (Read error: Connection reset by peer)
[12:13:31] *** Quits: rotateq (~user@b2b-78-94-235-194.unitymedia.biz) (Ping timeout: 252 seconds)
[12:13:44] *** Joins: rotateq (~user@b2b-78-94-235-194.unitymedia.biz)
[12:14:35] *** Joins: greaser|q (greaser@antihype.space)
[12:21:34] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[12:22:26] *** Joins: lisp123 (~lisp123@5.30.23.247)
[12:27:13] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[12:41:49] *** Joins: lisp123 (~lisp123@5.30.23.247)
[12:43:14] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[12:44:39] *** Quits: sts-q (~sts-q@212.53.219.184) (Ping timeout: 252 seconds)
[12:46:44] *** Joins: sts-q (~sts-q@212.53.219.184)
[13:15:34] *** Quits: hendursa1 (~weechat@user/hendursaga) (Remote host closed the connection)
[13:19:06] *** Joins: hendursa1 (~weechat@user/hendursaga)
[13:25:20] *** Joins: random-nick (~random-ni@87.116.165.220)
[13:42:11] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[14:19:37] *** Quits: CptKirk (~CptKirk@70-57-27-195.hlrn.qwest.net) (Quit: Client closed)
[14:32:19] <paule32> hello
[14:32:39] <paule32> under msdos (win console) i can do following
[14:32:58] <paule32> cl --quit --load test.lisp > log 2>1&1
[14:33:37] <paule32> this will load test.lisp, and error out init log file without error output console
[14:33:59] <paule32> how can i prevent the error output on screen, and pipe errors to log
[14:39:11] <mfiano> MS-DOS hasn't been a part of windows in about a quarter century, and I doubt MS-DOS knew about POSIX shell syntax.
[14:48:31] <paule32> no, i mean, windows has inbuilt console
[14:48:44] <cranium> powershell?
[14:48:57] <cranium> the blue one
[14:48:59] <paule32> ehm yes, this, too, but i mean cmd.exe
[14:49:02] <mfiano> This isn't the correct IRC channel for that
[14:50:05] <paule32> mfiano: i only ask for pipeing
[14:50:28] <mfiano> Please let this channel be for newcomers to ANSI Common Lisp
[14:51:10] <paule32> this only my place, where i can stay, the other channels of lisp dont like me
[14:51:40] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[14:53:14] <mfiano> That is because you do not listen to advice, such as this one.
[15:10:07] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 240 seconds)
[15:10:32] *** Joins: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se)
[15:18:42] *** Joins: selwyn (~selwyn@user/selwyn)
[15:20:17] *** Quits: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de) (Quit: Leaving)
[16:02:34] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[16:16:18] *** Joins: macaw (~macaw@176.221.120.196)
[16:26:19] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[16:28:11] *** Joins: selwyn (~selwyn@user/selwyn)
[16:28:34] <paule32> hello
[16:28:43] <paule32> i download emacs + slime
[16:28:50] <paule32> for windows 10
[16:29:00] <paule32> how can i install slime ?
[16:29:17] <paule32> i have depack it into E:\Emacs\slime
[16:48:24] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Remote host closed the connection)
[16:48:45] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[16:53:24] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[17:00:47] <rotateq> hey paule32 
[17:01:04] <rotateq> you could also use portacle
[17:01:48] <rotateq> i normally use spacemacs, there is much managed with layers in the config file, so I don't know for plain emacs
[17:08:07] *** Joins: Josh_2 (~user@37.25.47.130)
[17:11:48] <Cymew> Portacle is a good idea if you're on Windows and new to emacs and lisp.
[17:13:27] <rotateq> or if you have no root on this working machine here ... :)
[17:13:43] <rotateq> but nearly finished for today
[17:19:13] <anxt_> M-x package-install slime
[17:19:55] <anxt_> but i think paule32 is just funnin' y'all
[17:20:47] <Cymew> How up to date is the emacs package of slime in general?
[17:20:55] <anxt_> not terribly
[17:21:13] <Cymew> I almost expected that.
[17:21:24] <anxt_> i just cloned out the repo, and checked out a tag, and use that
[17:21:43] <Cymew> The packages part of emacs is still something new to me, so I also work from a git clone.
[17:22:06] <Cymew> But, I think a newbie can probably work from packages, or even better, portacle.
[17:22:23] <anxt_> it seems reasonable.  then an upgrade is git pull, git checkout <tag>
[17:22:39] <anxt_> i load swank out of there too
[17:29:49] <rotateq> see you later :)
[17:29:52] *** Quits: rotateq (~user@b2b-78-94-235-194.unitymedia.biz) (Quit: ERC (IRC client for Emacs 26.3))
[17:31:28] *** Quits: Cymew (~ante@c-e989225c.023-1144-7570702.bbcust.telenor.se) (Ping timeout: 250 seconds)
[17:34:05] <paule32> anxt_: no
[17:34:13] <paule32> i download emacs
[17:34:18] <paule32> it is no editor for me
[17:34:34] <paule32> sorry for idle
[17:34:43] <paule32> but i waste time with emacs
[17:35:10] <paule32> but, i install + setup quicklisp
[17:35:31] <beach> paule32: Can you even imagine how much of *our* time you have wasted in the past, and continue to waste every time you don't follow advice?
[17:38:14] *** Parts: paule32 (~paule32@user/paule32) (Leaving)
[17:41:06] <anxt_> I am guessing s/he is just a troll.  I don't think morons start using lisp.
[17:41:54] <beach> anxt_: I am afraid you are wrong.  
[17:42:11] <anxt_> beach, that's OK.  I am wrong all the time.
[17:43:33] <anxt_> just ask my wife :)
[17:46:08] *** Joins: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca)
[18:05:55] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Quit: ec)
[18:13:23] *** Quits: hendursa1 (~weechat@user/hendursaga) (Quit: hendursa1)
[18:13:46] *** Joins: hendursaga (~weechat@user/hendursaga)
[18:21:48] *** Joins: jeffrey (~jeffrey@80-115-60-193.cable.dynamic.v4.ziggo.nl)
[18:23:57] *** Quits: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[18:38:35] *** Joins: thrig (~thrig@65.113.153.50)
[18:42:05] *** Quits: cranium (~cranium@user/cranium) (Quit: Leaving)
[18:57:45] *** Joins: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca)
[19:09:23] *** Quits: macaw (~macaw@176.221.120.196) (Quit: Client closed)
[19:09:35] *** Joins: macaw (~macaw@176.221.120.196)
[19:14:30] *** Joins: CptKirk (~CptKirk@70-57-27-195.hlrn.qwest.net)
[19:17:31] *** Quits: jeffrey (~jeffrey@80-115-60-193.cable.dynamic.v4.ziggo.nl) (Ping timeout: 252 seconds)
[19:18:36] *** Quits: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[19:28:51] <CptKirk> I believe someone mentioned yesterday that CLOS is very different from typical OOP in other languages
[19:29:07] <CptKirk> Can someone articulate what that means?
[19:29:10] <beach> That might have been me.
[19:29:20] <thrig> depends on how you define "typical", as OO systems are wildly different
[19:29:42] <beach> CptKirk: Most object-oriented systems confuse classes with encapsulation. 
[19:29:43] <thrig> like the smalltalk guy looked at C++ and said "that ain't OO"
[19:30:08] <beach> CptKirk: with CLOS, classes are just containers for data and encapsulation is handled by the package system.
[19:30:46] <beach> CptKirk: So in CLOS, classes don't contain methods.  There is a concept of a generic function that has different methods that specialize to different classes.
[19:33:05] <CptKirk> Would it be accurate to say that the CLOS is more of a way to define a type with associated functions?
[19:34:29] <beach> more of ... than what?
[19:34:47] <CptKirk> than "other OO systems"?
[19:35:18] <beach> Not quite. 
[19:36:10] <beach> A class is a type, but some types can not be classes.  So you define classes for CLOS use, and not arbitrary types.
[19:36:59] <beach> And the functions are not "associated with" the class.  Functions are generic functions, meaning that they have multiple implementations, each one manifested by a method.
[19:38:03] <beach> A method can specialize to an arbitrary number of classes, so it's a multi-method.  The method is applicable when arguments to the generic function are instances of these classes, in the order they appear in the lambda list.
[19:39:35] <beach> Each call to a generic function determines a list of applicable methods.  These methods are combined by a method-combination object to form an effective method.  This effective method is what determines how the arguments are processed.
[19:43:23] <CptKirk> I'm taking "....encapsulation etc" to mean that you don't define accessors, or "private" state
[19:44:21] <beach> Correct.  Classes have named "slots", and slot names are symbols, so they obey the package system.
[19:44:52] <beach> Similarly slot accessors are generic functions, so their names also obey the package system.
[19:45:25] <CptKirk> But in usage of classes, I wonder what the distinction is. When using a class, or instance of an object derived from the class specification, it doesn't seem all that different from what I would expect from other dynamic OO languges, like say Python
[19:46:59] <beach> In a traditional OO language, the class definition is a syntactic construct, so methods must be grouped inside that construct.  Methods on generic functions can be in different places, and different files even.
[19:48:25] <beach> But yes, it is normal to project new information to what is already known.  But I can guarantee that CLOS object-oriented programming looks very different from that of those traditional languages. 
[19:48:32] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[19:51:32] <CptKirk> So the usage is just about the same, its how it is defined that is different
[19:53:02] <beach> No.  Generic functions are functions so they can be used with things like mapcar, reduce, etc.   Methods in a traditional language must be syntactically invoked with an object, as in obj.method(...).
[19:53:55] <beach> So, in addition, traditional OO languages are single dispatch, and it shows, because the "obj" in obj.method is treated specially.  In CLOS, it is just another argument. 
[19:59:21] <macaw> beach: Wouldn't it be fair to say that in short, CLOS on the surface can be used the same as (and is similar to) traditional OO, but when scratch even a bit deeper, there is a whole universe of differences?
[19:59:44] <macaw> s/scratch/you scratch/
[20:00:36] *** Quits: CptKirk (~CptKirk@70-57-27-195.hlrn.qwest.net) (Quit: Client closed)
[20:01:36] <beach> macaw: Sure, traditional OO style can be thought of as a tiny subset of CLOS, plus additional restrictions that makes it much harder to use than CLOS.
[20:02:00] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[20:02:53] <beach> I mentioned "method combinations" for instance.  That's an entire new universe to explore.  Traditional OO languages have one fixed (and particularly stupid) method combination.
[20:03:13] <thrig> if only there were some way :around that
[20:03:37] <beach> Heh.
[20:05:13] <macaw> beach: Thanks. And agreed - CLOS is way more thought-through.
[20:05:46] <beach> Sure.
[20:06:17] <beach> And, yes, they really gave it a lot of thought, rather than copying Simula-67 as the others did.
[20:06:40] <beach> ... that's 1967 in case you had a doubt.
[20:08:17] <thrig> Go got compared to Algo 68, iirc. pretty similar.
[20:09:52] <beach> Makes sense.
[20:11:10] *** Joins: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de)
[20:13:46] *** Joins: CptKirk (~CptKirk@70-57-27-195.hlrn.qwest.net)
[20:14:04] <CptKirk> where can I find the logs? I lost internet :C
[20:14:23] <beach> This channel is not logged.
[20:14:55] <beach> Not much was said after you left.
[20:15:02] <CptKirk> ok
[20:16:10] <pjb> CptKirk: that's so you may feel to ask even question you'd think are dumb. 
[20:17:18] <CptKirk> I already do that <3
[20:19:18] <pjb> Well, nobody will know, no logs, no trace ;-)
[20:28:19] <CptKirk> That's too bad
[20:35:17] <pjb> CptKirk: If you need CL exercices for this week-end: https://cliki.net/Exercices
[20:35:28] <CptKirk> seems like in a "school" room you'd want to have a record so you don't have to constantly repeat yourself
[20:36:00] <pjb> It's more oriented student than teacher ;-)
[20:36:58] <pjb> And while I may have some canned answers for references, the purpose is to give personalized interaction to the students.
[20:37:21] <pjb> Basic Lisp Techniques  Cooper - 2003 Franz, Inc. - 100 pages.  http://www.franz.com/resources/educational_resources/cooper.book.pdf
[20:37:31] <pjb> ^ example of canned answer ;-)
[20:39:55] <CptKirk> what about the LUV thing from yesterday?
[20:41:21] <pjb> Yes.  
[20:42:05] <pjb> The thing with books and tutorial,  is that while we may advice you some, you will know better which one is the best for you, the one that you understand better and learn more with.
[20:43:23] <CptKirk> I've read several, I was wondering if someone can share the link to the LUV thing that was mentioned yesterday since there are no logs
[20:51:30] *** Joins: lisp123 (~lisp123@5.30.23.247)
[20:52:18] <mfiano> minion: tell CptKirk about luv
[20:52:19] <minion> CptKirk: please look at luv: Tutorial on Good Lisp Programming Style: http://www.norvig.com/luv-slides.pdf
[20:52:24] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[21:15:52] *** Joins: jeffrey (~jeffrey@2001:1c00:b11:8800:399c:16c5:8a3c:727e)
[21:18:04] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[21:23:35] *** Joins: makomo (~makomo@user/makomo)
[21:24:35] *** Joins: lotuseater (~user@p200300e78715be00e2e5898694cab6cd.dip0.t-ipconnect.de)
[21:26:46] *** Quits: makomo (~makomo@user/makomo) (Client Quit)
[21:27:04] *** Joins: makomo (~makomo@user/makomo)
[21:30:55] *** Joins: tzagorsky (~textual@37.57.0.211)
[21:33:56] *** Joins: CptKirk16 (~CptKirk@70-57-27-195.hlrn.qwest.net)
[21:34:42] *** Quits: CptKirk (~CptKirk@70-57-27-195.hlrn.qwest.net) (Ping timeout: 256 seconds)
[21:38:47] *** Quits: tzagorsky (~textual@37.57.0.211) (Quit: Textual IRC Client: www.textualapp.com)
[22:06:56] *** Quits: thrig (~thrig@65.113.153.50) (Remote host closed the connection)
[22:07:40] *** Joins: Psybur (~Psybur@mobile-166-170-32-197.mycingular.net)
[22:21:21] *** Joins: tyson2 (~user@72.142.96.152)
[22:33:56] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 246 seconds)
[22:35:51] *** Joins: aeth (~aeth@user/aeth)
[22:37:50] <macaw> Wow, the "Good Lisp Programming Style" paper looks clearly-written and useful. Thank you for sharing!
[22:47:27] <CptKirk16> macaw can you link that paper?
[22:52:02] <macaw> Sure. It was the one minion sent towards you: "CptKirk: please look at luv: Tutorial on Good Lisp Programming Style: http://www.norvig.com/luv-slides.pdf" :)
[23:04:43] *** Quits: jeffrey (~jeffrey@2001:1c00:b11:8800:399c:16c5:8a3c:727e) (Ping timeout: 252 seconds)
[23:42:39] <CptKirk16> Oh I already read that
[23:42:48] <CptKirk16> Thought you were referring to another one macaw
[23:44:42] <CptKirk16> Again, probably coming from my APL background I feel after reading this I should mention I have a strong aversion to abstraction as well
[23:54:34] *** Joins: lottaquestions (~nick@2607:fa49:503e:3000:4dca:d3cb:8926:bf89)
[23:54:52] *** Quits: tyson2 (~user@72.142.96.152) (Quit: ERC (IRC client for Emacs 27.2))
