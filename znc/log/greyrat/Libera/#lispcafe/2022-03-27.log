[00:09:20] <MichaelRaskin> It would probably take less code to extend maxima to do whatever exotic things you want
[00:09:40] <MichaelRaskin> No promises about less learning curve though
[00:16:13] *** Quits: dra (~dra@2a04:4540:6422:4f00:6838:c833:a209:64c4) (Quit: Leaving)
[00:21:18] <selwyn> a lot of matrix calculus
[00:32:34] *** Quits: tyson2 (~user@cpe00fc8d34ff03-cm00fc8d34ff00.sdns.net.rogers.com) (Remote host closed the connection)
[00:39:36] *** Joins: tyson2 (~user@cpe00fc8d34ff03-cm00fc8d34ff00.sdns.net.rogers.com)
[01:05:16] *** Quits: random-nick (~random-ni@87.116.167.125) (Remote host closed the connection)
[01:05:45] <shka> lol@https://www.youtube.com/watch?v=Ism39fVM4Pw
[01:05:45] -ixelp- [ENG] ASL Season13 Ro.8 Day2 Action vs Light (Tastosis) - YouTube
[01:05:53] <shka> insanity 
[01:06:51] <MichaelRaskin> selwyn: hmm, depending on the detail Maxima might support most of your needs by itself
[01:13:41] *** Quits: rotateq (~user@p200300e787143500a6f16de1b1c2e823.dip0.t-ipconnect.de) (Quit: ERC (IRC client for Emacs 27.2))
[01:17:40] <shka> good night https://www.youtube.com/watch?v=WFEeYtNCQH4
[01:17:41] -ixelp- Madame Gdyby nie szerszenie - YouTube
[01:23:21] <selwyn> goodnight
[01:35:38] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[01:55:56] *** Quits: tyson2 (~user@cpe00fc8d34ff03-cm00fc8d34ff00.sdns.net.rogers.com) (Remote host closed the connection)
[02:26:11] <qhong> selwyn: what is the good idea of Mathematica?
[02:26:41] <qhong> I use Maxima for CAS and I know some mathematicians that also use it. I use it from Lisp like a normal Lisp package
[02:35:10] *** Joins: kevingal (~quassel@80.233.47.223)
[02:43:07] *** Joins: random-nick (~random-ni@87.116.167.125)
[02:43:36] <hayley> SAL9000: The best technique I know is escape _detection_, where you get feedback at runtime.
[02:44:36] <SAL9000> hayley: wait so you stack-allocate stuff and then move it onto the heap when you detect an escape? that is interesting although not sure if it'd fit $dayjob's architecture :(
[02:44:52] <hayley> Right.
[02:46:11] <SAL9000> I'm hoping to take aim at low-hanging fruit like the equivalent of { std::stringstream s; s << "xyz" << "zzy"; return s.str(); } -- except that our language currently heap allocates the 'stringstream' itself too.
[02:46:48] <hayley> Well, I think Bike might have something to say about it for Clasp...he mentioned some data flow analysis for it once.
[02:46:58] <moon-child> stack allocating dynamic buffers is hairy
[02:47:11] <moon-child> can do it, ofc
[02:47:16] <hayley> Or this <https://faculty.cc.gatech.edu/~harrold/6340/cs6340_fall2009/Readings/choi99escape.pdf> on Java?
[02:47:19] <SAL9000> the buffers would be step two... step one would be stack allocating the wrapper object, at least
[02:47:20] <moon-child> but need to ditch stack size limits
[02:47:29] <hayley> moon-child: haha lazy allocation goes brr
[02:47:32] *** Quits: Inline (~Inline@p200300cd472cf8009bb7e46c1da712cc.dip0.t-ipconnect.de) (Quit: Leaving)
[02:47:53] <hayley> Right, the trick is to promote from stack to heap if the stack gets large. (Not kidding.)
[02:48:21] <SAL9000> I'm open to adding something like LLVM's tinyvec (or whatever it was called)
[02:48:42] <hayley> The one where you can put a small vector on the stack, and larger are heap allocated?
[02:48:44] <SAL9000> iirc it basically has a fixed-size buffer which moves onto the heap when limit is exceeded, thing itself is meant to be stack-only, etc.
[02:48:46] <SAL9000> yeah
[02:49:38] <hayley> But at the moment, I have my eye on escape detection. The problem, though, is how to decide if stack allocation is worthwhile though, based on feedback.
[02:50:40] <SAL9000> how does that look like, anyway? instrumenting writes?
[02:50:49] <SAL9000> (escape detection, I mean)
[02:51:29] <hayley> Right. Then, if the write threatens to leave a dangling pointer, you copy from stack to heap, and the only pointers to that object will be in newer stack frames, so you just fix up those.
[02:52:02] <SAL9000> sounds like that'd only work if you have exact stack scanning (which we don't)
[02:52:06] *** Joins: Inline (~Inline@p200300cd472cf8009bb7e46c1da712cc.dip0.t-ipconnect.de)
[02:52:11] <hayley> ):
[02:52:25] <moon-child> :<
[02:52:33] <SAL9000> custom-lang stack frames are allowed to intermix natively with C/C++ stack frames
[02:52:55] <SAL9000> so stack scan must be ambiguous
[02:53:04] <hayley> But practically I guess you want to avoid repeated traps, so you will also allow for some feedback. Give each stack-allocated object an ID for where it was allocated, and flip a bit for the ID if it escapes. Then, when allocating another object, check if the bit is set. If so, allocate directly into the heap instead.
[02:53:07] *** Quits: shka (~herr@109.231.3.55) (Ping timeout: 260 seconds)
[02:53:46] <selwyn> qhong: well, the idea of having a cas that can also do numerics is a good idea, since there are many occasions where one wants to do both
[02:53:51] <moon-child> only 1 bit?
[02:54:12] <SAL9000> maybe a silly thought... what if you flip the problem on its head? basically do the tracing-JIT thing but for stack vs heap.
[02:54:24] <hayley> You can do it after multiple escapes, but in the literature one usually suffices.
[02:54:32] <SAL9000> default to heap alloc, track all (or candidate) allocations with source info of some kind
[02:54:42] <selwyn> i know several physicists who believe that mathematica is the first and only cas
[02:55:08] <SAL9000> if you DON'T see a given source location in GC heap after X time, add that source location to "to be recompiled" list and then run the more expensive analysis passes
[02:55:27] * hayley uploaded an image: (58KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/OHXhNSLmAuYgryFQVVlcRVuK/Screenshot%20from%202022-03-27%2009-25-17.png >
[02:55:41] <SAL9000> :D
[02:56:43] <drakonis> https://news.ycombinator.com/item?id=30811592
[02:56:44] -ixelp- Why we need Lisp machines | Hacker News
[02:56:45] <drakonis> this post...
[02:57:46] <hayley> We don't need the machine, but we do need the OS (or lack thereof, c.f. Ingalls) 
[02:57:58] <SAL9000> hayley: on a semi-related note, https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/
[02:57:58] -ixelp- Department of Computer Science and Technology: Capability Hardware Enhanced RISC Instructions (CHERI)
[02:58:19] <SAL9000> tl;dr "let's make 128-bit pointers which are actually a 64-bit pointer + cap"
[02:58:23] <drakonis> cheri is good shit.
[02:58:28] <hayley> SAL9000: Yes, why do C people get hardware acceleration for making their crap software safe?
[02:58:29] <drakonis> and its on arm now
[02:58:31] <SAL9000> (presumably the cap stores size info or whatever, dunno the details)
[02:58:45] <drakonis> these people hate C
[02:59:09] <drakonis> https://news.ycombinator.com/item?id=30800520and the perennial hn post shitting on lisp
[02:59:09] <SAL9000> hayley: because we're stuck with C for the forseeable future? and it's not like other languages don't have compiler/gc errors...
[02:59:16] <drakonis> https://news.ycombinator.com/item?id=30800520
[02:59:17] -ixelp- The Lisp Curse (2017) | Hacker News
[02:59:34] <hayley> Real Redemption Arc hours
[02:59:45] <hayley> And IIRC the article actually dates to 2011. Congratulations!
[03:00:11] <SAL9000> otoh, CHERI is going to kill all the C code which assumes sizeof(ptrdiff_t) == sizeof(void*)
[03:00:19] <drakonis> its funny that it keeps getting reposted in hn
[03:00:35] <drakonis> at least once a year since its original date
[03:00:49] <drakonis> the author is even mad that people keep reposting it
[03:01:28] <hayley> I'll give brownie points if someone posts https://applied-langua.ge/posts/lisp-curse-redemption-arc.html I guess
[03:01:28] -ixelp- The Lisp "Curse" Redemption Arc, or How I Learned To Stop Worrying And Love The CONS
[03:02:38] <selwyn> i wonder how much anti lisp sentiment is due to cope by people who try to justify why they don't use the 'super-smart' paul graham language
[03:03:25] <drakonis> paul graham was after all, a blight on the community
[03:03:48] <drakonis> also, most of the sentiment also comes from the community being hostile to everyone else
[03:05:01] <drakonis> during the height of the language's community a couple decades ago
[03:05:33] <drakonis> it has a way with coloring perception
[03:06:43] <drakonis> lispers looking down on everyone else for not using their ultimate language
[03:06:47] <drakonis> even on schemers
[03:06:49] <hayley> Yes.
[03:10:53] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-08-70-29-36-27.dsl.bell.ca)
[03:12:00] <drakonis> a raw deal, innit.
[03:13:22] <selwyn> why look down on scheme ._.
[03:13:42] <drakonis> because it didnt meet some kind of arbitrary standard of purity in the eyes of lispers
[03:14:21] *** Joins: Inline__ (~Inline@p4fedbe8f.dip0.t-ipconnect.de)
[03:14:35] <hayley> OTOH I dislike Scheme because most implementations aren't interactive enough.
[03:15:05] *** Quits: Inline (~Inline@p200300cd472cf8009bb7e46c1da712cc.dip0.t-ipconnect.de) (Ping timeout: 252 seconds)
[03:15:22] <drakonis> that's a bit of a complex matter i would say
[03:20:36] <selwyn> the tooling doesn't seem amazing
[03:22:16] <drakonis> oh, yeah, sure.
[03:22:31] <drakonis> it is kinda hard to have amazing tooling when you have a dozen active implementations
[03:23:06] <drakonis> and the spec isnt broad enough to have common lisp grade interactivity
[03:23:29] <drakonis> (might change in the near future now that r7rs-large is actually moving forward, at last)
[03:24:31] <drakonis> but the heavy lifting has to be done by the implementations
[03:24:36] *** Quits: kevingal (~quassel@80.233.47.223) (Ping timeout: 240 seconds)
[03:24:40] <sham1> Yeah. Schemes don't really have the same interactive development culture of CL, indeed many don't even do image-based program stuff. Although MIT/GNU Scheme is good with that, although outside of Geiser one somewhat struggles to find something similar to SLIME, one must admit
[03:25:13] <drakonis> scheme does not have something like sbcl, sadly.
[03:25:34] <drakonis> as much as guile exists, it doesn't get anywhere as much active attention as sbcl does
[03:25:39] <sham1> Chez is close
[03:25:52] <qhong> selwyn: sure. I think my Lisp with both GSLL and maxima loaded is close, but maybe less handy integration between the both
[03:25:54] <sham1> Although that's also R6RS and that's somewhat divisive
[03:26:11] <sham1> And I'm not sure about what Cisco is doing with it nowadays, if anything
[03:26:22] <selwyn> exactly
[03:26:35] <drakonis> nothing, really.
[03:26:54] <drakonis> i think the racket folks have done more work on their branch than mainline has received since opening up
[03:27:18] <sham1> Most probably
[03:27:33] <qhong> moon-child: I find that F-expr has the unintended application of making a nice SETF system. Does s7 propagate changes into Y in sth like (setf (proc1-with-setter x (proc2-with-setter y)) z)?
[03:28:08] <qhong> sham1: MIT/GNU Scheme best scheme. r0rs best rnrs.
[03:28:29] <sham1> Meh, MIT/GNU has received many a R7 feature
[03:28:31] <drakonis> ha
[03:28:58] <drakonis> mit scheme is the one that has a feature set closest to common lisp
[03:29:31] <sham1> Also being the implementation on which one would do SICP stuff on is also an interesting factor
[03:29:40] <moon-child> qhong: I don't follow.  Why would it matter if proc2 has a setter?
[03:30:05] <qhong> moon-child: (setf (car (cdr x)) 3)
[03:30:07] <moon-child> e.g. (setf (car (cdr x)) y).  Here we don't need a (setf cdr), only a (setf car)
[03:30:12] <moon-child> yes, exactly
[03:30:30] <qhong> oops, let me find another
[03:30:45] <qhong> basically any case that you would write a DEFINE-SETF-EXPANDER rather than #'(SETF FUNC)
[03:31:33] <moon-child> afaik the way it works is that values have setters, not functions
[03:31:57] <moon-child> but I'm not sure of the details.  E.g. (let ((x (car y))) (set! x 7)) does _not_ do the same as (set! (car y) 7)
[03:32:49] <drakonis> https://www.codesections.com/blog/raku-lisp-impression/ this is a post alright
[03:32:50] -ixelp- Raku's surprisingly good Lisp impression | CodeSections
[03:33:19] <drakonis> https://codeberg.org/scheme/r7rs/issues
[03:33:20] -ixelp- Issues - r7rs - Codeberg.org
[03:33:31] <drakonis> r7rs-large, its going to happen in my lifetime
[03:33:38] <drakonis> it should be a tagline lol
[03:33:47] <qhong> moon-child: I think it only has procedure setter, or setter _into_ a value (like vector or hash-table), basically equivalent to a procedure setter
[03:33:53] <drakonis> https://codeberg.org/scheme/r7rs/issues/64 restarts heyooo
[03:33:53] -ixelp- #64 - Restartable conditions - r7rs - Codeberg.org
[03:34:16] <qhong> moon-child: but I think that is probably suffice. My feeling that one sometimes need a setter to have unevaluated argument is probably an illusion
[03:37:17] <qhong> moon-child: uh, maybe it's needed when creating some non-existent element
[03:37:44] <sham1> drakonis: Raku certainly has the tools for customisable syntax and macros alright. It's just very convoluted like the rest of the Perl family
[03:38:05] <qhong> moon-child: e.g. (setf (assoc-value 2 (assoc-value 1 y)) 3), but Y is just NIL
[03:38:08] <drakonis> convoluted?
[03:38:14] <drakonis> probably a lot less than perl though
[03:38:18] <drakonis> from my experience
[03:39:02] <moon-child> qhong: I see
[03:39:35] <moon-child> qhong: raku does that (it calls it 'auto-vivification' iirc)
[03:39:39] <qhong> moon-child: but I'm not sure if that's foundamental, or just some Lisps conflating no value (NIL) with some empty alist/plist 
[03:39:55] <moon-child> I mean, it clearly doesn't work for hash tables
[03:40:35] <moon-child> so I think 'conflating' is right
[03:40:57] <moon-child> I'm not sure if there's a general solution that's cleaner than raku auto-vivification, and would feel ok about not having a solution
[03:41:00] <qhong> moon-child: does Raku do it right? does it work for nested non-existent accesses?
[03:41:17] <moon-child> yes
[03:41:34] <moon-child> http://ix.io/3TyX
[03:42:32] <qhong> moon-child: I think F-expr solves it. When receiving a argument (outer (inner . args)), outer evaluate inner first, check if it has a setter, and then apply it to the arguments
[03:43:09] <moon-child> I'm not sure.  But I have low blood sugar so may not be thinking quite straight.  I'ma go eat something
[03:43:38] <qhong> moon-child: sure, ttyl
[04:04:29] * hayley reads next class worksheet
[04:04:32] <hayley> "All recursive functions can be unwound. How would you implement an iterative tree traversal?" Tail recursion?
[04:04:46] <hayley> A work-list also works, if the function is not tail recursive.
[04:04:59] <hayley> Or continuation-passing style.
[04:06:15] *** Quits: Posterdati (~posterdat@user/Posterdati) (Quit: KVIrc 5.0.0 Aria http://www.kvirc.net/)
[04:06:26] <sham1> "All recursive functions can be unwound." Indeed, if by nothing else than by having an explicit stack of work
[04:06:59] <hayley> The other question IMO is if you want to.
[04:08:31] <hayley> "When bad programs happen to bad people: the sequel"
[04:08:49] <kakuhen> my flac decoder is cursed
[04:08:54] <sham1> Recursion often leads to neat ways of expressing the problem. Although if it requires an explicit stack, a lot of the elegance is just thrown out of the window
[04:09:00] <kakuhen> friend optimized a bit of the bit-reader, so we now process entire files about 2.5x faster
[04:09:09] <kakuhen> but (optimize (speed 3)) makes the decoder marginally slower compared to (optimize (speed 1))
[04:09:13] <hayley> "The usual whiners will complain that `recursion is less efficient than iteration,' because it requires (among other things) the stacking/unstacking of O(log(max(|m|,|n|))) stack frames. But since this gcd algorithm is tail-recursive--meaning that the value of the recursively-called subroutine is returned as the value of the routine itself--no stack frames need to be stacked, and this program is iterative. Compilers which can't compile this loop
[04:09:13] <hayley> iteratively are broken."
[04:09:38] <kakuhen> 2.3s to decode 1000 frames with sbcl defaults, and optimizing speed makes it 2.5s
[04:09:50] <hayley> kakuhen: SPEED does literally nothing for one-more-re-nightmare. So much so, that I diddle internal SBCL variables to make it do even less constraint propagation than (SPEED 0).
[04:10:30] <drakonis> sham1: to be fair, code is as readable as you make it
[04:10:51] <drakonis> there are people that treat programming like code golf, such as the perl folks
[04:11:22] * lagash shudders
[04:11:56] <drakonis> in most cases, it is cultural among the perl community
[04:12:15] <drakonis> doesn't seem to be as much of a problem among raku, yet.
[04:12:28] <drakonis> i imagine it will be once it grows more
[04:13:18] <drakonis> but like they say, there's always more than one way to skin a cat
[04:13:34] <sham1> Once Perl 5 people migrate over like a flock of birds
[04:13:44] <drakonis> ha, i'd be surprised if that happened
[04:16:14] <kakuhen> <hayley> "kakuhen: SPEED does literally..." <- that sounds amazing
[04:16:37] <kakuhen> unfortunately i want to keep my code portable, so I keep sbcl hacks to a minimum
[04:16:39] <hayley> https://github.com/telekons/one-more-re-nightmare/blob/master/Code/Compiler/optimize-settings.lisp
[04:16:40] -ixelp- one-more-re-nightmare/optimize-settings.lisp at master · telekons/one-more-re-nightmare · GitHub
[04:16:48] <kakuhen> i realized sbcl is the only implementation that is strict about the semantics of defconstant
[04:16:55] *** Quits: White_Flame (~quassel@user/white-flame/x-6930243) (Remote host closed the connection)
[04:16:58] <kakuhen> so i had to make my own macro to take care of that
[04:17:08] <kakuhen> otherwise quickloading my project would constantly complain about defconstant redefining a constant with... the same value
[04:17:14] <drakonis> the perl community seems like a real stickler for stability
[04:17:36] <drakonis> there's some folks that are getting pretty mad about the current perl maintainers changing things
[04:17:53] <drakonis> breaking changes even
[04:18:08] *** Joins: White_Flame (~quassel@user/white-flame/x-6930243)
[04:18:20] * kakuhen uploaded an image: (153KiB) < https://libera.ems.host/_matrix/media/r0/download/kotoura.moe/LCXBdOSaWCCjXwsSBvbfKiXr/image.png >
[04:18:25] <kakuhen> i now have this because i am too stubborn to pull in any dependency
[04:18:36] <kakuhen> even though it seems most lispers are fine with alexandria:only-once
[04:19:15] <kakuhen> the very last constant is problematic and compile+load will make some equality test fail and sbcl will signal error about redefining constants
[04:19:30] <kakuhen> other implementations will fail silently and assume you know what you mean
[04:19:42] *** Joins: Posterdati (~posterdat@user/Posterdati)
[04:20:36] <kakuhen> thankfully top-level macrolet is still considered a top-level form, so i can get away with doing this to implement a "file-local macro" (all of my constants are in this file)
[04:22:23] <kakuhen> in any case, i can somewhat sb-sprof output now
[04:22:37] <kakuhen> 83.8% of my time is spent on a read syscall apparently lol
[04:23:14] <kakuhen> the next heavy function is, you guessed it, the LPC function
[04:52:37] *** Joins: Oddity (~Oddity@user/oddity)
[04:58:05] <moon-child> qhong: ok, so
[04:58:15] <moon-child> I can say (incf (gethash k ht 0))
[04:58:22] <moon-child> suppose I wanted to be able to leave out the 0
[04:58:40] <moon-child> if that worked, it would work only because incf 'wants' a number, and there is a neutral number for the purposes of incrementing: 0
[04:59:22] <moon-child> what about (setf (gethash x (gethash y ht)) z)?  If that works, it works only because the outer gethash 'wants' a hash table, so it materializes one from the inner gethash
[04:59:33] <moon-child> but what happens if the outer gethash is a generic function?  Now it doesn't know what it wants
[04:59:46] <moon-child> and in fact, this problem exists already: what kind of hash table do you want?  CL has 4
[05:00:15] <moon-child> with just generic funtions, I can _imagine_ a solution to this (though not a good one, or a general one).  But as you are prototype-based, I don't think you can fix it
[05:22:39] *** Quits: random-nick (~random-ni@87.116.167.125) (Ping timeout: 256 seconds)
[05:34:49] *** Quits: molson (~molson@172-103-21-94-dynamic.midco.net) (Remote host closed the connection)
[05:35:18] *** Joins: molson (~molson@172-103-21-94-dynamic.midco.net)
[06:03:43] *** Joins: razetime (~quassel@117.254.34.143)
[06:27:48] *** Joins: Inline (~Inline@p200300cd473c9e009f1d7d6dc4a648e3.dip0.t-ipconnect.de)
[06:30:35] *** Quits: Inline__ (~Inline@p4fedbe8f.dip0.t-ipconnect.de) (Ping timeout: 260 seconds)
[06:55:13] *** Joins: lisp123 (~lisp123@143.238.164.103)
[06:56:12] *** Quits: razetime (~quassel@117.254.34.143) (Ping timeout: 240 seconds)
[06:56:56] *** Joins: razetime (~quassel@117.254.34.170)
[07:10:06] <gilberth> Why are relocatable object file formats not more generic? I mean, at the end of day a fixup could be just an expression, couldn't it? Instead every architecture has its own set of relocation types. Mostly for somehow sticking offsets into some instruction. Also you don't really need the concept of a data stream and then some fixups. Just have a sequence of expressions that evaluate to octets.
[07:10:17] <gilberth> These expressions could be any combinaton of a constant, the current relocation position, some symbol, one of the operators +, -, *, FLOOR, MOO, LDB, DPB, ASH. I believe that should cover it.
[07:11:01] <moon-child> I wondered this recently
[07:11:19] <gilberth> You did? Wanna co-author a spec?
[07:12:18] <moon-child> my assembler handles arbitrary expressions as relocations, so I figured, once I make it a linker too, it will do that for free
[07:12:29] <moon-child> gilberth: hmm, maybe.  It seems like a bit of a fringe thing
[07:12:44] <GreaseMonkey> honestly it would turn a lot of fringes into one
[07:13:13] <GreaseMonkey> IIRC ARM is an absolute shocker for having eleventy-billion different relocation types of which many are redundant in practice
[07:13:31] <moon-child> some risc architectures have a complicated format for immediates and displacements.  So just permitting arbitrary expressions doesn't save you
[07:13:35] <gilberth> Yep, my B32 assembler works that way. It's in Lisp and the output is just that kind of sequence of expression. atm I am at my 8080 assembler. I always wondered why relocation formats are not that way. It would be great when I could have just one universal linker.
[07:15:25] <gilberth> Well, I can see the historic context. Look at the a.out format. It's just loaded as is into the address space. The a.out object file format is just that plus a list of relocations/fixups. Those machines were tiny and slow. But I believe we could move past that.
[07:15:26] <GreaseMonkey> for the more complicated formats, a lot of it can be resolved by, uhh, avoiding them, or possibly having some sort of conditional
[07:15:28] <drakonis> https://www.youtube.com/watch?v=RhtiDYLbfF4
[07:15:28] -ixelp- How to Pick Up a Duck - YouTube
[07:15:34] <moon-child> hmm actually, add == and you're golden
[07:15:45] <moon-child> well, == and <
[07:15:48] <moon-child> do the actual encoding as part of the expression
[07:16:00] <moon-child> and conditionals are C*T + (1-C)*F
[07:16:28] <gilberth> When I want to be C friendly. I could spec a kind of postfix notation for the relocation expressions.
[07:17:03] <waleee> drakonis: that was one unaturally docile duck
[07:17:11] <gilberth> I also want alignment "instructions".
[07:17:23] <moon-child> in the object file?
[07:17:36] <moon-child> hmmmmm
[07:17:49] <moon-child> usually the assembler does that
[07:17:52] <GreaseMonkey> having done stuff with Thumb-1, you do need to deal with the program counter having some alignment applied to it
[07:17:56] <waleee> in reality you'd make sure to grab it over the wings so it doesn't flap like crazy
[07:18:00] <gilberth> Yes, when I say it's a strem of expressions producing bytes. There could be an instructions saying "Please align here".
[07:18:50] <moon-child> you may have an option between a large instruction and a small one.  And this has interplay with alignment directives
[07:19:09] <moon-child> if you don't have varying instruction sizes in your object file, then you can do all the aligning you need to in the assembler
[07:19:15] <GreaseMonkey> i suspect a lot of it wouldn't even need such a VM, as a lot of it follows the pattern of "here's the input range and granularity, and you have to split things across these bits to be output"
[07:19:52] <GreaseMonkey> although at least knowing whether to add or subtract certain expected inputs is going to be useful
[07:20:06] <GreaseMonkey> which of course includes the address of the thing
[07:20:45] <gilberth> moon-child: Are you talking about relative versus absolute jumps? Different operand sizes? Do linkers actually handle that?
[07:20:47] <GreaseMonkey> i wonder what it would take to find a list of every relocation type used in ELF ever
[07:21:11] <moon-child> gilberth: yes, different operand sizes.  Linkers don't handle that, and I think that's fine
[07:21:18] <gilberth> GreaseMonkey: binutils should cover it all.
[07:21:20] <GreaseMonkey> and as far as i know, linkers generally work with the jump size you give it and complain if you were too kind
[07:21:22] <moon-child> if you don't make the linker handle that, then there's no reason to add alignment directives
[07:21:33] <GreaseMonkey> erm, s/kind/optimistic/
[07:22:36] <gilberth> Ok. I'll prepare coffee and do some thinking and research. For once an ELF->fully-generic-object-file-format and back would be nice to have :-)
[07:22:37] <GreaseMonkey> you may still need to be able to do "take the current address and align it to this boundary"
[07:23:21] <moon-child> agreed
[07:23:29] <moon-child> I wonder why no existing linkers can do this
[07:23:52] <drakonis> waleee: indeed.
[07:24:25] <qhong> moon-child: I do have generic function. I think I found a way to blend prototype and multiple dispatch very nicely (basically by currying a multimethod into a chain of single method).
[07:24:35] <gilberth> GreaseMonkey: What do you mean by "align it". Would it change size, or just compute (* n (ceiling *current-relocation-pointer* n))?
[07:24:44] <moon-child> GreaseMonkey: the way current formats work is you specify an alignment for the entire section
[07:24:46] <GreaseMonkey> gilberth: something like the latter
[07:24:47] <qhong> moon-child: As for 4 hash table issue, I think the problem comes from that CL doesn't have a good equality predicate
[07:25:13] <qhong> moon-child: One single universal equality predicate is possible with good mutability management, as in _Equal Rights for Functional Objects_
[07:25:36] <moon-child> GreaseMonkey: and then they add padding if necessary to maintain that alignment when linking together multiple sections
[07:25:50] <moon-child> adding intra-sectional padding is problematic because the assembler will apply some of its own relocations ahead of time
[07:26:24] <GreaseMonkey> moon-child: this isn't about aligning the address that you're trying to hit, this is about PC-relative addressing on CPUs where "PC" in this case actually means "PC aligned to a 4-byte boundary maybe with some weird offset", such as ARM in Thumb mode
[07:26:30] <gilberth> So what do we need? I offer +, -, *, floor, ceiling, mod, rem, ash, ldb, dpb, boole, sign-extend, <, >, <=, >=, =, /=, if.
[07:27:10] <moon-child> ldb is redundant given boole and ash
[07:27:26] <GreaseMonkey> i'm not sure what the required function set is going to be, but i will recommend having a table of these functions and then using indices into the table on the actual lookup data
[07:27:33] <hayley> qhong: Except for when it's not. Like when you might want a case-sensitive string equality, or case-insensitive. Or any time you give :KEY to a sequence function.  
[07:27:50] <hayley> There are equivalence relations that aren't "do these print the same". 
[07:28:18] <moon-child> similarly if is redundant, as are all the comparators except <, <=, and =.  Technically you can get awway with _just_ <= or <, but having a bigger set is nice
[07:28:27] <moon-child> also should add round
[07:28:40] <moon-child> though round and ceiling can be faked given floor
[07:29:17] <qhong> hayley: sure, in those cases supply your own 2-argument predicate. But I think EGAL can deal with most cases when you use EQ EQL EQUAL EQUALP in CL, thus making hashtable autovivification more useful
[07:29:52] <gilberth> moon-child: Sure. Are you after a minimum set? When you're done, you speced a OISC machine :-p
[07:30:42] <moon-child> qhong: I think you missed the point.  The problem is not whether gethash is a generic function; the question is how do you do autovivification that some functions _are_ generic?
[07:31:57] <moon-child> *given that some ...
[07:32:03] <qhong> moon-child: hmm. That seems to be a general problem about "how F-expr and generic function play together"
[07:32:20] <moon-child> gilberth: I'm assuming this is not going to be written by hand.  A smaller instruction set may be space-advantageous
[07:32:43] <moon-child> you have 19 instructions; if we get rid of a couple, every instruction can be written in 4 bits
[07:32:44] <GreaseMonkey> ...uh, i may have worded what i said badly... if we call a lookup function built out of all the builtin functions a "program", we should have a table of programs, and then the lookups would be defined using an index to each program
[07:32:51] <qhong> I thought about it. I think it is doable, basically a prefix of the arguments should decide whether to evaluate the next argument, or not. But I doubt the usability
[07:33:35] <gilberth> moon-child: You imagine a bit-stream encoding? I won't be bothered by space. Bandwidth is plenty these days.
[07:33:42] <qhong> so currently my plan is to use generic function only for applicatives (normal functions)
[07:33:54] <hayley> When in doubt, put your data on tapes on a truck on the highway.
[07:34:20] <GreaseMonkey> fun fact, Google Tape is an internal Google service that they actually have needed to use on a few occasions to restore data
[07:34:39] <moon-child> gilberth: fair enough
[07:34:39] <GreaseMonkey> ...oh dear, i'm starting to see this become a generic data processing program system
[07:34:53] <moon-child> .oO( let's specify all of cl as an intermediate language for expressing relocations )
[07:35:21] <qhong> That is a pattern. Whenever you start to make a separate DSL.
[07:35:34] <GreaseMonkey> let's not be silly, we should stay minimalistic and use R6RS
[07:35:50] <qhong> r6rs sucks. please r0rs
[07:36:11] <hayley> r-1rs
[07:36:23] <moon-child> r69rs
[07:36:24] <GreaseMonkey> forth
[07:36:26] <gilberth> BTW the CP/M-80 .REL file format is a bit stream. But we moved past floppy disks and less than 64KB of RAM.
[07:36:31] <hayley> r3rcl
[07:36:57] <gilberth> SDCC uses an ASCII format rather. Still not generic, but kinda nice.
[07:40:40] <qhong> let's not be silly, we should stay minimalistic and use Conway's Game of Life
[07:41:32] <GreaseMonkey> i'm ok with whatever as long as we steer clear of anything remotely resembling lambda calculus
[07:42:09] <hayley> What part of \t.\f.f do you not understand?
[07:42:30] <qhong> :o it's a lisp channel isn't it
[07:42:46] <GreaseMonkey> yeah, that's why i made that joke
[07:43:00] <hayley> At least lambda calculus lets you be modular.
[07:43:03] <gilberth> What I also miss is specifying an end address of a section instead of a start address. At times you want to allocate some segment so that it ends at some specific address.
[07:43:48] <moon-child> I never wanted that.  But I have wanted to get the difference between two symbols at times
[07:44:01] *** Quits: lisp123 (~lisp123@143.238.164.103) (Remote host closed the connection)
[07:44:05] <gilberth> What about stacks? Think embedded systems.
[07:44:52] <gilberth> But that would be rather a part of a linker script.
[07:44:57] <moon-child> what's the problem, there?
[07:45:09] <gilberth> Stacks grow downwards.
[07:45:14] <moon-child> don't you usually say the program is loaded into the bottom half of memory, and the stack pointer is set to the top of memory?
[07:45:27] <moon-child> then, why would you need a dedicated section?
[07:45:33] <GreaseMonkey> another thing that would be useful as far as alignments go (yeah this point isn't really about relocation fixups i don't think) is having something where you don't care where it is in a 256-byte block, as long as it's fully contained within there
[07:45:35] <gilberth> What if I want to have more than one stack?
[07:46:04] <moon-child> hmmm
[07:46:15] <gilberth> GreaseMonkey: Indeed! Good point. That would have been very useful in my former life.
[07:46:27] <GreaseMonkey> well, there's always that one guy who makes a stack grow upwards
[07:46:37] <GreaseMonkey> ...ok, not really always, but i'm pretty sure people have done that
[07:46:51] <moon-child> some cpus have up-growing stacks
[07:46:51] <hayley> IIRC Multics had the stack grow away from the heap.
[07:47:00] <hayley> Though, that is independent of up or down.
[07:47:06] <gilberth> GreaseMonkey: I can't change the way the CALL and RET instructions work. :-)
[07:47:53] <GreaseMonkey> ...i was about to say "well you could use JP (HL)" but then there's still PUSH/POP, and SP-relative access on a Z80 is an absolute bastard of a thing
[07:48:09] <gilberth> But this "please make sure I don't cross a 256 byte boundary from here to there, thanks." is very useful. I really missed that at times.
[07:48:34] <GreaseMonkey> hmm, i actually wonder if WLA-DX has a facility for that
[07:48:45] <gilberth> GreaseMonkey: There is no stack relative addressing with the 8080 to begin with.
[07:49:11] <GreaseMonkey> i guess on the Z80, you can at least make use of copying SP to IX or IY
[07:49:29] <qhong> Question for Lisp-1 users: are you happy with writing lst, cns, %car and %cdr? I think it's rather suboptimal, especially when in the argument list because it makes inspection information confusing.
[07:49:38] <GreaseMonkey> copying? i mean clearing the register then doing e.g. `ADD IX, SP`
[07:49:38] <qhong> Should there by a construct to access shadowed bindings?
[07:49:52] <gilberth> You would need to say. LXI H,off : DAD H : MOV A, M : INX H : MOV H, M : MOV L, A to have HL = (SP+off)
[07:49:55] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 260 seconds)
[07:49:57] <qhong> so (lambda (list) ((unshadow list) 1 list))
[07:50:14] <moon-child> s7 has that
[07:50:18] <qhong> (replace-string "Should there by" "Should there be")
[07:50:23] <qhong> moon-child: interesting.
[07:50:25] <moon-child> (lambda (list) (#_list 1 list))
[07:50:40] <moon-child> it has to be metasyntax, because otherwise you can shadow 'unshadow', and then you have no way to unshadow it
[07:51:12] <gilberth> s/DAD H/DAD SP/
[07:51:17] <qhong> moon-child: I think that's acceptable. Only one name you don't use, instead of lots of names
[07:51:22] <moon-child> otherwise, it's equivalent to (lambda (list) (((rootlet) 'list) 1 list))
[07:51:30] <GreaseMonkey> i guess you'd also need to make sure L was clear before running that op
[07:51:40] *** Joins: aeth (~aeth@user/aeth)
[07:51:51] <qhong> moon-child: s7 looks more and more interesting to me. Is the author still at CCRMA? CCRMA looks rather inactive in recent years
[07:51:56] <moon-child> (rootlet is a function which returns the global environment.  But obviously it can be shadowed)
[07:52:02] <GreaseMonkey> i never learnt the 8080 ops, admittedly even the 68000 was before my time, i just ended up learning a bunch of how to code homebrew for old game consoles
[07:52:15] <gilberth> The 8085 has undocumented instructions for stack relative addressing. I wonder why they are undocumented. Would have very useful for ALGOL^WPASCAL^WC
[07:52:23] <moon-child> qhong: 'still at ccrma' afaik yes.  He posts on the s7 mailing list semi-regularly about new snd releases
[07:53:02] <qhong> moon-child: great.
[07:53:03] <GreaseMonkey> dunno, might be because there was this CPU called the 8086 and they kinda wanted to sell that
[07:53:46] <GreaseMonkey> "oh, you want to do C on an 8085? no, you need a C CPU like this 8086"
[07:53:57] *** Joins: semz_ (~semz@user/semz)
[07:54:42] <gilberth> And those are actually SP relative. Like LD DE, (SP+n). Even the Z80 doesn't have that.
[07:55:04] <gilberth> Would have been a killer feature for C. Yet Intel decided to hide it.
[07:55:37] <gilberth> There also is LD DE, (HL+n).
[07:55:49] * hayley posts the operating systems comparison meme and is reminded she didn't make fun of Windows and macOS
[07:56:18] <hayley> "GNU, Linux, BSD, etc." "See, Windows is in etc."
[07:56:55] *** Quits: semz (~semz@user/semz) (Ping timeout: 260 seconds)
[07:57:41] <qhong> hayley: xd. I use to get annoyed at online polls that have a pocket option "etc."
[07:57:54] <GreaseMonkey> eh, i tend to refer to Windows as Win32 because of how tied down everything was to that due to, well, proprietary software
[07:57:56] <qhong> so I started a poll "what's your operating system?" options: 1. Emacs 2. etc
[07:58:29] * hayley uploaded an image: (135KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/HvWsgKeFYKCPzLTluyQVRLbL/os-comparison.png >
[08:00:05] <hayley> "im not certified for anything" "only certificate I got was an SSL one from let's encrypt"
[08:01:33] <hayley> But poking at Windows and macOS can be found on approximately everywhere else on the Internet, so I didn't bother to do some more.
[08:02:30] * moon-child hands hayley the unix haters handbook
[08:02:44] * hayley wears it as a hat
[08:03:26] <hayley> Yet OS X^W^WmacOS is FreeBSD + Mach, and Windows has WSL. So I'm relatively fine shoving them into the "etc." 
[08:04:51] <gilberth> I have no idea what so ever about debugging information and wonder what daemons lurks there.
[08:04:55] * hayley wonders if SB-EXT:STACK-ALLOCATED-P can be used for user-space lazy allocation. Probably not.
[08:05:50] <moon-child> gilberth: dwarf spec is there if you care to read it
[08:06:02] <moon-child> also stabs, though, which is simpler, but limited
[08:06:39] <gilberth> moon-child: Yes, I'll do some homework.
[08:06:48] <moon-child> why?
[08:06:51] <moon-child> that doesn't sound like fun :P
[08:07:02] * hayley notes that we are actually at about the right time for AMD to release the Ryzen 6900X
[08:07:08] <GreaseMonkey> nice
[08:07:23] <hayley> https://gadgetversus.com/processor/amd-ryzen-9-6900x-specs/ Rumours but still.
[08:07:24] -ixelp- AMD Ryzen 9 6900X Specs - GadgetVersus
[08:08:16] <hayley> My leaked image from Computex 2019 said that the 6900X would be the first 7nm Lisp machine.
[08:08:27] <gilberth> moon-child: Because atm I ponder if I could come up with something which could cover what is actually used. I am done when I could convert back and forth to ELF and could have a replacement linker.
[08:08:29] * hayley uploaded an image: (108KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/NGcviwWoENUkdQDFimoIPxJL/symbolics-ryzen.jpeg >
[08:09:12] <moon-child> gilberth: stabs may be sufficient.  I suggest taking a look at it first, at any rate
[08:09:19] <moon-child> gdb supports it still
[08:09:59] <gilberth> Well, I have no idea what a linker does to that information. Is it a concern at all? idk
[08:10:48] <moon-child> afaik it is completely transparent to the linker
[08:11:04] <moon-child> it's just data dumped into a section, with no PT_LOAD
[08:15:02] <clothespin> I'm going to throw caution to the wind
[08:15:37] <clothespin> I'm using a C++ library with assertions that essentially crash my program when triggered
[08:16:03] <clothespin> I'm going to redefine the assertion macro to something less final
[08:16:36] <clothespin> so the worse thing that could happen is I could get a gobbledegook ui
[08:17:31] * hayley uploaded an image: (241KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/qCiWTrEmoUVZMEhRVUnAkstC/faa-committee.jpeg >
[08:17:41] <clothespin> do C++ people really tolerate starting and restarting the software they are developing all the time?
[08:17:58] <hayley> Your program is broken if it trips asserts. But yes.
[08:18:20] <clothespin> its broken if its not done
[08:18:47] <clothespin> not done software is the life of a software engineer
[08:21:56] <gilberth> Also this should work, I believe: cat foo.o bar.o > baz.o ; ld -o baz baz.o
[08:22:28] <moon-child>  why?
[08:22:37] <moon-child> I mean, you can say ld -r -o baz.o foo.o bar.o
[08:22:37] <hayley> It works for mp3s.
[08:22:43] <moon-child> also ar
[08:22:58] <gilberth> Because when I say a relocatable file is a stream of instructions, it should. It does with fasl files, for instance.
[08:23:48] <moon-child> ok, but clearly there is metadata; it expresses a stream, but obviously it is not _just_ a stream
[08:24:15] <moon-child> 'fasl'  interesting, on which implementations?
[08:25:20] <moon-child> (and this notion that nearly everything is a pipe is one of the problems with unix, precisely for this reason)
[08:25:30] <hayley> https://github.com/clasp-developers/clasp/releases/tag/1.0.0
[08:25:31] -ixelp- Release Clasp v1.0.0 · clasp-developers/clasp · GitHub
[08:25:46] <gilberth> moon-child: Which every I encountered so far.
[08:26:19] <moon-child> hayley: ha, good timing?
[08:26:32] <gilberth> The idea that I can mmap a binary and just make the CPU execute it, is so very 70s.
[08:27:33] <moon-child> afaik the reason linkers were separate from assemblers, originally, was memory use
[08:27:38] <gilberth> It made sense at that time as you could directly swap the text segment in and out from the binary.
[08:28:05] <moon-child> today I have enough memory to hold the entire contents of /bin and /lib at once
[08:29:20] <gilberth> moon-child: Yes. An compile time. In theory a C compiler could read and compile all the sources including libraries at once. No linking involved. But still space, see dynamic libraries.
[08:29:46] <moon-child> did we not just establish that space is cheap?
[08:30:02] <moon-child> the reason to have shared libraries is so that a program can link against libfoo version n, and I can easily swap out version n+1
[08:30:43] <gilberth> Yeah, that is a very mild benefit. Another benefit is that vendors could ship binary versions of their libs only.
[08:31:05] <moon-child> they could as easily ship static libraries
[08:31:13] <gilberth> And I doubt that of the 12GB or so my Firefox eats, a lot is shared anyway :-)
[08:31:15] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 272 seconds)
[08:31:32] <moon-child> indeed
[08:31:56] <gilberth> moon-child: Well, I said the compiler could see the complete source. In theory.
[08:32:13] <moon-child> 'lto'
[08:32:45] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[08:33:05] <gilberth> moon-child: Anyhow. Im principle I should be able to turn an .o file into an .s file, with lots of .byte, .word, ... in it shouldn't I? That already is a relocatable file format of sorts. And I could cat these.
[08:33:44] <moon-child> sure
[08:33:47] <gilberth> So in theory you could make it so that 'ld' is an alias for 'cat'. :-)
[08:34:08] <moon-child> but there the information is in-band.  In elf it is out-of-band.  (More or less.)
[08:34:38] <gilberth> Yes, the "we just mmap the binary and jump right at it' idea.
[08:34:43] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 260 seconds)
[08:35:19] <gilberth> a.out works that way. And a.out .o files are just a.out files plus a list of relocation fixups of the binary given.
[08:35:26] *** Joins: lisp123 (~lisp123@143.238.164.103)
[08:36:18] <gilberth> I still could do it that way. But I see no reason why I can't make it so, that you actually could cat those files.
[08:36:33] *** Joins: aeth (~aeth@user/aeth)
[08:37:06] <moon-child>  yes, there's no reason you couldn't.  I just don't really see the point
[08:37:13] <moon-child> but then, I don't really see the point of 'files' either, so
[08:38:21] <gilberth> I love my files. And, yes, I see files as streams. There isn't much difference to networking actually. A file transports data in time, while a network protocol transports data in space.
[08:39:42] <gilberth> And files are useful for exactly that. I could copy files. I could send them across a network. I could stash them.
[08:40:00] <moon-child> I do not want to have to write serialisation code
[08:40:21] <moon-child> and I do not want to have to deal with data that is inherently unstructured
[08:40:56] <moon-child> ...but I think we have argued this before :P
[08:41:15] <gilberth> Well, at the end of day you want to transport your data somewhere else, don't you? There is your serialization.
[08:41:50] <moon-child> sure.  But I can devise a single serialisation format which works for arbitrary language-level objects
[08:41:54] <moon-child> whatever language my system is based around
[08:42:18] <moon-child> and bake that into the implementation
[08:42:21] <gilberth> Yes, and when you would have that, where is the problem?
[08:42:27] <moon-child> such that it is completely transparent to use code
[08:42:34] <moon-child> well, then what do I need files for
[08:42:41] <moon-child> ?
[08:43:22] <gilberth> And BTW, ASCII based formats have the benefit that I could edit them and usually I could place comments there. I could look at diffs, etc. That's just too handy until you provide me the same tools for some universal data representation.
[08:43:44] <moon-child> ok.  So say I have provided such tools.  Are you happy then?
[08:44:04] <gilberth> Depends on how good those tools are :-)
[08:44:19] <moon-child> also: first-class access to the serialised format of some object means I can forge pointers or more generally create invalid objects
[08:44:21] <moon-child> which is not so nice
[08:44:39] <gilberth> But, moon-child, I am getting olde. I perhaps won't change my mental model that files are like a paper tape.
[08:45:04] <hayley> What's the name of the design process where they try really hard to not introduce bugs? Something like "clean room design" but it's not "clean room".
[08:46:53] <hayley> "Cleanroom software engineering" rather.
[08:55:14] <clothespin> my program feels like it is a bug, even though its not
[08:55:51] <clothespin> it's hardened areas surrounded by lots of soft parts
[08:57:02] <clothespin> cleanroom software engineerings sounds like the opposite of rapid prototyping
[08:57:11] <hayley> It is.
[08:57:26] <clothespin> that's the way nasa makes rockets
[08:57:49] <hayley> My reasoning is that you really don't want to fuck up anything touching money. The effort to handle a bad transaction is large, and the reputation lost moreso.
[08:58:21] <clothespin> everything touches money
[08:59:03] <hayley> In different amounts of indirection.
[08:59:06] <clothespin> there is some risk involved in coming up with something good
[08:59:58] <clothespin> i rapid prototype and eventually the inner layers get hard and the outer layer start to get hard
[09:01:06] <clothespin> i believe more design iterations are always better as long as you don't neglect your homework for trial and error
[09:01:35] <clothespin> that's why this C++ assertion thing is bogus
[09:01:57] <clothespin> can't we recover the running program?
[09:02:37] <clothespin> shut it down when we decide it needs it, not prematurely
[09:02:55] <moon-child> 'don't neglect your homework for trial and error'  hey.  Don't knock trial and error
[09:03:02] <moon-child> _plan_ for it.  That's what c++ doesn't do
[09:03:20] <clothespin> having the program running while doing a 'post mortem'
[09:03:22] * hayley has to write something nice for Agile development now
[09:03:46] *** Quits: Mandus (~aasmundo@0.51-175-33.customer.lyse.net) (Ping timeout: 260 seconds)
[09:05:22] <clothespin> it helps to do some actual thinking when up against a problem instead of mindless bashing it until it works
[09:05:39] *** Joins: Mandus (~aasmundo@85.112.154.250)
[09:05:48] <clothespin> that's all i'm saying about trial and error
[09:07:12] * hayley uploaded an image: (48KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/YsTZbjWSjafpaBaZpAcJJSjY/Screenshot_2022-03-27_15-36-41.png >
[09:07:19] <hayley> You can't get off this roundabout in the diagram.
[09:11:00] <gilberth> Must be an UK roundabout.
[09:11:48] <hayley> Yes, we drive on the left hand side here. But note that the angle of the other roads is such that you'd have to take a very sharp turn to get off the roundabout.
[09:13:39] <hayley> I believe this assignment wants references, and I claim that mistakes surrounding payment are awful. Can I cite my experience with my last university?
[09:15:01] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-08-70-29-36-27.dsl.bell.ca) (Remote host closed the connection)
[09:20:07] <hayley> But given what we learnt on development strategy can be summarised as "there's agile and there's waterfall, and waterfall is poop" I guess I have to say something nice for good grades.
[09:24:26] *** Quits: Mandus (~aasmundo@85.112.154.250) (Ping timeout: 272 seconds)
[09:25:58] *** Joins: Mandus (~aasmundo@0.51-175-33.customer.lyse.net)
[09:26:54] <kakuhen> the difference between standard-object and structure-object can mean a lot apparently
[09:27:09] <kakuhen> nearly 50% increase in performance when the bit reader in my flac decoder was changed to a struct 
[09:27:46] <kakuhen> well, that and changing a lot of generic functions for the reader to just functions
[09:29:29] *** Quits: lisp123 (~lisp123@143.238.164.103) (Remote host closed the connection)
[09:31:45] * moon-child looks around for call-site-optimizers
[09:32:18] * hayley looks for polymorphic inline cache
[09:45:45] <qhong> generic functions in all CL implementation are slow as molass
[09:46:16] <hayley> haha SICL goes brr
[09:46:44] <moon-child> s/goes/will go
[09:47:15] <hayley> Well, it can't be slow, because it can't "be" at all, without a host implementation so far.
[09:47:33] * hayley uploaded an image: (145KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/YbXRVFwexWOrTinXnsxEwvpI/siclos.png >
[09:54:41] <qhong> <qhong> hayley: I think as a very good approximation, if a language has an existing implementation, then it is bad [17:48]
[09:54:52] <hayley> You have indeed said that before.
[09:54:58] <qhong> Similarly, if an implementation exists, then it is bad
[09:55:17] <qhong> implementation nihilism
[09:55:39] <hayley> Nihilism would be that implementations don't innately have any qualities.
[09:56:31] <hayley> Being bad is a quality, thus this isn't nihilist.
[09:56:57] <qhong> makes sense. implementation is spooked
[09:57:06] <qhong> imagine having quality
[09:57:30] *** Joins: dave0 (~dave0@069.d.003.ncl.iprimus.net.au)
[09:57:37] <hayley> Real LISP hours
[09:58:58] <qhong> Down with symbols, they have property list
[09:59:38] <hayley> :D
[10:02:39] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 252 seconds)
[10:03:30] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[10:11:12] <qhong> Just realized symbols can have other symbols as their property
[10:11:14] <qhong> :o
[10:12:05] <moon-child> (setf (symbol-plist 'x) nil)
[10:17:23] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 260 seconds)
[10:18:15] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[10:25:34] <gilberth> This is getting extremely silly. Firefox just refused to download a PDF because it's HTTP. There isn't even a button [Dammit! I want it neverthess.] The rationale is: "It could have been tempered with." And HTML can't be tempered or what? Or plain text even? *sigh*
[10:30:00] <hayley> Yeah, it does that.
[10:30:07] <hayley> Though I thought there was a button.
[10:31:11] *** Joins: lisp123 (~lisp123@143.238.164.103)
[10:33:55] <gilberth> I have not spotted one. And I really don't get this https hype.
[10:34:24] <moon-child> I would much rather encrypt than not encrypt
[10:34:33] <moon-child> I like for as few people as possible to be able to snoop my traffid
[10:34:35] <moon-child> c
[10:34:49] *** Joins: rotateq (~user@p200300e787143500a6f16de1b1c2e823.dip0.t-ipconnect.de)
[10:35:22] <hayley> craffid?
[10:35:49] <gilberth> moon-child: The very fact that you contacted 1.2.3.4 isn't hidden. So what is the point in encrypting the document that I download, then?
[10:36:03] *** Quits: lisp123 (~lisp123@143.238.164.103) (Ping timeout: 260 seconds)
[10:36:14] <moon-child> you think there is no point?
[10:37:02] <gilberth> I believe there is none. And: Why would a PDF transferred via HTTPS be any more secure than one over HTTP?
[10:38:55] <gilberth> moon-child: Intelligence doesn't care about the content you transfer, it is concerned about the meta data, that is: When did who talk to whom. What is talked about is of no concern for mass surveillance.
[10:40:44] <moon-child> first: I believe there is absolutely a point in hiding as much information as you can.  This becomes especially important when the site you talk to is large; e.g. if I download a paper from arxiv, that says rather little about what I am actually researching
[10:41:23] <moon-child> second: without encryption, a mitm can swap out an altered file.  With encryption, you only trust your correspondant (and the root certs, which is a fairly large hole, but tofu)
[10:42:26] <dave0> it's a secret pdf
[10:42:36] <gilberth> I already trust any site that I visit. Do I really know who is behind https://www.example.com/?
[10:42:37] -ixelp- Example Domain
[10:43:07] *** Joins: lisp123 (~lisp123@143.238.164.103)
[10:44:23] <gilberth> It makes sense, when I login into my bank account or sth. Then I really want to know that it's my bank I am talking to with no MITM. But for just randomly browsing some information from random person? All I say is that it is overrated. And sold in the false impression that it would give me [for my use case] any "security".
[10:45:32] <moon-child> still.  Given the choice to encrypt, or not encrypt, why would I not encrypt?
[10:45:33] <gilberth> And why is HTML over HTTP ok, but not PDF? Makes no sense at all.
[10:45:46] <moon-child> I'm not defending firefox's behaviour here, mind
[10:45:58] <qhong> We talk to each others via air medium with no encryption and there aren't any problem. I think the problem is that our information infrastructure is too centralized
[10:46:16] <qhong> We should use short range/directional peer to peer radio instead
[10:46:23] <gilberth> moon-child: You may encrypt. I complained about Firefox outright refusing to download a damn PDF because it would "insecure".
[10:46:40] <moon-child> yes; again, I am not defending that
[10:46:51] <gilberth> Good.
[10:47:30] <dave0> bust out curl
[10:47:37] <gilberth> As I said, this is random. HTML is fine with Firefox. What's the difference?
[10:47:44] <moon-child> browser is supposed to be a user agent.  If it doesn't do what I want it to do, it is not doing a good job
[10:47:45] *** Quits: lisp123 (~lisp123@143.238.164.103) (Ping timeout: 252 seconds)
[10:47:45] <gilberth> dave0: I am a wgetter.
[10:48:07] <moon-child> I use both; is that bad?
[10:48:19] <qhong> maybe another problem is that firefox is not a user-centric software like Emacs
[10:48:24] <moon-child> I did observe on a couple of occasions that trying to download pdfs from microsoft with wget would fail, and with curl would succeed
[10:48:24] <qhong> use Nyxt instead?
[10:48:37] <moon-child> but also wget follows redirects by default, and I CBA to remember the flag to tell curl to follow redirects
[10:48:55] *** Joins: lisp123 (~lisp123@143.238.164.103)
[10:50:29] <gilberth> Perhaps. I just don't like curls default behaviour of not downloading but dumping the file on stdout. I just like wget better.
[10:51:50] <gilberth> Can I use curl to mirror a site? I use wget once in a while for that. I grow the habit of archiving more as web sites may vanish with time.
[10:53:19] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 260 seconds)
[10:53:35] *** Quits: lisp123 (~lisp123@143.238.164.103) (Ping timeout: 256 seconds)
[10:54:23] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[10:55:38] <moon-child> https://mrd0x.com/browser-in-the-browser-phishing-attack/  ahaha cute
[10:55:39] -ixelp- Browser In The Browser (BITB) Attack | mr.d0x
[10:56:46] <hayley> krohm
[10:58:58] *** Joins: X-Scale` (~ARM@80.199.137.78.rev.vodafone.pt)
[11:00:23] *** Quits: X-Scale (~ARM@46.50.6.46) (Ping timeout: 256 seconds)
[11:00:23] *** X-Scale` is now known as X-Scale
[11:15:14] *** Quits: lagash (lagash@lagash.shelltalk.net) (Ping timeout: 252 seconds)
[11:16:20] *** Joins: jeosol (~jeosol@user/jeosol)
[11:40:30] <dave0> hayley: this reminds me of you :-)    https://youtu.be/DAcvgCQMBs0
[11:40:31] -ixelp- Harem Scarem - Baby With A Nail Gun - YouTube
[11:40:49] <dave0> i was searching for the simpsons
[11:40:50] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Remote host closed the connection)
[11:41:15] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[11:57:15] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 260 seconds)
[11:57:53] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[12:01:51] <qhong> Encountered a problem: If I use the uniform calling convention that pass the argument as a list, then CONS will call itself and explodes
[12:02:19] <qhong> To break it I have to use primitive CONS instead of CONS closure living in the heap, which makes it not redefinable, oops
[12:02:51] <moon-child> 1. why would your uniform calling convention pass arguments as a list?
[12:03:08] <qhong> moon-child: that's the simplest and most uniform
[12:03:08] <moon-child> 2. (defun cons (car cdr) (secret-system-cons car cdr))
[12:04:26] <qhong> moon-child: so there will be two kinds of CONS calls: the normal one, and the ones just to break the circularity (e.g. for CONSing up the argument list for normal CONS)
[12:04:44] <qhong> and customizing CONS can only affect the first kind of CONS calls
[12:04:56] <moon-child> that's pretty much your only chocie
[12:05:02] <qhong> oops
[12:05:07] <qhong> feels bad
[12:05:09] <moon-child> you can't have something that's both transparent and opaque to the implementation
[12:07:17] <moon-child> I mean, it's also an implementation detail that the calling convention uses lists, right?  So customizing cons breaks calling--that's surprising and unexpected
[12:10:56] <qhong> moon-child: actually, my design is more like: there is only single argument function
[12:11:25] <qhong> the usual LAMBDAs are non-primitive and implemented by pattern matching on the single argument
[12:11:35] * moon-child hands qhong lambda calculus
[12:12:24] <moon-child> I think my point stands, though.  You can't have a system which is both transparent and opaque
[12:12:36] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 240 seconds)
[12:13:37] <qhong> Hmm, so if a system is transparent enough there will always be non-extensible bits exposed?
[12:13:47] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[12:15:29] <moon-child> the implementation is relying on cons fulfilling a certain contract.  If userspace code which breaks that contract is taken to be well-formed, then the implementation cannot rely on that contract
[12:20:58] *** Joins: lna2b4o7 (~ln43@user/ln43)
[12:22:29] <pjb> Flight 6502 https://www.youtube.com/watch?v=bAJi5EQunsQ
[12:22:29] -ixelp- - YouTube
[12:22:43] <lna2b4o7> video unavailable...
[12:27:01] <hayley> https://www.theverge.com/2022/3/25/22996248/apple-sideloading-apps-store-third-party-eu-dma-requirement
[12:27:02] -ixelp- Apple would be forced to allow sideloading and third-party app stores under new EU law - The Verge
[12:28:00] <lna2b4o7> https://youtu.be/wawbhXQX2TQ
[12:28:00] -ixelp- Yesterday Once More - YouTube
[12:29:26] <lna2b4o7> the good thing to stay away from any place is that one can see how things are going without being more involved
[12:34:03] * moon-child ponders an implementation of fork-join using fork(2)
[12:35:23] <kakuhen> is read-sequence on n-element vector faster than read-bytes repeated n times
[12:35:24] <hayley> htop reports my CPU is running at like 73°C. Never seen it do that before.
[12:35:46] <kakuhen> to temporarily speed up my flac decoder i am considering a 4 byte buffer rather than a 1 byte buffer but is proving difficult
[12:35:59] <hayley> Might be time I put more thermal paste in it. IIRC I have most of a paste thingy left over.
[12:36:00] <kakuhen> buffer for my bit reader that is
[12:36:31] <kakuhen> ccl offers an extremely cursed function that mmaps files and seems to give you very fast and large sequential reads
[12:36:35] <kakuhen> but that is not portable obviously
[12:36:44] <hayley> Shinmera made a mmap library too.
[12:36:53] <moon-child> just read the whole thing into memory
[12:38:08] <kakuhen> 無理
[12:38:33] <kakuhen> some retard's going to toss in a 2 gb flac and exhaust sbcl's heap
[12:38:38] <kakuhen> (that retard will be me in future testing)
[12:39:10] <dave0> are you reading 1 bit at a time?
[12:39:16] <kakuhen> no
[12:39:32] * hayley still wonders why gmod eats so much CPU time
[12:39:33] <kakuhen> my bit reader has a buffer of one byte, so best case scenario i can read 8 bits without having to call read
[12:39:53] <kakuhen> but if you dont exhaust the buffer, then it only does simple things like bitwise or and an incremement
[12:40:17] <dave0> kakuhen: you can buffer a word but read bytes
[12:40:44] <kakuhen> yeah i was originally considering "buffering" up to 64 bits
[12:41:07] <kakuhen> but before i write any code, it seems that i end up at roughly the same performance anyway if i use read-byte to get those bits
[12:41:15] <kakuhen> assuming read-sequence is faster, then i will use that
[12:41:52] <moon-child> depends on how dumb the implementation is.  It could be
[12:41:58] <moon-child> but probably it has its own buffer...
[12:42:08] *** semz_ is now known as semz
[12:42:25] <moon-child> .oO( that's all programming--esp. dsp and parallel--is.  Dumping buffers into buffers into buffers )
[12:42:31] <kakuhen> yeah, i know the case of sbcl on my machine, sb-impl::+bytes-per-buffer+ returns 8192
[12:42:40] <kakuhen> i dont know the equivalent of ccl but it seems signifncantly dumber
[12:43:00] <kakuhen> ccl is finally as fast as sbcl with the very very unoptimized version from 2 days ago
[12:44:25] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 256 seconds)
[12:45:15] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[12:45:31] <moon-child> ccl buffers too
[12:46:29] <hayley> Hm, how often am I supposed to change the thermal goop on a CPU?
[12:46:37] <moon-child> you're supposed to change it?
[12:46:52] <hayley> It doesn't usually run at like 70°C.
[12:47:10] <moon-child> urk
[12:47:24] <kakuhen> oh, it seems i misunderstood mmap
[12:47:43] <kakuhen> at first i thought it was mmap'ing the size of the file then filling it with the contents of that
[12:47:43] <kakuhen> that's why i was shying away from it
[12:47:46] <kakuhen> but now that i read the fine documentations...
[12:47:51] <moon-child> http://cidrdb.org/cidr2022/papers/p13-crotty.pdf
[12:47:56] <hayley> Usually like 55 under load. Not sure where the extra 15 degrees came from. And IIRC I also made the fan curve more aggressive, so it's also possible it's just not removing heat from inside the heap fast enough.
[12:47:58] <moon-child> just sayin
[12:51:25] <kakuhen> 3.4 convinces me not anymore
[12:51:28] * kakuhen uploaded an image: (32KiB) < https://libera.ems.host/_matrix/media/r0/download/kotoura.moe/kLwQGOzwGzYNgBmrgvQqbcAW/image.png >
[12:51:30] <kakuhen> this as well
[12:51:45] <kakuhen> i want to minimize ffi stuff as much as I can
[12:51:55] <kakuhen> my measure of "purity" so far is, "will this run on mezzano without modification?
[12:52:52] * hayley opens the desktop case and temperatures don't drop by much.
[12:53:04] <hayley> Well, more air to exchange with, so I suspect the cooler is the problem.
[12:54:58] <semz> reminds me that I should reapply the paste on my cpu properly sometime
[12:55:05] <moon-child> kakuhen: mmap is _probably_ fine if you are not concurrent
[12:55:15] <kakuhen> oh i plan to add threading, somehow
[12:55:15] <semz> I've been meaning to for two years now but isopropyl alcohol was sold out for ages because of panic buyers
[12:55:52] <moon-child>  but do you expect to blow out of memory in practice?
[12:56:00] <kakuhen> when my decoder exits from decode-residuals, you may assume the position of the next frame's sync code
[12:56:19] <kakuhen> so i was considering running a subframe parser in another thread while the first thread is busy with decode-lpc
[12:56:39] <kakuhen> only problem is figuring out the locks and stuff for the vectors that hold decoded samples
[12:57:11] <kakuhen> s/subframe parser/frame parser
[12:58:45] <kakuhen> actually this is much more rigid and worse than attempting to do e.g. one thread per channel
[12:58:58] <hayley> Does subframe parsing take considerable time vs decoding LPC?
[12:59:06] <kakuhen> it takes considerable time due to the amount of read()s
[12:59:18] <kakuhen> according to sb-sprof, I spend about 83% of my time in read() and the rest is mostly in LPC
[12:59:28] <hayley> Assuming both are sequential, then ideally they should take about the same amount of time.
[13:05:25] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 240 seconds)
[13:06:31] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[13:07:12] <gilberth> When the four bits are a nibble, what are three bits then?
[13:08:43] <kakuhen> read-sequence is nearly 2x slower on ccl :<
[13:08:46] <kakuhen> i guess its unfair since i am not pushing values onto a vector with read-byte
[13:10:00] <kakuhen> well, assuming we did not add tons of seconds with modulus operations, read-sequence is about 1.4x faster
[13:10:01] <gilberth> This is curious as I never measured any speed difference with read-sequence to an octet vector.
[13:10:29] <kakuhen> gilberth: in particular, i am opening /dev/random and reading 4,000,000 bytes with read-byte
[13:10:58] <kakuhen> then i compare it to 1,000,000 invocations of read-sequence (where the sequence is vector of 4 octets)
[13:10:59] <gilberth> You said you would use read-sequence. I am confused now.
[13:11:05] <kakuhen> i figured read-sequence takes extra time due to modifying sequences
[13:11:07] <moon-child> I would open a real file, not /dev/random
[13:11:11] <moon-child> performance will be different
[13:11:13] <kakuhen> so then i decided to try read-byte but setf aref myself
[13:11:17] <kakuhen> and that comes out considerably slower
[13:11:22] <kakuhen> ah 
[13:11:29] <kakuhen> yeah, i guess /dev/random doesnt help much
[13:11:43] <gilberth> kakuhen: ok. I see. I thought you were comparing with SBCL.
[13:11:44] <moon-child> (though the benchmark is probably still reasonably likely to be accurate)
[13:12:00] <kakuhen> gilberth: sorry for the confusion; for now i am attempting to compare read-byte and read-sequence on CCL
[13:12:16] <gilberth> Perhaps read-sequence turns into a read(2) and read-byte would turn into way less read(2)s because there is a buffer.
[13:13:35] <gilberth> Maybe cl:read-sequence is not implemented with having the use case to read just a few bytes in mind? idk
[13:13:54] <hayley> https://www.youtube.com/watch?v=V43iobDBNW8
[13:13:54] -ixelp- My Way / When Do I Get To Sing 'My Way' (Live in London 2018) - YouTube
[13:14:36] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 252 seconds)
[13:15:20] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[13:15:54] <semz> kakuhen: Are you sure it's not because /dev/random blocks on your kernel?
[13:16:27] <semz>  /dev/random and /dev/urandom are the same on recent kernels, but if you have an older one you might be measuring noise
[13:16:32] <kakuhen> that'd be surprising considering my machine has a coprocessor for random numbers
[13:16:42] <kakuhen> and i once measured how fast i can read from /dev/urandom iirc? using dd
[13:16:47] <kakuhen> and i was able to get somewhere around 1 GB/s i think
[13:16:52] <semz> nevermind then
[13:17:19] <gilberth> Na, CCL read-sequence goes through the buffer too. Maybe it was CMUCL which would hit read(2) directly when the buffer is empty.
[13:18:04] <gilberth> But then CMUCL's read-sequence used to return a short read just like read(2). Something I miss with CL.
[13:31:27] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 256 seconds)
[13:32:22] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[13:40:55] *** Joins: shka (~herr@109.231.3.55)
[13:42:36] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Remote host closed the connection)
[13:43:01] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[13:47:15] *** Quits: lna2b4o7 (~ln43@user/ln43) (Quit: Connection closed)
[13:56:56] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 252 seconds)
[13:57:22] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[14:17:15] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 260 seconds)
[14:41:38] <qhong> Question: what's an acceptable fixnum bit width?
[14:42:10] <hayley> 63
[14:42:19] <qhong> I find that immediate values can be very useful for encoding immutable values, but they need to eat the space of fixnum
[14:42:35] <hayley> Use other tags.
[14:43:11] <qhong> hayley: Mutable objects don't have tags in their pointer, because that will nuke BECOME:
[14:43:25] <gilberth> Folks have incredible wide screens these days, why can't those new fancy error messages which quote the context be such that the complain is right of the source quote, instead of below. But in general I don't like those overly verbose error messages. Give me an error message, a file, a line, and perhaps a column.
[14:43:46] <hayley> Just put the error in the source file? idk
[14:44:01] <gilberth> hayley, are you ok?
[14:44:21] <hayley> gilberth: Hey, Smalltalk-80 does that. If you have a parse error, it'll put a comment saying "parse error" at the site of the error.
[14:44:42] <gilberth> Emacs will put me to the spot just fine.
[14:45:11] <gilberth> hayley: I would hate it, if gcc would scribble into my C files.
[14:45:22] <hayley> I wouldn't mind DWIM though.
[14:45:25] <moon-child> can't have parse errors if you edit syntax trees that are well-formed by construction
[14:45:34] * hayley uploaded an image: (278KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/LHNDfZnnESSvykqWbefsIOVC/crab-laser.png >
[14:46:06] <gilberth> moon-child: Now you again. I hate structural editors, have I mentioned that already?
[14:46:46] <moon-child> gilberth: with a structural editor, I could just attach an error to a node, and you could display it however you want
[14:46:48] *** Quits: razetime (~quassel@117.254.34.170) (Ping timeout: 272 seconds)
[14:47:21] <gilberth> moon-child; And how would I be able to enter sth which doesn't parse at all?
[14:47:48] <moon-child> what would be the point of that?
[14:48:26] <moon-child> and I mean, it is exactly the same as with the lisp os.  You still have comments, and strings, which can pass through arbitrary byte streams.  But you're not _forced_ to use byte streams
[14:48:42] <moon-child> hell, you could even say #.(read-from-string "your text here") and get a full text editing experience
[14:49:19] <gilberth> I work that way. In mid-fly my code could look messy. Or, say, yank some C code into a Lisp buffer and then morph it into s-expressions. Or yank a table, I have from somewhere and use a keyboard macro to bring into a form my language can grok? This kind of things.
[14:49:32] <hayley> https://www.youtube.com/watch?v=4kGGzNuOTww
[14:49:32] -ixelp- EMOTIONAL DAMAGE meme (Steven He) - YouTube
[14:50:41] <gilberth> SEDIT is a nice idea in theory. It's just that I cannot work with it. I spend too much thinking on what tree operations I could use to bring what I see to what I want.
[14:53:09] <moon-child> gilberth: I can imagine a mode which would let you take a node and treat it as text, and then turn it back into a tree once it parses again.  But in the large, I think structural forms are much better for analysis (esp. interactive), and relating the state of the code to the state of the image
[14:53:50] <moon-child> 'spend too much thinking'  I suspect this is just a matter of having a good environment and getting used to it.  I know vim pretty well, and can use it pretty well; but if I didn't, I expect I would similary spend way too much time thinking about what text-editing operations to use to get to the state I want
[14:54:07] <moon-child> *similarly
[14:55:56] <moon-child> (analysis: e.g. instead of text-search, I can have a pattern-matcher.  Instead of text search-and-replace, I have a term-rewrite.  Instead of complicated autocomplete that's not even that smart, I have fairly simple autocomplete that's rather smart.  Instead of relating errors to ast nodes back to source positions, I relate errors to ast nodes, which _are_ source positions)
[14:56:20] <gilberth> Do you want a COMMENT special form, too? Interlisp is here --->
[14:56:25] <semz> In what sense is structural editing different from "paredit without doing stupid things"? Speaking from a user perspective here, obviously it differs in terms of automatic analysis etc
[14:56:49] <semz> As in, would somebody used to paredit notice the difference outside of better tooling?
[14:57:00] <qhong> The only thing I see missing from real structural editing is next/prev-line
[14:57:12] <gilberth> semz: Structural editing is different because what you edit is the internal representation, not some text.
[14:57:26] <qhong> I have to admit, 2D character grid is very intuitive/overfitted to human architecture
[14:57:29] <moon-child> qhong: how about next-form-in-innermost-progn?
[14:57:50] <qhong> moon-child: it's not exactly the same. Cursor position
[14:57:56] <gilberth> semz: You could try it with SEDIT with Medley. It is rather nice as the pretty printer is behind it and it would pretty print your code as you go.
[14:57:58] <moon-child> semz: I haven't used paredit.  So hard to say.  I am working from first principles
[14:58:11] <qhong> when you do next-line, the cursor will move right under the current position. Not a surrounding form
[14:58:33] <semz> Huh, lispers who don't use paredit apparently exist.
[14:58:43] <moon-child> qhong: I would not have a single 'cursor position'.  (Except when editing a symbol/number/string.)  Rather, the 'cursor' covers a tree node
[14:58:50] <gilberth> semz: Yes, I am one of those.
[14:59:17] <semz> guess I'll give Medley a try
[14:59:32] <gilberth> Tried it. And paredit was doing silly things. Left me with broken code, which I couldn't edit anymore.
[14:59:34] <hayley> I don't use paredit either.
[14:59:35] <moon-child> semz: it seems to me that paredit starts with a textual environment and tries to spruce it up.  And my experience with such things is that they fail.  E.G. I cannot stand when I type a ( or a ", and the environment closes it for me
[14:59:39] <gilberth> paredit, that is.
[15:01:03] <semz> moon-child: how's that different from treating ( as an alias for something like create-new-subtree?
[15:01:35] <gilberth> moon-child: Funny you mention that auto insert of closing delimiters. I hate that with passion, because it breaks the assumption that when I hit a key that character appears. With auto-delimiters. "(" would insert "()" and ")" would insert either ")" or be a forward-char.
[15:01:44] <qhong> moon-child: that's what "real" structure editors do. However I find myself more adapted to 2D grid model. I suspect that's the case for most people
[15:02:15] <gilberth> Don't put those auto-delimiters into the buffer proper. Have them in dim, if you wish, but make them transparent to my typing.
[15:02:22] <moon-child> qhong: as semz says, in a 'real' structural editor, ( would not 'insert' two characters; it would create a _single_ new parse node
[15:03:14] <gilberth> Yes, and with structural editing the subject of your editing is not characters, but nodes.
[15:03:32] <moon-child> semz: because, like gilberth, when I work in text files I end up with unbalanced delimiters.  And ultimately, when I work with text, it is easiest for me to reason about it as text; if I would like a ), I will type it; when I type a (, I am not yet thinking of the )
[15:03:57] * gilberth nods.
[15:05:02] <semz> Hm, can't say I understand. Different strokes for different folks I guess.
[15:05:35] <gilberth> I mean, I just want to type the code. I have no trouble with parens. An there is close paren highlighting. I use the variant that the matching open paren is highlighted, when I type ")". Not the variant which highlights any matching "(" when just moving around.
[15:05:40] <moon-child> semz: I mean--I can _imagine_ a 'sufficiently smart structural editor' that would maintain an automatic correspondance between its structure and a textual representation.  But I can't imagine you would get there unless you made a concerted effort to get there, and you _started_ with the structure rather than with the text
[15:05:49] <gilberth> So it's inconsistent for a text editor.
[15:06:38] <hayley> https://dl.acm.org/doi/10.1145/3373376.3378525 Neural networks for pretenuring?
[15:06:38] -ixelp- Learning-based Memory Allocation for C++ Server Workloads | Proceedings of the Twenty-Fifth International Conference on  [...]
[15:07:12] <hayley> "The model learns context-sensitive per-allocation site lifetimes from previous runs, generalizes over different binary versions, and extrapolates from samples to unobserved calling contexts. Instead of size classes, LLAMA's heap is organized by lifetime classes that are dynamically adjusted based on observed behavior at a block granularity."
[15:08:08] <gilberth> And this paren flash is like I think. I learned it that way. Even on paper. For when I learned Lisp, I wrote my programs on paper as I had no Lisp at home. Like (defun fib (n) (if (< n 2) (+ (fib (- n 2)) (fib (- n 1 .oO(close -, FIB, IF, DEFUN done)
[15:08:45] <gilberth> I forgot + :-/
[15:08:50] <semz> lel
[15:08:55] <moon-child> I do that when I write lisp programs in irc
[15:09:03] <moon-child> or, snippets, I should say
[15:09:28] <moon-child> but I don't like time-sensitive functions.  I use the variant which always highlights the matching parenthesis.  It also helps sometimes when looking at nested forms
[15:09:56] <gilberth> Yep. And I taught doing it that way. And the first like seven years of Lisp hacking, I had no paren flashing.
[15:10:42] <moon-child> my experience is, if something flashes for a brief period of time, sometimes I want to see it highlighted again.  So, what, I should delete the parenthesis and re-type it?  Or, if I have to hold down a key for a brief period of time, I may hold it down for too long; or vice versa
[15:10:43] <gilberth> I like the brief flash just as I hit ")".
[15:11:35] <moon-child> (though, slime/sly flashing is not too bad.  Hmm.)
[15:11:36] <gilberth> moon-child: Granted. In that case, when I wonder where the matching "(" is, I use c-m-b c-m-f. Habits.
[15:14:36] *** Joins: dra (~dra@2a04:4540:6410:c100:4cc4:f220:91bd:91f9)
[15:14:38] <dra> Hello!
[15:16:06] <gilberth> But then I am German. German is funny because you could stack as many verbs as you wish at the end of a sentence. With subordinate clauses the verb goes last and you can nest clauses as many as you wish, you only need to close them. Like the .oO(-, FIB, +, IF, DEFUN full stop) :-)
[15:16:14] <rotateq> dra: you again :)
[15:16:59] <qhong> gilberth: do you speak Forth?
[15:17:28] <gilberth> I speak the pro variant: PostScript. I don't like Forth at all.
[15:17:55] <qhong> based
[15:18:20] <kakuhen> based on what?
[15:18:33] <rotateq> reversed german notation .. or so
[15:19:16] <rotateq> in postscript it's similar?
[15:19:44] <dra> rotateq: Ha! I show up when I remember to start my IRC client... never set up a bounce.
[15:19:53] <rotateq> nice dra :D
[15:25:12] <gilberth> Well, unlike PostScript in German you can actually shuffle the subject, verb and object as you see fit. "Ich lese ein Buch", "Ein Buch lese ich.", "Ein Buch ich lese.", "Lese ein Buch ich", and "Lese ich ein Buch?" are all valid. Though the last is a question.
[15:26:59] <hayley> Broke: divide and conquer
[15:27:00] <hayley> Woke: https://dl.acm.org/doi/10.1145/91556.91652
[15:27:02] -ixelp- Unify and conquer | Proceedings of the 1990 ACM conference on LISP and functional programming
[15:35:25] *** Quits: Oddity (~Oddity@user/oddity) (Ping timeout: 240 seconds)
[15:36:52] <moon-child> gilberth: hmm, in english that is more annoying.  Cf https://elronnd.net/
[15:37:06] *** Quits: dbotton (sid492350@id-492350.lymington.irccloud.com) (Quit: Connection closed for inactivity)
[15:41:02] <gilberth> moon-child: Yes, as English lost all declension [term? I looked that up] with time, it depends on a fixed and rigid word order. Something which at times is hard for me.
[15:41:45] <moon-child> english has declension, but not very much
[15:42:50] <qhong> down with synthetic language, longlive analytic language
[15:43:03] <gilberth> What is the declension of "the book"? "the book", "the book", "the book", "the book", "the books", "the books", "the books", "the books". Only plural has a different ending. Perhaps plural will vanish too with time? Who knows?
[15:43:32] <gilberth> One funny case is "whom" though. I seem to have less trouble with "who" versus "whom" than some native speakers. :-p
[15:43:48] <moon-child> 'to be' is conjugated
[15:43:51] <qhong> whomst'd've
[15:44:18] <shka> https://www.youtube.com/watch?v=gkVinUodKvg
[15:44:18] -ixelp- Vader - The Book - YouTube
[15:44:30] <gilberth> moon-child: Yes, conjugated. That's important for tense but not for making out subject and object.
[15:45:34] <gilberth> I really don't know what besides person pronoms are still declinated in English.
[15:45:46] <moon-child> I am, you are, he is ...
[15:46:54] <gilberth> I mean, you can tell who is the agressive person with "She hits him" and "Him hits she", but not with "The woman hits the man" versus "The man hits the woman".
[15:48:06] <gilberth> In German it's "Die Frau schlägt den Mann." and "Den Mann schlägt die Frau". It's obvious which is subject and which is object.
[15:48:16] * moon-child nods
[15:48:20] <moon-child> in hebrew we have a lot of assorted declensions.  I can say 'my two keyboards', and this is one word (though it's an awkward construction, and probably no one would say it in practice)
[15:49:09] <gilberth> Is there a "two-of-kind" along with singular and plural?
[15:49:45] <moon-child> yeah
[15:50:17] <semz> I wish German declensions would differ more. Feels silly when half the endings are the same.
[15:50:18] <gilberth> So you have a my-two-of-a-kind as a declension?
[15:51:06] <moon-child> well, there's a 'my' declension, and a 'two-of-a-kind' declension, and if you stretch you can apply them one after the other
[15:51:15] <gilberth> semz: This comes because we suffer from the very same problem as English suffers. We don't stress the last syllable. This leads to the ending being not stressed and lost with time.
[15:52:11] <moon-child> the two-of-a-kind thing is only really idiomatic for some words though.  Not like singular and plural which can go much anywhere
[15:52:20] <gilberth> There is a dative ending in "e", which isn't used much anymore. You could use it to sound old-fashioned.
[15:52:22] <moon-child> (well, most anywhere.  There's no singular water, for instance)
[15:52:39] <semz> makes sense
[15:54:35] *** Joins: treflip (~user@user/treflip)
[15:54:43] <gilberth> moon-child: What if I refer to different kinds of water? Say in taste? This [bubble] water tastes better than that? I tried three bubble waters? I mean water is a special case. Although it has no singular or plural when referring to just the substance, it gains singular and plural in a different context.
[15:55:46] <gilberth> I don't know if "waters" would be use in English. In German you would. There is "Wasser" = water and "Wässer" as a plural.
[15:56:43] <moon-child> well, you could say e.g. (transliterated cuz I don't have a hebrew keyboard) 'ha maim ha ze ta'im' (this water is tasty).  The 'ze' is singular, but the water is still plural
[15:58:36] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-08-70-29-36-27.dsl.bell.ca)
[16:00:21] <gilberth> Sure. Techinacally in German "Wasser" is plural. It's a pluraletantum. But there is a plural-plural when referring to more than one [kind] of [bubble] water I may have tried.
[16:00:53] <moon-child> ah, I see
[16:01:17] <moon-child> I don't think hebrew has anything like that
[16:01:21] <rotateq> Gewässer
[16:01:54] * hayley stuck between "Generational GC cures all", lazy allocation, and compile time garbage inference
[16:04:34] <edgar-rft> Was, Wasser, am Wassersten
[16:04:49] <rotateq> edgar-rft: :D
[16:05:06] <shka> generations don't cure all, but they solve most common problem
[16:05:09] *** Quits: dave0 (~dave0@069.d.003.ncl.iprimus.net.au) (Read error: Connection reset by peer)
[16:05:20] <edgar-rft> German for profesionals
[16:05:33] *** Joins: dave0 (~dave0@069.d.003.ncl.iprimus.net.au)
[16:05:40] <rotateq> inconsistency in human languages
[16:06:08] <rotateq> I'm bad at those anyway.
[16:06:38] *** Joins: random-nick (~random-ni@87.116.176.196)
[16:06:47] <hayley> shka: It's usually the tenured GC that gets you.
[16:07:26] <qhong> rotateq: We should get rid of inflection at least. Use analytic languages instead
[16:07:33] <rotateq> or now I could learn Mandarin and Korean to have an additional reason for a near-by maybe interesting industry company to employ me in 2 years cause they have locations there too
[16:08:27] <rotateq> qhong: I'm not any better at such :) not even in programming languages (or I just think that)
[16:10:00] <qhong> I do like to compare synthetic language with sth like CL and analytic language with sth like Scheme/Haskell
[16:10:12] <shka> hayley: until you are using goland
[16:10:16] <shka> *golang
[16:10:33] <shka> https://discord.com/blog/why-discord-is-switching-from-go-to-rust pretty silly article 
[16:10:34] -ixelp- Why Discord is switching from Go to Rust
[16:10:42] <hayley> Then tenured GC gets you in throughput. Since there is no generational filter. womp womp
[16:10:56] <rotateq> shka: goland may be the adventure park for hipsters :P
[16:11:04] <qhong> There can be a case to be made that human are actually not well suited to uniform/regular/simplistic languages, because it's hard for human to _unlearn_ things
[16:11:40] <shka> also discord goes to rust because they can't write proper LRU cache, kek
[16:11:46] <rotateq> lel Discord heavily relies on Elixir (so the BEAM) primarily, now they use those NIFs with Rust
[16:11:54] <hayley> But then, having some additional things before the nursery means that is churned less. So you have predictable short stuff -> unpredictable short stuff -> unpredictable old stuff
[16:12:06] <rotateq> BEEEAAAM!
[16:12:11] <rotateq> rip Joe
[16:12:48] <hayley> He's making phone calls in heaven.
[16:13:02] <hayley> "Hello Joe." "Hello God."
[16:13:36] <rotateq> this week I watched the "mess we're in talk" again, wonderful
[16:13:57] <rotateq> or he talks with Agner Krarup Erlang
[16:14:35] <hayley> While GC language is pretty gruesome (and now poorly timed), I realize that analyzing the obvious stuff means less obvious objects have more time to die in the same sized nursery.
[16:15:30] <rotateq> 1kg black hole, the ultimate laptop :D
[16:17:41] <rotateq> hayley: https://trash.randomerror.de/kezqz/mess.png
[16:21:17] <rotateq> "Don't write bugs, generate them." :D
[16:26:23] <gilberth> Wässerchen. "zu wässern" as a verb. "zu wassern" as a verb. German is a fun language.
[16:26:54] <rotateq> it is indeed :D
[16:28:26] <gilberth> Darf das das? Das darf das! Dass das das darf!?
[16:29:26] <gilberth> Wenn Fliegen hinter Fliegen fliegen, dann fliegen Fliegen Fliegen nach.
[16:30:03] <gilberth> Komm, wir essen Opa! --- Zeichensetzung kann Leben retten.
[16:30:16] <rotateq> oh yes :D
[16:30:29] <rotateq> Come on, we eat gilberth. ;)
[16:30:39] <semz> #lispcafe is being colonized by the germans
[16:30:52] <semz> soon it'll serve beer instead of coffee
[16:31:19] <gilberth> Won't happen. Germans are big time coffee drinkers.
[16:31:57] <rotateq> "From now on the prices from 1965 are valid!"
[16:32:22] <rotateq> I don't drink coffee, but mate as my coffeine source.
[16:33:20] <gilberth> I drink coffee whole day and I am happy I actually may drink coffee again, after it was almost two years without any for me.
[16:33:44] <rotateq> so I know what to bring as a gift for you ^^
[16:34:08] <gilberth> A mug? With a lambda on it?
[16:34:17] <rotateq> no coffee
[16:34:43] <gilberth> A mug would last longer.
[16:34:45] <rotateq> in the local hackerspace some people once roasted coffee beans
[16:34:48] <rotateq> yes okay
[16:35:15] <rotateq> in the week after easter we have free days :D
[16:35:58] <gilberth> I am not fancy with my coffee. The fanciest is that I use one of those: <https://m.media-amazon.com/images/I/51EyvQ+NMRL._AC_SX466_.jpg>
[16:36:14] <rotateq> or better 19. -- 22.04.
[16:36:44] <rotateq> and we crafted some own pasta once
[16:37:38] <rotateq> gilberth: okay I think a barista machine is not in my budget at the moment :D
[16:38:21] <gilberth> I don't want such a machine.
[16:38:35] <rotateq> I know :P
[16:38:43] <rotateq> me neither
[16:38:57] <gilberth> My wife used to have a fancy coffee maker. I never used it.
[16:39:12] <rotateq> ah such an "automatic" one?
[16:39:56] <gilberth> Yes, one which would ground beans. With three different compartments for three different kind of beans.
[16:41:47] <gilberth> I prefer my boring filtered coffee.
[16:43:11] <rotateq> I was really annoyed that I couldn't be in Porto on Monday and Tuesday. Instead, there was nothing but grits. But at least I could watch streams and participate a bit via IRC.
[16:45:48] <rotateq> Microsoft shitshow
[16:49:35] <rotateq> gilberth: Some years ago I saw those nice TeX mugs, but they were out of stock. :(
[16:50:57] <edgar-rft> probably out of print :-)
[16:51:10] <rotateq> yes
[16:51:35] <sham1> I actually hate DST
[16:51:39] <edgar-rft> TeX still worked but the printer was out of ink
[16:51:47] <sham1> This is just stupid
[16:52:04] <rotateq> sham1: What's now DST?
[16:52:06] <edgar-rft> This, too :-)
[16:52:24] <sham1> Daylight Saving Time
[16:52:28] <edgar-rft> DST = Dumb Stupid Time
[16:52:42] <rotateq> ah okay
[16:53:06] <edgar-rft> rotateq: Sommerzeit
[16:53:12] <rotateq> the oven in the kitchen needs the new time plus again 2mins
[16:53:17] <sham1> Esp. For an insomniac such as myself the first week or so of this will be torture
[16:53:28] <rotateq> edgar-rft: danke jetzt hab selbst ich es verstanden XD
[16:54:05] <edgar-rft> do I get interest for all my saved daylight?
[16:54:47] <rotateq> it's nice today outside, I should tank some UV light.
[16:55:22] *** Joins: razetime (~quassel@117.254.34.170)
[16:55:48] <rotateq> edgar-rft: You use ink printer for TeX documents?! :D
[16:56:09] <rotateq> did you get my fax on your nail printer?
[16:57:09] <sham1> The only way to appreciate the BASED nature of the TeX typesetting is to print it out
[16:57:12] <gilberth> A nail printer. How fancy! Could it print a nice lambda symbol onto my polished nails?
[16:57:44] <rotateq> sham1: yes but on LASER printer
[16:59:52] <rotateq> I should also decide to let all my work colleagues believe that Word and PowerPoint, for example, are great and reliable programmes that you absolutely have to use. Otherwise it just drains your energy reserves.
[17:00:16] <rotateq> or their Visual Studio gibberish and what not else
[17:02:18] <rotateq> as even most of the teachers think this
[17:07:19] <edgar-rft> rotateq: how else do you get the picture onto the mug?
[17:07:52] <rotateq> edgar-rft: don't know, maybe adobe photoshop? ;)
[17:08:24] <rotateq> but then they remove the "print on mug" feature your companies pipeline relies on
[17:08:37] <edgar-rft> I'm busy with printing the nails for the next crucifiation
[17:08:57] <rotateq> shit sells and people like to eat it
[17:09:08] <rotateq> edgar-rft: phew :D
[17:09:56] <rotateq> https://www.youtube.com/watch?v=SJUhlRoBL8M
[17:09:56] -ixelp- Eric Idle - "Always Look On The Bright Side Of Life" - STEREO HQ - YouTube
[17:10:42] <edgar-rft> I'd be intersted to become a customer of "Jesus' Nail Studio" :-)
[17:11:01] <rotateq> lel
[17:14:24] <edgar-rft> I think I'll open a tatoo studio with my nail printer
[17:15:16] <rotateq> and with your laser printer another to remove them
[17:15:24] <rotateq> perfect business idea
[17:19:59] *** Quits: razetime (~quassel@117.254.34.170) (Read error: Connection reset by peer)
[17:35:55] *** Joins: razetime (~quassel@117.254.34.170)
[17:36:36] <gilberth> For applying solder paste to PCBs a very thin laser cut metal sheet with holes where you want solder could be used. I once contemplated to use one of those with nail polish to apply a lambda on top.
[17:38:28] <rotateq> cool
[18:02:53] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Remote host closed the connection)
[18:03:16] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[18:19:14] *** Joins: kevingal (~quassel@80.233.47.223)
[18:26:55] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 260 seconds)
[18:28:33] *** Joins: aeth (~aeth@user/aeth)
[18:51:40] *** Quits: treflip (~user@user/treflip) (Remote host closed the connection)
[19:05:24] *** Joins: dbotton (sid492350@id-492350.lymington.irccloud.com)
[19:06:18] <clothespin> morning
[19:28:23] *** Quits: kevingal (~quassel@80.233.47.223) (Ping timeout: 250 seconds)
[19:44:09] *** Joins: domovod (~domovod@176.196.122.197)
[20:08:40] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-08-70-29-36-27.dsl.bell.ca) (Remote host closed the connection)
[20:22:50] *** Joins: lagash (lagash@lagash.shelltalk.net)
[20:27:47] *** Joins: kevingal (~quassel@80.233.39.223)
[20:38:13] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[20:42:37] *** Joins: lisp123 (~lisp123@139.168.166.203)
[20:44:00] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 272 seconds)
[20:45:26] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[20:47:01] *** Quits: lisp123 (~lisp123@139.168.166.203) (Ping timeout: 245 seconds)
[20:48:47] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 250 seconds)
[20:49:41] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[20:52:41] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 250 seconds)
[20:54:49] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[21:09:21] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 250 seconds)
[21:09:51] *** Joins: tyson2 (~user@cpef492bf758151-cm688f2e29d8d0.cpe.net.cable.rogers.com)
[21:11:24] *** Joins: aeth (~aeth@user/aeth)
[21:19:50] *** Quits: Inline (~Inline@p200300cd473c9e009f1d7d6dc4a648e3.dip0.t-ipconnect.de) (Quit: Leaving)
[21:20:52] *** Joins: Inline (~Inline@p200300cd473c9e009f1d7d6dc4a648e3.dip0.t-ipconnect.de)
[21:21:36] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 245 seconds)
[21:22:46] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[21:24:38] *** Quits: kevingal (~quassel@80.233.39.223) (Ping timeout: 252 seconds)
[21:32:19] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 250 seconds)
[21:33:31] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[21:46:16] *** Quits: dave0 (~dave0@069.d.003.ncl.iprimus.net.au) (Quit: dave's not here)
[21:46:21] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Quit: WeeChat 3.4.1)
[21:46:32] *** Quits: razetime (~quassel@117.254.34.170) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
[21:55:19] *** Quits: tyson2 (~user@cpef492bf758151-cm688f2e29d8d0.cpe.net.cable.rogers.com) (Remote host closed the connection)
[21:58:55] *** Quits: domovod (~domovod@176.196.122.197) (Quit: WeeChat 3.4)
[21:59:41] *** Joins: tyson2 (~user@cpef492bf758151-cm688f2e29d8d0.cpe.net.cable.rogers.com)
[22:08:00] *** Joins: Lycurgus (~juan@98.4.112.204)
[22:16:19] *** Joins: treflip (~user@user/treflip)
[22:17:01] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 240 seconds)
[22:19:22] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[22:28:51] *** Quits: treflip (~user@user/treflip) (Remote host closed the connection)
[22:47:04] *** Quits: tyson2 (~user@cpef492bf758151-cm688f2e29d8d0.cpe.net.cable.rogers.com) (Remote host closed the connection)
[22:53:55] *** Quits: pjb (~pjb@user/pjb) (Read error: Connection reset by peer)
[23:08:12] *** Quits: Lycurgus (~juan@98.4.112.204) (Quit: Exeunt)
