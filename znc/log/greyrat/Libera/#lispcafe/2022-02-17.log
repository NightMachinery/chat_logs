[00:10:18] <hayley> @neominimum: The former.
[00:10:35] <hayley> @GreaseMonkey There are enough cryptos in Rust to make insults.
[00:16:47] *** Joins: vms14 (~user@29.red-79-153-202.dynamicip.rima-tde.net)
[00:17:13] <vms14> I have to confess the feature I like the most of lisp is not macros or the format function
[00:17:52] <vms14> it's that when I've put :D lisp responds with the same happyness
[00:18:05] <shka> :D
[00:18:11] <vms14> :D
[00:18:35] <gilberth> Well, without macros Lisp wouldn't be Lisp.
[00:18:53] <vms14> for some reason I've put this :D when I start slime
[00:19:07] <vms14> specially the first time it runs on a computer
[00:19:54] <parjanya> vms14: the repl is always happy
[00:20:31] <pjb> gilberth: wrong. Without macros, lisp would still be lisp, because it would be trivial to implement a macro system on it.
[00:20:42] *** Joins: dre (~dre@101.191.49.59)
[00:20:53] <pjb> gilberth: macros were added to lisp only in 1964, 6 years after the invention of lisp.
[00:21:13] <vms14> and btw slime sometimes does not start in emacs28 in netbsd, I think it has to do with no threading support, but maybe it's that it asks about different versions and there is no minibuffer prompt, cause when I put slime connect always work as long as I have a swank server running, but always warns about different versions and asks for confirmation, maybe this is why it sometimes run and sometimes not when I simpli put "slime"
[00:21:28] <shka> and 60 years with macros
[00:22:01] <gilberth> pjb: As a pre-processor, yes. Before macros there was EVAL and those functions which would get un-evaluated arguments.
[00:22:05] <pjb> and we must say that there was at least fexprs.
[00:22:29] <vms14> simply*
[00:22:49] <gilberth> But granted. My toy "Core Lisp" doesn't have macros on their own. It's only the REPL and the compiler, which have those. And the latter are written in Lisp.
[00:23:01] <vms14> I torture people by writing, being it english or code
[00:23:45] <vms14> gilberth: you had a lisp with macros written in lisp
[00:24:07] <vms14> I think you had one
[00:24:28] <vms14> someone showed me some code to implement macros time ago
[00:24:41] <gilberth> I have multiple implementation in all sorts of funny languages like PostScript or Rust.
[00:24:47] <vms14> lol
[00:24:51] <parjanya> gilberth: btw, I was perusing your server and I found many hidden gems there... tex+pascal+clim and all sorts of sorcery
[00:24:54] <vms14> give me one :/
[00:24:59] <vms14> I have only half
[00:26:34] <gilberth> When you think about it, even given an interpreter, you want to expand macros just once at the time you say DEFUN. This is what ANSI CL calls minimal compilation. And this could be done entirely in Lisp, if you write your REPL in Lisp. Instead of "REPL" it would be read-macroexpand-eval-print.
[00:27:27] <vms14> but it's hard when the implementing language isn't lisp
[00:27:55] <gilberth> Before I had CLISP in dark, dark MS-DOS times, I had XLISP. And this macroexpand-once was one of the first things I added. A byte-code was the second.
[00:28:27] <vms14> I've tried with perl and was kind of lucky since I've made a lisp that was a perl transpiler written in perl, so it "had" the language accessible and some stuff could just be defined at compile time and still exist at run time
[00:28:38] <vms14> where compile time was just writing perl code
[00:29:09] <vms14> but was shit, not usable and everything was wrong
[00:29:11] <gilberth> PostScript was the most fun implementation, as it actually is a Lisp->PS compiler. And Ghostscript's interpreter is surprisingly fast.
[00:30:06] <vms14> I still try to learn forth and see if I'll like it
[00:30:17] <vms14> it seems to have the whole "power" of lisp macros
[00:30:23] <vms14> and reader macros
[00:30:36] <gilberth> Rust was the most painful and the by a far margin slowest implementation. Go was fair and actually painless.
[00:30:39] <vms14> but I don't understand yet how it works
[00:30:58] <vms14> I see you can define a compile time behaviour and a runtime behavior in the same word
[00:31:01] <gilberth> Nice thing about PostScript is, that PostScript can generate PostScript code.
[00:31:19] <vms14> gilberth: then that was why was "fun"
[00:31:51] * hayley is in the MPS mailing list now.
[00:32:22] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Remote host closed the connection)
[00:32:57] <gilberth> Still, one of my unfinshed just-for-fun projects. I have an implementation in Perl and one in MBASIC-80, too. I ought to set up a web page "Lisp in funny implementation languages".
[00:33:18] <vms14> haha you should
[00:33:46] <vms14> actually it would be very useful
[00:34:06] <vms14> because a lot of programmers could see lisp implemented in their favourite language
[00:34:07] <gilberth> Only for entertainment, I guess.
[00:34:39] <vms14> and won't be a lisp written from a guy who does not even know what a macro is and implemented lisp just because it seemed easy
[00:35:10] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[00:35:18] <gilberth> However my philosophy was to specify what I call "Core Lisp". That is just QUOTE, IF, LAMBDA, SETQ, CATCH/THROW. You can implement all other CL special forms on top of that.
[00:36:42] <vms14> gilberth: why you don't focus on some implementation that let's you use libraries you could be interested in and aren't availabe in lisp
[00:37:40] <gilberth> What would that give me?
[00:37:44] <vms14> in my case I've tried to put lisp in perl because I wanted to have a lisp with the power od cpan
[00:38:25] <gilberth> Hmm. I never had the urge to use some Perl libraries.
[00:38:57] <vms14> gilberth: there are a lot of oneliners that can be useful, specially when you have the cpan
[00:40:03] <gilberth> Still, I never had the urge. And for actual hacking I would prefer a full CL with a native code compiler.
[00:40:04] <vms14> but, my goal was because I see lisp as a black box, as something isolated from the outside world, and wanted to put perl as the hands of lisp, or as "the guy who does the dirty work"
[00:40:18] <vms14> where lisp would be the mind and perl the "body"
[00:41:27] <vms14> I'm looking at some forth videos and the guy has made a hello world, but it prints in reverse order xD
[00:42:17] <vms14> which is funny because it's like: *other languages*: "Hello world" *forth*:"dlrow olleH"
[00:43:19] <selwyn> cffi is a lot of work
[00:43:26] <selwyn> avoid if possible
[00:43:46] <selwyn> its also not easy to use a black box thats isolated from the outside world
[00:43:59] <shka> also, passing lisp stuff into C is a lot of hassle 
[00:44:02] <selwyn> yes
[00:44:15] <shka> calling C functions, pretty easy
[00:44:24] <shka> but lisp callbacks and stuff
[00:44:27] <shka> problem
[00:44:58] <selwyn> libraries that ffi into foreign code have to be well maintained
[00:45:17] <gilberth> selwyn: I use CCL. I could just run the modified gcc compiler over the header files in question to have FFI binding. Painless.
[00:45:40] <selwyn> i don't understand
[00:46:03] <gilberth> I never write FFI bindings by hand.
[00:46:11] <selwyn> you build ccl with the c library of your choice?
[00:46:48] <selwyn> or does it have a modified gcc
[00:47:23] <gilberth> CCL has a database of the C function prototypes and C data types. You run a modified gcc over the header files to generate those. Then in your code you just say (#_funny_c_fun 1 2 3).
[00:47:41] <selwyn> i see
[00:49:21] <selwyn> does anyone know what the timeline on the clasp release is?
[00:50:16] <gilberth> I have something different, which is --- again --- not finished. It works like a C->CL compiler actually. It could read and parse the header files and in your CL you could then mix C and Lisp freely. C macros are no problem, as this goes though the C->CL compiler. 'getc' is actually a macro? No problem, you still write (#_getc f) in Lisp. C is generated like getc(f) and subjected to the C->CL compiler which would expand the 'getc'.
[00:52:00] <gilberth> You can also say #_(getc(@f)) which is C and '@' is the escape back to Lisp. So to access a 'width' field of some 'bbox' field of what (FOO) returns, you can say #_(@(FOO)->bbox.width).
[00:53:13] <selwyn> cool
[00:53:16] <gilberth> Anyhow, as nice as the CCL ffi database is, as awkward is the actual API to manipulate C data structures.
[00:54:04] <gilberth> selwyn: Yep, one of my unfinished projects. I wrote it for the GTK backend of my Free-CLIM to come.
[00:55:29] <gilberth> Another note on CCL: It comes with a very nice Objective-C bridge build upon its FFI. You can actually use CLOS to define new Objective-C classes.
[00:55:59] <selwyn> https://clasp-developers.github.io/clbind-doc.html
[00:56:00] -ixelp- Exposing C++ Libraries with clbind
[00:56:00] <gilberth> And Objective-C you need to address the GUI with a Mac.
[00:59:54] *** Joins: dra (~dra@2a04:4540:6400:c900:6d9c:9eae:1ccb:cbea)
[00:59:58] <dra> Hello!
[01:02:08] *** Joins: mgl (~mgl@cpc87455-finc19-2-0-cust234.4-2.cable.virginm.net)
[01:11:56] <vms14> btw if you publish all your implementations it's likely the js one (if exists) will be the most used, as long as is eaasy to add to node/browser
[01:12:31] <vms14> and as long as has dom access or js interop
[01:13:01] <vms14> just realized cause I was looking at this
[01:13:04] <vms14> http://forth.thi.ng/
[01:13:37] <vms14> it has some words like js-create-element *js-document* *js-window* and more
[01:14:11] <vms14> I think I saw this or a similar one some time ago
[01:14:35] <vms14> and there are some lisp implementations for the browser
[01:14:39] <selwyn> i don't know about most used
[01:14:40] <vms14> didn't like them
[01:14:55] <selwyn> how many people are writing forth in the browser? compared to microcontrollers or whatever
[01:15:07] <skeemer> vms14, at the moment i like both... but i have a slight preference for common lisp when it comes to actually do stuff... this is for two reasons i guess... 1) i am not experienced... 2) it seems that the scheme world is too sharded with many implementations who only have a bunch of libraries for a subset of things and it seems you are expected to write your own stuff 
[01:15:19] <selwyn> that said, i like the look of scheme that targets js
[01:15:30] <skeemer> so i am not still so hardcore to use a scheme in real life... of course unless we go on racket... but that is not a pure scheme 
[01:15:52] <vms14> selwyn: I don't think many people use forth
[01:16:00] <vms14> it's even less popular than lisp
[01:16:09] <skeemer> vms14, what i like about scheme is the minimalism associated with it
[01:16:23] <skeemer> i like the idea of ideally being able to write my own scheme 
[01:16:29] *** Quits: serbest (~ike@user/serbest) (Quit: Konversation terminated!)
[01:16:40] <vms14> and the fact it's historically tied to assembly and cheap devices makes it even worse
[01:16:53] <skeemer> this said, i think chicken scheme is one of the most interesting schemes i played with 
[01:17:23] <vms14> skeemer: that minimalism of scheme will never be present as it's likely you'll use a scheme implementation with "batteries included"
[01:17:49] <vms14> as for cl, I started with cl and when I saw scheme didn't like the differences
[01:18:47] <vms14> but as features over scheme, dirty macros + gensym, clos, and much more "builtin" functions, the loop macro and the format function
[01:18:55] <vms14> and keywords :D
[01:19:41] <vms14> but, if you for example want to use SDL, make a web server, or whatever X thing is likely you'll be able to do in both
[01:19:54] <vms14> and racket seems nice
[01:20:08] <vms14> when I saw it first time looked like the best toy language
[01:20:26] <vms14> but it's not a toy language, it's very powerful and has a lot of libraries
[01:21:26] <vms14> also you have continuations and define-syntax which never learned what really does, but it's supposed to be similar to a macro. And racket has more stuff like pattern match and idk what contracts where
[01:21:49] <vms14> also it's easy to keep dsl organized there, which is nice, as lisp programs are usually dsl
[01:22:09] <vms14> domain specific languages
[01:23:12] <vms14> what I like from lisp is you are able to transform the problem into a thing the language can understand and it ties much better to the language
[01:24:48] <vms14> btw continuations in forth are something simple, you fuck with the return stack of the language
[01:25:13] <vms14> you can drop items from there and would result in a function exit
[01:25:54] <vms14> i have to undrstand more, as idk how I should implement the return stack
[01:27:37] <vms14> words are address of memory that points to native code or lists of words which are indeed lists of those addresses, for every word you put stuff in the return stack and when the word finishes you use the return stack to return where you called that word
[01:33:14] <vms14> https://www.reddit.com/r/Forth/comments/28f7rs/comparison_of_common_lisp_and_forth_macro/
[01:33:15] -ixelp- Comparison of Common Lisp and Forth macro capabilities : Forth
[01:38:35] <vms14> how I make a repl for a transpiler?
[01:39:03] <vms14> should I compile every line of code and link it dinamically like with dlopen?
[01:39:55] <vms14> dynamically*
[01:40:28] <vms14> I don't have any other idea than this or recompile the whole thing
[01:45:17] <skeemer> vms14, i don't see why common lisp is not more popular
[01:45:24] *** Quits: dra (~dra@2a04:4540:6400:c900:6d9c:9eae:1ccb:cbea) (Quit: Leaving)
[01:45:26] <skeemer> i mean now we have clojure which is sortr of becoming popular
[01:45:44] <skeemer> i still have to get a precise idea on it... but seems pretty cool, but no tail call optimization
[01:45:57] <skeemer> what about common lisp, sbcl does it perform tail call optimization? 
[01:46:04] <skeemer> or it is something just related to schemes? 
[01:46:33] <random-nick> scheme's specification requires implementations to do tail call optimization, CL's does not
[01:46:43] <vms14> skeemer: popularity is strongly related with the job market
[01:47:01] <vms14> the more popular the language the better job market has and viceversa
[01:47:01] <random-nick> and clojure doesn't do TCO probably because the JVM doesn't let it
[01:47:03] <White_Flame> sbcl does TCO, but it also depends on optimization declarations
[01:47:21] <vms14> clojure is popular because tarjets the jvm and has java interop
[01:47:29] <vms14> so it's stealing java popularity
[01:47:42] <vms14> targets* xD
[01:48:39] <vms14> the reason lisp is not popular is because people can see the benefit on ivesting time learning it
[01:49:11] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 256 seconds)
[01:49:55] <vms14> before you see the power of a macro you need to learn basic lisp stuff in order to be presented with macro examples and understand what can they do and how they do it
[01:50:05] <White_Flame> however, lisp is getting to be less of a "dirty word" and more respectable in concept
[01:50:26] <White_Flame> with the non-lisp majority in general, IMO
[01:50:35] <vms14> so I cannot put a macro to a nonlisper and expect him to understand it, and if it understands the example is so simple that cannot excite him
[01:50:59] <vms14> White_Flame: cause functional programming is being a thing lately
[01:51:05] *** Joins: aeth (~aeth@user/aeth)
[01:51:33] <vms14> people starts realizing fp really helps to build maintainable and extensible code
[01:51:50] <vms14> specially when fp seems to be parallel friendly
[01:52:03] <White_Flame> except lisp isn't really FP, its strenght is code-is-data, especially re macros
[01:52:24] <vms14> yes, but it's fp related, therefore the respect you start to see
[01:53:00] <vms14> and it's like one of the best introductions to fp since it encourages it but does not force you
[01:53:14] <vms14> also fp and trees are a nice match
[01:53:29] <vms14> and lisp is a tree processor
[01:55:01] <skeemer> vms14, i don't know i just hope that people wouldn't look at common lisp as many look at COBOL, as an old and ugly language which just remained around for legacy reasons
[01:56:31] <vms14> White_Flame: how botttom up programming and fp are related?
[01:56:49] <vms14> I think they kind of retroaliment each other but cannot explain
[01:57:31] <vms14> skeemer: people just see parenthesis and thinks wtf
[01:58:30] <vms14> also lack of documentation, libraries, devs (community)... compared with other mainstream languages they're used to know about, makes them go away
[01:58:46] <vms14> cause they don't see lisp provides any value for them
[01:59:24] <vms14> and if you ask stuff like this to lispers, lispers will say "if they don't want to use it, who cares"
[02:00:07] <vms14> but somehow it seems this attitude is what is "killing" the language
[02:00:18] <vms14> although lisp will never die
[02:00:50] <vms14> but even if you want to be a lisp advocate, it's hard
[02:01:17] <vms14> I've talked with a lot of programmers and always tried to explain them what macros are and give them a lot of examples
[02:01:30] <vms14> even translating the code to their langs
[02:01:52] <vms14> sometimes they kind of realize some stuff, but they won't move
[02:02:08] * hayley continues to believe that communities only serve the purpose of justification for "source: dude trust me"
[02:02:36] <vms14> it looks something esotheric, which kind of, because learning lisp is a bit like learning programming again
[02:03:18] <vms14> hayley: I did stalk you today too
[02:03:41] <vms14> I found you in freelancer xD and heared your voice but no real photo :/
[02:03:47] <vms14> heard*
[02:04:54] <hayley> https://theanarchistlibrary.org/library/apio-ludd-i-want-friends-not-community-my-comrades
[02:04:55] -ixelp- I Want Friends, Not Community / My Comrades | The Anarchist Library
[02:05:19] <vms14> hah you fool, lispers have no friends
[02:07:49] *** Quits: cosimone (~user@93-47-229-224.ip115.fastwebnet.it) (Remote host closed the connection)
[02:07:51] <vms14> why do you think lisp was created in ai labs
[02:08:27] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[02:25:51] <hayley> moon-child: FWIW the paper is "Rust as a language for high performance GC implementation" <https://users.cecs.anu.edu.au/~steveb/pubs/papers/rust-ismm-2016.pdf>. But indeed no mention of optimising around aliasing.
[02:45:35] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Quit: taking a break.  remember kids, sekai is better than kotonoha)
[02:56:14] <vms14> hayley: do you like stuff about jit?
[02:57:14] <vms14> a guy just gave me a pdf that could serve me as introduction for how a jit compiler works, but maybe it's more useful for you as it's not an introduction but more about providing a jit able to perform security checks
[02:58:00] *** Joins: masinter (~masinter@c-73-158-116-21.hsd1.ca.comcast.net)
[02:58:31] <vms14> https://cdn.remexre.xyz/files/52d2ed3238f6d3c4fb6715a97329bb64b2247e6c.pdf
[02:59:35] <moon-child> https://dl.acm.org/doi/10.1145/3434327  newer
[02:59:36] -ixelp- Formally verified speculation and deoptimization in a JIT compiler | Proceedings of the ACM on Programming Languages
[03:00:30] <masinter> whether a compiler is a JIT compiler depends on how long it takes to compile
[03:00:56] <vms14> lol moon-child that's the link he gave me and it makes me subscribe so I told him and gave me the other link
[03:01:27] <remexre> vms14: no, moon-child's link is to a later work
[03:02:05] <remexre> just, both are POPL papers
[03:02:05] <vms14> oh right
[03:02:07] <moon-child> masinter: I think there is a more interesting interpretation of 'JIT' as a mechanism to compensate for runtime dynamism or divergence
[03:02:10] <vms14> https://dl.acm.org/doi/pdf/10.1145/1706299.1706313 it's this one
[03:02:11] -ixelp- Verified just-in-time compiler on x86 | Proceedings of the 37th annual ACM SIGPLAN-SIGACT symposium on Principles of pro [...]
[03:03:30] <masinter> if your compiler is fast enough you could jusst compile everything.. don't need to postpone or only compile for a few percieved optimizations
[03:03:48] *** Quits: shka (~herr@109.231.0.226) (Ping timeout: 240 seconds)
[03:04:06] <moon-child> again: the point of JIT is not to compensate for compiler slowness but for language dynamism
[03:04:13] <moon-child> inline caching, hot/cold ordering, ...
[03:04:40] <moon-child> (or, rather, the interesting distinction, imo)
[03:04:44] <vms14> masinter: I'd do something like (system "gcc -o stuff") (dlopen "stuff") xD
[03:05:21] *** Quits: iquites (sid77830@id-77830.lymington.irccloud.com) (Ping timeout: 245 seconds)
[03:05:54] *** Joins: iquites (sid77830@id-77830.lymington.irccloud.com)
[03:05:57] *** Quits: neominimum (sid537410@user/neominimum) (Read error: Connection reset by peer)
[03:06:00] *** Quits: sunarch (uid526836@user/sunarch) (Read error: Connection reset by peer)
[03:06:02] *** Quits: pl (sid98063@id-98063.helmsley.irccloud.com) (Read error: Connection reset by peer)
[03:06:09] <vms14> moon-child: my goal was to know how can you provide a repl for a transpiler
[03:06:21] *** Joins: neominimum (sid537410@user/neominimum)
[03:06:27] <hayley> Self the Video strongly suggests their JIT is tuned to avoid noticeable pauses due to compilation.
[03:06:28] *** Joins: sunarch (sid526836@user/sunarch)
[03:06:35] *** Joins: pl (sid98063@id-98063.helmsley.irccloud.com)
[03:06:38] <vms14> and the only way I can think of is gcc and dlopen
[03:07:02] <hayley> They also tracked a metric like "minimum mutator usage" for GCs, to avoid doing lots of short compilations in one go.
[03:07:07] *** Quits: mgl (~mgl@cpc87455-finc19-2-0-cust234.4-2.cable.virginm.net) (Ping timeout: 256 seconds)
[03:08:06] <vms14> yet a repl is only for dev purposes and there is no efficiency stuff, but doing gcc + dlopen for every line or even for only some stuff like (defuns) or provide raw native code insertion does not seem nice
[03:08:37] <remexre> if you really want to avoid your own codegen, there's also libtcc
[03:08:54] <remexre> though tcc's support for platforms other than i686 and amd64 is kinda ehhhh
[03:09:16] <moon-child> why ehhhh?
[03:09:34] <hayley> ECL and SBCL interpret the easy stuff, and only compile hairy forms.
[03:09:52] <remexre> moon-child: as of 2019 it consistently miscompiled varargs for aarch64-linux
[03:11:20] <moon-child> remexre: I had miscompiled varargs on amd64 quite recently, just sayin
[03:22:55] <masinter> there's evidence of some work on a JIT for medley/maiko for running "native"
[03:23:43] <masinter> i think the little endian factor ruled it out
[03:24:49] <vms14> found something familiar in a forth book
[03:25:04] <vms14> https://i.imgur.com/mVsLJrp.png
[03:25:30] <vms14> it's like http://www.tommarkson.com/lisp/pride/history.gif and other lisp dialects trees I've seen
[03:28:36] <masinter> Those kinds of diagrams are really over-simplification
[03:28:46] <masinter> take LOOP
[03:29:21] <masinter> Interlisp has "iterative statements"
[03:30:43] <masinter> LOOP became part of common lisp
[03:31:13] <masinter> I did it originally as a macro for LISP/360
[03:33:29] <masinter> ideas moved from implementation to implementation one by one
[03:35:28] <masinter> it's harder to draw or make sense of a chart with so many nodes
[03:39:51] *** Joins: lucerne0 (~lucerne@ip202.ip-51-178-215.eu)
[03:40:33] <White_Flame> I think it's even more true with forth
[03:41:09] <White_Flame> chuck moore hated that there was a standard, as it was supposed to be an exploratory language where you make your own primitives
[03:41:17] <White_Flame> I'm under the impression that mccarthy had somewhat similar ideas about lisp
[03:41:33] <moon-child> my impression is that most forth people eschewed the standardised version
[03:41:34] *** Quits: lucerne (~lucerne@ip202.ip-51-178-215.eu) (Ping timeout: 250 seconds)
[03:41:35] *** lucerne0 is now known as lucerne
[03:41:38] <White_Flame> so the lanuages intentionally drifted & cross-pollinated all over the place
[03:42:12] <White_Flame> the prolog community actively eschews its standard, and has replaced a lot
[03:42:27] <masinter> common lisp resulted from design-by-committee literally
[03:42:44] <moon-child> apl standardisation was also a colossal failure
[03:43:05] <masinter> common lisp apparently wasn't an utter failure
[03:43:42] <masinter> people use it for real projects
[03:43:52] <moon-child> ;o
[03:44:53] *** Quits: minion (~minion@common-lisp.net) (Remote host closed the connection)
[03:45:25] <masinter> ietf does "review by committee" and "design by design team"
[03:46:09] *** Joins: minion (~minion@common-lisp.net)
[03:46:13] <masinter> the WHATWG requires implementation buy in
[03:47:24] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 240 seconds)
[03:48:28] *** Joins: aeth (~aeth@user/aeth)
[03:48:56] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Ping timeout: 272 seconds)
[03:50:20] <hayley> So, Chrome sets standards?
[03:50:56] <masinter> there's a process you can find on whatwg.org
[03:52:19] <hayley> https://www.youtube.com/watch?v=xDHQaZVh7ts
[03:52:19] -ixelp- Lyrically Speaking with Ron Mael (Special Guest Reader Edition): "Hasta Mañana Monsieur" - YouTube
[03:53:41] <masinter> hayley if you mean "effectively" yes
[03:55:35] <hayley> .oO("AI isn't sentient, it just does maths on its inputs set by training data" Let me tell you about what neurons do!)
[03:55:51] <selwyn> well, what neurons are thought to do
[03:55:53] <selwyn> but ok
[03:56:35] <hayley> That's what my neurons thinks your neurons think about what scientist neurons think neurons do.
[03:56:56] *** Joins: iamFIREc1 (~iamFIREcr@user/iamfirecracker)
[03:56:56] <hayley> I say that some of those neurons are gonna lie, and we better cut them out.
[03:57:28] *** Quits: Alfr (~Alfr@user/alfr) (Killed (strontium.libera.chat (Nickname regained by services)))
[03:57:33] *** Joins: Alfr (~Alfr@user/alfr)
[03:57:53] *** Quits: minion (~minion@common-lisp.net) (Remote host closed the connection)
[03:57:54] *** Quits: lucerne (~lucerne@ip202.ip-51-178-215.eu) (Quit: Ping timeout (120 seconds))
[03:58:18] *** Joins: lucerne (~lucerne@ip202.ip-51-178-215.eu)
[03:58:54] *** Joins: minion (~minion@common-lisp.net)
[03:59:17] *** Joins: masinter_ (~masinter@c-73-158-116-21.hsd1.ca.comcast.net)
[03:59:43] *** Quits: iamFIREcracker (~iamFIREcr@user/iamfirecracker) (Ping timeout: 272 seconds)
[03:59:57] <masinter_> haley AI is a goal, not a fact
[04:00:17] <hayley> AI is when it doesn't work.
[04:00:21] *** Quits: masinter (~masinter@c-73-158-116-21.hsd1.ca.comcast.net) (Ping timeout: 272 seconds)
[04:01:00] <hayley> I know a Haley but I don't think she has anything witty to say about AI.
[04:02:13] <masinter_> https://larrymasinter.net/85-ai-tutorial.pdf#page=4 from 1985
[04:04:12] * hayley has a server outage, but at least the cause is funny.
[04:04:17] <hayley> "A contractor for the building cut a water main on another floor. This flooded 2 floors, and a generator room. This affected one of our generators and a transfer switch. We were not allowed in until Fire Dept gave go ahead. Currently this is all being worked on live. Hope to be fully resolved within the hour."
[04:26:38] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[04:35:10] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Ping timeout: 272 seconds)
[05:06:58] *** Quits: vms14 (~user@29.red-79-153-202.dynamicip.rima-tde.net) (Remote host closed the connection)
[05:34:21] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[05:35:10] *** Quits: random-nick (~random-ni@87.116.181.150) (Quit: quit)
[05:44:13] *** Joins: Rue (~rue@2001-b011-1000-17d9-d616-1cce-b758-6ab8.dynamic-ip6.hinet.net)
[06:12:35] <gilberth> Ok. I am at like 5ms latency now. Next stop: Use some binary tree for the output record of the input buffer, so that it will scale. It should be feasible to use the input editor for modest size multi-line input. I wonder, if I could get away with what is incremental redisplay essentially.
[06:13:04] * hayley now tries to think of what to write in the MMTk porting channel.
[06:14:44] <gilberth> "Hi there, I am hayley, your local GC addict who sleeps with the GC handbook under her pillow! Any advice for porting MMTk?" :)
[06:16:02] <hayley> "Hi everyone, I'm thinking of using MMTk for SBCL but I want to check what'll need to be done. SBCL has weak references, vectors, hash tables (with key, value, or both being weak), and the Lisp side has an idea of a TLAB with assembler snippets for inline allocation. However, I cannot start off with the no-GC test, because it is impossible to bootstrap SBCL that way. And the build process generates C code to refer to structures defined in Lisp,
[06:16:02] <hayley> so either I would retarget that or write some parts of the GC in C."
[06:16:45] <hayley> "It would also be nice to have list linearisation, where lists are laid out so that the rest of the list is close to a cons cell, and some people want incremental or concurrent GC too. But I'll settle for parallel myself."
[06:17:08] <gilberth> You have hash tables on object identity.
[06:18:01] <hayley> "Also, I can barely write enough Rust to make a benchmark, nor can I write working GCs, but I would be willing to work on these things. And we have hash tables with address-based hashes, and conservative stack scanning because SBCL doesn't generate maps."
[06:18:09] <gilberth> Having weak hashtables is not the issue here, you named weak pointers already. I guess that EQ hashtables are.
[06:18:28] <mfiano> hayley: THat was funny coming from you.
[06:18:36] <gilberth> Oh, that's the Rust thing? I'd port that to C.
[06:18:39] <hayley> They have likely implemented weak pointers for Java, but I think arbitrarily weak key/value/key+value tables are new. And so are weak vectors.
[06:18:50] <hayley> gilberth: No can do, the point here is to avoid writing a parallel GC.
[06:19:05] <gilberth> ?
[06:19:12] <hayley> Oh, also SAVE-LISP-AND-DIE support too.
[06:19:23] <hayley> MMTk is a library which has parallel moving GC already.
[06:19:51] <gilberth> Yes, and if its so great, for SBCL, I would port it to C.
[06:20:59] <mfiano> "Rust". "0.1 experimental status". Move along.
[06:21:55] <hayley> drmeister is using MMTk for Clasp, and the library is a port of the GC module of some JVM (which was also called MMTk).
[06:22:05] <gilberth> Well, I would be concerned about Rust not even having a spec. It's a moving target and a random language du jour.
[06:22:13] <mfiano> ^
[06:23:18] <hayley> My hands are tied here. I can't manage to make gencgc parallel, the MPS is apparently run by lunatics, and MMTk is the only not-shit option I can think of.
[06:23:20] <moon-child> so, probably not for production, but fine for playing with
[06:24:08] <hayley> It's also funded by the Australian government. When has that ever made bad investment decisions?
[06:24:16] * hayley avoids making eye contact with the laid-off seL4 team.
[06:28:08] <moon-child> hmm.  In html, I want some text to be right-aligned
[06:28:29] <moon-child> so I do: <table><tr><td style=width:100%>foo</td><td style=width:100%;text-align:right>bar</td></tr></table>
[06:28:49] <moon-child> this seems to do the right thing
[06:28:53] * gilberth spares a few single quotes.
[06:29:05] <moon-child> if I don't have width:100% on the first td, it is made very narrow
[06:29:19] <moon-child> but is this guaranteed?  That space will be given first to the first td and then to the second?
[06:29:44] <gilberth> It is.
[06:30:42] <gilberth> You could also still invoke HTML and say <TD ALIGN=RIGHT> --- A matter of taste.
[06:31:46] <moon-child> thanks!
[06:31:48] <gilberth> You want the second column as narrow as possible?
[06:32:14] <gilberth> The table spanning the whole width? The first column taking all not needed by the second?
[06:33:26] <moon-child> I want the first column to take up as much space as it likes, and then the contents of the second column to be along the right edge of the parent
[06:34:19] <gilberth> Define "it likes".
[06:35:10] <moon-child> I'm transcribing something like this https://0x0.st/o89z.png
[06:35:42] <gilberth> Is "Proof:" another column?
[06:35:50] <moon-child> I want the QED on the right, and the equations on the left
[06:35:52] <moon-child> yeah
[06:36:07] <gilberth> And QED flush bottom?
[06:36:47] <moon-child> yeah
[06:37:35] <gilberth> <table width=100%><tr><td valign=baseline nowrap=nowrap>Proof:<td valign=baseline width=100%>For x blah blah<td valign=bottom align=right nowrap=nowrap>QED</table>
[06:37:37] <moon-child> right now I do <tr><td>Proof</td><td>line 1</td></tr>  <tr><td></td><td style=width:100%>line 2</td><td style=width:100%;text-align:right>QED</td></tr>  and it looks good
[06:38:38] <gilberth> Put both lines into just one table cell.
[06:39:00] <gilberth> valign= then does the trick for you.
[06:40:11] <moon-child> thanks!
[06:40:34] <gilberth> At your service.
[06:44:44] <gilberth> For QED you could also use a floating box. Like <TD>For all epsilon < 0 blah <BR>line 2 blah <SPAN style='float:right'>QED<SPAN>
[06:46:05] *** Joins: dave0 (~davezero@069.d.003.ncl.iprimus.net.au)
[06:46:54] *** Quits: masinter_ (~masinter@c-73-158-116-21.hsd1.ca.comcast.net) (Ping timeout: 272 seconds)
[06:47:33] <moon-child> ah right, I forgot about float
[06:47:46] * moon-child hasn't touched web seriously in quite a while, and never knew too much about it anyway
[06:48:59] * hayley has posted a wall of text about hard things in the SBCL runtime
[06:49:41] <hayley> https://plaster.tymoon.eu/view/2952
[06:59:13] <gilberth> moon-child: CSSish solution w/o tables: http://clim.rocks/gilbert/some-css.html
[07:01:06] *** Joins: iamFIREcracker (~iamFIREcr@user/iamfirecracker)
[07:01:36] * moon-child bonks gilberth
[07:02:39] <hayley> "Note: Don't try at home!"
[07:02:40] <hayley> Shit, can't read the proof.
[07:03:07] *** Quits: iamFIREc1 (~iamFIREcr@user/iamfirecracker) (Ping timeout: 256 seconds)
[07:03:11] <gilberth> Your Lorem is too rusty?
[07:03:50] <hayley> Too soon!
[08:06:54] * hayley watches copying between two USB 3 hard drives run at like 16 MB/s
[08:07:11] <hayley> You wouldn't even saturate USB 2 and its 400 Mbits(?) right?
[08:08:36] *** Joins: semz_ (~semz@user/semz)
[08:10:56] <White_Flame> is the write drive SMR?
[08:10:57] *** Quits: molson (~molson@172-103-21-94-dynamic.midco.net) (Remote host closed the connection)
[08:11:05] *** Quits: semz (~semz@user/semz) (Ping timeout: 250 seconds)
[08:11:28] <hayley> Good question. I don't know.
[08:11:39] <hayley> But AIUI that sucks for write speed, right?
[08:12:04] <White_Flame> yep
[08:12:08] <White_Flame> I got <5MB/sec with mine
[08:12:18] <White_Flame> on an 8TB "archive" drive
[08:12:26] <hayley> I bought a cheap hard drive, and I got a cheap hard drive. What did I expect?
[08:12:39] <White_Flame> I did finally find a place for it as a PS4 external drive, since 5MB/sec is faster than my internet connection anyway
[08:12:53] <White_Flame> and that's mostly WORM style access
[08:12:53] <hayley> But it still seems to be humming around 16MB/s on a 2 TB drive, which is somewhat less bad.
[08:13:07] <White_Flame> if it's 2TB then it's probably not SMR
[08:13:17] <hayley> I did get a "backup drive" at first, but the cashier told me another was on sale. So I got the latter.
[08:13:36] <White_Flame> but it might be a USB2 hub, and 16MB read + 16MB write + overhead = 400Mbits?
[08:13:46] <moon-child> White_Flame: WORM?
[08:13:52] <White_Flame> write-once, read many
[08:13:53] <moon-child> Write-Only something?
[08:13:53] <hayley> "Write once, read many"
[08:13:55] <moon-child> ah
[08:14:18] <hayley> Hm, I believe USB 3 hubs and cables here. And one external drive is being read from, and the other being written to.
[08:14:38] <White_Flame> and the computer's port is usb3?
[08:14:59] <hayley> Yes.
[08:15:06] <White_Flame> welp, something sucks
[08:15:33] <hayley> Should've went to the proper computer store. At least then I could look at the model numbers, which the more "consumer" one I went to is not too good at showing.
[08:16:02] <hayley> Was going to ask the former store what they thought about getting a CPU this year, too.
[08:16:12] <White_Flame> meanwhile, my brand new 18TB drive works and reports OK, but constantly clicks the head around and has tens of millions of SMART read/seek errors and growing
[08:16:12] *** Quits: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se) (Ping timeout: 272 seconds)
[08:16:30] <White_Flame> I wonder if newegg is going to deny my RMA when they receive it
[08:16:55] <White_Flame> AMD has said that they expect 2nd half of this year to start to get better
[08:16:56] <hayley> Are you sure you got a hard drive?
[08:17:14] <White_Flame> as opposed to a floppy one?
[08:17:32] <moon-child> perhaps I can finally get a gpu!  Though I wanted an nv one, but
[08:17:51] <hayley> As opposed to a few rocks in a metal case, I guess.
[08:18:35] <White_Flame> hayley: as I mentioned, it actually does work.  formatted without failure for a full slow write (took 2 days, 19 hours), as well as an extended full-surface SMART self-test
[08:18:46] * hayley gets an email notification on her phone, but the server is still down. Weird.
[08:19:15] *** Joins: molson (~molson@172-103-21-94-dynamic.midco.net)
[08:19:29] <White_Flame> I have a gtx1080 in my main machine, but the video has never been quite stable on it either on it or the intel igpu
[08:19:57] <hayley> By the second half of this year, I might have made a job appear out of thin air.
[08:20:04] <White_Flame> I probably need to resintall/upgrade the OS.  I had about a year of uptime that now reset with shutting it down to install the hard drive
[08:21:04] <hayley> Given that my justification for a more expensive CPU is more parallelism, and a 256-bit ALU on the side. The parallel GC is then justified by my intention to buy a new CPU with more cores.
[08:21:46] <hayley> I don't think I should have to keep growing the heap to keep REGRIND running on 24 threads smoothly.
[08:21:54] <hayley> 10 is already bad enough.
[08:22:03] <White_Flame> yeah, we do have a 1st gen threadripper for a server, but my main box is 4 core 6700k, laptop is 2 core 7500
[08:22:12] <White_Flame> need moar corez
[08:22:35] <moon-child> gilberth: ha, bonus: the table-based solution (without styles) renders correctly in elinks
[08:22:37] <White_Flame> but I'm not going to pay nutso prices, so I wait
[08:23:20] *** semz_ is now known as semz
[08:23:26] <hayley> Seems MMTk chat has settled down, but Steve and I disagreed on image dumping. Apparently it works for Julia already, but the issue is that SBCL image dumping basically memcpys to disk. So the heap cannot be relocatable, unless I use the patches pl mentioned.
[08:23:28] <gilberth> moon-child: I suppose elinks is some plain text browser?
[08:23:35] <moon-child> yes
[08:24:51] <gilberth> Well, I still use TABLE for layout and also attributes like ALIGN and VALIGN just because of that. However I use w3m. It's nice to be able to generate a plain text version of your document.
[08:25:04] <hayley> Also, SBCL _will_ allocate in the MMTk heap as part of bootstrapping (to compile new code from a "cold" image), so I cannot use the no-GC GC for more than approximately 10 seconds without swapping like hell.
[08:25:13] <gilberth> And it's a pitty that Firefox has no char-cell based plain cell backend.
[08:25:26] <hayley> But surviving 10 seconds on MMTk-without-the-GC is still success at that point, I guess.
[08:25:34] <moon-child> gilberth: actually, somebody did something like that
[08:25:42] <moon-child> firefox->text
[08:25:52] <gilberth> Oh, like 25 years late!
[08:27:39] <gilberth> Anyhow, I still use w3m for testing. BTW what do braille terminal users use?
[08:27:55] <moon-child> I don't know
[08:28:05] <moon-child> I think blind people usually use a screenreader for browsers
[08:29:33] <gilberth> I don't know what they use these days. One fellow student at my time at uni was blind and had a braille laptop running DOS and Linux. However uni had a service to support blind people; the blind students could get papers etc. manually transcribed to plain text for them.
[08:30:08] <gilberth> And I can't imagine editing source code with a screen-reader. Too little bandwidth.
[08:30:57] <hayley> I can't imagine most text documents with a screen-reader either due to bandwidth.
[08:31:17] <gilberth> It was just two rows of braille and the VGA text screen was mirrored to that braille rows, so they could use any text-based software.
[08:31:40] <hayley> You can make espeak speak pretty quickly (though perhaps not anyone's favourite TTS engine, idk) but sighted people cheat and abuse document structure, more or less.
[08:31:57] <hayley> A sort of visual prefetching, if you will.
[08:32:30] <gilberth> Blind people do that with braille, too. Said student was quick, real quick, on his braille terminal.
[08:32:44] <hayley> I'd link the relevant part of Terminal Boredom, but my server is still down ):
[08:33:08] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Remote host closed the connection)
[08:34:58] <hayley> But the "worst case" that I came up with was a decision tree of sorts (which I actually found). If you only have plain text, the best you can do is number each state, and your document is an ordered list. A sighted person can read down the left of the page to skim for the next state. A blind person...erm. No good unless you have a find feature that works all the time.
[08:36:33] <gilberth> As I said, you could scan with braille, too.
[08:37:10] <hayley> In any way where the reader doesn't consume all but the start of each paragraph?
[08:37:30] <hayley> s/all but the start of each paragraph/the entire text/?
[08:37:54] <gilberth> hayley, I am talking about braille.
[08:37:56] <moon-child> I wonder, could you use your entire hand, rather than just your fingertip?
[08:38:14] <gilberth> I never observed that.
[08:38:18] <hayley> I don't think most of one's hand is sensitive enough for it. But I haven't tried that.
[08:38:25] <moon-child> as a sort of 'peripheral vision': less precise, but suitable for scanning
[08:38:57] <hayley> gilberth: okay. Now I think it would be fair to have a command to skip paragraphs, in any case. So the reader would continually scan through the start of each paragraph.
[08:39:01] <gilberth> If you have a full-page braille device. Sure that should work.
[08:39:57] <gilberth> Don't know if those exist.
[08:40:17] <hayley> But, in my opinion, visual hacking due to clever layout makes scanning practical for sighted people.
[08:40:41] <gilberth> Of course, this is why we indent our code.
[08:41:40] <moon-child> I heard blind people find indentation useful too
[08:42:01] <hayley> It's a bit like what Steele was talking about with divide-and-conquer recursion and plain iteration; you can cheat your way out of many things by exploiting the two dimensions in otherwise un-structured text.
[08:42:06] <gilberth> On braille, yes. I keep repeating myself.
[08:42:36] <moon-child> for a screenreader, I mean
[08:42:50] <hayley> moon-child: I've heard tabs are more accessible, but I've never seen any evidence or reasoning for it.
[08:43:03] <gilberth> moon-child: Are you talking about a voice or tactile interface?
[08:43:25] <moon-child> hayley: poor editing environment, presumably, that says: 'space space space space space space space space' rather than 'tab tab'
[08:43:35] <hayley> Oh, someone did mention it for visual impairment: https://www.reddit.com/r/javascript/comments/c8drjo/nobody_talks_about_the_real_reason_to_use_tabs/
[08:43:46] <moon-child> gilberth: I read an anecdote from a blind person who used a voice interface and said indentation was helpful
[08:44:20] <gilberth> Ah, did the voice interface react somehow to the indentation?
[08:44:34] <moon-child> https://www.vincit.fi/fi/software-development-450-words-per-minute/  this, I think
[08:44:35] -ixelp- Software development 450 words per minute – Vincit
[08:44:41] <hayley> But I guess we are SOL for Lisp indentation.
[08:45:02] <moon-child> oh, no, it was braille
[08:45:07] <moon-child> nevermind
[08:45:14] <hayley> SOL = shit outta luck, since that apparently is not a very unique abbreviation.
[08:45:39] * moon-child has always enjoyed POS = Piece Of Shit / Point Of Sale
[08:45:50] <hayley> moon-child: Now's your chance to sell structural editing!
[08:46:25] <moon-child> ha, maybe
[08:46:29] <moon-child> that's a unique angle
[08:49:33] <hayley> I mean, I was saying that sighted people rely on visual hacks to recover structure in plain text before.
[08:49:47] <hayley> It appears to follow for source code.
[08:49:49] <gilberth> moon-child: Ah, he says that braille is much more efficient than a screen reader.
[08:52:06] <moon-child> well, I also see structural editing as having the potential to take _better_ advantage of visual layout to communicate structure
[08:52:23] <moon-child> and ultimately sighted people rely on visual hacks to recover structure from grids of pixels anyway
[08:52:31] <gilberth> I still hate tabs. It's a compression scheme. And an odd one, as the width of a tab depends on the current carriage position. diff's for instance break with tab.
[08:52:32] <moon-child> so I don't know how different it ultimately is
[08:53:54] <hayley> All just a thought, I shouldn't be put in charge of developing tools for people with visual impairments.
[08:54:55] <hayley> But I seem to have become a worse reader since 15 or so, so I am more dependent on visual hacks to get much done. Hence I don't like it when people suggest to put more information in unstructured plain text.
[08:55:21] <moon-child> 'I seem to have become a worse reader since 15 or so'  same! :/
[08:55:47] <aeth> tabs are great
[08:55:53] <aeth> I don't know how I could use Firefox without tabs
[08:56:25] <gilberth> The only trouble I have is black text on white background. My hunch is that this is some kind of neurological problem.
[08:57:35] <hayley> Another dilemma then: I am trying to figure out if there is a name for some combination of self-actualisation and circular logic. In TPOPOS I say something like "People argue that most people don't program, so don't prioritise making programming accessible, and thus most people will continue to not program, regardless of their desires." Someone asked me today, "why do they keep a game server on when no one is using it?" so I replied, "if the
[08:57:35] <hayley> server was off, no one could use it."
[08:57:52] <hayley> A positive feedback loop, perhaps.
[08:58:25] <gilberth> However, all that doctors say is *shrug*.
[08:59:54] <hayley> Well, I remember my sight being pretty good in high school. I could sit at the back of the science classroom (which was longer than it was wide) and read instructions on the whiteboard from there. Not that the writing was small, but the teacher didn't believe me.
[09:01:26] <hayley> Oh, what the fuck, now the drive copies at 70MB/s?
[09:01:39] <hayley> I guess I played myself, as the file manager insisted on doing two different copy tasks concurrently.
[09:03:53] <gilberth> Programming is more accessible these days than ever.
[09:05:01] <hayley> Tell that to people who think you should use Rust or C for everything, and who think writing maintainable code is a waste of time.
[09:05:35] <hayley> Again, would be nice to have the article on a working server.
[09:06:04] <gilberth> Still, these days you just need some machine and can get started. All tools, documentation, tutorials are readily available and free.
[09:06:27] <hayley> Sure. But then you will struggle to achieve anything.
[09:07:08] <hayley> It's sure gotten better, but people can still propose worse.
[09:07:19] <gilberth> Yes, learning programming isn't easy. You need discipline.
[09:07:20] <hayley> Oh, hey wait I do have a mirror of that particular article...
[09:07:30] <hayley> https://theanarchistlibrary.org/library/gnuxie-lulamoon-and-hayley-patton-the-poverty-of-post-open-source#toc2
[09:07:32] -ixelp- The Poverty of Post-Open Source | The Anarchist Library
[09:08:19] <gilberth> But it's way more accessible these days compared to the time I was a child. I had no teacher, just some BASIC manual. But I was lucky and had "machine".
[09:08:46] <hayley> Right.
[09:09:49] *** Joins: eugercek (~user@user/eugercek)
[09:10:05] <gilberth> So, if somebody really wants to get into hacking today, there is nothing stopping him or her. And plenty of information available.
[09:10:09] <hayley> But despite those changes, it can still be made worse. I wouldn't give a 12yo gilberth a C compiler and tell him to get on with it.
[09:10:49] <gilberth> That you need to be precise in your thinking is nothing that will ever change.
[09:11:24] <gilberth> hayley: I was 12yo as I wrote a Lisp interpreter in C. Easy.
[09:11:31] <hayley> Dammit.
[09:11:41] <hayley> You're no fun.
[09:11:55] <gilberth> 13yo as I won my first prize at a science fair.
[09:12:30] <hayley> #.(age gilberth)yo gilberth struggled with writing a Lisp interpreter in Rust, but that's not really the point.
[09:13:31] <gilberth> Yeah, I needed some time to find my way around with Rust.
[09:13:34] <hayley> Language and style choices can still be productivity foot-guns.
[09:14:33] <hayley> And if prominent figures in your "movement" argue that any effort put into style or design is worthless, then you are probably fucked.
[09:15:05] <gilberth> Sure, this is why I hacked my Lisp interpreter. The first version was with Pascal on my 8-bit machine. I was like 11yo IIRC. We had Lisp at school, and I wanted to have one at home.
[09:16:04] <hayley> (Arguably they were only talking about what you do at your day job, but this reminds me of the guy who argued that writing correct code was unimportant, as you just had to make customers happy. Tell me again when your business burns to the ground due to those bugs you don't care for fixing.)
[09:17:03] <gilberth> Anyhow, for me it was BASIC -> machine language (not assembly) -> Pascal and assembly | Lisp -> C -> Love-affair with Prolog -> Lisp
[09:18:10] <hayley> (This guy: https://www.reddit.com/r/programming/comments/se88im/dubious_achievement_comm_of_the_acm_34_4_april/hup2tas/?context=5)
[09:18:12] -ixelp- "Dubious Achievement", Comm. of the ACM 34, 4 (April 1991), 18. : programming
[09:18:25] <gilberth> So nothing changed. There two languages I actually use: CL and C.
[09:18:47] <edgar-rft> machine language is what we speak in irc
[09:19:13] <hayley> TL/DR: "What high quality software is nowhere set in stone by the universe. Software must be fit for its purpose." "The "relative perception of its users" is an ethical judgement, even though "don't kill me with your software" usually goes without saying."
[09:20:03] <hayley> (Ethics come into play because Henry Baker referred to the extreme of an embedded system killing someone. Granted, if they are dead, they will not dislike your product.)
[09:20:36] <gilberth> They won't like it either.
[09:21:05] <hayley> Tell me, who actually likes Windows?
[09:21:41] <gilberth> I steer clear of people liking Windows, so I don't know any.
[09:22:16] <hayley> I've seen a lot of people, and I can't think of anyone that likes Windows. People who can stand Windows, sure. People who actually have positive thoughts about it, no.
[09:22:53] <gilberth> So why do they use it then?
[09:23:12] <hayley> (Your next problem with this strategy, of course, would be the grieving family of the user. I assume you made enough money to bribe them to shut up.)
[09:23:28] <hayley> Because they don't dislike it enough to use anything else, I'd guess.
[09:23:40] <moon-child> gilberth: what happened with prolog?
[09:24:28] <gilberth> moon-child: Prolog and me drifted apart.
[09:24:29] <hayley> But what structure did I discover? It's a feedback loop, it's circular reasoning, a sort of Catch-22...
[09:24:38] <moon-child> but why?
[09:24:56] <hayley> Hooray, server is back.
[09:25:41] <hayley> https://www.webhostingtalk.com/showthread.php?t=1867356
[09:25:52] <gilberth> moon-child: I liked Lisp better. If only for the data structures. With Prolog being a single-paradigm language I felt a bit too constraint.
[09:26:23] <hayley> "Prolog" "I felt a bit too constrained"
[09:26:26] <moon-child> lol
[09:26:51] <gilberth> I never had constrains for my Prolog. Which I also have written myself.
[09:27:25] <hayley> Perhaps people who like such terms would find it not too wrong to say that such feedback encourages monocultures.
[09:27:55] <gilberth> Anyhow, it was nice, but I felt that for most tasks Lisp just was a better more verstile fit. I can't image CLIM in Prolog e.g.
[09:28:29] <moon-child> people are working on prolog gui
[09:29:22] <gilberth> Sure. But it begins with: How do you express a tree data structure with state? Assert relations with nodes named by gensyms?
[09:30:14] <moon-child> don't know.  I am not a prologger; maybe White_Flame knows
[09:30:17] <moon-child> but: https://cdn.discordapp.com/attachments/752244695668752424/934838668139565066/video-1642895359.mp4
[09:31:11] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Remote host closed the connection)
[09:31:34] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[09:31:44] <gilberth> moon-child: What's so exciting about that?
[09:32:11] <moon-child> doesn't seem particularly exciting.  Just: that's the extent of my knowledge of what people are doing with prolog and gui
[09:33:05] <gilberth> Well, you could do anything you wish with Prolog. It's just I felt more at home with Lisp.
[09:34:02] <gilberth> It's a pity though. There once was a Turbo Prolog by Borland. At times I wonder how a Turbo Lisp would have looked like.
[09:34:11] <GreaseMonkey> yellow on blue
[09:34:13] <moon-child> ha
[09:34:23] <gilberth> Right.
[09:35:09] <gilberth> In DOS times I was almost there. I married uemacs to xlisp. Or the other way around.
[09:36:58] <gilberth> Heh, could be fun project. Imagine WordStar keybindings with Lisp :-)
[09:41:02] <gilberth> Though there was AIDS which came with mulisp. The "artificial intelligence development system". A kind of IDE, it came with a structure editor.
[09:42:55] *** Quits: chiselfuse (~chiselfus@user/chiselfuse) (Ping timeout: 240 seconds)
[09:45:11] *** Joins: chiselfuse (~chiselfus@user/chiselfuse)
[09:45:53] <White_Flame> gilberth: prolog trees can be either a single data term that you traverse into, or a set of reified nodes each with their own ID
[09:46:38] <White_Flame> I think that stylistic preference probably prefers the former, for more atomic updates to it, if that single tree value gets asserted
[09:46:40] <gilberth> If the former you can't modify it.
[09:46:55] <White_Flame> update_tree(OldTree,K,V,NewTree)
[09:47:07] <White_Flame> or whatever
[09:47:16] <White_Flame> then retract OldTree & assert NewTree in a fact
[09:47:26] <gilberth> Well, then you have no EQ. Which perhaps more the issue.
[09:48:00] <White_Flame> although if it's a tree of gui widgets, then splaying them out into facts is probably more likely
[09:48:12] <White_Flame> generalized data trees I think would be held in a singular value
[09:48:36] <gilberth> Sure, I would do with facts for GUI widgets.
[09:49:11] <gilberth> Just keep the state you want to maintain in the data base. Name the widgtes by gensyms, when in doubt.
[09:51:01] <gilberth> But then you have pointers that are just pointers by its use. Something I don't like. Nothing better than using indices as pointers.
[09:52:39] <White_Flame> right, facts vs bindings almost feels like 2 different languages. they're completely separate styles
[09:54:11] <gilberth> It would feel like implementing structures by symbols. The symbol is the object and the slots are put onto the plist.
[09:55:27] <gilberth> e.g. (defun make-rect (w h) (let ((r (gensym "RECT-"))) (setf (get r 'width) w (get r 'height) h)) r) (defun rect-area (r) (* (get r 'width) (get r 'height)) etc.
[09:56:47] <gilberth> I have never seen Lisp used that way.
[09:57:42] *** Quits: pjb (~pjb@user/pjb) (Remote host closed the connection)
[10:00:42] *** Quits: dre (~dre@101.191.49.59) (Ping timeout: 272 seconds)
[10:08:09] <hayley> From my code from university in 2020: "// I paid the garbage collector in advance for this "clever" use of // copying to allow for some "concurrent" modification."
[10:12:11] <hayley> I also turned some low-resolution death screen drawings into string literals, because the game was all text art.
[10:26:19] * hayley uploaded an image: (17KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/EZUZAJPFWLxxefmondkrwZSv/the-many-deaths-in-this-assignment.png >
[10:26:23] <hayley> I should remaster this in CLIM.
[10:27:00] <hayley> https://jepsen.io/analyses/radix-dlt-1.0-beta.35.1 lol
[10:27:01] -ixelp- Jepsen: Radix DLT 1.0-beta.35.1
[10:27:37] * moon-child considers adding wrecking balls to slashem
[10:28:16] <hayley> The hazards in this game were ghosts, aliens, giant footballs, cacti and goblins.
[10:29:43] <hayley> ...as per the specification for the assignment.
[10:34:42] <hayley> "Here's a YourKit snapshot from one of those Radix nodes pushing ~12 txns/sec. Some of it's crypto (BouncyCastle), but it looks like it's burning a ton of time in BerkeleyDB IO. Roughly 1/3rd waiting for fsync. Rather a *lot* of fsyncs, as it turns out. Roughly 11 calls per txn on each node, at least in this particular run." lol
[10:35:32] <dave0> the rain is really coming down
[10:36:06] <moon-child> lol no high volume transaction processing without concurrency control, two phase commit, sql, or c++
[10:36:54] <hayley> Speaking of seL4, https://microkerneldude.org/2022/02/17/a-story-of-betrayal-csiros-war-on-ts/
[10:36:55] -ixelp- A Story of Betrayal: CSIRO’s War On TS | microkerneldude
[10:37:10] * gilberth killed one PROCESS-WAIT-WITH-TIMEOUT and wonder how many there are still hiding.
[10:38:20] <dave0> hayley: australia decided to take funding away from seL4 and put it into artificial intelligence lol
[10:38:33] <hayley> Yep.
[10:38:34] <hayley> Idiots.
[10:42:08] <dave0> hayley: remember when the (nsw?) govt introduced those digital vaccination certificates that were easily forged? they responded by putting a hologram in the pdf lol
[10:42:32] <dave0> they have no connection to reality
[10:42:50] <hayley> lol
[10:43:57] <White_Flame> a scan of a hologram?
[10:58:06] <dave0> White_Flame: apparently yes
[10:58:57] <dave0> i can visualise their thinking... "we put holograms on money so you can't forge it, lets put a hologram in the pdf so it can't be forged'
[11:00:38] <gilberth> You could perhaps also put watermarks into a PDF.
[11:00:55] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Ping timeout: 240 seconds)
[11:01:06] <gilberth> And coffee stains.
[11:06:53] <hayley> There's a TeX package for that, no?
[11:07:12] <hayley> https://texblog.org/2012/06/21/classic-coffee-stains-with-latex/
[11:07:12] -ixelp- Classic coffee stains with LaTeX – texblog
[11:07:21] * gilberth was waiting for someone mentioning it.
[11:07:52] * hayley tries to remember how the meme goes
[11:08:24] <hayley> "NO RUST DEPENDENCIES ALLOWED IN SWCL!!!1!" *MMTk exists* "Okay that one looks nice, I guess it can come in"
[11:09:27] <gilberth> hayley is slowly dragged to the dark side. We must do something about it and save her.
[11:10:04] <hayley> Hey, I'm trying to avoid it as much as possible. But I have no options here.
[11:10:34] <gilberth> That is what they all say: "I have no choice." You always have a choice.
[11:11:18] <hayley> Sure, I'll just live with SBCL's serial GC when I have 24 hardware threads busy doing stuff for me.
[11:11:22] <hayley> That'll work just fine.
[11:12:14] <gilberth> Just spawn 24 SBCL processes. Problem solved. Or don't get that many cores. :-p
[11:12:38] <hayley> One of my physicist friends: "Honestly out of all the government research organizations, CSIRO is by far the shadiest—they have such an emphasis on buzzwords that their website is borderline unreadable. Their (former Telstra) CEO made the whole thing into a glorified consulting agency."
[11:13:28] <hayley> Funny, I heard the former premier(?) of Queensland works at Optus now.
[11:14:34] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[11:15:10] <hayley> 24 SBCL processes take up more memory (I've tried about as many before, wouldn't recommend it). And I can't get a notably faster CPU that doesn't have more cores.
[11:31:52] *** Joins: shka (~herr@109.231.3.55)
[12:01:59] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[12:02:30] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[12:02:34] *** Quits: hugo (znc@verdigris.lysator.liu.se) (Quit: ZNC 1.8.2 - https://znc.in)
[12:02:52] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Client Quit)
[12:05:03] <selwyn> the university of queensland is really good at quantum physics
[12:07:10] *** Joins: cosimone (~user@93-47-231-171.ip115.fastwebnet.it)
[12:08:53] <selwyn> one of the main quantum computing architectures was partly invented there
[12:22:28] *** Joins: mgl (~mgl@cpc87455-finc19-2-0-cust234.4-2.cable.virginm.net)
[12:23:27] <hayley> https://www.youtube.com/watch?v=s37cUyTGRUM
[12:23:28] -ixelp- Firth Of Fifth (Remastered 2008) - YouTube
[12:25:12] <selwyn> https://twitter.com/no1border/status/1006256763014995973?lang=en
[12:35:16] <ck_> maybe he knows something we don't
[12:36:48] *** Quits: minion (~minion@common-lisp.net) (Remote host closed the connection)
[12:37:00] <ck_> or possibly that's the bridge's non-fungible token
[12:37:33] *** Joins: minion (~minion@common-lisp.net)
[12:47:05] <selwyn> lol
[12:54:48] <hayley> https://twitter.com/stevemblackburn/status/1494240906006110209 "[Barrier] Overhead now as low as 0.8% on a modern AMD CPU (was 1.8%)."
[13:03:18] * hayley uploaded an image: (366KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/cNvSzEjFuCHZajdghMiudhId/barrier-overhead.png >
[13:15:48] <shka> how is data in the sbcl image really stored?
[13:16:05] <shka> what happens when image is loaded?
[13:16:21] <hayley> It's a bit for bit copy of the heap IIRC.
[13:16:40] <moon-child> aha!  I think I have gotten somewhere with my bezier curve sdf
[13:17:07] <moon-child> 1: we can approximate the curve with a circle; pick a focus, shoot a ray from that focus through the point being sampled to pick an initial guess
[13:17:28] <moon-child> 2: the point on the curve which is closest to the point being sampled will have a normal which points towards it
[13:17:59] <shka> hayley: and what when image is loaded? memory working set suggest that data is in the virtual memory, but not actually in the ram?
[13:18:01] <moon-child> and the normal is much easier to work with than the 5th-degree polynomial I would need to wrangle if I searched for roots instead
[13:18:13] <shka> what kind of sorcery is this
[13:20:49] * hayley reads output_space in src/runtime/save.c
[13:21:44] <hayley> I guess things seem page aligned, so SBCL could mmap.
[13:23:02] <shka> or maybe some linux trickery 
[13:24:39] <hayley> src/runtime/os-common.c load_core_bytes seems to mmap.
[13:24:50] <hayley> Of course, only if you don't compress cores, which I tend to. ):
[13:25:37] <gilberth> Don't and the 24 SBCL instance might share RAM.
[13:25:37] <shka> linux has some low level mechanisms for copy on write memory (outside of fork)
[13:26:39] <gilberth> shka: MAP_PRIVATE is standard and nothing Linux specific.
[13:27:29] <hayley> "190W under `stress -c 64 -m 2048 --vm-bytes 1048576` with cores derestricted" "hey its me ur sister can I have ur cpu" "no"
[13:27:29] <shka> gilberth: thanks, i am not well versed in the unix programming actually
[13:27:32] <hayley> What do I do now?
[13:28:48] <shka> anyway, it is pretty funny because i have 513 mb sbcl image 
[13:29:10] <shka> it happens to have the whole counter-strike de_mirage map in it
[13:29:41] <shka> but memory working set is low, even for workloads that go through all of that
[13:29:49] <shka> NEAT
[13:37:00] <shka> i guess that's because there is no modification of those memory pages
[13:37:29] <shka> gilberth: i got that right?
[13:58:26] <gilberth> When the pages are just mmap(2)ed and not actually written or read, they may as well still sit on the disk and not make it to the RAM.
[14:00:26] <shka> even if accessed a lot?
[14:01:31] <gilberth> Well, when you actually read those 500+ MB the kernel has to read them from disk.
[14:02:25] <gilberth> But when you don't write, the kernel could later just drop free up the RAM, as it knows where to get the data.
[14:02:38] <gilberth> s/drop//
[14:03:59] <gilberth> A medium stage is that those pages are part of the FS cache and not of your process proper. That are those minor page faults, which are served from FS cache and not from disk.
[14:04:34] <shka> gilberth: make sense
[14:19:02] <shka> i guess sbcl images are shockingly useful
[14:19:15] <shka> weird that i didn't use them much
[14:20:37] <selwyn> shka: that is weird
[14:20:45] <selwyn> you can load all your data into them and them dump them
[14:20:52] <shka> yes
[14:21:13] <shka> it always knew that, didn't realize how effective it can really be
[14:21:14] <selwyn> that alone saved me a ridiculous, ridiculous amount of time
[14:21:29] <hayley> https://www.youtube.com/watch?v=fn1R-5p_j5c
[14:21:30] -ixelp- Pink Floyd - Welcome to the Machine (Official Music Video) - YouTube
[14:24:32] <shka> selwyn: it gets weirder, because vellum is built around immutable tree
[14:24:50] <shka> and i work with a damn large datasets
[14:26:45] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[14:33:12] <selwyn> only drawback is that they aren't modular
[14:33:18] <selwyn> that hasn't been a problem for me though
[14:33:39] *** Joins: pjb (~pjb@user/pjb)
[14:41:03] *** Joins: iamFIREc1 (~iamFIREcr@user/iamfirecracker)
[14:43:24] *** Quits: iamFIREcracker (~iamFIREcr@user/iamfirecracker) (Ping timeout: 240 seconds)
[14:47:51] *** Joins: treflip (~user@user/treflip)
[14:54:15] <hayley> "I was thinking about it more in terms of understanding how the AMD cpu (5950X Zen 3) was hiding that non-trivial work, than that the Intel cpus were not. It's an extra, load, mask and conditional on every pointer store."
[14:54:41] <hayley> WHO WOULD WIN: M1 with atomic RC optimisation, or Zen 3 with concurrent tracing GC optimisation
[14:54:42] <moon-child> that's non-trivial...?
[14:55:00] <moon-child> I mean
[14:55:10] <moon-child> you're paying tlb,cache,... anyway...
[14:55:21] * hayley thinks
[14:56:03] <moon-child> apple kinda painted themselves into a corner though; they do mobile, so they have to care about battery life, and tracing gc costs power
[14:56:19] <hayley> We load a word from bitmap, pull out the right bit for grey-ness, and jump if not set?
[14:56:21] <moon-child> so what they went with is not completely unreasonable
[14:56:44] <moon-child> I thought java puts those bits in the object header?
[14:57:08] <hayley> So does immediate refcounting. But I guess if you do your own hardware, you get to make whatever low power.
[14:57:44] <hayley> You're probably right. OCaml uses the mark bitmap. Slight difference.
[14:57:51] <shka> hayley: they have to interop with obj-c
[14:58:18] <moon-child> gcc's objc implementation uses bdw
[14:58:25] <moon-child> so it's clearly doable
[15:00:00] <hayley> IIRC Gil Tene and Cliff Click claimed at different times that the load value barrier test and jump was just one x86-64 micro-op.
[15:00:33] <moon-child> yeah, test+jcc is fused
[15:01:52] <hayley> But, well, read barriers are usually seen as pretty slow. Not sure what goes wrong, really.
[15:02:29] <moon-child> well, measure it up against the other work that you're doing with the value you read
[15:02:48] <moon-child> maybe all you're doing is comparing it to something else and branching on the result, also
[15:02:59] <moon-child> so now you go from one to two operations
[15:03:41] <moon-child> and, I don't remember stats, but loads make up a fairly large proportion of the operations performed by most programs
[15:05:03] * hayley at least enjoys the 0.8% overhead for write barriers.
[15:05:54] <hayley> I do believe I made a meme about AMD acquiring Symbolics for the 6900X lispm chip. 5950X is pretty close.
[15:06:09] *** Joins: random-nick (~random-ni@87.116.179.129)
[15:07:08] *** Quits: random-nick (~random-ni@87.116.179.129) (Client Quit)
[15:18:56] <shka> lol @ this commentary https://youtu.be/8qFtmMct4vQ?t=4071
[15:18:56] -ixelp- [ENG] AfreecaTV StarLeague(ASL) S13 Ro.24 Day1 (Tastosis) - YouTube
[15:23:35] <ck_> hey nice I didn't know the season (or english commentary) had started
[15:23:39] <ck_> thanks for the link
[15:23:52] <shka> ck_: hth
[15:25:11] * hayley begins to feel her two first years of university were a waste.
[15:25:20] <shka> hayley: yes
[15:25:27] <shka> sorry, but that is the reality
[15:26:41] <hayley> idk, doing a study of read and write barriers sure sounds like less of a waste.
[15:29:26] <shka> hayley: well, it is just that there are us, and there are the normies
[15:53:31] *** Quits: eugercek (~user@user/eugercek) (Ping timeout: 256 seconds)
[16:02:45] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[16:04:37] *** Joins: random-nick (~random-ni@87.116.167.125)
[16:23:00] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Ping timeout: 240 seconds)
[16:26:30] <pl> The trick for university is that you can access a ton of resources you'll find much harder later
[16:28:06] <shka> yes
[16:28:27] <shka> they also will make sure you have no time to actually make use of those resources
[16:28:36] <pl> my university bluntly stated that they are responsible only for 50% of the time they expect me to study
[16:28:48] <shka> my pro tip? got yourself a good bro at uni
[16:29:01] <pl> shka: well, polish unis seemed to have much weirder workload
[16:30:17] <shka> dunno, i was a the medical uni and those are particularly infamous for the obscene workloads
[16:31:17] <selwyn> how did you get into coding?
[16:32:11] <selwyn> i learned loads of stuff at uni, but i was very much not doing computer science
[16:32:39] <shka> well, i learned C++ to do OpenMW
[16:32:55] <selwyn> being forced to spend all your time learning useful stuff at uni does actually come with disadvantages of its own but they are comparatively minor
[16:33:07] <shka> and i learned lisp because i wanted to learn something different 
[16:33:30] <shka> and most stuff at the time was C++ copycats to a degree
[16:33:44] <shka> i was wondering if haskell or lisp
[16:34:03] <shka> but lisp looked more accessible believe it or not
[16:35:14] <shka> PCL was a great book for a practically minded person
[16:36:04] <shka> i was also using linux when i started programming, because fuck vista
[16:36:17] <shka> and since linux, i already knew how to script
[16:49:09] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[17:08:34] <selwyn> cool
[17:12:48] *** Quits: dave0 (~davezero@069.d.003.ncl.iprimus.net.au) (Quit: dave's not here)
[17:16:27] *** Quits: skeemer (~skeemer@h-158-174-23-219.NA.cust.bahnhof.se) (Remote host closed the connection)
[17:16:51] *** Joins: skeemer (~skeemer@h-158-174-23-219.NA.cust.bahnhof.se)
[17:35:59] <shka> oh and then i turned out that lispcafe has a lot of weirdos in it and i love it
[17:36:13] <shka> so that's the key points in the story :P
[18:29:24] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 240 seconds)
[18:31:34] *** Joins: aeth (~aeth@user/aeth)
[18:55:03] <pl> shka: so, you might recall I work for a certain snow-obsessed database company now
[18:55:25] <shka> pl: great, how this is working for ya?
[18:55:36] <pl> the database deployment is metacircular
[18:55:38] <shka> you don't have to write raytracers for CS maps i presume?
[18:55:52] <shka> what do you mean by that?
[18:56:17] <pl> shka: today I've seen demo of actions like upgrading an environment (or an user set) to different package version
[18:56:23] <pl> it's done using SQL on our database :D
[18:57:18] <pl> as in, our database is the datastore for our control plane, which deploys our database, and the database logs into our databsae which is deployed as "virtual" client in our overall database deployment
[18:57:37] <pl> you literally use SELECT and ALTER statements to update version in prod
[19:01:50] <shka> ... ok?
[19:02:37] <shka> yeah, it is doable 
[19:02:46] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Remote host closed the connection)
[19:03:05] <shka> and it kinda makes sense to do it this way because it is platform agnostic 
[19:03:07] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[19:03:56] <pl> shka: I'd say it's more that database developers end up doing everything in SQL ;P
[19:04:19] <shka> pl: yes, and this is an advantage 
[19:04:30] <shka> because you need to hire just snowflake expert
[19:04:48] <shka> not azure/amazon/whatever devops
[19:05:15] <pl> but this makes the extra sense that sales/support team tools (or even user tools) can use it to let's say change details of special parameters the same way
[19:05:23] <pl> shka: this is all internal
[19:05:35] <shka> pl: yeah, but it is still relevant
[19:05:41] <pl> and we're present on all major clouds
[19:05:48] <shka> yes
[19:06:21] <shka> and it does not take a lot of effort to support those clouds because, well, you don't have that much cloud specific code to begin with
[19:06:50] <shka> so yeah, it is smart
[19:07:14] <shka> and whatever, variable is a variable 
[19:07:26] <shka> if you already have database, use it
[19:08:48] <shka> pl: anyway, a clever decision
[19:10:42] <pl> Lots of per platform code, but it's all abstracted, so deployment of software release indeed doesn't see it 
[19:10:55] <shka> good
[19:11:01] <shka> it is important
[19:11:06] <pl> Most visible platform specific stuff is things like instance types for dedicated accounts 
[19:11:08] <shka> critical even
[19:11:24] <pl> Because AWS instance names for example leak this way 
[19:11:30] <pl> *type names 
[19:12:10] <pl> (all company specific stuff redacted) `ALTER $CERTAIN_SUBSYSTEM_NAME NAME_OF_DEPLOYMENT_GROUP server_type='amazon_instance_size';`
[19:14:10] <pl> BTW, cloud agnostic is why I like k8s (and am working on integrating crossplane.io into my toolkit) 
[19:14:35] <shka> heh
[19:15:10] <pl> Crossplane uses k8s control plane, and allows you to create interface/implementation split 
[19:15:24] * shka is meanwhile putting 9gbs worth of lisp images into docker
[19:16:33] <pl> So you create an interface for "I want a postgres database with those params", and write implementation that does it through AWS RDS or GCP Cloud SQL, and you just load the implementations available in the environment 
[19:17:40] <pl> shka: what are you pushing? 
[19:18:20] <shka> detailed description may lead to damage of what is left of my reputation :P
[19:18:28] <shka> but picture this
[19:18:36] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 252 seconds)
[19:18:40] <shka> we do counter-strike
[19:19:05] <pl> I know XD
[19:19:13] <shka> and we sometimes need to know if there is a line of sight between two players
[19:19:23] <shka> so we can measure reaction time and stuff
[19:19:45] <shka> and the solution R&D came with is to use blender scripts
[19:20:23] <shka> and that kinda works, but do you want or need blender of all things in a docker container?
[19:20:48] <shka> so i rolled my own ray casting 
[19:21:05] <shka> because i had a hard time getting anything that does that
[19:21:33] <shka> and me being me, i did it all in CL
[19:22:08] <shka> and because i am a lazy asshole, i simply read all of the level geometry into lisp image, and then saved it
[19:22:41] <shka> and it is cool, it is fine, easy to use, way quicker then the blender solution 
[19:22:42] <pl> LOL 
[19:22:58] <pl> Have you considered packaging levels into FASLs? 
[19:23:00] <shka> but it is STILL 9 GB of lisp images
[19:23:48] <shka> yeah, but actually why would i bother to save 100mb when there is so much of that geometry stuff
[19:24:04] <shka> cost/benefit was not looking great
[19:24:23] <shka> anyway, the most hilarious part
[19:25:32] <shka> those dockers are run inside kubernetes on a scalable cluster of azure spot vms
[19:26:30] <shka> pl: so imagine what is the impact on spinning up those nodes
[19:26:51] <pl> shka: consider adding a preload task 
[19:27:05] <shka> oh, i can do that?
[19:28:16] <shka> pl: also, fun fact, gzexe reduces the size of those images to about quarter
[19:28:31] <shka> which is not something i expected to see, but it is there
[19:28:33] <pl> I think there are some open source implementations, essentially you run a job on clusters as DaemonSet that connects to containerd and auto-pulls images on boot
[19:28:44] <pl> shka: what about SBCL's compression?
[19:29:37] <shka> didn't bother with it, i don't want to load so much data into RAM each time i need to check a demo
[19:30:18] <shka> and SBCL compression would do that to me
[19:31:10] <shka> also, i suspect that the actual boot overhead would be about the same as with gzexe
[19:35:09] <shka> anyway
[19:35:11] <shka> behold
[19:35:13] <shka> pl: https://i.imgur.com/VizPY7O.png
[19:35:23] <shka> 9gbs worth os lisp images
[19:36:16] <shka> but blender files iteslf were even larger
[19:36:26] <shka> so... it is a net benefit
[19:42:18] <semz> what if we just replaced all file formats with lisp images that display the contents
[19:42:46] <shka> semz: honestly? i kinda like this idea :P
[19:44:35] <semz> it's a terrible idea for many reasons but it does have a certain appeal doesn't it
[19:45:12] <shka> semz: kinda horrible, but i played with it, and there is some value in it
[19:45:34] <shka> but... not all file formats :P
[19:47:01] <pl> reminds me of Alan Kay's file format approach
[19:47:23] <shka> pl: elaborate
[19:48:48] <pl> this was back on tapes, but essentially, start the tape with program that described the format of data following
[19:49:11] <shka> ok
[19:49:22] <pl> self-describing files
[19:50:19] <shka> i was personally interested in simply wrapping all of the data a CS replay into executable file that acts as a query server
[19:51:39] <shka> and sure, lisp images have overhead... but since demo files are large, it is not that significant
[19:53:09] *** Joins: kevingal (~quassel@2a02:8084:4140:f300:24b4:3a5b:fddb:7ca9)
[19:53:48] <shka> so anyway, there is a reason why this is not our current reality, but there is certain appeal in it for sure 
[19:57:34] <shka> pl: anyway, i spend 3 days on that whole ray casting ordeal, but we went from 112 seconds per demo file to 15 
[19:57:39] <shka> which is great
[19:58:49] *** Joins: notzmv (~zmv@user/notzmv)
[20:42:17] *** Joins: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se)
[20:57:56] <selwyn> are your order of magnitude savings popular
[20:58:18] <selwyn> or are you still considered the lisp weirdo
[20:58:44] <shka> selwyn: dunno, but my backs hurt from carrying this company :P
[21:00:36] *** Quits: mgl (~mgl@cpc87455-finc19-2-0-cust234.4-2.cable.virginm.net) (Quit: Client closed)
[21:00:46] <shka> we are under-staffed, and are low on people who know how to actually build software
[21:02:37] <shka> my team is just 3 people, including me
[21:03:15] <shka> one is just writing SQL, me is me, and the last is still finishing his bachelor degree and is a smart guy
[21:03:40] <shka> but didn't want to write that ray tracer so i ended up making it myself
[21:49:26] *** Quits: rogersm_ (~rogersm@90.166.180.250) (Quit: Leaving...)
[21:56:06] <treflip> An individual enterpreneur on my local job site is seeking for an "NFT-programmer" with 1-3(!) years of experience in "NFT-programming". The task is to generate 5000 random images and place them on the market. I can't stop laughing.
[21:57:16] <treflip> This is the most ridiculous job I've seen so far.
[22:00:49] <ck_> when I see something like that I try to find comfort in the perspective that "at least these people will keep themselves busy"
[22:02:30] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 252 seconds)
[22:13:01] *** Joins: eugercek (~user@user/eugercek)
[22:22:09] <shka> https://www.youtube.com/watch?v=8QQFXI5sWg4 good night all
[22:22:09] -ixelp- Variete I znowu ktoś przestawił kamienie - YouTube
[22:26:50] *** Quits: molson (~molson@172-103-21-94-dynamic.midco.net) (Quit: Leaving)
[22:56:27] *** Quits: treflip (~user@user/treflip) (Quit: good night)
[23:01:00] <SAL9000> pl: that runs into a meta-problem, doesn't it? i.e. what describes the format of the format-program? :-)
[23:02:02] <pl> SAL9000: well, that's where you hit minimal viable os interface 
[23:03:04] <SAL9000> at the end of the rabbit hole you end up with the Arecibo message engraved on the side of the tape
[23:03:44] <pl> A KA10 (which I still believe informed a lot of RMS' declarations regarding freedom of firmware) could have close to nothing, just the RIM10B scribbled in first block 
[23:04:33] <SAL9000> not sure what you mean by KA10 and Google isn't helping
[23:04:43] <SAL9000> https://gunkies.org/wiki/KA10 ?
[23:04:44] -ixelp- KA10 - Computer History Wiki
[23:05:06] <pl> Have it load a slightly modified DDT that by default runs a "load a program from tape based o thùs header" would work 
[23:05:08] <pl> Yes 
[23:05:37] <pl> The first PDP-10 model (second after PDP-6)
[23:12:53] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Remote host closed the connection)
[23:16:14] <pl> RIM10B was a paper tape bootloader that used minimal resources and could start without firmware at all 
[23:17:17] <pl> (worst case you could load it using switches into registers as it fit inside just registers) 
[23:20:22] <pl> shka: https://github.com/containerd/stargz-snapshotter/blob/main/docs/estargz.md 
[23:20:23] -ixelp- stargz-snapshotter/estargz.md at main · containerd/stargz-snapshotter · GitHub
[23:22:18] <shka> pl: oooooooooooooooooh, thank you kind soul
[23:30:30] <pl> Mnd or mind not work on your setup, but if it works... 
[23:31:23] <shka> well, it looks promising at least, i forwarded this to my devops 
[23:45:36] <clothespin> hello
[23:50:51] *** Quits: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se) (Ping timeout: 252 seconds)
[23:52:37] *** Joins: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se)
[23:54:05] *** Joins: rogersm (~rogersm@90.166.180.250)
