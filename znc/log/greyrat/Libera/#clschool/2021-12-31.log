[00:46:45] *** Joins: nij- (~jin@2001:48f8:9021:806::d58e)
[00:47:57] <nij-> I have a macro that applies on a list I'd like to make default. Something like (defvar +default-status+ '(rest active)) (im-a-macro +status+). The problem is that the macro is expanded before the variable is bound.. resulting an error. What's a good way to resolve this?
[00:48:11] <nij-> typo: it should be (im-a-macro +default-status+).
[01:03:45] <nij-> Or is such practice discouraged? What should I do then?
[01:05:13] <White_Flame> you mean the macroexpansion should change based on the value of some variable or constant?
[01:06:29] <White_Flame> or if your (im-a-macro +default-status+) is a toplevel form, then it will be executed automatically, which yeah might occur before the defvar
[01:06:44] <White_Flame> (also if you have + for earmuffs, shouldn't it be (defconstant +default-status+ ...) ? )
[01:53:01] <nij-> I tried #'defconstant but it _sometimes_and_not_always_ throws an error that says the constant is being redefined.. another mystery..
[02:45:56] *** Joins: nexeq-pc (~nexeq@user/nexeq)
[02:51:03] <White_Flame> nij-: right, you declare some value as unchanging, and if you put a different instance of a value in there (eg non-EQL) then it violates the old constant references that were compiled
[02:51:42] <nij-> But I never redefine the constant.
[02:51:47] <White_Flame> so (defconstant +foo+ 3) generally won't complain, but (defconstant +foo+ '(a b c)) always will, because it's going to be a different instance of a list when re-evaluated
[02:52:39] <White_Flame> there are often little utils to basically do (unless (boundp +foo+) (defconstant +foo+ '(a b c)) for you to avoid the warnings/errors
[02:52:48] <White_Flame> I think there's one in alexandria
[02:54:25] <White_Flame> yeah, it has DEFINE-CONSTANT, which also gives you the ability to specify the test, if EQL is too specific (which it often is)
[02:54:46] <nij-> I'm not sure I understand.. but this is definitely interesting.
[02:54:48] <White_Flame> so the literal '(a b c) could be used for an EQUAL define-constant, and not complain
[02:54:50] <nij-> Why would it complain?
[02:55:00] <White_Flame> '(a b c) and '(a b c) are 2 different objects
[02:55:02] <nij-> in the case of '(a b c).
[02:55:10] <nij-> I know. But it should be only evaled once.
[02:55:13] <White_Flame> they are not EQL, they're 2 separate lists on the heap
[02:55:27] <White_Flame> if you C-c C-k the file, or re-quickload it, it will evaluate the defconstant form again
[02:55:43] <nij-> I didn't. All I did is (ql:quickload :my-local-package).
[02:55:58] <nij-> And sometimes it complained, sometimes it didn't. That's weird isn't it?
[02:56:02] <White_Flame> once per image lifetime?
[02:56:11] <nij-> Yeah. It only shows up once.
[02:56:38] <White_Flame> no, you (ql:quickload)ed it only once per image lifetime?
[02:56:45] <nij-> Yes.
[02:57:14] <White_Flame> I don't think it's "weird", there's something specific in your code that is reevaluating it :)
[02:57:38] <White_Flame> be it part of a macroexpansion, or something in your .asd, or actually loading it twice from a repl or something
[02:57:38] <nij-> Hm. I see. I will try to find it out.
[02:57:46] *** Quits: nexeq-pc (~nexeq@user/nexeq) (Quit: Leaving)
[02:57:59] <White_Flame> very likely the 3rd.  just making changes & reloading
[02:58:24] <nij-> Gotcha.
[02:59:01] <White_Flame> I'm not sure if reloading from a cached .fasl affects a single defconstant, too
[02:59:09] <White_Flame> but that's more internal details
[03:02:25] *** Quits: nexeq (~nexeq@user/nexeq) (Read error: Connection reset by peer)
[03:03:34] *** Joins: nexeq (~nexeq@user/nexeq)
[03:03:34] <nij-> yeah.. 
[03:04:02] <nij-> I would use defvar for now. But thanks for highlighting the fact that the two lists are different.
[03:17:01] *** Quits: Jing (~hedgehog@2604:a840:3::1067) (Remote host closed the connection)
[03:17:40] *** Joins: Jing (~hedgehog@2604:a840:3::1067)
[03:19:06] *** Quits: nexeq (~nexeq@user/nexeq) (Read error: Connection reset by peer)
[03:19:46] *** Joins: nexeq (~nexeq@user/nexeq)
[03:20:46] *** Parts: nij- (~jin@2001:48f8:9021:806::d58e) (Using Circe, the loveliest of all IRC clients)
[03:21:09] <White_Flame> defvar can be real confusing as well, when you change (defvar *foo* 2) to (defvar *foo* 3) and nothing happens ;)
[03:22:02] <White_Flame> with larger programs, you usually end up with some form of initialization entry point, which makes initial state values clean
[03:22:11] <White_Flame> setting them explicitly at startup
[03:24:57] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[03:25:28] *** Joins: trocado (~uiop9@bl18-243-251.dsl.telepac.pt)
[03:38:37] *** Quits: random-nick (~random-ni@87.116.167.125) (Ping timeout: 240 seconds)
[03:45:55] *** Quits: cranium (~cranium@user/cranium) (Quit: Leaving)
[03:48:37] *** Quits: trocado (~uiop9@bl18-243-251.dsl.telepac.pt) (Ping timeout: 240 seconds)
[04:08:20] *** ilmu3 is now known as ilmu
[04:29:15] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[04:44:41] *** Joins: dre (~dre@2001:8003:c932:c301:8304:d78a:deb9:dfd1)
[05:04:52] *** Joins: mrmr1 (~mrmr@user/mrmr)
[05:06:37] *** Quits: mrmr (~mrmr@user/mrmr) (Ping timeout: 240 seconds)
[05:06:37] *** mrmr1 is now known as mrmr
[06:03:50] *** Quits: nexeq (~nexeq@user/nexeq) (Remote host closed the connection)
[06:45:07] *** Quits: sts-q (~sts-q@212.53.219.246) (Ping timeout: 256 seconds)
[06:52:29] *** Joins: sts-q (~sts-q@91.200.108.171)
[07:30:56] <beach> Good morning everyone! 
[08:22:28] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[09:50:30] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 268 seconds)
[10:00:03] *** Quits: Jing (~hedgehog@2604:a840:3::1067) (Remote host closed the connection)
[10:00:41] *** Joins: Jing (~hedgehog@240e:390:7c53:a7e1:99f1:6d34:38bc:e28a)
[10:42:32] *** Quits: Jing (~hedgehog@240e:390:7c53:a7e1:99f1:6d34:38bc:e28a) (Read error: Connection reset by peer)
[10:43:43] *** Joins: Jing (~hedgehog@2604:a840:3::1013)
[10:52:07] *** Joins: ilmu1 (~ilmu@176.76.242.110)
[10:55:01] *** Quits: ilmu (~ilmu@176.76.241.221) (Ping timeout: 240 seconds)
[11:13:24] *** Joins: pjb (~pjb@user/pjb)
[11:35:59] *** Joins: winning-luser (~wl@2601:8c1:80:70d0::414b)
[11:36:43] *** Quits: winning-luser (~wl@2601:8c1:80:70d0::414b) (Client Quit)
[11:46:46] *** Joins: lisp123 (~lisp123@5.30.23.247)
[11:56:18] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 268 seconds)
[12:17:22] *** Quits: dre (~dre@2001:8003:c932:c301:8304:d78a:deb9:dfd1) (Ping timeout: 260 seconds)
[12:58:33] *** Joins: nij- (~jin@2001:48f8:9021:806::d58e)
[12:59:26] <nij-> Hello! I have a CL program currently put in my QL local-project dir. (ql:quicklisp :it) loads it without a problem (no error).
[13:00:50] <nij-> However, while a macro I defined #'my-macro is loaded, I notice that (my-macro (a b c)) never gets loaded.
[13:01:33] <nij-> This confuses me. I want (my-macro (..)) to be evaluated during the (ql:quickload :it) process. 
[13:03:11] <beach> I don't understand.  What does it mean for "#'my-macro" to be "loaded", and what does it mean for (my-macro (a b c)) to be "loaded"?
[13:03:19] <beach> Only files are loaded.
[13:03:58] <nij-> Evaluated? Put another way: while I evaluated #'my-macro, it was defined.
[13:04:20] <nij-> However, the effect that the evaluation of (my-macro (..)) was absent.
[13:04:21] <beach> What does the syntax #'my-macro mean?
[13:04:45] <nij-> I suppose it means the macro function 'my-macro ?
[13:04:52] <beach> WOW.
[13:05:06] <beach> #'<stuff> means (function <stuff>) and not macro, and 'my-macro evaluates to a symbol.
[13:05:16] <beach> Where do you get all this strange notation from?
[13:05:33] <beach> So let's start again.
[13:05:43] <nij-> Ok
[13:05:55] <beach> So your macro named MY-MACRO gets defined?
[13:06:06] <nij-> Yes
[13:06:27] <beach> But the form (MY-MACRO (A B C)) is not evaluated at all?  How do you know?
[13:07:10] <nij-> Because if it is evaluated, the functions #'fun-a #'fun-b and #'fun-c must be defined.
[13:07:23] <nij-> Evaluating #'fun-a telss me that it isn't.
[13:07:38] <nij-> Now, I manually evaluate the form (MY-MACRO (A B C)). And then they are defined.
[13:07:53] <nij-> So I conclude that the form (MY-MACRO (A B C)) isn't evaluated.
[13:08:02] <beach> I see.  So, forms are evaluated at load-time only if they are top-level forms.
[13:08:23] <beach> Is your form (MY-MACRO (A B C)) a top-level form?
[13:08:34] <nij-> ! a notion I'm not aware of ( I mean top-level forms ). Thanks, I will read about it.
[13:08:49] <beach> If not, it is going to be evaluated at compile time when the form it is part of is compiled.
[13:09:10] <beach> Top-level just means that it is not nested inside any other form.
[13:09:59] <nij-> It is not nested inside any other form..
[13:10:21] <beach> Then it should have been evaluated when you load the file that it is contained in.
[13:10:33] <beach> Are you sure you have your packages right?
[13:10:57] <nij-> I think so. To show you the code, if you are willing to, can I query you?
[13:10:59] <beach> It looks like you are building symbols from A B C to FUN-A etc.
[13:11:18] <beach> Paste the code to something like plaster.tymoon
[13:12:41] <beach> Here is another thing you can try: After loading the system, try (apropos "fun-a")
[13:12:54] <nij-> I will do that. https://bpa.st/XIDQ
[13:13:07] <beach> You will then see if there is a symbol FUN-A that is in the wrong package.
[13:14:06] <beach> Why are you using EVAL here?
[13:15:29] <nij-> (apropos "window-focus-prev"); => NO-VALUES \\ WINDOW-FOCUS-PREV
[13:16:00] <nij-> beach: I believe I need an eval because its wrapped in a loop form.
[13:16:23] <beach> What makes you believe that?
[13:17:39] <nij-> I remember without that eval it doesn't even define the functions.
[13:17:51] <beach> I think you are terribly confused.
[13:17:52] <nij-> And then I thought.. hmm maybe its because (loop ..) returns NIL.
[13:18:00] <beach> Yes.
[13:18:26] <beach> A macro should return a form to be evaluated in place of the macro call.
[13:18:35] <beach> They should not evaluate things at macro-expansion time.
[13:19:02] <nij-> I see.
[13:19:14] <beach> Try returning (progn (defcommand...) (defcommand...)) instead.
[13:19:21] <nij-> The code smells very bad then.
[13:19:22] <beach> And no EVAL.
[13:19:29] <beach> Very.
[13:19:32] <nij-> No wonder it sometimes worked, and sometimes didn't.
[13:19:43] <nij-> Could it relate to some unspecified behavior?
[13:20:17] <beach> If you just load the source file, it will be defined, because there is then no separate compile time and load time.
[13:20:46] <beach> But if you compile it and then load it, the functions will be defined at compile time, but not at load time.
[13:20:58] <nij-> Gotcha. And (ql:quickload ..) only loads but not necessarily compiles?
[13:21:34] <beach> If the file is already compiled, then it only loads the FASL.
[13:22:31] <beach> So have the macro do `(progn ,(loop ... collect `(defcommand...)))
[13:22:46] <beach> Then check the expansion of the macro.
[13:22:51] <nij-> Yep. I think I know how to fix it. But I'm still wondering what failed me exactly.
[13:23:04] <nij-> Taking this experience to really sharpen my knowledge about CL.
[13:23:22] <beach> The first time you do quickload, the files are compiled and then the FASLs are cached in a secret place.
[13:23:37] <nij-> The FASLs have the macros expanded?
[13:23:52] <beach> Yes, macros are expanded at compile time.
[13:23:58] <beach> So the FASL will contain NIL.
[13:24:07] <nij-> Ah ha.
[13:24:19] <nij-> But the macro MY-MACRO is still defined?
[13:24:25] <nij-> yes
[13:24:28] <nij-> Got that.
[13:24:28] <beach> Sure.
[13:24:54] <nij-> Wonderful. Last tiny point.. why weren't you happy with my belief in what #'my-macro is?
[13:25:56] <beach> Because it usually means a function and not a macro.  Let me verify what the operator FUNCTION says... 
[13:26:05] <nij-> REPL> #'my-macro ;; => #<CLOSURE (:MACRO MY-MACRO) {10027F411B}>
[13:26:42] <nij-> (function 'my-macro) ;; ; caught ERROR: ; //   'MY-MACRO is not a legal function name.
[13:27:11] <beach> "Specifically, it is an error to use function on a symbol that denotes a macro or special form."
[13:28:16] <beach> #'my-macro is a reader macro that turns it into (FUNCTION MY-MACRO), not (FUNCTION 'MY-MACRO)
[13:29:08] <beach> The FUNCTION special operator takes a function name as an argument, and (QUOTE MY-MACRO) is not a valid function name.
[13:29:08] <nij->  REPL> (function MY-MACRO);;=> #<CLOSURE (:MACRO MY-MACRO) {10027F411B}>
[13:29:42] <nij-> I'm using SBCL.
[13:29:44] <beach> What does that prove?  That your Common Lisp implementation is not conforming perhaps. 
[13:29:57] <nij-> Gasp again. Got that!
[13:30:06] <beach> The language is not defined by what SBCL does, but what the standard says.
[13:30:19] <nij-> An implementation may choose not to signal this error for performance reasons, but implementations are forbidden from defining the failure to signal an error as a useful behavior. http://www.lispworks.com/documentation/lw60/CLHS/Body/s_fn.htm
[13:30:19] <beach> So: "Specifically, it is an error to use function on a symbol that denotes a macro or special form."
[13:30:31] <nij-> The sentence that follows what you quoted.
[13:30:39] *** Joins: rain3 (~rain3___@2a02:2f09:d003:cb00:928d:3338:a339:f956)
[13:30:54] <beach> OK, so it's conforming.
[13:31:05] <beach> But that doesn't make the syntax #'my-macro valid.
[13:31:32] <nij-> Sure. Better to say "the macro MY-MACRO"?
[13:32:00] <beach> Even better "the macro named MY-MACRO".
[13:32:21] <beach> But sure, "the macro MY-MACRO" will usually do.
[13:32:27] <nij-> Got it. Thanks for your help :)
[13:32:35] <beach> Sure.  Good luck.
[13:36:48] *** Quits: nij- (~jin@2001:48f8:9021:806::d58e) (Quit: Using Circe, the loveliest of all IRC clients)
[14:19:37] *** Quits: Jing (~hedgehog@2604:a840:3::1013) (Ping timeout: 240 seconds)
[14:24:08] *** Joins: Jing (~hedgehog@2604:a840:3::1013)
[14:51:46] *** Joins: treflip (~user@user/treflip)
[15:35:35] *** Joins: lisp123 (~lisp123@5.30.23.247)
[15:57:25] <lisp123> As my last question for 2021 :-) (hope y'all have had/will have a great NYE/NY), tt seems function overloading (where the lambda lists are not congruent) is generally frowned upon, but I'm trying to get a better sense of why
[15:59:48] <lisp123> One can hack in parameter overloading with the use of &key &allow-other-keys
[16:00:57] <lisp123> My feeling is that its a bad idea because then two functions which are overloaded against each other represent "different processes", since the inputs are different. Which I think I can be happy with, but any other ideas?
[16:11:12] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[16:14:59] <lisp123> I guess packages solves the problem largely, so I should just remove the idea of function overloading from my lisp dictionary
[16:17:55] <lisp123> One of the other downsides of 'overloading' is that documentation becomes very messy, which is not the lisp way. That's enough of a reason to avoid it!
[16:18:24] <lisp123> Here is a useful thread https://groups.google.com/g/comp.lang.lisp/c/rvE7Yd3GEwo/m/9c3e1ivMBuwJ (pjb, blast from the past for you here ;))
[16:54:16] <pjb> you can use synonyms or a different language. In French, tirer une conclusion, effectuer un retrait, ou dessiner sont trois mots différents.
[16:55:01] <pjb> Even if tirer une conclusion, effectuer un retrait, et tirer un trait (dessiner), all draw on the same semantic field, for some histerical reasons.
[16:57:37] <lisp123> Perhaps French is the superior language after all ;)
[16:57:59] <rotateq> deepl is my friend
[17:01:40] <rotateq> a friend of me also learns this esperanto for some years now
[17:07:03] *** Joins: random-nick (~random-ni@87.116.180.98)
[17:21:00] <lisp123> Time to wrap up for the NY. Pjb & rotateq & all, it's been a pleasure, have a great last few hours of 2021 and see you in the new year!
[17:22:06] <beach> lisp123: Take care!
[17:22:17] <lisp123> beach: You too :)
[17:25:04] <rotateq> I have still 9h left achieving something, but not high probability for that anymore.
[17:25:13] <rotateq> you too lisp123 
[17:43:11] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[17:56:17] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[18:02:00] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[19:11:08] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[19:38:18] *** Quits: Jing (~hedgehog@2604:a840:3::1013) (Remote host closed the connection)
[19:42:17] *** Joins: mrmr5 (~mrmr@user/mrmr)
[19:42:34] *** Joins: Jing (~hedgehog@2604:a840:3::1013)
[19:44:17] *** Quits: mrmr (~mrmr@user/mrmr) (Ping timeout: 256 seconds)
[19:44:17] *** mrmr5 is now known as mrmr
[20:04:02] *** Quits: rain3 (~rain3___@2a02:2f09:d003:cb00:928d:3338:a339:f956) (Ping timeout: 240 seconds)
[21:06:59] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 268 seconds)
[21:07:35] *** Joins: aeth (~aeth@user/aeth)
[22:05:47] *** Joins: alcaeus (~user@ip24-251-241-74.ph.ph.cox.net)
[22:31:28] *** Quits: Jing (~hedgehog@2604:a840:3::1013) (Ping timeout: 268 seconds)
[22:32:35] *** Joins: Jing (~hedgehog@2604:a840:3::1013)
[22:52:48] *** Joins: ilmu2 (~ilmu@176.76.243.219)
[22:55:10] *** Joins: Oladon (~olad@98.43.81.226)
[22:55:32] *** Quits: ilmu1 (~ilmu@176.76.242.110) (Ping timeout: 240 seconds)
