[09:36:24] *** Quits: FlorianDoubletGi (~gitterflo@2001:470:69fc:105::310c) (*.net *.split)
[09:36:24] *** Quits: XavierNoriaGitte (~gitterfxn@2001:470:69fc:105::3111) (*.net *.split)
[09:36:24] *** Quits: MattPattersonGit (~gitterfid@2001:470:69fc:105::3105) (*.net *.split)
[09:36:24] *** Quits: ChrisSeatonGitte (~gitterchr@2001:470:69fc:105::30fb) (*.net *.split)
[09:36:24] *** Quits: byteit101[m] (~byteit101@2001:470:69fc:105::30ec) (*.net *.split)
[09:39:54] *** Joins: FlorianDoubletGi (~gitterflo@2001:470:69fc:105::310c)
[09:39:54] *** Joins: XavierNoriaGitte (~gitterfxn@2001:470:69fc:105::3111)
[09:39:58] *** Joins: ChrisSeatonGitte (~gitterchr@2001:470:69fc:105::30fb)
[09:39:59] *** Joins: MattPattersonGit (~gitterfid@2001:470:69fc:105::3105)
[09:42:23] *** Joins: byteit101[m] (~byteit101@2001:470:69fc:105::30ec)
[12:30:08] *** Quits: puritylake[m] (~puritylak@2001:470:69fc:105::1:1904) (Quit: You have been kicked for being idle)
[15:46:27] <headius> Good morning
[18:41:13] <headius> ahorek: I updated https://github.com/ruby/io-wait/pull/2 with all the right bits for JRuby and moved that lib file into ext
[18:41:47] <headius> if we can get io-wait support out there we can start to use the shipping net/* libraries
[18:41:53] <headius> getting closer and closer to 3.0
[18:42:01] <MattWelke[m]> Made a Java gem. Nothing special to say about it. Just cool to see. :3
[18:42:01] <MattWelke[m]> https://github.com/mattwelke/java-gem-test
[18:44:09] <headius> Matt Welke: Nice! So the idea here is just plain Java sources packaged up and shipped in a gem, yeah?
[18:44:33] <headius> I was going to say that PR above is a good example of building a JRuby ext, but this is not an ext, it's just a Java library to be consumed from JRuby
[18:45:10] <MattWelke[m]> Not sure what a JRuby extension is right now.
[18:45:39] <headius> extension = using JRuby Java APIs to integrate directly into Ruby, like String or Array or Hash
[18:46:03] <headius> eliminates the overhead of crossing Java/Ruby boundary but requires a lot more knowledge of JRuby internals
[18:46:05] <MattWelke[m]> But yeah my goal last night was to get a basic idea of how to make a Ruby gem (up until then I'd only published NPM and Go libraries) and once I had that working, I was curious what it would be like to include some Java in it for use in JRuby. I ended up being successful after a lot of trial and error and following the rjack GitHub repo as an example.
[18:47:07] <MattWelke[m]> For example, one weird thing I noticed was that I had to use a package in Java. I've been able to execute class files where no package was used in the Java world, but in JRuby, it said "unitialized constant" when I'd call like `Hola.hi`. It only worked when I used a package and called it like `com.mattwelke.javagemtest.Hola.hi`.
[18:47:13] <headius> honestly if the Java part is standalone you might be best off publishing a Maven artifact and then linking that in with jar-dependencies (RubyGems plugin we provide that allows fetching and installing Maven artifacts alongside gems)
[18:47:46] <headius> ahh you can access the default package from JRuby but it is not recommended in the Java world these days
[18:48:01] <MattWelke[m]> true. I just like to start minimal and then build my way up.
[18:48:19] <MattWelke[m]> The extension method you describe sounds like something worth building up to now. Less overhead sounds good.
[18:48:22] <headius> sure, this is a very simple way to get some Java code into a gem
[18:48:31] <MattWelke[m]> And afaik this is how things like ActiveRecord are implemented in JRuby?
[18:49:01] <headius> for AR we have an extension, since there's a ton of Ruby types being tossed around and converted and such
[18:49:10] <headius> logically it is just a wrapper around JDBC though
[18:50:12] <MattWelke[m]> > honestly if the Java part is standalone
[18:50:12] <MattWelke[m]> Maybe this explains why I went this route btw. I was using https://github.com/dekellum/rjack as an example.
[18:51:46] <MattWelke[m]> actually, nevermind. Lost my train of thought. I don't see any advantage to them not using extensions based on my understanding so far.
[18:52:47] <MattWelke[m]> I just liked the pattern I saw in that repo. They just ship the JAR with the gem and the main Ruby file for the gem `require`s it. That way you don't need to use any tool other than bundler to get the JAR.
[18:54:21] <MattWelke[m]> And it was the discussion in https://github.com/mkristian/jbundler/issues/90 that prompted me to look into how to get JARs without using jbundler.
[18:54:28] <headius> ok sure
[18:54:38] <headius> so this is definitely a way to repackage Java libs for use in JRuby
[18:54:38] <MattWelke[m]> I know people there said to check out jar-dependencies. But I happened to stumble upon the rjack repo first.
[18:55:11] <headius> they appear to be mostly maven builds that will fetch the library in question, and then some bits to turn that into a gem
[18:55:44] <MattWelke[m]> Exactly. And because I like to start with minimal tests and then build up, I wasn't using Maven yet. Just javac and jar.
[18:55:45] <headius> historically we used to recommend people re-release Java jars as gems, but got away from that because there ends up being dups and none of them are canonical (like fetching from Maven itself)
[18:56:34] <MattWelke[m]> > repackage Java libs for use in JRuby
[18:56:34] <MattWelke[m]> This might be the right approach for a technique I wanted to try then. Remember me saying I thought it'd be neat to make data pipelines in Ruby with Apache Beam? I wouldn't need high performance because the Java code in Apache Beam is just called to set up a DAG. It's the Beam internals that do the work.
[18:57:18] <MattWelke[m]> So maybe wrapping the Beam JARs, either plainly like in my example where the JRuby user is expected to call Java, or richly where I make some Ruby methods people can call, would do the trick.
[18:58:24] <headius> for a library like that I would just use their jars directly, either republished or via jar-dependencies, and then a thin wrapper in Ruby to make it nice
[18:58:38] <headius> doesn't sound like there's need for a tightly integrated extension
[18:58:55] <headius> depends on what data is crossing that boundary mostly
[18:59:17] <MattWelke[m]> Do you have an example I can look at for making an extension instead of the way I repackaged the JAR?
[18:59:20] <headius> (i.e. would it want to be able to use Ruby String data directly or is copying into a Java String first ok)
[18:59:34] <headius> hmm
[19:00:12] <headius> well the psych gem (Ruby yaml lib, wraps libyaml in C and SnakeYaml in Java) does both: jar-dependencies to fetch the SnakeYAML library and an extension to provide the Psych API
[19:00:24] <headius> github.com/ruby/psych
[19:00:50] <headius> it is a pretty clean example of wrapping a Java lib with a (mostly minimal) extension
[19:01:31] <MattWelke[m]> Does jar-dependencies come into play when you're making an extension?
[19:01:47] <MattWelke[m]> Trying to wrap my mind around the various ways to call Java from Ruby here... Want to play with each one.
[19:02:13] <headius> it does if your extension depends on existing Java libraries that are published with Maven
[19:02:32] <headius> if your extension is just a standalone piece of Java code there's no real need for jar-deps
[19:03:29] <MattWelke[m]> And an example of "standalone piece of Java code" might be a Ruby gem that for performance reasons, had a C extension in the MRI world? So in the Java world, the C extension would be ported to Java and made into a Java extension?
[19:03:54] <MattWelke[m]> s/Java/JRuby/
[19:04:11] <headius> right
[19:04:56] <headius> the port of "oj" that enebo has been working on is a good example.. standalone hand-written json library in C ported to Java
[19:05:10] <MattWelke[m]> And we can expect there to be some situations where a Java extension would be more performant than a "pure Ruby" gem where we relied on JRuby to run the Ruby code? I imagine it would be the same use cases where in the MRI world, they opt to make a C extension.
[19:05:41] <headius> very similar yes
[19:05:53] <headius> JRuby will run Ruby code faster in general, but sometimes you just have to push bytes
[19:05:56] <MattWelke[m]> Alright I've got lots more to play with now. ty for the advice :)
[19:06:48] <MattWelke[m]> Sorry for any dumb questions. I haven't done Ruby or Java since 2016, in school.
[19:06:51] <headius> FWIW I know we don't have very clear messaging here and we want to fix that... JRuby has been around a long time so there's lots of different conflicting approaches
[19:07:15] <MattWelke[m]> Don't ask me why JRuby appeals to me so much for learning both deeply. I just like to challenge myself I guess. xD
[19:07:35] <headius> welcome to the party pal ðŸ˜€
[19:07:56] <MattWelke[m]> One of my main areas of focus is docs btw. My company thinks of me as the "docs guy" and I do a lot of training for new hires.
[19:08:09] <MattWelke[m]> I'd be happy to contribute back guides once I sort all this out myself, assuming I stay interested in JRuby.
[19:08:25] <headius> we have lots of docs, they are just old and conflicting and hard to navigate ðŸ˜€
[19:08:48] <headius> when given a choice between fixing a user segv or updating docs I kinda have to fix the segv
[19:09:55] * MattWelke[m] uploaded an image: (368KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/SVIcgzuBQQKcyiXBNjlDyCyD/image.png >
[19:09:58] <MattWelke[m]> yeah makes sense. I don't blame you
[19:10:46] <MattWelke[m]> work time, ttyl
[19:13:59] <headius> ttfn
[20:09:44] <headius> I've caught up a few issues so I'm going to reward myself with some 3.0 work
[20:09:54] <headius> enebo: have you made any improvements to kwargs on master?
[20:10:09] <enebo[m]> nope
[20:10:35] <enebo[m]> It is a big ticket item I have not had the energy to attempt
[20:10:38] <headius> ok, maybe you have some guidance on what is there and what is missing
[20:10:45] <headius> I can try to do what I can
[20:11:21] <enebo[m]> yeah I think mostly just reviewing the binding changes
[20:12:32] <enebo[m]> shoot HAHA I need to find the YUGE issue which talks about them
[20:12:58] <headius> hmm yeah this really needs changes in the nodes and parser
[20:13:40] <headius> well maybe... ArgsNode right now for example just has an array of args and a keyword offset, but the new way is that keyword args are explicitly separate
[20:14:18] <enebo[m]> Well I think we have thatalready
[20:14:28] <headius> public ListNode getKeywords() {
[20:14:28] <headius>         return new ListNode(getLine()).addAll(args, keywordsIndex, getKeywordCount());
[20:14:28] <headius>     }
[20:14:31] <enebo[m]> Or at least literal kwarg syntax is there
[20:14:59] <enebo[m]> but I think the main work will be in changing the plumbing of calls
[20:15:17] <enebo[m]> since when we know we are passing kwargs in a call we would like them to be out of band
[20:15:19] <headius> I should dig up some failing specs and start walking through it
[20:15:31] <enebo[m]> or a known position
[20:15:53] <enebo[m]> but detecting literal kwargs I think is there.  It is more about I have kwargs and I want to make a call
[20:16:16] <enebo[m]> So on native side it would be cool if we had something which would just recieve it into the method
[20:16:41] <enebo[m]> On interp/jit side that whole frobnicate and to_hash and all that probably needs a change
[20:17:29] <enebo[m]> if we have a call to a Ruby implemented method and it passes a kwarg we know it is a kwarg and so we won't be to_hash'ing in that case.  We will still need to make sure all required kwargs are there
[20:17:53] <enebo[m]> The other part is that there is ruby2_keywords which can be marked on a hash
[20:18:15] <enebo[m]> Somewhere internally I guess we off-ramp that hash into the out of band param piece of making a call
[20:18:58] <headius> hmm yeah the native piece
[20:19:17] <headius> that will be nice to have but CRuby has nothing like that
[20:19:33] <headius> on the native side they still largely just look for kwargs in last arg slot or something
[20:19:43] <enebo[m]> I do foresee call/finvoke to all accept an additional param so essentially bifurcating all those methods :(
[20:21:08] <enebo[m]> Actually I was going to say it can just be one param but ideally we don't want that
[20:21:42] <enebo[m]> we probably want some metadata saying what the values of the kwarg are and positionally pushing those as args
[20:21:57] <headius> most of those paths will have to box and unbox except for the most trivial cases
[20:22:30] <enebo[m]> I think this is something we can possibly change/evolve over time too
[20:22:33] <headius> like we could have finvoke(..., key, value) and finvoke(..., key1, value1, key2, value2) but obviously can't take that too far
[20:23:16] <headius> 45)... (full message at https://libera.ems.host/_matrix/media/r0/download/libera.chat/dd45ade78de4a3423d5926d58db0d4fb754ea5ce)
[20:23:25] <enebo[m]> yeah this also means we need an int for how many real args and then something to process those kwargs
[20:23:53] <headius> arg forwarding is also failing a lot of stuff
[20:24:05] <enebo[m]> arg forwarding is broken completely
[20:24:17] <enebo[m]> err well for anything involving ** or &
[20:24:27] <enebo[m]> that is because we do not have kwargs working
[20:24:34] <headius> ok
[20:24:51] <enebo[m]> The parser was making invisible variables for those two but it broke more because kwargs is not working
[20:25:13] <enebo[m]> in the parser forwarding is just making some unseen variables to hold the three values you will forward
[20:25:33] <enebo[m]> IR building will just take those and then the forwarded call will get them as params
[20:25:56] <enebo[m]> so it is simple to turn fully on but we have to know how we plan on passing kwargs 
[20:28:45] <headius> well perhaps we should also talk about how to represent call args in a squashed format without losing structure
[20:29:01] <headius> IRubyObject[] is not sufficient to keep kwargs and positional separate
[20:29:19] <headius> and we have to have a squashed way unless we are adding a separate kwargs arg to every call path
[20:29:28] <headius> that might be doable in the long term but clearly not this month
[20:30:04] <enebo[m]> yeah I am not sure
[20:30:50] <enebo[m]> Doubling all our call signatures is possible I think but I am not sure it is where we want to be in the end
[20:32:09] <headius> if we had an analog to Signature that was Arguments with separate slots for positional and kwargs that would be a lowest common denominator for passing and forwarding
[20:37:18] <headius> heh ArgsNode does receive a list of keyword args in one constructor but shoves them into the same array, is this just a space-saving measure?
[20:39:05] <headius> perhaps that is a place to start
[20:39:29] <headius> I see IR also has logic for looking at the last normal arg of a call and treating it as "maybe kwargs" if it is a hash, so that is clearly changing in 3
[20:39:36] <headius> IRBuilder I mean
[20:43:02] <headius> $ jruby -S ast -e 'call(1, 2, b:3)'... (full message at https://libera.ems.host/_matrix/media/r0/download/libera.chat/e51c5576b39bb6b6ece4aacb7d3ab5b12d8e993b)
[20:43:15] <headius> yeah so starting at this low level it already is munging positional and kwargs together
[20:43:53] <headius> I think we need to start here and in parser and keep keywords as a separate item rather than a HashNode
[20:44:38] <enebo[m]> I have an idea
[20:44:55] <enebo[m]> and yeah how we handled kwargs for pre-3 is just different
[20:45:26] <enebo[m]> I think we can make a RubyKeywords implements IRubyObject and just pass it as last arg
[20:45:37] <headius> I guess I am saying I'm not sure whether I can start to fix stuff in IR and beyond unless the parser is keeping these separate to begin with
[20:45:39] <enebo[m]> We can also make an Operand Keywords which can cache this
[20:45:52] <enebo[m]> Since it will have no side-effects
[20:46:04] <headius> yeah that is along the lines I'm thinking
[20:46:23] <headius> elevate kwargs to its own construct everywhere and then we are not playing this guesing game
[20:46:54] <enebo[m]> ok I had thought about this before but I had not thought about the idea we can keep a cached box because we know we are only going to be using it for a single call which will extract what it uses
[20:47:31] <enebo[m]> if we pass on kwargs it will have to put those into another keyword which will make another cachable instance
[20:47:42] <enebo[m]> so there will be some assignment cost but no allocation cost
[20:48:23] <enebo[m]> in literal kwargs builds it will have no cost and if they are literals not even assignment
[20:48:28] <enebo[m]> (on call set up side)
[20:49:06] <enebo[m]> I may be a little too optimistic here
[20:50:05] <enebo[m]> The values themselves we will be pushed in so they will not need to change the box but that site may be happening in parallel so for things like foo(a: some_meth) we have to remake the box over and over since some_meth can return anything
[20:50:21] <enebo[m]> but foo(a: 1) can just be alloc'd once forever at that site
[20:51:59] <enebo[m]> For IR I think we just need Keywords operand and the AST keyword keys and values emit into assigning to it:
[20:53:30] <enebo[m]> https://gist.github.com/enebo/27c72308a0b970a29580a2204b95fb05
[20:54:49] <enebo[m]> In the second file in that gist you will see what will actually happen since the fixnum will prop
[20:55:00] <enebo[m]> If all args prop we can optimize to only allocate a single instance
[20:55:40] <enebo[m]> lunch
[21:03:33] <headius> yeah so having a per-context carrier object would be helpful for many things
[21:04:17] <headius> it delocalizes the args from the call and the receiver (damaging escape analysis and what have you) but this is the default path... specific calls+receiver combinations will just pass things on the stack directly and avoid the box altogether
[21:04:38] <headius> but the cached box avoids allocation; caller fills the struct, receiver empties it
[21:04:59] <headius> then for arg forwarding we always have a structured way to pass the same argument layout forward
[21:27:21] *** Joins: subbu (~subbu@user/subbu)
[21:30:23] <enebo[m]> back
[21:35:16] <headius> So am I right in thinking that in 3.0  all calls will explicitly separate positional and keyword arguments with literal hashes just being normal positional arguments
[21:37:09] <enebo[m]> compile.c I think does do that
[21:37:17] <enebo[m]> for some things
[21:37:20] <headius> The only magic happens on the receiving side, which for normal 3.0 methods will only accept the literal keyword arguments as keyword args and for receivers marked as ruby2_keywords use the maybe logic to unbox any passed in hash
[21:38:05] <headius> I guess what I'm getting at is that we really need to start at the beginning of the call pipeline and make sure keyword arguments are being separated all the way through into IR because there is no other representation we need to maintain
[21:38:46] <headius> All calls either have keyword arguments and we know their names or don't have keyword arguments and pass only positional
[21:39:20] <enebo[m]>         flag |= VM_CALL_KWARG;
[21:39:23] <headius> With the special dispensation for rest keyword args but they still are considered separately from positional in all cases except once we get to the receiving side
[21:40:11] <enebo[m]> I believe adding a keywords operand in IR allows us to represent anything but its real benefit is we represent it live as something masquerading as IRubyObject but not used as IRubyObject
[21:40:47] <enebo[m]> Signature verification will need to args[args.length - 1] instanceof RubyKeywords or something like that
[21:41:12] <headius> Keywords operand I agree with, or at least something specifically keyword related in IR The values can be arbitrary expressions so I'm not sure an operand will be enough
[21:41:48] <headius> The metadata for the structure of the keywords is static but the values are calculated at runtime
[21:41:59] <enebo[m]> well we have Array as an operand but the array can have anything expanded into it.
[21:42:00] <enebo[m]> I think they are a direct analogue
[21:42:46] <headius> Yeah in that case it's just an array of references to temporary variables
[21:43:02] <enebo[m]> but there is a hybrid here that you can end up generating an immutable keywords if all values are not variables but literals
[21:43:06] <headius> So the argument values get calculated and shoved into temps and then yanked out for the keywords operand during the call
[21:43:25] <enebo[m]> in the interpreter they would for sure
[21:43:26] <headius> Oh for sure, that's how we're going to eliminate all allocation for things like the exception keyword that's all over IO now
[21:44:01] <enebo[m]> for the JIT you can possibly unwrap the box into something else?
[21:44:04] <headius> exception: false doesn't need to allocate anything to hit the right logic
[21:44:46] <headius> For jet, what I want is the metadata so I can embed a descriptor into the dynamic call and pass the values as plain old Java arguments on the stack
[21:44:50] <enebo[m]> yeah that case should work great with keywords operand ebcause we make one live instance of RubyKeywords and we know its contents never change
[21:44:51] <headius> For jit
[21:45:11] <headius> What do you mean by that? At minimum it has to be per thread
[21:45:49] <enebo[m]> keywords([:exception] [true]) -> we know it never changes we can share it across anything forever
[21:46:34] <enebo[m]> simple literal values in IR will propagate
[21:46:35] <headius> For that case yeah, and if we are calling an old style method we just create the hash at that point and populate it
[21:47:01] <enebo[m]> but are their old stle methods?
[21:47:14] <enebo[m]> there are old style arguments but is there methods?
[21:47:19] <headius> If they are flagged with ruby2_keywords
[21:47:42] <headius> I'm not sure what the difference is
[21:47:47] <enebo[m]> oh it has been a while...I did not (and do not) remember that working for method definitions
[21:48:08] <headius> Yeah it started out as a way to mark a method as using the old style where any arbitrary hash passed in can be interpreted as keywords
[21:48:16] <headius> It's used in the same way as public and private
[21:48:21] <enebo[m]> https://www.rubydoc.info/stdlib/core/Proc:ruby2_keywords
[21:49:19] <enebo[m]> ok I did not remember this detail but those methods obviously will need to process the static incoming keywords and make them splatty
[21:49:31] <headius> The marker on a hash is used to indicate whether the hash was created to support old style keywords I think
[21:50:08] <headius> That part isn't clear to me just yet
[21:50:27] <headius> In any case I don't think there's any ambiguity on the call side and keywords there are explicitly kept separate
[21:50:49] <headius> And only support the literal syntax or splatting out of a hash
[21:51:43] <enebo[m]> I think from IR side of things an operand Keywords which is similar in idea to Array but where we can detect immutable Keywords being an optimization we can pass it through ordinary call path and the special object type can be easily noticed
[21:52:38] <enebo[m]> My only fear with this design is native core methods which do not expect to see those.  In that case I think we just make it emulate a hash in behavior
[21:53:29] <enebo[m]> That might have a positive side-effect too...All our old core impl logic will just continue to work (if RubyKeywords extends RubyHash)
[21:54:43] <headius> Core methods would just be implicitly using the old style unless we specify the new style and provide a parameter or parameters to put the keywords in
[21:55:12] <headius> Or we go around and mark every method that receives keywords with an old style flag right now and start moving the default behavior toward having individual Java arguments for keywords
[21:55:34] <enebo[m]> but if we had a RubyKeywords which is a RubyHash (and add fields or what not) we could possibly never have to even change the core methods
[21:56:00] <enebo[m]> I personally would like to change them but I am also thinking about this as a faster effort
[21:56:54] <enebo[m]> We can always add a better mechanism later via populators/annos but something which would work with the existing impl would be nice since it would eliminate a lot of short term work
[21:58:19] <enebo[m]> oh man I forgot I was fixing Dir#glob bugs last week
[21:58:25] <enebo[m]> talk about a scary place
[21:58:40] <headius> write a compiler
[21:58:50] <enebo[m]> ok
[21:59:15] <headius> so actually my first model is probably best
[21:59:16] <enebo[m]> I got it down to 3F but it is a single failure where {}{} need to not sort but the things matching inside them do sort
[21:59:31] <headius> unless you specify that this arg is this keyword then we just assume you are receiving ruby2_keywords style and will sort it out yourself
[21:59:55] <headius> that will let the existing methods work as they do today and when we have a way to split off keyword arguments on java arguments it will just switch
[22:00:18] <headius> hah well that is useful ðŸ™„
[22:00:38] <headius> I guess I can start looking at this by creating the IR operand and trying to plumb it
[22:01:06] <enebo[m]> So what about idea of a masquerading IRubyObject with the keys/values in it?
[22:01:23] <enebo[m]> Or do you just want to start by using an actual RubyHash
[22:01:29] <headius> what does that save us over using RubyHash?
[22:01:40] <headius> any impl of IRubyObject has like 100 methods to implement
[22:02:34] <enebo[m]> I was going to say we could specialize lookup by having it in a field but we still have to determine the field
[22:02:47] <headius> I mean we certainly could make it a marker subtype of RubyHash too, I'm just not fond of trying to fake out IRubyObject and having it leak and go weird on us
[22:02:54] <enebo[m]> and I think nothing would prevent that from being a very specific case and not the generic one
[22:03:19] <enebo[m]> I guess the other piece is knowing for sure it is a keyword arg
[22:03:27] <headius> if you mean using this as an out-of-band way to pass kwargs I think that would just be best on ThreadContext
[22:03:34] <headius> the Arguments struct I was describing earlier
[22:03:41] <enebo[m]> signature verification for example
[22:04:20] <headius> what do you want IRubyObject for here exactly? Just so we can pass through generic call paths and not lose the keyword-ness of it?
[22:04:23] <enebo[m]> For mutable keyword values you sort of have to use TV
[22:04:45] <enebo[m]> for immutable you would not neccesarily but I am not sure if they actually helps
[22:05:28] <enebo[m]> yeah I think if we are in Proc#call we need to easily know the last argument is a keyword or not.  
[22:05:51] <headius> if this is for passing fully-literal kwargs we could have another structure, that would be useful... the way we do this right now is by having RubyHash create a "packed" version of a hash that stuffs everything in one bucket
[22:06:09] <headius> which is basically then just an array of key/value pair objects
[22:06:25] <headius> more efficient would be if we had a direct addressed hash
[22:06:30] <headius> or as you say, fields
[22:06:43] <headius> OneKeywordHash that just has a key and a value field
[22:06:59] <enebo[m]> yeah
[22:07:08] <headius> if this is the key I want, that is the value I want, and no lookup
[22:07:13] <headius> and keys are always symbols so idempotent
[22:08:18] <enebo[m]> yeah
[22:08:32] <enebo[m]> this is the whole exception: false case
[22:09:01] <headius> right
[22:09:37] <enebo[m]> So one place I see a benefit or maybe even a compat issue is Signature.checkArity
[22:10:01] <headius> hey refresh my memory why we sometimes have an ArrayNode and sometimes an ArgsNode
[22:10:11] <headius> ArgsNode is the receiver side?
[22:10:11] <enebo[m]> we have to know that if the signature requires a kwarg it is really a kwarg and not a hash
[22:10:37] <enebo[m]> in 2.x we don't care
[22:10:39] <headius> it is confusing because CallNode has a field called "argsNode" which will usually be an ArrayNode, right?
[22:10:56] <enebo[m]> heh I have to remember as well
[22:11:14] <headius> that nomenclature might be nice to clean up some day because it always confuses me when I return to this level
[22:11:33] <headius> DefNode.getArgsNode returns ArgsNode
[22:12:14] <headius> CallNode.getArgsNode seems to only return an ArrayNode, or perhaps a single argument's node
[22:12:51] <headius> again this is where I am wondering if I'm getting from parser what I need... I really need to know that these are the positional args and these are the keyword args before I dive into the call path
[22:13:18] <enebo[m]> ah ok I was just rooting around in the source
[22:13:40] <headius> like that paste above... a call with two positional and one keyword arg just looks like a call with an array with two args and a hash
[22:13:43] <headius> that's not good enough
[22:13:45] <enebo[m]> CallNode is just a list of things to pass to a call
[22:13:54] <headius> though HashNode does have a flag to indicate kwargs
[22:14:07] <headius> right but it is treating kwargs as fuzzy
[22:14:09] <headius> it should be strict now
[22:14:17] <enebo[m]> but for kwargs and block are tacked onto it
[22:14:42] <headius> it should be getPositionalArgs with an array of them, and getKeywordArgs with a set of k/v pairs in some form
[22:15:51] <enebo[m]>                 | args ',' assocs ',' {
[22:15:51] <enebo[m]>                     $$ = support.arg_append($1, support.remove_duplicate_keys($3));
[22:15:59] <headius> I'm just brainstorming here but most of this work is on the call side, explicitly peeling off keyword args and deferring their handling until we have a receiver
[22:16:36] <headius> it is how we wanted kwargs to optimize but could not (or at least it was tricky) because of the fuzziness
[22:16:45] <enebo[m]> Interesting.  This is just how it is done in MRI whereas on def side it does have a little more complexity since there are different types of things it accepts
[22:17:24] <enebo[m]> I know in one case the issue is that the grammar figures out the elements in the reverse order so they/we make a holder object
[22:17:26] <headius> hmm
[22:17:44] <headius> so does that mean they are just treating it as the last arg with some marker?
[22:18:12] <enebo[m]> Let me look at their parser but I think this will be the same since this is all _ method names
[22:18:15] <headius> I think we can infer where the kwargs are from the current structure, but it is a lot of manual inspection of this arg array
[22:18:56] <headius> it would be nice if I could just CallNode.getKeywordArgs because then I can plumb them straight through to a receiver, or create a hash lazily for old style
[22:19:31] <enebo[m]> 			$$ = $3 ? arg_append(p, $1, new_hash(p, $3, &@3), &@$) : $1;
[22:19:32] <enebo[m]> HEH
[22:19:35] *** Quits: joast (~rick@cpe-98-146-112-4.natnow.res.rr.com) (Quit: Leaving.)
[22:19:42] <enebo[m]> so they wrap assocs in a hash
[22:19:47] <enebo[m]> but it is still just a list
[22:20:16] <headius> MRI is not the best example perhaps because everything is just a ball of crap
[22:20:31] <enebo[m]> hahah ok...this is because in MRI hashes are made out of lists
[22:20:47] <enebo[m]> so assocs makes a list and then anything using assocs makes the hash at that point
[22:21:02] <enebo[m]> I just make the hash at assocs
[22:21:37] <enebo[m]> so a difference without distinction
[22:22:03] <enebo[m]> anyways call could be made to be  {position, kwargs, block}
[22:22:09] <headius> ok I think I was wrong
[22:22:24] <headius> I don't think I can accurately infer from the current AST that kwargs are kwargs
[22:22:39] <enebo[m]> yeah I am confused how they infer it
[22:22:41] <headius> it has this "maybe" logic that checks for all symbol keys, etc, but that's not a guarantee
[22:23:17] <headius> on the receiver side it is separated in ArgsNode so I know where the keyword metadata is, but on call side it is just an opaque hash at the end of the args array
[22:23:20] <enebo[m]> 	$$ = $3 ? arg_append(p, $1, new_hash(p, $3, &@3), &@$) : $1;
[22:23:23] <headius> it might be a hash or it might be kwargs
[22:23:23] <enebo[m]> This code kills me
[22:23:41] <enebo[m]> $$ = $3...talk about working to fit this onto a single line
[22:23:49] <headius> haha yeah
[22:24:56] <enebo[m]> This is really weird...how do they work this out?
[22:25:13] <enebo[m]> They just do what they always have and make the last argument a hash
[22:25:27] <headius> is there a marker in the call node?
[22:25:27] <enebo[m]> So just symbol key checking?
[22:25:45] <headius> treat_last_arg_as_keywords or something?
[22:26:00] <headius> there has to be a way they differentiate from passing kwargs and passing a hash
[22:26:33] <enebo[m]> yeah I believe foo(a: 1) is just a kwarg period in 3
[22:27:00] <enebo[m]> but perhaps it will still be a hash when it isn't going to a kwarg accepting method
[22:27:13] <headius> and I don't believe I can differentiate that from foo({a: 1}) in our current parser/AST
[22:27:13] <enebo[m]> I made the mistake of reading 4 years of discussion on this about a month ago
[22:27:29] <enebo[m]> ah
[22:27:39] <enebo[m]> Let's see how that looks
[22:27:48] <enebo[m]> I will look at { ... } stuff in parser
[22:27:53] <headius> I can't start stuffing literal hashes into kwargs without knowing they're kwargs so this is a sticking point
[22:28:11] <headius> even if they have all symbol keys (which is the "maybe" logic now)
[22:28:33] <headius> there is no maybe... kwarg or no kwarg
[22:28:53] <enebo[m]> 			$$ = new_hash(p, $2, &@$);
[22:28:53] <enebo[m]> 			$$->nd_brace = TRUE;
[22:28:56] <enebo[m]> ok
[22:29:04] <enebo[m]> So it is marked from the literal hash direction
[22:29:09] <headius> ah
[22:29:23] <headius> so this last hash arg is really a "brace" hash and don't treat it as kwargs
[22:29:35] <headius> unfortunate naming but ok
[22:29:45] <enebo[m]> that would be my guess...look for nd_brace in compile
[22:30:28] <headius> so we can add a field to HashNode for now and just flip that on in the literal hash construction in parser
[22:30:42] <headius> other dir seems more logical but matching MRI here
[22:31:15] <enebo[m]> OMGZ There is a lot of logic in HashNode
[22:31:32] <enebo[m]> I thought you were talking about what they were doing on inspecting for symbol keys
[22:31:51] <enebo[m]> I will add a field now
[22:31:51] <headius> isMaybeKwargs
[22:31:53] <enebo[m]> yeah
[22:32:14] <enebo[m]> Give me a couple.
[22:33:40] * headius sent a code block: https://libera.ems.host/_matrix/media/r0/download/libera.chat/43bb8f01e055e1a997ab4dca103e2e157214a00b
[22:33:54] <headius> example of something failing because we cannot make this distinction right now
[22:34:59] <enebo[m]> nice.  I am glad we made it past this hurdle
[22:35:16] <enebo[m]> each little detail clears things up a bit more
[22:35:18] <headius> if we can get the parser side hooked up right I think the rest will start to fall out quickly
[22:35:39] <headius> it is a simplification overall but some work to get rid of all this maybe logic
[22:36:34] <nirvdrum[m]> It sounds like you have a plan, but in case you didn't know, Chris and another Shopify employee have been working to improve kwargs in TruffleRuby. They hit a few hurdles along the way and I think they've managed to clear them. I'm sure he'd be happy to share ideas if you run into similar issues.
[22:37:15] <headius> as part of 3.0 work or just in general?
[22:37:35] <headius> we are not considering optimization at this point, but that will fall naturally out of having explicit keywords on call and receive sides
[22:38:06] <headius> I already know how to plumb keyword args straight through with no allocation but I need it to be explicit
[22:38:09] <nirvdrum[m]> In general. Although, the 3.0 semantics are less wonky than 2.7, so they've decided to adopt 3.0 and drop their work on supporting 2.7 semantics.
[22:38:25] <enebo[m]> good call
[22:38:38] <headius> yeah I gave up trying to make 2.7 kwargs optimize because of this wonkiness
[22:38:58] <nirvdrum[m]> The general idea is to make kwargs no more expensive than positional args.
[22:39:16] <headius> it should be easy now... just include metadata that describes the call stack and where positional args and key/value args are located, and unravel it on the receiver
[22:39:31] <headius> right, that should be easy with invokedynamic
[22:40:02] <headius> they will be exactly the same as positional args through to the receiver, and as long as the receiver also has explicit kwargs there's no alloc
[22:40:21] <nirvdrum[m]> I think they're mapping kwargs to synthetic positional args and storing a mapping in the method. But, don't quote me on that. There's been a bit of experimentation over the past couple of months and I'm not actively working on it.
[22:40:33] <headius> yeah, sounds like my impl
[22:40:51] <headius> if I run into any snags I'll ping Chris about it
[22:41:51] <headius> indy makes it pretty easy to mark up a call with metadata, so then it is just a matter of routing the positional args to either keywords on the receiver or lazily standing up a hash
[22:42:24] <nirvdrum[m]> Sounds good.
[22:42:34] <nirvdrum[m]> Some of it really sucks from what I gather. Good luck.
[22:42:45] <headius> in 2.7, it definitely does
[22:42:57] <headius> I believe it will be vastly simpler in 3
[22:43:50] <nirvdrum[m]> I think there was some work around storing data at the call site rather than the method, too, to deal with optional args. But, yeah, Chris would be the guy to ask. I've exhausted my knowledge on the topic.
[22:44:12] <enebo[m]> I believe we need a flag on RubyHash
[22:44:16] <headius> that's what I'm hoping enebo can provide for me from the parser
[22:44:52] <headius> really has to come from parser, so if y'all have parser changes to support this it would be great to see them
[22:45:03] <headius> in any case I can take it up with Chris as needed
[22:45:31] <headius> enebo: if we continue overloading RubyHash to also carry literal kwargs, then probably yes
[22:45:45] <headius> I do not know how that dovetails with the ruby2_keywords flag
[22:46:32] <enebo[m]> during signature checkArity we just look to see if the last argument is a Hash and if not try and make it one.  That seems like that is not 3.0 behavior
[22:46:42] <enebo[m]> So we need to know if the last arg is actually kwargs or a hash
[22:46:46] <headius> yeah that will all change
[22:47:20] <headius> arity for non-ruby2_keywords methods will explicitly consider positional and keyword args separately
[22:47:49] <enebo[m]> but I thought you were just saying we didn't need to extend RubyHash
[22:48:11] <headius> well, I said I don't want some new synthetic IRubyObject dummy struct
[22:48:41] <enebo[m]> oh I revised that a little later to say it should extend RubyHash since then it would work with existing native core methods
[22:48:43] <headius> RubyHash with a flag or KeywordHash < RubyHash would be fine
[22:48:48] <enebo[m]> ok
[22:48:50] <headius> ok yeah I missed that
[22:49:13] <enebo[m]> yeah I only made the comment because I thought you were against the extended version but it is all clear now
[22:49:25] <enebo[m]> I pushed
[22:49:25] <headius> nirvdrum: and thanks btw, I know that kwarg optimization work has been ongoing in TR but good to know they have refocused on 3.0 behavior
[22:49:56] <headius> incidentally, though, shouldn't escape analysis and partial evaluation be eliminating these hashes for you?
[22:50:06] <headius> I thought that was the answer to stuff like this
[22:50:17] <headius> enebo: ok
[22:51:01] <enebo[m]> if (hasKwargs() && !TypeConverter.checkHashType(runtime, args[args.length - 1]).isNil()) {
[22:51:13] <enebo[m]> I think we do this a few times
[22:51:13] <headius> heh I do like isLiteral better than "isBrace" but MRI folks pick weird names sometimes
[22:51:23] <enebo[m]> It will be really nice to kill this off
[22:51:38] <headius> oh yeah we have half a dozen different flavors of that all over the place
[22:51:39] <enebo[m]> yeah brace was too strange to me
[22:52:08] <enebo[m]> if (args.length - 1 > required() + opt()) {
[22:52:14] <enebo[m]> we will still have this stuff happening
[22:52:24] <enebo[m]> unless we went full out of band like Block
[22:54:58] <headius> we need a better AST printer
[22:56:08] <enebo[m]> ah I will update HashNode to print that out
[22:56:23] <headius> good luck, I just realized all AST printing relies on the same generic Node.toString
[22:56:39] <headius> we don't even have an AST printing visitor that lets nodes print themselves
[22:56:40] <enebo[m]> yeah I thought it was written around providing extra info
[22:57:50] <headius> oh I see, there is toStringInternal that can be overridden
[22:58:00] <enebo[m]> and I think toStringExtra
[22:58:03] <headius> we only do that in one place
[22:58:10] <headius> toStringExtraInfo
[22:58:11] <headius> yeah
[22:58:19] <headius> fill that sucker up with info
[22:58:41] <enebo[m]> coming to your repo soon
[23:02:39] <enebo[m]> ok I added it and it is 100% marked as !literal
[23:03:31] <headius> sweet
[23:03:53] <headius> I am scrubbing out the maybe logic as I go
[23:04:16] <enebo[m]> cool
[23:08:30] * headius sent a code block: https://libera.ems.host/_matrix/media/r0/download/libera.chat/f57d77f9390fc06a6194cb14c68d7b4210688f60
[23:08:38] <headius> woot
[23:08:43] <headius> for call(b:1)
[23:10:04] <headius> hmm IR is still seeing `call({b:1})` as kwargs though, I didn't break enough stuff
[23:11:32] <enebo[m]> headius: are you seeing literal ever set?
[23:11:47] <headius> I don't think so
[23:12:01] <enebo[m]> I am confused.  I can see that field getting set but then by the time I print out the ast it always says kwarg
[23:12:03] <headius> call({b:1}) still has literal = false
[23:12:16] <enebo[m]> I think something must be making a new hashnode from an old one?
[23:12:16] <enebo[m]> Looking into it
[23:13:18] <enebo[m]> what the hell
[23:13:28] <enebo[m]> I did not even put this remotely in the right place :)
[23:13:38] <headius> have another cup of coffee
[23:14:08] <enebo[m]> Seriously
[23:14:08] <headius> half these specs will pass if we can just get the hash marked as literal
[23:14:12] <enebo[m]> My brain cannot even process this
[23:14:14] <headius> because it will trigger arg errors
[23:14:51] <headius> actually maybe even more will pass because once we are beyond the call we know we have a kwargs hash versus a normal hash and only kwargs hashes will get sent through as such
[23:14:51] <enebo[m]> hahaha
[23:15:02] <headius> receiver side will need massaging but they will act like ruby2_keywords for now
[23:15:10] <enebo[m]> yeah I knew there was a lot hinging on telling the difference
[23:15:26] <enebo[m]> but we will also get signature mismatches which will be easy once we can look at a type or field
[23:15:36] <headius> right
[23:15:50] <headius> and we just wire it up as we go
[23:16:44] <enebo[m]> Last weds I did knock off about 30 F/E on ruby/spec so no doubt that doubled with MRI
[23:17:04] <enebo[m]> Those glob sorts are way more complicated than we have it impld too
[23:17:26] <headius> a large percentage of remaining fails are due to kwargs and forwarding being broken
[23:17:41] <headius> and the rest are pattern matching ðŸ¤ª
[23:17:54] <enebo[m]> not many though
[23:18:08] <enebo[m]> I made thousands of pattern matching tests work
[23:18:19] <enebo[m]> I should say I made them all work until we updated stuff
[23:18:21] <headius> ah nice, wasn't sure how far you got into them
[23:18:40] <headius> I just noticed a block of fails in the language specs and didn't really look too hard
[23:18:42] <enebo[m]> yeah anything there is from a single experimental feature of matching or just a bug
[23:19:06] <enebo[m]> I pushed the fix so kwarg/literal works
[23:19:12] <headius> yay
[23:19:18] <enebo[m]> and displays which would have been a nice thing to have done first
[23:20:52] <headius> just in the first couple layers after parser this already cleans up a bunch of logic
[23:21:53] <enebo[m]> ah yeah went through my last spec/ruby run and we fail 1 test in pattern matching
[23:22:35] <headius> ok so I guess next thing is that I need to identify a RubyHash that is kwargs
[23:22:43] <enebo[m]> Actually I expect this kwargs stuff will fix about <40F/E on ruby/spec
[23:22:44] <headius> so that will be the subclass marker or flag
[23:22:47] <enebo[m]> but it is important
[23:23:04] <enebo[m]> mri may have a lot more tests for it too
[23:23:20] <headius> maybe not many specs directly fixed but there are a lot of case expecting 3.0 kwarg behavior within a test for other behavior
[23:23:24] <headius> yeah more in MRI suite
[23:23:42] <headius> some of them are failing in the harness or in setup/teardown
[23:23:57] <enebo[m]> but a number of these are the worst ones because they  will break generic code
[23:42:35] <enebo[m]> https://github.com/jruby/jruby/blob/master/core/src/main/java/org/jruby/ir/IRBuilder.java#L1259-L1401
[23:42:51] <enebo[m]> Just in case anyone was curious about pattern matching
[23:47:36] <headius> I was curious
[23:48:28] <enebo[m]> I also experimented with some new syntax in builder
[23:48:43] <enebo[m]> label as lambda helper looks pretty nice
[23:48:56] <enebo[m]> but I did several other closure-based helpers
[23:49:08] <headius> I will this work to a branch and we can debate some choices
[23:49:30] <headius> I have added a quick KeywordHash subtype of RubyHash and now the places where we try to dig it out of call args just need to check instanceof
[23:49:58] <enebo[m]> nice
[23:50:15] <enebo[m]> it is a simple way around things for now
[23:50:26] <enebo[m]> old code in core methods will still mostly just work
