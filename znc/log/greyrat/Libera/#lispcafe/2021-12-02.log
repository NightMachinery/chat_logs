[00:00:00] <shka> you can't add vectors to each other
[00:00:03] <moon-child> that's more of a performance thing than anything
[00:00:09] <moon-child> what if I want to define my own quaternion type?
[00:00:26] <shka> use different package and shadow cl symbols
[00:00:34] <selwyn> yeah and that is annoying
[00:00:45] <selwyn> i accept it of course
[00:01:15] <shka> it may be, but i will take this over True*[1]
[00:01:21] <shka> at any day
[00:01:34] <selwyn> well, ok
[00:01:35] <sham1> True*?
[00:01:36] <selwyn> i see your point
[00:01:45] <shka> sham1: try that in python
[00:02:04] <shka> selwyn: operator gore as I like to call this :P
[00:02:11] <sham1> Oh
[00:02:17] <sham1> That's horrible
[00:02:27] <selwyn> a great cause of personal anxiety for me is that the operator overloading that i did do
[00:02:35] <sham1> And Python has a fairly sanely strong type system
[00:02:38] <selwyn> was not planned to deal with types properly
[00:02:41] <sham1> It just has these weird things
[00:02:46] <shka> sham1: yeah, but you can multiply a String with a *
[00:02:48] <shka> that's cute
[00:02:53] <shka> AND USEFUL right?
[00:02:57] <shka> (it is not)
[00:03:00] <sham1> You can also multiply a list with a number
[00:03:04] <shka> yes
[00:03:23] <shka> but why?
[00:03:42] <hayley> https://www.theregister.com/2021/11/30/aws_reinvent_rust/ A: no
[00:03:42] -ixelp- Can Rust save the planet? Why, and why not ‚Ä¢ The Register
[00:03:43] <shka> what is the generic code that must work with both sequences and the numbers?
[00:03:58] <selwyn> i think the cuteness, or conciseness, is a big factor
[00:03:58] <sham1> Of course one can also go to a ridiculous other direction: https://arcanesentiment.blogspot.com/2015/01/if-scheme-were-like-scheme.html
[00:03:59] -ixelp- Arcane Sentiment: If Scheme were like Scheme
[00:04:02] <selwyn> things must look pretty in python
[00:04:11] <shka> selwyn: fuck being pretty
[00:04:15] <sham1> Python is A E S T H E T I C
[00:04:19] <moon-child> sham1: hehe yes, that post was amazing
[00:04:28] <hayley> "Garbage-collecting languages are inherently less efficient, said Lerche. [...] ‚ÄúThe garbage collector is going to have to pause the process to do the garbage collection pass. And when it's paused ‚Ä¶ the service is not able to respond anymore to requests,‚Äù he said. This means languages such as Java, C# and JavaScript can never be as efficient and performant as C and Rust." YOU FOOL YOU MORON
[00:04:36] <shka> i am personally look like a fucking ghoul and i don't care
[00:04:37] <selwyn> they were so happy to get their walrus operator
[00:05:05] <sham1> moon-child: that post is the epitome of "F you, but you're right"
[00:05:42] <moon-child> new scheme version will have generic functions
[00:05:48] <sham1> Yes
[00:05:50] <moon-child> they finally admitted defeat
[00:06:10] <shka> anyway, the point is
[00:06:42] <sham1> Having a different procedure for mapping over a list vs a vector vs a generator vs... is silly
[00:06:47] <shka> it is actually advantageous to have type specific code error-out as quickly as possible  
[00:07:18] <shka> and this is what, IMHO CL got right
[00:07:33] <moon-child> (CAR NIL)
[00:07:44] <shka> moon-child: yes, NIL is a lis
[00:07:46] <shka> *list
[00:07:52] <sham1> But NIL is not a cons pair
[00:07:57] <shka> yes
[00:08:07] <moon-child> CAR and CDR are (or, should be) defined on conses, not lists
[00:08:15] <shka> i would personally only prefer to have dedicated boolean types in lisp
[00:08:22] <shka> but whatever
[00:08:22] <sham1> And CAR and CDR only make sense for Cons pairs. And I personally like that (car '()) is an error in scheme
[00:08:25] <selwyn> hm
[00:08:31] <selwyn> i don't miss dedicated booleans at all
[00:08:39] <moon-child> nor I
[00:08:46] <moon-child> and I really hate that () is not self-evaluating in scheme
[00:08:48] <selwyn> it makes talking to json difficult
[00:08:59] <sham1> Wut?
[00:09:02] <selwyn> but since when are we trying to use json as a yardstick of good practice
[00:09:15] <sham1> Dedicated booleans make it easier to distinguish between a JSON null vs a false
[00:09:17] <shka> selwyn: and databases
[00:09:29] <moon-child> sham1: how do you distinguish a json null vs a json []?
[00:09:40] <selwyn> shka: oh
[00:09:41] <moon-child> I guess you could map the latter to #().  But that's no so ergonomic
[00:09:42] <sham1> '() vs #()
[00:10:03] <moon-child> if I‚Äôm converting a cl list to json.  I don't want to have to make my empty lists into vectors
[00:10:17] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Quit: WeeChat 3.3)
[00:10:28] <sham1> Or maybe a null keyword
[00:10:38] <selwyn> but then the null keyword is not nil
[00:10:47] <shka> selwyn: yeah
[00:10:55] *** Joins: amazigh (~amirouche@user/amirouche)
[00:10:55] <shka> it is endlessly frustrating 
[00:11:03] <amazigh> https://youtu.be/hcJ34wp41hI
[00:11:04] -ixelp- Frenic - Database Doom (Official Video) - YouTube
[00:11:04] <sham1> Well then you do :false or something. Of course :false is not falsy and thus one finds yet another dead end
[00:11:12] <moon-child> perhaps cl should distinguish (), nil, null, undefined, and false, in order to better interoperate with js
[00:11:22] <moon-child> oh yes, also unspecified for scheme compat
[00:11:23] <hayley> ü§î
[00:11:30] <sham1> Would make writing my CBOR stuff easier
[00:11:52] <sham1> Because I decided to make CBOR false nil and null and undefined as singleton instances of a class
[00:11:54] <shka> what i do is to use only vectors for sequences, t as true, nil as false, and :null as a NULL/None
[00:12:04] <shka> and it is FINE
[00:12:10] <shka> but that :null is rather annoying
[00:12:27] <sham1> So you have nil for false, t for true, +null+ for, well take a guess, and +undefined+
[00:13:06] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[00:18:10] <sham1> There's also +false+ and +true+ for symmetry although they just alias nil and t
[00:20:25] <hayley> https://www.youtube.com/watch?v=2sUyk5zSbhM
[00:20:26] -ixelp- On The Run - YouTube
[00:23:11] <hayley> https://old.reddit.com/r/rust/comments/r6e5s3/the_onemorerenightmare_compiler/hmu817u/ POV: I am going to hell
[00:23:12] -ixelp- Plasma_000 comments on The one-more-re-nightmare compiler
[00:24:01] <sham1> In an unrelated note, why are WebSockets so convoluted
[00:25:12] <sham1> I feel that I shouldn't need an entire HTTP server stack on the implementation language just to make a WS endpoint. I have nginx for a reason
[00:26:26] <hayley> They wouldn't be "web"sockets then.
[00:27:03] <shka> what hayley said is true
[00:27:40] <sham1> Hm, probably a fair point. I just feel that a websockets server library should have the most rudimentary HTTP parsing just to enable it to do the HTTP handshake to establish the websocket thing
[00:27:42] <shka> but from the implementation endpoint, you need to send http request, and then you steal the socket from the server 
[00:28:19] <shka> thing is... rudimentary http parsing is not sufficient even for the websocket
[00:29:03] <GreaseMonkey> huh, not even wikipedia describes the "simple" framing format that you use once you're in
[00:29:27] <GreaseMonkey> FIN: 1 bit - Indicates that this is the final fragment in a message.  The first fragment MAY also be the final fragment. <-- why do you need this. why do you even want this. why.
[00:30:02] <shka> i mean, it may work for simple use cases, but it is not good enough 
[00:30:25] <shka> so yeah, websocket server must be a full fledged http server 
[00:30:33] <GreaseMonkey> you've got TCP. you're already getting broken up and reassembled. you should not care about making your own fragmentation.
[00:31:37] *** Quits: Inline (~Inline@aftr-37-201-240-100.unity-media.net) (Ping timeout: 256 seconds)
[00:33:04] <GreaseMonkey> frame-opcode-control = %x8 ; connection close <-- were they trying to make this work over UDP initially
[00:34:04] <sham1> Well then I'd have to somehow wrangle either Hunchentoot or Clack to integrate nicely with other TCP sockets
[00:34:07] <shka> the fuck is happening with the youtube?
[00:34:32] <sham1> Although they might also just spawn new threads which also works I suppose
[00:34:40] <shka> it seems to be able to handle one request at the time
[00:34:42] <shka> youtube, is
[00:34:53] <shka> *at a time
[00:34:54] <sham1> I've noticed that Youtube has been rather jank for me
[00:35:11] <GreaseMonkey> i propose HttpStreams, where one just says they support HttpStreams in an upgrade handshake, and then you just have TCP send() and recv() semantics, and the only data supported is binary
[00:35:29] <sham1> Genious
[00:35:33] <sham1> Genius*
[00:36:04] <GreaseMonkey> and also HttpDatagrams, a layer on top of HttpStreams where every message is prefixed with either 1 byte (MSBit clear) or 4 bytes (MSBit set) in big-endian and that's your datagram length
[00:36:54] <GreaseMonkey> but why would we need to do something this simple when we're expected to just use electron everywhere
[00:43:48] <shka> yeah, it is fucked
[00:44:53] <hayley> https://www.youtube.com/watch?v=UtixaQtGzYI
[00:44:54] -ixelp- Syd Barrett And Richard Wright Go To The Supermarket - YouTube
[01:19:36] <Gnuxie> https://parliamentlive.tv/event/index/97777cf7-be1f-4fa1-95fe-4814658e369e?in=16:44:18
[01:19:37] -ixelp- Parliamentlive.tv - House of Commons
[01:19:51] <Gnuxie> Boris gets called a liar and it's a-ok cos he actually is 
[01:19:59] <selwyn> lol
[01:20:16] <selwyn> you're not supposed to call mps liars in the house of commons
[01:20:44] <selwyn> thats why he won't say it directly
[01:20:55] <selwyn> ooh
[01:21:20] <selwyn> ok so he did call him a liar
[01:21:51] <Gnuxie> https://i.redd.it/0b6ysd7ljw281.jpg
[01:22:12] <Gnuxie> had to share this it's too funny
[01:23:24] <selwyn> he didn't have to retract thats a result
[01:44:55] <gilberth> This house is falling apart. I have cozy 18¬∞C at my room for the thermostat of my heater been stuck over night. Further it appears as if our dish washer is dying slowly, too.
[02:00:03] *** Joins: aeth (~aeth@user/aeth)
[02:00:23] <aeth> I had that annoying concurrency issue again, where I auto-identify but somehow it doesn't let me in +r channels in time and it takes me days to notice.
[02:02:25] <aeth> tomorrow is 20211202
[02:02:38] <Gnuxie> fuck
[02:03:41] <sham1> Today is
[02:03:49] <sham1> Funny how timezones work
[02:04:02] <aeth> there is one authoritative time zone and it switches in about 90 minutes
[02:04:18] <aeth> blame the British
[02:05:41] *** Quits: shka (~herr@83.175.151.96.piasta.pl) (Ping timeout: 252 seconds)
[02:11:54] <hayley> https://news.ycombinator.com/item?id=29397799 pne-more-re-nightmare, not to be confused with one-more-re-nightmare
[02:11:56] -ixelp- Pne-more-re-nightmare ‚Äì A fast regex compiler in Common Lisp | Hacker News
[02:19:55] <selwyn> there was me thinking that aeth had appropriately chosen the correct time zone
[02:22:29] <hayley> "The main downside of using regex derivatives like this is that compilation is worst case exponential." 2 bad so sad
[02:22:55] *** Quits: random-nick (~random-ni@87.116.165.83) (Ping timeout: 252 seconds)
[02:30:03] *** Quits: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de) (Ping timeout: 256 seconds)
[02:30:14] *** Joins: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de)
[02:32:57] <hayley> https://www.reddit.com/r/rust/comments/r6e5s3/the_onemorerenightmare_compiler/hmuxuut/?context=3
[02:32:58] -ixelp- The one-more-re-nightmare compiler : rust
[02:33:02] <hayley> "This is where DFA compilation can be quite precarious, since many common classes (like \w) are quite large. Stick a bounded repetition operator on there and you very quickly start hurting." What is isum :S
[02:36:26] <hayley> btw this guy takes a second to do Laurikari on \w{3}, so I am really guessing he is just isum-less.
[02:36:51] *** Quits: mfiano (~mfiano@li1282-157.members.linode.com) (Ping timeout: 256 seconds)
[02:36:58] <kakuhen> so today I learned that lispworks has a multiprocessing library
[02:37:13] <kakuhen> but I can't seem to access it from the personal edition; looks like another excuse to potentially shell out hundreds for a compiler
[02:38:48] <hayley> That said, I don't think dropping a test for \w inline is a good idea.
[02:41:04] <hayley> How the hell do you do the test then? Use a bitmap and have a bajillion bytes of bitmaps?
[02:49:40] <moon-child> there was a cool trick somebody did to compress such tables
[02:49:51] <moon-child> one sec, I‚Äôll see if I can find it
[02:50:21] <moon-child> https://github.com/apankrat/notes/tree/master/fast-case-conversion
[02:50:22] -ixelp- notes/fast-case-conversion at master ¬∑ apankrat/notes ¬∑ GitHub
[02:52:48] <jasom> Trying out advent of code; part 2 for today is silly; (A + B + C) < (B + C + D) ‚â° A < D
[02:54:06] <kakuhen> i gave up on day 1 before going to bed
[02:54:30] <kakuhen> friend told me it was a one-liner and i tried depserately to do it in literally one line
[02:54:44] <moon-child> it is 5 characters in apl!
[02:54:46] <kakuhen> (loop for (x y) on list by #'cddr when y collect (lambda (x y) (unless (zerop (- x y)) 1) into stuff finally (reduce #'+ stuff))
[02:54:51] <kakuhen> yes i know im stupid
[02:54:58] <kakuhen> i never b othered to test it and im sure it fails in one particular edge case
[02:55:32] <moon-child> p sure you don't want by #'cddr
[02:55:45] <moon-child> it's overlapping pairs
[02:55:59] <jasom> That's not how I did it, but (loop for (x y) on list when (and y (< x y)) sum 1) would be my solution
[02:56:15] <jasom> Mine did the reading as part of the loop so it's quite different
[02:56:23] <moon-child> jasom: can just say ‚Äòcount (and y (< x y))‚Äô
[02:56:37] <jasom> moon-child: TIL about count in loop
[02:56:39] <gilberth> People should believe Owen. Perhaps this is why nobody figured out submatch addressing with a DFA before me.
[02:56:49] <moon-child> jasom: :)
[02:58:15] <gilberth> Besides with tag assignments you can't decide whether an automaton is minimal anyway. First year CS.
[02:58:48] <hayley> Does Owens mention isums? He used derivative classes to cut down on dispatch, but sets are still just of characters and not ranges.
[02:59:31] <hayley> .oO(Could memoize isum operations if they get slow, too, since we rarely create "new" isums except due to + and &.)
[02:59:40] <gilberth> hayley: That is just an implementation detail not changing the size of the DFA.
[02:59:47] <hayley> Sure.
[03:00:13] <jasom> Out of curiousity, how do DFA implementations handle parts of "regexes" that have non-regular implications?  Do they just not implement all of perl's regex features?
[03:00:21] <hayley> Do you think I should be concerned about O(2^n) DFA generation? I doubt they occur in practise, but I have no idea. 
[03:00:36] <gilberth> And milady, isums are interned with my implementation. And we do isum operations only once for new states on the first set.
[03:00:44] <hayley> Right, either they refuse to implement Perl's "reg"ex stuff, or they bail out to a NFA or something.
[03:01:13] <jasom> hayley: NFAs have no more power than DFAs (It's been almost 20 years since I took a CS class, but I remember that one for sure)
[03:01:38] <gilberth> Even the traditional Thompson method with subset construction is O(exp). You can't escape that. And, yes, in practice this is of no concern.
[03:01:42] <hayley> Right, not an NFA, but something that is definitely not O(n).
[03:02:49] <hayley> gilberth: Still, what would you do for hairier isums? Still emit (or (<= ...) (<= ...))? Bitmaps?
[03:03:14] <gilberth> Yes, but is not O(n) for your lex(1), too. Don't know about glibc. But I read reports that you could trigger O(2^n) with grep(1).
[03:03:57] <hayley> There might be some tricks with bitmap compression still. /me hasn't read moon-child's link yet.
[03:04:28] <gilberth> hayley: Or binary search. I guess the optimal heuristic still needs some benchmarks to be taken. And: This changed over the last around fifteen years.
[03:04:48] <hayley> We also have some funny instructions with...BMI1 and 2 on x86-64 too.
[03:05:34] <hayley> e.g. https://www.felixcloutier.com/x86/pext to pull any damn bits out of a word, because why not.
[03:06:11] <gilberth> lex(1) builds a map of char -> equivalence class. There are usually only a few equivalence classes, especially for grep. So you might win, if that mapping could be made fast.
[03:07:21] <gilberth> Though lex(1) does this for the purpose of getting the tables small, as transitions are a lookup of the equivalence class of the char at hand x the state.
[03:07:41] <hayley> Okay, there is "table compression" where all zero blocks are deleted. And I can still do the HAMT trick of (LOGCOUNT (LDB ...)) to decompress and find a block index.
[03:09:03] <hayley> "The number of ranges is indeed smaller than the number of characters, but there are still a lot of ranges. And I suppose this invites the question: is your DFA byte based or codepoint based? If byte based (as I would expect), then you can't really just store ranges of codepoints. You have to build the UTF-8 encoding of \w into the DFA itself. It is not small."
[03:09:46] <gilberth> Well, I don't believe in this kind of eqv class mapping. But more benchmarks are probably called for. As well as recognizing tight loops and prioritizing on the interesting characters. And unrolling.
[03:10:22] <gilberth> Remind me, that I wanted to craft a C backend, so that I could have a look what gcc or clang could do.
[03:11:52] <gilberth> hayley: Your quote names a moot point.
[03:12:31] <hayley> Seems we only get moot points so far.
[03:13:10] <hayley> I need to actually experiment on making an ISUM for ALPHANUMERICP.
[03:13:36] <gilberth> As it should not matter whether you decode \w for every state once to have less transitions, or do it in each transition. I decided against an eqv class based approach, because in a scanner you have states that don't care for a lot of equivalence classes because they look for specific things like a terminating '"' or "*/" or a newline.
[03:14:22] <gilberth> And those latter states will be slowed down by figuring out [global] eqv classes they don't care about.
[03:14:55] <hayley> Despite having written a regular expression, I still don't know much about practical uses of regular expressions.
[03:15:39] <gilberth> And in a scanner, I also deal with punctuation, which would give a large number of equivalence classes and states looking for just a single character. Like telling a sole "%" from "%=", say.
[03:16:07] * hayley has an ISUM for ALPHANUMERICP. It has 554 ranges.
[03:16:42] <hayley> Definitely a bytemap then. (Bytes cause bit addressing is still slow on x86-64.) 
[03:17:01] <gilberth> Yes, and you can't escape that. What happens, when you use UTF-8 directly?
[03:17:43] <hayley> I still don't have a conversion function.
[03:17:57] <gilberth> You want a table of 2^21 code points? One for each equivalence class? Not feasible, hence by ISUM.
[03:18:06] <hayley> But I bet my claim that "most clones die quickly" also works for arbitrary UTF-8 bytes.
[03:18:23] <gilberth> It should.
[03:18:45] <hayley> gilberth: Somewhat more feasible with page compression. The largest alphanumeric character is #.(code-char 195101) apparently.
[03:18:58] <hayley> #\CJK_COMPATIBILITY_IDEOGRAPH-2FA1D
[03:19:26] <gilberth> What about: . ?
[03:19:41] <hayley> . is all but whitespace, right?
[03:20:11] <gilberth> This is silly, you may want to do with a two-stage table. Why not use UTF-8 then?
[03:20:34] <hayley> What I am thinking is a two-stage table.
[03:20:36] <gilberth> hayley: . is either everything but #\newline or at an option every character.
[03:20:47] <hayley> Okay.
[03:20:59] <hayley> "Yeah codepoint based presents an issue for your DFA representation I think. Because your transitions are not just defined over bytes but something more complex, which tends to hit memory usage pretty hard and also tends to increase the fixed costs of executing each transition. But, I haven't followed your path too seriously, soaybe I am missing something. I look forward to seeing where your work takes you. :)"
[03:21:08] <hayley> "No shit Sherlock?"
[03:21:20] *** Joins: childlikempress (~moon-chil@cardinal.elronnd.net)
[03:21:26] <moon-child> hayley: are you above shifting?
[03:21:26] *** Quits: moon-child (~moon-chil@cardinal.elronnd.net) (Remote host closed the connection)
[03:21:47] <gilberth> hayley: Yes, and then you could use just UTF-8. That already is a nice variable stage encoding. With the ASCII just having one stage. And you will perhaps deal with ASCII most of the time, anyway.
[03:21:50] <hayley> It hurts most with SIMD, else you're bottlenecked by branching, but at that point, it's plenty fast already.
[03:22:06] *** childlikempress is now known as moon-child
[03:22:28] <hayley> moon-child: I was thinking to use the hash-array mapped trie approach, i.e. have a word representing present entries, and then LDB and LOGCOUNT to find the compressed index.
[03:22:43] <gilberth> Oh dear. Buy those posters some brain, will you, hayley?
[03:23:04] <hayley> I think I'd get in big trouble for that.
[03:23:23] * moon-child nods
[03:23:45] <gilberth> hayley: Good luck with that approach. I still bet on branch prediction. But an interesting idea, I'd love to see results.
[03:24:42] <hayley> For \w we'd have like 1,108 comparisons for our 554 ranges. Not happening.
[03:25:27] <hayley> Okay, I guess you binary search those.
[03:25:29] <moon-child> binary search.  So more like 9
[03:25:34] <gilberth> log_2(554) = a bit more than nine. And you could balance on the expected frequency.
[03:26:12] <hayley> Still a damn lot.
[03:26:44] <hayley> Also recall that something has to compile that, and instruction locality would be nice too. 
[03:26:58] <moon-child> do the ascii bit in-line, and then call
[03:27:08] <hayley> That could work.
[03:27:19] <gilberth> I would still propose UTF-8. Generally the length of an UTF-8 already somewhat correlates with the frequency, I'd guess.
[03:27:23] <moon-child> hmm, no, that messes up your branch prediction
[03:28:05] <hayley> But OTOH I don't want to place Anglocentric bets, like how the Rust regex engine has a model for only the first byte; i.e. anything non-ASCII gets pretty hairy results.
[03:28:30] <hayley> But then Unicode perhaps already made them for me, by keeping the one byte ASCII characters.
[03:28:47] <gilberth> I mean, people might use the nice \w in their REs but still deal with ASCII data. No harm done.
[03:29:08] <gilberth> And BTW grep runs much faster with LC_CTYPE=C, ever noticed?
[03:29:32] <moon-child> yeah, the branch isn‚Äôt going to hurt you if you're running non-english text, and will help quite a bit with ascii
[03:29:55] <gilberth> hayley: I am happy with Anglo-Saxon bets. People will grep source code, logs, etcs. All ASCII.
[03:30:51] <hayley> Sure.
[03:31:04] <gilberth> And an occasional "√©" for "caf√©" won't hurt too much, especially when¬† you look for say just '"'.
[03:31:04] * selwyn bets ¬£100
[03:31:07] <selwyn> the anglo always wins
[03:31:36] * moon-child makes a redesign of unicode where all the most common classes are completely contiguous
[03:31:38] <moon-child> there, done!
[03:31:50] * gilberth bets ‚Ç¨200.
[03:32:05] <gilberth> moon-child: That would be really nice.
[03:32:31] <moon-child> it would never work.  They are constantly adding characters?
[03:32:35] <gilberth> After all nobody shuffled digits or letters in US-ASCII.
[03:32:35] <hayley> Monkey's paw: but none of the characters in a given class are in order, like EBCDIC.
[03:32:36] <moon-child> s/?/!/
[03:32:56] <hayley> Well, worse than EBCDIC I guess.
[03:33:07] <gilberth> Who uses EBCDIC?
[03:33:18] <moon-child> I PREFER SIXBIT
[03:33:36] <gilberth> WITH SIX BITS A WORD?
[03:34:00] <gilberth> chars, rather.
[03:34:02] <moon-child> SIX BITS PER CHARACTER STOP LIMITED PUNCTUATION STOP
[03:34:24] <moon-child> (ok, maybe not that few :)
[03:34:48] <gilberth> I PROPOSE <SHIFT> 5 <SHIFT> BITS
[03:35:53] <moon-child> what do you spend the extra space on?  '. () ?
[03:36:30] <gilberth> In five bits? Same as in six as it has a figure shift code.
[03:37:02] <hayley> .oO(He still didn't give me any advice on encoding ranges in a compact way. Probably just calls ALPHANUMERICP like CL-PPCRE does.)
[03:37:03] <moon-child> hmm
[03:37:09] <gilberth> I would need a dash and a semicolon.
[03:37:10] <pjb> moon-child: 6 bits are enough, there are even unassigned codes left!
[03:37:34] <hayley> Ironically using compression for tables might make my ALPHANUMERICP faster than that in SBCL.
[03:37:47] <Alfr> 6 bit character codes is a problem, that'd only make 64 characters, less than the 96 required.
[03:37:49] <gilberth> hayley: Is that a specific comment you refer to?
[03:38:09] <hayley> gilberth: I was referring to the lack of a comment, but one second...
[03:38:38] <pjb> moon-child: on 7090, the # are unassigned: "0123456789#=\"###+ABCDEFGHI%.)###-JKLMNOPQR√ò$*### /STUVWXYZ¬±,(###"
[03:38:45] <hayley> "I'm not sure what a good way to test membership of more complicated sets would be; I currently just inline it all, which would lead to code bloat. Using a bit/byte-map for those sets would also require non-negligible space."  "The number of ranges is indeed smaller than the number of characters, but there are still a lot of ranges." *Nothing on representing the ranges.*
[03:39:29] <gilberth> Alfr: Six bit has upper case letters only, which would then only be four chars to sacrifice. Let's take { } and [ ], we don't use them in CL that much.
[03:39:31] <pjb> Is a bitmap of 128 KB too much? (ceiling char-code-limit 8) #| --> 139264 ; 0 |# 
[03:40:10] <moon-child> pjb: how many 128k bitmaps do you need?
[03:40:13] <gilberth> pjb: For each equivalence class? Yes.
[03:40:18] <hayley> For each complex ISUM that might appear, yes. And I am not keen on bit addressing, because x86-64 is sometimes shit at it.
[03:41:22] <gilberth> That those bitmaps or tables are not feasible was the reason to use an interval sum representation in the first place. It would have been with just 8-bit character sets.
[03:41:49] <Alfr> gilberth, oh, I'd love to read that conformance statement, has to contain something like: ... due to platform character set limitations ...
[03:42:11] <gilberth> hayley: Ok, then, we would need a routine to turn an unicode code range to a RE on UTF-8, right?
[03:42:27] <hayley> Yes, I used to have one, but now I don't.
[03:42:42] <gilberth> Eaten by quantum GC?
[03:42:58] <hayley> Eaten by not updating it to use ISUMs.
[03:43:23] <gilberth> I'll craft one. Later.
[03:43:43] <hayley> Fortunately my tour of Hacker News and r/programming has not caused many people to dare download the engine, so I can still break things.
[03:43:43] <gilberth> Could need that for XML parsing anyway.
[03:44:00] <hayley> .oO(They're still wondering where the CL-PPCRE compatible functions are, surely.)
[03:44:20] <gilberth> With that brain-dead API?
[03:44:48] <hayley> Yes.
[03:45:21] <gilberth> Frankly, it's a good thing as people just don't get that we are POSIX compatible and not PCRE compatible.
[03:45:31] <hayley> Sure.
[03:46:57] <gilberth> I mean, would you advertise this as a drop-in replacement, you would get many complains of it "not working", while it would work perfectly. And we should be the only POSIX conformant implementation existing.
[03:47:25] <gilberth> Or: I still have to see another implementation which is.
[03:48:08] <gilberth> But people don't seem to care too much about a correct implementation.
[03:48:45] * hayley accidentally prints a 1 million character bit vector and Emacs hangs.
[03:49:12] <pjb>  (setf *print-length* 10)
[03:49:20] <gilberth> It doesn't hang, it just thinks very, very hard.
[03:49:47] <hayley> Sure, and I'll be dead long before computing A(10, 10). 
[03:50:08] <gilberth> What is A(10,10)?
[03:50:16] <hayley> (count 1 (bitmap #'alphanumericp)) ‚áí 110141
[03:50:17] <hayley> Ackermann function?
[03:50:17] <moon-child> ackermann
[03:50:28] <gilberth> Ah!
[03:50:44] <gilberth> Try using SIMD. :-)
[03:50:54] <hayley> (:
[03:53:39] * hayley has a vector of how populated with alphanumeric characters pages are. But only 469 256-character pages are actually needed of 4,352. 
[03:56:10] <hayley> Without compression, we could just use 48 4k pages, i.e. about 24.5kB of bitmap if we really wanted bitmaps, as all above 48 pages are all zero. Compression would only reduce it to 38 pages.
[04:05:32] * hayley just wrote a regex compiler to study for university. What went wrong?
[04:05:51] <White_Flame> university isn't for practical learning!
[04:06:22] <jasom> https://www.cs.purdue.edu/homes/dec/essay.criticize.html (written by a former professor of mine)
[04:06:23] -ixelp- How To Criticize Computer Scientists
[04:06:23] <White_Flame> the purpose of university is to sell textbooks!
[04:07:34] <gilberth> And to demonstrate that you could endure the drill and repeat knowledge in an exam.
[04:07:53] <White_Flame> the one thing that uni drills into you is your social security number (or other country equivalent)
[04:08:31] <gilberth> Hmm, I haven't noticed.
[04:09:53] <hayley> "An experimentalist will slip one or more of the following keywords and phrases into lectures and technical conversations: "architecture," "memory," "cpu" (sometimes abbreviated "CISC" or "RISC"), "I/O" or "bus", "network", "interface", "virtual", "compile" or "compiler", "OS" or "system", "distributed", "program" or "code", and "binary". They talk about building programs and running the resulting system on real computer systems."
[04:10:14] <hayley> "You can tell someone is a theorist because they slip one or more of the following keywords and phrases into lectures and technical conversations: "theorem", "lemma", "proof", "axiom", "polynomial time", "logarithmic", "semantics", "numerical", "complexity", "nondeterministic" or "nondeterminism", and "for large enough N". They write lots of equations, brag about knocking off the "extra log factor", and often end their lecture with an uppercase
[04:10:14] <hayley> "O" followed by a mathematical expression enclosed in parentheses. You can also recognize a theorist because they take forever to prove something that may seem quite obvious."
[04:10:30] <hayley> Hey, no fair, I do both. The ELS referees wouldn't believe that integer addition is commutative.
[04:11:50] <hayley> No, there are insults for both.
[04:22:00] * hayley goes to play Minecraft 1.18 now
[04:23:23] <kakuhen> hayley: https://arxiv.org/ftp/arxiv/papers/1003/1003.2081.pdf
[04:23:25] <kakuhen> reminded me of this paper
[04:26:09] <hayley> Cool, Minecraft just keeps crashing when I try to boot it.
[04:28:24] <hayley> Foo, they want Java 17 for 1.18.
[04:31:11] * hayley already had a repo for Zulu JVMs, uses that.
[04:37:16] <hayley> Well, I found the caves, but no cliffs.
[04:38:58] <gilberth> Looking for your idol?
[04:39:58] <hayley> The new Minecraft update is the "Caves and Cliffs Update", but it also does not help that there is no Cliff Click either.
[04:43:38] <hayley> https://www.youtube.com/watch?v=-iztsqviqko
[04:43:38] -ixelp- The Joy Circuit (Live 81) - YouTube
[04:47:06] <hayley> Well, BT only has a latency of 1 cycle, so better cache usage of a bitmap probably wins out.
[05:18:28] <hayley> If I handle the cases where a whole page is full as well as a whole page being empty, it appears relatively few are actually required.
[05:19:05] <hayley> 2912 bytes for ALPHANUMERICP!
[05:24:29] <hayley> Seems 256 bytes/page is the best for ALPHANUMERICP, ALPHA-CHAR-P and DIGIT-CHAR-P.
[05:24:55] <hayley> ...but GRAPHIC-CHAR-P is best with 4096 byte pages.
[05:31:37] <hayley> Problem: the vector of bit vectors is bloody huge. I could use a larger bit vector and a vector of smaller offsets into the bit vector, I guess.
[06:28:04] <hayley> https://twitter.com/FakeUnicode/status/1466227320499310595?s=20 lol
[06:37:17] <moon-child> how does the branch count for the sparse bitmap compare with binary search and hamt?
[06:37:44] <moon-child> just store a flag for empty/full pages?
[06:40:06] <gilberth> hayley: For ALPHANUMERICP I get this monster: <http://clim.rocks/gilbert/alphanumericp.svg>
[06:42:53] <gilberth> [I use "/" as my escape character as graphviz has issues with "\", that would be my bug for today.]
[06:49:06] <gilberth> I was hoping for more sharing.
[06:57:54] <hayley> IIRC I had to double escape to make Graphviz happy.
[06:58:53] <hayley> https://twitter.com/FakeUnicode/status/1466243359622635525 The letter regex.
[07:00:02] <gilberth> This doesn't work when I say \\xHH, it jumps onto the \xHH without checking that the there is a previous "\".
[07:00:25] <hayley> Oh dear.
[07:01:29] <hayley> gilberth: BTW how long does it take to generate \w{3}?
[07:02:08] <gilberth> I don't have \w.
[07:03:01] <hayley> Just ALPHANUMERICP 3 times then.
[07:03:18] <hayley> Ideally don't run Graphviz, just make a DFA. Does it take more or less than a second?
[07:03:46] <gilberth> hayley: On UTF-8? You don't want to know.
[07:05:03] <hayley> Well, sucks to be me if I want to match bytes on [:alpha:] now.
[07:05:27] <gilberth> Yep, we need a different approach.
[07:06:26] <hayley> I guess if we really believe that a. SIMDing prefixes handles like 90% of your performance and your runtime and b. most things are ASCII, then decoding UTF-8 on the fly to maintain the illusion of a codepoint DFA can't be so bad.
[07:07:08] <hayley> People still use NFA interpreters after all!
[07:08:25] <gilberth> Yes, they do. Milady, this is like with GC, only because the NFA does not expose the O(2^n) worst case, does not mean that it isn't there.
[07:09:08] <gilberth> They have the O(2^n) in execution time, we have it at compile time.
[07:09:55] <hayley> And in the case of UTF-8 at least, we can blindly skip around, since we won't accidentally match continuation bytes.
[07:10:32] <gilberth> But ok, grepping is different from scanning here. You could pick any must-be-there-substr for SIMD looking for it.
[07:11:09] <hayley> My point still holds merely if most things are ASCII, and people are stupid and use interpreters.
[07:11:54] * hayley celebrates having 60 stars on one-more-re-nightmare. Now wasm2ps isn't her most popular library.
[07:12:06] <gilberth> Yes. And do people really care about the gazillion other characters besides #\space considered to be \w ?
[07:13:16] <hayley> Probably not.
[07:13:39] * hayley now wants to find a use for PEXT, but can't think of any.
[07:13:52] <gilberth> What does PEXT do?
[07:14:23] <hayley> https://www.felixcloutier.com/x86/pext
[07:14:53] <gilberth> I can google myself. I was hoping for a tl;dr.
[07:15:22] <hayley> You pass in a mask and it extracts bits from a word, and then compacts them back together.
[07:15:42] <hayley> I have no idea what to do with it, but it is amusing.
[07:15:43] <gilberth> Ah, a multi LDB?
[07:15:49] <hayley> Sure.
[07:17:35] <hayley> It could work for some compression hack, but I have no idea what.
[07:21:01] <hayley> But my desktop is a big loser w.r.t PEXT performance, with a latency of 18 cycles to do one PEXT.
[07:23:18] <gilberth> lol
[07:24:55] <moon-child> hmm, pext is fast on zen3
[07:24:56] <moon-child> :/
[07:26:01] <hayley> Still I don't have a use.
[07:27:01] <White_Flame> I presume some sort of tag bits, GC bits, etc might be able to use something like that?
[07:27:44] <hayley> But I think the guy was...undescriptive with how he even handled these problems. IIRC Rust regex has functions for "previous character" and "next character" so it does decoding out of the DFA.
[07:29:19] <hayley> pub fn can_exec(insts: &Program) -> bool { [...] for inst in insts { match *inst { Char(_) | Ranges(_) => return false, ... } } true } // Foo, he doesn't even try.
[07:30:08] <moon-child> White_Flame: probably not, in those cases you just need to mask some bits, and you know ahead of time which ones
[07:30:22] <White_Flame> if you combine them into a lookup dispatch table?
[07:30:39] <White_Flame> but yeah, a plain test could just use masking, but pext could make the immediate you compare against encode smaller? :-P
[07:31:14] <gilberth> hayley: We can do that. First do the branch on \Sigma=0..127 to the next state directly, and only then go into the UTF-8 decoder. You will win for all ASCII.
[07:31:32] <moon-child> White_Flame: maybe, but pext itself is bigger so probably not
[07:31:51] <hayley> https://github.com/rust-lang/regex/blob/master/src/input.rs#L158-L165 Bastard!
[07:31:51] -ixelp- regex/input.rs at master ¬∑ rust-lang/regex ¬∑ GitHub
[07:32:16] <moon-child> and probably you'll be just comparing against a byte anyway
[07:32:23] <hayley> He does decode UTF8 on the fly.
[07:32:28] <moon-child> plus you burn a register specifying the desired mask
[07:32:44] <hayley> https://www.youtube.com/watch?v=G3LvhdFEOqs Hey, look, I have the second-from-top synthesizer in this video.
[07:32:44] -ixelp- OZZY OSBOURNE - "Mr. Crowley" 1981 (Live Video) - YouTube
[07:33:29] <gilberth> Or we would need an SIMD implementation of an UTF-8 decoder :-)
[07:33:31] <White_Flame> you can use pext to do utf-8 decoding
[07:33:51] <moon-child> haha good point
[07:33:55] <White_Flame> or at least to combine the textual bits together after ensuring the tagging bits
[07:33:56] <hayley> And this guy told me that he usually uses a byte DFA. That's a damn lie.
[07:34:21] <hayley> https://www.reddit.com/r/rust/comments/r6e5s3/the_onemorerenightmare_compiler/hmv2a69/ "If byte based (as I would expect), then you can't really just store ranges of codepoints."
[07:34:23] -ixelp- The one-more-re-nightmare compiler : rust
[07:34:39] <White_Flame> https://groups.google.com/g/julia-dev/c/GPd5sBnmrEg/m/hsfW8TCqPrYJ
[07:34:41] -ixelp- LLVM: trying to use x86 pext intrinsic
[07:34:45] <gilberth> White_Flame: I can do two PEXT: One for the both upper "tag" bits, then for the six bit payload.
[07:35:49] *** Joins: dave0 (~davezero@069.d.003.ncl.iprimus.net.au)
[07:36:10] <dave0> maw
[07:36:31] <gilberth> Hello dave0!
[07:36:40] <dave0> maw gilberth !
[07:37:18] <White_Flame> I bet you could pext 4 bytes of utf8 together, then pext together the tag bits and compute a mask without branching and mask the 1st pext'd value
[07:37:41] * hayley watches the video and tries to steal the synthesizer settings
[07:37:55] <moon-child> White_Flame: yes.  But branching is probably faster
[07:38:25] <gilberth> But also here: I would be happy with an UTF-8 decoder, which would be blazing fast in the ASCII case. I need PEXT^-1 to make 32-bit words from octets and a fast way to detect whether any MSB is lit. I'll consider my previous approach though and do dispatch on 0..127 first and then do utf-8 decoding on the fly.
[07:39:12] <moon-child> 'fast way to detect whether any MSB is lit'  VPTEST?
[07:39:33] <hayley> gilberth: Guess what, we have https://www.felixcloutier.com/x86/pdep too
[07:40:05] <gilberth> Sure, I never looked at SIMD instructions. I'm a practical SIMD noob.
[07:40:49] <hayley> That isn't SIMD.
[07:41:05] <gilberth> hayley: That only works at 64 bit at once, doesn't it?
[07:41:21] <hayley> 32 or 64.
[07:41:45] <gilberth> So one or two chars, will sure help a lot.
[07:47:55] <hayley> I guess we are still doing a codepoint DFA though.
[07:49:59] *** Quits: semz (~none@user/semz) (Ping timeout: 252 seconds)
[07:50:34] <hayley> https://www.youtube.com/watch?v=ZVKirxPRxkY
[07:50:34] -ixelp- One More Red Nightmare - YouTube
[07:50:42] <hayley> Well, I had my fun still.
[07:55:24] *** Joins: lisp123 (~lisp123@5.30.23.247)
[07:59:53] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[08:02:40] *** Joins: semz (~none@user/semz)
[08:12:09] <moon-child> hayley: some parts of that remind me of _shine on, you crazy diamond_
[08:12:57] <hayley> Yeah, 2:05-4:00 is a bit like that.
[08:19:17] <hayley> One small problem is that prefix extraction for SIMD is slightly harder if we are decoding UTF-8 on the fly. Now, say, a sequence of 3 isums of code points might not be of a fixed length.
[08:25:47] * hayley wants more UCS4, and a pony.
[08:26:17] <moon-child> multi-codepoint graphemes when
[08:26:40] <semz> isn't this basically what combining characters are
[08:26:51] * hayley uploaded an image: (11KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/KHewqBiBTaknJRnfovzcXqQA/bruhcha.jpg >
[08:27:06] <hayley> Oh well, I am safe in CL as long as no one wants to match bytes ever. Good enough for me.
[08:27:08] <semz> or the zero width joiner madness
[08:27:26] <moon-child> semz: yes
[08:27:38] <moon-child> I mean, in -nightmare, not in unicode
[08:28:23] <semz> nightmare, unicode, what's the difference
[08:28:42] <moon-child> :)
[08:29:56] <hayley> .oO(The only place that didn't pick up on the KC reference was r/rust apparently. Fucken kids.)
[08:31:46] <hayley> e.g. https://news.ycombinator.com/item?id=29404745 https://www.reddit.com/r/programming/comments/r5x5im/the_onemorerenightmare_regular_expression_compiler/hmpm723/ https://www.reddit.com/r/KingCrimsonCircleJerk/comments/r6aht9/compile_stuff_with_the_rythm_of_br00fs_trash/
[08:31:47] -ixelp- I express my appreciation for the author's reference to King Crimson - the track... | Hacker News
[08:52:29] *** Quits: kakuhen (~kakuhen@user/kakuhen) (Remote host closed the connection)
[08:53:32] *** Joins: kakuhen (~kakuhen@user/kakuhen)
[08:55:05] *** Quits: kakuhen (~kakuhen@user/kakuhen) (Client Quit)
[09:07:03] <gilberth> I believe it is safe to assume that when a box says "best before 01.10.14" that this refers to a date in the past.
[09:08:32] <hayley> If I hash consed bitmap pages, I could just have one #*00000.... and one #*11111.... page, and eliminate the test for sentinel values. But is the additional read, which I guess might be hot in cache, faster than branching?
[09:11:31] <moon-child> use 4k pages and make the mmu do it
[09:11:56] <hayley> Thanks, I never liked portable code anyway.
[09:12:04] <hayley> Or my TLB, for that matter.
[09:14:14] <moon-child> regarding read vs branch: you are probably going to branch on the result of the table lookup anyway.  So you trade one branch for two, each of which may be more predictable
[09:14:30] <hayley> True.
[09:16:27] <hayley> The extra branches to test for T and NIL seem to be faster here.
[09:17:03] <moon-child> wouldn't expect to get a clear idea of the d from microbenchmarks
[09:17:10] <moon-child> depends on the actual distribution of chars in the input
[09:20:56] <hayley> What's weirder is that the tests constantly touch a page that actually exists (for [0, 1024)). So the extra branches should be a net negative.
[09:22:16] <hayley> I think I like the hash consing idea more, since it'd handle any other equivalent pages (though I don't think I found any).  
[09:22:51] <moon-child> eh, correctly-predicted branches are free :)
[09:23:45] <hayley> This would be negative cost then.
[09:25:59] <hayley> Or not, now the roles have reversed when I threw SB-SPROF into the mix. sigh
[09:27:27] <moon-child> yeah, benchmarking can be a pain.  Recently I added alignment to some loop and it got slower
[09:28:20] <hayley> But I guess I'll just bet on hash consing, since that involves less code, and I have no other heuristics to use. 
[09:48:03] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 252 seconds)
[10:47:18] <hayley> https://www.youtube.com/watch?v=XlLBKZHVjSM
[10:47:18] -ixelp- [YTP] Pingu's mass murder spree - YouTube
[10:56:43] *** Quits: makomo (~makomo@user/makomo) (Ping timeout: 256 seconds)
[11:15:15] *** Joins: shka (~herr@83.175.151.96.piasta.pl)
[11:37:36] *** Joins: treflip (~user@95.79.32.99)
[11:39:00] *** Quits: pjb (~pjb@user/pjb) (Ping timeout: 268 seconds)
[11:54:33] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 252 seconds)
[11:56:17] *** Joins: aeth (~aeth@user/aeth)
[11:57:31] <hayley> All in all, using a double table rather than a full bitmap isn't that much slower, and you kinda asked for it if you're doing \w.
[12:09:06] * hayley next looks at PEXTing UTF-8 decoding
[12:12:32] <hayley> How many bits do we need to distinguish all the "types" of bytes? Looks like 17 from 32 bits, as we need to handle two three byte characters, or one four byte character. So we need 5+4+4+4 bits.
[12:16:08] <hayley> https://r-libre.teluq.ca/2400/3/Transcoding%20Billions%20of%20Unicode%20Characters%20per%20Second%20with%20SIMD%20Instructions.pdf apparently needs only 6,561 elements, which is much less than 2^17.
[12:19:00] *** Joins: pjb (~pjb@user/pjb)
[12:29:43] <dave0> hayley: wikipedia says amd64 has SSE2, are you using that for your simd utf-8 decoder?
[12:30:00] <hayley> I don't have a decoder, that's gilberth's homework.
[12:30:19] <dave0> aha okay
[12:35:23] <moon-child> don‚Äôt get gather until avx i think
[12:35:42] <moon-child> given gather i bet you can do a utf8 decoder that's fast _and_ branch-free
[12:35:44] <moon-child> maybe
[12:36:04] <moon-child> probably want scatter too though...overlapping writes aren‚Äôt that bad, right?
[12:39:28] <hayley> https://www.youtube.com/watch?v=FqTDhtJGQ04
[12:39:29] -ixelp- Emerson Lake & Palmer: TARKUS for piano - Massimo Bucci (1st version) - YouTube
[12:44:23] <hayley> https://github.com/rust-lang/regex/blob/master/src/utf8.rs So it has its own pretty branch heavy UTF-8 decoder. But I guess that one can avoid decoding if all the lengths of possible characters are the same.
[12:44:23] -ixelp- regex/utf8.rs at master ¬∑ rust-lang/regex ¬∑ GitHub
[13:16:24] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Remote host closed the connection)
[13:16:47] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[13:45:21] *** Joins: semz_ (~none@user/semz)
[13:45:24] *** Quits: semz (~none@user/semz) (Ping timeout: 268 seconds)
[13:47:22] *** Quits: treflip (~user@95.79.32.99) (Remote host closed the connection)
[13:55:52] <selwyn> shka: i am attending a talk on quantum support-vector machines
[13:56:03] <shka> on what?
[13:56:14] <shka> QUANTUM SVM?
[13:56:21] <shka> ... what? how?
[13:57:54] <selwyn> well it has just started
[13:58:07] <selwyn> i had heard about them before but know very little
[14:00:18] <Gnuxie> Q U A N T U M    M A C H I N E    L E A R N I N G
[14:00:20] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[14:01:12] <hayley> Q U A N T U M   R E G U L A R   E X P R E S S I O N S
[14:01:41] <Gnuxie> Q U A N T U M M Y
[14:01:52] <shka> well maybe there is some trick to get quantum kernel
[14:02:06] <hayley> https://en.wikipedia.org/wiki/Quantum_finite_automaton Fuck!
[14:02:07] <shka> or just conventional kernel, but with smaller n
[14:02:20] <shka> then SVM is on the table
[14:02:22] <shka> i guess
[14:02:27] <selwyn> yeah the latest slide appears to be about a quantum circuit parametrising a kernel
[14:02:46] * hayley complains to the CEO of quantum computers
[14:02:56] <hayley> /msg stylewarning bro what the fuck
[14:04:17] <dave0> fire quantum torpedos
[14:08:51] <sham1> What is this, Star Trek?
[14:09:10] <dave0> yes! capt picard
[14:09:17] <selwyn> hm
[14:09:31] <selwyn> quantum regular expressions probably still difficult
[14:32:26] *** Joins: treflip (~user@95.79.32.99)
[14:35:01] <selwyn> they use a quantum circuit to classify scikit-learn digits with high accuracy
[14:35:20] <selwyn> that is impressive
[15:04:06] <shka> but is it practical?
[15:04:30] <shka> if you are getting the same result as with the classical computer, only at a higher cost...
[15:05:15] <selwyn> it's impressive that they can do it on a 'irl' dataset
[15:05:20] <selwyn> i've never seen that before
[15:05:38] <shka> ok, i see
[15:05:43] <selwyn> but yes they are getting the same result as a classical computer
[15:05:47] <shka> well, SVM will do that 
[15:05:51] <selwyn> this is my criticism of d wave tbh
[15:06:01] <shka> so if your kernel is fine 
[15:06:04] <shka> it will work
[15:06:25] <shka> so in a way it was the easiest way to do that and call it quantum
[15:06:27] <selwyn> i wasn't convinced on the advantage of doing this on a quantum computer though
[15:06:35] <selwyn> shka: yeah i got that impression
[15:06:53] <selwyn> but when you are trying to show off performance on an ibm quantum computer with ~10 qubits
[15:06:59] <selwyn> you have to work with what you have
[15:08:58] <hayley> These are professional qubits, you can almost feel not getting fired for buying them!
[15:10:55] <selwyn> shka: there are some extra error sources associated with doing anything on a quantum computer
[15:11:07] <selwyn> so the fact that they could get similar classification accuracies is a result in itself
[15:11:30] <shka> right, but again, SVM is the best for that
[15:11:54] <shka> because you find the optimal fit 
[15:12:19] <shka> so it is somewhat noise resistant
[15:12:51] <selwyn> right
[15:14:14] <shka> selwyn: you would not be able to make back propagation with high noise because you need small and precise gradients 
[15:14:45] <shka> but SVM, come to think of it, is the easiest to make work
[15:14:48] <hayley> They don't train reduced resolution neural networks with reduced resolution, do they?
[15:14:49] <selwyn> its difficult to do backpropagation on a quantum computer anyway
[15:15:20] <shka> hayley: they may, but it is not the problem
[15:16:45] <shka> it is also, btw, why deep learning is almost certainly not how brain works
[15:16:54] <shka> biological channels are noisy 
[15:17:54] <hayley> IMO quite similar, since IIRC 8 bit or whatever networks were trained with stochastic rounding. So you just set a quantize with error above the quantum noise floor (only an amateur classical electrical engineer, sorry) and everyone is none the wiser.
[15:18:47] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 252 seconds)
[15:29:15] <sham1> Not even a quantum electrical engineer smh
[15:41:33] <selwyn> trying to understand the brain seems like hubris to me sometimes
[15:45:03] *** Joins: random-nick (~random-ni@87.116.180.220)
[15:47:53] <hayley> gilberth: jcowan suggested to binary search over the isum, more or less. And I figure, as the isum length is known at compile time, I can make it branch free.
[15:50:44] <hayley> But that's searching over the vector, and not doing it "in control flow", I guess.
[16:01:03] *** Joins: waleee (~waleee@h-82-196-111-63.NA.cust.bahnhof.se)
[16:07:11] *** Quits: waleee (~waleee@h-82-196-111-63.NA.cust.bahnhof.se) (Ping timeout: 252 seconds)
[16:15:55] <shka> selwyn: they are physical objects
[16:16:19] <shka> so they can and should be studied 
[16:17:10] <selwyn> whenever i look into things like computational neuroscience
[16:17:27] <selwyn> they have to take such a broad view that its hard to say whether its of any use or not
[16:18:08] <shka> lol
[16:18:19] <shka> and a quantum dude is saying that
[16:18:22] <shka> of all people :D
[16:24:47] <selwyn> lol
[16:24:58] <selwyn> i used to be worried that we just didn't have enough algorithms
[16:25:18] <selwyn> i am more bullish nowadays
[16:38:09] <selwyn> anyone have any idea what thin films could be used for in a silicon photonic chip?
[16:40:47] <shka> no clue 
[16:47:22] <edgar-rft> a quantum dude is only a quantum of a dude?
[16:47:45] <shka> i actually wonder what is the current state of the art in the photonic chips 
[16:49:05] <selwyn> well, the state of the art is that they are designing and building single photon detectors and sources
[16:49:08] <selwyn> which is very exciting
[16:50:24] <edgar-rft> building a single photon source is easy as long as no second one exists :-)
[16:50:59] <selwyn> lol
[16:51:32] <edgar-rft> no, seriously, they try to emit a single photon?
[16:51:49] <selwyn> yes
[16:51:56] <selwyn> more importantly, they do it deterministically
[16:52:02] <selwyn> which is very difficult
[16:52:03] <edgar-rft> is that even possible?
[16:52:25] <selwyn> answer appears to be yes
[16:52:42] <selwyn> or at least, the sources are only slightly non-deterministic
[16:52:57] <Gnuxie> bruh
[16:53:00] <selwyn> however the people developing them don't spill all the juicy details
[16:53:57] <selwyn> https://www.nature.com/articles/s41467-020-16187-8
[16:53:58] -ixelp- Near-ideal spontaneous photon sources in silicon quantum photonics | Nature Communications
[16:54:55] <selwyn> bruh indeed
[17:04:35] <pl> ehhhh, single photon detection is not that hard... so long as you have exactly one photon coming in
[17:05:05] <selwyn> but you want it in silicon
[17:05:07] <pl> photomultipliers do that pretty regularly, though with some inexactness in detecting things like exact energy
[17:05:08] <selwyn> with low dark counts
[17:05:10] <selwyn> low jitter
[17:05:12] <selwyn> and the rest of it
[17:05:18] <selwyn> this was achieved only recently
[17:05:40] <selwyn> iirc these ones additionally can resolve number quite well, which is not easy as you say
[17:06:22] <selwyn> https://en.wikipedia.org/wiki/Superconducting_nanowire_single-photon_detector
[17:06:25] <selwyn> its really cool!
[17:49:32] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Quit: Leaving)
[17:59:58] <shka> wonder if cosmic gamma radiation will trigger this detector
[18:03:10] *** Quits: treflip (~user@95.79.32.99) (Remote host closed the connection)
[18:04:05] *** Joins: treflip (~user@95.79.32.99)
[18:20:13] *** Joins: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net)
[18:44:31] *** Joins: Inline (~Inline@aftr-37-201-240-100.unity-media.net)
[18:47:25] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 252 seconds)
[18:49:12] *** Joins: aeth (~aeth@user/aeth)
[19:13:05] *** Quits: Inline (~Inline@aftr-37-201-240-100.unity-media.net) (Ping timeout: 252 seconds)
[19:13:24] *** Joins: Inline (~Inline@aftr-37-201-240-100.unity-media.net)
[19:27:23] *** Quits: treflip (~user@95.79.32.99) (Quit: ERC (IRC client for Emacs 27.2))
[19:34:34] <dave0> nite all
[19:35:19] *** Quits: dave0 (~davezero@069.d.003.ncl.iprimus.net.au) (Quit: dave's not here)
[19:43:20] *** Quits: Inline (~Inline@aftr-37-201-240-100.unity-media.net) (Ping timeout: 252 seconds)
[19:48:36] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[19:57:41] <shka> https://en.wikipedia.org/wiki/Overengineering
[19:57:43] <shka> that photo
[19:59:17] <selwyn> lol
[20:00:28] <selwyn> re the detectors i would guess that cosmic rays can't set them off but i am not sure
[20:01:55] <selwyn> photonic quantum computers are designed with error correction in mind so you wouldn't need to account for cosmic rays at the hardware level in any case
[20:19:11] <shka> selwyn: well, that's reassuring 
[20:19:48] <shka> because, well, matter-antimatter annihilation is something that can happen from time to time 
[20:20:27] <selwyn> they can only detect certain wavelengths of photons
[20:20:38] <selwyn> which makes me think that not just any kind of rubbish can set them off
[20:20:39] <shka> that's good
[20:22:18] <selwyn> anyway, it means that you can maintain a photonic quantum computer at around 8 kelvin
[20:23:28] <selwyn> no need for milli kelvin temperatures
[20:25:52] *** Joins: makomo (~makomo@user/makomo)
[20:28:17] <shka> seriously, the fuck they did with the youtube
[20:28:40] <selwyn> https://youtu.be/WQRmSOKgMPA?t=439
[20:28:41] -ixelp- Silicon Photonic Quantum Computing - PsiQuantum at 2021 APS March Meeting - YouTube
[20:28:44] <selwyn> yt works fine for me
[20:28:57] <shka> let me demonstrate the problem
[20:30:53] <shka> now it works also fine
[20:31:40] <shka> thing is, when launching two videos at the same time, one will freeze until the other one is closed
[20:31:50] <shka> and unfreezes INSTANTLY 
[20:32:02] <shka> it looks like there is some kind of limiter at work
[20:32:41] <shka> and it sometimes is overly aggressive 
[20:33:38] <White_Flame> I hate that sometimes a video starts autoplaying when you move to its tab, and sometimes it doesn't
[20:33:49] <White_Flame> unpredictable behavior sucks
[20:33:56] <ck_> it's the power of a/b testing
[20:34:39] <selwyn> > Germany to ban unvaccinated people from shops and bars
[20:34:41] <selwyn> wow
[20:35:01] <shka> something, something, apocalypse is near
[20:35:13] <shka> the mark of the beast and that stuff
[20:36:17] <White_Flame> the way that our state's numbers have been going, the daily case rate went up and steady once they started dropping mask requirements for vaccinated people
[20:37:25] <White_Flame> so both the antivaxxers and the vaccinated are spreading it now :-P
[20:37:32] <ck_> equality and justice for all
[20:38:04] <ck_> also, barred from entering bars, what a terrible fate, don't know what I would do in that situation
[20:46:34] *** Joins: Inline (~Inline@aftr-37-201-240-43.unity-media.net)
[20:51:43] *** Quits: Inline (~Inline@aftr-37-201-240-43.unity-media.net) (Ping timeout: 256 seconds)
[20:59:54] *** Quits: ozzymcduff (~mathieu@81-234-151-21-no94.tbcn.telia.com) (Remote host closed the connection)
[21:02:12] *** Joins: ozzymcduff (~mathieu@81-234-151-21-no94.tbcn.telia.com)
[21:05:42] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[21:10:07] *** Joins: mfiano (~mfiano@li1282-157.members.linode.com)
[21:13:14] *** Joins: CrashTestDummy2 (~CrashTest@cpe-24-168-60-220.hvc.res.rr.com)
[21:15:54] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[21:16:08] *** Quits: mfiano (~mfiano@li1282-157.members.linode.com) (Quit: leaving)
[21:16:28] <shka> does gnome files has some file-over-ssh support?
[21:16:39] *** Quits: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 256 seconds)
[21:18:36] *** Joins: mfiano (~mfiano@li1282-157.members.linode.com)
[21:20:03] *** Quits: CrashTestDummy2 (~CrashTest@cpe-24-168-60-220.hvc.res.rr.com) (Ping timeout: 256 seconds)
[21:20:56] <APic> No Idea.
[21:21:05] <APic> Sounds slow.
[21:24:46] *** Quits: mfiano (~mfiano@li1282-157.members.linode.com) (Quit: leaving)
[21:28:29] <White_Flame> shka: there's always sshfs, which all the file browsers will be able to browse into
[21:30:14] *** Joins: CrashTestDummy2 (~CrashTest@cpe-24-168-60-220.hvc.res.rr.com)
[21:31:18] *** Quits: rogersm (~rogersm@90.166.177.48) (Quit: Leaving...)
[21:32:24] *** Joins: yourname_ (~mfiano@li1282-157.members.linode.com)
[21:33:13] *** Quits: yourname_ (~mfiano@li1282-157.members.linode.com) (Client Quit)
[21:33:22] *** Joins: mfiano (~mfiano@li1282-157.members.linode.com)
[21:33:31] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 252 seconds)
[21:33:55] *** Joins: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net)
[21:37:11] *** Quits: CrashTestDummy2 (~CrashTest@cpe-24-168-60-220.hvc.res.rr.com) (Ping timeout: 252 seconds)
[21:42:03] *** Quits: mfiano (~mfiano@li1282-157.members.linode.com) (Quit: leaving)
[21:42:19] *** Joins: mfiano (~mfiano@li1282-157.members.linode.com)
[21:45:38] *** Quits: mfiano (~mfiano@li1282-157.members.linode.com) (Client Quit)
[21:45:47] *** Joins: mfiano (~mfiano@li1282-157.members.linode.com)
[21:50:03] *** Quits: mfiano (~mfiano@li1282-157.members.linode.com) (Client Quit)
[21:50:13] *** Joins: mfiano (~mfiano@li1282-157.members.linode.com)
[22:16:44] *** Joins: clothesp_ (~awolven@2601:246:4000:1030:b03d:2fe:e5d4:5326)
[22:31:41] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[22:34:01] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 252 seconds)
[22:34:12] *** Quits: clothesp_ (~awolven@2601:246:4000:1030:b03d:2fe:e5d4:5326) (Remote host closed the connection)
[22:36:03] *** Joins: aeth (~aeth@user/aeth)
[22:43:36] *** Joins: clothesp_ (~awolven@2601:246:4000:1030:b03d:2fe:e5d4:5326)
[22:49:33] *** Joins: robin__ (~robin@user/terpri)
[22:50:55] *** Quits: robin (~robin@user/terpri) (Remote host closed the connection)
[22:55:54] *** Quits: clothesp_ (~awolven@2601:246:4000:1030:b03d:2fe:e5d4:5326) (Remote host closed the connection)
[23:36:29] *** robin__ is now known as robin
[23:46:59] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 252 seconds)
[23:51:23] *** Joins: clothesp_ (~awolven@2601:246:4000:1030:b03d:2fe:e5d4:5326)
[23:57:25] *** Quits: clothesp_ (~awolven@2601:246:4000:1030:b03d:2fe:e5d4:5326) (Remote host closed the connection)
[23:59:21] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
