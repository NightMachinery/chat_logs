[00:17:47] *** Quits: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl) (Ping timeout: 260 seconds)
[00:28:13] *** Quits: geekosaur (~geekosaur@xmonad/geekosaur) (Remote host closed the connection)
[00:28:32] *** Joins: geekosaur (~geekosaur@xmonad/geekosaur)
[00:33:32] *** Quits: mvk (~mvk@2607:fea8:5ce3:8500::3800) (Ping timeout: 260 seconds)
[00:38:53] *** Joins: vicfred (~vicfred@user/vicfred)
[00:43:14] *** Joins: mvk (~mvk@2607:fea8:5ce3:8500::3800)
[01:02:42] *** Joins: zaquest (~notzaques@5.130.79.72)
[01:15:13] *** Quits: odnes_ (~odnes@5-203-146-18.pat.nym.cosmote.net) (Quit: Leaving)
[01:37:01] *** Quits: vicfred (~vicfred@user/vicfred) (Quit: Leaving)
[02:03:50] *** Joins: libertyprime (~libertypr@118-92-82-225.dsl.dyn.ihug.co.nz)
[02:17:23] *** Quits: libertyprime (~libertypr@118-92-82-225.dsl.dyn.ihug.co.nz) (Ping timeout: 246 seconds)
[02:19:10] *** Joins: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl)
[02:25:36] *** Joins: libertyprime (~libertypr@118-92-82-225.dsl.dyn.ihug.co.nz)
[02:41:40] *** Quits: zaquest (~notzaques@5.130.79.72) (Remote host closed the connection)
[02:44:08] *** Quits: coot (~coot@213.134.190.95) (Quit: coot)
[02:44:09] *** Joins: zaquest (~notzaques@5.130.79.72)
[02:48:18] *** Quits: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl) (Ping timeout: 260 seconds)
[02:57:00] *** Quits: mvk (~mvk@2607:fea8:5ce3:8500::3800) (Ping timeout: 240 seconds)
[02:59:58] *** Quits: liz (~liz@cpc84585-newc17-2-0-cust60.16-2.cable.virginm.net) (Ping timeout: 260 seconds)
[03:18:41] *** Quits: libertyprime (~libertypr@118-92-82-225.dsl.dyn.ihug.co.nz) (Quit: leaving)
[03:32:26] *** Quits: joes (~joes@hardfought/member/joes) (Ping timeout: 272 seconds)
[04:02:55] *** Quits: hololeap (~hololeap@user/hololeap) (Ping timeout: 240 seconds)
[04:03:35] *** Joins: hololeap (~hololeap@user/hololeap)
[04:16:35] *** Quits: hololeap (~hololeap@user/hololeap) (Ping timeout: 240 seconds)
[04:17:56] *** Joins: vicfred (~vicfred@user/vicfred)
[04:20:19] *** Joins: hololeap (~hololeap@user/hololeap)
[04:29:13] *** Quits: Pickchea (~private@user/pickchea) (Quit: Leaving)
[04:44:47] *** Joins: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl)
[05:05:58] *** Quits: benin (~benin@183.82.204.110) (Ping timeout: 260 seconds)
[05:19:28] *** Quits: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl) (Ping timeout: 272 seconds)
[05:41:04] *** Quits: Midjak (~Midjak@82.66.147.146) (Quit: This computer has gone to sleep)
[05:58:48] *** Joins: mvk (~mvk@2607:fea8:5ce3:8500::3800)
[07:15:48] *** Joins: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl)
[07:30:03] *** Quits: hololeap (~hololeap@user/hololeap) (Remote host closed the connection)
[07:31:24] *** Joins: hololeap (~hololeap@user/hololeap)
[07:49:32] *** Quits: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl) (Ping timeout: 246 seconds)
[08:07:31] *** Joins: benin (~benin@183.82.204.110)
[09:43:38] *** Quits: benin (~benin@183.82.204.110) (Ping timeout: 246 seconds)
[09:46:14] *** Joins: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl)
[09:56:14] *** Joins: benin (~benin@183.82.204.110)
[10:01:00] *** Quits: mvk (~mvk@2607:fea8:5ce3:8500::3800) (Ping timeout: 240 seconds)
[10:20:23] *** Quits: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl) (Ping timeout: 260 seconds)
[12:16:48] *** Joins: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl)
[12:25:22] *** Quits: x88x88x (~x88x88x@149.28.53.172) (Quit: ZNC - https://znc.in)
[12:45:30] *** Joins: odnes (~odnes@5-203-146-18.pat.nym.cosmote.net)
[13:30:45] *** Joins: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb)
[13:47:51] *** Quits: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl) (Ping timeout: 260 seconds)
[14:01:10] *** Joins: coot (~coot@213.134.190.95)
[14:16:41] *** Joins: liz (~liz@cpc84585-newc17-2-0-cust60.16-2.cable.virginm.net)
[14:25:25] *** Joins: jollygood2 (~bc8147f2@cerf.good1.com)
[15:13:15] *** Quits: toulene (~toulene@user/toulene) (Ping timeout: 260 seconds)
[15:17:14] <Christoph[m]> Good morning! I just read about DefaultSignatures (https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/exts/default_signatures.html).
[15:17:14] <Christoph[m]> I just checked, DefaultSignatures can be used to supply the default implementation (<*>) = ap in case there is a Monad instance. Is there a reason why that's not done?
[15:33:21] *** Joins: toulene (~toulene@user/toulene)
[15:33:53] *** Quits: toulene (~toulene@user/toulene) (Read error: Connection reset by peer)
[15:37:01] *** Joins: toulene (~toulene@user/toulene)
[15:40:50] *** Joins: Pickchea (~private@user/pickchea)
[15:44:43] *** Joins: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl)
[16:19:24] *** Quits: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl) (Ping timeout: 272 seconds)
[17:10:39] *** Quits: odnes (~odnes@5-203-146-18.pat.nym.cosmote.net) (Remote host closed the connection)
[17:11:01] *** Joins: odnes (~odnes@5-203-146-18.pat.nym.cosmote.net)
[18:16:51] *** Joins: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl)
[18:30:55] *** Quits: ski (~ski@remote12.chalmers.se) (Quit: Lost terminal)
[18:49:03] *** Quits: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl) (Ping timeout: 260 seconds)
[19:16:26] *** Joins: joes (~joes@hardfought/member/joes)
[19:25:27] *** Quits: jollygood2 (~bc8147f2@cerf.good1.com) (Quit: CGI:IRC (Session timeout))
[19:28:00] <dminuoso> Christoph[m]: It's probably just convoluted historical reasons.
[19:29:37] *** Quits: Pickchea (~private@user/pickchea) (Quit: Leaving)
[19:29:43] <abastro[m]> Perhaps it could potentially break downstream instances if DefaultSignature is used
[19:31:04] <dminuoso> It shouldn't, as ap = <*> is an implied law.
[19:31:18] <dminuoso> Besides, at worst this would only unbreak code.
[19:31:33] <abastro[m]> I mean, sth like performance impacts
[19:31:35] <dminuoso> The only way to trigger DefaultSignature is to not supply a definition for (<*>), which would just bottom out
[19:31:51] <dminuoso> If you've already supplied a definition for (<*>), it will not use the default implementation
[19:32:03] <abastro[m]> Hmmm
[19:32:33] <abastro[m]> Perhaps they are using the fact that it breaks
[19:32:48] <dminuoso> It seems most likely that it's a difficult proposal as that would break Haskell2020 compability
[19:32:49] <abastro[m]> And it suddenly doesn't break, they might complain
[19:33:07] <dminuoso> In the sense that they would alter a Haskell2010 class in a way that propagates without language extensions
[19:33:18] <dminuoso> That is, as a user you cant turn default methods on or off
[19:33:20] <abastro[m]> Oh wait
[19:33:33] <abastro[m]> Is Applicative a Haskell2010 typeclass
[19:33:57] <dminuoso> Mmm
[19:34:24] <dminuoso> Well, I guess not. But it would be communicating a language extension in the base library.
[19:34:32] <dminuoso> Without a possible opt-out
[19:34:46] <dminuoso> (since default sigs themselves are a language extension)
[19:34:59] <dminuoso> But really Im just speculating
[19:35:02] <abastro[m]> Hmm
[19:35:18] <abastro[m]> I mean I just thought of this: https://xkcd.com/1172/
[19:35:40] <abastro[m]> Perhaps someone's workflow relies on (<*>) being undefined
[19:35:45] <dminuoso> I very much doubt that.
[19:36:15] <dminuoso> Unprecise exceptions and essential impossibility of catching pure exceptions make me doubt that very much
[19:36:20] <dminuoso> *Imprecise
[19:36:48] <abastro[m]> <del>Perhaps I could start relying on (<*>) being undefined</del>
[19:37:26] <abastro[m]> Wait, you cannot catch exception thrown by undefined?
[19:38:00] <geekosaur> you have to be in IO to catch an exception
[19:38:29] <dminuoso> And you will have no way to find out the source of your exception
[19:38:51] <dminuoso> (part of the reason why is because of imprecise exception semantics)
[19:39:30] <dminuoso> Also there's not sufficient metadata at exceptions to figure out where a bottom came from
[19:39:39] <abastro[m]> Okay perhaps I will use the functionality to turn off the app then.
[19:41:01] <abastro[m]> This is too much for "jokes" hmm
[19:41:58] <dminuoso> A much better question is why `ap` isnt part of monad-of-no-return proposal. :p
[19:42:48] <dminuoso> But then again, we still have traverse and mapM, sequenceA and sequence, etc..
[19:42:49] <abastro[m]> Hmm.. why would it
[19:43:07] <dminuoso> Well, so this is part of the historical reasons now
[19:43:24] <dminuoso> Applicative wasnt always a superclass of Monad which is why we have ap and (<*>) at the same time
[19:43:36] <dminuoso> The new relationship essentially makes ap a useless a thing
[19:43:52] <abastro[m]> One might argue that using `mapM` gives us the precision
[19:44:16] <abastro[m]> Also, doesn't many ppl implement (<*>) using ap
[19:45:01] <geekosaur> now we're getting into the territory of backlash over constant breaking changes
[19:45:23] <dminuoso> The only reason mapM hasnt been yanked yet, was that there was theoretical considerations that mapM *might* have a slightly more efficient implementation than traverse.
[19:45:34] <dminuoso> That was Simon Marlows reservation a few years ago when it was brought up
[19:46:09] <dminuoso> But reality is, this is not being relied on, and I think you will have to conjur up exotic monads where this could be possible, let alone authors having enough of a bottleneck to special case it there.
[19:47:06] <dminuoso> And what geekosaur just said
[19:54:45] <abastro[m]> I mean, breaking changes are quite harmful
[19:55:13] <dminuoso> Mmm, I think there's many dimensions to this.
[19:55:37] <dminuoso> Breaking changes let you clean up past mistakes, improve UX for new beginners, and sometimes let you introduce new ideas.
[19:55:49] <dminuoso> The cost is friction amongst your users
[19:56:07] <dminuoso> The Linux kernel for example is on the extreme end of never altering an API
[19:56:20] <dminuoso> But that means something as absurd as ioctl is going to stay in the kernel for decades to come.
[19:56:44] <dminuoso> Other languages are on the other side, where standard libraries change every 6 months
[19:56:44] <abastro[m]> And reputation being research languages
[19:57:09] <dminuoso> Which gives them velocity, which promotes pinning but introduces costs of backporting security fixes, etc.
[19:58:03] <abastro[m]> Which language has stdlib changing every 6 months?
[19:58:09] <abastro[m]> Never heard of any personally
[19:59:25] <dminuoso> ECMAScript has quite a bit of velocity in that regard.
[19:59:43] <dminuoso> Heck, they change the language itself in these regular intervals.
[19:59:58] <dminuoso> Not in a total makeover, but any potentially breaking change is enough
[20:00:21] <abastro[m]> You mean JS std?
[20:00:24] <abastro[m]> Or is it sth else
[20:07:21] *** Joins: Midjak (~Midjak@82.66.147.146)
[20:10:31] <abastro[m]> If you do mean ECMAScript as a JS standard, they do retain backwards compatibility in some form.
[20:11:39] <abastro[m]> They also have a valuable tool called Babel
[20:11:50] <dminuoso> ECMAScript has yearly editions.
[20:12:06] <dminuoso> The point is: they alter the language in very regular intervals.
[20:12:23] <dminuoso> Which is a far higher bar than altering library functions.
[20:14:05] <abastro[m]> That is more or less without problem because they have good compatibolity tool
[20:14:43] <dminuoso> And babel is a symptom of another problem
[20:14:47] <dminuoso> Not a good solution.
[20:14:54] <abastro[m]> Which problem?
[20:15:38] <dminuoso> You do not have good forward compatibility in implementations, because code is not compiler to a standardized language like WASM (yet, mostly).
[20:15:54] <abastro[m]> What is the proble.
[20:15:54] <abastro[m]> Problem*
[20:16:31] <dminuoso> An interpreted language in a problem domain where the interpreter is almost never under a software authors control.
[20:16:38] <abastro[m]> Well, I guess it is fixed this way after using JS as web language
[20:16:42] <dminuoso> It's an extremely poor design choice.
[20:17:05] <abastro[m]> Still a choice ppl have to live with
[20:17:43] <abastro[m]> Also existence of babel helps them a lot with amending the changes
[20:17:53] <abastro[m]> Easier migration as well, I think
[20:18:14] <dminuoso> It's absurd because you now have a compilation step (so all the "benefits" of an interpreted language are gone now) but without any of the benefits (common/standardized ISA-equivalent, performance)
[20:18:21] <dminuoso> You get the worst of both worlds.
[20:18:45] <dminuoso> Debugging is impossible without source maps, which in the problem domain greatly complicate integration and deployment
[20:19:07] <abastro[m]> Instead you can more easily adopt future versions without much breakage
[20:19:19] <dminuoso> That's nonsense
[20:19:30] <dminuoso> If implementations targeted WASM, you wouldnt either.
[20:19:55] <dminuoso> and babel plugins are horrifyingly brittle
[20:20:11] <abastro[m]> Thing is, it might be harder to interop with different versions
[20:20:16] <dminuoso> the usual tooling to drive babel is even more horrible
[20:20:23] <dminuoso> I dont want to touch webpack at all in my life again
[20:20:32] <dminuoso> 17:50:11   abastro[m] | Thing is, it might be harder to interop with different versions
[20:20:34] <dminuoso> Why?
[20:20:37] <abastro[m]> I guess being interpreted language also helps with compats
[20:20:42] <dminuoso> no it doesnt
[20:20:57] <dminuoso> precisely because you pointed out, most js users have to go through babel for one reason or another
[20:21:12] <abastro[m]> Because you can simply port the language into former versions
[20:21:35] <dminuoso> again, wouldnt be necessary if you compiled your code into a low level language like wasm
[20:21:48] <dminuoso> because all you would need is for clients to be WASM compatible
[20:21:57] <dminuoso> they wouldnt even know what JS was
[20:22:02] <dminuoso> Or ECMAScript rather
[20:22:08] <abastro[m]> You can use older toolsets with newer stuffs as well
[20:22:16] <abastro[m]> I mean
[20:22:26] <dminuoso> thats fine, if you like it so be it
[20:22:28] <dminuoso> I dont
[20:22:56] <abastro[m]> Ofc it is not great for compat with browser
[20:22:57] <abastro[m]> However, what about compat with older code
[20:23:26] <abastro[m]> Compiling into older versions should allow easier interop, at least it did when I last checked
[20:24:08] <dminuoso> abastro[m]: not really
[20:24:34] <dminuoso> abastro[m]: since in most reasonable cases you use something like webpack to compile your application into a bundle, all the original code is at your disposal beforehand
[20:24:37] <dminuoso> so something like ABI wouldnt be a concern
[20:24:52] <dminuoso> much like it is in haskell, where you rarely end up with a binary Haskell module
[20:25:20] <abastro[m]> Yet haskell is ridden with backward-compatibility problems
[20:25:29] <dminuoso> Yeah, but that has nothing to do with ABI
[20:25:43] <dminuoso> The kind of problem potential *we* have, you have in JavaScript as well
[20:25:57] <dminuoso> Exactly *because* you usually go through webpack/babel
[20:26:10] <dminuoso> So your webpack/babel must be able to compile the entire transitive closure
[20:26:19] <abastro[m]> Well never heard of the kind ot problem we have in haskell in JS space tho
[20:26:45] <dminuoso> Part of it is because almost all problems are turned into runtime failures
[20:27:11] <dminuoso> you are frequently led to believe everything is fine, the rest is just people wondering why the menu wont open, and the odd bug report
[20:27:15] <abastro[m]> Well if so, that's a win for dynamic typing
[20:27:25] <dminuoso> referrings bugs to users?
[20:27:32] <dminuoso> Sorry I dont ever buy this argument.
[20:27:40] <dminuoso> If you think thats a win
[20:27:44] <dminuoso> Just use -fdefer-type-errors
[20:27:51] <abastro[m]> It does not always go to users as well
[20:27:53] <dminuoso> That's *exactly* the same thing
[20:28:01] <dminuoso> Go enable it, and you can have the same behavior in Haskell.
[20:28:02] <abastro[m]> Like, tests exist for a reason
[20:28:16] <dminuoso> It will always compile, and if it crashes, oh well - at least you weren't troubled to fix it.
[20:28:22] <dminuoso> abastro[m]: Type systems *are* tests.
[20:28:29] <abastro[m]> Hm actually
[20:28:44] <dminuoso> They are provably correct, automated tests with perfect coverage
[20:28:49] <abastro[m]> Maybe that is why more recent JS are not used in most shops
[20:29:22] <dminuoso> Why do you think most serious JS shops use TypeScript or flow?
[20:29:23] <abastro[m]> ES6 is the most recent in majority of shops
[20:29:35] <abastro[m]> They do?
[20:29:41] <dminuoso> Yes, IME they do.
[20:30:07] <abastro[m]> Well idk, what I've heard is many simply moving from JS to TS
[20:30:19] <abastro[m]> Oh
[20:30:20] <abastro[m]> No
[20:30:24] <abastro[m]> That is what not I mean
[20:30:35] <abastro[m]> I was intending to say, moving from ES5 to ES6
[20:31:16] <dminuoso> The kind of garbage "high velocity, high breakage" startup that attempt to fool investors into spending money more rapidly than the monkeys add npm libraries, they tend to not care
[20:31:23] <dminuoso> Because maintainability is not an important concern
[20:31:42] <abastro[m]> I am not talking about startups
[20:32:39] <dminuoso> Pick airbnb for instance, which is one of the largest ECMAScript drivers (they even have people on various boards responsible for ECMAScript and related)
[20:33:38] <abastro[m]> Well yeah what I've heatd is partly from System Integrators so
[20:33:46] <abastro[m]> They might be biased
[20:33:55] <dminuoso> https://i.redd.it/fi6ry4acqbf21.jpg
[20:34:10] <abastro[m]> Though in the other hand, most SW shops in where I live is SI
[20:34:21] <dminuoso> TypeSystems are automated test frameworks. As soon as you accept them as such, compile time breakage means less runtime bugs.
[20:35:07] <abastro[m]> Actually I think I can refer to an article in my local for a common attitude in SW around where I live
[20:35:18] *** Joins: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl)
[20:38:38] <abastro[m]> @paste
[20:38:38] <lambdabot> A pastebin: https://paste.debian.net/
[20:39:00] <abastro[m]> Eh, debian? Anyway
[20:39:53] *** Quits: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl) (Ping timeout: 246 seconds)
[20:40:41] <dminuoso> abastro[m]: Really the important gist is: When you experience compiler errors due to Haskell backwards compability issues, think of the type system as showing you where you have bugs. Why would you insist that a test would help here?
[20:40:59] <abastro[m]> https://paste.tomsmeding.com/8ZtQO8xL
[20:41:06] <dminuoso> Consider: that would mean you must have all tests that would detect *all* impedence mismatching bugs
[20:41:11] <dminuoso> the type system does this automatically without effort.
[20:41:14] <abastro[m]> RIP that is pasted as single line
[20:42:43] <abastro[m]> And translation was off.m
[20:43:01] <dminuoso> Almost every compile time error I get in Haskell is something that would have meant discovering that bug later in integration or by a user.
[20:43:06] <dminuoso> That is time saved.
[20:43:20] <dminuoso> You get the false impression that the lack of a type system increases velocity because it disturbs you less.
[20:43:32] <abastro[m]> Anyway the article is saying that an employee complained about why not going to ES6/TS, and the manager doing backlash against it and sharing it in public
[20:43:34] <dminuoso> And yeah sure, just flip on -fdefer-type-errors on Haskell, and you get that same false sense of security
[20:43:38] <dminuoso> GHC will no longer complain
[20:43:44] <dminuoso> Instead it will just flat out crash
[20:43:53] <abastro[m]> Saying that software industry is not somewhere you learn
[20:44:05] <abastro[m]> And that to be practical, it has to be put back
[20:44:11] <dminuoso> In JavaScript and other languages you get something even worse, depending on surrounding code it can be caught and silently discarded, hiding bugs making your software unpredicable
[20:44:37] <abastro[m]> They are also saying that technical debt is something you should leverage, not avoid
[20:45:07] <abastro[m]> Just like any debt regarding a business
[20:45:42] <dminuoso> That's a nonsense comparison.
[20:45:57] <abastro[m]> Wdym nonsense comparison
[20:46:57] <abastro[m]> Well for reference, that is posted on a popular website discussing SW development and was appreciated as a monthly best article.
[20:47:44] <abastro[m]> Imho, shows the reality of SW dev well - esp with its interaction with business
[20:47:52] <dminuoso> Technical debt is just an arbitrary phrase people utter nowadays to justify whatever it is they're doing.
[20:48:07] <dminuoso> The comparison with "debt" and likening it to an investment is just an absurd framing trick
[20:48:22] <abastro[m]> Yep it might be, but lots of ppl buy into it
[20:48:47] <dminuoso> The first fundamental problem about using the term technical debt is quantifiability.
[20:49:03] <dminuoso> Lets say Im tasking you to write some arbitrary piece of software.
[20:49:03] <abastro[m]> Basically it is driving the SW business practice.
[20:49:08] <abastro[m]> I mean, we can argue how wrong it is
[20:49:30] <dminuoso> Can you tell me, apriori, the exact *debt* in terms of man hours you would have to pay down the road for using a dynamic language?
[20:49:31] <abastro[m]> However, I am saying that this is how many businesses view tech.
[20:49:35] <dminuoso> Do you know, beforehand, the exact kind of bugs you will produce
[20:49:57] <dminuoso> the exact amount of lost gross income, the exact amount of hours spend in integratino bugs
[20:50:04] <dminuoso> the relaity is, you cant reasonably know
[20:50:11] <dminuoso> because you dont know what kind of bugs you will be producing
[20:50:22] <dminuoso> if this is a debt, its a completely unpredictable debt, you cant even make a guess
[20:50:41] <abastro[m]> For a fair comparison, one cannot accurately project how long would it take to pay back the debt
[20:50:46] <abastro[m]> Business environment, Interest rates and other factors exist
[20:51:11] <abastro[m]> But
[20:51:25] <abastro[m]> I don't want to argue about the validity of wording
[20:51:27] <abastro[m]> It's more about that this is common practice in industry
[20:51:34] <abastro[m]> So there is only 2 ways for it to change such view, either the businesses die out or break their ego and change
[20:52:12] <abastro[m]> I doubt possibility of the latter
[20:52:27] <dminuoso> "paying a debt off" suggests an investment. but in reality "technical debt" is just thrown around for "poorly written"
[20:52:28] <dminuoso> its sort of like
[20:52:47] <dminuoso> "lets botch this bridge, and fix it later"
[20:52:54] <abastro[m]> Which means.. ya perhaps we are confronting lots of bankruptcy ahead in the future
[20:52:56] <dminuoso> You wouldnt call this an investment. :-)
[20:53:11] <dminuoso> It's just gross negligence
[20:53:22] <dminuoso> And sure, it might be financially more feasible to botch the bridge
[20:53:28] <abastro[m]> It's either that, or maybe they have some truth in their views.
[20:53:29] <dminuoso> simply because its cheaper
[20:53:47] <dminuoso> but long term it means bridge will collapse, customers wont be as happy
[20:54:01] <abastro[m]> Most software does not need to be as robust as bridge tho
[20:54:09] <dminuoso> why not?
[20:54:16] <abastro[m]> Also customers seem to be quite happy for them
[20:54:39] <dminuoso> I've lost personal money before due to software bugs,
[20:54:47] <dminuoso> And because we have established a global attitude of
[20:54:48] <abastro[m]> Why? Because (I found that) most customers would put up with the (often sml) bugs
[20:54:55] <dminuoso> "software bugs, nothing can be done about that"
[20:55:02] <dminuoso> it means there's no way I can get my money back
[20:55:13] <abastro[m]> Yep
[20:55:31] <dminuoso> we had a person die in germany 2 years ago due to gross negligence in IT security of a hospital
[20:55:33] <dminuoso> but really
[20:55:40] <dminuoso> "hackers, nothing can be done about it"
[20:55:47] <dminuoso> you tell me "doesnt need to be robust"
[20:55:49] <dminuoso> I say differently
[20:55:49] <abastro[m]> Well until ppl start to actively complain about it
[20:55:58] <dminuoso> I pride myself on my work
[20:56:25] <abastro[m]> Things are not going to change
[20:56:25] <abastro[m]> Doesn't need to be robust in terms of business*
[20:56:38] <dminuoso> That is your opinion perhaps
[20:56:40] <abastro[m]> Robust software would be great, and is mandated if we consider morals
[20:56:45] <dminuoso> I like selling quality products.
[20:57:14] <dminuoso> At work resposible for the SDN that automates our core network, and I like that in the past 2 years we have not had a single outage caused by a bug in our automation.
[20:57:19] <abastro[m]> Well if it needed to be robust, there won't be so many companies selling buggy products
[20:57:24] <abastro[m]> Btw by business, I strictly mean profit-basis
[20:57:27] <dminuoso> (the past 2 years that we have been using that SDN stack)
[20:58:12] <dminuoso> 18:27:19   abastro[m] | Well if it needed to be robust, there won't be so many companies selling buggy products
[20:58:14] <abastro[m]> Anyway how do you think about loads of businesses out there which are fine with bugs?
[20:58:16] <dminuoso> Id say that would be a good thing
[20:58:27] <dminuoso> Yeah, and I feel like there should be regulatoin for that
[20:58:29] <dminuoso> There should be liability
[20:58:57] <abastro[m]> Indeed but
[20:59:55] <abastro[m]> We need ppl to start complaining
[20:59:57] <abastro[m]> And have some kind of strike
[20:59:57] <abastro[m]> I mean assembly
[20:59:58] <abastro[m]> I don't see it changing otherwise, because regulation does not appear from vacuum
[21:05:11] <abastro[m]> Said that, maybe there is a consumer movement to bring in regulation against writing bug-ridden software. Do you know of any? I would participate in those if I knew.
[21:42:37] *** Quits: coot (~coot@213.134.190.95) (Quit: coot)
[21:43:18] *** Joins: coot (~coot@213.134.190.95)
[22:30:04] *** Quits: vicfred (~vicfred@user/vicfred) (Quit: Leaving)
[23:03:00] <sm> https://www.rfc-editor.org/rfc/rfc9225.html
[23:32:27] *** Quits: hololeap (~hololeap@user/hololeap) (Remote host closed the connection)
[23:33:49] *** Joins: hololeap (~hololeap@user/hololeap)
[23:50:35] *** Joins: mvk (~mvk@2607:fea8:5ce3:8500::3800)
[23:54:47] *** Quits: liz (~liz@cpc84585-newc17-2-0-cust60.16-2.cable.virginm.net) (Read error: Connection reset by peer)
[23:54:59] *** Joins: liz (~liz@cpc84585-newc17-2-0-cust60.16-2.cable.virginm.net)
