[00:32:00] *** Quits: nexeq (~nexeq@user/nexeq) (Remote host closed the connection)
[00:33:43] *** Joins: nexeq (~nexeq@user/nexeq)
[00:33:55] *** Quits: nexeq (~nexeq@user/nexeq) (Remote host closed the connection)
[00:38:13] *** Quits: abrantesasf (~abrantesa@187.36.170.211) (Remote host closed the connection)
[00:38:15] *** Joins: nexeq (~nexeq@user/nexeq)
[01:30:41] *** Quits: nexeq (~nexeq@user/nexeq) (Remote host closed the connection)
[01:30:58] *** Joins: nexeq (~nexeq@user/nexeq)
[01:34:33] *** Quits: paule32 (~paul@user/paule32) (Ping timeout: 256 seconds)
[01:38:50] *** Joins: lisp123 (~lisp123@5.30.23.247)
[01:44:11] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[02:11:17] *** Quits: nexeq (~nexeq@user/nexeq) (Remote host closed the connection)
[02:11:33] *** Joins: nexeq (~nexeq@user/nexeq)
[03:00:13] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[03:03:25] *** Quits: random-nick (~random-ni@87.116.167.125) (Ping timeout: 240 seconds)
[03:03:34] *** Joins: Oladon (~olad@98.43.81.226)
[03:23:37] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 240 seconds)
[03:25:52] *** Joins: aeth (~aeth@user/aeth)
[03:35:55] *** Joins: aeth_ (~aeth@user/aeth)
[03:36:01] *** Quits: aeth (~aeth@user/aeth) (Killed (NickServ (GHOST command used by aeth_)))
[03:36:03] *** aeth_ is now known as aeth
[03:41:36] *** Joins: lisp123 (~lisp123@5.30.23.247)
[03:46:27] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[03:46:43] *** Joins: paule32 (~paul@nat-91-137-19-20.net.encoline.de)
[03:46:43] *** Quits: paule32 (~paul@nat-91-137-19-20.net.encoline.de) (Changing host)
[03:46:43] *** Joins: paule32 (~paul@user/paule32)
[04:56:00] *** Joins: paule32_ (~paul@nat-91-137-19-20.net.encoline.de)
[04:57:45] *** Quits: paule32_ (~paul@nat-91-137-19-20.net.encoline.de) (Changing host)
[04:57:45] *** Joins: paule32_ (~paul@user/paule32)
[04:59:01] *** Quits: paule32 (~paul@user/paule32) (Ping timeout: 240 seconds)
[05:22:52] *** Joins: lisp123 (~lisp123@5.30.23.247)
[05:25:51] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[05:26:22] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Quit: WeeChat 3.4)
[05:27:17] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 240 seconds)
[06:09:17] *** Quits: paule32_ (~paul@user/paule32) (Ping timeout: 240 seconds)
[06:13:54] *** Joins: tanners (~tanners@pool-71-127-59-41.washdc.fios.verizon.net)
[06:15:04] *** Parts: tanners (~tanners@pool-71-127-59-41.washdc.fios.verizon.net) ()
[06:29:23] *** Joins: imode (~imode@user/imode)
[06:38:13] *** Quits: sts-q (~sts-q@91.200.108.143) (Ping timeout: 240 seconds)
[06:43:27] *** Joins: sts-q (~sts-q@212.53.219.230)
[07:23:23] *** Joins: tanners (~tanners@pool-71-127-59-41.washdc.fios.verizon.net)
[07:28:47] *** Quits: tanners (~tanners@pool-71-127-59-41.washdc.fios.verizon.net) (Quit: Quit)
[07:28:59] *** Joins: tanners (~tanners@pool-71-127-59-41.washdc.fios.verizon.net)
[07:29:44] *** Quits: tanners (~tanners@pool-71-127-59-41.washdc.fios.verizon.net) (Client Quit)
[07:29:56] *** Joins: tanners (~tanners@pool-71-127-59-41.washdc.fios.verizon.net)
[07:30:27] <beach> Good morning everyone! 
[07:39:25] *** Joins: Oladon (~olad@98.43.81.226)
[07:58:09] *** Quits: tanners (~tanners@pool-71-127-59-41.washdc.fios.verizon.net) (Quit: Quit)
[08:07:24] *** Joins: Jing (~hedgehog@2604:a840:3::103c)
[08:11:03] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[08:16:12] *** Joins: gnoirzox (~gnoirzox@178.170.103.136)
[09:09:43] *** Joins: rain3 (~rain3___@2a02:2f09:d003:cb00:928d:3338:a339:f956)
[09:15:29] *** Quits: rain3 (~rain3___@2a02:2f09:d003:cb00:928d:3338:a339:f956) (Read error: Connection reset by peer)
[09:15:42] *** Joins: rain3 (~rain3___@2a02:2f09:d003:cb00:928d:3338:a339:f956)
[09:21:01] *** Quits: rain3 (~rain3___@2a02:2f09:d003:cb00:928d:3338:a339:f956) (Ping timeout: 240 seconds)
[09:21:38] *** Joins: rain3 (~rain3___@2a02:2f09:d003:cb00:928d:3338:a339:f956)
[10:04:12] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[10:12:59] *** Joins: artchad (~user@public-gprs233180.centertel.pl)
[10:49:05] *** Quits: Jing (~hedgehog@2604:a840:3::103c) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[11:05:34] *** Joins: paule32_ (~paul@nat-91-137-19-20.net.encoline.de)
[11:05:34] *** Quits: paule32_ (~paul@nat-91-137-19-20.net.encoline.de) (Changing host)
[11:05:34] *** Joins: paule32_ (~paul@user/paule32)
[11:10:34] *** Joins: Jing (~hedgehog@2604:a840:3::103c)
[12:55:57] *** Quits: Jing (~hedgehog@2604:a840:3::103c) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[12:56:40] *** Joins: Jing (~hedgehog@2604:a840:3::103c)
[13:12:44] *** Joins: lg113 (~lg113@238.pool85-51-16.dynamic.orange.es)
[13:15:53] *** Quits: lg113 (~lg113@238.pool85-51-16.dynamic.orange.es) (Remote host closed the connection)
[13:18:53] *** Joins: lg113 (~lg113@238.pool85-51-16.dynamic.orange.es)
[13:19:57] *** Quits: paule32_ (~paul@user/paule32) (Ping timeout: 240 seconds)
[13:21:23] *** Joins: lisp123 (~lisp123@5.30.23.247)
[13:25:01] *** Quits: lg113 (~lg113@238.pool85-51-16.dynamic.orange.es) (Remote host closed the connection)
[13:36:11] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[13:43:42] *** Joins: lisp123 (~lisp123@5.30.23.247)
[13:48:49] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[13:57:15] *** Joins: lg113 (~lg113@238.pool85-51-16.dynamic.orange.es)
[13:57:32] *** Parts: lg113 (~lg113@238.pool85-51-16.dynamic.orange.es) ()
[14:22:48] *** Joins: nij- (~jin@2001-48F8-9021-806-0-0-0-619B-dynamic.midco.net)
[14:23:04] <nij-> Hello! Why can't I load second climacs? https://bpa.st/L54A
[14:23:17] <nij-> I have put the folder in quicklisp/local-projects
[14:25:31] <artchad> what's climacs?
[14:25:32] <artchad> O . o
[14:26:37] *** Joins: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb)
[14:27:42] <nij-> CL based emacs?
[14:28:23] <artchad> sounds neat.
[14:28:32] <artchad> it seems like some system is not to be found
[14:29:18] <artchad> putting it in $HOME/.local/share/common-lisp might fix the issue 
[14:30:37] <nij-> I also think that quicklisp tries to pull climacs from the online repo rather than looking at the folder I put into manually.
[14:31:41] <artchad> I'm no quicklisp expert, but I would assume local systems have precedence over pulling them from a remote place.
[14:32:09] <artchad> what exactly did you do to try and install climacs?
[14:32:58] <artchad> I'd assume a simple (ql:quickload :climacs).
[14:33:01] * artchad tries that.
[14:33:43] <nij-> hmm lemme see
[14:34:24] <artchad> I personally get a different error. Component "clx" not found. Maybe the repos .asd file is out of date. Maybe the names of systems changed.
[14:34:31] <nij-> I `git clone` the repo, manually moved it under ~/quicklisp/local-projects/
[14:34:55] <artchad> can you link me the repo?
[14:34:58] <nij-> Did (ql:quickload :climacs). It still pulled from the internet.
[14:35:02] <nij-> Ah, correctly loaded!
[14:35:13] <nij-> https://github.com/robert-strandh/Second-Climacs
[14:35:37] <artchad> If it finally worked for you, that's nice.
[14:36:12] <artchad> I would usually check wether the thing I'm looking for is part of quicklisp. (ql:system-apropos "some string")
[14:38:03] <nij-> Hmm.. not sure it's the right thing I want
[14:38:15] <nij-> In any case, I do want quickload to use the local copy..
[14:39:33] <artchad> for me quicklisp always prefered to use local copy inside ~/quicklisp/local-projects
[14:40:04] <artchad> (ql:register-local-projects)
[14:40:06] <artchad> try that?
[14:40:52] <nij-> ;; => NIL
[14:41:43] <artchad> that command should rebuild the ~/quicklisp/local-projects/system-index.txt
[14:41:56] <artchad> I myself am just playing around. ;D
[14:42:14] <artchad> I'm not the maintainer.
[14:42:30] <nij-> lemme see that txt file
[14:43:42] <artchad> I tried grep -i clim ~/quicklisp/local-projects/system-index.txt
[14:43:57] <artchad> maybe the system you want to load is called second-climacs?
[14:44:15] <nij-> Second Climacs is indeed in system-index.txt
[14:44:26] <nij-> It's called second-climacs-base, I believe.
[14:44:59] <nij-> Ah. Ok, I think the problem is exactly that I do not have cluffer-emacs-compatibility.
[14:45:48] <nij-> Oh, which is provided here https://github.com/robert-strandh/cluffer-emacs-compatibility
[14:45:51] <beach> nij-: A system is missing: cluffer-emacs-compatibility. 
[14:45:59] <beach> Right.
[14:46:00] <nij-> I'm too spoiled by everything-on-quicklisp. Sorry about that.
[14:46:10] <artchad> nij-: you didn't follow the instructions carefully. D:
[14:46:33] <artchad> hi, beach.
[14:47:40] <nij-> Having it working! Thanks a lot!
[14:47:41] <beach> nij-: Second Climacs is not ready for general use.  That's why I haven't taken the time to make it easy to install.
[14:53:23] <nij-> beach: Suppose we have a full compiler that compiles elisp into CL (e.g. the GNU emacs buffers got translated completely into data, without a GUI). Do you think Second Climacs is ready to run the generated CL code?
[14:55:20] <beach> I don't see it.  There must be hundreds function in Emacs Lisp that do not exist in Common Lisp, and that are required to run Emacs.  Calls to those functions must be translated to calls to Common Lisp functions, but who is going to write those functions? 
[14:55:46] <beach> And I don't know what you mean by the buffer being translated into data. 
[14:55:56] <beach> Data must be accessed using functions. 
[14:56:06] *** Joins: paule32_ (~paul@nat-91-137-19-20.net.encoline.de)
[14:56:07] *** Quits: paule32_ (~paul@nat-91-137-19-20.net.encoline.de) (Changing host)
[14:56:07] *** Joins: paule32_ (~paul@user/paule32)
[14:56:18] <nij-> I mean, suppose those functions are written, and everything that's not done is the GUI.
[14:56:42] <nij-> The inner data representations of GNU emacs data structures are all presented.
[14:56:55] <beach> Well, then, you have everything you need, so you can run it in any Common Lisp implementation.  No need for Second Climacs. 
[14:58:50] <nij-> There should be codes that deal with GUI to show the data in visual.
[15:00:00] <beach> Second Climacs has code to present the result of parsing buffer text into some data structure, but that's different from what Emacs does.  But to display an Emacs buffer, I bet it's just a few lines of calls to CLX.
[15:00:24] <nij-> I see.
[15:00:46] <beach> I think if you want to have a clone of Emacs in Common Lisp, you might as well start from scratch, or from a more Emacs-like editor like LEM.
[15:08:36] *** Joins: random-nick (~random-ni@87.116.167.125)
[15:09:04] <beach> I am personally not interested in emulating Emacs.  After all, Emacs was written in 1984 or so and things have changed.  
[15:10:04] <beach> The point of Second Climacs (for Common Lisp editing) is to parse the buffer contents using Eclector so that we can have a much better understanding of what it contains than what Emacs does.  
[15:10:23] <beach> I am not even sure that Emacs would allow for any such sophisticated parsing technique. 
[15:19:03] *** Quits: paule32_ (~paul@user/paule32) (Ping timeout: 256 seconds)
[15:22:29] <beach> One more thing: there is lots of Emacs code that would not be part of an editor if it were to be translated to Common Lisp.  Emacs can display PDF or JPG in an Emacs buffer for instance.  What is the point of that?  It would be much better to have independent viewers written in Common Lisp and using McCLIM for the display.
[15:35:12] <nij-> I see your point.
[15:41:11] <random-nick> well in the case of JPGs, they're usually displayed in emacs as part of some document, such as when viewing a web page in eww or some other such format, so an independent viewer would not suffice
[15:41:27] <random-nick> but it is probably more part of emacs as a computing platform than emacs as a (plain)text editor
[15:42:38] <beach> Exactly, and I would prefer to have such a platform be independent of Second Climacs in a Common Lisp solution, and instead be part of a more general environment using McCLIM.
[15:45:51] *** Joins: lisp123 (~lisp123@5.30.23.247)
[15:50:13] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[16:22:13] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[16:31:20] *** Joins: Cake (~Cake@2a02:c7f:9b31:900:b935:eaea:eae5:7fca)
[16:37:29] <artchad> I've defined a method that takes a single argument, but I would like to change it so that it takes two arguments. How can I redefine such a method?
[16:37:38] <artchad> The generic function #<STANDARD-GENERIC-FUNCTION GK-UI:UPDATE-FILLED-AMOUNT-0 (1)> takes 1 required argument; was asked to find a method with specializers (PANEL T)
[16:38:32] <beach> You can't change the number of required arguments of a method so that it is different from the number of required arguments of the generic function it is a method on.
[16:40:28] <artchad> so I would have to evaluate defgeneric with the appropriate lambda list?
[16:40:35] <beach> The lambda lists must be congruent.
[16:40:39] <artchad> "I think you call that thing a lambda list.
[16:40:45] <artchad> si si
[16:40:55] <beach> Yes, you would have to redefine your generic function.
[16:50:23] *** Quits: artchad (~user@public-gprs233180.centertel.pl) (Read error: Connection reset by peer)
[16:51:42] *** Joins: artchad (~user@public-gprs233180.centertel.pl)
[16:56:52] *** Joins: jeffrey (~jeffrey@2001:1c00:b1c:4100::80c0)
[17:03:19] *** Joins: treflip (~user@user/treflip)
[17:07:45] *** Quits: Cake (~Cake@2a02:c7f:9b31:900:b935:eaea:eae5:7fca) (Remote host closed the connection)
[17:10:13] *** Quits: rotateq (~user@p200300e787097300818cd04b4ea1a4f3.dip0.t-ipconnect.de) (Ping timeout: 240 seconds)
[17:47:13] *** Joins: lisp123 (~lisp123@5.30.23.247)
[17:51:37] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 240 seconds)
[18:11:03] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[18:18:08] *** Quits: nexeq (~nexeq@user/nexeq) (Read error: Connection reset by peer)
[18:18:52] *** Joins: nexeq (~nexeq@user/nexeq)
[18:39:09] *** Quits: nij- (~jin@2001-48F8-9021-806-0-0-0-619B-dynamic.midco.net) (Remote host closed the connection)
[18:54:42] *** Joins: rotateq (~user@185.66.193.48)
[18:54:53] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[19:00:16] *** Joins: lisp123 (~lisp123@5.30.23.247)
[19:10:55] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[19:11:10] *** Joins: lisp123 (~lisp123@5.30.23.247)
[19:21:36] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[19:25:06] *** Joins: lisp123 (~lisp123@5.30.23.247)
[19:26:57] *** Quits: rain3 (~rain3___@2a02:2f09:d003:cb00:928d:3338:a339:f956) (Ping timeout: 240 seconds)
[19:35:08] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[19:36:19] *** Joins: lisp123 (~lisp123@5.30.23.247)
[19:36:54] *** Quits: lisp123 (~lisp123@5.30.23.247) (Client Quit)
[19:44:31] *** Joins: lisp123 (~lisp123@5.30.23.247)
[19:50:31] *** Joins: nij- (~jin@2001-48F8-9021-806-0-0-0-619B-dynamic.midco.net)
[19:50:51] <nij->  What's the best way to destructively add an entry to the tail of a list? Something like (setf *x* '(1 2)) (ADD 3 *x*) *x* ;; => (1 2 3) .. I currently use (setf *X* (append *X* (list 3))) to achieve this but it doesn't seem to be the most efficient way.
[19:51:17] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 240 seconds)
[19:51:37] <bremner> I don't think efficient (sublinear) access to the tails of lists is possible
[19:53:05] <nij-> How about pushing things from the head? (ADD 3 *X*) ;; => (3 1 2)?
[19:53:39] <bremner> are you looking for cons?
[19:54:21] <lisp123> (setf *x* (cons *x* 3)) - does that work?
[19:54:30] <nij-> Yeah, should be the same as (setf *X* (cons 3 *x*))
[19:54:46] <nij-> But it mentions *x* two times.
[19:55:17] <nij-> Oh, it's literally called (push 3 *x*).
[19:55:32] <nij-> Hmm.. I guess I should push things to the head instead of tail then. Thanks.
[19:55:41] <lisp123> But you wanted (1 2 3) not (3 1 2)
[19:56:16] <lisp123> Its a very big difference between the two, so be careful what you wish for ;)
[19:57:04] <White_Flame> head pushing is the fastest, but usually is paired with an nreverse at the end
[19:57:11] <White_Flame> also, head pushing is not destructive to the list itself
[19:58:09] <lisp123> White_Flame: So (nreverse (push 3 x)) is faster than (cons x 3)?
[19:58:15] <White_Flame> if you do want to push to the tail, it involves walking to the end and destructively setting teh cdr there
[19:58:24] <lisp123> Ah got it
[19:58:34] <lisp123> Forgot that part
[19:58:35] <White_Flame> (cons x 3) does not append to the list
[19:58:52] <White_Flame> if x is (1 2), then you get ((1 2) . 3)
[19:59:04] <lisp123> Indeed
[19:59:15] <White_Flame> (setf (cdr (last x)) '(3)) would push to the tail after traversing
[19:59:17] <lisp123> *quietly hides*
[19:59:24] <White_Flame> (last x) returns the last cons cell of the list
[19:59:47] <White_Flame> (or NIL if the parameter was already NIL, which isn't a cons cell)
[20:00:03] <edgar-rft> destructive APPEND is called NCONC
[20:00:05] <White_Flame> you also have to be careful about not modifying literal data
[20:01:02] <White_Flame> another thing that things like LOOP's COLLECT does is to remember the last cons cell as it builds the list in order
[20:01:25] <White_Flame> so you have 2 local variables, head & tail
[20:01:53] <White_Flame> where head remains the same, but (setf (cdr tail) (list new-val)) (setf tail (cdr tail))
[20:02:02] <White_Flame> on each addition
[20:02:59] <nij-> Gotcha
[20:03:06] <lisp123> White_Flame: Nice to know. That's a smart way of doing it
[20:03:59] <White_Flame> and if you don't store the tail cons cell, then LAST will always walk & find it for you
[20:04:12] <White_Flame> as in the first solution
[20:05:13] <lisp123> So the best way is to store the tail cons cell right, and avoid all this nreverse nonsense?
[20:05:27] <lisp123> (i dont mean nonsense in a bad way :P)
[20:06:06] <White_Flame> if you're purely holding it as local mutable data
[20:06:27] <lisp123> Makes sense, thanks White_Flame
[20:09:07] *** Joins: Oladon (~olad@98.43.81.226)
[20:09:41] <edgar-rft> Adding things to the end of a list is nearly never fast im Lisp, because builtin lists are singly-linked and you always have to traverse all elements to find the last one. You can of course build custom data structures maintaining a pointer to the last element for faster access but that means that the buitin list acessors (car, dr, first, second ..., last) probably won't work with your custom data structure 
[20:09:42] <edgar-rft> out of the box.
[20:10:54] <White_Flame> I think this is more in a singular lexical context, where you can hold head/tail local variables in a single iteration body
[20:11:04] <White_Flame> but yeah, if you're passing stuff around during the construction, then it's not as nice
[20:12:10] <White_Flame> and of course, pushing to head and nreverse is the easiest, and performance isn't bad if you're not in a tight loop or the lists aren't egregiously large
[20:13:33] <lisp123> edgar-rft: Thanks, that's a good reminder
[20:13:42] <lisp123> I'm going to save down this discussion so I don't forget in the future
[20:14:24] <lisp123> White_Flame: Yeah and if lists are large, perhaps it should be some other data structure
[20:15:34] <edgar-rft> lisp123: no worries, you'll do it wrong a few times and then you'll *never* forget it, that's how we all learned it :-)
[20:15:56] <White_Flame> you also need to have a dummy head cell, to have a CDR to add to
[20:16:15] <White_Flame> so in constructing (1 2 3), your head actually holds (nil 1 2 3) or whatever, then returns (cdr head)
[20:16:33] <White_Flame> because you can't (setf (cdr x) ...) when x is nil
[20:16:34] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[20:16:54] <White_Flame> so there's little bits like that accumulate more code than push/nreverse
[20:17:00] <lisp123> White_Flame: True, thanks
[20:18:06] <lisp123> edgar-rft: hehe :-) 
[20:22:17] <edgar-rft> Another gotcha with lists is that even computing the LENGTH of a list is also slow because it needs to traverse and count *all* elements. That's because in contrast to builtin arrays builtin lists do not maintain their length internally.
[20:22:45] *** Quits: Jing (~hedgehog@2604:a840:3::103c) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[20:22:47] <lisp123> That's true
[20:23:09] <lisp123> However, in contrast (to the defence of the venerable list), as a recursive data structure it has a lot of value in recursive algorithms
[20:24:10] <White_Flame> There are some things like instead of doing (> (length x) 10), you can walk X up to 10 steps to see if it's at least that long, and not actually calculate the full length
[20:24:37] <edgar-rft> cons cells (where lists are built from) have the advantage that you an build the weirdest custom data structures out of them :-)
[20:24:45] <lisp123> White_Flame: ooh! that's another great tip to remember
[20:25:21] <White_Flame> same if you're measuring which list is longer; you only technically have to trarverse the length of the shorter of the two
[20:26:50] <mfiano> Which should even work when comparing a proper list with a circular one, unlike the naive approach
[20:27:22] <lisp123> edgar-rft: Remind me of this, never knew how complicated it was to get CONS right https://www.xach.com/naggum/articles/3092837184154309@naggum.no.html
[20:29:45] <edgar-rft> lisp123: cons cells are great but you can also run rather quickly into an infinite mess :-)
[20:30:22] <lisp123> yep - it might be one of the best ways for lisp to give programmers enough rope to hang themselves on
[20:30:56] *** Parts: nij- (~jin@2001-48F8-9021-806-0-0-0-619B-dynamic.midco.net) (Using Circe, the loveliest of all IRC clients)
[20:31:06] <White_Flame> it's just an untyped 2-tuple, the minimum composite structure from which any composite can be built
[20:31:12] <edgar-rft> I built lots of custom data structures from cons cell where I totally lost track howto mange them after only a few hours :-)
[20:31:34] <White_Flame> edgar-rft: yeah, refactoring the structure gets impossible as well ;)
[20:31:35] <edgar-rft> *howto manage them...
[20:31:44] <White_Flame> need lots of accessor helper functions
[20:31:53] <White_Flame> and/or identification tags within the cons tree
[20:36:22] <edgar-rft> interesting Lisp exercise: try to write a possibly effiicient function for destructively removing a random element somewhere from the middle of a list without destroying the remaining list structure.
[20:40:26] <lisp123> (defun edgar-rft (list element acc) (cond ((equal (car list) element) (cons (nreverse acc) (cdr list)) (t (edgar-rift ((cdr list) element (cons (car list) acc)))))))))
[20:40:29] <lisp123> something like that?
[20:40:50] <aeth> if order doesn't matter, then even that operation might be faster on a vector than a list. Definitely clearer to understand.
[20:41:04] <aeth> just swap the last element into the element you remove and decrement the size of the vector by 1
[20:41:14] <aeth> (assuming either adjustable, or you track when to stop)
[20:41:34] <aeth> the downside, of course, being that you never reclaim space
[20:53:40] *** Quits: nexeq (~nexeq@user/nexeq) (Read error: Connection reset by peer)
[20:54:42] <edgar-rft> I have to say that I wrote such a funtion nearly 100 times and I never found a way without allocating additional memory.
[20:54:42] <edgar-rft> It doesn't neccessarily to identify a specific object, say I want to pop the (random length) element from a list without alloating any memory or destroying the order of the elements in the remaining list.
[20:54:42] <edgar-rft> lisp123: there's some copy&paste mess in your code
[20:56:05] <lisp123> edgar-rft: Sorry, I was typing it out here and not in the editor :P
[20:56:16] *** Joins: nexeq (~nexeq@user/nexeq)
[20:56:19] *** Quits: nexeq (~nexeq@user/nexeq) (Read error: Connection reset by peer)
[20:56:25] <lisp123> Let me do a pastebin
[20:59:28] *** Joins: nexeq (~nexeq@user/nexeq)
[21:01:34] *** Quits: nexeq (~nexeq@user/nexeq) (Read error: Connection reset by peer)
[21:13:21] <rotateq> edgar-rft: like yesterday when someone else showed and this weird paste site messed things up (plus also some bad code layout)
[21:16:35] <rotateq> lisp123: but maybe do instead "#include edgar-rft.h"
[21:18:09] <rotateq> "error: no dispatch macro character for #i found"
[21:18:26] <lisp123> https://plaster.tymoon.eu/view/2828#2828
[21:18:47] <lisp123> ehhh its bad because i hacked in an append, but now i'm tired for lisping :O *gives up*
[21:19:30] <rotateq> you could add a short doc-string :)
[21:20:29] *** Joins: nexeq (~nexeq@user/nexeq)
[21:20:40] <lisp123> "Inefficiently removes an item from a list non-destructively, even though destructively was asked. Oh and bugs."
[21:21:58] <rotateq> shall the ACCUMULATOR be an empty list at first?
[21:22:23] <rotateq> by intention i mean :P
[21:22:32] <lisp123> like ()?
[21:22:37] <rotateq> yes
[21:22:52] <rotateq> better write then (let ((accumulator '())) ...)
[21:22:57] <lisp123> yes that would be better :P My code didn't work so I resorted to good old trusty nil
[21:23:00] <lisp123> Never failed me
[21:23:06] <lisp123> THen I realised I had a typo elsewhere..
[21:23:21] <lisp123> I *did* try with () first though, to my credit
[21:24:54] <lisp123> edgar-rft: you should ask #commonlisp
[21:24:54] <rotateq> it may be syntactically the same, but not semantically
[21:25:48] <rotateq> another advise i learned from beach_ at some point here :)
[21:26:55] <lisp123> So (let ((x-marks-the-spot nil)) -> What is the semantic meaning?
[21:27:10] <lisp123> Falsity? Lack of Value?
[21:30:01] <lisp123> Okay, so I have a *real-world* question now. If I want to specialise on NOT class-A, is the best way to do (defmethod something (a) ...) and then (defmethod something ((a class-a)) "prevent the earlier defined method from applying")?
[21:30:15] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[21:30:24] <mfiano> http://www.lispworks.com/documentation/HyperSpec/Body/01_dadd.htm
[21:31:34] <rotateq> lisp123: something that could be set to anything at some point
[21:33:33] <lisp123> mfiano: Thanks!
[21:33:47] <lisp123> rotateq: didn't follow
[21:33:55] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[21:33:55] <rotateq> lisp123: why not?
[21:34:28] <lisp123> oh sorry, got it (thought it was in relation to my method 'something)
[21:34:34] <rotateq> :)
[21:36:15] <rotateq> but good that you use COND
[21:36:25] *** Joins: aeth_ (~aeth@user/aeth)
[21:36:30] *** Quits: aeth (~aeth@user/aeth) (Killed (NickServ (GHOST command used by aeth_)))
[21:36:33] *** aeth_ is now known as aeth
[21:40:42] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[21:45:41] *** Joins: Lanny (~Lanny@2600:1700:5f60:d2f:8468:ff44:88cf:d0da)
[21:46:32] *** Quits: epony (epony@user/epony) (Ping timeout: 240 seconds)
[21:48:56] *** Joins: Oladon (~olad@98.43.81.226)
[21:50:38] *** Joins: epony (epony@user/epony)
[21:54:21] <edgar-rft> this is what I usually do -> https://plaster.tymoon.eu/view/2830#2830
[21:54:43] <edgar-rft> I don't claim that this is the best code ever :-)
[22:01:49] <lisp123> Looks advanced :-)
[22:03:52] <rotateq> as edgar-rft is also some years in business ;)
[22:12:36] <edgar-rft> this an be useful if you want e.g. draw a random card from a finite set in a card game or similar situalions
[22:12:53] <rotateq> ah nice
[22:13:58] <rotateq> or the next lottery numbers
[22:14:46] <edgar-rft> ..or at least for writing little stupid games was where I used it most often for :-)
[22:16:16] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[22:16:17] *** Quits: treflip (~user@user/treflip) (Quit: good night)
[22:35:57] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[22:39:27] <White_Flame> by "without allocating additional memory", I presume that's heap memory?  just holding onto an existing cons cell in a local var shouldn't allocate anything GC-pressure wise
[22:42:07] *** Quits: aeth (~aeth@user/aeth) (Quit: Reconnecting)
[22:42:18] *** Joins: aeth (~aeth@user/aeth)
[22:44:58] <White_Flame> another interesting model I've seen is combine a hashtable, whose values are the cons cells of a list.  Then you can pretty immediately hop to any element.  The hashtable key probably shouldn't be the list index, though
[22:47:02] <White_Flame> hmm, too bad nthcdr isn't an accessor, else (pop (nthcdr index list)) would work nicely
[22:47:48] <White_Flame> still, (pop (cdr cell)) would remove the element after the current cell
[22:53:27] *** Joins: aeth_ (~aeth@user/aeth)
[22:53:42] *** Quits: aeth (~aeth@user/aeth) (Killed (NickServ (GHOST command used by aeth_)))
[22:53:47] *** aeth_ is now known as aeth
[23:02:40] <edgar-rft> My main concern was that in games you can have sets (lists or other structures made from linked cons cells) of non-trivial size and it works best if you allcoate all the memory once at the beginning of the game and then try to re-use things as much as possible to avoid lengthy garbage collection gaps. There are of course *many* ways to achieve that goal, my code is no way the best solution for *all* 
[23:02:40] <edgar-rft> possible situations.
[23:04:10] <White_Flame> sure, basically back into manual memory management & pooling
[23:08:37] <aeth> the problem space of games are basically just expressed as giant arrays of numbers. CL's not bad for that.
[23:08:48] <aeth> I mean, maybe you'd use lists in suboptimal ways for things like the pathfinding.
[23:15:22] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[23:16:45] *** Joins: lisp123 (~lisp123@5.30.23.247)
[23:21:17] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 240 seconds)
[23:45:08] *** Joins: nitrowheels (~nitrowhee@151.95.83.100)
[23:55:26] *** Joins: Oladon (~olad@98.43.81.226)
