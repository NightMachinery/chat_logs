[00:07:34] *** Joins: yauhsien (~yauhsien@118-167-41-229.dynamic-ip.hinet.net)
[00:12:20] *** Quits: yauhsien (~yauhsien@118-167-41-229.dynamic-ip.hinet.net) (Ping timeout: 268 seconds)
[00:31:06] *** Quits: Leone (~Leo@45.72.233.136) ()
[00:47:29] *** Quits: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se) (Ping timeout: 268 seconds)
[00:56:31] *** Joins: mst_ (~matthewt@vps-6c71e929.vps.ovh.net)
[00:56:43] *** Quits: Cienisty (Cienisty@user/cienisty) (Killed (strontium.libera.chat (Nickname regained by services)))
[00:56:48] *** Quits: ttmrichter-M (~ttmrichte@user/ttmrichter) (Ping timeout: 246 seconds)
[00:57:01] *** Joins: freem_ (~quassel@166.ip-51-178-51.eu)
[00:57:08] *** Joins: Cienisty (Cienisty@user/cienisty)
[00:57:10] *** Quits: mst_ (~matthewt@vps-6c71e929.vps.ovh.net) (Changing host)
[00:57:10] *** Joins: mst_ (~matthewt@perl/shadowcat-mst/chainsaw-wielder)
[00:57:29] *** Quits: mst (~matthewt@perl/shadowcat-mst/chainsaw-wielder) (Killed (sodium.libera.chat (Nickname regained by services)))
[00:57:29] *** mst_ is now known as mst
[00:57:47] *** Quits: freem (~quassel@166.ip-51-178-51.eu) (Ping timeout: 246 seconds)
[00:57:50] *** freem_ is now known as freem
[01:01:45] *** Joins: ttmrichter-M (~ttmrichte@user/ttmrichter)
[01:09:42] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[01:16:29] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 268 seconds)
[01:58:21] *** Joins: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se)
[02:59:40] *** Quits: rgrinberg (~textual@ip73-183-64-186.ct.co.cr) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[03:22:04] *** Joins: szutt (~szutt@116.37.2.145)
[03:32:37] *** Joins: rgrinberg (~textual@ip73-183-64-186.ct.co.cr)
[04:08:54] *** Joins: yauhsien (~yauhsien@118-167-41-229.dynamic-ip.hinet.net)
[04:13:38] *** Quits: yauhsien (~yauhsien@118-167-41-229.dynamic-ip.hinet.net) (Ping timeout: 260 seconds)
[06:16:28] *** Quits: jealousmonk (~user@2804:431:e7c4:3098:2e09:5aa9:4bb0:cca9) (Quit: ERC (IRC client for Emacs 27.1))
[06:42:05] *** Quits: cmsmcq (~cmsmcq@65.19.36.46) (Ping timeout: 268 seconds)
[06:54:02] *** Joins: cmsmcq (~cmsmcq@65.19.36.46)
[07:09:19] *** Quits: szutt (~szutt@116.37.2.145) (Quit: Client closed)
[07:17:30] *** Quits: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se) (Ping timeout: 260 seconds)
[07:26:06] *** Quits: Sheilong (uid293653@id-293653.ilkley.irccloud.com) ()
[07:31:02] *** Joins: yauhsien (~yauhsien@118-167-41-229.dynamic-ip.hinet.net)
[07:35:42] *** Quits: yauhsien (~yauhsien@118-167-41-229.dynamic-ip.hinet.net) (Ping timeout: 260 seconds)
[08:49:10] *** Quits: cbarrett (sid192934@id-192934.helmsley.irccloud.com) (Ping timeout: 260 seconds)
[08:50:20] *** Quits: econo (uid147250@user/econo) (Ping timeout: 268 seconds)
[08:50:46] *** Quits: pony (sid524992@smol/hors) (Ping timeout: 260 seconds)
[08:50:57] *** Quits: Balooga (sid407689@id-407689.lymington.irccloud.com) (Ping timeout: 268 seconds)
[08:51:10] *** Joins: Balooga (sid407689@id-407689.lymington.irccloud.com)
[08:52:04] *** Joins: cbarrett (sid192934@2a03:5180:f:1::2:f1a6)
[08:52:11] *** Joins: econo (uid147250@user/econo)
[08:52:22] *** Joins: pony (sid524992@smol/hors)
[09:06:26] *** Joins: yauhsien (~yauhsien@2402:7500:4e4:2cb1:35e8:471e:a055:9d52)
[09:19:40] *** Quits: skapata (~Skapata@user/skapata) (Remote host closed the connection)
[09:34:44] *** Quits: theglass (~glass@user/theglass) (Ping timeout: 246 seconds)
[09:46:07] *** Quits: rgrinberg (~textual@ip73-183-64-186.ct.co.cr) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[09:50:58] *** Quits: pbone (~pbone@159.196.16.104) (Ping timeout: 260 seconds)
[09:59:15] *** Joins: rgrinberg (~textual@ip73-183-64-186.ct.co.cr)
[09:59:49] *** Joins: pbone (~pbone@159.196.16.104)
[10:14:41] *** Quits: pbone (~pbone@159.196.16.104) (Ping timeout: 245 seconds)
[10:17:18] *** Joins: pbone (~pbone@159.196.16.104)
[10:24:16] *** Quits: yauhsien (~yauhsien@2402:7500:4e4:2cb1:35e8:471e:a055:9d52) (Remote host closed the connection)
[10:33:29] *** Joins: theglass (~glass@246.ip-137-74-113.eu)
[10:33:29] *** Quits: theglass (~glass@246.ip-137-74-113.eu) (Changing host)
[10:33:29] *** Joins: theglass (~glass@user/theglass)
[10:38:11] *** Quits: econo (uid147250@user/econo) (Quit: Connection closed for inactivity)
[10:42:29] *** Joins: yauhsien (~yauhsien@118-167-41-229.dynamic-ip.hinet.net)
[10:42:38] *** Quits: yauhsien (~yauhsien@118-167-41-229.dynamic-ip.hinet.net) (Remote host closed the connection)
[11:09:14] <Haxxa> ski Sorry (timezones) still working on this, other predicates can be defined that is fine.
[11:10:01] <Haxxa> Multiple solutions should be possible as long as they fit in that scope, if anyone had any examples I would appreciate it, I have managed to create predicates to find the larget value in a list but not create a permutation with it. 
[11:13:43] *** Joins: yauhsien (~yauhsien@118-167-41-229.dynamic-ip.hinet.net)
[11:18:26] *** Quits: yauhsien (~yauhsien@118-167-41-229.dynamic-ip.hinet.net) (Ping timeout: 245 seconds)
[11:38:26] <ski> Haxxa : ok. i guess one could imagine several (some may be more and some may be less efficient) ways of doing it
[11:39:02] <ski> one way would be to say that the second list is a permutation of the first, such that the last element is a maximal element ..
[11:39:38] <Haxxa> efficiency isn't important in this context, if you are willing to submit a pastebin of one example it would help my understanding a lot
[11:39:45] *** Quits: rgrinberg (~textual@ip73-183-64-186.ct.co.cr) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[11:39:58] <ski> .. but that seems rather wasteful, since number of permutations grows pretty quickly, and the number of those permutations which have the last element a maximal element would grow inversely proportional to the length of the list
[11:40:55] <Haxxa> how would you specify : such that the last element is a maximal element ,sorting seem trivial but specifying the tail as the largest element has not been obvious to me 
[11:40:55] <ski> another variant would be to select an arbitrary element (removing it from the list), then insert it anywhere, and then check that the last is maximal
[11:41:26] <ski> or, you could simply make a predicate which adds an element at the end, and use that, rather than inserting arbitrarily
[11:41:31] <Haxxa> yeah both of those cases would be feasible, speed isn't a concern
[11:41:48] <ski> (both of these would preserve the relative order of elements, apart from the moved element)
[11:43:02] <ski> if you're not concerned with perturbing the relative order of the other elements (and you don't care to generate *all* possible perturbations, like the permutation version would), then you could do a single "percolation" through the list
[11:43:53] <Haxxa> I don't mind generating all permutations even though its wasteful. I honestly am just struggling to create a single viable implementation at this stage 
[11:45:29] <ski> another version i was thinking about would skip past elements up to an arbitrarily selected point, and then continue, while checking that all elements are at most the selected one, which is finally inserted at the end .. but one'd need to do something, in order to make sure that the selected element is also at least the previous elements .. this one, if it can be made to work, would possibly be relatively 
[11:45:35] <ski> efficient (as would the percolation one) -- this one also doesn't disturb relative order
[11:45:54] <Haxxa> In essence what I am asking for is an example, I understand each variant but I struggle to create a predicate based on this 
[11:45:55] <ski> .. anyway, i thought i'd just mention some potential approaches
[11:46:02] <Haxxa> Thank you
[11:46:25] <ski> (by "percolation", i mean what "Bubble sort" does, if you're familiar with that)
[11:47:10] <ski> <Haxxa> how would you specify : such that the last element is a maximal element ,sorting seem trivial but specifying the tail as the largest element has not been obvious to me
[11:47:13] <ski> hmm
[11:47:52] <ski> well, i guess the simplest would be using a predicate which selects the last element, then another to check that it's maximal
[11:48:19] <ski> (or, if you prefer, compute a maximum, and then check that the last element is equal to that maximum)
[11:49:01] <ski> i think it would also be possible to walk the list to the end, then check that the last is maximal, "on the way back" (so that's a single "back-and-forth" list traversal)
[11:50:06] <ski> .. anyway, at this point, i suspect it would be better to use a clearer approach, than attempting to be clever, while making it more inscrutable
[11:50:37] <ski> well .. how would you write a predicate that relates a list to its last element ?
[11:51:24] <ski> presumably, it's have to be a recursive predicate, since lists are a recursive data structure
[11:51:42] <ski> so .. what's the base case, and what's the inductive/recursive case/step ?
[11:52:00] <ski> what's the simplest possible case of a list and its last element ?
[11:52:51] <Haxxa> ski I have 2 predicates designed for finding the max in the list: https://paste.debian.net/1218402/
[11:53:26] <Haxxa> How I then compare this to permutations in which the max element is the tail I'm not sure on.
[11:54:32] <ski> for maxlist/2, i'd factor out the computing of max of two numbers, into a separate predicate. (DRY : Don't Repeat Yourself. you're currently repeating the list traversal part, in the two clauses of maxlist/2)
[11:55:44] <Haxxa> I did that to try limit the number of predicates as the specification stated, as long as it works I'm fine efficiency is not relevant in this context over shorter predicates
[11:56:31] <ski> (oh, and `Max is Head' / `Max is TailMax' here is pretty useless. better to use `=' than `is' here (well, the first one could use `is', in case you explicitly want to allow arithmetical *expressions*, rather than (just) numbers, in the list. but to me it seems be better, a more sensible separation of concerns, to only allow plain numbers. if you have expressions, you could evaluate them prior to calling 
[11:56:37] <ski> maxlist/2)
[11:56:49] <ski> )
[11:58:07] <Haxxa> Thanks, I really think I'm going to need an example to put thi together, I have been working on this fo a while and I'm not really getting there.
[11:58:44] <ski> some point about factoring applies to maxl2/2 (including its helper predicate maxl2/3 .. which i might call maxl2_aux/3 here, to emphasize that the user is (presumably ?) not intended to call it directly, but rather call maxl2/2, which initializes your accumulator `WK' properly)
[12:00:37] <ski> oh, and maxlist/2 is known as the direct(ly) recursive solution, while maxl2/2 is the accumulating/accumulative solution. one advantage to the latter (in this case), is that it's tail recursive, the recursive call is the last call in the clause .. and so, they will run in constant stack space, rather than linear
[12:02:02] <ski> (or rather, it would, if you had made sure that only one clause could be tried .. which could be fixed by factoring out the "maximum of two" (while making that deterministic) ..)
[12:02:35] <ski> hm
[12:02:56] <ski> Haxxa : well, what do you think of defining a predicate `last_element(List,Element)' ?
[12:03:52] <ski> (oh, just noticed another problem, too .. you have no base case for maxlist/2)
[12:05:15] <Haxxa> Look, it breaks the requirements as it should be doable in one predicate, but maybe that specification is misinterpreted, maybe they just don't want the inbuilt predicates used.  but I would be happy to. Honestly at this stage, any solution that works I am happy with
[12:05:37] *** Joins: szutt (~szutt@116.37.2.145)
[12:05:44] <ski> hm, do you prefer top-down or bottom-up coding ?
[12:05:47] <Haxxa> as long as I have a predicate/2 which takes an inlist and outputs an outlist with the biggest element last 
[12:05:55] <Haxxa> (integer)
[12:06:08] <Haxxa> I don't mind whatever is easier.
[12:06:33] <Haxxa> Just need to see it in concrete terms so I can understand it
[12:06:38] <ski> (iow, do you want to try defining last_element/2 first .. or do you want to define say move_max_right/2 first, in terms of last_element/2 (and perhaps something more), and only then define last_element/2 ?)
[12:07:14] <Haxxa> The former is sufficient 
[12:07:18] <ski> well, bottom-up is more concrete in the sense that you get to see some kind of working results sooner (albeit not working results for the main task)
[12:07:25] <ski> so
[12:07:32] <ski> <ski> well .. how would you write a predicate that relates a list to its last element ?
[12:07:35] <ski> <ski> presumably, it's have to be a recursive predicate, since lists are a recursive data structure
[12:07:38] <ski> <ski> so .. what's the base case, and what's the inductive/recursive case/step ?
[12:07:42] <ski> <ski> what's the simplest possible case of a list and its last element ?
[12:08:59] <Haxxa> I don't know.
[12:09:09] <Haxxa> I am still learning
[12:09:14] <ski> well, the simplest possible list is the empty list
[12:09:21] <ski> what's the last element of an empty list ?
[12:10:01] <Haxxa> it lacks one
[12:10:21] <ski> yep. so the empty list is not the base case
[12:10:35] <ski> so, the next possible simplest list is a list with one element, right ?
[12:10:40] <Haxxa> yes
[12:10:40] <ski> like `[Element]'
[12:10:45] <ski> what's the last element of that list ?
[12:10:49] <Haxxa> Element
[12:10:52] <ski> yep
[12:10:58] <ski> so, now you can state the fact :
[12:11:05] <ski>   last_element([Element],Element).
[12:11:09] <ski> which states :
[12:11:29] <ski>   The last element of the singleton list containing `Element', is `Element'.
[12:11:37] <ski> ok, so far ?
[12:11:40] <Haxxa> yep
[12:11:52] <ski> next, we need a recursive case
[12:11:59] <Haxxa> The next step will need to be recursive for a list thats not singleton or empty
[12:12:29] <ski> usually, with lists, the recursive case is a list with at least one element. occasionally, it could be a list with at least two (or three, &c.) elements, though
[12:12:49] <ski> mm
[12:13:00] <ski> so, one could start with writing something like
[12:13:16] <ski>   last_element([Element|List],LastElement) :- ...
[12:13:30] <ski> (`...' indicating code yet to be written / filled in)
[12:14:18] <ski> now, for the recursive case to be recursive, it ought to contain a recursive call. and, typically, the recursive call should be called on "smaller" arguments, in some sense
[12:14:36] <ski> something like
[12:14:48] <ski>   last_element([Element|List],LastElement) :- ..last_element(...,...)..
[12:15:24] <ski> for lists, "smaller" usually means a tail of a list that you got as parameter of the current call (what's to the left of the `:-')
[12:15:56] <ski> in this case, the tail of `[Element|List]' is `List', so following that, we'd get
[12:15:59] <ski>   last_element([Element|List],LastElement) :- ..last_element(List,...)..
[12:16:10] <ski> Haxxa : this making any sense ?
[12:16:41] <ski> for concreteness, you can imagine a concrete test case, when pondering what the code should be like, e.g.
[12:16:57] <ski>   ?- last_element([a,b,c,d],Last).
[12:17:37] <Haxxa> Yes, it does although, I appreciate the help. its a bit challenging to follow through IRC messages though, I think I will do some more reading. I feel a bit tired and defeated.
[12:18:06] <ski> and, you know that `[a,b,c,d]' is not a singleton list (it doesn't match `[Element]', in the base case), but it does match `[Element|List]' .. what concrete values would that give to `Element' and `List', for this example ?
[12:20:01] <ski> then, the important bit, when thinking recursively, is that you should simply trust that the recursive call will do its intended job, and then you should see how you could connect the current input to the input of the recursive call (we already have a candidate for this), and how to connect the output of the recursive call to the desired output of the current call
[12:20:58] <ski> (people often attempt to trace through exactly what happens across recursive calls. it can sometimes be nice to do that, but often it can also just add extra cognitive burden)
[12:21:10] <ski> hm
[12:24:12] <ski> in the case of `last_element([a,b,c,d],Last)', you can probably guess that we want the recursive call to be `last_element([b,c,d],TailLast)' .. now, assuming that the recursive call does its job, `TailLast' will be the last element of `[b,c,d]' (which we know ought to be `d') .. so, the question then is, given that `TailLast = d', what code should we write (in terms of `TailLast', and possibly 
[12:24:18] <ski> `Element',`List'), in order to make `Last' become the last element of `[Element|List]', iow of `[a,b,c,d]' (which is ?) ?
[12:25:35] <ski> Haxxa : i'm not sure i'm able to give more details/hints than that, without either me simply giving it away (in which case you learn less), or else you giving feedback that i could respond to
[12:25:49] <Haxxa> okay, thanks for your help
[12:29:17] <ski> (well, i could perhaps remind you that `[a,b,c,d]' is shorthand notation for `[a|[b,c,d]]', which is shorthand for `[a|[b|[c|[d|[]]]]]' .. although, hopefully you already know this. lists are "single-linked lists", in Prolog. every list is either the empty list `[]', or a non-empty list `[X|Xs]' consisting of its first element `X', and the list `Xs' containing all the remaining elements (the tail of the 
[12:29:23] <ski> list, which may be empty). we have direct access to the first element of a (non-empty) list. the only way to access other elements (e.g. the last), is by traversing the "chain" of links from the first "cons cell" `[a|...]')
[12:31:12] <ski> .. and judging from your struggles, i'd say you need more practice with writing recursive predicates, e.g. on lists, but also possibly on numbers
[12:32:56] <ski> .. if you'd like to, i could give code (and explanations) for recursive definitions of some other predicates .. but perhaps you'd prefer to read atm, or perhaps take a short break, maybe a quick walk outside in fresh air or something
[12:45:08] *** Joins: Lycurgus (~juan@98.4.112.204)
[13:07:32] *** Joins: Leone (~Leo@45.72.233.136)
[13:20:13] *** Quits: Lycurgus (~juan@98.4.112.204) (Quit: Exeunt)
[17:27:18] *** Joins: X-Scale` (~ARM@165.201.137.78.rev.vodafone.pt)
[17:28:21] *** Quits: X-Scale (~ARM@83.223.240.168) (Ping timeout: 268 seconds)
[17:29:50] *** X-Scale` is now known as X-Scale
[18:06:00] *** Joins: X-Scale` (~ARM@31.22.160.27)
[18:07:12] *** Quits: X-Scale (~ARM@165.201.137.78.rev.vodafone.pt) (Ping timeout: 268 seconds)
[18:08:52] *** X-Scale` is now known as X-Scale
[18:23:50] *** Quits: choas (~lars@ppp-188-174-49-112.dynamic.mnet-online.de) (Ping timeout: 268 seconds)
[18:25:07] *** Quits: TheCoffeMaker_ (~TheCoffeM@125-121-245-190.fibertel.com.ar) (Quit: So long and thanks for all the fish)
[18:25:16] *** Joins: choas (~lars@ppp-188-174-55-18.dynamic.mnet-online.de)
[18:27:03] *** Joins: TheCoffeMaker (~TheCoffeM@user/thecoffemaker)
[18:56:06] *** Quits: choas (~lars@ppp-188-174-55-18.dynamic.mnet-online.de) (Ping timeout: 260 seconds)
[19:02:50] *** Joins: choas (~lars@ppp-188-174-52-206.dynamic.mnet-online.de)
[19:03:49] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[19:19:51] *** Quits: szutt (~szutt@116.37.2.145) (Quit: Client closed)
[19:30:12] *** Joins: skapata (~Skapata@2804:14c:87b0:a6f9:477:1061:59ab:6b1f)
[19:30:12] *** Quits: skapata (~Skapata@2804:14c:87b0:a6f9:477:1061:59ab:6b1f) (Changing host)
[19:30:12] *** Joins: skapata (~Skapata@user/skapata)
[19:37:35] *** Joins: rgrinberg (~textual@ip73-183-64-186.ct.co.cr)
[19:51:21] *** Joins: Lycurgus (~juan@98.4.112.204)
[20:01:37] *** Joins: yauhsien (~yauhsien@118-167-41-229.dynamic-ip.hinet.net)
[20:19:52] *** Quits: rgrinberg (~textual@ip73-183-64-186.ct.co.cr) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[20:52:32] *** Joins: rgrinberg (~textual@200.5.63.76)
[20:53:23] *** Joins: econo (uid147250@user/econo)
[21:04:58] *** Quits: rgrinberg (~textual@200.5.63.76) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[21:13:05] *** Quits: Lycurgus (~juan@98.4.112.204) (Quit: Exeunt)
[21:21:24] *** Joins: rgrinberg (~textual@200.5.63.76)
[21:43:39] *** Quits: skapata (~Skapata@user/skapata) (Ping timeout: 268 seconds)
[21:46:29] *** Joins: pelle (~pelle@83-94-28-36-cable.dk.customer.tdc.net)
[21:52:02] *** Joins: skapata (~Skapata@2804:14c:87b0:a6f9:a052:a7f8:c6e4:b537)
[21:52:02] *** Quits: skapata (~Skapata@2804:14c:87b0:a6f9:a052:a7f8:c6e4:b537) (Changing host)
[21:52:02] *** Joins: skapata (~Skapata@user/skapata)
[22:04:27] *** Joins: Sheilong (uid293653@id-293653.ilkley.irccloud.com)
[22:08:03] *** Quits: yauhsien (~yauhsien@118-167-41-229.dynamic-ip.hinet.net) (Remote host closed the connection)
[22:08:39] *** Joins: yauhsien (~yauhsien@118-167-41-229.dynamic-ip.hinet.net)
[22:19:33] *** Quits: yauhsien (~yauhsien@118-167-41-229.dynamic-ip.hinet.net) (Remote host closed the connection)
[22:20:05] *** Joins: yauhsien (~yauhsien@118-167-41-229.dynamic-ip.hinet.net)
[22:24:21] *** Joins: pizzapal (~pizzapal@047-227-081-076.res.spectrum.com)
[22:30:36] *** Quits: rgrinberg (~textual@200.5.63.76) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[22:35:07] *** Joins: rgrinberg (~textual@200.5.63.76)
[22:38:10] *** Quits: yauhsien (~yauhsien@118-167-41-229.dynamic-ip.hinet.net) (Remote host closed the connection)
[22:38:42] *** Joins: yauhsien (~yauhsien@118-167-41-229.dynamic-ip.hinet.net)
[22:43:50] *** Quits: yauhsien (~yauhsien@118-167-41-229.dynamic-ip.hinet.net) (Ping timeout: 260 seconds)
[22:50:48] *** Quits: pelle (~pelle@83-94-28-36-cable.dk.customer.tdc.net) (Remote host closed the connection)
[22:58:18] *** Quits: pizzapal (~pizzapal@047-227-081-076.res.spectrum.com) (Read error: Connection reset by peer)
[23:26:46] *** Joins: yauhsien (~yauhsien@118-167-41-229.dynamic-ip.hinet.net)
[23:31:11] *** Quits: yauhsien (~yauhsien@118-167-41-229.dynamic-ip.hinet.net) (Ping timeout: 256 seconds)
[23:34:48] *** Quits: rgrinberg (~textual@200.5.63.76) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[23:38:10] *** Joins: rogersm (~rogersm@90.166.177.48)
