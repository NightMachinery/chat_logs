[00:08:01] *** Quits: AmR (~AmREiSa@156.199.244.83) (Ping timeout: 245 seconds)
[00:13:15] *** Joins: varioust (~varioust@cpe-108-167-11-88.neb.res.rr.com)
[00:17:48] <yolo_> the caller passes wrong arguments to my function: send err msg to stderr, log it to syslog, then raise an exception. anything else I can handle this gracefully?
[00:18:46] <yolo_> i used to do assert() but it will be turned off by NDEBUG at runtime, need something better
[00:19:54] <LiaoTao> yolo_, I'd hate for a library that I use to assume that it can output things without my consent
[00:21:07] *** Joins: pulse_ (~pulse@user/pulse)
[00:21:23] <LiaoTao> As for assertions/error codes/exceptions, you should probably consider what a typical use case for your library is
[00:22:51] <LiaoTao> Like, assertions seem like a good thing to have regardless in most cases. Exceptions should be exceptional. Error codes should be convenient lest they go ignored.
[00:22:51] *** Quits: Kebianizao (~Kebianiza@188.127.161.90) (Read error: Connection reset by peer)
[00:23:09] *** Joins: Kebianizao (~Kebianiza@188.127.161.90)
[00:23:13] <yolo_> you mean I should just return error-code so the caller has to deal with it, instead I raise an exception(or assertion but then it's gone at runtime)
[00:23:44] <yolo_> so the best way is: assert still(for debugging), error-code as normal, exception only when there is an earthquake?
[00:24:15] <yolo_> any reference on 'how to write c++/c library"
[00:24:18] *** Quits: pulse (~pulse@user/pulse) (Ping timeout: 260 seconds)
[00:24:59] *** Quits: pah_ (~pah@host-79-49-135-16.retail.telecomitalia.it) (Ping timeout: 264 seconds)
[00:25:04] <LiaoTao> yolo_, Basically I wouldn't want something that can fail within its normal mode of operation to throw an exception. If it's something that the user is expected to handle at the callsite an error code seems like the most natural thing to use.
[00:25:19] <LiaoTao> s/can fail/will fail/
[00:25:42] <yolo_> ok, thanks, assertion + errorCode that is
[00:26:51] *** Quits: RoKenn (~RoKenn@user/rokenn) (Quit: NSA proxy service interrupted)
[00:27:08] <LiaoTao> yolo_, Just remember to document whatever choice you make. Especially possible exceptions.
[00:27:11] <johnny> yolo_, there are also libraries out there like std::excepted-lite or other Result type libraries
[00:27:27] <johnny> expected-lite*
[00:27:55] *** Quits: paul424 (~tom@ip-31-0-124-185.multi.internet.cyfrowypolsat.pl) (Remote host closed the connection)
[00:29:22] *** Joins: ShiftyLogic (~shiftylog@66.115.146.16)
[00:29:26] *** Quits: varioust (~varioust@cpe-108-167-11-88.neb.res.rr.com) (Ping timeout: 260 seconds)
[00:30:33] *** Joins: ShiftyLo_ (~shiftylog@66.115.146.16)
[00:30:33] <yolo_> checking. I never wrote any libraries, has always been a library user by far, but now I need write some lib
[00:34:14] *** Quits: pulse_ (~pulse@user/pulse) (Quit: pulse_)
[00:34:14] *** Quits: Kebianizao (~Kebianiza@188.127.161.90) (Read error: Connection reset by peer)
[00:35:09] *** Joins: pah (~pah@user/pah)
[00:42:59] *** Quits: pah (~pah@user/pah) (Ping timeout: 264 seconds)
[00:43:14] *** Joins: Kebianizao (~Kebianiza@188.127.161.90)
[00:44:12] <yolo_> johnny: is expected-lite doing with std::option does
[00:44:18] <yolo_> s/with/what/
[00:44:28] <johnny> i mean kinda
[00:45:09] <johnny> if you wanna read some rationale as to what the difference really would be, you could check our rust's result type or read this paper http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0323r10.html
[00:46:19] *** Quits: kenanmarasli (~kenanmara@user/kenanmarasli) (Quit: Leaving)
[00:46:29] <johnny> i still also have this particular library i was looking into.. https://github.com/lamarrr/STX no comment on quality though since i haven't actually looked at it yet
[00:46:39] <RandomReader> it depends on what you're going for, but in general, it's the programmer's responsibility to write correct code
[00:46:58] <RandomReader> you want to make your API/interface easy to do the correct thing with, but you're typically not responsible for catching mistakes
[00:47:00] <johnny> imagine writing correct code
[00:47:31] <RandomReader> e.g. std::string provides an interface and documentation about how to use it .. it does not range-check its indexes or check whether try to construct it from a nullptr
[00:47:45] <RandomReader> because those are not correct ways to use it, and it has clearly documented requirements
[00:47:56] <yolo_> std::expected is new to me, how is it different from std::option, seems duplicate to ignorant me
[00:48:33] <LordKalma> I tend to prefer exceptions to magic codes in library code imgho
[00:48:44] <LordKalma> of course there's conventioned stuff like
[00:48:50] <yolo_> RandomReader: you're correct, for library stuff doc becomes important, as it tells how to use it properly
[00:48:53] <LordKalma> not found is == .end(), that sort of stuff
[00:48:54] <RandomReader> if your boundary is not a C++ programmer but is something else, say a network interface, then it is more like processing user input and you should be thoroughly defensive to avoid your code crashing
[00:49:23] *** Joins: pah (~pah@user/pah)
[00:49:36] <RandomReader> but for general APIs, the more important thing is the overall design, so that it is easy to do the correct thing with and the programmer-user is less likely to make mistakes
[00:49:44] <johnny> yolo_, std::expected is closer to sd::variant than std::optional
[00:49:48] <johnny> std::variant*
[00:50:24] <RandomReader> meanwhile a correct user will want to know the full contract, how your library API behaves, so that they can do what they intend to do
[00:50:28] <LordKalma> npaperbot, search P0323R10
[00:50:29] <npaperbot> P0323R10: [Library] std::expected <https://wg21.link/p0323r10> (by JF Bastien, Vicente Botet) (2021-04-15) (Related: https://wg21.link/lewg29, https://wg21.link/p0323r10/github)
[00:50:35] <LordKalma> seems interesting
[00:50:46] <RandomReader> which is why LiaoTao talked about assuming things without consent -- that is behavior that is unexpected or hard to control
[00:51:02] <RandomReader> e.g. maybe I want to use the library with no syslog, etc
[00:51:36] <LordKalma> *never* force logging into your libraries
[00:51:48] <LordKalma> I have a C library I use that god damn printf's random crap
[00:51:49] <LordKalma> like wtf
[00:51:55] <johnny> i'll have to figure that one out at some point
[00:52:12] <LordKalma> if you want logging you need a registering system
[00:52:13] <johnny> it's an executable, but parts could be used as a library
[00:52:18] <LordKalma> and global state.. but oh well
[00:53:56] <yolo_> if no syslog in the lib, how does lib function report its own design errors?
[00:54:04] <yolo_> library can have bugs too
[00:54:11] <RandomReader> short article: https://www.aristeia.com/Papers/IEEE_Software_JulAug_2004_revised.htm   more thorough talk: https://www.youtube.com/watch?v=TdajK_SXwoc
[00:54:35] <RandomReader> in general, it's not supposed to, that's unexpected behavior
[00:54:47] <RandomReader> you (as the author) are responsible for testing those bugs out of it before you ship it :P
[00:55:01] <RandomReader> as in, if you can write logging for it, you can also write a test scenario that will trigger it
[00:55:11] <RandomReader> which you can then fix
[00:55:53] <yolo_> nice, which is why I spent a few days to add doctect-catch2-doctest into the stuff i work on
[00:55:55] <RandomReader> if the library relies on something else that can generate an error, say a system call, then of course you should report that -- in the same path that indicates success/failure for the user of your api
[00:56:34] <yolo_> all edge-cases and corner-cases must be fully tested, I recall sqlite's testing code is like 10x more than its 'real' code
[00:56:39] <RandomReader> and there may be other conditions where that only occur dynamically, so they become the same thing: that particular part of your library API becomes something that "might" succeed, so you design your API to be able to indicate that
[00:56:41] <LordKalma> Testing testing testing
[00:57:10] <LordKalma> yolo_: in engineering projects the test team is 2:1 to the design team
[00:57:15] <LordKalma> At least
[00:57:33] <RandomReader> and this goes back to exceptions, error codes, "expected", etc -- there are tradeoffs to all of these, most important is just be consistent, so the API user knows what to expect
[00:57:33] *** Quits: Kebianizao (~Kebianiza@188.127.161.90) (Read error: Connection reset by peer)
[00:57:57] *** Joins: varioust (~varioust@72-46-56-102.lnk.ne.static.allophone.net)
[00:58:01] <LordKalma> And library components should be Sall enough, or composed of small enough bits that are testable and that don't, like, fail and babe to report that
[00:58:07] <LordKalma> You leave that to application code
[00:59:03] <LordKalma> I think that sometimes it's tempting to push as much as possible into library code so that the app is creating a object in main, and that sure is possible, but if we're talking public libraries, reusable libraries, you have to keep it generic
[00:59:49] <LordKalma> Or become Qt or something. Qt has logging, and everything you can ever imagine. Only took like 25 years
[01:00:21] <RandomReader> Qt isn't a "library" though, it's an "application framework"
[01:00:40] <RandomReader> meaning you build an entire application from the things it provides, rather than just use it as a tiny piece of the rest of your app
[01:00:59] <RandomReader> (individual situations vary, but that's the overall design)
[01:01:34] *** Quits: pah (~pah@user/pah) (Ping timeout: 260 seconds)
[01:01:50] *** Joins: pah_ (~pah@host-82-61-3-137.retail.telecomitalia.it)
[01:01:55] *** Joins: markong (~kvirc@213.146.188.203)
[01:05:42] <yolo_> Thanks. Reading those.
[01:06:18] *** Joins: Kebianizao (~Kebianiza@188.127.161.90)
[01:08:00] <LordKalma> Fair enough
[01:08:18] <LordKalma> When you call something a framework you're saying you'll enforce design decisions
[01:08:50] *** Quits: pakcjo (~pakcjo@user/pakcjo) (Ping timeout: 260 seconds)
[01:09:36] <LordKalma> In C# there are some libraries/frameworks for app development that are like MVVM or GTFO
[01:10:05] <LordKalma> It's becoming a trend. But let me have my spaghetti ffs
[01:10:28] <LiaoTao> You have to be firm with C# developers. Otherwise they will certainly find the worst possible convoluted mess and try to shoehorn your library into it.
[01:11:00] <LordKalma> I have mvvm. I don't understand it. It's true what they say I guess. Ignorance fuels hatred.
[01:12:30] <LordKalma> LiaoTao: for example Avalonia supports mvvm, or not. Even though they want you to use mvvm and they write everything as if you were doing it the mvvm way. But some libraries, like a library that a dude wrote that provides a docking manager for Avalonia, only supports mvvm patterns and designs.
[01:12:49] *** Joins: badone (~badone@209.132.189.136)
[01:15:39] *** Joins: pakcjo (~pakcjo@user/pakcjo)
[01:16:13] <LiaoTao> LordKalma, Fair enough. I just wanted to take the opportunity to insult the intelligence of your average C# developer.
[01:18:23] *** Quits: Juliu (~Juliu@2a02:810b:c640:3ec0:2402:3824:89e9:f383) (Ping timeout: 264 seconds)
[01:19:01] *** Quits: m_ben (~m_ben@user/m-ben/x-7429725) (Quit: WeeChat 3.3)
[01:21:26] <LordKalma> Bahaha
[01:21:46] <LordKalma> Well, everybody is doing mobile apps these days
[01:22:01] *** Joins: Xe4roX (~Xe4roX@31-10-144-26.cgn.dynamic.upc.ch)
[01:22:22] *** Quits: varioust (~varioust@72-46-56-102.lnk.ne.static.allophone.net) (Quit: varioust)
[01:22:23] <LordKalma> C++ is shit for that, no matter how much qt and felgo try to convince you of otherwise
[01:23:02] *** Quits: proller (~p@80.240.216.69) (Ping timeout: 260 seconds)
[01:23:25] <LiaoTao> I even like C# and Java. I just hate C# developers.
[01:24:32] <LordKalma> Fair enough
[01:24:33] *** Quits: Kebianizao (~Kebianiza@188.127.161.90) (Read error: Connection reset by peer)
[01:24:51] <LordKalma> Remembering #csharp on freenode was absolute cancer
[01:25:09] <LordKalma> Might be on libera, I just don't want to discover
[01:26:17] *** Quits: Tobbi (~Tobbi@2a02:8108:1240:48ec:1d19:ac87:3b13:4cf) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[01:26:25] <LordKalma> You know C++ surprises me a lot in that. For a language that typically doesn't pull in the twitter activist JS developer, the community doesn't feel like a boys club most of the time
[01:26:51] <LordKalma> We even have the #include<c++> Community. Which has an amazing name
[01:27:14] <RandomReader> *elitist snob mode* that's because it can't be used (successfully) by amateurs :D
[01:27:18] <LordKalma> Like, really interesting. KDE guidelines are strong on that too
[01:27:24] *** Joins: pah (~pah@user/pah)
[01:27:45] <LordKalma> RandomReader: thats the thing. When you think of elitist clubs you don't thing of inclusion communities
[01:27:49] <RandomReader> ...seriously though, I think one part if it is its age / maturity as a language, and another part is the diversity of use cases
[01:27:57] <LordKalma> Don't think of
[01:28:14] *** Quits: pah_ (~pah@host-82-61-3-137.retail.telecomitalia.it) (Ping timeout: 260 seconds)
[01:28:21] <RandomReader> the same thing that means there isn't a Cargo that everyone uses also means there isn't One True Way that folks push everywhere
[01:29:05] <LordKalma> Well, the c++ demographics for sure aren't the same as yesterday's newly released framework. Or today's. There's one every day. Which again surprises me further haha
[01:30:33] <LiaoTao> People taught to be opinionated before they are experienced aren't very pleasant to work with.
[01:31:12] <LordKalma> Hahaha being an ass with social questions or just toxic is relatively independent of experience in tech
[01:31:16] <LordKalma> But I hear ya
[01:31:30] <LiaoTao> On the other hand people who are both clueless and have no opinion make for great C# developers.
[01:31:42] * LiaoTao shrugs
[01:33:25] <LordKalma> C# overwhelms me tbh. Its just so much crap to take in. And they want to learn specific design patterns at the same time
[01:33:27] <LordKalma> Fuck that
[01:33:52] *** Joins: Kebianizao (~Kebianiza@188.127.161.90)
[01:34:14] <LiaoTao> LordKalma, I wasn't even referring to the social aspect as much as that way of cockshuredly offering "just do this" as an answer without really considering the circumstances or motivations behind a question.
[01:34:39] <LordKalma> That's stack overflow
[01:34:53] <LiaoTao> That's your brain on stackoverflow and nothing else.
[01:34:58] <LordKalma> "hey, what about this?" "use that, closed"
[01:35:20] <LordKalma> How do you learn c++? Use rust, closed, reported.
[01:36:01] *** Joins: proller (~p@80.240.216.69)
[01:36:07] <LiaoTao> I see it all too often from people with a few years of C++ experience, and I'm guessing it's sort of universal.
[01:37:22] *** Quits: npaperbot (~npaperbot@dodecahedron.m-ou.se) (Remote host closed the connection)
[01:37:29] *** Joins: npaperbot (~npaperbot@dodecahedron.m-ou.se)
[01:37:29] *** ChanServ sets mode: +v npaperbot
[01:37:59] <johnny> see what?
[01:38:11] *** pah is now known as pa
[01:38:59] <LiaoTao> johnny, The attitude resulting from being taught to be opinionated before accumulating enough experience to know why a given opinion is useful.
[01:39:36] <johnny> the hard part is knowing whne you're experienced enough :(
[01:39:36] *** Quits: Kebianizao (~Kebianiza@188.127.161.90) (Read error: Connection reset by peer)
[01:39:50] <johnny> but sometimes, it'd nice tojust have a pattern to follow so one can gain the experience
[01:39:58] <veverak> that is the neat part, never
[01:40:13] <johnny> it doesn't have to be the best pattern, but it's nice to have a pattern so you get a feel for things
[01:40:29] <johnny> and remember, not all of us are programming in the languages we use by choice
[01:40:38] <LiaoTao> It's not all that bad to be opinionated without a strong motivation, but it becomes a problem when you lose your humility and introspection.
[01:40:40] <johnny> i'm not programming in C++ by choice for example
[01:41:23] <LiaoTao> veverak, Indeed, but at least you learn to motivate things somewhere along the line.
[01:41:40] <veverak> that's true
[01:41:49] <johnny> then again i'm rarely programming in a language by choice. i find a thing that does what i want to  do, and if it's in a reasonable language for it's purpose, i go with it
[01:42:02] <johnny> unless it's the only thing that does whta it does..
[01:42:23] <veverak> truth to be told I became opinionated more about peoples behavior than technical stuff
[01:42:45] <veverak> I can turn easily to jerk mode once I think that I see hype-driven development
[01:43:09] <johnny> don't go too far, because there's always room to learn and play around with new techniques, even if you don't yet see the utility
[01:43:35] <veverak> playing with new stuff is OK
[01:43:45] <veverak> trying something just "because we can" is also OK
[01:44:03] <johnny> also, there's gotta be a boostrap phase when people write actually usual things with it
[01:44:18] <veverak> forcing something without accepting neg. properties and overvaluating good parts just because somebody likes it on the internetz?
[01:44:59] <veverak> johnny: to put it differently: there is case when it is really bad nad I became vocal about that in those moments
[01:45:01] <johnny> i feel like people uhmmm hype up hype driven development too much .. except for one particular case
[01:45:19] <johnny> mongodb/nosql is like the only time it caused real problems
[01:46:07] <johnny> i thought it was neat, but i avoided that one altogether
[01:46:29] <johnny> i guess now it's all "nocode/lowcode" and serverless
[01:46:45] <johnny> ah. microservices.. that was something
[01:47:05] <veverak> I avoided docker in one job
[01:47:21] <veverak> we had working deployment of app to device - just big fat binary
[01:47:33] <johnny> veverak, so i guess in the end it was about adopting stuff you might want at google/amazon scale but not for your thing that could work on a single VM with simple failover
[01:47:49] <veverak> they wanted to put docker there, and after wheek I did not get even single answer to "what problem is this solving?"
[01:47:55] *** Joins: Kebianizao (~Kebianiza@188.127.161.90)
[01:48:03] <veverak> just generic statements being told about docker during that time
[01:48:13] <johnny> isn't the problem always the unstable base layer? :)
[01:48:39] <veverak> johnny: the problem is adopting stuff without understanding context, yes
[01:48:44] <johnny> i've generally avoided docker if it could be done with a single binary.. i mean heck.. that's how i got clion to try out, and also android studi
[01:48:56] <johnny> well single directory not single binary
[01:49:15] <johnny> but of course that means shipping a whole vm too
[01:49:27] <scjg> Is there any good reason to use "OBJECT" library in cmake instead of static/shared? I see its only used to temporarily package obj files into some named lib without creating the actual lib file, not sure what would be the use case?
[01:49:38] <johnny> that is the use case isn't it?
[01:50:10] <johnny> basically a way to to mix and match those objects into say tests or other actual librarys and executables
[01:50:29] <LiaoTao> scjg, It's pretty useful for custom languages in CMake
[01:50:33] <LiaoTao> Apart from that, dunno
[01:50:35] *** Quits: whupdup (~whupdup@pool-173-76-128-81.bstnma.fios.verizon.net) (Quit: Going offline, see ya! (www.adiirc.com))
[01:51:24] <johnny> one could *mostly* consider it a macro
[01:51:50] <johnny> or at least that's how i've seen it used anyways
[01:52:43] *** Quits: lionkor (~lionkor@beammp/staff/lionkor) (Quit: quit)
[01:54:30] <johnny> LordKalma, i dunno.. this channel does feel a bit like a boys club
[01:55:32] <johnny> i suppose it was way more active it'd be way worse though. at least there's enough experience to go around in which people have seen that there are more tradeoffs than one can imagine
[01:57:08] *** Quits: ahlk (~user@2600:1700:31c0:3a10::43) (Read error: Connection reset by peer)
[01:58:17] *** Joins: ahlk (~user@2600:1700:31c0:3a10::43)
[01:59:06] <yolo_> each lang has its places, depends on what you do. while I need c++ for my systemc job, to write a cross-platform CLI I use go for that
[01:59:36] <johnny> there was a huge amount of go based cli stuff that came out, and i thought i was gonna be forced to learn go
[01:59:45] <johnny> so far i've managed to avoid it
[02:00:19] <LiaoTao> Average Go developers are slightly better than average C# developers.
[02:00:23] <LiaoTao> Slightly.
[02:00:28] <yolo_> when you have one code base to generate 10 binaries for different arch and OSes with one script on Linux, it's a time saver
[02:01:16] <johnny> LiaoTao, do you think that's more of a factor of fact that C# is taught in schools while go wasn't when it was popular, thus people who picked it up mostly did it intentionally?
[02:01:46] <yolo_> the cross-platform is so nice, i actually plan to write my next cross-platform GUI in the format of: golang(backend)+browser(frontend)
[02:01:56] <LiaoTao> C# is taught in schools? I thought it was Java and Python all the way down.
[02:02:13] * yolo_ will never learn rust due to time limits and brain cell loss
[02:02:13] *** Quits: Kebianizao (~Kebianiza@188.127.161.90) (Read error: Connection reset by peer)
[02:02:55] <LiaoTao> johnny, And I also have no idea why Go developers tend to be trash. I would have never lumped it together with C# in my preconceptions.
[02:03:05] <yolo_> no C# in school, actually no Microsoft in classes, everyone teaches python and java
[02:03:19] <johnny> i thought it was.. i've seen references to it plenty of times . like at cornell's cs program
[02:03:23] <johnny> maybe it's just optional
[02:03:50] *** Joins: blackout69 (~blackout6@net-31-156-121-187.cust.vodafonedsl.it)
[02:04:08] *** Joins: varioust (~varioust@72-46-56-102.lnk.ne.static.allophone.net)
[02:04:12] <johnny> i've never gone to uni, so i have no direct experience, it's all second hand :(
[02:04:34] <yolo_> CS51 actually teaches C, I hope each CS knows some C
[02:04:46] <johnny> LiaoTao, so.. you say avergae go better than average C#, but still trash?
[02:05:09] *** Joins: whupdup (~whupdup@pool-173-76-128-81.bstnma.fios.verizon.net)
[02:05:19] <johnny> for me.. go's error handling throws me off, but yet there's still plenty of useful programs written in it
[02:05:24] <LiaoTao> johnny, From my personal experience, yes. I'd also rather read trash Go code than trash C# code.
[02:05:38] <johnny> isn't that why go was invented in the first place?
[02:05:46] <LiaoTao> So I've heard.
[02:06:08] <yolo_> why need trash C#, I mean, I never spend 1 millisecond with C# so far, life is good
[02:06:17] <johnny> i'd rather C# than java tho i think
[02:06:31] <johnny> although at least i have kotkin in java
[02:06:35] <johnny> kotlin*
[02:06:56] <johnny> i know peeps who love clojure , so they usually end up with the jvm backed implementation
[02:07:21] <johnny> i assume one could implement it on top of the CLR, but i've never looked into it
[02:08:02] <LiaoTao> yolo_, Because life is suffering
[02:08:39] <LiaoTao> Java and C# read mostly the same to me, but Java codebases are obviously 10 levels of useless abstractions deeper on average.
[02:09:27] <LiaoTao> The early 2000s was a great time for extreme OOP fart sniffing.
[02:10:30] <johnny> but i want my abstractabstractabstractfactorybeanfactory
[02:11:00] *** Joins: Kebianizao (~Kebianiza@188.127.161.90)
[02:11:05] <johnny> the real truth is that programming is always hype driven
[02:11:47] <johnny> it's a young field and we still have barely scratched the surface of the best way to tell a computer to do something
[02:12:45] *** Joins: emerent_ (~quassel@p200300cd574855bdba27ebfffed28a59.dip0.t-ipconnect.de)
[02:12:45] *** emerent is now known as Guest353
[02:12:45] *** Quits: Guest353 (~quassel@p200300cd5748553bba27ebfffed28a59.dip0.t-ipconnect.de) (Killed (iridium.libera.chat (Nickname regained by services)))
[02:12:45] *** emerent_ is now known as emerent
[02:15:33] <LiaoTao> Anyway, time for bed and then back to the C# coal mine
[02:15:36] <LiaoTao> Have a good one
[02:27:21] *** Quits: blackout69 (~blackout6@net-31-156-121-187.cust.vodafonedsl.it) (Quit: Leaving.)
[02:29:27] *** Joins: Hokedli (~lasliedv@gateway/tor-sasl/hokedli)
[02:38:29] *** Joins: AbleBacon_ (~AbleBacon@user/AbleBacon)
[02:40:20] *** Quits: teepee (~teepee@openscad/teepee) (Remote host closed the connection)
[02:40:21] *** Quits: magla (~gelignite@55d47dc5.access.ecotel.net) (Quit: Stay safe!)
[02:42:41] *** Joins: teepee (~teepee@openscad/teepee)
[02:45:59] *** Quits: PJBoy (~PJBoy@user/pjboy) (Ping timeout: 264 seconds)
[02:49:18] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[02:50:27] *** Quits: Hokedli (~lasliedv@gateway/tor-sasl/hokedli) (Quit: Konversation terminated!)
[02:52:21] *** Joins: andreasbuhr (~quassel@p549db304.dip0.t-ipconnect.de)
[02:53:46] *** Quits: andreasbuhr (~quassel@p549db304.dip0.t-ipconnect.de) (Client Quit)
[02:54:26] *** Joins: NovumDXW (~NovumDXW@113.91.34.220)
[02:54:42] *** Quits: spaceangel (~spaceange@ip-89-176-181-220.net.upcbroadband.cz) (Remote host closed the connection)
[02:54:42] *** Joins: andreasbuhr (~quassel@p549db304.dip0.t-ipconnect.de)
[03:03:12] *** Quits: whupdup (~whupdup@pool-173-76-128-81.bstnma.fios.verizon.net) (Quit: Going offline, see ya! (www.adiirc.com))
[03:14:59] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[03:19:45] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[03:24:31] *** Joins: X-Scale` (~ARM@92.250.98.212)
[03:26:14] *** Quits: X-Scale (~ARM@31.22.147.35) (Ping timeout: 260 seconds)
[03:27:03] *** X-Scale` is now known as X-Scale
[03:27:24] *** Quits: varioust (~varioust@72-46-56-102.lnk.ne.static.allophone.net) (Quit: varioust)
[03:27:29] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[03:31:11] *** Joins: varioust (~varioust@72-46-56-102.lnk.ne.static.allophone.net)
[03:50:59] *** Quits: Kebianizao (~Kebianiza@188.127.161.90) (Quit: Coyote finally caught me)
[03:58:47] *** Quits: varioust (~varioust@72-46-56-102.lnk.ne.static.allophone.net) (Quit: varioust)
[03:58:54] *** Quits: CaCode (~CaCode@user/cacode) (Ping timeout: 260 seconds)
[04:02:40] *** Joins: lh_mouse (~lh_mouse@mingw-w64/developer/lhmouse)
[04:07:26] *** Quits: DSpider (DSpider@2a02:2f00:1ff:ffff::646c:6a26) (Quit: Leaving)
[04:20:45] *** Quits: dextercd (~dexter@2a02-a450-f25d-1-76d4-35ff-fefe-34c.fixed6.kpn.net) (Quit: WeeChat 3.3)
[04:25:25] *** Quits: shailangsa (~shailangs@host217-39-45-200.range217-39.btcentralplus.com) (Remote host closed the connection)
[04:26:53] *** Quits: RabidToaster (~Thunderbi@bras-base-otwaon234vw-grc-25-65-93-17-96.dsl.bell.ca) (Ping timeout: 246 seconds)
[04:34:56] *** Joins: lh_ideapad (~lh_mouse@mingw-w64/developer/lhmouse)
[04:42:22] *** Quits: markong (~kvirc@213.146.188.203) (Ping timeout: 260 seconds)
[04:47:42] <KombuchaKip> Hello friends. I am having some difficulty using a std::condition_variable correctly. My L44 blocks indefinitely. This is pseudo-codesque, but hopefully an adequate distillate of my problem. https://pastebin.com/FMYKfbWN
[04:54:41] <RandomReader> as written, 63 is never false, which means the lock is never released for 44
[04:57:41] <KombuchaKip> RandomReader: But the predicate is an or'ing with m_Ready which is set to true in DoSomeWork(), no?
[04:58:13] *** Joins: TheGuestMovie (~TheGuestM@173.231.114.74)
[04:59:20] <Alipha> KombuchaKip: where's EveryNowAndThen implemented?
[04:59:49] <KombuchaKip> Alipha: That's just pseudo code. It's not a real function.
[05:00:29] <KombuchaKip> Alipha: The MonitorThread continuously runs in the background until the object destructs. Periodically it does DoSomeWork();
[05:01:27] *** Joins: night_wulfe_ (~wulfe@cpe-174-103-156-213.cinci.res.rr.com)
[05:02:54] <TheGuestMovie> real humbling moment when I run to "git blame" to see which idiot wrote some line, and I see it was me
[05:04:46] <RandomReader> the m_mutex must be available for the condition variable to reacquire it on 44, and it's not released and the cv isn't notified inside the while loop
[05:05:06] *** Quits: night_wulfe (~wulfe@cpe-174-103-156-213.cinci.res.rr.com) (Ping timeout: 245 seconds)
[05:05:19] <RandomReader> the predicate is a sanity check, not a trigger
[05:05:52] *** Quits: NovumDXW (~NovumDXW@113.91.34.220) (Read error: Connection reset by peer)
[05:06:17] *** Joins: NovumDXW (~NovumDXW@113.91.34.220)
[05:06:45] <RandomReader> the cv.wait() may return even if not notified, in which case the predicate determines when it's pointless and should go back to waiting
[05:08:25] <RandomReader> sorry misread some of the pseudobits, the mutex will be released between while condition checks, but you'll still need to notify the cv so it can take over in between
[05:10:24] *** Quits: LiaoTao (~LiaoTao@gateway/tor-sasl/liaotao) (Ping timeout: 276 seconds)
[05:10:36] *** Joins: LiaoTao_ (~LiaoTao@gateway/tor-sasl/liaotao)
[05:11:13] <KombuchaKip> RandomReader: Perhaps what I should do is move L61 to the bottom of the while loop in the MonitorThread()?
[05:11:42] *** Quits: Hello71 (~Hello71@wireguard/contributor/hello71) (Ping timeout: 276 seconds)
[05:11:50] <RandomReader> yeah I'd try that
[05:12:16] *** Joins: varioust (~varioust@cpe-108-167-11-88.neb.res.rr.com)
[05:12:21] <KombuchaKip> RandomReader: Or the top of the while loop?
[05:12:41] <KombuchaKip> RandomReader: I suppose it doesn't matter where in the while loop, as long as the mutex is released each iteration.
[05:13:06] *** Joins: Hello71 (~Hello71@wireguard/contributor/hello71)
[05:13:41] *** Quits: NovumDXW (~NovumDXW@113.91.34.220) (Quit: Leaving)
[05:21:59] <KombuchaKip> RandomReader: It unfortunately still hangs.
[05:24:23] *** Quits: varioust (~varioust@cpe-108-167-11-88.neb.res.rr.com) (Read error: Connection reset by peer)
[05:29:30] *** Quits: ARoxdale (~ARoxdale@84.203.31.229) (Ping timeout: 260 seconds)
[05:36:30] *** Quits: TheGuestMovie (~TheGuestM@173.231.114.74) (Quit: Client closed)
[05:37:22] *** Quits: npaperbot (~npaperbot@dodecahedron.m-ou.se) (Remote host closed the connection)
[05:37:30] *** Joins: npaperbot (~npaperbot@dodecahedron.m-ou.se)
[05:37:30] *** ChanServ sets mode: +v npaperbot
[05:57:58] *** Quits: artok (~azo@mobile-access-5672e7-16.dhcp.inet.fi) (Ping timeout: 260 seconds)
[05:58:34] *** Quits: plastico (~plastico@neomutt/plastico) (Quit: WeeChat 3.3)
[05:58:54] *** Quits: andreasbuhr (~quassel@p549db304.dip0.t-ipconnect.de) (Ping timeout: 260 seconds)
[05:59:19] *** Joins: andreasbuhr (~quassel@p549db337.dip0.t-ipconnect.de)
[06:17:39] *** Joins: night_wulfe (~wulfe@cpe-174-103-156-213.cinci.res.rr.com)
[06:20:59] *** Joins: The_Jag_ (~The_Jag@host-87-16-87-93.retail.telecomitalia.it)
[06:21:42] *** Quits: night_wulfe_ (~wulfe@cpe-174-103-156-213.cinci.res.rr.com) (Ping timeout: 260 seconds)
[06:23:34] *** Quits: The_Jag (~The_Jag@host-82-56-115-92.retail.telecomitalia.it) (Ping timeout: 260 seconds)
[06:32:32] *** Joins: artok (~azo@mobile-access-5672e7-16.dhcp.inet.fi)
[06:37:38] *** Quits: artok (~azo@mobile-access-5672e7-16.dhcp.inet.fi) (Ping timeout: 260 seconds)
[06:39:59] *** Quits: ShiftyLo_ (~shiftylog@66.115.146.16) (Remote host closed the connection)
[06:45:02] *** Quits: ShiftyLogic (~shiftylog@66.115.146.16) (Ping timeout: 260 seconds)
[06:52:04] *** Joins: smallville7123 (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au)
[07:26:30] *** Quits: AbleBacon_ (~AbleBacon@user/AbleBacon) (Read error: Connection reset by peer)
[07:26:30] *** Quits: AbleBacon (~AbleBacon@user/AbleBacon) (Read error: Connection reset by peer)
[07:33:28] *** Joins: artok (~azo@mobile-access-5672e7-16.dhcp.inet.fi)
[07:33:57] *** Quits: darkstarx (~darkstard@2601:1c2:300:c8a0::6c32) (Quit: Leaving)
[07:41:56] *** Joins: darkstardevx (~darkstard@2601:1c2:300:c8a0::6c32)
[07:43:49] *** Quits: darkstardevx (~darkstard@2601:1c2:300:c8a0::6c32) (Remote host closed the connection)
[07:44:16] *** Joins: darkstardevx (~darkstard@2601:1c2:300:c8a0::6c32)
[07:48:08] *** Quits: ville (~ville@178-75-128-81.bb.dnainternet.fi) (Quit: leaving)
[07:48:27] *** Joins: peeps[zen] (~peepsalot@openscad/peepsalot)
[07:49:54] *** Quits: peepsalot (~peepsalot@openscad/peepsalot) (Ping timeout: 260 seconds)
[07:55:26] *** Joins: ville (~ville@178-75-128-81.bb.dnainternet.fi)
[07:57:02] <KombuchaKip> RandomReader: I observed something in the while loop. If the lock is released more frequently it doesn't deadlock. If the work in the loop takes a while, like a second, between each unlock / lock, the constructor blocks forever.
[07:59:21] <KombuchaKip> RandomReader: The while loop contains a select() which times out after 1 second of no fd activity.
[08:15:53] *** Quits: smallville7123 (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au) ()
[08:23:45] *** Quits: sprout_ (~quassel@2a02:a467:ccd6:1:8872:6fff:30a7:51e0) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
[08:24:03] *** Joins: sprout (~quassel@2a02:a467:ccd6:1:8872:6fff:30a7:51e0)
[08:39:25] *** Joins: smallville7123 (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au)
[08:46:27] *** Quits: great_taste (~great_tas@190.32.235.20) (Quit: Client closed)
[08:54:26] *** Quits: ferdna (~ferdna@user/ferdna) (Quit: Leaving)
[09:02:08] *** Quits: RandomReader (~RandomRea@user/randomreader) (Quit: RandomReader)
[09:04:13] *** Quits: badone (~badone@209.132.189.136) (Quit: ZNC 1.7.5 - https://znc.in)
[09:11:47] *** Quits: skapata (~Skapata@user/skapata) (Read error: Connection reset by peer)
[09:17:44] *** Joins: RandomReader (~RandomRea@user/randomreader)
[09:24:12] *** Quits: mIGu (~mig21@user/naur) (*.net *.split)
[09:24:12] *** Quits: OnlineCop (~OnlineCop@user/onlinecop) (*.net *.split)
[09:24:12] *** Quits: Argorok (sid195487@hampstead.irccloud.com) (*.net *.split)
[09:24:12] *** Quits: wyre (~wyre@user/wyre) (*.net *.split)
[09:24:12] *** Quits: kkd (~kkd@255.205.154.104.bc.googleusercontent.com) (*.net *.split)
[09:24:12] *** Quits: jancoow (~jancoow@user/jancoow) (*.net *.split)
[09:24:12] *** Quits: Rayke (rayke@user/rayke) (*.net *.split)
[09:24:12] *** Quits: dblsaiko (~saiko@crispy.dblsaiko.net) (*.net *.split)
[09:24:12] *** Quits: tinloaf (~tinloaf@2a03:94e0:163c:57e:bc51:5c66:86e7:1) (*.net *.split)
[09:24:12] *** Quits: shenghi (~shenghi@chrysocolla.mutablevoid.org) (*.net *.split)
[09:24:12] *** Quits: M-ou-se (~m-ou-se@circle.m-ou.se) (*.net *.split)
[09:24:12] *** Quits: roxlu (~roxlu@2a01:7c8:aac0:286:8c3a:b01c:3830:245b) (*.net *.split)
[09:24:12] *** Quits: oj (quassel@user/oj) (*.net *.split)
[09:24:12] *** Quits: WhizzWr (Whizz@s-o-m-e.h-o-s-t.name) (*.net *.split)
[09:24:12] *** Quits: francis (francis@user/francis) (*.net *.split)
[09:24:21] *** Joins: francis (francis@user/francis)
[09:24:21] *** Joins: Argorok (sid195487@id-195487.hampstead.irccloud.com)
[09:24:26] *** Joins: oj (oj@user/oj)
[09:24:28] *** Joins: M-ou-se (~m-ou-se@circle.m-ou.se)
[09:24:29] *** Joins: roxlu (~roxlu@2a01:7c8:aac0:286:8c3a:b01c:3830:245b)
[09:24:38] *** Joins: shenghi (~shenghi@chrysocolla.mutablevoid.org)
[09:24:51] *** Joins: Rayke (rayke@2600:3c03::f03c:92ff:fe86:498b)
[09:24:53] *** Joins: tinloaf (~tinloaf@2a03:94e0:163c:57e:bc51:5c66:86e7:1)
[09:25:04] *** Joins: OnlineCop (~OnlineCop@2001:470:1f07:89::beef:beef)
[09:25:15] *** Joins: jancoow (~jancoow@user/jancoow)
[09:25:23] *** Quits: OnlineCop (~OnlineCop@2001:470:1f07:89::beef:beef) (Changing host)
[09:25:23] *** Joins: OnlineCop (~OnlineCop@user/onlinecop)
[09:25:37] *** Joins: dblsaiko (~saiko@crispy.dblsaiko.net)
[09:25:39] *** Joins: kkd (~kkd@255.205.154.104.bc.googleusercontent.com)
[09:25:42] *** Joins: wyre (~wyre@user/wyre)
[09:26:16] *** Joins: shailangsa (~shailangs@host217-39-45-200.range217-39.btcentralplus.com)
[09:27:33] *** Joins: mIGu (~mig21@user/naur)
[09:32:50] *** Quits: ivan (~ivan@user/ivan) (*.net *.split)
[09:32:50] *** Quits: shtumf[m] (~shtumfmat@2001:470:69fc:105::1:1b21) (*.net *.split)
[09:32:50] *** Quits: elemongw[m] (~elemongwk@2001:470:69fc:105::34ee) (*.net *.split)
[09:32:50] *** Quits: fiesh (~fiesh@2003:ec:a821:1::163) (*.net *.split)
[09:32:50] *** Quits: andreyv (~andrey@user/andreyv) (*.net *.split)
[09:32:50] *** Quits: Dragoon (~Dragoon@user/dragoon) (*.net *.split)
[09:32:50] *** Quits: rouji (~rouji@x0.at) (*.net *.split)
[09:32:50] *** Quits: TinoDidriksen (~TinoDidri@tinodidriksen.com) (*.net *.split)
[09:32:50] *** Quits: Nixx (~quassel@bulbasaur.sjorsgielen.nl) (*.net *.split)
[09:32:50] *** Quits: HeTo (henkka@beer.modeemi.fi) (*.net *.split)
[09:32:50] *** Quits: lh_not_bot (~lh_bot@mingw-w64/developer/lhmouse) (*.net *.split)
[09:32:50] *** Quits: Hobbyboy (Hobbyboy@hobbyboy.co.uk) (*.net *.split)
[09:32:50] *** Quits: xq (~xq@user/xq) (*.net *.split)
[09:33:01] *** Joins: HeTo (henkka@beer.modeemi.fi)
[09:33:02] *** Joins: fiesh (~fiesh@2003:ec:a821:1::163)
[09:33:04] *** Joins: TinoDidriksen (~TinoDidri@tinodidriksen.com)
[09:33:12] *** Joins: Nixx (~quassel@bulbasaur.sjorsgielen.nl)
[09:33:12] *** Joins: andreyv (~andrey@user/andreyv)
[09:33:17] *** Joins: Hobbyboy (Hobbyboy@hobbyboy.co.uk)
[09:33:25] *** Joins: lh_not_bot (~lh_bot@mingw-w64/developer/lhmouse)
[09:33:30] *** Joins: Dragoon (~Dragoon@e244041.upc-e.chello.nl)
[09:33:33] *** Quits: Dragoon (~Dragoon@e244041.upc-e.chello.nl) (Signing in (Dragoon))
[09:33:33] *** Joins: Dragoon (~Dragoon@user/dragoon)
[09:36:11] *** Joins: shtumf[m] (~shtumfmat@2001:470:69fc:105::1:1b21)
[09:37:23] *** Quits: npaperbot (~npaperbot@dodecahedron.m-ou.se) (Remote host closed the connection)
[09:37:30] *** Joins: npaperbot (~npaperbot@dodecahedron.m-ou.se)
[09:37:30] *** ChanServ sets mode: +v npaperbot
[09:38:06] *** Joins: kenanmarasli (~kenanmara@user/kenanmarasli)
[09:38:22] *** Joins: elemongw[m] (~elemongwk@2001:470:69fc:105::34ee)
[09:41:13] *** Joins: rouji (~rouji@x0.at)
[09:45:00] *** Joins: ivan (~ivan@user/ivan)
[09:59:40] *** Joins: Juliu (~Juliu@2a02:810b:c640:3ec0:2402:3824:89e9:f383)
[10:00:38] *** Quits: lh_ideapad (~lh_mouse@mingw-w64/developer/lhmouse) (Ping timeout: 260 seconds)
[10:01:04] *** Joins: lh_ideapad (~lh_mouse@mingw-w64/developer/lhmouse)
[10:10:51] *** Joins: malloy (~jimery@116.30.221.89)
[10:13:08] *** Quits: smallville7123 (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au) ()
[10:20:17] <malloy> hello, what's the benefits of using 'template<typename Mutex> class'? only to accept different types of mutex?
[10:22:00] *** Joins: Tobbi (~Tobbi@2a02:8108:1240:48ec:a86f:1f20:803d:2891)
[10:23:54] <fiesh> possibly, hard to say without the actual code
[10:30:00] *** Joins: sord937 (~sord937@gateway/tor-sasl/sord937)
[10:30:21] *** Joins: ShiftyLogic (~shiftylog@66.115.146.16)
[10:33:29] <TinoDidriksen> Makes sense to give the template argument a semantic name so you know what kind of types it wants.
[10:34:59] *** Quits: ShiftyLogic (~shiftylog@66.115.146.16) (Ping timeout: 268 seconds)
[10:39:34] *** Joins: riksteri (riksteri@gateway/vpn/airvpn/riksteri)
[10:44:47] *** Quits: chozorho (~chozorho@c-69-250-72-103.hsd1.md.comcast.net) (Quit: WeeChat 3.0)
[10:48:20] *** Joins: euouae (~euouae@user/euouae)
[10:48:32] <euouae> Hello
[10:48:45] <TinoDidriksen> Hullo
[10:49:41] <euouae> I have a function that throws sim exception called deep in code. I’d like to return a message to the user as an error and exit the application. Where is it I appropriate to handle the error? Top level or as soon as it’ is thrown and call exit()?
[10:49:53] <euouae> Simple, not sim exception
[10:50:33] <TinoDidriksen> The exception is bad enough that you need to exit?
[10:50:50] <euouae> The command line argument provided is invalid for the task
[10:51:59] <euouae> In the GUI code I’m catching the exceptions to change the style of the text box, etc. but there’s also cli invocations available that I’d like to deal with
[10:52:10] <TinoDidriksen> I question how a cmdline parser can be deep in the code, but other than that I'd say handle it near the throw and exit() out.
[10:52:52] <euouae> Basically it’s setting some signals that call a function that calls an exporter that calls the parser that throws
[10:53:59] <euouae> Makes sense, thank you
[10:58:01] *** Joins: ravan (~ravan@user/ravan)
[11:00:53] *** Quits: zmt01 (~zmt00@user/zmt00) (Ping timeout: 265 seconds)
[11:02:11] <fiesh> I'd handle it where it actually semantically becomes invalid -- if the command line argument is `--zomg` and that doesn't exist, then handle it right there.  if the command line argument is `--inputFile bla` and bla doesn't exist or isn't readable, handle it where you try to read it... etc.
[11:02:39] <euouae> That’s to avoid catching a different exception right?
[11:03:35] <euouae> Or is it to make it as clear as possible to the code reader where the exception originated from?
[11:10:34] <johnny> i'd say there's nothing wrong with doing it twice if it's valid, since you can provide a different error message for example, or just to simplify things a bit
[11:11:03] <johnny> if your program can't continue without it, then just do it ASAP
[11:11:31] <johnny> really tho.. like other things, it depends
[11:20:06] *** Joins: magla (~gelignite@55d4d950.access.ecotel.net)
[11:46:25] *** LiaoTao_ is now known as LiaoTao
[11:53:13] *** Joins: Haohmaru (~Haohmaru@195.24.53.110)
[11:56:06] *** Joins: DSpider (~DSpider@82.79.237.29)
[12:06:52] *** Quits: Juliu (~Juliu@2a02:810b:c640:3ec0:2402:3824:89e9:f383) (Ping timeout: 268 seconds)
[12:10:57] *** Quits: artok (~azo@mobile-access-5672e7-16.dhcp.inet.fi) (Quit: to work)
[12:12:01] *** Joins: PJBoy (~PJBoy@2a00:23c7:8302:b301:7c9f:628e:65f:173a)
[12:12:01] *** Quits: PJBoy (~PJBoy@2a00:23c7:8302:b301:7c9f:628e:65f:173a) (Changing host)
[12:12:01] *** Joins: PJBoy (~PJBoy@user/pjboy)
[12:15:06] *** Quits: DSpider (~DSpider@82.79.237.29) (Read error: Connection reset by peer)
[12:15:50] *** Joins: DSpider (DSpider@2a02:2f00:1ff:ffff::646c:68aa)
[12:19:45] *** Quits: euouae (~euouae@user/euouae) (Quit: Client closed)
[12:22:23] *** Quits: Terminus (~null@user/terminus) (Quit: ZNC 1.8.2 - https://znc.in)
[12:23:45] *** Joins: John99 (~johnny@87.200.94.90.dynamic.jazztel.es)
[12:23:54] *** Joins: Terminus (~null@user/terminus)
[12:25:05] <LordKalma> oi oi
[12:25:06] <LordKalma> morning
[12:25:17] <LordKalma> !rq
[12:25:17] <nolyc> LordKalma: <gggp> please give some explain
[12:25:47] *** Quits: lh_mouse (~lh_mouse@mingw-w64/developer/lhmouse) (Read error: Connection reset by peer)
[12:26:11] *** Joins: lh_mouse (~lh_mouse@mingw-w64/developer/lhmouse)
[12:27:17] *** Joins: Guest396 (~Guest39@eth-west-pareq2-46-193-4-100.wb.wifirst.net)
[12:29:02] *** Joins: spaceangel (~spaceange@ip-89-176-181-220.net.upcbroadband.cz)
[12:29:26] *** Quits: DSpider (DSpider@2a02:2f00:1ff:ffff::646c:68aa) (Ping timeout: 260 seconds)
[12:29:37] <malloy> fiesh: it's from spdlog, https://paste.rs/vpI, but i saw it quite often
[12:29:57] *** Joins: DSpider (DSpider@2a02:2f00:1ff:ffff::646c:68aa)
[12:31:12] *** Joins: ShiftyLogic (~shiftylog@66.115.146.16)
[12:35:17] *** Joins: Juliu (~Juliu@2a02:810b:c640:3ec0:2402:3824:89e9:f383)
[12:35:30] *** Quits: fiesh (~fiesh@2003:ec:a821:1::163) (Ping timeout: 260 seconds)
[12:36:26] *** Quits: ShiftyLogic (~shiftylog@66.115.146.16) (Ping timeout: 260 seconds)
[12:41:52] <LordKalma> hahah ffs, just found a webpage with a memory leak
[12:43:13] <Haohmaru> no way
[12:47:33] *** Quits: lh_ideapad (~lh_mouse@mingw-w64/developer/lhmouse) (Ping timeout: 268 seconds)
[12:48:00] *** Joins: lh_ideapad (~lh_mouse@mingw-w64/developer/lhmouse)
[12:49:44] <LordKalma> yap
[12:49:50] <LordKalma> it bsod'ed my pc
[12:49:53] <LordKalma> reproducable
[12:55:51] <Stryyker> it should have just crashed your browser
[12:56:29] <LordKalma> every time I open that page my ram goes brrrr
[13:02:09] *** Joins: fiesh (~fiesh@2003:fb:1018::21)
[13:12:51] *** Quits: LiaoTao (~LiaoTao@gateway/tor-sasl/liaotao) (Remote host closed the connection)
[13:13:09] *** Joins: LiaoTao (~LiaoTao@gateway/tor-sasl/liaotao)
[13:13:14] *** Quits: malloy (~jimery@116.30.221.89) (Read error: Connection reset by peer)
[13:18:28] *** Joins: malloy (~jimery@116.30.220.108)
[13:21:47] *** Joins: blackout69 (~blackout6@net-31-156-121-187.cust.vodafonedsl.it)
[13:21:54] *** Quits: kenanmarasli (~kenanmara@user/kenanmarasli) (Quit: Leaving)
[13:23:36] <NyB> sigh... when calling a const function on a class with no mutable fields makes your unit tests pass, that's probably a compiler error, right?
[13:25:21] <PJBoy> const functions can have side effects
[13:26:37] <NyB> any hints? No threads, no mutable fields... I'm a little bit stumped...
[13:26:48] <LordKalma> only *this is const ;)
[13:26:50] <PJBoy> { int x = 0; SHOW(x); S s{&x}; s.f(); SHOW(x); } struct S { int* p; void f() const { *p = 1; } };
[13:26:51] <geordi> x = 0 x = 1
[13:26:53] <LordKalma> you could change half of the static world
[13:27:10] *** Joins: euouae (~euouae@user/euouae)
[13:27:44] <PJBoy> { S::x = 0; SHOW(S::x); S().f(); SHOW(S::x); } struct S { inline static int x; void f() const { x = 1; } };
[13:27:45] <geordi> S::x = 0 S::x = 1
[13:28:08] <PJBoy> any kind of global or indirectly writable variable
[13:28:13] <PJBoy> or any kind of function that does that
[13:28:32] <mort> do we know if std::colony is coming any time soon?
[13:28:37] <PJBoy> it's called std::hive
[13:28:38] <NyB> hmm... there should be none of that here, but I'd better check....
[13:28:45] <PJBoy> npaperbot search hive
[13:28:45] <npaperbot> P2332R0: [Library Evolution] Establishing std::hive as replacement name for the proposed std::colony container <https://wg21.link/p2332r0> (by Matthew Bentley, Ville Voutilainen, Gašper Ažman) (2021-03-08) (Related: https://wg21.link/p2332r0/github)
[13:28:45] <npaperbot> Also: P0447R16, P0447R15
[13:28:54] <mort> aha
[13:29:14] <PJBoy> [P0447] is what I wanted to link
[13:29:14] <npaperbot> P0447R16: [SG14, Library Evolution, WG21] Introduction of std::hive to the standard library <https://wg21.link/p0447r16> (by Matt Bentley) (2021-09-09) (Related: https://wg21.link/p0447r16/github)
[13:29:52] <PJBoy> 16 revisions and they still managed to choose a totally useless name
[13:30:11] <mort> curious to criticize the name std::colony for being an unfamiliar name not being in common usage when a "colony" is what everyone who uses and implements that datastructure calls it and nobody has ever called it a "hive" ever
[13:30:31] <PJBoy> apparently colony isn't that common
[13:30:37] <mort> but meh, as long as we get something which walks like a colony and quacks like a colony; a colony under any other name is still a colony
[13:30:44] <PJBoy> the paper does talk about bikeshedding
[13:31:12] <LiaoTao> I dislike the change to hive.
[13:31:19] <LiaoTao> I will still call it colony.
[13:31:24] <PJBoy> you do you I guess
[13:31:35] <PJBoy> I'm not a fan of being purposefully wrong about something's name
[13:31:40] <PJBoy> even if I disagree with it
[13:31:43] <PJBoy> and I do disagree with it
[13:31:58] <PJBoy> anyways, see http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2332r0.html#summary for some semblance of rationale
[13:32:13] <PJBoy> colony was voted strongly against
[13:32:34] <PJBoy> hive neutral, so
[13:32:37] <mort> I'm completely fine with the name hive
[13:32:38] <PJBoy> still not great
[13:32:41] *** Quits: cursey (~cursey@user/cursey) (Quit: bye)
[13:32:52] <PJBoy> I would have gone for bucket_array in a heart beat
[13:33:06] <mort> bucket_vector maybe
[13:33:11] <PJBoy> sure
[13:33:28] <mort> because "array" has the connotation of being compile-time constant size and a colony's buckets aren't
[13:33:56] <euouae> But it’s not a bucket array
[13:33:56] <PJBoy> except when it's valarray >_>
[13:33:57] <mort> but bucket_array would work too for sure, the buckets aren't compile-time constant size but they're runtime constant size
[13:34:03] <LiaoTao> PJBoy, But like you're wrong too. The committee doesn't have a stellar voting record anyway.
[13:34:25] <PJBoy> objectively speaking, calling std::hive something other than std::hive is wrong
[13:34:32] <PJBoy> and calling it std::hive is objectively right
[13:34:46] <mort> I absolutely love that a "vector" is an array of values and "valarray" is a vector
[13:34:57] <LiaoTao> I won't call std::hive std::colony, but I will call the data structure a colony over a hive
[13:35:01] <PJBoy> crazy world, right
[13:35:02] <LiaoTao> Or even bucket whatever as you mentioned
[13:35:10] <PJBoy> yeah ok
[13:35:22] <PJBoy> like referring to unordered_map as a hash map
[13:35:27] <PJBoy> that's fine by me
[13:36:02] <PJBoy> argh hive sucks so much
[13:36:55] <mort> std::array_of_buckets_increasing_geometrically_with_a_skip_list_for_iteration
[13:36:58] <PJBoy> I look forward to having to describe what that container is to absolutely every single programmer I have to work with
[13:37:16] <euouae> What is it? :P
[13:37:23] *** Quits: npaperbot (~npaperbot@dodecahedron.m-ou.se) (Remote host closed the connection)
[13:37:31] *** Joins: npaperbot (~npaperbot@dodecahedron.m-ou.se)
[13:37:31] *** ChanServ sets mode: +v npaperbot
[13:37:45] <mort> I think today I'll use a vector of unique_ptr
[13:37:55] <euouae> Is it basically like a vector except efficient for certain operations?
[13:37:58] <mort> that's colonyesque except that iteration order is not predictable
[13:38:21] <PJBoy> it's a bucket array, kinda like deque
[13:38:37] <mort> the colony's interface is like this: you can add stuff to it, and the thing you added has a stable address which won't ever change, and you can remove stuff from it, and you can iterate through everything that's there
[13:39:03] <euouae> It’ll only change if you remove it right?
[13:39:04] <PJBoy> additionally each element of each array can be marked as erased, so erasure of an element doesn't require moving other elements (not contiguous)
[13:39:24] <mort> the address of an element in the colony won't ever change, not even when you remove other elements
[13:39:39] <euouae> What if you remove the element itself
[13:39:41] *** Joins: RoKenn (~RoKenn@2001:a61:3505:d101:e368:2fea:b1c9:72d1)
[13:39:41] *** Quits: RoKenn (~RoKenn@2001:a61:3505:d101:e368:2fea:b1c9:72d1) (Changing host)
[13:39:41] *** Joins: RoKenn (~RoKenn@user/rokenn)
[13:39:42] <PJBoy> up until an entire block is erased, then the entire bucket will be erased, but this doesn't affected iteratory stability
[13:39:59] <PJBoy> man I'm not doing this justice
[13:40:01] <mort> if you remove the element then its lifetime dies
[13:40:05] <mort> ends*
[13:40:12] <LiaoTao> Did Matthew go with the high- or low complexity jump-counting pattern in the end?
[13:40:13] <LiaoTao> I haven't been keeping up
[13:40:48] <mort> euouae: it's like if you have a pointer to the last element of a std::vector and then you pop_back(); your pointer still points to the element but its lifetime has ended
[13:41:25] <euouae> I don’t quite understand the address thing
[13:41:41] <mort> in the vector example or in the colony case
[13:42:42] <PJBoy> in abstract, it's an optimised std::list
[13:42:54] <euouae> Okay I guess I understand that pjboy
[13:43:10] <PJBoy> you trade some constant time operations for amortized constant
[13:43:18] <PJBoy> and you get some memory locality for your troubles
[13:43:35] <mort> "an optimized std::list" is a perfect way to describe it actually
[13:44:09] <euouae> Of course list is better for some cases!
[13:44:20] <euouae> list with different trade offs maybe ?
[13:44:22] <mort> "the interface of a doubly linked list, but implemented using contiguous memory rather than nodes"
[13:45:20] <euouae> I’m not sure how constant time iteration is achieved, is it based on the block size?
[13:45:21] *** Joins: nojhan (uid443807@id-443807.lymington.irccloud.com)
[13:45:22] <mort> std::list has the advantage that you won't end up keeping around buckets which are too big, with std::hive you could insert a whole bunch of elements, then delete all except for the last element, and you'll still keep all the memory around
[13:45:45] <LiaoTao> euouae, jump-counting pattern
[13:45:51] <LiaoTao> You can google to find Matthew Bentley's papers
[13:45:53] <PJBoy> it's amortized constant iteration
[13:46:05] <PJBoy> so a single pre-increment could take linear time
[13:46:21] <PJBoy> but N increments will still take O(N) time
[13:47:13] <euouae> Huh? That means 1 takes O(1)…
[13:47:23] *** Joins: cursey (~cursey@user/cursey)
[13:47:28] <PJBoy> it's like vector's push_back
[13:47:41] <PJBoy> sometimes you have to reallocate all the memory, which takes linear time
[13:48:05] <PJBoy> but that only happens when the vector needs to double its memory allocation
[13:48:17] <PJBoy> so *most* of the time it's O(1) to push back
[13:48:30] <mort> vector push_back is amortized linear because every N inserts, you have to move N elements
[13:48:36] <mort> and N/N = 1
[13:48:47] <PJBoy> but if you have to do N operations, it will have to do that rellocation roughly 1/N times
[13:49:24] <PJBoy> so commonly it's O(1), worst case is O(N), amortized time over N operations is O(1) per push_back
[13:49:56] <PJBoy> there should be a nice graph for this somewhere
[13:50:45] <euouae> Seems like a 2020 paper
[13:50:50] <euouae> is this a new concept ?
[13:50:59] <PJBoy> std::colony was proposed in 2019
[13:51:16] <PJBoy> and has gone through many many revisions
[13:51:41] <LiaoTao> euouae, 2020 is for his low complexity extension, while the original high complexity paper is 2019
[13:51:46] <LiaoTao> Or even 2018, I don't recall
[13:51:57] <PJBoy> the implementation comes from the PLF library
[13:52:15] <PJBoy> which was 2017?
[13:52:47] <LiaoTao> I think he mentions in the paper that he couldn't find anywhere where it was written down, though I may just be plain wrong.
[13:53:01] <euouae> Pretty cool
[13:53:14] <euouae> I’ll take a look tomorrow to see if I can grok it
[13:53:18] <PJBoy> 2015 it turns out
[13:53:30] <PJBoy> according to this changelog https://plflib.org/colony.htm
[13:54:22] <PJBoy> this TLDR is good
[13:54:24] <PJBoy> > A combination of a linked-list of increasingly-large memory blocks with metadata. Part of this metadata is the head of a free-list of erased elements within that group, and also a 'next' pointer to the next group which has erased element locations which can be re-used. Another part of the metadata is a low complexity jump-counting skipfield, which is used to skip over erased elements...
[13:54:25] <PJBoy> ...during iteration in O(1) amortised time. The end result's a bidirectional, unordered C++ template data container which maintains positive performance characteristics while ensuring pointer stability to non-erased container elements.
[13:55:42] *** Joins: whupdup (~whupdup@pool-173-76-128-81.bstnma.fios.verizon.net)
[13:55:43] <euouae> I’m sorta kinda getting it
[13:55:54] <euouae> But I think the implementation will be cool to see in full
[13:56:03] <PJBoy> the implementation is available
[13:56:07] <euouae> Sure
[13:56:20] <euouae> But y
[13:56:24] <PJBoy> it's even on conan
[13:56:26] <euouae> my mind is not available right now :P
[13:56:32] <PJBoy> https://github.com/mattreecebentley/plf_colony for header only
[13:56:53] <PJBoy> love 5k line header only libraries
[13:57:28] <PJBoy> with hard tabs :/
[13:57:30] <LiaoTao> Looks like he indeed went with the latter Low Complexity pattern
[13:58:04] <LiaoTao> "Unlike a bucket array it does not use keys, iterates faster due to the use of an advanced skipfield type (previously a high complexity jump-counting pattern, now a low complexity jump-counting pattern) instead of a boolean field, and frees or recycles unused memory from erased elements on-the-fly."
[13:58:09] <PJBoy> yeah
[13:58:43] <LiaoTao> Going to have to read the implementation to see how he deals with the problems that are introduced by not keeping track of things
[13:58:55] <PJBoy> the benchmarks don't compare the two complexity designs
[13:58:59] <PJBoy> so, that sucks
[14:00:08] <Raziel> I am very confused by that thing's example.
[14:00:17] <PJBoy> what thing?
[14:00:36] <Raziel> plf::colony
[14:00:51] <PJBoy> it has some examples in the motivation section
[14:00:55] <PJBoy> do you mean one of those?
[14:00:57] <mort> do they keep a 'next' pointer and a 'previous' pointer? Otherwise I'm confused as to how they can do bidirectional iteration
[14:01:12] <LiaoTao> The jump counting pattern is symmetric
[14:01:14] <Raziel> I mean the one where it iterates from .begin to .end and calls .erase every time but apparently that only deletes half the elements
[14:01:35] <PJBoy> oh, the "Basic example of usage"?
[14:01:40] <Raziel> yeeees
[14:01:42] <PJBoy> I didn't see that
[14:02:07] <PJBoy> well erase gets you the iterator to the next element
[14:02:13] <PJBoy> and then the for loop increments it
[14:02:16] <Raziel> oh.
[14:02:25] <Raziel> that makes sense v:
[14:02:27] <mort> LiaoTao: but the jump counting skipfield is in the head of each block, right?
[14:02:30] <PJBoy> same behaviour with every container
[14:02:40] <PJBoy> (every sequence container)
[14:02:45] <euouae> Yknow, intuitive code that needs no comments!
[14:02:47] *** Joins: xq (~xq@user/xq)
[14:02:50] <LiaoTao> mort, I'm not sure on how this is implemented exactly. I just know there's a skipfield somewhere.
[14:02:52] <mort> if you're at the first element in a block, I don't see how you can go to the previous element
[14:03:03] <mort> without a pointer to the previous block
[14:03:20] <euouae> I think blocks are only utilized for reallocation purposes
[14:03:30] <euouae> They’re otherwise “not there”
[14:03:31] <LiaoTao> It should all be index based and then you do some math to figure out which block it's in
[14:03:54] <mort> that works if there's an array of blocks
[14:03:57] <mort> which I suppose there probably si
[14:03:59] <mort> is*
[14:04:05] <mort> s/array/vector/
[14:04:29] <LiaoTao> I tried implementing this in another language and that's what I got anyway
[14:04:31] <PJBoy> https://github.com/mattreecebentley/plf_colony/blob/master/plf_colony.h line 604 if it helps
[14:04:50] <PJBoy> there's indeed a previous pointer
[14:05:28] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[14:05:33] <LiaoTao> Interesting
[14:05:39] <PJBoy> colony_iterator starts at 464
[14:05:50] <PJBoy> I like that it uses the template<bool is_const> pattern than I like
[14:06:19] <PJBoy> also see `advance` at 730, which has some algorithm notes
[14:07:09] *** Quits: euouae (~euouae@user/euouae) (Quit: got to go)
[14:07:43] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Remote host closed the connection)
[14:08:14] <PJBoy> line 371 for the `group` definition
[14:08:18] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[14:08:22] <PJBoy> it looks like dogshit on github
[14:08:31] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Remote host closed the connection)
[14:09:05] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[14:09:10] <LiaoTao> I suppose it makes sense to have it as a linked list of groups if you're using pointers as iterators
[14:11:36] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Remote host closed the connection)
[14:12:14] *** Quits: ravan (~ravan@user/ravan) (Read error: No route to host)
[14:13:32] <mort> I wish jthread was older than C++20
[14:14:17] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[14:15:18] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Remote host closed the connection)
[14:15:50] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[14:16:34] *** Quits: Juliu (~Juliu@2a02:810b:c640:3ec0:2402:3824:89e9:f383) (Quit: Quit)
[14:18:41] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Remote host closed the connection)
[14:19:16] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[14:20:01] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Client Quit)
[14:20:22] *** Joins: Guest1 (~Guest1@business-90-187-112-253.pool2.vodafone-ip.de)
[14:21:20] *** Joins: ravan (~ravan@user/ravan)
[14:29:21] *** Joins: markong (~kvirc@213.146.188.203)
[14:36:45] *** Quits: whupdup (~whupdup@pool-173-76-128-81.bstnma.fios.verizon.net) (Quit: Going offline, see ya! (www.adiirc.com))
[14:37:40] *** Quits: Guest396 (~Guest39@eth-west-pareq2-46-193-4-100.wb.wifirst.net) (Quit: Client closed)
[14:38:31] *** Joins: AmR (~AmREiSa@41.232.235.167)
[14:41:05] *** Joins: plastico (~plastico@neomutt/plastico)
[14:45:13] *** Joins: ARoxdale (~ARoxdale@84.203.31.229)
[14:53:58] <PJBoy> yeah I don't understand why std::thread doesn't join on destruction
[14:54:45] <mort> well, std::jthread is more than just joining on destruction though
[14:54:53] <mort> it's the whole termination signaling stuff
[14:55:37] <PJBoy> ah right
[14:55:45] <PJBoy> yeah ok that's a bit more complexity
[14:58:41] *** Joins: xkuru (~xkuru@user/xkuru)
[14:59:45] *** Joins: Leone (~Leo@45.72.233.136)
[15:00:12] *** Quits: xkuru (~xkuru@user/xkuru) (Client Quit)
[15:01:03] *** Joins: xkuru (~xkuru@user/xkuru)
[15:01:49] *** Joins: m_ben (~m_ben@user/m-ben/x-7429725)
[15:03:14] *** Quits: ARoxdale (~ARoxdale@84.203.31.229) (Ping timeout: 268 seconds)
[15:09:04] <mort> it would've been nice with some std::variant utility methods
[15:09:22] <mort> if you could do 'foo.is<int>()' rather than 'std::holds_alternative<int>(foo)'
[15:09:56] <mort> or 'foo.get_if<int*>()' rather than 'std::get_if<int*>(foo)'
[15:10:07] <LiaoTao> Make your own is<int>(foo)? :P
[15:10:07] <mort> at least to me it reads much nicer as methods
[15:10:26] <mort> maybe what we need is uniform function call syntax
[15:10:39] <LiaoTao> Yup
[15:10:58] <Guest1> It is a bipolar library :)
[15:11:13] <mort> it would be less obviously bipolar with ufcs
[15:11:38] <Guest1> ufcs? what u mean?
[15:11:43] <mort> uniform function call syntax
[15:11:45] <LiaoTao> Every time I use variant I lament that C++ doesn't have first-class support for it
[15:11:57] <LiaoTao> It's just so clunky
[15:12:28] <mort> if there's a global function 'doThing(MyType)', and I have a 'MyType foo', UFCS would allow me to call 'foo.doThing()' and it would be syntax sugar for 'doThing(foo)'
[15:14:46] <PJBoy> which is the problem with UFCS >_>
[15:14:59] <mort> what about it is a problem?
[15:15:25] <PJBoy> if you have existing code that has a `doThing(MyType)` and a `MyType::doThing()`
[15:15:29] <PJBoy> UFCS would break that code
[15:15:51] <mort> I don't think so?
[15:16:00] <Raziel> how's it work when you have doThing(OneType, SomeOtherType)?
[15:16:12] <mort> if you do 'foo.doThing()' and there's a MyType::doThing it would presumably call the method
[15:16:27] <mort> Raziel: 'foo.doThing(otherThing)' would call 'doThing(foo, otherThing)'
[15:16:30] <PJBoy> you could give the member function access priority, yeah
[15:16:36] <Guest1> foo.doThing(SomeOtherType)?
[15:16:52] <PJBoy> but it's still a bit brittle
[15:16:58] <mort> I think you'd have to give member function access priority
[15:17:09] <mort> can't be an error at least, unless you want to restructure the entire stdlib
[15:17:20] <m_ben> wasn't there a talk where herb sutter suggested UFCS for c++?
[15:17:39] <mort> it would be awesome to be able to always do 'foo.begin()' and it automatically calls 'begin(MyType)' or 'MyType::begin' depending on what's available
[15:17:44] <PJBoy> UFCS have been discussed for quite a while now
[15:17:58] <PJBoy> and ultimately I think they're not ever getting in
[15:18:13] <PJBoy> there's a lot of concern about risk of breaking old code
[15:18:15] <mort> I agree that it does feel pretty brittle
[15:18:27] <PJBoy> for what is ultimately just a minor aesthetic benefit
[15:18:52] <mort> to not break (too much) old code, you'd have to always 100% call the method if it's even possible to call the method, even if there are better matches as a non-method
[15:19:51] <mort> anyways, I think it'd be neat regardless
[15:20:17] <PJBoy> there's some potential to bring it in on an opt-in basis
[15:20:29] <mort> not very uniform then
[15:20:46] <PJBoy> yeah
[15:25:05] *** Joins: Guest10 (~Guest10@eth-west-pareq2-46-193-4-100.wb.wifirst.net)
[15:27:42] *** Quits: proller (~p@80.240.216.69) (Ping timeout: 260 seconds)
[15:40:29] <m_ben> speaking of UFCS and C++: https://www.reddit.com/r/cpp/comments/qk6hcc/tuplesget_a_cpo_version_of_tuple_stdget/hiv79a7/?utm_source=reddit&utm_medium=web2x&context=3
[15:40:38] <m_ben> I haven't seen his talk yet
[15:40:57] <mort> ugh I'm in a situation where I have to #include <curl/curl.h> in a header just to get at its definitions of curl_off_t -- and I have to do that because I need to implement a callback which takes those functions as arguments, and the callback has to be a static member function because it needs to refer to a private type from the class
[15:41:53] *** Quits: Guest10 (~Guest10@eth-west-pareq2-46-193-4-100.wb.wifirst.net) (Quit: Client closed)
[15:43:38] <PJBoy> can you write your callback as a template instead?
[15:43:45] <PJBoy> taking a typename T instead of a curl_off_t
[15:44:05] <mort> I suppose..
[15:44:08] <PJBoy> I've been doing that with some of my windows API interactions
[15:46:43] <mort> do I then *have* to implement it in the header? Or is there a way to implement the curl_off_t version in the .cc and have myFunction<curl_off_t> resolve to that?
[15:48:14] *** Quits: lh_ideapad (~lh_mouse@mingw-w64/developer/lhmouse) (Ping timeout: 268 seconds)
[15:48:41] *** Joins: lh_ideapad (~lh_mouse@mingw-w64/developer/lhmouse)
[15:49:56] <PJBoy> hm, not sure
[15:51:28] <LiaoTao> If you can version lock curl you can always just use whatever type it is defined as. Google says it's int64_t
[15:51:46] <LiaoTao> Of course it's brittle, but it may be sufficient
[15:51:58] *** Joins: whupdup (~whupdup@pool-173-76-128-81.bstnma.fios.verizon.net)
[15:53:18] <mort> C++ is great at putting you in difficult situations like this
[15:53:42] <mort> there's no reason why C++ couldn't have a mechanism to define private member functions outside of the header
[15:54:07] <TinoDidriksen> We do: PIMPL
[15:54:11] <PJBoy> you can define private member functions outside the header
[15:54:18] <PJBoy> regardless of pimpl
[15:54:22] <mort> you can't
[15:54:28] <mort> or do I mean declare rather than define
[15:54:36] <TinoDidriksen> You mean declare.
[15:55:01] <PJBoy> wouldn't it be scary to allow undeclared functions access to your private data?
[15:55:17] <PJBoy> would break encapsulation wide open
[15:55:26] <undeclared> yeah man nobody should trust my functions
[15:55:42] <mort> encapsulation is already broken wide open
[15:56:07] <LiaoTao> struct CurlArgWrapper; // wrapper.hh    struct CurlArgWrapper { curl_off_t x; }; // wrapper.cc        class Foo { static void doStuff(CurlArgWrapper w); } // foo.hh
[15:56:10] <LiaoTao> Wouldn't that work?
[15:56:51] <PJBoy> nah
[15:57:01] <PJBoy> curl_off_t wouldn't convert to CurlArgWrapper implicitly
[15:57:03] *** Joins: onizu (uid373383@id-373383.uxbridge.irccloud.com)
[15:57:09] <mort> I have to give curl a function pointer to doStuff with curl_off_t as its arguments
[15:57:18] <LiaoTao> Oh right
[15:57:39] <LiaoTao> Captureless lambda?
[15:58:22] <LiaoTao> But you'd probably need to know curl_off_t at the callsite then
[15:58:29] <PJBoy> if it has to be a private member function, then it needs some captures
[15:58:53] <mort> actually, a captureless lambda is probably the way to go
[15:59:19] <PJBoy> if you can use a captureless lambda, then why do you need this callback to have access to your class' privates?
[15:59:36] <LiaoTao> [](curl_off_t x) { Foo::doStuff(CurlArgWrapper{x}); } for a static function
[15:59:47] <PJBoy> it could just be a static function in the source file
[15:59:51] <mort> because it gets a userdata pointer (you know, the common C idiom) and I have to cast that pointer to a type that's defined in the class as a private
[16:00:31] <PJBoy> well the lambda should have the same problem, right?
[16:00:42] <mort> no, because a lambda defined in a member also has access to privates
[16:00:51] <PJBoy> you need to know what a curl_off_t is to define the lambda
[16:00:59] <PJBoy> which is the same problem
[16:01:17] <LiaoTao> It's not necessarily in a header anymore
[16:01:29] <mort> if you have a member function defined in the .cc, you can define the lambda in that member function and then the lambda also has access to the privates
[16:01:40] <PJBoy> so the lambda wouldn't be a member
[16:01:47] <mort> no
[16:01:59] <mort> it would be defined in a member function, but wouldn't be a member itself
[16:02:36] <PJBoy> alrighty then
[16:03:04] <PJBoy> makes sense
[16:03:50] <PJBoy> the lambda would still have to capture though
[16:03:53] <mort> no
[16:04:24] <PJBoy> how else would it access the class' member variables?
[16:04:42] <mort> you pass curl both a function pointer and a data pointer, then curl calls the function pointer with the data pointer you gave it as its first argument
[16:05:09] <PJBoy> do you not need access to private members from that data pointer?
[16:05:13] <PJBoy> just the private type?
[16:05:29] <PJBoy> actually does that work
[16:05:34] <mort> yeah, but if I needed access to private members it would work as well
[16:05:55] <mort> I'll implement this then I can show you exactly how it works
[16:06:39] *** Quits: fiesh (~fiesh@2003:fb:1018::21) (Quit: reboot)
[16:06:42] <PJBoy> yeah ok it does work
[16:06:50] <PJBoy> I've never even considered this scenario before
[16:07:15] <PJBoy> { A().f(); } class A { int x{}; void g() { BARK; } public: void f(); }; void A::f() { [](A* p) { p->g(); }(this); }
[16:07:16] <geordi> A::g()
[16:07:22] <PJBoy> was my test case
[16:07:26] <mort> you wouldn't use it ever unless you happen to be working with a callback-based C API
[16:08:03] <PJBoy> oh I've worked with those
[16:08:30] <PJBoy> but I've not been fortunate enough to get a "user data" pointer
[16:08:43] <mort> well, that, _and_ you have to pass in a callback which needs to access private members, _and_ that callback can't be defined in the header as a static member function
[16:08:48] <mort> ouch
[16:08:59] <mort> C APIs which don't give you a userdata pointer are annoying
[16:09:12] <PJBoy> yeah it's pretty crappy
[16:09:48] <PJBoy> I'm gonna remember this lambda trick though
[16:09:56] <mort> it's useful
[16:09:58] <PJBoy> the more I think about it, the more I like it
[16:15:35] <onizu> does vcpkg not work with vscode?
[16:16:43] *** Joins: fiesh (~fiesh@2003:fb:1018::21)
[16:17:52] <PJBoy> AFAIK vcpkg has no special integration with VS code
[16:18:15] <PJBoy> you gotta get CMake to talk to vcpkg
[16:18:22] <PJBoy> and VC code to talk to CMake
[16:18:25] <PJBoy> *VS code
[16:21:53] *** Joins: smallville7123 (~smallvill@cpe-172-193-72-46.qld.foxtel.net.au)
[16:22:04] *** Quits: Xe4roX (~Xe4roX@31-10-144-26.cgn.dynamic.upc.ch) (Remote host closed the connection)
[16:22:22] <onizu> PJBoy: yes, I am using CMake. And added "CMAKE_TOOLCHAIN_FILE" in cmake.configureSettings in .vscode/settings.json  and  added "${vcpkgRoot}/x86-windows/include"   in .vscode/c_cpp_properties.json
[16:22:40] *** Joins: proller (~p@2a02:6b8:0:40c:d084:b940:a3c3:ddc3)
[16:22:56] <PJBoy> you know more than me then :)
[16:22:56] <onizu>  "CMAKE_TOOLCHAIN_FILE": "E:/path/vcpkg/scripts/buildsystems/vcpkg.cmake"
[16:23:12] <onizu> but it's unable to find the include directory
[16:28:30] *** Joins: frost (~frost@user/frost)
[16:30:22] *** Quits: blackout69 (~blackout6@net-31-156-121-187.cust.vodafonedsl.it) (Quit: Leaving.)
[16:32:53] *** Joins: ShiftyLogic (~shiftylog@66.115.146.16)
[16:34:05] *** Joins: ShiftyLo_ (~shiftylog@66.115.146.16)
[16:38:12] *** Quits: ShiftyLogic (~shiftylog@66.115.146.16) (Ping timeout: 268 seconds)
[16:38:48] *** Quits: ShiftyLo_ (~shiftylog@66.115.146.16) (Ping timeout: 268 seconds)
[16:40:46] *** Joins: dextercd (~dexter@2a02-a450-f25d-1-76d4-35ff-fefe-34c.fixed6.kpn.net)
[16:47:22] *** Joins: lpapp (~lpapp@ec2-15-161-137-233.eu-south-1.compute.amazonaws.com)
[16:47:45] <lpapp> hi, I have template<typename T, typename S>  Mat4<T> operator * (const S& d, const Mat4<T>& m) { ... } to support multiplication for a matrix with float, double, int and half float
[16:48:09] <lpapp> I also have template<typename T>  template<typename S> inline Vec2<T> Vec2<T>::operator *  (const Mat4<S>& m) const  ... }
[16:48:16] <lpapp> to multiple a vec2 with mat4
[16:48:20] <lpapp> how to reconcile this though?
[16:48:24] <lpapp> The linux compiler says:
[16:48:31] <lpapp> error: ISO C++ says that these are ambiguous, even though the worst conversion for the first is better than the worst conversion for the second: [-Werror]
[16:48:41] <lpapp> note: candidate 1: ndk::Mat4<S> ndk::operator*(const S&, const ndk::Mat4<S>&) [with T = float; S = ndk::Vec2<float>]
[16:48:47] <lpapp> note: candidate 2: ndk::Vec2<T> ndk::Vec2<T>::operator*(const ndk::Mat4<S>&) const [with S = float; T = float]
[16:49:22] *** Quits: lh_ideapad (~lh_mouse@mingw-w64/developer/lhmouse) (Ping timeout: 260 seconds)
[16:50:13] *** Joins: lh_ideapad (~lh_mouse@mingw-w64/developer/lhmouse)
[16:55:38] *** Joins: pulse (~pulse@user/pulse)
[17:08:13] *** Quits: Guest1 (~Guest1@business-90-187-112-253.pool2.vodafone-ip.de) (Quit: Client closed)
[17:09:53] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[17:12:52] <PJBoy> what are the operands you're multiplying?
[17:12:55] <lpapp> maybe, it is to check for arithmetic types.
[17:13:03] <PJBoy> and which one of the two candidates would you want called
[17:13:08] <lpapp> and not sure how useful Vec2 * mat4 actually is either.
[17:13:18] <lpapp> in this case, the second for sure.
[17:13:55] <PJBoy> what even is T in the first candidate?
[17:14:34] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Ping timeout: 260 seconds)
[17:14:57] <PJBoy> I'm guessing it's supposed to be `const ndk::Mat4<T>&` for the RHS parameter
[17:15:26] <lpapp> PJBoy: matrix type
[17:15:32] <lpapp> float, double, int, half, etc.
[17:15:53] <PJBoy> can you confirm it's a typo?
[17:16:00] <lpapp> what is a typo?
[17:16:08] <PJBoy> well there's no T in what you wrote for candidate 1
[17:16:17] <lpapp> yes, that looks strange
[17:16:21] <lpapp> not sure where that comes from tbh
[17:16:34] <rpav> [with T = float; S
[17:16:43] <PJBoy> that's fishy
[17:16:46] <lpapp>   template<typename T, typename S>
[17:16:50] <lpapp>   Mat4<T> operator * (const S& d, const Mat4<T>& m)
[17:16:51] *** Joins: blackout69 (~blackout6@net-31-156-121-187.cust.vodafonedsl.it)
[17:16:54] <lpapp> this is where the compiler points to
[17:16:58] *** Joins: Juliu (~Juliu@2a02:810b:c640:3ec0:2402:3824:89e9:f383)
[17:16:59] <lpapp> I do not see Mat4<S> there
[17:17:03] <PJBoy> bizarre
[17:17:08] <lpapp> not sure why it is thinking of that candidate.
[17:17:17] <rpav> are you building with 20
[17:17:28] <lpapp> ?
[17:17:32] <lpapp> 20 what?
[17:17:34] <rpav> -std=c++20
[17:17:38] <lpapp> no
[17:18:02] <PJBoy> anyways yeah, make a SFINAE on the S parameter so that it's one of the types you mentioned
[17:18:12] <PJBoy> think that's your only option
[17:18:58] <lpapp> yeah, or specialisations or overloads.
[17:19:14] *** Quits: frost (~frost@user/frost) (Quit: Connection closed)
[17:19:33] <PJBoy> I'm actually not sure if specialisations would work
[17:19:35] <PJBoy> but yeah
[17:19:45] *** Joins: RabidToaster (~Thunderbi@bras-base-otwaon234vw-grc-25-65-93-17-96.dsl.bell.ca)
[17:20:42] <PJBoy> overload resolution takes place on functions and base function templates, specialisations are only considered afterwards if a base function template wins overload resolution
[17:22:25] <LordKalma> I tough template resolution was before overloads...
[17:23:39] *** Quits: MaddHatter (~maddhatt@user/maddhatter) (Ping timeout: 260 seconds)
[17:24:22] *** Joins: MaddHatter (~maddhatt@user/maddhatter)
[17:26:16] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[17:31:13] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Ping timeout: 268 seconds)
[17:31:34] *** Joins: Guest3251 (~Guest32@business-90-187-112-253.pool2.vodafone-ip.de)
[17:36:26] *** Quits: John99 (~johnny@87.200.94.90.dynamic.jazztel.es) (Remote host closed the connection)
[17:37:10] <rpav> overloads are actually preferred to templates i think
[17:37:24] *** Quits: npaperbot (~npaperbot@dodecahedron.m-ou.se) (Remote host closed the connection)
[17:37:32] *** Joins: npaperbot (~npaperbot@dodecahedron.m-ou.se)
[17:37:32] *** ChanServ sets mode: +v npaperbot
[17:37:41] <rpav> like if you have <T> foo(T); and int foo(int); then it chooses the latter doesn't it
[17:37:47] <Haohmaru> i read "overlords are actually prefered to temples"
[17:37:55] <rpav> well, that too
[17:37:56] <rpav> ;)
[17:38:08] <PJBoy> functions are preferred to function templates, yeah
[17:39:20] <PJBoy> unless a conversion is needed for one of the arguments
[17:39:28] <PJBoy> in which case functions can tie with function templates
[17:40:03] <PJBoy> { f(0, 0); } void f(double, int) {} void f(auto, double) {} // e.g.
[17:40:03] <geordi> error: call of overloaded 'f(int, int)' is ambiguous
[17:41:22] <rpav> P987654R0; function-template deathmatch resolution in the case of ties
[17:43:28] <rpav> i made a thing for desktop groups for projects yesterday and it's a huge QoL improvement; not specifically C++, but it applies to working on all my C++ projects!
[17:47:09] *** Quits: ravan (~ravan@user/ravan) (Remote host closed the connection)
[17:48:55] *** Quits: DSpider (DSpider@2a02:2f00:1ff:ffff::646c:68aa) (Quit: Leaving)
[17:49:34] *** Quits: lh_ideapad (~lh_mouse@mingw-w64/developer/lhmouse) (Ping timeout: 260 seconds)
[17:49:59] *** Joins: lh_ideapad (~lh_mouse@mingw-w64/developer/lhmouse)
[17:52:01] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[17:52:36] <Alipha> malloy: you write `typename Mutex` instead of `typename T` because it's good to give meaningful names. It would probably be better if more people gave template parameters meaningful names, but unfortunately just using T and U is pretty common. Like how `i` is often used for for loops, which isn't a very helpful name (but maybe a more descriptive name isn't necessary)
[17:53:11] *** Joins: ravan (~ravan@user/ravan)
[17:54:17] *** Quits: Guest3251 (~Guest32@business-90-187-112-253.pool2.vodafone-ip.de) (Quit: Client closed)
[17:54:25] *** Quits: blackout69 (~blackout6@net-31-156-121-187.cust.vodafonedsl.it) (Quit: Leaving.)
[17:55:38] *** Joins: blackout69 (~blackout6@net-31-156-121-187.cust.vodafonedsl.it)
[17:56:16] <rpav> T/S/U for entirely generic types makes sense, like `i` for index .. just avoid them perhaps for less-generic types .. concepts ought to help make them actually-not-generic too
[17:56:29] <rpav> i use like C for container, but like CRTP or similar for more specific purposes
[17:56:34] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Ping timeout: 260 seconds)
[17:56:42] <rpav> F for function
[17:57:51] <rpav> `i` (j, x, y, z, t) are pretty helpful if you only use them for indexing variables (and if you're not, wtf)
[17:58:00] <rpav> or vector components i guess
[17:58:31] <rpav> like items[theIntegerIndexVariable] isn't going to make things more readable than items[i]
[17:59:35] *** Quits: Juliu (~Juliu@2a02:810b:c640:3ec0:2402:3824:89e9:f383) (Ping timeout: 268 seconds)
[18:00:11] *** Joins: DSpider (~DSpider@82.79.237.100)
[18:03:55] <Alipha> Yeah, definitely. Though I do think as a whole, T and U are used too often. But I'm not saying they should never be used
[18:09:44] *** Joins: Juliu (~Juliu@2a02:810b:c640:3ec0:2402:3824:89e9:f383)
[18:11:43] <rpav> yeah
[18:12:08] <rpav> i really should play with concepts more too .. "typesafe types"
[18:12:14] *** Joins: lionkor (~lionkor@beammp/staff/lionkor)
[18:13:01] <rpav> i'd say metatypes, but that's ruined .. 🤔 "facetypes"
[18:13:02] * rpav runs
[18:13:06] *** Quits: lh_ideapad (~lh_mouse@mingw-w64/developer/lhmouse) (Remote host closed the connection)
[18:16:46] *** Quits: peeps[zen] (~peepsalot@openscad/peepsalot) (Ping timeout: 245 seconds)
[18:17:00] *** Joins: peepsalot (~peepsalot@openscad/peepsalot)
[18:18:52] *** Joins: betelgeuse (~betelgeus@94-225-47-8.access.telenet.be)
[18:19:37] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[18:22:29] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Client Quit)
[18:24:33] <PJBoy> I subscribe to the idea of variable name length corresponding to lifetime
[18:24:59] <rpav> heh
[18:25:03] <PJBoy> if you make a variable that's only used on the very next line, then it's good to keep it short
[18:25:41] <rpav> i go more with "<number of times i'm going to type it> / <clarity of name>" or something
[18:25:52] <rpav> or "weight choices by"
[18:26:06] *** Quits: MaddHatter (~maddhatt@user/maddhatter) (Ping timeout: 268 seconds)
[18:26:21] <rpav> actually i guess if clarity of name is 0..1 with "0" being "entirely unclear" and 1 being "entirely self-descriptive" then * not /
[18:26:24] *** Joins: MaddHatter (~maddhatt@user/maddhatter)
[18:26:46] <rpav> if i was good at math i wouldn't be a programmer
[18:27:00] *** Joins: ShiftyLogic (~shiftylog@66.115.146.16)
[18:27:44] *** Joins: ShiftyLo_ (~shiftylog@66.115.146.16)
[18:28:01] <mort> interesting, I didn't know vector::erase and std::erase(vector) were completely different things
[18:28:13] *** Quits: ShiftyLogic (~shiftylog@66.115.146.16) (Client Quit)
[18:28:50] *** Joins: ShiftyLogic (~shiftylog@66.115.146.16)
[18:29:24] <mort> that'd be fun with ufcs
[18:29:39] <PJBoy> they take different parameters
[18:30:24] <PJBoy> in retrospect, I'm not really sure why std::erase is a non-member function
[18:30:55] <PJBoy> maybe for uniformity due to std::list
[18:33:37] <mort> std::erase is more algorithm-y isn't it
[18:34:24] *** Quits: ShiftyLo_ (~shiftylog@66.115.146.16) ()
[18:34:25] <mort> yea they take different parameters, but that's even worse: 'vec.erase(foo)' actually erases the element at the iterator if 'foo' is an iterator, or it moves the element to the end if 'foo' is a T
[18:34:29] <PJBoy> not in particular IMO
[18:34:39] *** Quits: m_ben (~m_ben@user/m-ben/x-7429725) (Quit: WeeChat 3.3)
[18:34:42] <PJBoy> it's as algorithmic as std::list::remove
[18:34:59] <mort> doesn't std::list::remove actually remove an element though?
[18:35:03] <PJBoy> yeah
[18:35:13] <mort> std::erase just finds an element and moves it to the end
[18:35:16] <PJBoy> which I would use as precedence for making erase a member function
[18:35:18] <InPhase> mort: I'm mostly waiting for cin.getline to enter the 21st century.
[18:35:22] <PJBoy> nah std::erase removes the element
[18:35:25] <PJBoy> that's the point
[18:35:39] <mort> oh
[18:35:42] <mort> I may be thinking about std::remove?
[18:35:43] <mort> idk
[18:35:53] <PJBoy> yeah std::remove does the reordering
[18:35:57] <mort> these names man
[18:36:00] <PJBoy> and container::erase does the erasing
[18:36:08] <PJBoy> and std::erase combines the two steps
[18:36:29] <PJBoy> (generally speaking)
[18:37:39] <mort> I see
[18:37:52] <PJBoy> std::erase_if for maps and lists have the same effect, but they don't use std::remove
[18:38:04] <PJBoy> tldr std::erase does what you want
[18:38:21] <mort> usually, erase and remove are synonyms
[18:38:38] <PJBoy> idk, I never hear "erase" outside of C++
[18:39:01] <PJBoy> the fact that std::list::remove exists and does erasure though
[18:39:07] <PJBoy> those terms are fubar
[18:39:31] <InPhase> That std::remove really should have been called something like filter_sort.  Things should do what they say on the label, and that's one of the worst offenders.
[18:40:45] <PJBoy> it doesn't sort though
[18:40:54] <InPhase> It rearranges by a filter.
[18:41:07] <mort> it does "sort", in a way
[18:41:13] <imMute> mort: it does no such thing.
[18:41:14] <InPhase> It's a filter sort, not a less than sort.
[18:41:15] <mort> or, well, it categorizes, but categorizing things is often called sorting
[18:41:32] <mort> it puts all the matching elements at the end, all the non-matching elements at the beginning, that's a sort
[18:41:34] <PJBoy> how do you make it not sound like std::partition?
[18:41:38] <InPhase> If you separate your red socks and your blue socks, you're sorting your socks.  You don't have to line them up by sock size.
[18:41:53] <PJBoy> because it sounds like you're describing a bad name for std::partition
[18:42:20] <mort> I don't know what std::partition does, but std::remove sorts all the matching elements at the end and non-matching elements at the beginning
[18:42:20] <rpav> InPhase: what if i want a secondary key?!
[18:42:37] <PJBoy> std::partition arranges all elements that match a condition before all elements that don't
[18:43:00] <PJBoy> std::remove is like a destructive version of that
[18:43:12] <mort> what does std::remove destroy?
[18:43:23] <PJBoy> the elements matching the predicate you pass
[18:43:32] <mort> no? It just moves them to the end?
[18:43:36] <InPhase> PJBoy: Well the only difference (other than the lack of a value call in partition, which could be fixed) is that the predicate is backwards.
[18:43:49] <PJBoy> it does not preserve the removed elements
[18:43:58] <mort> oh, curious
[18:44:01] <PJBoy> they are left in an unspecified state
[18:44:07] <PJBoy> usually moved from
[18:44:15] *** Joins: cart_man (~rynot@host-78-144-120-137.as13285.net)
[18:44:16] <mort> makes sense I suppose
[18:44:40] <PJBoy> also it uses move semantics
[18:44:45] <PJBoy> whereas partition uses swaps
[18:47:38] <PJBoy> { vector v{4, 3, 2, 1, 0}; auto it_bad = remove_if(RANGE(v), [](int x) { return x >= 3; }); SHOW(v); v.erase(it_bad, end(v)); SHOW(v); }
[18:47:39] <geordi> v = {2, 1, 0, 1, 0} v = {2, 1, 0}
[18:47:59] <PJBoy> the last three (valid) elements overwrote the first two (invalid) elements
[18:48:19] <PJBoy> and std::remove doesn't give a fuck about those moved-from elements
[18:49:15] <PJBoy> contrast with partition
[18:49:18] <PJBoy> { vector v{4, 3, 2, 1, 0}; auto it_bad = partition(RANGE(v), [](int x) { return x < 3; }); SHOW(v); v.erase(it_bad, end(v)); SHOW(v); }
[18:49:18] <geordi> v = {0, 1, 2, 3, 4} v = {0, 1, 2}
[18:50:08] *** Joins: meator (~meator@user/meator)
[18:50:27] <PJBoy> so there really is no good name for the std::remove algorithm
[18:51:35] <PJBoy> we also note that std::remove_copy does not do this
[18:51:47] <PJBoy> it works like an inverted std::copy
[18:52:07] <PJBoy> _if
[18:53:44] <cq-work> I don't know why but I keep coming across the need for a fixed-size string on stack recently.
[18:53:51] *** Joins: TheHermann (~TheHerman@gateway/tor-sasl/thehermann)
[18:55:14] *** Quits: lh_mouse (~lh_mouse@mingw-w64/developer/lhmouse) (Read error: Connection reset by peer)
[18:58:06] <PJBoy> there should be something like that in stdlib tbf
[18:58:19] <PJBoy> like you can make an std::array and put a std::string_view over it, sure
[18:58:52] <PJBoy> but you don't get the modifying string operations
[18:59:31] <PJBoy> I guess you could use a stack allocator with std::string
[18:59:41] <PJBoy> but then you'd need a stack allocator
[19:03:20] <mort> When you do something like `foo(&Something{})`, is the temporary's lifetime extended so that it's alive for the duration of the call?
[19:03:45] <mort> I would guess yes, but clang warns about it which wouldn't make much sense if it's a valid pattern
[19:03:52] <cq-work> What's the warning?
[19:04:04] <PJBoy> is Something's operator& overloaded?
[19:04:07] <mort> "Taking the address of a temporary object" (-Waddress-of-temporary)
[19:04:11] <PJBoy> yeah indeed
[19:04:13] <mort> it's a struct from C so no
[19:04:19] <PJBoy> rvalues don't have addresses
[19:04:47] <PJBoy> except in C where you have compound literals
[19:05:03] <PJBoy> or in member functions where you have a this pointer
[19:05:34] *** Joins: zmt01 (~zmt00@user/zmt00)
[19:06:49] <PJBoy> but yeah generally speaking temporaries do live the life of the function call
[19:07:07] <PJBoy> so like `foo(make_unique<Something>().get())` would work
[19:08:26] *** Quits: lionkor (~lionkor@beammp/staff/lionkor) (Ping timeout: 260 seconds)
[19:09:24] *** Joins: Tokamak (~Tokamak@172.58.191.91)
[19:09:57] <PJBoy> { f(get(B())); } using tracked::B; auto* get(auto&& t) { return &t; } void f(B* p) { cout << p, *p; }
[19:09:57] <geordi> B0* 0x7fff16619010, B0 B0~
[19:10:30] <PJBoy> that extremely questionable get function might work?
[19:10:31] *** Quits: Tokamak (~Tokamak@172.58.191.91) (Client Quit)
[19:16:43] <rpav> what if we implemented all functions as an overload of fn(F, ...)
[19:17:31] <lpapp> is SFINAE implementd with enable_if_t?
[19:18:01] <rpav> that's a very useful way to sfinae your function, to be accurate
[19:21:46] *** Quits: TheHermann (~TheHerman@gateway/tor-sasl/thehermann) (Remote host closed the connection)
[19:22:25] *** Joins: TheHermann (~TheHerman@gateway/tor-sasl/thehermann)
[19:27:38] <PJBoy> enable_if_t and void_t are the big guns
[19:28:26] <InPhase> SFINAEIADF
[19:28:48] <InPhase> Substitution Failure Is Not An Error, It's A Design Flaw.
[19:29:32] <lpapp> the interesting thing is that we only get this compilation error on Linux, not msvc on Windows or clang on Mac.
[19:29:32] <rpav> lucky accident
[19:29:37] <InPhase> Probably the most useful design flaw in C++...  But still.
[19:29:57] <rpav> if not for sfinae c++ would probably not be what it is today
[19:31:19] <lpapp> is sfinae TMP
[19:31:20] <InPhase> I'm not sure if people would have recognized the need for a replacement for SFINAE provided features if it didn't exist.  But also, maybe without it, there would have been more incentive to design that more sensibly.  enable_if_t helps a little bit, but is still working within the oddity of it.
[19:31:57] <rpav> yeah i would probably say it's possible people would have been like, "hey we can't do this, it's an error, but it would be super useful, let's add some nice facility to make it work"
[19:32:41] <rpav> (..upon which, the committee, seeing the word "useful" in conjunction with their precioussss language, would have nixed it forever..)
[19:32:56] *** Joins: great_taste (~great_tas@190.32.235.20)
[19:33:04] <PJBoy> SFINAE is part of TMP, yeah
[19:33:59] <lpapp> not sure I fancy TMP
[19:34:13] <lpapp> I mean this is all we have, but whether it is needed is arguable.
[19:34:31] <rpav> "needed" is a useless term, as nothing is "needed"
[19:34:43] <lpapp> I would debate that
[19:34:51] <rpav> your debate is not needed
[19:35:25] <rpav> the better question is, "is it useful in the context of the language," to which the answer is "hell yes"
[19:36:22] <rpav> C++ without TMP is basically 90s class + inheritance + virtual, which was pretty neat but definitely would not be nearly as useful for so many things .. especially high-perf stuff, which is the main place C++ shines
[19:36:34] <PJBoy> lpapp, https://wandbox.org/permlink/PSkGOSxB2nW66g3zis what I assume you want
[19:36:47] <lpapp> Yeah, I am questioning C++
[19:36:50] <PJBoy> * https://wandbox.org/permlink/PSkGOSxB2nW66g3z is what I assume you want
[19:36:53] <lpapp> the context, not its details
[19:37:02] *** Joins: lionkor (~lionkor@beammp/staff/lionkor)
[19:37:04] <lpapp> PJBoy: 500 — Internal Server Error
[19:37:06] <rpav> if you're not writing code with high-performance needs, you probably shouldn't be using C++
[19:37:15] <PJBoy> lpapp, I malformed the link in the first message
[19:37:16] <lpapp> I do not think it is a good observation
[19:37:25] <lpapp> C++ is not the only high-performance
[19:37:29] <rpav> there are other nicer tools that will likely get the job done faster and prettier
[19:37:30] <lpapp> and performance is often about complexity than micr
[19:37:32] <lpapp> o
[19:37:58] <lpapp> PJBoy: this is not what I wrote.
[19:38:06] <rpav> no, in high-perf stuff, time complexity isn't really even part of the discussion, it's already assumed
[19:38:13] <lpapp> PJBoy: template<typename T, typename S, std::enable_if_t<std::is_arithmetic<S>::value, bool> = true>
[19:38:24] <PJBoy> I thought you wanted to SFINAE over some known set of types
[19:38:29] <lpapp> yeah
[19:38:37] <PJBoy> ah you have a solution already
[19:38:40] <PJBoy> I missed that
[19:38:46] <lpapp> well, not solution
[19:38:47] <lpapp> an idea
[19:38:51] <lpapp> still testing it with CI
[19:39:29] <rpav> (ok, or systems programming .. C++ being pretty good with the low-level bits and bobs applies to that too)
[19:40:16] <lpapp> yeah yeah
[19:40:40] <lpapp> LT would argue :)
[19:41:00] <lpapp> with the system programming part.
[19:41:06] <rpav> ¯\_(ツ)_/¯
[19:41:28] <lpapp> I guess it is okay
[19:41:29] <PJBoy> LT has what you would call a C++ "hate fetish"
[19:41:30] <rpav> C works.. lisp also works.. i think even smalltalk worked
[19:41:40] <lpapp> it is just that sometimes one wishes rust was as popular as C++ or more.
[19:41:41] <rpav> the question is what's most useful
[19:42:07] <rpav> if by "one" you mean "you" then maybe; but call back when you've written tens of thousands of lines of rust and can tell me the downsides
[19:42:28] <lpapp> PJBoy: I got my idea from here: https://en.cppreference.com/w/cpp/types/enable_if
[19:42:35] <PJBoy> yeah your form looks good
[19:42:47] <lpapp> the == true might not be needed in my case.
[19:42:47] <rpav> well to be fair pre-c++-11 was kinda crap, so it's been kinda crap for like 2/3 of the lifetime of linux
[19:43:05] <lpapp> ah, LT loves C++11?
[19:43:07] <lpapp> :)
[19:43:10] <PJBoy> even pre C++11 is better than C
[19:43:14] <rpav> eh
[19:43:30] <PJBoy> now C + gnu extensions, that's more of a competition
[19:43:31] <rpav> i'd disagree since none of the modern things really worked pre-11, or were worse hacks
[19:43:35] <PJBoy> but like
[19:43:40] <PJBoy> function overloading alone makes C++ better
[19:43:53] <rpav> that's a matter of debate
[19:43:55] <PJBoy> why would you want to rewrite the same function several times with the type embedded in the names
[19:44:25] <PJBoy> templates are obviously better than macros where applicable
[19:44:36] <lpapp> yeah, I think C++ is modern without TMP and OOP.
[19:44:40] <rpav> a lot of people just don't like overloading, and though i think it's a bit silly i can see some of the arguments
[19:45:14] <InPhase> Overloading is a huge asset when you can combine it with generic programming with templates.
[19:45:27] <rpav> templates are better where they apply, excepting that they increase code size a bit unpredictably, and are slow as shit
[19:46:03] <rpav> templates and overloading aren't really intersecting except that C++ sortof handwaves them together
[19:46:47] <rpav> i.e. foo<int> wouldn't necessarily have to be "an overload of" foo<double> or whatever, because the type could likewise be part of the name .. it would _look_ like an overload with syntax sugar, but
[19:47:08] <veverak> rpav: templates are slow?
[19:47:13] <veverak> I assert you ment compilation :)
[19:47:31] <InPhase> rpav: Templates run fast and keep code size pretty small since they are compile time abstractions.  Sounds backwards.
[19:47:34] <rpav> veverak: oh, right.. specifically that yes, and a huge problem
[19:47:45] <rpav> like consider how long linux takes to build now, as a C program
[19:47:55] <rpav> and compiling C is incredibly fast today
[19:48:00] <PJBoy> maybe if they switched to modules, it'd compile almost instantly
[19:48:05] <rpav> nah
[19:48:12] <PJBoy> idk man
[19:48:19] <PJBoy> after seeing those stdlib header benchmarks
[19:48:35] *** Joins: paulmcquad (~gamer@78.17.229.141)
[19:48:42] <PJBoy> and knowing that doing metaprogramming with macros can't be optimised
[19:48:43] <InPhase> Compile times do matter, but generally I find them manageable in C++ to not impede development.  Runtime performance is the most important thing.
[19:48:45] *** Quits: lionkor (~lionkor@beammp/staff/lionkor) (Ping timeout: 268 seconds)
[19:49:33] <PJBoy> of course the kernel is prohibitively C-like
[19:49:35] <PJBoy> but still
[19:49:39] <paulmcquad> Hi. Why is this printing out 30 Seats -> https://ideone.com/foDz3I
[19:49:45] <InPhase> Templates let me provide extra abstraction, which increases code clarity, which in turn reduces errors, but without compromising performance.
[19:49:49] *** Joins: soman (~soman@83.139.147.234)
[19:50:07] <InPhase> I find that a worthwhile tradeoff for extra compilation time.
[19:50:12] <PJBoy> paulmcquad, because you told it to
[19:50:14] <rpav> https://www.reddit.com/r/cpp/comments/6aqihe/some_modules_benchmarking/ <- a few years back modules were nearly as slow as #include
[19:50:32] <PJBoy> and now they're hundreds of times quicker
[19:50:39] <PJBoy> just imagine where they'll be in 2 years time from now
[19:50:48] <InPhase> Yeah.  I'm very optimistic about the future of modules.
[19:50:57] <rpav> i haven't actually seen across-the-board benchmarks that are conclusive and recent
[19:51:37] <rpav> _also_ they need to include actual instantiations, because instantiations are where things tend to fall over
[19:51:43] <rpav> not just pure textual parse speedup
[19:52:11] <PJBoy> paulmcquad, one thing I should point out is that you're never using movie2seatsor movie3seats
[19:52:42] <rpav> as of a year ago with gcc it appeared a wash .. http://www.icce.rug.nl/documents/cplusplus/cplusplus07.html#l165
[19:54:26] <rpav> maybe google sucks (ok it definitely sucks but) or my search terms are off but i'm not really seeing more recent benchmarks vs pch at all ;/
[19:54:58] <PJBoy> I think people are still waiting to get support in gcc/clang
[19:55:11] <rpav> clang should have support now i thought
[19:55:42] <PJBoy> still partial on https://en.cppreference.com/w/cpp/compiler_support/20
[19:55:46] <rpav> ok very partial
[19:56:03] <rpav> i had to click the complete one to make sure it wasn't like the basic spec
[19:57:07] <rpav> explicit template instantiation + modules _might_ help a lot, if they can precompile that stuff .. otoh, you can already do that now can't you
[19:58:04] <rpav> like you can `extern template class foo<T>;` can't you then actually stick that instantiation in a specific .cpp?
[19:58:11] <rpav> (for some actual T of course)
[19:58:36] <PJBoy> you can do that, yeah
[19:58:40] <PJBoy> I dare not speculate on compile times though
[19:59:02] *** Parts: lpapp (~lpapp@ec2-15-161-137-233.eu-south-1.compute.amazonaws.com) ()
[19:59:15] <PJBoy> you should at the very least be able to get better incremental build times from modules compared to headers for the declarations that you don't export
[19:59:54] <rpav> yeah hopefully .. even if it's basically "modular PCH" it ought to help
[20:00:07] <PJBoy> and maybe the compiler will actually analyse what things you use from a module when it does its dependency analysis
[20:00:17] <rpav> VS implements this stuff .. i don't know its state but if it's clearly fast then presumably others can too
[20:00:18] *** Joins: toverna (~uni@2.95.65.14)
[20:01:28] <PJBoy> I'll remark that VS is still a bit unstable when it comes to errors involving modules
[20:02:11] <rpav> well 17 took a couple years to get mostly there i guess
[20:02:51] <rpav> this is c++-time; people are still using c++11 like it's modern C++, and that was 10 years ago .. i blame std::chrono
[20:03:10] <PJBoy> libc++ is still struggling with C++17
[20:03:16] <rpav> :/
[20:03:47] <ville> libstdc++ is still struggling with 11! ok ok it's just the cache size queries
[20:04:24] <PJBoy> hahaha
[20:05:00] <ville> oh wait that's 17 too. for some reason thought they were in 11
[20:05:01] <rpav> i don't think anyone 100% implements anything
[20:05:18] <PJBoy> MSVC do
[20:05:28] <PJBoy> maybe they'll rename it to std::sixty_four one day
[20:05:56] <rpav> did anyone actually fully implement codecvt? or pmr?
[20:06:15] <cq-work> codecvt is partially implemented by most compilers.
[20:06:18] <rpav> or probably other dark little crevices of the standard no one uses
[20:06:18] <InPhase> I guess if both gcc and clang are still partial on modules, the next Ubuntu LTS cycle is going to miss out on modules.
[20:06:22] <PJBoy> yeah MSVC
[20:06:44] <ville> speaking of great naming what would you name a function that checks if a value is a power of two?
[20:06:54] <rpav> sqrt?
[20:06:55] <PJBoy> is_power_of_two
[20:07:08] <InPhase> PJBoy: What a terrible name.  It should be:  IsPowerOfTwo
[20:07:18] <ville> amateurs. it's of course has_sinlge_bit: https://en.cppreference.com/w/cpp/numeric/has_single_bit
[20:07:31] <rpav> InPhase: without any manager or factory or bean? madness
[20:08:02] <mort> it's impressive that iostreams has worse formatting options than the ancient printf
[20:08:12] <whupdup> ville: but that wouldn't work on a ternary computer
[20:08:20] <PJBoy> has_single_bit is slightly better for the case where it can only be used with unsigned types
[20:08:55] <InPhase> rpav: I like FunctionCaps, ClassCaps, and variable_snakes for good visual distinction.
[20:09:29] <whupdup> ClassCaps, function_snakes, and variableCamels for me, plus of course LOUD_CONSTANTS
[20:09:34] <PJBoy> popcount is the one I take issue with
[20:09:46] <PJBoy> popcount sounds like an audio DSP function
[20:09:52] <rpav> hah
[20:09:57] <ville> popcount is alright at least it's an instruction directly pretty much
[20:10:22] <PJBoy> or perhaps a evolutionary algorithm helper function
[20:10:28] <InPhase> I group functions with classes, because a class constructor can be conceptualized as just another function call that creates a class.  It's a natural grouping.
[20:10:48] <rpav> whupdup: actually that's an interesting question; how much of the C++ standard relies on running on a binary computer
[20:11:24] <rpav> by interesting i mean "completely useless nerd sniping fodder" but
[20:11:29] <PJBoy> I'd wager all of it
[20:11:44] <whupdup> pretty sure the standard intentionally leaves the definition of bit vague enough to allow for that... or maybe I'm mixing it up with the fact the size of a byte is flexible
[20:11:48] <PJBoy> CHAR_BIT is defined w.r.t. bits
[20:11:55] <InPhase> rpav: Technically it's only as if it runs on a binary computer.
[20:12:01] <rpav> PJBoy: well, like iostreams or strings don't seem to _need_ to be?
[20:12:11] <PJBoy> those are implemented in terms of fundamental types
[20:12:22] <PJBoy> and those fundamental types have a size requirement relative to CHAR_BIT
[20:12:29] <InPhase> rpav: Although implementing some of those as-ifs could get tricky and cumbersome without it.
[20:12:39] <sprout> what is a sane extension for c++20 modules? .cpp? are 'we' going to have .cpp files in include directories now?
[20:12:49] <PJBoy> ixx is sane
[20:12:57] <PJBoy> honestly .hpp is sane still
[20:13:17] <sprout> ixx?
[20:13:18] <PJBoy> granted it's weird to compile headers
[20:13:25] <PJBoy> ixx is what visual studio requires for modules
[20:13:33] <sprout> heh
[20:13:39] <PJBoy> and it's fine, so
[20:13:45] <PJBoy> why not
[20:14:11] <sprout> I usually follow the opensource OS conventions...
[20:14:14] <rpav> InPhase: sure but like, you couldn't have something that _required_ a certain behavior that was only possible on a binary machine, and still be efficient on an arbitrary-non-binary machine
[20:14:25] <sprout> but heh.
[20:14:33] <PJBoy> no one else has implemented modules, so
[20:15:04] <InPhase> rpav: Well, Turing computability and all indicates there's always a way.
[20:15:26] <paulmcquad> How can i minus the seats off movie1?
[20:15:38] <sprout> oh.   figure that.  I thought gcc/llvm were there.   solves a problem I guess
[20:15:45] <sprout> thanks
[20:15:52] <InPhase> rpav: As far as I know the C++ standard does not prohibit the result of compilation from being bytecode run in an embedded interpreter, for example.
[20:16:10] <rpav> InPhase: but "computationally possible" is not the same as "meets certain time-complexity requirements"
[20:16:41] *** Quits: Haohmaru (~Haohmaru@195.24.53.110) ()
[20:16:50] <rpav> all turing machines _can compute_ the same, but are not necessarily equivalently efficient
[20:16:51] <InPhase> rpav: One can anticipate that all bytecode interpreters on non insanely designed non-binary machines providing the same time complexity, even if not the same performance.
[20:17:10] <InPhase> s/providing/provide/
[20:17:24] <rpav> i'm not sure either way
[20:17:38] <ville> whupdup: i am not sure what you mean?
[20:19:03] *** Quits: emerent (~quassel@p200300cd574855bdba27ebfffed28a59.dip0.t-ipconnect.de) (Ping timeout: 268 seconds)
[20:19:24] *** Joins: emerent (~quassel@p200300cd574855f2ba27ebfffed28a59.dip0.t-ipconnect.de)
[20:20:23] <ville> whupdup: c++ defines that the abstract machine has bits that make up bytes. if it's a ternary computer it still needs to work "as-if" if it claims to run c++
[20:20:44] <ville> http://www.eelis.net/c++draft/intro.memory#1.sentence-2
[20:20:46] <whupdup> nevermind, I got the fact that bytes aren't explicitly defined as 8 bits mixed up with defining bits
[20:21:26] <rpav> does the standard actually define "bit"
[20:21:30] *** Quits: smallville7123 (~smallvill@cpe-172-193-72-46.qld.foxtel.net.au) ()
[20:21:45] <PJBoy> the standard doesn't define *all* of computer science
[20:22:04] <rpav> no but it should be specific about relevant terms
[20:22:15] <PJBoy> I think bit is unambiguous
[20:22:42] <rpav> hey, you can't demand pedantry only some of the time! ;)
[20:22:59] <whupdup> does bit imply binary though
[20:23:01] *** Quits: TheHermann (~TheHerman@gateway/tor-sasl/thehermann) (Remote host closed the connection)
[20:23:05] <PJBoy> bit is short for binary digit
[20:23:08] <ville> rpav: c does, c++ references c: https://port70.net/~nsz/c/c11/n1570.html#3.5p1
[20:23:19] <rpav> i mean, if you want to be pedantic, you can, but then i can be non-pedantic and make a valid claim you can't! ;)
[20:23:35] <PJBoy> wtf
[20:23:47] <PJBoy> so C actually allows for bits to hold more than 2 values?
[20:23:49] *** Joins: TheHermann (~TheHerman@gateway/tor-sasl/thehermann)
[20:23:51] <rpav> ville: ah but that doesn't exclude non-binary bits
[20:23:53] <rpav> yeah
[20:24:22] <PJBoy> crazy world
[20:24:35] <rpav> well
[20:24:54] <ville> or you can interpeted that it also restricts that only two values are defined. the object can be larger and able to represent more, but the other values are not recognized
[20:25:40] <rpav> actually you could hypothetically have like the "BCD" equivalent of binary right, like, your system _uses_ trits but your program only encodes everything as bits? though cpu instructions would likely still have to exist to make efficient use of such, since "11t" would not be the same to any math instructions as "11b"
[20:25:41] <PJBoy> it only says that it's large enough for two values
[20:25:47] <PJBoy> it doesn't say what values it can hold :/
[20:25:56] <ville> PJBoy: it also says it may only have one of two values
[20:26:05] <PJBoy> where does it say that?
[20:26:16] <PJBoy> I see the same wording without "only"
[20:26:35] <rpav> oh yeah that'd be another funny one .. it could hold 9 values, none of which are precisely 0 or 1, and none of the arithmetic operations do regular math, but it would still definitely hold 2 values
[20:27:20] *** Joins: lionkor (~lionkor@beammp/staff/lionkor)
[20:27:24] <PJBoy> it also says "byte is composed of a contiguous sequence of bits"
[20:27:30] <PJBoy> which makes me ponder the definition of "contiguous"
[20:30:27] <PJBoy> more info here https://port70.net/~nsz/c/c11/n1570.html#6.2.6.1
[20:30:37] *** Quits: TheHermann (~TheHerman@gateway/tor-sasl/thehermann) (Remote host closed the connection)
[20:30:42] <PJBoy> " Values stored in unsigned bit-fields and objects of type unsigned char shall be represented using a pure binary notation"
[20:31:06] *** Joins: TheHermann (~TheHerman@gateway/tor-sasl/thehermann)
[20:31:14] <PJBoy> and goes on to cite the American National Dictionary for Information Processing Systems
[20:31:45] *** Joins: lkor (~lionkor@beammp/staff/lionkor)
[20:32:35] *** Quits: lionkor (~lionkor@beammp/staff/lionkor) (Ping timeout: 260 seconds)
[20:32:45] <PJBoy> it goes on to say "If there are N value bits, each bit shall represent a different power of 2 between 1 and 2^N - 1, so that objects of that type shall be capable of representing values from 0 to 2^N - 1 using a pure binary representation; this shall be known as the value representation"
[20:33:00] <PJBoy> for unsigned integer types *other* than unsigned char
[20:33:25] <PJBoy> and then signed int bits are defined relative to unsigned int bits
[20:33:28] <mort> weird that std::ifstream::read doesn't return the number of bytes read
[20:33:46] <mort> the last read will be a short read, right, so you have to know
[20:33:48] <PJBoy> that's what gcount is for
[20:33:52] <PJBoy> but yeah it's real weird
[20:34:14] <mort> readsome() returns the count, but doesn't seem to work with file streams?
[20:34:15] <cq-work> I guess they wanted chaining really bad.
[20:34:17] <mort> at least I always get 0
[20:34:58] <mort> we need a completely redesigned, good I/O library for C++
[20:35:03] <PJBoy> readsome is one of those implementation defined functions
[20:35:23] <PJBoy> it has no guarantee of returning any bytes ever
[20:35:25] *** Joins: kenanmarasli (~kenanmara@user/kenanmarasli)
[20:35:32] <mort> I mean it does make sense that it wouldn't work for files tbh, since nothing is pushing data into the ifstream, you have to pull the bytes out of the file
[20:35:40] <mort> a bit weird to have it defined on ifstream though
[20:35:43] <PJBoy> it does work with files
[20:36:11] <PJBoy> if you had an implementation that pre-fetches bytes from a file, it would probably give them to you
[20:37:18] <cq-work> Boost iostream literally refused to use it iirc though
[20:37:37] <PJBoy> yeah there's not much reason to use it
[20:37:40] <PJBoy> if any
[20:38:20] <PJBoy> << in.readsome(data(buf), size(buf)); ifstream in(__FILE__); array<char, 0x10> buf;
[20:38:20] <geordi> Operation not permitted: poll
[20:38:27] <PJBoy> great
[20:38:49] <PJBoy> of course geordi would make this pollitical
[20:39:07] <kalven> huehue
[20:39:17] <mort> I assume it's just disallowing any I/O calls right?
[20:39:23] <PJBoy> thanks for the sympathy laugh
[20:39:27] <PJBoy> nah
[20:39:53] <PJBoy> { in.read(data(buf), size(buf)); cout << buf; } ifstream in(__FILE__); array<char, 0x10> buf;
[20:39:54] <geordi> {'#', 'i', 'f', ' ', '!', 'd', 'e', 'f', 'i', 'n', 'e', 'd', '(', 'G', 'E', 'O'}
[20:40:25] <PJBoy> but geordi is locked down fairly tightly
[20:41:12] <PJBoy> and poll is a system call
[20:41:57] <PJBoy> used for non-blocking IO?
[20:43:03] <cq-work> Again though, I'm not sure what a better API would look like. We've gone over it in the past and there's been past proposals but nothing that would make it significantly better.
[20:43:34] <PJBoy> well I liked the look of that byte IO paper
[20:43:41] <PJBoy> just needs someone to champion it
[20:43:46] *** Joins: skapata (~Skapata@2804:14c:87b0:a6f9:64b5:fc80:8eb8:cf03)
[20:43:46] *** Quits: skapata (~Skapata@2804:14c:87b0:a6f9:64b5:fc80:8eb8:cf03) (Changing host)
[20:43:46] *** Joins: skapata (~Skapata@user/skapata)
[20:44:01] <PJBoy> [P2146]
[20:44:01] <npaperbot> P2146R2: [LEWGI] Modern std::byte stream IO for C++ <https://wg21.link/p2146r2> (by Amanda Kornoushenko) (2020-07-22) (Related: https://wg21.link/p2146r2/github)
[20:44:28] <cq-work> Yeah, but nobody liked that. Iirc, the reference implementation got removed and it was shit on on reddit and twitter
[20:44:46] <PJBoy> I don't think anyone disliked it
[20:45:08] <PJBoy> but yeah the author + social media = shitty drama
[20:50:23] <sprout> heh.  feels like the only 'sane' solution for OSes is to add a module directory,  /usr/local/module.  a place where modules go
[20:50:33] <sprout> not sure I am gonna touch this
[20:52:02] *** Quits: onizu (uid373383@id-373383.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[20:52:19] <Alipha> Just implement a type-safe fprintf and fscanf ;-)
[20:52:44] <sprout> free the type.   nudity is the future
[20:52:55] *** lkor is now known as lionkor
[20:53:05] <sprout> uh,  free the term
[20:53:11] <sprout> or something
[20:55:18] <PJBoy> erase the type
[20:58:34] <Alipha> I don't know what type of person you are, but...
[21:00:17] *** Joins: Serpent7776 (~Serpent77@90-156-31-193.internetia.net.pl)
[21:01:35] *** Quits: toverna (~uni@2.95.65.14) (Quit: Konversation terminated!)
[21:02:16] <PJBoy> I'm pretty generic
[21:03:43] *** Joins: Guest41 (~Guest41@eth-west-pareq2-46-193-4-100.wb.wifirst.net)
[21:04:22] <Alipha> PJBoy is more of a concept, apparently
[21:16:34] <Alipha> mort: PJBoy: fyi, the explicit instantiation route was viable, if you didn't want to go with the lambda trick: https://wandbox.org/permlink/X6JkxFkuF6N9njn0
[21:17:56] *** Joins: AbleBacon (~AbleBacon@user/AbleBacon)
[21:20:53] <PJBoy> ah perfect
[21:30:50] *** Joins: kraa (~kraa@107-190-7-216.cpe.teksavvy.com)
[21:31:26] *** Joins: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net)
[21:32:52] *** Joins: stefanos82 (~stefanos8@62-169-104.netrun.cytanet.com.cy)
[21:35:38] *** Joins: paule32 (~paule32@user/paule32)
[21:35:57] *** Joins: m_ben (~m_ben@user/m-ben/x-7429725)
[21:37:24] *** Quits: npaperbot (~npaperbot@dodecahedron.m-ou.se) (Remote host closed the connection)
[21:37:33] *** Joins: npaperbot (~npaperbot@dodecahedron.m-ou.se)
[21:37:33] *** ChanServ sets mode: +v npaperbot
[21:39:37] *** Joins: TheGuestMovie (~TheGuestM@173.231.114.74)
[21:43:29] *** Joins: nikko77 (~nikko77@2001:1388:5ca1:b729:4495:60a9:53f5:d6d4)
[21:44:04] *** Quits: markong (~kvirc@213.146.188.203) (Ping timeout: 268 seconds)
[21:45:17] *** Quits: stefanos82 (~stefanos8@62-169-104.netrun.cytanet.com.cy) (Quit: Leaving)
[21:45:46] *** Quits: paulmcquad (~gamer@78.17.229.141) (Quit: Konversation terminated!)
[21:46:26] *** Quits: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
[21:47:50] *** Joins: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net)
[21:48:46] *** Quits: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net) (Client Quit)
[21:50:11] *** Joins: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net)
[22:27:14] *** Quits: Juliu (~Juliu@2a02:810b:c640:3ec0:2402:3824:89e9:f383) (Ping timeout: 268 seconds)
[22:28:46] *** Quits: TheGuestMovie (~TheGuestM@173.231.114.74) (Quit: Client closed)
[22:33:55] *** Joins: smallville7123 (~smallvill@cpe-172-193-72-46.qld.foxtel.net.au)
[22:41:46] *** Quits: ahlk (~user@2600:1700:31c0:3a10::43) (Ping timeout: 245 seconds)
[22:45:05] *** Joins: Juliu (~Juliu@2a02:810b:c640:3ec0:2402:3824:89e9:f383)
[22:46:22] <MaddHatter> what's the name of that packager for c++? Popular, let's you self-host... mentioned in this channel before
[22:47:25] <MaddHatter> hmm... was it conan?
[22:49:31] <comrad> vcpkg or something, that thingy from microsoft?
[22:50:04] <comrad> MaddHatter: probably conan yeah
[22:50:24] <rpav> probably conan, but really you should check out https://github.com/cpm-cmake/CPM.cmake
[22:50:54] <MaddHatter> rpav: we don't use cmake... sort-of. It's complicated. Mostly don't.
[22:51:08] <rpav> conan is sortof the JavaPackageFactoryClassManagerBean solution
[22:51:24] <rpav> well conan will definitely hypothetically support non-cmake
[22:51:35] <MaddHatter> so how do conan and vcpkg compare?
[22:52:12] <rpav> my impression is that vcpkg is the "quick and easy toy" and conan is the "rough and enterprisey total solution"
[22:52:43] <comrad> i combine vcpkg and microsoft in my mind. and that reminds me of the awful nuget, so i tend to avoid it
[22:52:59] <rpav> i didn't actually use vcpkg, but it didn't seem to support a lot of build-type stuff or various configurations ... i _did_ host my own conan build for awhile, which was sortof doable but a lot of work
[22:53:16] <TinoDidriksen> vcpkg is great.
[22:53:41] <rpav> (build type/config stuff like "I want these options with debug/x86_64 for linux" or "windows + gcc + release" etc)
[22:53:48] <MaddHatter> that's not real encouraging... I don't want "a lot of work" because nobody's going to buy into that, but we do have a lot of various configurations to deal with
[22:54:43] <rpav> conan wasn't _that_ much work, i mean .. i was one person self-hosting and it worked, if you had like a couple people semi-owning it it would probably be fine
[22:54:46] *** Quits: meator (~meator@user/meator) (Quit: Leaving)
[22:55:20] <rpav> i never set up their "big"/official server thing either, just used the tiny one that didn't require 8GB of ram, java, and a sacrificed goat
[22:55:36] *** Quits: Tobbi (~Tobbi@2a02:8108:1240:48ec:a86f:1f20:803d:2891) (Ping timeout: 268 seconds)
[22:55:57] <rpav> but at the same time you definitely get a lot of flexibility, binary packages, distribution of stuff, etc
[22:56:28] <comrad> i never understood why java solutions had to be so blown memory eating
[22:56:35] <rpav> all i really needed was "fetch/build X" and i wanted something that was easy/transparent for distirbuting open souce stuff too
[22:57:02] <comrad> i love java and i tend to write java tools with less ram
[22:57:33] <rpav> no idea .. probably mostly style and design
[22:57:41] <Raziel> bad coders? :^)
[22:57:48] <rpav> also JVMs which may require large static allocations and not be able to dynamically reallocate their heap?
[22:57:51] *** Joins: Tobbi (~Tobbi@2a02:8108:1240:48ec:d482:ac12:2161:fb6a)
[22:57:58] <rpav> probably
[22:58:23] <comrad> rpav: you can set max heap to be used on a JVM, that does not mean it will use all 8 gig from the start
[22:59:47] <TinoDidriksen> It's still absurd that Java can't just grow by default. Being able to set a max is fine - requiring to know the max up front is silly.
[23:00:24] <comrad> TinoDidriksen: you can argue both ways, with the max limit your software cannot eat all of your ram away
[23:00:37] *** Joins: ahlk (~user@2600:1700:31c0:3a10::43)
[23:01:21] <TinoDidriksen> No, the default should be to dynamically grow infinitely. If you want to limit it, that's fine - but the default should not be limited.
[23:05:17] <comrad> your RAM is infinite?
[23:05:39] <comrad> i understand what you mean, but practically this is not a problem
[23:06:15] <Alipha> downloadmoreram.com
[23:06:25] <comrad> RaaS!
[23:06:39] <TinoDidriksen> Practically it is a problem. Just ask any Minecraft player.
[23:06:47] *** Joins: paul424 (~tom@ip-5-172-236-151.multi.internet.cyfrowypolsat.pl)
[23:06:55] <paul424> What is general way of making deep copy ?
[23:07:17] <TinoDidriksen> Use the copy-ctor and ensure it does what you want.
[23:07:38] <paul424> naah I do use operator=
[23:07:54] <TinoDidriksen> That's also fine.
[23:07:58] <Raziel> TinoDidriksen, I just give minecraft like 64gb, it has not managed to fully use that yet :p
[23:08:01] <MaddHatter> We've had to screw with jvm setting so much to keep Jenkins running
[23:08:04] <Alipha> !give paul424 ruleof3
[23:08:05] <nolyc> paul424: If you have one of 1) non-empty destructor 2) copy constructor 3) copy assignment operator then you almost certainly need _all_ three. In C++11, this is optionally extended to the Rule Of Five (by including the move constructor and move assignment operator).
[23:08:37] <paul424> I have pointer to mCoveringBuilding ... so it should be something like mCoveringBuilding = new Building(*mCoveringBuilding) right ?
[23:08:48] <TinoDidriksen> That's the copy-ctor.
[23:08:53] *** Quits: kraa (~kraa@107-190-7-216.cpe.teksavvy.com) (Remote host closed the connection)
[23:09:11] *** Joins: kraa (~kraa@107-190-7-216.cpe.teksavvy.com)
[23:09:19] <Alipha> paul424: why is mCoveringBuilding a Building pointer instead of a Building object?
[23:09:29] <TinoDidriksen> And you should use smart pointers if you must have pointers.
[23:09:41] <MaddHatter> paul424: it depends; that's why the compiler doesn't do it for you automatically. Maybe you want a unique_ptr. Maybe you want a shared_ptr. Maybe you want to copy the pointed-to thing.
[23:10:03] <paul424> Alipha, because Building are independent entities ?
[23:10:29] <Alipha> paul424: what do you mean by "independent"?
[23:12:31] <paul424> arghts Building is Abstract base class
[23:15:53] *** Joins: greyrat (~greyrat@ip202.ip-51-178-215.eu)
[23:16:03] <Alipha> paul424: i'm used to sewing by hand. doesn't mean that a sewing machine would be easier and faster ;-)
[23:16:11] <Alipha> *wouldn't be
[23:16:49] <paul424> Alipha, good methor I will keep it in mind ;)
[23:17:09] *** Server sets mode: +Fcnt 
[23:18:21] *** Quits: m_ben (~m_ben@user/m-ben/x-7429725) (Quit: WeeChat 3.3)
[23:18:59] <paul424> naah following the code base of large project is hard , really hard
[23:20:56] <paul424> I have had a collegue on university working for a enterprise company which maintained a program of 1000 LOC. Then I thought it was an enterprise to work on such large code base. But here is OD which is few dozens of thousands line of code
[23:21:34] *** Joins: ARoxdale (~ARoxdale@84.203.31.229)
[23:21:51] <paul424> what I lack the most is some class browser in emacs .... so far I can jump from file to file , method to method with speedbar
[23:22:16] *** Quits: mackal (~mackal@pool-96-237-249-63.bstnma.fios.verizon.net) (Quit: BE VIGILANT.)
[23:22:29] *** Quits: riksteri (riksteri@gateway/vpn/airvpn/riksteri) (Quit: riksteri)
[23:22:44] <paul424> but I would like to have something more class oriented ... and this mouse usage is so counter productive ... ok enough confessions ;D
[23:23:11] *** Joins: grep_xtrange (~x@ac255238.ppp.asahi-net.or.jp)
[23:23:40] *** Joins: nshire_ (~Neal@47.150.248.17)
[23:24:46] *** Quits: blackout69 (~blackout6@net-31-156-121-187.cust.vodafonedsl.it) (Quit: Leaving.)
[23:24:49] *** Joins: mackal (~mackal@pool-96-237-249-63.bstnma.fios.verizon.net)
[23:26:44] *** Quits: z8z (~x@ac255238.ppp.asahi-net.or.jp) (Ping timeout: 260 seconds)
[23:27:12] *** Quits: nshire (~Neal@user/nshire) (Ping timeout: 260 seconds)
[23:28:04] <Alipha> https://wandbox.org/permlink/J3eGI4fG3LUeWfdA ?
[23:31:28] *** Joins: pah (~pah@user/pah)
[23:32:11] *** Quits: pa (~pah@user/pah) (Ping timeout: 264 seconds)
[23:33:30] <ville> paul424: https://github.com/emacs-lsp/lsp-mode/
[23:34:57] <paul424> Alipha, ville yeap thanks :)
[23:38:01] *** Quits: nshire_ (~Neal@47.150.248.17) (Quit: Leaving)
[23:38:16] *** Joins: nshire (~Neal@user/nshire)
[23:44:17] *** Quits: TheHermann (~TheHerman@gateway/tor-sasl/thehermann) (Remote host closed the connection)
[23:45:03] *** Joins: TheHermann (~TheHerman@gateway/tor-sasl/thehermann)
[23:47:43] <cq-work> It's not uncommon, I don't think, for big companies to have codebases with a million or more lines of code.
[23:48:07] <cq-work> A few thousand lines is like... a function worth to some of these companies.
[23:48:59] <cbreak> line count is easier to come by with almann style, and a line length limit of 80 :D
[23:49:17] *** Quits: johnny (~johnny@user/johnny) (Read error: Connection reset by peer)
[23:49:43] <Alipha> my work's codebase is in the millions and we're not that big. granted, it's enterprise java code (and other languages)
[23:50:12] <paul424> hmm and that auto thing .... is there a tool which would re-stitch and re-decorate my program with types instead of auto ?
[23:50:45] <paul424> cbreak, he he ;)
[23:51:14] <imMute> paul424: some uses of auto can't be replaced with the actual types - such as generic functions
[23:51:44] <cbreak> generic functions aren't objects
[23:51:56] <cbreak> auto is only for objects
[23:53:00] <imMute> cbreak: I meant generic (templated) functions that must use auto because the actual types involved depend on parameters and thus can't be replaced with the actual types (because they change depending on invocation)
[23:53:07] <cq-work> You're saying `auto bob = [&] {};` doesn't end up with bob having an object?
[23:53:23] <cbreak> imMute: ah, templates
[23:54:07] <cbreak> it's possible to write the correct type there, usually, if you can write a template meta programming expression for it
[23:54:31] <paul424> so such programs exists or not ?
[23:55:02] <cbreak> paul424: try an IDE. Those sometimes tell you the true types on instantiations
[23:55:16] <cbreak> but it only makes sense for instantiations obviously
