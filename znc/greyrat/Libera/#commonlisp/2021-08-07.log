[00:04:05] <lisp-newbie> Hi, I'm getting when doin: (alexandria-1:alist-plist (param-list)) a plist where each value is itself a list of the value AKA a cons... but I just want the value itself...anyone have any ideas why and how to fix it?
[00:05:02] <Josh_2> Can you show me what you mean?
[00:05:13] *** Joins: dsk (~dsk@user/dsk)
[00:05:20] *** Quits: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d) (Ping timeout: 256 seconds)
[00:05:27] *** Quits: makomo_ (~makomo@user/makomo) (Quit: WeeChat 3.0.1)
[00:05:36] *** Joins: makomo (~makomo@user/makomo)
[00:05:46] <lisp-newbie> the outputs? yeah...
[00:05:54] <Josh_2> Yes
[00:06:07] <Bike> lisp-newbie: in an alist the value for a given key is the cdr of the cons. like '((a . 4) (b . 6)) means a = 4, b = 6
[00:06:11] <lisp-newbie> for a list like this: (("id" 24) ("name" "sample - 24, 712 issue 76"))
[00:06:15] <lisp-newbie> I get this
[00:06:32] <Bike> right, that's (("id" . (24)) ("name" . ("sample...")))
[00:06:58] <lisp-newbie> ("id" (24) "name" ("sample - 24, 712 issue 76"))
[00:07:59] <lisp-newbie> oh, so what I have is not really an a list then haha
[00:08:01] <lisp-newbie> ?
[00:09:27] <lisp-newbie> https://www.gnu.org/software/emacs/manual/html_node/elisp/Dotted-Pair-Notation.html so from this I had a list, not an alist... got it
[00:10:15] <Bike> well, you had an alist where the values are lists
[00:10:35] *** Quits: rain3 (~rain3___@79.115.250.43) (Ping timeout: 258 seconds)
[00:12:27] <nirnam> what do you call a list that contain alist in which value are a list?
[00:18:58] *** Joins: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d)
[00:20:48] <pjb> lisp-newbie: assoc returns the entry. For an a-list, you can use cdr on the entry to get the value. If you map keys to lists, you can use second instead.
[00:21:32] <pjb> (mapcar 'cdr '((a . 4) (b . 6))) #| --> (4 6) |#  (mapcar 'second '(("id" 24) ("name" "sample - 24, 712 issue 76"))) #| --> (24 "sample - 24, 712 issue 76") |#
[00:22:01] <lisp-newbie> pjb Bike, thanks, I was dealing with the same function I've been working for the past few days, I got it... I did like this: (map 'list (lambda (it) (cons (symbol-maker (car it)) (cadr it))) alist-nonsymbols)
[00:22:14] <lisp-newbie> I converted the list to be an alist
[00:22:52] <pjb> (mapcar  (lambda (value alist) (funcall value (assoc 'key alist)))   '(cdr second)  '( ((a . 1) (key . foo) (b . 2))   ((a  1) (key  foo) (b  2)))) #| --> (foo foo) |#
[00:22:59] <pjb> lisp-newbie:
[00:23:02] <pjb> ^
[00:23:04] <lisp-newbie> but the problem with what I'm doing is that for a value like this: (("list" 1 2 3 4)) I loose the 2 3 4
[00:23:19] <lisp-newbie> but I think that's OK for my use, because I don't really expect, at least not now, to have lists...
[00:23:24] <pjb> lisp-newbie: of course, if you really have a list, use cdr!
[00:23:30] <pjb> or wrap the list.
[00:23:49] <lisp-newbie> what does wrapping the list mean?
[00:23:53] <lisp-newbie> pjb ^
[00:24:12] <pjb> (cdr (assoc "list" '(("list" 1 2 3 4)) :test (function equal))) #| --> (1 2 3 4) |#
[00:24:12] <pjb> (second (assoc "list" '(("list" (1 2 3 4))) :test (function equal))) #| --> (1 2 3 4) |#
[00:24:24] <pjb> this:                          ^
[00:24:42] *** Quits: amb007 (~a_bakic@118.175.185.81.rev.sfr.net) (Ping timeout: 245 seconds)
[00:24:57] <pjb> because with conses: (("list" (1 2 3 4))) == (("list" . ((1 2 3 4))))
[00:26:32] <pjb> The question is whether you have a lot of literal data, in which case you may prefer to avoid the dot (simplier to type), then you must use list operators, or whether you will build the alist by program, in which case you can ignore the question and just use cons and car/cdr. (or acons to build the a-list).
[00:26:56] <pjb> with a lot of literal data,  you may even prefer to write p-lists.
[00:26:59] <lisp-newbie> oh gt it
[00:27:02] <lisp-newbie> by program
[00:27:12] <lisp-newbie> *got it
[00:27:26] <lisp-newbie> yeah, thanks, that clears it up, I'm going to check if it works now
[00:27:27] <pjb> p-lists have the advantage of having fewer parentheses, but the inconvenient of not detecting missing keys or values.
[00:27:53] <pjb> (a 1 b 2 c 3)   simplier to write.   but if you skip a value: (a 1 b c 3) that breaks without noticing.
[00:28:14] <Inline> duhh, no idea but i liked the one sided paren of plisp or so in reduce (algebra system)
[00:28:22] <Inline> heh
[00:28:32] *** Joins: froggey (~froggey@cpc96342-rdng26-2-0-cust314.15-3.cable.virginm.net)
[00:30:24] *** Joins: lisp123_ (~lisp123@45.130.83.208)
[00:32:44] *** Joins: peterhil (~peterhil@dsl-hkibng32-54fb52-57.dhcp.inet.fi)
[00:34:16] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 272 seconds)
[00:44:50] <jcowan> my brain is a little fried today: is there a CL macro-like thing that is recognized in operand position either as well as, or separately from, being recognized in operator position?
[00:46:30] <pjb> I don't understand the question.
[00:47:06] <pjb> perhaps you mean lambda?
[00:47:08] *** Joins: amb007 (~a_bakic@80.149.170.8)
[00:47:38] <pjb> (lambda ())  is a macro that expands to (function (lambda ())) in which lambda is (in) an argument.
[00:49:13] <Bike> No, if I understand the question correctly
[00:49:14] *** Quits: nirnam (~nirnam@1.47.135.162) (Ping timeout: 268 seconds)
[00:49:27] <Bike> or maybe symbol macros would count
[00:50:32] <pjb> (let ((list (list (quote list)))) (list list)) #| --> ((list)) |#
[00:50:43] <pjb> does (list list) qualify?
[00:53:33] *** Quits: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d) (Ping timeout: 276 seconds)
[00:53:40] *** Quits: lisp-newbie (~lisp-newb@186.75.20.114) (Quit: This computer has gone to sleep)
[00:56:26] *** Joins: lisp-newbie (~lisp-newb@186.75.20.114)
[00:57:38] *** Quits: cage (~cage@dynamic-adsl-78-15-36-212.clienti.tiscali.it) (Remote host closed the connection)
[00:57:53] *** Quits: pegaso (~reis-r@177.107.24.63) (Quit: Leaving)
[00:59:17] *** Joins: nirnam (~nirnam@1.47.135.162)
[01:00:48] *** Joins: cage (~cage@dynamic-adsl-78-15-36-212.clienti.tiscali.it)
[01:03:39] *** Joins: Fare (~fare@2601:184:4a7f:995c:e987:a9ae:e4c8:1c6e)
[01:03:57] *** Quits: silasfox (~sbv@2001-4dd6-62dc-0-6027-7522-36-c7ab.ipv6dyn.netcologne.de) (Ping timeout: 276 seconds)
[01:06:00] *** Joins: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d)
[01:06:18] *** Quits: amb007 (~a_bakic@80.149.170.8) (Read error: Connection reset by peer)
[01:06:40] *** Joins: amb007 (~a_bakic@80.149.170.8)
[01:07:13] *** Quits: lisp-newbie (~lisp-newb@186.75.20.114) (Quit: This computer has gone to sleep)
[01:10:38] *** Joins: silasfox (~sbv@2001-4dd6-62dc-0-6027-7522-36-c7ab.ipv6dyn.netcologne.de)
[01:20:06] *** Joins: lisp123 (~lisp123@5.30.23.247)
[01:22:22] *** Joins: lisp-newbie (~lisp-newb@186.75.20.114)
[01:23:24] *** Quits: mingus (~jan-magnu@ti0135a400-2471.bb.online.no) (Read error: Connection reset by peer)
[01:23:38] *** Joins: mingus (~jan-magnu@ti0135a400-2471.bb.online.no)
[01:24:06] *** Quits: lisp123_ (~lisp123@45.130.83.208) (Ping timeout: 276 seconds)
[01:24:42] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 240 seconds)
[01:32:40] *** Quits: lisp-newbie (~lisp-newb@186.75.20.114) (Quit: This computer has gone to sleep)
[01:35:07] *** Quits: dlowe (~dlowe@user/dlowe) (Ping timeout: 245 seconds)
[01:39:54] *** Quits: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d) (Ping timeout: 258 seconds)
[01:42:12] *** Quits: gaqwas (~john@dynamic-095-117-155-081.95.117.pool.telefonica.de) (Ping timeout: 258 seconds)
[01:42:42] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[01:45:39] *** Quits: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 252 seconds)
[01:46:20] *** Joins: lisp-newbie (~lisp-newb@186.75.20.114)
[01:50:45] *** Quits: pve (~pve@37-136-239-129.rev.dnainternet.fi) (Quit: leaving)
[01:52:23] <jcowan> Symbol macros, yes.  Thanks.
[01:53:45] <lotuseater> I like those. :)
[01:54:11] <jcowan> I'm not a big fan, but they have their uses.
[01:54:24] <lotuseater> yes
[01:54:32] *** Quits: cage (~cage@dynamic-adsl-78-15-36-212.clienti.tiscali.it) (Quit: rcirc on GNU Emacs 27.1)
[01:55:35] <lotuseater> for example one time I used SYMBOL-MACROLET in a function which was a translated geometric algorithm from Pascal
[01:56:52] <lotuseater> so for "better reading" I used eg (symbol-macrolet ((p[i].x (point-x (aref p i))))) to condense this accession to the x coordinate
[01:57:05] *** Joins: lisp123 (~lisp123@5.30.23.247)
[01:59:32] <jcowan> A nice case is to somewhat transparently convert a function to a macro.  You can't write #'foo where foo is a macro name, but you can write foo where foo is a symbol macro that expands to the function underlying the ordinary macro.
[01:59:32] *** Quits: nirnam (~nirnam@1.47.135.162) (Read error: Connection reset by peer)
[01:59:45] *** Joins: nij- (~jin@2001-48F8-9021-806-0-0-0-1AD1-dynamic.midco.net)
[01:59:59] *** Quits: amb007 (~a_bakic@80.149.170.8) (Read error: Connection reset by peer)
[02:00:12] <nij-> I can't figure this out.. could someone help out? It's related to CFFI and some UNIX socket stuff: %make-unix-socket
[02:00:31] <nij-> https://github.com/tdrhq/cl-unix-sockets/blob/master/unix-sockets.lisp#L228 in I can connect to a socket using this line of code
[02:01:06] <nij-> In another terminal, I ran `$ socat - UNIX-RECV:/tmp/file` to listen on the socket /tmp/file.
[02:01:21] <nij-> However, both ends don't seem to be compatible.
[02:02:32] <nij-> Here's the backtrace: https://bpa.st/DNEA
[02:03:59] <lotuseater> jcowan: ha yes :D
[02:05:56] *** Quits: lisp-newbie (~lisp-newb@186.75.20.114) (Quit: This computer has gone to sleep)
[02:11:20] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 258 seconds)
[02:17:21] *** Joins: amb007 (~a_bakic@194.24.248.254)
[02:25:09] *** Joins: lisp-newbie (~lisp-newb@186.75.20.114)
[02:31:24] *** Quits: lisp-newbie (~lisp-newb@186.75.20.114) (Quit: This computer has gone to sleep)
[02:31:39] *** Quits: amb007 (~a_bakic@194.24.248.254) (Ping timeout: 258 seconds)
[02:31:41] *** Joins: lisp-newbie (~lisp-newb@186.75.20.114)
[02:31:54] *** Quits: lisp-newbie (~lisp-newb@186.75.20.114) (Remote host closed the connection)
[02:32:02] *** Joins: lisp-newbie (~lisp-newb@186.75.20.114)
[02:32:15] *** Quits: lisp-newbie (~lisp-newb@186.75.20.114) (Remote host closed the connection)
[02:34:31] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[02:37:46] *** Joins: akoana (~ah@user/akoana)
[02:41:25] *** Quits: Krystof (~user@81.174.155.115) (Ping timeout: 250 seconds)
[02:42:57] *** Joins: lisp123 (~lisp123@5.30.23.247)
[02:47:38] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 268 seconds)
[02:56:08] <Bike> nij-: https://github.com/tdrhq/cl-unix-sockets/blob/master/unix-sockets.lisp#L81 this should be :format-control. that's why you're getting a meta-error. i don't know about your actual problem, though.
[02:59:32] *** Quits: rogersm (~rogersm@90.166.177.48) (Quit: Leaving...)
[03:02:24] *** Joins: amb007 (~a_bakic@cable-94-189-183-212.dynamic.sbb.rs)
[03:06:14] *** Quits: amb007 (~a_bakic@cable-94-189-183-212.dynamic.sbb.rs) (Read error: Connection reset by peer)
[03:06:21] *** Joins: PinealGlandOptic (~PinealGla@37.115.210.35)
[03:06:22] *** Quits: random-nick (~random-ni@87.116.181.197) (Ping timeout: 245 seconds)
[03:06:52] *** Joins: rgherdt_ (~rgherdt@ip5f5af1c2.dynamic.kabel-deutschland.de)
[03:07:49] *** Joins: amb007 (~a_bakic@cable-94-189-183-212.dynamic.sbb.rs)
[03:16:07] *** Quits: frgo (~frgo@p200300deef181d001d95c29ee5038c26.dip0.t-ipconnect.de) (Remote host closed the connection)
[03:16:34] *** Joins: frgo (~frgo@p200300deef181d00f162dfaf18093baa.dip0.t-ipconnect.de)
[03:18:42] *** Quits: amb007 (~a_bakic@cable-94-189-183-212.dynamic.sbb.rs) (Read error: Connection reset by peer)
[03:19:00] *** Joins: lisp-newbie (~lisp-newb@186.75.20.114)
[03:20:24] *** Joins: amb007 (~a_bakic@cable-94-189-183-212.dynamic.sbb.rs)
[03:21:09] *** Quits: lisp-newbie (~lisp-newb@186.75.20.114) (Client Quit)
[03:21:24] *** Joins: lisp-newbie (~lisp-newb@186.75.20.114)
[03:21:36] *** Quits: lisp-newbie (~lisp-newb@186.75.20.114) (Remote host closed the connection)
[03:21:44] *** Joins: lisp-newbie (~lisp-newb@186.75.20.114)
[03:22:06] *** Quits: lisp-newbie (~lisp-newb@186.75.20.114) (Remote host closed the connection)
[03:22:27] *** Quits: attila_lendvai (~alendvai@C226779F.nat.pool.telekom.hu) (Ping timeout: 252 seconds)
[03:28:41] *** Quits: selwyn (~selwyn@user/selwyn) (Quit: Leaving)
[03:32:06] *** Quits: uai (~uai@80.84.120.18) (Quit: WeeChat 3.2)
[03:33:44] <nij-> Bike: oh - I want to send a message from the Lisp repl to the terminal :)
[03:36:03] *** Joins: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d)
[03:36:12] <dieggsy> does allegro's excl:dumplisp not work properly if run from sly/slime ?
[03:36:46] <dieggsy> it seems to hang on alisp -I my-image (I also don't know how to start a sly repl from an image)
[03:39:26] *** Quits: Melantha (~pyon@user/pyon) (Quit: WeeChat 3.2)
[03:42:23] <nij-> dieggsy what's the error message?
[03:42:45] <dieggsy> nij-: no error message, the image just doesn't start up properly if i dumplisp from within sly
[03:43:13] <dieggsy> ....i've found a few people online saying saving images while connected to slime/sly doesn't work, so maybe that's just something i hvae to live with?
[03:43:30] <dieggsy> it just sort of hangs forever
[03:44:09] <nij-> sly works by connecting to the slynk server
[03:44:23] <nij-> maybe it's because that the image is await to be connected to a sly?
[03:44:41] <nij-> Last time it didn't let me dump, saying that i will break the thread (that allows the connection)
[03:46:02] <dieggsy> ah, ok. welp. now I know, i guess. it's extremely inconvenient though
[03:46:29] <dieggsy> i wanted to save state after something that takes quite a while to execute
[03:46:30] <Xach> dieggsy: it is very normal for any lisp to not work if there are threads and stuff running.
[03:46:54] <Xach> dieggsy: the normal way to do that is to load things in a single thread and then dump, being careful not to start other extra stuff
[03:47:05] <Xach> or carefully stop it if you do start it
[03:47:44] <Xach> i use alisp dumped images, slynk is loaded but no server started. the server starts when the image restarts.
[03:48:16] <dieggsy> Xach: wait, but that does mean i can't dump after already running slynk, right ?
[03:48:57] <Xach> dieggsy: i think you can, if you stop the server and its threads.
[03:49:26] <dieggsy> Xach: i'm not actually sure how to do that. wouldn't that cut off my connection with the repl
[03:50:19] <Xach> dieggsy: one of them, yeah. but allegro has a rich repl by default, and can also do batchy things too (which is a good way to set up an image to dump)
[03:50:52] <Xach> in other words: you should not generally be interactively initiating an image dump from a repl like sly's.
[03:51:59] <dieggsy> ah. ok. and the way around this would be to... start some other repl from which i start a slynk server that I connect to with sly, and stop sly when I want to dump, doing so from the original repl?
[03:54:05] <nij-> Bike:  Nvm, I found a workaround! Finally :) thanks for reaching out!
[03:54:45] <nij-> You stop slynk, not sly dieggsy
[03:55:01] <nij-> sly is on the emacs' side. Slynk is the thread that's run from the perspective of the lisp repl.
[03:55:19] <dieggsy> er, right. that
[03:55:22] <nij-> In particular, there's `slynk.lisp` and `sly.el`.
[03:55:31] <nij-> So you wouldn't want to start slynk at all..
[03:55:55] <dieggsy> well, I'd want to if i want to interact with lisp from emacs using sly
[03:55:57] <nij-> But maybe there's some workaround. I dunno \@_@/
[03:56:22] <dieggsy> the point is to have the convenience of sly but be able to save an image as well
[03:56:32] <dieggsy> so I'd have to start and stop it when i needed to do that
[03:57:41] <Xach> dieggsy: in my experience making an image is very batchy. not something you do after a fun interactive session.
[03:58:02] <Xach> I'm open to new paradigms but that's my experience
[03:58:06] <nij-> I think dieggsy wants a running slynk once it's started.
[03:58:28] <nij-> Is that what you want?
[03:59:14] <nij-> Oh perhaps not \ @@ /
[03:59:45] <dieggsy> What I want is just to save an image after a REPL session like I can do from a terminal, because then I can later start a repl using that image
[03:59:47] <dieggsy> which works fine on the terminal
[04:00:06] <dieggsy> but doesn't let me do fun emacs stuff
[04:02:26] <Xach> dieggsy: i haven't seen people do that - i think it would take a little creativity but maybe it's not too hard
[04:02:47] <Xach> being aware of what threads might be doing stuff and stopping them
[04:02:49] <nij-> You can perhaps create a thread that sleeps for 20 seconds, and then wake up, killing all other threads, and save+die.
[04:03:08] <nij-> That will kill slynk and the connection to sly too xD
[04:05:07] <dieggsy> Basically this is just because we have a program that's largely interacted with through the repl and sometimes to debug I read in a bunch of objects from a database, which can take a couple hours. It'd be nice to have an image to start from where this is all pre-loaded. I can probably just set this up once from the terminal and try and connect to that image with sly/slynk, since I don't have to do this regularly. Might try that next
[04:10:16] *** Quits: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d) (Ping timeout: 268 seconds)
[04:10:33] *** Quits: rgherdt_ (~rgherdt@ip5f5af1c2.dynamic.kabel-deutschland.de) (Ping timeout: 258 seconds)
[04:16:25] <nij-> I don't know why this wouldn't work: https://bpa.st/PVQA
[04:16:56] <nij-> I make a thread that kills all the non-essential thread, and call save-lisp-and-die.. but it didn't kill the lisp, and there's no image dumped.
[04:18:39] <hayley> Here I get the error message "Cannot save core with multiple threads running."
[04:19:27] <hayley> I think you are supposed to save from the first thread created, and there is a library for picking the first thread portably...
[04:21:36] <hayley> (trivial-main-thread:with-body-in-main-thread () (mapc #'bt:destroy-thread (remove trivial-main-thread:*main-thread* (bt:all-threads))) (sb-ext:save-lisp-and-die "/tmp/blah")) amazingly works.
[04:21:57] <hayley> However, the resulting core does not appear to want to work.
[04:25:01] *** Joins: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d)
[04:30:48] <Xach> destroying threads is pretty dodgy
[04:30:58] <Xach> it can foul up state pretty well
[04:31:43] <hayley> Yeah, don't do this.
[04:50:36] *** Joins: dlowe (~dlowe@user/dlowe)
[04:53:06] *** Quits: Fare (~fare@2601:184:4a7f:995c:e987:a9ae:e4c8:1c6e) (Ping timeout: 258 seconds)
[04:55:43] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[04:58:34] *** Quits: taiju (~taiju@240b:253:ec40:2400:3cf8:2df8:a9c6:9f5a) (Ping timeout: 240 seconds)
[04:58:51] *** Quits: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d) (Ping timeout: 258 seconds)
[04:59:15] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 276 seconds)
[05:08:26] *** Quits: amb007 (~a_bakic@cable-94-189-183-212.dynamic.sbb.rs) (Ping timeout: 258 seconds)
[05:11:58] *** Joins: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d)
[05:13:54] <nij-> Ok.. it didn't work for me. Nevermind.
[05:16:58] *** Quits: makomo (~makomo@user/makomo) (Ping timeout: 240 seconds)
[05:18:00] *** Quits: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d) (Ping timeout: 272 seconds)
[05:18:59] *** Quits: lotuseater (~user@p200300e7871b3f008a69ffac690ca7c7.dip0.t-ipconnect.de) (Quit: ERC (IRC client for Emacs 27.2))
[05:21:30] *** Quits: dlowe (~dlowe@user/dlowe) (Remote host closed the connection)
[05:44:00] *** Joins: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d)
[05:54:39] *** Joins: taiju (~taiju@61.127.163.30)
[05:59:02] *** Quits: taiju (~taiju@61.127.163.30) (Ping timeout: 258 seconds)
[06:00:13] *** Joins: taiju (~taiju@61.127.163.30)
[06:04:47] *** Quits: taiju (~taiju@61.127.163.30) (Ping timeout: 258 seconds)
[06:09:23] *** Quits: dsk (~dsk@user/dsk) (Ping timeout: 258 seconds)
[06:12:29] *** Quits: derelict (~derelict@user/derelict) (Quit: WeeChat 3.2)
[06:13:56] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[06:17:49] *** Quits: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d) (Ping timeout: 258 seconds)
[06:28:31] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[06:44:41] *** Joins: lisp123 (~lisp123@5.30.23.247)
[06:49:17] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 250 seconds)
[06:52:12] *** Joins: derelict (~derelict@user/derelict)
[06:58:02] *** Joins: prxq (~quassel@x4db65406.dyn.telefonica.de)
[07:01:54] *** Quits: prxq_ (~quassel@x4dbeabef.dyn.telefonica.de) (Ping timeout: 252 seconds)
[07:31:54] <beach> Good morning everyone!
[07:36:26] *** Joins: pillton (~user@2405:b000:600:b0::36a)
[07:47:47] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Ping timeout: 250 seconds)
[07:54:06] *** Quits: Bike (~Glossina@71.69.170.70) (Quit: sleepin')
[07:59:48] *** Joins: duber (~user@65.79.128.64)
[08:08:42] *** Joins: char (~Srain@cpe-76-186-124-165.tx.res.rr.com)
[08:12:49] *** Quits: nij- (~jin@2001-48F8-9021-806-0-0-0-1AD1-dynamic.midco.net) (Quit: Using Circe, the loveliest of all IRC clients)
[08:14:03] *** Joins: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d)
[08:22:41] <gendl> Morning beach.
[08:23:28] <gendl> does CL support having a hash table with custom equality predicate?
[08:23:50] <beach> Not the standard, no.
[08:24:12] <moon-child> (though you can obviously support such a feature if you make your own hash table)
[08:24:14] *** Quits: djuber` (~user@65.79.128.64) (Quit: ERC (IRC client for Emacs 28.0.50))
[08:25:13] <gendl> is it hard to make your own hash table? Would I find examples of such things on quicklisp? (cl-containers?)
[08:26:02] <beach> gendl: I think hayley is the expert on this topic.
[08:26:54] * moon-child waits to hear extolled the virtues of NonBlockingHashMap :)
[08:27:00] <beach> gendl: hayley is the one who implemented the SICL hash tables, and the one who studied different kinds of implementations, including lock-free hash tables, like the one by Cliff Click.
[08:27:24] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 256 seconds)
[08:28:30] <beach> gendl: If you need very good performance, it can be tricky, otherwise, it is pretty straightforward.
[08:29:12] <beach> gendl: You need to come up with a hash function that works for the equality predicate you have in mind, so that if two keys are equal according to that predicate, they also have the same hash value.
[08:29:36] <mfiano> gendl: Have you seen this? https://github.com/metawilm/cl-custom-hash-table
[08:29:58] <gendl> mfiano: i hadn't, thanks!
[08:30:16] <mfiano> It's a portability library since some implementations allow non-standard tests and hash functions
[08:30:27] <mfiano> Also has a fallback case for others
[08:30:38] <mfiano> (I haven't used it, just remember seeing it at some point)
[08:30:57] <gendl> beach: got it. I'm trying to key on 3d points which are vectors of double-float numbers.
[08:31:17] <mfiano> Use #'equalp
[08:31:21] <gendl> equality is tested by a coincident-point? function which compares the x y z values within an epsilon
[08:31:26] <mfiano> Oh
[08:31:59] <moon-child> also equalp will be slower than a function which knows to just check (aref x 0/1/2)
[08:32:19] <mfiano> gendl: side note, are you using absolute tolerance for that test?
[08:32:20] <moon-child> gendl: you will have difficulty generating a hash function which works correctly
[08:32:39] <moon-child> because equality wrt your predicate is not transitive
[08:33:30] <moon-child> gendl: rather than a hash table, I expect you want an octree
[08:34:14] <gendl> mfiano: absolute tolerance, yes i think so. We just check if the diff between the num and the other num is less than a given epsilon or not.  The epsilon is set by default with a global parameter but you can pass in your own as a key argument to coincident-point?
[08:34:47] <gendl> moon-child: I suspected this would be tricky to do with a straight up hash table.
[08:35:06] <moon-child> not just tricky, not well defined
[08:35:24] <moon-child> what if your hash table contains points x and y, which are not equal.  YOu want to key a point z, but z is equal to both x and y?
[08:35:34] <gendl> well, tricky to get behaving as desired maybe
[08:36:00] <mfiano> gendl: I would highly recommend reading this as a brief overview of why that is a bad idea: https://realtimecollisiondetection.net/blog/?p=89 and this for a longer discussion https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
[08:36:07] <moon-child> incidentally, if tolerance is set by a global parameter, why not simply rebind that before calling coincident-point?
[08:36:14] <gendl> moon-child: that is a good thought experiment
[08:36:16] <moon-child> having it as a key argument seems redundant
[08:36:19] <gendl> and i don't have a good answer
[08:37:32] <gendl> this stuff is modeled after stuff from the ICAD days and they never taught dynamic scope to their users
[08:37:42] <gendl> so they put key arguments on functions like this
[08:38:02] <mfiano> tl;dr, it is much more robust to combine absolute and relative tolerance testing
[08:38:18] <gendl> so we do the same for compatibility to legacy code from circa 1992
[08:39:02] <gendl> mfiano: i'm scared to read the thing about comparing floating point numbers
[08:39:15] <mfiano> tldr2: (< (abs (- x y)) (max abs (* rel (max (abs x) (abs y)))))
[08:39:27] <mfiano> Use that and profit
[08:39:43] <gendl> 😃🙃
[08:39:56] <gendl> got it
[08:39:57] <mfiano> oops
[08:40:05] <mfiano> that has a symbol macro in it
[08:40:06] <mfiano> one sec
[08:41:46] <mfiano> oh no, rel and abs vars are the relative and absolute tolerances, signature being (x y &key (rel +some-epsilon+) (abs rel))
[08:41:56] <gendl> ok
[08:42:46] <mfiano> basically absolute tolerance tets fails when the magnitude of the nums is large, and relative when they are too small
[08:43:05] <mfiano> so combining them, and giving the user the option to fine-tune both epsilons is the right way
[08:43:47] <mfiano> I know this was a tangent, but I am sort of obsessed with numerical stability
[08:43:59] <mfiano> sorry :)
[08:44:33] <gendl> it's a worthy obsession
[08:48:56] *** Quits: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d) (Ping timeout: 256 seconds)
[09:01:17] *** Joins: Fare (~fare@2601:184:4a7f:995c:5bed:587d:781c:2ba)
[09:03:32] *** Joins: dsk (~dsk@user/dsk)
[09:21:28] *** Joins: rain3 (~rain3___@79.115.250.43)
[09:22:19] *** Joins: ahc (~ahc@121.98.229.241)
[09:26:58] *** Quits: Fare (~fare@2601:184:4a7f:995c:5bed:587d:781c:2ba) (Ping timeout: 240 seconds)
[09:34:02] *** Quits: ggoes (~gregf@fsf/staff/ggoes) (Quit: WeeChat 2.3)
[09:40:12] *** Joins: Fare (~fare@2601:184:4a7f:995c:81ed:c77f:410:aac)
[09:47:44] *** Joins: ggoes (~gregf@fsf/staff/ggoes)
[09:48:42] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[09:50:34] <mfiano> Has anyone played with https://github.com/alex-gutev/static-dispatch before?
[09:50:52] <mfiano> The documentation mentions type dispatching everywhere, and I'm not sure if it means class/type or arbitrary types. I am guessing the former, or method-lambda-lists would be wrong unless the user created atomic type specifier aliases for complex types.
[09:50:58] *** Quits: dsk (~dsk@user/dsk) (Ping timeout: 240 seconds)
[09:51:11] <mfiano> I only ask because the specialization-store library dispatches on actual types. I'm familiar with the latter, but there are some aspects of the former I like better, and would like to know if it works for arbitrary types or just class/eql as with standard method dispatch.
[09:52:58] *** Quits: Fare (~fare@2601:184:4a7f:995c:81ed:c77f:410:aac) (Ping timeout: 256 seconds)
[09:54:31] *** Joins: selwyn (~selwyn@user/selwyn)
[09:56:05] <mfiano> Nevermind. I should have read the very last line of the README: "Enhance generic functions to allow for specialization on all types rather than just classes."
[10:16:27] *** Joins: retropikzel (~retropikz@2001:999:200:1f35:ae12:3ff:fe96:9d08)
[10:16:37] <hayley> moon-child: https://i.redd.it/40mor19n2wt61.png
[10:16:38] *** Quits: vats (~vats@103.70.83.249) (Ping timeout: 258 seconds)
[10:17:03] *** Joins: kakuhen (~kakuhen@user/kakuhen)
[10:17:08] <hayley> From memory, hash tables with custom tests and hash functions on SBCL are considerably slower than with inbuilt test functions. Not exactly sure why; maybe they can't inline something.
[10:19:06] <moon-child> haha
[10:21:59] <hayley> I can complain about the bad things about NonBlockingHashMap still. Relative to a non-synchronised hash table, the ideal load factor is miserable (like 0.25 or so), and it doesn't properly remove keys from the table without performing a "resize", so you either copy more often or have a poor probe length.
[10:22:48] <hayley> 42nd at Threadmill kind of improved on it, as you can cheat death by using SIMD to probe faster, and thus have longer probe lengths, but at the cost of false sharing which completely destroys performance on a NUMA system.
[10:26:37] <moon-child> huh, really?  I don't know very much about the topic, but I thought numa was about putting larger-scale allocations (at least hw page size, of necessity) on memory that's physically closer to a core that accesses it
[10:26:39] *** Joins: notzmv- (~zmv@user/notzmv)
[10:27:02] <moon-child> whereas simd ops are 64 bytes max (and self-aligned), so you would never cross a page that way?
[10:27:30] <hayley> Well, that was my conclusion after testing on a two-socket computer (10 cores/20 threads per socket).
[10:28:16] <hayley> Say we had a table which was just a vector of key and value words. Then, for 64 byte cache lines, we would fit 4 mappings per cache line.
[10:29:13] <hayley> I used a trick by Matt Kulukundis which was implemented in Abseil's flat_hash_map; you keep a partial hash vector with one byte of each hash. That table fits 64 mappings per cache line.
[10:30:17] <hayley> My understanding is that there would be like 16× more contention with that partial hash vector, and it is very slow on a dual-socket machine.
[10:31:30] *** Quits: notzmv- (~zmv@user/notzmv) (Ping timeout: 272 seconds)
[10:31:35] <moon-child> oh--right, of course.  I understand
[10:33:13] <hayley> But if you write very rarely, it does go like 30% faster than NonBlockingHashMap, which is probably useful for someone.
[10:34:19] <moon-child> at some point, if your wries are rare enough you may be better off with locks
[10:34:28] <moon-child> (unless you expect your writes to be clustered when they do happen)
[10:35:23] <hayley> As per the image, I still think it is a big win even over a readers-writer lock (or sharded RW locks) to do no synchronisation to read.
[10:35:25] *** Quits: akoana (~ah@user/akoana) (Quit: leaving)
[10:38:17] *** Joins: amb007 (~a_bakic@cable-94-189-183-212.dynamic.sbb.rs)
[10:44:37] *** Joins: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d)
[10:46:36] *** Joins: lisp123 (~lisp123@5.30.23.247)
[10:51:43] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 268 seconds)
[10:55:45] *** Joins: Lord_of_Life_ (~Lord@user/lord-of-life/x-2819915)
[10:55:52] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 256 seconds)
[10:56:59] *** Lord_of_Life_ is now known as Lord_of_Life
[11:00:13] *** Joins: pve (~pve@87-93-146-138.bb.dnainternet.fi)
[11:13:07] <pjb> That said, the way hash-tables are specified in CL hints at some implementation choices that should give good performance even with a "naive" implementation. The main problem actually is to have a good hash function.  The way CL hash-tables are specified (with thresholds for resizing) imply that you don't need buckets.
[11:14:21] <mfiano> Can someone with an SBCL handy try to reproduce a failure I'm getting here with some test code?
[11:14:24] <pjb> This also gives an opportunity to implementation to use perfect hash functions, in case the hash-table won't be further modified.
[11:14:44] <pjb> mfiano: http://ideone.com has a sbcl.
[11:15:39] <mfiano> Does it allow network (quicklisp)?
[11:15:41] <pjb> mfiano: https://ideone.com/WLfxNa
[11:15:49] <pjb> I don't think so.
[11:15:52] <mfiano> https://gist.github.com/mfiano/f7533183d539a1a3cfc09e5839da2e41
[11:16:00] <mfiano> I am wondering why #'test fails here
[11:16:10] <mfiano> (to compile, that is)
[11:19:26] <pjb> 1- asd file, or use (eval-when (:compile-toplevel :load-toplevel :execute) (ql:quickload :static-dispatch))
[11:19:47] <pjb> 2- defgeneric: ;   No generic function present when encountering a defmethod for elt. Assuming it will be an instance of standard-generic-function. ;   No generic function present when encountering a defmethod for (setf elt). Assuming it will be an instance of standard-generic-function.
[11:19:47] <pjb>  
[11:20:03] <pve> mfiano: it compiles on my setup
[11:20:09] <pjb> Funny, you have them…
[11:20:15] <mfiano> ; caught ERROR:
[11:20:17] <mfiano> ;   don't know how to dump #<STANDARD-METHOD ORIGIN2::ELT (AGGREGATE T) {1001B46923}> (default MAKE-LOAD-FORM method called).
[11:20:26] <pjb> and 3- ;   In origin2::test: Undefined function origin2::elt
[11:20:31] <pjb> (in ccl); now trying sblc.
[11:21:15] <pjb> Oh, I assume it's not cl:defgeneric cl:defmethod; then indeed, check the expansions, you can report a bug to static-dispatch.
[11:21:47] <mfiano> Correct, it's not
[11:23:52] <pjb> without conditions muffled, sbcl also reports: ; in: defun test     (ORIGIN2::ELT ORIGIN2::A 2)
[11:23:52] <pjb> ; caught style-warning:   undefined function: origin2::elt
[11:23:52] <pjb> ; compilation unit finished   Undefined function:     elt
[11:23:52] <pjb>  
[11:24:34] <mfiano> Yeah it's seeming like a bug in static-dispatch, but I'm not sure how the tests even pass
[11:24:48] <mfiano> This was the first, very basic example of me trying to use it!
[11:24:57] <mfiano> Also tried HEAD
[11:26:57] <pjb> The expansions contains sbcl-specific stuff on sbcl; it uses a compiler-macro, so it could be faily conforming instead.
[11:30:18] *** Quits: duber (~user@65.79.128.64) (Ping timeout: 240 seconds)
[11:31:28] <mfiano> Bug reported, thanks
[11:38:37] *** Joins: gaqwas (~john@dynamic-095-118-100-133.95.118.pool.telefonica.de)
[11:38:59] <mfiano> Side note, this is why I try to stay away from these libraries (specialization-store, inlined-generic-functions, and a few others). They have always failed in mysterious ways on random Quicklisp/implementation upgrades, and due to their complexity it's very hard to track down the blame on the library or the implementation, not to mention fixing it locally.
[11:39:17] <mfiano> I decided to try this one because it had a feature I was interested in. Not worth the hassle :)
[11:48:21] *** Joins: lisp123 (~lisp123@5.30.23.247)
[11:52:51] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 258 seconds)
[11:56:58] *** Joins: lisp123 (~lisp123@5.30.23.247)
[12:03:58] *** Quits: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d) (Ping timeout: 258 seconds)
[12:05:51] *** Joins: makomo (~makomo@user/makomo)
[12:14:31] *** Joins: vats (~vats@103.70.83.249)
[12:18:30] *** Joins: dsk (~dsk@user/dsk)
[12:19:25] *** Joins: jimka (~user@2a01:e0a:26a:f400:914e:da8c:37da:fc42)
[12:25:07] *** Quits: jimka (~user@2a01:e0a:26a:f400:914e:da8c:37da:fc42) (Ping timeout: 250 seconds)
[12:34:39] *** Joins: sm2n_ (~sm2n@user/sm2n)
[12:34:53] *** Quits: mister_m (~user@c-73-110-154-209.hsd1.il.comcast.net) (Remote host closed the connection)
[12:35:09] *** Joins: mister_m (~user@c-73-110-154-209.hsd1.il.comcast.net)
[12:35:18] *** Joins: djuber` (~user@65.79.128.64)
[12:35:36] *** Quits: copec (~copec@home.unaen.org) (Ping timeout: 256 seconds)
[12:36:10] *** Quits: pieguy128 (~pieguy128@bras-base-mtrlpq5031w-grc-57-65-92-163-194.dsl.bell.ca) (Ping timeout: 256 seconds)
[12:36:25] *** Joins: hendursa1 (~weechat@user/hendursaga)
[12:36:28] *** Joins: pieguy128 (~pieguy128@bas1-montreal02-65-92-163-194.dsl.bell.ca)
[12:36:44] *** Quits: deckard (~deckard@ec2-3-129-211-221.us-east-2.compute.amazonaws.com) (Ping timeout: 252 seconds)
[12:36:48] *** Joins: deck4rd (~deckard@ec2-3-129-211-221.us-east-2.compute.amazonaws.com)
[12:36:56] *** Joins: copec (~copec@home.unaen.org)
[12:37:18] *** Quits: djuber (~user@65.79.128.64) (Ping timeout: 256 seconds)
[12:37:18] *** Quits: sm2n (~sm2n@user/sm2n) (Ping timeout: 256 seconds)
[12:38:42] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 244 seconds)
[12:42:34] *** Joins: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d)
[12:48:26] *** Quits: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d) (Ping timeout: 258 seconds)
[12:48:42] *** Joins: asarch (~asarch@2806:10ae:7:6d3f:2629:fba:30a3:e233)
[12:50:29] <asarch> How do you "break" a loop? E.g. (loop while result do (setf result (some-query)) (when (string= result 'foo') break))?
[12:50:37] <phoe> do (loop-finish)
[12:50:51] <asarch> Thank you!
[12:56:09] <moon-child> you can also do (loop while result do (whatever) until (string= result "foo"))
[12:56:31] <moon-child> also consider the difference between loop-finish and returhn
[12:57:02] <asarch> ?
[12:57:03] *** Joins: shka (~herr@109.231.62.239)
[13:01:16] *** Joins: elf_fortrezz (~elf_fortr@adsl-72-50-6-19.prtc.net)
[13:14:34] *** Joins: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d)
[13:17:34] *** Joins: rgherdt_ (~rgherdt@ip5f5af446.dynamic.kabel-deutschland.de)
[13:20:32] *** Quits: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d) (Ping timeout: 245 seconds)
[13:32:31] *** Quits: pillton (~user@2405:b000:600:b0::36a) (Quit: ERC (IRC client for Emacs 27.2))
[13:35:12] *** Joins: cage (~cage@dynamic-adsl-78-15-36-212.clienti.tiscali.it)
[13:38:57] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[13:39:33] *** Joins: lisp123 (~lisp123@5.30.23.247)
[13:44:40] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 272 seconds)
[13:45:07] *** Quits: vats (~vats@103.70.83.249) (Ping timeout: 245 seconds)
[13:46:39] *** Joins: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d)
[13:50:11] *** Joins: lisp123 (~lisp123@5.30.23.247)
[13:50:24] *** Quits: rgherdt_ (~rgherdt@ip5f5af446.dynamic.kabel-deutschland.de) (Ping timeout: 256 seconds)
[14:10:56] *** Quits: asarch (~asarch@2806:10ae:7:6d3f:2629:fba:30a3:e233) (Quit: Leaving)
[14:13:16] *** Quits: elf_fortrezz (~elf_fortr@adsl-72-50-6-19.prtc.net) (Quit: Client closed)
[14:16:25] *** Joins: elf_fortrezz (~elf_fortr@adsl-72-50-4-51.prtc.net)
[14:16:54] *** Quits: elf_fortrezz (~elf_fortr@adsl-72-50-4-51.prtc.net) (Client Quit)
[14:17:10] *** Joins: elf_fortrez (~elf_fortr@adsl-72-50-4-51.prtc.net)
[14:20:26] *** Quits: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d) (Ping timeout: 256 seconds)
[14:24:08] *** Quits: kakuhen (~kakuhen@user/kakuhen) (Quit: Leaving...)
[14:27:48] <lisp123> These continuation passing macros...how much do they slowdown code? As they are macros, hopefully not by too much?
[14:28:59] <hayley> They have some slowdown, as splitting things into multiple functions tends to limit optimisations in various ways.
[14:38:03] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[14:38:45] *** Joins: lisp123 (~lisp123@5.30.23.247)
[14:39:34] *** Joins: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d)
[14:40:21] *** Joins: random-nick (~random-ni@87.116.181.197)
[14:43:02] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 245 seconds)
[14:44:35] *** Quits: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d) (Ping timeout: 258 seconds)
[14:48:25] *** Quits: elf_fortrez (~elf_fortr@adsl-72-50-4-51.prtc.net) (Ping timeout: 246 seconds)
[14:55:06] *** Joins: lisp123 (~lisp123@5.30.23.247)
[14:55:13] <lisp123> hayley: thanks, that makes sense
[15:01:09] *** Joins: nature (~nature@mail.blazebone.com)
[15:16:03] *** Quits: frgo (~frgo@p200300deef181d00f162dfaf18093baa.dip0.t-ipconnect.de) (Remote host closed the connection)
[15:16:29] *** Joins: frgo (~frgo@p200300deef181d00f162dfaf18093baa.dip0.t-ipconnect.de)
[15:22:32] *** Quits: nature (~nature@mail.blazebone.com) (Ping timeout: 258 seconds)
[15:22:47] *** Quits: dsk (~dsk@user/dsk) (Ping timeout: 250 seconds)
[15:33:07] *** Joins: Krystof (~user@81.174.155.115)
[15:33:57] *** Joins: dlowe (~dlowe@user/dlowe)
[15:34:48] <pjb> lisp123: the point here is that a compiled that natively works with continuation will naturally optimize continuations and continuation passing style code.  But this is not what CL compilers optimize for.  You may count on CL compilers to optimize for closures (lambda), and some for tail calls, notably recursive tail calls (but compromises with the optiomization of dynamic variables and other dynamic bindings have to be done).
[15:35:28] <pjb> lisp123: so yes, you can write code using continuation passing style macros, but this won't necessarily be the best match for the optimization your compiler has implemented.
[15:36:09] <pjb> lisp123: this is not the reason why you would use a different style; you will choose a style to optimize the programmer's time! If you have a solution that is more elegantly written and understood in continuation passing, then you should definitely write it using them!
[15:36:38] <pjb> lisp123: see: http://cliki.net/Performance  People often forget the first sectioN!
[15:37:49] *** Joins: rgherdt_ (~rgherdt@ip5f5af446.dynamic.kabel-deutschland.de)
[15:42:12] <lisp123> pjb: thanks
[15:43:31] <lisp123> pjb: Yes for now, continuations seem helpful - and I plan to worry about any optimisations much down the track. Its an interesting topic for sure
[15:43:42] *** Quits: santiagopim (~user@90.166.59.133) (Remote host closed the connection)
[15:44:11] <lisp123> Wonder if anyone has read this one: https://arxiv.org/pdf/1510.03057.pdf
[15:46:24] <pjb> Interesting. I will.
[15:47:37] <mfiano> Oh, another Lisp constraint programming paper. Yay
[15:48:00] <pjb> But applied to IRCAM Open Music system.
[15:48:59] <mfiano> Even still, I like reading about propagation networks, constraint solvers and related AI.
[15:50:01] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[15:50:24] <mfiano> Reminds me to polish up my WFC algorithm and release it some time :/
[15:51:33] *** Joins: vats (~vats@103.70.83.249)
[15:52:18] *** Joins: santiagopim (~user@90.166.59.133)
[15:56:41] <mfiano> The typesetting really messed up the CL indentation in that paper :(
[16:00:28] *** Joins: lisp123_ (~lisp123@45.130.83.208)
[16:00:59] <lisp123_> mfiano: yeah it did. I was hoping for more CL code than it had but perhaps the devils in the detail - will read through it more carefully rather than skimming
[16:03:34] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[16:10:39] *** Joins: lotuseater (~user@p200300e7871b3f008a69ffac690ca7c7.dip0.t-ipconnect.de)
[16:22:12] *** Quits: lisp123_ (~lisp123@45.130.83.208) (Remote host closed the connection)
[16:24:08] *** Joins: Melantha (~pyon@user/pyon)
[16:36:05] *** Joins: nij- (~jin@2001-48F8-9021-806-0-0-0-1AD1-dynamic.midco.net)
[16:38:47] <nij-> I'm deeply amazed by April. Anyone has used that before? https://github.com/phantomics/april
[16:39:27] <phantomics>  Thanks nij-
[16:39:43] <nij-> Oh author here! Thanks too!
[16:40:08] <nij-> It implements a part of Dyalog. But is it a proper subset? Or does it have a breaking change?
[16:40:25] *** Joins: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d)
[16:40:51] <nij-> I'm not familiar with APL at all, and would like to take this chance to start learning. I'd like to know how it differs..
[16:41:32] <phantomics> It's not intended as a subset of Dyalog, its functions and operators are mostly patterned after Dyalog. It has several differences from Dyalog. For example, it has no guards, rather implementing k-style if statements with $[ ... ]
[16:42:42] <phantomics> Because it is a compiler, April needs to know if the operands in a user-defined operator are functions or values. ⍺⍺ and ⍵⍵ denote function operands, ⍶ and ⍹ denote value operands
[16:44:23] <phantomics> Those are the main changes you need to make to code when porting it from Dyalog. Also, because of the way it works as a compiler, the definition of a function in April always needs to come before its use. That's another gotcha
[16:45:18] <phantomics> But overall if you learn how the functions and operators work in Dyalog 99% of that knowledge carries over to April
[16:46:11] <phantomics> Dyalog has many, many more system functions than April does though, April assumes that you'll do stuff like filesystem interaction through CL and then feed the results into April
[16:51:30] *** Quits: amb007 (~a_bakic@cable-94-189-183-212.dynamic.sbb.rs) (Ping timeout: 252 seconds)
[16:52:51] *** Joins: amb007 (~a_bakic@109.245.227.78)
[16:53:42] *** Joins: nirnam (~nirnam@1.47.28.235)
[16:54:12] *** Joins: yitzi (~yitzi@173-27-106-188.client.mchsi.com)
[16:54:56] <nij-> Wow, 99% is very good! Is there a spec (or will there be) written for April?
[16:57:18] <nij-> phantomics: By the way, do you use it often with Lisp? I imagine I can leverage its terse-ness and blend it with Lisp. Not sure how practical it would be.
[16:58:10] *** Joins: Fare (~fare@2601:184:4a7f:995c:5a5b:d213:452e:1a55)
[16:58:27] *** Joins: lisp123 (~lisp123@45.130.83.208)
[17:01:04] <phantomics> I use it constantly with Lisp, April was designed to be integrated into Lisp code. I'd like to get an April REPL mode working through Emacs sometime but for now you have to invoke it through CL. The arrays April outputs are regular Lisp arrays that you can process with Lisp's array tools, it's very seamless compared to something like NumPy
[17:02:17] <phantomics> There isn't a written spec for April yet outlining all the functions, but you can read the Dyalog APL manual to see how the functions work, knowing April's work the same way. http://docs.dyalog.com/18.0/Dyalog%20APL%20Language%20Reference%20Guide.pdf
[17:02:53] <phantomics> However, April does have a spec of sorts in the spec.lisp file, the top-level language definition is in that file and it lists each function and operator
[17:02:56] <lotuseater> nij-: I now also used it a bit.
[17:03:18] <phantomics> You can also evaluate (april (demo)) to see demos of all the functions based on the unit tests, that will give you an idea of how they work
[17:08:43] *** Quits: lisp123 (~lisp123@45.130.83.208) (Ping timeout: 258 seconds)
[17:11:22] *** Joins: lisp123 (~lisp123@45.130.83.208)
[17:12:26] *** Joins: notzmv (~zmv@user/notzmv)
[17:14:58] *** Quits: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d) (Ping timeout: 256 seconds)
[17:17:03] <nij-> Very exciting!
[17:17:04] *** Quits: amb007 (~a_bakic@109.245.227.78) (Read error: Connection reset by peer)
[17:17:12] *** Joins: amb007 (~a_bakic@87.116.160.211)
[17:17:17] <nij-> lotuseater: Good to know that too! :)
[17:17:33] <lotuseater> yes as you asked and I read that
[17:17:39] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 276 seconds)
[17:18:24] <lotuseater> You could also have an interesting read by Iversons paper "Notation as a Tool of Thought"
[17:27:04] *** Joins: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d)
[17:29:00] <nij-> Hopefully this can extend my arsenal of notations too. I long complain about the lack of alphabets in math and physics.
[17:31:21] <lotuseater> I think it heavily depends on how ones brain is wired.
[17:41:02] *** Quits: amb007 (~a_bakic@87.116.160.211) (Ping timeout: 256 seconds)
[17:41:53] *** Joins: amb007 (~a_bakic@cable-94-189-183-212.dynamic.sbb.rs)
[18:00:51] *** Quits: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d) (Ping timeout: 258 seconds)
[18:09:12] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[18:12:18] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 240 seconds)
[18:14:54] <lisp123> In the form, (+ 1 (+ 2 (+3 4), the ___ in (+ 1 ___) is not a tail call, correct?
[18:15:58] <hayley> .oO( READER-ERROR: Comma not in a backquote. )
[18:16:22] <hayley> Only the outer-most call to + would be a tail call, yes.
[18:17:01] <lisp123> Thanks!
[18:22:03] *** Quits: hendursa1 (~weechat@user/hendursaga) (Quit: hendursa1)
[18:22:28] *** Joins: hendursaga (~weechat@user/hendursaga)
[18:24:41] *** Joins: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d)
[18:26:47] *** Quits: Fare (~fare@2601:184:4a7f:995c:5a5b:d213:452e:1a55) (Ping timeout: 245 seconds)
[18:28:05] *** Quits: yitzi (~yitzi@173-27-106-188.client.mchsi.com) (Read error: Connection reset by peer)
[18:28:48] *** Joins: Bike (~Bike@71.69.170.70)
[18:28:48] *** ChanServ sets mode: +o Bike
[18:34:41] <beach> lisp123: The rules for function application in Common Lisp is that the arguments are evaluated before the function is applied.  And tail position means that the computation is finished when the form in the tail position has been evaluated.  But since the function + has not been applied yet, then the argument is not in tail position.
[18:41:52] *** Quits: rgherdt_ (~rgherdt@ip5f5af446.dynamic.kabel-deutschland.de) (Ping timeout: 258 seconds)
[18:42:37] *** Joins: yitzi (~yitzi@173-27-106-188.client.mchsi.com)
[18:43:22] *** Quits: lisp123 (~lisp123@45.130.83.208) (Remote host closed the connection)
[18:44:04] *** Joins: lisp123 (~lisp123@45.130.83.208)
[18:44:52] *** Quits: lisp123 (~lisp123@45.130.83.208) (Remote host closed the connection)
[18:44:56] *** Quits: vats (~vats@103.70.83.249) (Ping timeout: 258 seconds)
[18:45:04] *** Joins: lisp123 (~lisp123@45.130.83.208)
[18:46:26] <lisp123> beach: thanks
[18:47:36] <beach> Sure.
[18:54:09] *** Quits: MichaelRaskin (~MichaelRa@ipb21b6221.dynamic.kabel-deutschland.de) (Ping timeout: 252 seconds)
[18:57:23] *** Joins: MichaelRaskin (~MichaelRa@ipb21b6221.dynamic.kabel-deutschland.de)
[18:57:23] *** ChanServ sets mode: +o MichaelRaskin
[18:57:58] *** Quits: lisp123 (~lisp123@45.130.83.208) (Remote host closed the connection)
[18:58:27] *** Quits: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d) (Ping timeout: 245 seconds)
[19:02:30] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[19:05:47] *** Joins: lisp123 (~lisp123@45.130.83.208)
[19:07:25] <jcowan> The forms in a function call are never in tail position, although in Scheme the first argument to eval and apply are treated as if they were.
[19:11:34] *** Joins: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d)
[19:12:18] *** Quits: Josh_2 (~user@37.25.47.130) (Quit: ERC (IRC client for Emacs 27.1))
[19:13:24] *** Quits: amb007 (~a_bakic@cable-94-189-183-212.dynamic.sbb.rs) (Ping timeout: 256 seconds)
[19:13:45] *** Joins: amb007 (~a_bakic@cable-94-189-183-212.dynamic.sbb.rs)
[19:16:05] *** Quits: lisp123 (~lisp123@45.130.83.208) (Remote host closed the connection)
[19:17:33] *** Joins: lisp123 (~lisp123@45.130.83.208)
[19:18:17] *** Quits: amb007 (~a_bakic@cable-94-189-183-212.dynamic.sbb.rs) (Ping timeout: 258 seconds)
[19:18:53] *** Joins: amb007 (~a_bakic@109.245.227.78)
[19:21:00] *** Quits: lisp123 (~lisp123@45.130.83.208) (Read error: Connection reset by peer)
[19:28:45] *** Joins: lisp123 (~lisp123@45.130.83.208)
[19:35:32] *** Quits: lisp123 (~lisp123@45.130.83.208) (Ping timeout: 272 seconds)
[19:36:45] *** Joins: duber (~user@65.79.128.64)
[19:42:48] *** Joins: lisp123 (~lisp123@45.130.83.208)
[19:45:30] *** Quits: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d) (Ping timeout: 258 seconds)
[19:47:24] *** Quits: lisp123 (~lisp123@45.130.83.208) (Ping timeout: 256 seconds)
[19:56:26] *** Joins: lisp123 (~lisp123@45.130.83.208)
[20:00:59] *** Quits: lisp123 (~lisp123@45.130.83.208) (Ping timeout: 250 seconds)
[20:08:30] *** Joins: lisp123 (~lisp123@45.130.83.208)
[20:11:40] *** Joins: selwyn (~selwyn@user/selwyn)
[20:12:59] *** Quits: lisp123 (~lisp123@45.130.83.208) (Read error: Connection reset by peer)
[20:29:04] *** Quits: retropikzel (~retropikz@2001:999:200:1f35:ae12:3ff:fe96:9d08) (Quit: Leaving)
[20:41:37] *** Joins: lisp123 (~lisp123@45.130.83.208)
[20:43:05] *** Joins: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d)
[20:43:26] *** Joins: vats (~vats@103.70.83.249)
[20:47:37] *** Quits: cpape` (~user@2a01:4f9:c010:632d::1) (Remote host closed the connection)
[20:47:51] *** Joins: cpape` (~user@2a01:4f9:c010:632d::1)
[20:48:36] *** Quits: duber (~user@65.79.128.64) (Ping timeout: 256 seconds)
[20:49:38] *** Quits: skyl4rk (~tlvb@user/tlvb) (Ping timeout: 272 seconds)
[20:49:50] *** Quits: Colleen (~fermion@supersolid.equilibrium.tymoon.eu) (Read error: Connection reset by peer)
[20:50:04] *** Joins: Colleen (~fermion@supersolid.equilibrium.tymoon.eu)
[20:51:10] *** Joins: skyl4rk (~tlvb@user/tlvb)
[20:51:32] *** Quits: lisp123 (~lisp123@45.130.83.208) (Ping timeout: 272 seconds)
[20:57:55] *** Joins: jmhimara (~jmhimara@170.39.139.5)
[20:58:00] *** Quits: selwyn (~selwyn@user/selwyn) (Ping timeout: 276 seconds)
[20:58:53] *** Joins: jmhimara43 (~jmhimara@170.39.139.5)
[20:58:53] *** Quits: jmhimara43 (~jmhimara@170.39.139.5) (Client Quit)
[21:02:13] *** Quits: jmhimara (~jmhimara@170.39.139.5) (Ping timeout: 246 seconds)
[21:10:33] *** Quits: amb007 (~a_bakic@109.245.227.78) (Read error: Connection reset by peer)
[21:10:41] *** Joins: amb007 (~a_bakic@cable-94-189-183-212.dynamic.sbb.rs)
[21:14:59] *** Quits: yitzi (~yitzi@173-27-106-188.client.mchsi.com) (Remote host closed the connection)
[21:15:25] *** Joins: yitzi (~yitzi@173-27-106-188.client.mchsi.com)
[21:16:07] *** Quits: yitzi (~yitzi@173-27-106-188.client.mchsi.com) (Remote host closed the connection)
[21:18:04] *** Quits: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d) (Ping timeout: 256 seconds)
[21:18:28] *** Joins: lisp123 (~lisp123@45.130.83.208)
[21:19:57] <lisp123> jcowan: yes that makes sense and interesting note on scheme
[21:20:13] <lisp123> I am reading through this now: https://www.cs.rpi.edu/academics/courses/fall00/ai/scheme/reference/schintro-v14/schintro_127.html
[21:20:30] <lisp123> A nice introduction on scheme does it
[21:21:03] <jcowan> More explanations (unless outright wrong) are usually better.
[21:21:46] <lisp123> Yes, there's many different ways to look at it. Now am I am thinking for my own on what problem do continuations specifically solve
[21:22:19] <lisp123> Of course I know they are useful in stuff like multiple processes and nondeterminism, but going a bit deeper into specifically their benefit
[21:22:25] <jcowan> State machines, for one.
[21:23:17] <jcowan> In a typical language, a state machine is a big while-loop with a big case statement inside, and a variable that carries the state.
[21:23:20] <lisp123> For those interested, this is a useful read, but it's a bit beyond me for now: http://www.nhplace.com/kent/PFAQ/unwind-protect-vs-continuations-overview.html
[21:24:35] <jcowan> In Scheme, it's a bunch of definitions that tail-call one another to move to the next state, with no variable needed.  (They may still need a let-wrapper to carry other state-stuff than *the* state of the state machine.)
[21:25:17] <lisp123> jcowan: nice I haven't yet studied state machines
[21:26:24] <lisp123> jcowan: from what I understand, scheme will re-write your functions to be tail calls, whereas in CL one has to handle that part themselves (also the passing of continuations between functions) - is that your understanding?
[21:26:40] <jcowan> Yes, pretty much.
[21:26:56] <jcowan> And in almost all other languages (Haskell and ML have proper tail calling too).
[21:27:21] *** Joins: elf_fortrez (~elf_fortr@adsl-72-50-4-122.prtc.net)
[21:27:38] *** Joins: tfeb (~tfb@88.98.95.237)
[21:27:58] <lisp123> jcowan: Thanks :) It took me a good 1.5 hours to connect all the dots, it was an innocuous few words in PG's On Lisp ("if a ... occurs in a segment of code, it must be a tail call")
[21:28:23] *** Joins: selwyn (~selwyn@user/selwyn)
[21:28:38] <jcowan> I have *no* idea what that means, unless it refers to some drawing or other.
[21:29:05] <lisp123> just some continuous passing macros in the book, it requires one to organise all the functions as tail calls
[21:29:14] <mariari> with lazy ML's often tail calls aren't needed due to laziness often acting in it's place (not always)
[21:29:24] <jcowan> Yes.
[21:29:26] <lisp123> The importance of which I didn't understand after spending some time on it
[21:29:45] <lisp123> until after*
[21:30:26] <lisp123> mariari: that makes sense, but adding lazy evaluation to continuations definitely blows my mind :S :)
[21:30:47] <lisp123> But it completely makes sense (at least based on my superficial understanding)
[21:31:03] <mariari> haha. There are other evaluation strategies that don't care about tail calls at all
[21:31:18] <mariari> like optimal reductions also don't really care IIRC due to the nature of how reductions work
[21:32:10] <lisp123> do you have a link to that? google-fu didn't seem to return anything that seems related
[21:32:18] <lisp123> I would be curious to study those too
[21:32:18] *** Quits: skyl4rk (~tlvb@user/tlvb) (Ping timeout: 240 seconds)
[21:32:19] <mariari> yes there is an entire book
[21:33:45] *** Quits: froggey (~froggey@cpc96342-rdng26-2-0-cust314.15-3.cable.virginm.net) (Ping timeout: 276 seconds)
[21:33:56] <mariari> https://dl.acm.org/doi/10.5555/320040 I belive this is the book
[21:34:20] <mariari> should be 400 pages or so. But it uses interaction nets as the representation
[21:34:31] <lisp123> Thanks! I will read through it
[21:34:38] <mariari> note that some research has come out since to solve the major issue with this strategy though it requires you to be under elementary complexity
[21:34:55] <mariari> also no one has properly compiled this to a stack machine yet, though it is possible
[21:35:08] <mariari> so current models of this are actually slower than you'd like, but you do get optimal sharing
[21:35:25] <lisp123> I see. These are all interesting stuff, head scratching a bit ;)
[21:35:53] *** Joins: skyl4rk (~tlvb@user/tlvb)
[21:35:56] <mariari> it's fine the model itself is rather basic to write, just needs to wrap your head around it
[21:37:02] <lisp123> Yup. for now I need to write down everything about continuations before I forget it
[21:38:57] *** Joins: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d)
[21:39:21] *** Quits: tfeb (~tfb@88.98.95.237) (Quit: died)
[21:39:49] *** Joins: froggey (~froggey@cpc96342-rdng26-2-0-cust314.15-3.cable.virginm.net)
[21:39:49] *** Quits: SAL9000 (~SAL9000@shirakumo/sal9000) (Quit: router reboot :))
[21:44:41] <jcowan> State machines are like "Be in a state, read an input, decide based on the state and the input what state to go to.  You start in the start state and end in the end state.
[21:44:42] <jcowan> "
[21:45:06] *** Quits: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d) (Ping timeout: 258 seconds)
[21:45:15] <jcowan> It's a model of computation that is suprisingly powerful given its complexity.
[21:45:48] <jcowan> Regular expressions (without backtracking and such) can be computed by a state machine.
[21:51:32] <lotuseater> lisp123: did you already worked through chapter 20 of "On Lisp"?
[21:52:15] *** Quits: Bike (~Bike@71.69.170.70) (Quit: Connection closed)
[21:52:27] <lisp123> lotuseater: yeah, actually twice. I forgot it the first time (1 week ago), and now writing some notes so I don't forget again
[21:52:30] <jcowan> s/complexity/si,mplicity
[21:54:00] *** Quits: peterhil (~peterhil@dsl-hkibng32-54fb52-57.dhcp.inet.fi) (Ping timeout: 252 seconds)
[21:54:23] <lotuseater> I also found it a good complement to see how continuations work as monads, but I know I don't understand the concept in full upto now.
[21:54:45] <lisp123> Do you get it now?
[21:55:58] <lotuseater> read the sentence again :)
[21:57:55] <lisp123> English is an ambiguous language ;) It could mean you didn't understand the concept until now (but now do) or you didn't understand the concept up to the point in time which is now (and now don't)
[21:58:19] <lisp123> I presume the former though
[21:58:38] <lotuseater> yeah you're right
[21:58:50] <lisp123> Just wanted to be sure :D
[21:59:15] <lotuseater> No, this is one thing in a looong list of stuff and concepts I'm not yet aware of.
[21:59:18] <lotuseater> hehe okay
[21:59:39] <lotuseater> we could also query again or tomorrow if you want
[22:00:25] <lisp123> Oh so you still need to understand it?
[22:00:36] <lotuseater> of course
[22:00:56] <lotuseater> better as just to pretend to understand something for real
[22:05:47] *** Joins: yitzi (~yitzi@173-27-106-188.client.mchsi.com)
[22:09:36] *** Joins: Bike (~Bike@71.69.170.70)
[22:09:36] *** ChanServ sets mode: +o Bike
[22:10:22] *** Joins: attila_lendvai (~alendvai@C226779F.unconfigured.pool.telekom.hu)
[22:10:59] *** Joins: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d)
[22:11:58] *** Quits: attila_lendvai (~alendvai@C226779F.unconfigured.pool.telekom.hu) (Read error: Connection reset by peer)
[22:12:24] *** Joins: attila_lendvai (~alendvai@C226779F.nat.pool.telekom.hu)
[22:15:46] *** Quits: amb007 (~a_bakic@cable-94-189-183-212.dynamic.sbb.rs) (Ping timeout: 272 seconds)
[22:16:56] *** Joins: amb007 (~a_bakic@109.245.227.78)
[22:18:55] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Ping timeout: 244 seconds)
[22:18:55] *** Quits: amb007 (~a_bakic@109.245.227.78) (Read error: Connection reset by peer)
[22:20:41] *** Joins: amb007 (~a_bakic@109.245.227.78)
[22:22:34] *** Joins: SAL9000 (~SAL9000@shirakumo/sal9000)
[22:24:33] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[22:29:42] *** Quits: attila_lendvai (~alendvai@C226779F.nat.pool.telekom.hu) (Ping timeout: 245 seconds)
[22:40:45] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[22:45:09] *** Quits: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d) (Ping timeout: 252 seconds)
[22:45:38] *** Joins: cosimone (~user@93-34-133-3.ip49.fastwebnet.it)
[22:51:00] *** Quits: amb007 (~a_bakic@109.245.227.78) (Read error: Connection reset by peer)
[22:51:22] *** Joins: amb007 (~a_bakic@87.116.175.23)
[22:54:09] *** Quits: lisp123 (~lisp123@45.130.83.208) (Remote host closed the connection)
[22:54:46] *** Joins: lisp123 (~lisp123@45.130.83.208)
[22:58:22] *** Quits: amb007 (~a_bakic@87.116.175.23) (Ping timeout: 256 seconds)
[22:58:57] *** Joins: amb007 (~a_bakic@109.245.227.78)
[22:59:28] *** Quits: lisp123 (~lisp123@45.130.83.208) (Ping timeout: 258 seconds)
[23:00:13] <pjb> And note that since our computers have a finite memory size, they're not turing machines, but state machines!
[23:08:22] *** Quits: Bike (~Bike@71.69.170.70) (Quit: Connection closed)
[23:11:41] <Xach> enjoy a new quicklisp dist update this day
[23:14:34] <nij->  Thanks Xach! query-repl seems pretty cool :)
[23:15:44] <mfiano> I think I was the first one to pull it. I just so happened to check this month about 5 minutes before the announcement.
[23:17:31] *** Joins: lisp123 (~lisp123@45.130.83.208)
[23:18:20] *** Quits: lisp123 (~lisp123@45.130.83.208) (Remote host closed the connection)
[23:18:32] *** Joins: lisp123 (~lisp123@45.130.83.208)
[23:18:43] *** Quits: elf_fortrez (~elf_fortr@adsl-72-50-4-122.prtc.net) (Ping timeout: 246 seconds)
[23:18:43] *** Quits: amb007 (~a_bakic@109.245.227.78) (Read error: Connection reset by peer)
[23:19:55] *** Joins: selwyn (~selwyn@user/selwyn)
[23:20:34] *** Joins: amb007 (~a_bakic@109.245.227.78)
[23:21:18] *** Parts: nij- (~jin@2001-48F8-9021-806-0-0-0-1AD1-dynamic.midco.net) (Using Circe, the loveliest of all IRC clients)
[23:21:19] <lotuseater> pjb: good point :)
[23:22:54] *** Quits: froggey (~froggey@cpc96342-rdng26-2-0-cust314.15-3.cable.virginm.net) (Ping timeout: 272 seconds)
[23:27:14] <mfiano> Xach: Does Quicklisp keep metadata about which commit was pulled for vcs projects? Would be nice to have if not in the event the dist version matches the date latest commits were made to a project to know if I should manually clone.
[23:28:17] <mfiano> After some extra detective work I discovered I just missed the changes I was hoping for. Oh well
[23:29:07] *** Quits: lisp123 (~lisp123@45.130.83.208) (Remote host closed the connection)
[23:29:25] *** Joins: lisp123 (~lisp123@45.130.83.208)
[23:30:43] *** Joins: Bike (~Glossina@71.69.170.70)
[23:30:43] *** ChanServ sets mode: +o Bike
[23:34:21] *** Joins: froggey (~froggey@cpc96342-rdng26-2-0-cust314.15-3.cable.virginm.net)
[23:35:09] *** Joins: attila_lendvai (~alendvai@C226779F.nat.pool.telekom.hu)
[23:40:21] *** Quits: amb007 (~a_bakic@109.245.227.78) (Read error: Connection reset by peer)
[23:40:34] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[23:41:54] *** Joins: amb007 (~a_bakic@109.245.227.78)
[23:41:59] *** Joins: jimka (~user@2a01:e0a:26a:f400:c79:f12c:3584:a67d)
[23:44:18] *** Quits: rain3 (~rain3___@79.115.250.43) (Ping timeout: 240 seconds)
[23:49:10] *** Joins: jmhimara (~jmhimara@132.194.13.222)
[23:51:21] <Xach> mfiano: it doesn't, but that's a goal
[23:55:51] *** Quits: silasfox (~sbv@2001-4dd6-62dc-0-6027-7522-36-c7ab.ipv6dyn.netcologne.de) (Ping timeout: 250 seconds)
[23:56:01] <mfiano> I see
[23:56:33] *** Joins: lisp123_ (~lisp123@5.30.23.247)
[23:57:51] *** Joins: silasfox (~sbv@2001-4dd1-7b1c-0-5b98-b56f-27b-b4a7.ipv6dyn.netcologne.de)
