[00:08:55] *** Quits: mro (~mro@port-92-195-142-11.dynamic.as20676.net) (Remote host closed the connection)
[00:10:30] *** Joins: mro (~mro@port-92-195-142-11.dynamic.as20676.net)
[00:11:24] *** Quits: jlrnick (~josephler@2a01cb040a15940040f41e6f55014ce7.ipv6.abo.wanadoo.fr) (Ping timeout: 252 seconds)
[00:17:34] <d_bot> <VPhantom> Alright, `Uuseg` didn't hurt _too_ bad. ðŸ˜›
[00:17:59] <d_bot> <monk> solved this problem, i'm posting my solution over in #beginners for feedback on the solution in case anyone is interested
[00:20:27] *** Joins: rgrinberg (~textual@2806:101e:7:5da4:a506:183a:7675:98e5)
[00:38:20] *** Quits: Serpent7776 (~Serpent77@90-156-31-193.internetia.net.pl) (Quit: leaving)
[00:56:05] *** Joins: Tuplanolla (~Tuplanoll@91-159-69-98.elisa-laajakaista.fi)
[00:58:31] *** Quits: mro (~mro@port-92-195-142-11.dynamic.as20676.net) (Remote host closed the connection)
[01:00:50] *** Joins: mro (~mro@port-92-195-142-11.dynamic.as20676.net)
[01:17:57] *** Joins: wingsorc (~wingsorc@user/wingsorc)
[01:34:47] *** Quits: rgrinberg (~textual@2806:101e:7:5da4:a506:183a:7675:98e5) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[01:37:17] *** Joins: rgrinberg (~textual@2806:101e:7:5da4:a506:183a:7675:98e5)
[01:37:31] *** Quits: andreypopp_ (uid22726@id-22726.ilkley.irccloud.com) (Quit: Connection closed for inactivity)
[01:42:58] *** Joins: salkin (~salkin@84.212.156.62)
[01:46:36] *** Quits: rgrinberg (~textual@2806:101e:7:5da4:a506:183a:7675:98e5) (Ping timeout: 240 seconds)
[02:01:32] *** Quits: salkin (~salkin@84.212.156.62) (Quit: salkin)
[02:24:20] *** Quits: mro (~mro@port-92-195-142-11.dynamic.as20676.net) (Quit: Leaving...)
[02:27:24] *** Joins: azimut_ (~azimut@gateway/tor-sasl/azimut)
[02:29:35] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Ping timeout: 240 seconds)
[02:34:24] *** Quits: jonasbits (~quassel@2a00:66c0:1:1::58) (Ping timeout: 252 seconds)
[02:38:32] *** Joins: rgrinberg (~textual@2806:101e:7:5da4:81fd:dc83:46f:8469)
[02:51:28] *** Quits: rgrinberg (~textual@2806:101e:7:5da4:81fd:dc83:46f:8469) (*.net *.split)
[02:51:28] *** Quits: wingsorc (~wingsorc@user/wingsorc) (*.net *.split)
[02:51:28] *** Quits: v0idpwn (sid483136@id-483136.helmsley.irccloud.com) (*.net *.split)
[02:51:28] *** Quits: megeve (sid523379@id-523379.hampstead.irccloud.com) (*.net *.split)
[02:51:28] *** Quits: cbarrett (sid192934@2a03:5180:f:1::2:f1a6) (*.net *.split)
[02:51:28] *** Quits: Boarders_ (sid425905@id-425905.lymington.irccloud.com) (*.net *.split)
[02:51:28] *** Quits: greenbagels (~gb@user/greenbagels) (*.net *.split)
[02:51:28] *** Quits: Putonlalla (~sapekiis@it-cyan.it.jyu.fi) (*.net *.split)
[02:51:28] *** Quits: szkl (uid110435@id-110435.uxbridge.irccloud.com) (*.net *.split)
[02:51:28] *** Quits: d_bot (~d_bot@2001:4802:7800:1:be76:4eff:fe20:3027) (*.net *.split)
[02:51:28] *** Quits: Cypi (~Cypi@cypi.fr) (*.net *.split)
[02:51:28] *** Quits: bacam (~bacam@dhondt.z273.org.uk) (*.net *.split)
[02:53:47] *** Joins: wingsorc (~wingsorc@user/wingsorc)
[02:53:47] *** Joins: v0idpwn (sid483136@id-483136.helmsley.irccloud.com)
[02:53:47] *** Joins: megeve (sid523379@id-523379.hampstead.irccloud.com)
[02:53:47] *** Joins: cbarrett (sid192934@2a03:5180:f:1::2:f1a6)
[02:53:47] *** Joins: Boarders_ (sid425905@id-425905.lymington.irccloud.com)
[02:53:47] *** Joins: greenbagels (~gb@user/greenbagels)
[02:53:47] *** Joins: Putonlalla (~sapekiis@it-cyan.it.jyu.fi)
[02:53:47] *** Joins: szkl (uid110435@id-110435.uxbridge.irccloud.com)
[02:53:47] *** Joins: d_bot (~d_bot@2001:4802:7800:1:be76:4eff:fe20:3027)
[02:53:47] *** Joins: Cypi (~Cypi@cypi.fr)
[02:53:47] *** Joins: bacam (~bacam@dhondt.z273.org.uk)
[02:53:47] *** Quits: d_bot (~d_bot@2001:4802:7800:1:be76:4eff:fe20:3027) (Excess Flood)
[02:54:22] *** Joins: d_bot (~d_bot@2001:4802:7800:1:be76:4eff:fe20:3027)
[02:56:57] *** Quits: szkl (uid110435@id-110435.uxbridge.irccloud.com) (Ping timeout: 250 seconds)
[02:58:00] *** Joins: szkl (uid110435@id-110435.uxbridge.irccloud.com)
[03:14:08] *** Quits: Tuplanolla (~Tuplanoll@91-159-69-98.elisa-laajakaista.fi) (Quit: Leaving.)
[03:26:36] *** Quits: Haudegen (~quassel@178.115.237.87.static.drei.at) (Ping timeout: 240 seconds)
[03:35:17] *** Quits: hackinghorn (~hackingho@user/hackinghorn) (Ping timeout: 240 seconds)
[04:18:23] *** Quits: szkl (uid110435@id-110435.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[04:35:17] *** Joins: szkl (uid110435@id-110435.uxbridge.irccloud.com)
[04:53:21] *** Quits: dextaa_ (~dextaa@cpc142174-lewi20-2-0-cust34.2-4.cable.virginm.net) (Remote host closed the connection)
[05:07:32] *** Joins: hackinghorn (~hackingho@user/hackinghorn)
[05:21:33] *** Joins: rgrinberg (~textual@2806:101e:7:5da4:81fd:dc83:46f:8469)
[06:27:55] *** Quits: adanwan (~adanwan@gateway/tor-sasl/adanwan) (Ping timeout: 240 seconds)
[06:28:41] *** Joins: adanwan (~adanwan@gateway/tor-sasl/adanwan)
[06:34:36] <ns12> Hello, when I use the "Thread" library in Linux or FreeBSD, are the threads POSIX threads?
[06:35:01] <companion_cube> yes, but there's a runtime lock, just so you know
[06:35:21] <companion_cube> (we are all awaiting impatiently the release of OCaml 5.0, where a new abstraction will give us true multicore)
[06:37:16] <ns12> companion_cube: The docs say "Lightweight threads for Posix 1003.1c and Win32". Are there non-lightweight threads too? Why specifically "lightweight threads"?
[06:37:44] <ns12> companion_cube: "yes, but there's a runtime lock, just so you know" - What is the significance of that?
[06:40:18] <companion_cube> hmmmm there used to be another thing for threads, but now it's just posix threads.
[06:40:35] <companion_cube> the runtime lock means 2 threads won't run at the same time (except when engaged in some particular C calls)
[06:42:11] <ns12> companion_cube: So if I want two things to run at the same time, I should use Unix.fork to create a new process?
[06:43:57] <companion_cube> if you want to use multiple cores, probably, yeah
[06:44:06] <companion_cube> the question then is whether it's worth the extra pain :p
[06:45:47] <ns12> What extra pain?
[06:46:00] <companion_cube> handling multiple processes and coordinating them
[06:46:59] <ns12> If Unix.fork can already make OCaml execute two things in parallel, what is the significance of "multicore OCaml"?
[06:47:16] <companion_cube> that within one process you'll have able to use multiple cores
[06:47:41] <companion_cube> in a more convenient way, with finer grained concurrency (mutexes, thread pools, etc.)
[06:48:39] <ns12> Does this only benefit programs that use threads? If my OCaml program does not use threads, there is no benefit in using "multicore OCaml", correct?
[06:52:13] <companion_cube> it's not even out yet
[06:52:23] <companion_cube> but yeah, it'll need to use some form of threads
[06:52:28] <companion_cube> it won't magically parallelize anything
[07:02:19] <ns12> So why do I hear lots of complaints about OCaml not supporting multicore? The lack of multicore only seems to affect those programs that use threads.
[07:03:36] *** Joins: bobo (~bobo@37.171.228.85)
[07:04:26] *** Quits: spip (~bobo@37.171.43.217) (Ping timeout: 272 seconds)
[07:10:44] <ns12> companion_cube: ^
[07:19:24] *** Quits: rgrinberg (~textual@2806:101e:7:5da4:81fd:dc83:46f:8469) (Ping timeout: 240 seconds)
[07:32:30] *** Quits: adanwan (~adanwan@gateway/tor-sasl/adanwan) (Remote host closed the connection)
[07:32:31] *** Quits: azimut_ (~azimut@gateway/tor-sasl/azimut) (Remote host closed the connection)
[07:32:45] *** Joins: adanwan (~adanwan@gateway/tor-sasl/adanwan)
[07:32:49] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[07:41:50] <d_bot> <darrenldl> ns12: well i mean many things dont use threads because we do not have multicore yet, rather than because multicore would not be useful for certain problems
[07:46:14] *** Quits: ralu (~ralu@static.211.245.203.116.clients.your-server.de) (Ping timeout: 272 seconds)
[07:59:19] *** Joins: mbuf (~Shakthi@122.162.72.100)
[08:06:24] <companion_cube> yeah, right now if you want to use multiple cores you have to do the annoying dance of using multiple processes
[08:06:30] <companion_cube> that's what people complain about
[08:06:37] <companion_cube> even though it's the same in node.js, python, etc.
[08:15:00] *** Quits: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se) (Ping timeout: 240 seconds)
[08:17:39] *** Quits: zebrag (~chris@user/zebrag) (Quit: Konversation terminated!)
[08:32:46] *** Joins: Haudegen (~quassel@178.115.237.87.static.drei.at)
[08:37:30] <ns12> Okay. Thanks for the explanations.
[08:40:07] <ns12> I have a question about the "Random" library. Given the same seed, will the random number generator generate the same numbers on different computers?
[08:42:14] <d_bot> <mk-fg> That's usually the idea behind using RNG seeds
[08:46:42] <ns12> Even when the OCaml version is different?
[08:52:24] <d_bot> <mk-fg> I'd expect algorithms behind it to stay the same, but haven't looked myself
[08:53:42] <d_bot> <mk-fg> Crypto stuff doesn't get replaced that often anyway, even when it's something ancient like md5 :)
[08:54:23] <ns12> Since the docs don't guarantee reproducibility of random numbers across computers and across OCaml versions, I think it is best to just implement my own random number generator.
[08:57:17] <ns12> companion_cube: Why is multicore such a big deal for OCaml? Every time OCaml is mentioned, someone inevitably complains about the lack of multicore. But the lack of multicore does not stop them from using Python ...
[08:58:06] <d_bot> <mk-fg> Hm, is it? I've only seen it ever mentioned in this discord and on HN occasionally
[09:01:41] *** Joins: gravicappa (~gravicapp@178.214.246.212)
[09:29:41] <d_bot> <Bluddy> ns12: It's all about the class of programming languages. Within the class of compiled/JIT-based high performance programming languages, OCaml is the only one that doesn't have multicore support. However, within the last 10 years, Javascript has conquered the programming world, relegating all other languages to small niches. At this point, the basis of comparison has changed, since JS is not a high performance language.
[09:30:43] *** Joins: ralu (~ralu@static.211.245.203.116.clients.your-server.de)
[09:37:45] *** Joins: shawnw (~shawn_w@c-73-225-121-73.hsd1.wa.comcast.net)
[09:46:21] <d_bot> <darrenldl> ns12: id avoid rolling a bespoke prng if you're using it for security stuff
[09:47:18] *** Quits: shawnw (~shawn_w@c-73-225-121-73.hsd1.wa.comcast.net) (Quit: Leaving)
[09:47:26] <d_bot> <darrenldl> then again Random is not for security to begin with hm (afaik)...
[10:12:09] *** Joins: Serpent7776 (~Serpent77@90-156-31-193.internetia.net.pl)
[10:17:15] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Ping timeout: 240 seconds)
[10:18:57] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[10:22:02] *** Quits: hackinghorn (~hackingho@user/hackinghorn) (Ping timeout: 272 seconds)
[10:37:51] <d_bot> <Jektrix> V8 is a pretty damn good JIT all in all.
[11:07:34] <d_bot> <Bluddy> sure. It's just not quite at the level of a compiled or semi-compiled language.
[11:08:18] <d_bot> <Bluddy> and it's very memory-hungry
[11:12:19] *** Joins: hackinghorn (~hackingho@user/hackinghorn)
[11:18:44] <d_bot> <Bluddy> but it just doesn't matter that much anymore in most segments. the web and cloud computing have changed the way most programming is done.
[11:20:13] <d_bot> <Bluddy> JS is still pretty bloated and slow on phones though.
[11:31:49] <ns12> darrenldl: I will be using the bespoke PRNG for games and toy simulations. Thanks for the warning.
[11:35:30] <d_bot> <darrenldl> ns12: then Lehmer random number generator is pretty good afail
[11:35:32] <d_bot> <darrenldl> afaik
[11:35:40] <d_bot> <darrenldl> simple and fast
[11:36:30] <ns12> Yes, that's what I have already implemented. Thanks.
[11:38:23] *** Quits: szkl (uid110435@id-110435.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[11:48:27] *** Joins: mro (~mro@2002:5cc3:c051:0:d43:bbe9:dbce:3943)
[12:30:09] *** Quits: Sofi (~sofi@2001:470:69fc:105::1:44cc) (Quit: You have been kicked for being idle)
[12:42:52] <octachron> ns12, Random's PRNG will change for OCaml 5.0 (because it is useful to have a splittable PRNG for multicore), but that is the first change of PRNG since 1995
[12:45:53] <sadiq> always pretty sad when your IDE explains the code you're replacing is 25 years old.
[12:47:59] <sadiq> (it's also where learning some French has been handy)
[12:54:29] *** Joins: Anarchos (~Anarchos@52.166.149.185)
[13:00:12] *** Joins: jlrnick (~josephler@2a01cb09e0253a28246e30ddef064a36.ipv6.abo.wanadoo.fr)
[13:07:30] *** Quits: jlrnick (~josephler@2a01cb09e0253a28246e30ddef064a36.ipv6.abo.wanadoo.fr) (Read error: Connection reset by peer)
[13:15:02] <ns12> octachron: Thank you for this information.
[13:34:22] *** Joins: bartholin (~bartholin@158.110.71.2)
[13:37:34] <d_bot> <guymoque-3987> Does anyone know an OCaml library that looks like Python's `urllib` ?
[14:09:42] <energizer> there are 4 modules in urllib, which one do you mean https://docs.python.org/3/library/urllib.html
[14:11:04] <d_bot> <guymoque-3987> the `urllib.parse` submodule
[14:12:25] <d_bot> <guymoque-3987> but nevermind, I have make what I want to do ðŸ™‚
[14:18:59] *** Joins: xenu_ (~xenu@carychium-tridentatum.xenu.pl)
[14:19:15] *** Quits: xenu (~xenu@carychium-tridentatum.xenu.pl) (Read error: Connection reset by peer)
[14:21:03] *** Quits: Anarchos (~Anarchos@52.166.149.185) (Quit: Client closed)
[14:44:17] *** Quits: unyu (~pyon@user/pyon) (Ping timeout: 240 seconds)
[14:45:40] <ns12> Is there a general rule of thumb for choosing between association lists, Maps, and Hashtbls for a small amount of elements (30-40 items)?
[14:48:40] <d_bot> <Et7f3> Association list when you can search by key or value
[14:49:14] <d_bot> <Et7f3> Usually a tuple of map do the same
[14:50:05] <d_bot> <Et7f3> Map vs hashtbl is if you want immutability and ability to come back
[14:50:54] <d_bot> <Et7f3> With map when you add a element your create a new map that share memory
[14:51:50] <d_bot> <Butanium (@me on answer)> what do you mean by come back ?
[14:56:30] <d_bot> <antron> use an earlier state of the map
[14:56:35] <d_bot> <antron> "state"
[14:57:35] <d_bot> <antron> since map is immutable, you (cheaply) create new maps when you add or remove elements. that means the earlier "state" is still around as a complete value, if you retain a reference to it
[14:59:55] <octachron> My rule of thumb is generally to use a Map, which has the advantage to restrict users to the Map.S interface
[15:01:56] <d_bot> <Bluddy> hashtbl has the highest performance, so if you're doing something like game state based on frame rate, go for that
[15:02:00] <d_bot> <antron> ive drifted to using Hashtbl over time, because of the non-functorial default interface. however, Hashtbl does have some strange and surprising semantics for some of its functions, so Map is probably the better choice if one is getting started and not ready for surprises ðŸ™‚
[15:04:18] <d_bot> <Bluddy> that's true. plus the fact that it uses generic equality and hashing by default
[15:04:19] <octachron> Indeed, if you know that you need maximal performance at any cost, `Hashtbl` is better. But in that case, you already know what you want, and there is no need for a rule of thumb.
[15:08:16] *** Joins: unyu (~pyon@user/pyon)
[15:25:32] <ns12> Is Hashtbl efficient even for 10 items? Isn't there some kind of overhead associated with hash tables?
[15:25:32] <ns12> In Common Lisp, for example, I don't use hash tables for 30 items. I would use association lists instead, because the overhead of hash tables makes it less efficient than association lists for small number of items.
[15:28:53] <d_bot> <Bluddy> you choose how much space to initialize the hashtbl with. it's quite efficient.
[15:29:53] <d_bot> <orbitz> As always: measure your program if performance matters
[15:37:33] *** Joins: jlrnick (~josephler@gw.lipn.univ-paris13.fr)
[15:37:40] <d_bot> <darrenldl> and very often, performance hit happens at places you were not focusing on up front
[15:40:28] *** Joins: dextaa_ (~dextaa@cpc142174-lewi20-2-0-cust34.2-4.cable.virginm.net)
[15:40:38] *** Quits: dextaa_ (~dextaa@cpc142174-lewi20-2-0-cust34.2-4.cable.virginm.net) (Changing host)
[15:40:38] *** Joins: dextaa_ (~dextaa@user/dextaa)
[15:51:22] *** Joins: dhil (~dhil@cpc103052-sgyl39-2-0-cust260.18-2.cable.virginm.net)
[15:57:20] *** Quits: dextaa_ (~dextaa@user/dextaa) (Remote host closed the connection)
[16:31:04] *** Joins: mro_ (~mro@2002:5cc3:c051:0:9d82:6989:e579:ed09)
[16:33:47] *** Quits: mro (~mro@2002:5cc3:c051:0:d43:bbe9:dbce:3943) (Ping timeout: 250 seconds)
[16:38:14] *** Quits: jlrnick (~josephler@gw.lipn.univ-paris13.fr) (Ping timeout: 272 seconds)
[16:43:37] *** Joins: dextaa_ (~dextaa@user/dextaa)
[16:52:10] *** Quits: Haudegen (~quassel@178.115.237.87.static.drei.at) (Quit: Bin weg.)
[17:21:43] <d_bot> <mseri> ns12 also parmap and parany allow you you to parallelize the code
[17:22:44] <ns12> How does Lwt relate to threading and parallelism?
[17:25:10] <d_bot> <Bluddy> Lwt provides green threads ie. not parallelism but concurrency to deal with IO latencies.
[17:25:33] <d_bot> <Bluddy> So the same as Promised/async-await in JS
[17:26:00] *** Quits: bobo (~bobo@37.171.228.85) (Quit: Konversation terminated!)
[17:29:49] <ns12> How does that work? Suppose I use Lwt to execute a blocking system call. Wouldn't that block the entire process, such that there is no concurrency?
[17:30:11] <d_bot> <orbitz> Depends on the system call
[17:30:27] <d_bot> <orbitz> many system calls have a non-blocking mode, and then Lwt behind the scenes handles doing something else until the result is ready
[17:30:51] <d_bot> <Bluddy> that's why, just like in JS land, all calls from Lwt are non-blocking. If you need a blocking call, you can spin it off to another system thread.
[17:30:59] *** Joins: spip (~bobo@37.171.228.85)
[17:31:04] <d_bot> <antron> ns12: lwt is using the non-blocking mode of system calls that have it (e.g. socket I/O) or a thread pool for running blocking calls
[17:33:58] *** Quits: bartholin (~bartholin@158.110.71.2) (Ping timeout: 272 seconds)
[17:34:49] *** Joins: bartholin (~bartholin@158.110.71.2)
[17:34:50] <ns12> Given that only one thread can execute at any given time due to the limitations in OCaml, what is the advantage of using Lwt? Even with Lwt, there will still be only one thread executing at a time.
[17:36:12] <d_bot> <orbitz> If your application is doing things that are generally I/O bound, then there is lots of time to do something else while the I/O happens
[17:36:33] <haesbaert> ns12: lwt still gives you concurrency, just doesn't give you parallelism
[17:36:56] <haesbaert> ns12: you can write things that "block on a lwt promise" for example
[17:38:18] <d_bot> <antron> ns12: the thread pool used for blocking I/Os by lwt is implemented entirely in C and does not touch the ocaml runtime or its lock
[17:38:27] <ns12> So instead of wasting time waiting for blocking system calls to complete, I could use Lwt to get the ability to do other things while waiting?
[17:38:35] <d_bot> <antron> yes
[17:38:49] <d_bot> <antron> you can spawn a huge number of outstanding I/Os and do something else on the CPU, like figure out which other I/Os to spawn
[17:38:52] <haesbaert> yeah, you can look at it as a very nice abstraction on select/poll
[17:39:03] *** Joins: wonko (~wjc@user/wonko)
[17:39:10] <haesbaert> at least that's how my brain understood in the beginning
[17:39:33] <d_bot> <antron> it is, at the center, a wrapper around epoll, kqueue, or whatever each system has
[17:39:44] <d_bot> <Bluddy> ns12: your comparison to using threads is valid. green threads are lighter than system threads. additionally, OCaml can tell which parts of the code are lwt-threaded due to the type system.
[17:39:47] <d_bot> <antron> together with a thread pool
[17:40:25] <d_bot> <antron> Bluddy: lwt-threading is a confusing terminology. because lwt promsies and the internal lwt C thread pool both have the term "thread' in them but they are entirely separate entities from each other
[17:40:42] <ns12> Must Lwt be implemented in C, or could it have been implemented purely in OCaml?
[17:41:08] <d_bot> <antron> if lwt was implemented purely in ocaml, it would incur synchronizations with the runtime lock at least at the start and end of each I/O
[17:41:33] <d_bot> <orbitz> Lwt can be written entirely in Ocaml
[17:41:35] <d_bot> <antron> right now to start an I/O operation from ocaml using lwt, you call some function, it goes to C, and starts a call in the C thread pool
[17:42:52] <d_bot> <antron> if you wrote it entirely in ocaml, you would call the ocaml function, it would go to another ocaml function in another thread, which would force taking the ocaml lock, then it would start the I/O from ocaml, releasing the lock, so you'd still get concurrency, but then you'd need that ocaml worker thread to wake up again after the I/O, take the lock again, only to tell the main thread that the I/O is done, then release the lock, le
[17:43:01] <d_bot> <antron> so it's possible to implement it this way but it would be very inefficient
[17:43:09] <haesbaert> antron: when you say thread pool, you actaully mean a pthread ? (I never read the lwt code, I just imagine how it is)
[17:43:10] <d_bot> <antron> you would still get concurrency, though
[17:43:30] <d_bot> <antron> yeah, lwt uses pthreads on Unix and windows threads on windows
[17:43:32] <d_bot> <orbitz> What @antron  says is not true of all calls
[17:43:34] <ns12> "If your application is doing things that are generally I/O bound ..." - For example, making queries to a database server?
[17:43:43] <d_bot> <orbitz> ns12: yes
[17:43:50] <haesbaert> I see, so you can buy a blocking context  I guess
[17:43:51] <d_bot> <antron> orbitz: the exception is calls that have non-blocking modes, like pipe and socket I/O
[17:44:18] <d_bot> <orbitz> Yes, I know.  I just felt your statement implied all I/O calls, so clarifying.
[17:45:01] <d_bot> <orbitz> You need to interface at some level with whatever language your OS is wirtten in to perform a call, but if you discount that, in many cases, something like Lwt can be written entirely in Ocaml.  Many OS's even provides async IO for filesystem operations
[17:45:12] <ns12> It must have been a lot of work to re-implement the Unix library.
[17:45:25] <d_bot> <orbitz> ns12: it isn't really
[17:45:38] <d_bot> <antron> to date most have been terrible, like aio, which is typically implemented using a low-quality lwt-like abstraction in user space
[17:45:45] *** Joins: Everything (~Everythin@37.115.210.35)
[17:45:54] <d_bot> <antron> low-quality because these things often received little maintenace
[17:46:01] <haesbaert> but aio is virtually unusable in any form
[17:46:05] <d_bot> <antron> while working on lwt i profiled aio and it was much slower than lwt
[17:46:11] <d_bot> <antron> yes it also has a completely broken api and many other problems
[17:46:17] <haesbaert> exactly
[17:46:53] <d_bot> <orbitz> I don't disagree
[17:46:55] <d_bot> <antron> libdispatch is implemented the same way as lwt with the same performance
[17:47:06] <d_bot> <antron> (that's macos gcd)
[17:47:41] <haesbaert> I used a lot of niel's provos libevent (not to be confused with libev)
[17:47:43] <d_bot> <antron> so in practice a library like lwt had to, until maybe io_uring on linux, be written against the "old" system call api, pretty much the way lwt is written
[17:47:58] <d_bot> <antron> libuv is also written the same way
[17:48:32] <haesbaert> I love libevent tbh
[17:48:51] *** Quits: wonko (~wjc@user/wonko) (Remote host closed the connection)
[17:49:19] <d_bot> <antron> orbitz: the main limitation of writing lwt in ocaml would be contention on the big runtime lock between the main thread and worker threads, otherwise yes, it could be written in ocaml
[17:49:37] *** Quits: wingsorc (~wingsorc@user/wingsorc) (Ping timeout: 250 seconds)
[17:49:38] *** Joins: wonko (~wjc@user/wonko)
[17:49:40] <d_bot> <orbitz> Yep
[17:52:32] <ns12> Thank you all for answering my questions.
[17:52:52] *** Quits: wonko (~wjc@user/wonko) (Remote host closed the connection)
[17:53:04] <sleepydog> i have heard good things about windows completion ports, but never used it
[17:53:07] *** Joins: wonko (~wjc@user/wonko)
[17:53:53] *** Quits: wonko (~wjc@user/wonko) (Remote host closed the connection)
[17:54:39] *** Joins: wonko (~wjc@user/wonko)
[17:55:06] *** Parts: Everything (~Everythin@37.115.210.35) ()
[17:56:31] <d_bot> <antron> we never had time to try them in lwt. also, i heard that libuv eventually moved away from them
[17:56:37] <d_bot> <antron> but i did hear good opinions on the api
[17:56:40] *** Joins: Haudegen (~quassel@91.114.49.10)
[18:01:00] *** Quits: mro_ (~mro@2002:5cc3:c051:0:9d82:6989:e579:ed09) (Remote host closed the connection)
[18:07:00] *** Quits: sleepydog (03e7eaddce@2604:bf00:561:2000::3c6) (Ping timeout: 240 seconds)
[18:07:12] *** Joins: sleepydog (03e7eaddce@2604:bf00:561:2000::3c6)
[18:07:54] *** Joins: d_bot_ (~d_bot@2001:4802:7800:1:be76:4eff:fe20:3027)
[18:08:12] *** Quits: unyu (~pyon@user/pyon) (Ping timeout: 240 seconds)
[18:08:36] *** Quits: d_bot (~d_bot@2001:4802:7800:1:be76:4eff:fe20:3027) (Ping timeout: 240 seconds)
[18:10:29] *** Joins: unyu (~pyon@user/pyon)
[18:19:15] *** Joins: mro (~mro@2002:5cc3:c051:0:9d82:6989:e579:ed09)
[18:23:51] *** Quits: mro (~mro@2002:5cc3:c051:0:9d82:6989:e579:ed09) (Ping timeout: 250 seconds)
[18:27:19] *** Quits: dextaa_ (~dextaa@user/dextaa) (Remote host closed the connection)
[18:28:13] *** Joins: mro (~mro@port-92-195-192-81.dynamic.as20676.net)
[18:32:24] *** Joins: dextaa_ (~dextaa@user/dextaa)
[18:34:38] *** Quits: mro (~mro@port-92-195-192-81.dynamic.as20676.net) (Remote host closed the connection)
[18:38:00] *** Quits: wonko (~wjc@user/wonko) (Ping timeout: 252 seconds)
[18:46:54] *** Joins: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se)
[19:04:03] *** Joins: bobo (~bobo@37.164.142.248)
[19:04:32] *** Quits: spip (~bobo@37.171.228.85) (Ping timeout: 272 seconds)
[19:10:16] *** Joins: mro (~mro@2002:5cc3:c051:0:9d82:6989:e579:ed09)
[19:22:15] *** xenu_ is now known as xenu
[19:23:44] *** Quits: mro (~mro@2002:5cc3:c051:0:9d82:6989:e579:ed09) (Remote host closed the connection)
[19:25:20] *** Joins: zebrag (~chris@user/zebrag)
[19:36:47] *** Quits: dextaa_ (~dextaa@user/dextaa) (Quit: The Lounge - https://thelounge.chat)
[19:50:19] *** Joins: mro (~mro@port-92-195-192-81.dynamic.as20676.net)
[19:58:30] *** Quits: mbuf (~Shakthi@122.162.72.100) (Quit: Leaving)
[20:04:03] *** Joins: wonko (~wjc@user/wonko)
[20:09:36] <d_bot_> <darrenldl> any active user of any of the distributed computing libs?
[20:24:12] *** Joins: rgrinberg (~textual@2806:101e:7:5da4:50f5:7256:bb18:3ed3)
[20:27:39] *** Joins: jonasbits (~quassel@2a00:66c0:1:1::58)
[20:45:45] *** Quits: mro (~mro@port-92-195-192-81.dynamic.as20676.net) (Remote host closed the connection)
[20:47:23] *** Joins: mro (~mro@port-92-195-192-81.dynamic.as20676.net)
[20:51:35] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Ping timeout: 240 seconds)
[20:52:12] *** Quits: wonko (~wjc@user/wonko) (Ping timeout: 252 seconds)
[20:56:53] *** Quits: mro (~mro@port-92-195-192-81.dynamic.as20676.net) (Remote host closed the connection)
[20:57:09] *** Joins: dalek_caan (~Thunderbi@109-252-124-86.nat.spd-mgts.ru)
[20:57:44] *** Quits: Haudegen (~quassel@91.114.49.10) (Quit: Bin weg.)
[21:32:02] *** Joins: vicfred (~vicfred@user/vicfred)
[21:34:45] *** Joins: vicfred_ (~vicfred@user/vicfred)
[21:37:35] *** Quits: vicfred (~vicfred@user/vicfred) (Ping timeout: 256 seconds)
[21:38:04] <d_bot_> <Continuation Calculus> is there any way to ask merlin to not shadow basic types? (unit, int, string, etc.). or even better, a way to not shadow simple types (like, `type x = single_variable` should not shadow `single_variable`)
[21:39:05] *** Quits: vicfred_ (~vicfred@user/vicfred) (Client Quit)
[21:44:27] *** Quits: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se) (Ping timeout: 252 seconds)
[21:58:25] *** Joins: salkin (~salkin@84.212.156.62)
[21:59:50] *** Joins: mro (~mro@port-92-195-192-81.dynamic.as20676.net)
[22:01:40] *** Quits: mro (~mro@port-92-195-192-81.dynamic.as20676.net) (Remote host closed the connection)
[22:02:39] *** Joins: mro (~mro@port-92-195-192-81.dynamic.as20676.net)
[22:02:43] <d_bot_> <octachron> That's probably merlin heuristic for determining the best name for a type kicking in. You could try to use a name that the heuristic doesn't like? (The heuristic is penalizing module names containing `__`, I am not sure about type name containing `__`).
[22:03:22] <d_bot_> <octachron> Defining the alias in a small module could work too.
[22:04:55] *** Joins: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se)
[22:06:16] *** Joins: Haudegen (~quassel@178.115.237.87.static.drei.at)
[22:11:11] *** Quits: mro (~mro@port-92-195-192-81.dynamic.as20676.net) (Remote host closed the connection)
[22:23:03] *** Quits: rgrinberg (~textual@2806:101e:7:5da4:50f5:7256:bb18:3ed3) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[22:26:51] *** Quits: xgqt (~xgqt@gentoo/developer/xgqt) (Read error: Connection reset by peer)
[22:29:06] *** Quits: gravicappa (~gravicapp@178.214.246.212) (Ping timeout: 272 seconds)
[22:32:28] *** Joins: xgqt (~xgqt@gentoo/developer/xgqt)
[22:33:35] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 240 seconds)
[22:35:31] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[22:43:50] *** Quits: ejones (~jones@167.88.120.129) (Ping timeout: 252 seconds)
[22:54:35] *** Joins: rgrinberg (~textual@2806:101e:7:5da4:50f5:7256:bb18:3ed3)
[23:01:05] *** Quits: dalek_caan (~Thunderbi@109-252-124-86.nat.spd-mgts.ru) (Quit: dalek_caan)
[23:05:43] *** Quits: rgrinberg (~textual@2806:101e:7:5da4:50f5:7256:bb18:3ed3) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[23:21:18] *** Joins: mro (~mro@2002:5cc3:c051:0:9d82:6989:e579:ed09)
[23:31:05] *** Quits: mro (~mro@2002:5cc3:c051:0:9d82:6989:e579:ed09) (Remote host closed the connection)
[23:39:03] *** Joins: mro (~mro@port-92-195-192-81.dynamic.as20676.net)
[23:47:35] *** Joins: dextaa_ (~dextaa@user/dextaa)
