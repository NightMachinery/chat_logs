[01:53:40] *** Joins: badone (~badone@209.132.189.152)
[02:56:33] *** Quits: great_taste (~great_tas@user/great-taste/x-5798414) (Quit: Client closed)
[03:07:10] *** Joins: great_taste (~great_tas@user/great-taste/x-5798414)
[04:48:42] <hnOsmium9999> << boolalpha << !!0
[04:48:43] <geordi> false
[04:48:46] <hnOsmium9999> << boolalpha << !1
[04:48:47] <geordi> false
[08:54:28] *** Quits: great_taste (~great_tas@user/great-taste/x-5798414) (Quit: Client closed)
[09:22:21] *** Quits: badone (~badone@209.132.189.152) (Quit: ZNC 1.7.5 - https://znc.in)
[11:01:31] *** Quits: Cyp (~cyp@213.237.85.100) (Read error: Connection reset by peer)
[11:53:12] *** Joins: Cyp (~cyp@213.237.85.100)
[11:53:32] *** Quits: hnOsmium9999 (~hnosm@2607:fb90:2765:ae95:7d37:8b3f:c88f:e1fd) (Ping timeout: 240 seconds)
[11:53:36] <TinoDidriksen> geordi --version
[11:53:37] <geordi> GCC 12.0.1 20220222 (experimental)
[12:47:42] <TinoDidriksen> geordi --version
[12:47:43] <geordi> error: libstdcxx_patched_typeinfo.hpp: No such file or directory
[12:47:47] <TinoDidriksen> Er
[12:48:02] <TinoDidriksen> << "hello world"
[12:48:02] <geordi> Same error.
[12:48:06] <TinoDidriksen> Uh oh
[12:49:19] <TinoDidriksen> Rolling back...
[12:49:25] <TinoDidriksen> geordi --version
[12:49:27] <geordi> GCC 12.0.1 20220222 (experimental)
[12:49:39] <TinoDidriksen> Ping Eelis
[12:53:47] <TinoDidriksen> Log seems happy enough: "patching file libstdcxx_patched_typeinfo.hpp (read from /usr/local/include/c++/12.0.1/typeinfo) ; Hunk #1 succeeded at 81 (offset 4 lines). ; Hunk #2 succeeded at 103 with fuzz 2 (offset 4 lines)."
[13:38:59] <TinoDidriksen> Eelis, how can I do a selftest that the built image works? I'd like to put the update in a cron job, but want to catch these kinds of runtime issues before pushing it online.
[17:01:04] *** Quits: Cyp (~cyp@213.237.85.100) (*.net *.split)
[17:01:04] *** Quits: NiKaN (sid385034@id-385034.helmsley.irccloud.com) (*.net *.split)
[17:01:04] *** Quits: geordi (~geordi@tinodidriksen.com) (*.net *.split)
[17:02:30] *** Joins: Cyp (~cyp@213.237.85.100)
[17:02:30] *** Joins: NiKaN (sid385034@id-385034.helmsley.irccloud.com)
[17:02:30] *** Joins: geordi (~geordi@tinodidriksen.com)
[17:02:30] *** erbium.libera.chat sets mode: +v geordi
[17:06:57] *** Quits: NiKaN (sid385034@id-385034.helmsley.irccloud.com) (Ping timeout: 240 seconds)
[17:08:23] *** Joins: NiKaN (sid385034@id-385034.helmsley.irccloud.com)
[19:02:07] <Eelis> TinoDidriksen: if  `docker run -it geordi geordi-local "<< 3"`  returns output "3" it's a reasonable indication that things are ok
[19:02:42] <Eelis> in fact you don't even need the "-it" flags
[19:03:44] <Eelis> weird error you got there
[19:03:54] <Eelis> wonder what that's all about
[19:23:52] <TinoDidriksen> Huh, works fine on the machine I build it on, but doesn't if I docker save -> docker load it on another machine. I assume it gets built for the local CPU, and there's enough of a feature difference from building on i5-11500T to running on i7-3770.
[19:33:49] <Eelis> hmm i see
[21:25:35] <CarloWood> { A a; } struct A { int x; std::mutex m; };
[21:25:36] <geordi>  
[21:26:05] <CarloWood> { std::pair<void*, A> p(nullptr, {}); } struct A { int x; std::mutex m; };
[21:26:06] <geordi> error: no matching function for call to 'pair<void*, A>::pair(nullptr_t, <brace-enclosed initializer list>)'
[21:26:19] <CarloWood> { std::pair<void*, A> p(nullptr); } struct A { int x; std::mutex m; };
[21:26:20] <geordi> error: no matching function for call to 'pair<void*, A>::pair(nullptr_t)'
[21:26:53] <CarloWood> { std::pair<void*, A> p = std::make_pair<void*, A>(nullptr); } struct A { int x; std::mutex m; };
[21:26:53] <geordi> error: no matching function for call to 'make_pair<void*, A>(nullptr_t)'
[21:27:00] <CarloWood> { std::pair<void*, A> p = std::make_pair<void*, A>(nullptr, {}); } struct A { int x; std::mutex m; };
[21:27:00] <geordi> error: no matching function for call to 'pair<void*, A>::pair(void*, A)'
[21:27:20] <CarloWood> { std::pair<void*, A> p; } struct A { int x; std::mutex m; };
[21:27:21] <geordi>  
[21:27:43] <CarloWood> { std::pair<void*, A> p = { nullptr, }; } struct A { int x; std::mutex m; };
[21:27:44] <geordi> error: could not convert '{nullptr}' from '<brace-enclosed initializer list>' to 'pair<void*, A>'
[21:27:58] <CarloWood> { std::pair<void*, A> p = {{ nullptr, }}; } struct A { int x; std::mutex m; };
[21:27:59] <geordi> error: could not convert '{{nullptr}}' from '<brace-enclosed initializer list>' to 'pair<void*, A>'
[21:28:02] <CarloWood> { std::pair<void*, A> p = {{ nullptr }}; } struct A { int x; std::mutex m; };
[21:28:03] <geordi> Same error.
[21:28:09] <CarloWood> { std::pair<void*, A> p = { nullptr }; } struct A { int x; std::mutex m; };
[21:28:09] <geordi> error: could not convert '{nullptr}' from '<brace-enclosed initializer list>' to 'pair<void*, A>'
[21:28:44] <CarloWood> { std::pair<void*, A> p; } struct A { int x; std::mutex m; A(int x_) : x(x_) { } };
[21:28:44] <geordi> error: no matching function for call to 'pair<void*, A>::pair()'
[21:29:03] <CarloWood> { std::pair<void*, A> p(nullptr, A{}); } struct A { int x; std::mutex m; A(int x_) : x(x_) { } };
[21:29:03] <geordi> error: no matching function for call to 'A::A(<brace-enclosed initializer list>)'
[21:29:13] <CarloWood> { std::pair<void*, A> p(nullptr, A{42}); } struct A { int x; std::mutex m; A(int x_) : x(x_) { } };
[21:29:14] <geordi> error: no matching function for call to 'pair<void*, A>::pair(nullptr_t, A)'
[21:44:25] <TinoDidriksen> Hrmph. Even building on a Xeon E3-1275 is not compatible with the i7-3770. That's somewhat surprising. Now I wonder if I can run the i7-3770 build on the other machines...will test later.
[22:36:34] <TinoDidriksen> Nope, not inversely compatible either. Can't run the i7 image on the Xeon.
[22:37:20] <TinoDidriksen> That's a little too odd, imo. Eelis, should the build be machine dependent to such a degree?
[22:38:36] <TinoDidriksen> Deleting, pruning, and reloading the image on the same machine works, so it's not just a Docker save/load quirk.
[23:07:35] <Eelis> TinoDidriksen: i honestly haven't given it any attention. the details of which image builds will work on which image runners never crossed my mind
[23:08:22] <TinoDidriksen> Me neither, until I wanted to run this cron job on a faster machine. Not a big deal for me, was just puzzling.
[23:08:51] <Eelis> yeah makes sense that an issue i didn't give any attention to ends up exploding :)
[23:24:47] <TinoDidriksen> geordi --version
[23:24:49] <geordi> GCC 12.0.1 20220303 (experimental)
