[00:04:03] *** Quits: Snaffu (Snaffu@gateway/vpn/protonvpn/snaffu) (Remote host closed the connection)
[00:06:20] *** Joins: Snaffu (~Snaffu@c-174-60-107-126.hsd1.pa.comcast.net)
[00:26:39] *** Quits: uncleyear (~ian@93.185.27.45) (Remote host closed the connection)
[00:30:13] *** Joins: uncleyear (~ian@93.185.27.45)
[00:31:55] *** Quits: jespada (~jespada@90.254.247.46) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[00:40:40] *** Quits: derelict (~derelict@user/derelict) (Quit: WeeChat 3.2)
[00:47:10] *** Joins: mwnaylor (~user@2601:5ce:4300:5fa0::8497)
[01:16:02] *** Quits: op2 (~op@user/op2) (Remote host closed the connection)
[01:18:01] *** Quits: mwnaylor (~user@2601:5ce:4300:5fa0::8497) (Ping timeout: 246 seconds)
[01:25:43] *** Joins: mwnaylor (~user@2601:5ce:4300:5fa0::8497)
[01:47:31] *** Joins: kipz (~kipz@home.kipz.org)
[01:48:59] *** Quits: ahungry (~user@99-40-9-245.lightspeed.livnmi.sbcglobal.net) (Remote host closed the connection)
[01:49:26] *** Joins: isekaijin (~pyon@user/pyon)
[01:50:34] *** Quits: Snaffu (~Snaffu@c-174-60-107-126.hsd1.pa.comcast.net) (Ping timeout: 240 seconds)
[01:51:25] *** Joins: jespada (~jespada@90.254.247.46)
[01:54:30] *** Joins: son0p (~ff@181.136.122.143)
[02:07:30] *** Joins: derelict (~derelict@user/derelict)
[02:16:55] *** Quits: zephyr (~alandiper@ec2-34-230-252-114.compute-1.amazonaws.com) (Read error: Connection reset by peer)
[02:16:57] *** Joins: zephyr0 (~alandiper@ec2-34-230-252-114.compute-1.amazonaws.com)
[02:21:06] *** Quits: seschwar (~seschwar@user/seschwar) (Quit: :wq)
[02:32:03] *** Quits: jespada (~jespada@90.254.247.46) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[02:33:03] *** Joins: jespada (~jespada@90.254.247.46)
[02:35:45] *** zephyr0 is now known as zephyr
[02:35:52] *** Quits: wallymathieu (~wallymath@81-234-151-21-no94.tbcn.telia.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[02:59:52] *** Quits: Trieste (~T@user/pilgrim) (Ping timeout: 246 seconds)
[03:01:32] *** Joins: Trieste (T@user/pilgrim)
[03:11:15] *** Quits: kipz (~kipz@home.kipz.org) (Remote host closed the connection)
[03:16:48] *** Joins: golanv (~golanvtch@2001:470:69fc:105::54c)
[03:40:16] *** Joins: libertyprime (~libertypr@124.197.60.232)
[03:45:58] *** Joins: selfsymmetric-mu (~matt@c-73-10-148-139.hsd1.nj.comcast.net)
[03:47:20] *** Quits: libertyprime (~libertypr@124.197.60.232) (Ping timeout: 252 seconds)
[03:59:06] *** Joins: Guest74 (~Guest74@pool-71-174-239-146.bstnma.fios.verizon.net)
[03:59:30] <Guest74> Hey new to clojure and was trying to use map with zipmap but unsure of what to do with the zipmap keys in the sense that it doesn't seem to fit properly and was wondering if there was a better approch to what I am trying to do
[04:01:24] <Guest74> so for example I have two sequences, one being ('a' 'b' 'c') and ((1 2 3) (4 5 6) (7 8 9)) and I would like ({:letter a :numbers (1 2 3)} :letter b :numbers (4 5 6) :letter c :numbers (7 8 9)})
[04:01:52] <Guest74> (missing a few {} above but hopefully my message is clear)
[04:06:32] <Vaelatern> Hrm
[04:06:39] <chujev> zipmap isn't appropriate here
[04:06:46] <chujev> you can try:
[04:06:49] <chujev> ,(map #(hash-map :letter %1 :numbers %2) '("a" "b" "c") '((1 2 3) (4 5 6) (7 8 9)))
[04:08:04] <Vaelatern> yeah zipmap gives you {'a' (1 2 3) 'b' (4 5 6) 'c' (7 8 9)}
[04:09:17] <Vaelatern> which might be what you want, since (keys) is the first seq and (vals) is the second, or you actually want that data transform you said so you can (map :letter) to get the first seq and (map :numbers) to get the seq
[04:15:28] <Guest74> ok thanks, yeah I was trying to fit zipmap into the way I've been using map but it got messy. I've been finding myself doing a lot of this and was also wondering if I am using map incorrectly or should be doing something else. So for example lets say I have a function that takes 2 args, and I will use map to call that function, and one of the args
[04:15:28] <Guest74> I have a sequence which makes sense for map bc I want to call that function of every value in the sequence, but the other arg for the funtion will be consistent and I find myself doing stuff like (repeat (count sequence) consistent param) as the other arg to map
[04:16:02] <Guest74> I can clarify that if needed but yeah is there something else I should be doing in these cases that is more inline with standard clojure pratices?
[04:16:50] *** Quits: justache (~justache@user/justache) (Read error: Connection reset by peer)
[04:17:09] <Vaelatern> (map (partial my-fn "normal-arg") my-seq)
[04:17:25] *** Quits: cbleslie (~cbleslie@47.148.37.14) (Read error: Connection reset by peer)
[04:18:02] *** Joins: cbleslie (~cbleslie@47.148.37.14)
[04:18:26] *** Joins: justache (~justache@user/justache)
[04:21:04] <Vaelatern> sound good?
[04:22:08] <Guest74> yeah I think that seems better, I think I looked at something like that before and was thrown off bc the order of my args would be wrong
[04:22:45] <Vaelatern> then (map #(my-fn % "normal-arg") my-seq) works too
[04:23:49] <chujev> using "for" can also be readable and convenient (for [x some-sequence] (my-fn x :constant-arg))
[04:25:00] *** Joins: libertyprime (~libertypr@124.197.60.232)
[04:25:27] <Vaelatern> it's lazy too, isn't it?
[04:25:37] <chujev> yep
[04:25:59] <Vaelatern> difficulty with (for) is it's hard to then fit that in a thread ->>
[04:32:02] <Vaelatern> and I really really like threading
[04:32:07] <Vaelatern> maybe a bit too much
[04:38:07] <chujev> threading is great too.  you can often replace a chain of map/filter/... calls with one "for", or wrap it in a function for further threading
[04:42:02] <Vaelatern> good point, and the for in that case acts more like a transducer wouldn't it, since it's lazy and evaluates one element at a time
[04:42:29] * Vaelatern reconsiders the use of for, favorably
[04:42:43] <Guest74> hm maybe I should try to look into threading since I seem to chain a lot of maps together
[04:45:09] <Guest74> is it considered bad pratice to chain maps?
[04:46:50] <Vaelatern> ->> exists for that
[04:47:09] <Vaelatern> if your lists are massive could hit performance issues with a thread
[04:47:41] <Vaelatern> (but things are generally lazy so it's generally fine)
[04:56:32] <Guest74> you have been so helpful so another question if you don't mind about standards, take that structure I mentioned before ({:letter 'a' :numbers (1 2 3)} ...) and I want to 'loop' through it in the way that I call a function for each item in numbers, while also using that letter, such as fn a 1,  fn a 2,  fn a 3...and so on and I really think I wan't
[04:56:32] <Guest74> side effects so I was using nested doseq, but it seems like again the fact that I am using two do seq is wrong from my short time with clojure
[04:57:04] <Guest74> but am struggling to find what I want via google when I usually have no trouble with something like python finding what I am looking for
[05:03:06] <jeaye> You want to call a function for each item, so here's the question: do you care about the result for each function?
[05:03:34] <jeaye> If the answer is no, the fn must have side effects. Otherwise, calling it and not using the result would be pointless.
[05:03:51] <jeaye> If the answer is yes, it has side effects, so using a doseq may make sense.
[05:04:28] <Guest74> yeah my message wasn't clear but do not care about the result, only care about the side effects that occur from the function I am calling 
[05:04:29] <chujev> doseq sounds good, you don't need to nest them: (doseq [{:keys [letter numbers]} list-of-maps, num numbers] (side-effect! letter num))
[05:04:31] <jeaye> Er, broken logic if the answer is yes.
[05:04:55] <jeaye> Guest74: Then doseq makes sense.
[05:05:18] <jeaye> But also note that the fn doing the doseq to call the effecting fn is itself an effecting fn.
[05:06:16] <chujev> without destructuring magic that would be: (doseq [m list-of-maps, num (:numbers m)] (side-effect! (:letter m) num))
[05:07:08] <jeaye> So separate that logic into its own little fn and don't bury it into your business logic. The way we succeed in Clojure is by having the vast majority of fns be pure data transformations while having a small collection of effecting fns, pushed to the edge of the code.
[05:10:45] <Guest74> thanks and yeah I've found that seperating things into very basic functions has been very beneficial in my ability to understand whats going on so I think I am on the right track there
[05:12:08] <Guest74> chujev: almost seems like without destructuring its less complicated?
[05:14:29] <chujev> perhaps, but i'm used to destructuring and would prefer that version
[05:18:07] *** Quits: Tolstoy (~Keith@97-120-23-14.ptld.qwest.net) (Quit: Textual IRC Client: www.textualapp.com)
[05:44:41] <Vaelatern> I feel like the ideal clojure program keeps its stateful behavior near the "top", far away from the translation and mutating parts of the code. That way if your side-effecting code has to change, at least it's not in the middle of everything.
[05:49:42] <Vaelatern> so gather your side-effecting into consistent places, your code will be happier when side effects don't abound
[05:55:01] *** Joins: Tolstoy (~Keith@97-120-23-14.ptld.qwest.net)
[06:09:03] *** Quits: cbleslie (~cbleslie@47.148.37.14) (Read error: Connection reset by peer)
[06:09:08] *** Joins: cbleslie0 (~cbleslie@47.148.37.14)
[06:09:09] *** Quits: cbleslie0 (~cbleslie@47.148.37.14) (Read error: Connection reset by peer)
[06:17:00] *** Quits: shredder (~user@user/shredder) (Quit: quitting)
[06:19:20] *** Joins: shredder (~user@user/shredder)
[06:27:16] *** Quits: Guest74 (~Guest74@pool-71-174-239-146.bstnma.fios.verizon.net) (Quit: Client closed)
[08:05:01] *** Joins: Iacob (~Iacob@106.47.78.191)
[08:05:53] *** Quits: Iacob (~Iacob@106.47.78.191) (Client Quit)
[08:06:13] *** Joins: Iacob (~Iacob@106.47.78.191)
[08:17:09] *** Joins: luna_ (~luna@124.205.197.98)
[08:46:42] *** Quits: luna_ (~luna@124.205.197.98) (Remote host closed the connection)
[09:02:19] *** Joins: luna_ (~luna2021@124.205.197.98)
[09:05:46] *** Quits: derelict (~derelict@user/derelict) (Ping timeout: 240 seconds)
[09:12:31] *** Quits: luna_ (~luna2021@124.205.197.98) (Remote host closed the connection)
[09:14:04] *** Quits: Iacob (~Iacob@106.47.78.191) (Quit: Leaving)
[09:19:32] *** Joins: luna_ (~luna2021@124.205.197.98)
[09:24:23] *** Quits: luna_ (~luna2021@124.205.197.98) (Ping timeout: 252 seconds)
[09:48:59] *** Joins: struchu (~struchu@staticline-31-183-185-141.toya.net.pl)
[09:58:10] *** Joins: luna_ (~luna2021@124.205.197.98)
[10:11:06] *** Quits: patrix (~patrix@2400:4050:ca42:6b00:30c9:6ab4:92d3:b90b) (Ping timeout: 240 seconds)
[10:34:25] *** Joins: patrix (~patrix@2400:4050:ca42:6b00:8070:e430:8a03:809c)
[10:46:12] <Para> Vaelatern: "functional core, imperative shell" is sort of that
[10:51:04] *** Joins: turlando (~turlando@user/turlando)
[10:52:00] *** Quits: jespada (~jespada@90.254.247.46) (Ping timeout: 268 seconds)
[10:55:04] *** Joins: xerxes (~xerxes@117.222.64.149)
[10:55:05] *** Joins: jespada (~jespada@90.254.247.46)
[10:58:43] *** Quits: uncleyear (~ian@93.185.27.45) (Remote host closed the connection)
[11:00:08] *** Joins: uncleyear (~ian@93.185.27.45)
[11:10:16] *** Joins: nly (~nly@122.161.65.99)
[11:14:29] *** Joins: wallymathieu (~wallymath@81-234-151-21-no94.tbcn.telia.com)
[11:20:05] *** Parts: nly (~nly@122.161.65.99) ()
[11:54:38] *** Quits: mwnaylor (~user@2601:5ce:4300:5fa0::8497) (Ping timeout: 252 seconds)
[11:55:37] *** Joins: sailorCat (~user@178.67.192.225)
[11:57:45] *** Joins: rhett (Username@174-126-122-77.cpe.sparklight.net)
[11:57:54] *** Quits: rhett (Username@174-126-122-77.cpe.sparklight.net) (Excess Flood)
[12:13:23] *** Quits: struchu (~struchu@staticline-31-183-185-141.toya.net.pl) (Ping timeout: 255 seconds)
[12:19:10] *** Quits: sailorCat (~user@178.67.192.225) (Ping timeout: 246 seconds)
[12:28:56] *** Quits: wallymathieu (~wallymath@81-234-151-21-no94.tbcn.telia.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[12:36:32] *** Joins: hendursa1 (~weechat@user/hendursaga)
[12:39:38] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 244 seconds)
[12:52:27] *** Joins: struchu (~struchu@aajr245.neoplus.adsl.tpnet.pl)
[12:53:44] *** Quits: xerxes (~xerxes@117.222.64.149) (Quit: leaving)
[13:03:06] *** Quits: turlando (~turlando@user/turlando) (Ping timeout: 272 seconds)
[13:30:42] *** Joins: Iacob (~Iacob@106.47.78.191)
[15:04:56] *** Quits: luna_ (~luna2021@124.205.197.98) (Remote host closed the connection)
[15:10:43] *** Quits: Iacob (~Iacob@106.47.78.191) (Quit: Leaving)
[15:19:15] <EdwardIII> Para: i thought that video summed it up nicely. it tends to be a big question for people new to trying fp-flavoured stuff, "yeah but obviously i need state somewhere, where does it go?"
[15:24:23] *** Joins: luna_ (~luna2021@124.205.197.98)
[15:33:34] *** Joins: luna__ (~luna2021@124.205.197.98)
[15:36:17] *** Quits: luna_ (~luna2021@124.205.197.98) (Ping timeout: 252 seconds)
[15:39:56] *** Quits: Trieste (T@user/pilgrim) (Ping timeout: 255 seconds)
[15:41:33] *** Quits: luna__ (~luna2021@124.205.197.98) ()
[16:31:58] *** Joins: Snaffu (~Snaffu@c-174-60-107-126.hsd1.pa.comcast.net)
[16:43:16] *** Joins: xulfer (uid452788@id-452788.charlton.irccloud.com)
[16:47:32] <EdwardIII> sobel: yesterday you said you use state machines a lot. do you use some specific FSM library? 
[16:49:43] <EdwardIII> sobel: doing a little file uploading panel that shows % completed and was thinking this could be a good choice
[16:49:43] *** Joins: yoonkn (~user@175.197.208.79)
[16:52:23] *** Quits: struchu (~struchu@aajr245.neoplus.adsl.tpnet.pl) (Read error: Connection reset by peer)
[16:53:00] *** Joins: struchu (~struchu@aajr245.neoplus.adsl.tpnet.pl)
[17:32:44] *** Joins: Trieste (~T@user/pilgrim)
[17:34:15] <sobel> EdwardIII: i don't use a library for FSMs, mostly i just use program data and (cond)
[17:34:43] <EdwardIII> ok nice
[17:35:27] <EdwardIII> i don't suppose you have any examples? i'm seeing one like this ,but it uses a macro and seems maybe a bit complicated? https://nakkaya.com/2010/06/22/finite-state-machine-implementation-in-clojure/
[17:35:39] <aphyr> Yeah, so many of my FSMs are just like (reduce (fn [[state something] input] (case [state input] ...)) [:init something] inputs)
[17:36:25] <EdwardIII> ah this is interesting. and that reducer would run whenever something gets updated in an atom i'm guessing?
[17:36:48] <aphyr> That example runs over a sequence of inputs
[17:37:13] <aphyr> I generally try to decouple state from the actual FSM--it's often nice to have both pure and stateful variants of the state machine
[17:37:58] <aphyr> so I write the transition function (step state input) => state' once, and if I need state, wrap the state in an atom and hit it with (swap! fsm step input)
[17:38:24] <sobel> ^ all of that
[17:38:39] <aphyr> Here's a concrete example from the Knossos linearizability checker, which has a generic protocol so you can plug in your own state machines representing different datatypes: https://github.com/jepsen-io/knossos/blob/master/src/knossos/model.clj#L12-L22
[17:39:10] <aphyr> And this is an implementation of that state machine protocol which implements a simple register (a read-write variable) https://github.com/jepsen-io/knossos/blob/master/src/knossos/model.clj#L52-L59
[17:39:56] *** Quits: Snaffu (~Snaffu@c-174-60-107-126.hsd1.pa.comcast.net) (Quit: leaving)
[17:40:02] *** Quits: Trieste (~T@user/pilgrim) (Ping timeout: 252 seconds)
[17:40:25] <aphyr> One really nice advantage to this approach is that you can do parallel searches through the FSM space, because there's no shared state--so Knossos is free to do all kinds of backtracking and speculative execution tricks
[17:41:03] <aphyr> You can also memoize the state machine transitions and compile them into a transition table for super-fast, minimal-allocation transitions: https://github.com/jepsen-io/knossos/blob/master/src/knossos/model/memo.clj
[17:43:50] *** Joins: Trieste (T@user/pilgrim)
[17:44:13] <aphyr> (this might be more than you wanted hahaha, tl;dr "a single two-argument function" is often a perfectly fine FSM
[17:45:45] *** Quits: hendursa1 (~weechat@user/hendursaga) (Quit: hendursa1)
[17:45:53] *** Joins: nighcoder (~ciumbi@45.58.87.61)
[17:46:46] *** Joins: hendursaga (~weechat@user/hendursaga)
[17:53:37] <EdwardIII> thanks aphyr & sobel. i'll try to parse tihs mentally :)
[17:53:47] <EdwardIII> *this
[17:57:06] <sobel> pls enjoy!
[18:01:57] <aphyr> Yeah! State machines are fun!
[18:02:25] *** Joins: turlando (~turlando@93-42-250-112.ip89.fastwebnet.it)
[18:02:25] *** Quits: turlando (~turlando@93-42-250-112.ip89.fastwebnet.it) (Changing host)
[18:02:25] *** Joins: turlando (~turlando@user/turlando)
[18:04:55] *** Joins: op2 (~op@user/op2)
[18:09:11] *** Quits: xulfer (uid452788@id-452788.charlton.irccloud.com) (Ping timeout: 252 seconds)
[18:09:30] *** Joins: Yaser_Amiri (~yaser@89.199.66.185)
[18:11:32] *** Quits: struchu (~struchu@aajr245.neoplus.adsl.tpnet.pl) (Ping timeout: 272 seconds)
[18:11:44] *** Joins: xulfer (uid452788@id-452788.charlton.irccloud.com)
[18:12:12] <Yaser_Amiri> Hi, I want to use test.check to generate a journal (a sequence that each member has a relation to the previous one), this needs some kind of state or something like that but I can't find anything related in docs. Is it even posibble?!
[18:15:55] <aphyr> oh good question
[18:16:53] *** Quits: xulfer (uid452788@id-452788.charlton.irccloud.com) (Ping timeout: 252 seconds)
[18:17:49] <aphyr> So... how complex of a relationship do you need here?
[18:17:51] *** Joins: xulfer (uid452788@id-452788.charlton.irccloud.com)
[18:19:08] <aphyr> Like let's say you were trying to, I dunno, generate sequences of account balances in a bank account--you could instead generate a vector of deposits/credits, and then use fmap to transform that into a vector of resulting balances via (reductions + 0 deltas)
[18:19:35] <aphyr> Basically take advantage of test.check's generators to produce *unrelated* data, then *relate* it via fmap somehow
[18:21:20] *** Joins: derelict (~derelict@user/derelict)
[18:23:08] <Yaser_Amiri> Good example! lets say I have 1000$ at inital point and I want generate series of writhraws. I must NOT be able to writhraw 1002$ (some of all withraws must be less than 1000)
[18:23:29] *** Joins: mwnaylor (~user@2601:5ce:4300:5fa0::8497)
[18:23:29] <aphyr> Yeah, you could do that too
[18:23:48] <Yaser_Amiri> where should I keep the balance?
[18:23:50] <aphyr> Skip over any deltas which would cause your balance to go negative
[18:24:08] <Yaser_Amiri> That would be many numbers :)))
[18:24:19] <aphyr> About half, no?
[18:25:12] <Yaser_Amiri> maybo more! I can not control if I don't have the balance! It random number!
[18:25:14] <aphyr> Think something like (reductions (fn [[balance deltas] delta] (let [balance' (+ balance delta)] (if (neg? balance') deltas (conj deltas delta))) ...)
[18:25:52] <aphyr> Generate deltas, then fmap them through that call to reductions to make sure the delta sequence never goes negative
[18:26:26] <aphyr> Er, sorry, you'd want a reduce or loop, and to extract just the deltas at the end, not reductions in this case, but hopefully you get the gist
[18:28:20] <aphyr> In general, you can write arbitrary generators with any function (fn [rand size]), so if you need to you could drop to that
[18:28:23] <aphyr> https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L28
[18:29:41] <aphyr> Take a look at how gen/vector is defined--if you don't want to do this kind of filtering/fmap trick, you could implement the whole journal generation process from scratch
[18:29:44] <Yaser_Amiri> Hmm! I'll try again! thanks!
[18:30:39] <Yaser_Amiri> And thanks for the jepsen ;)
[18:31:10] <aphyr> ^_^
[18:32:38] *** Parts: derelict (~derelict@user/derelict) (WeeChat 3.2)
[18:35:49] *** Joins: ahungry (~user@99-40-9-245.lightspeed.livnmi.sbcglobal.net)
[18:48:35] *** Quits: iomonad (~iomonad@user/iomonad) (Quit: [1]    28823 segmentation fault (core dumped)  weechat)
[18:52:25] *** Joins: iomonad (~iomonad@user/iomonad)
[18:59:10] *** Quits: Yaser_Amiri (~yaser@89.199.66.185) (Ping timeout: 268 seconds)
[19:03:12] *** Joins: Yaser_Amiri (~yaser@5.211.22.180)
[19:04:22] *** Quits: iomonad (~iomonad@user/iomonad) (Quit: [1]    28823 segmentation fault (core dumped)  weechat)
[19:07:51] *** Joins: iomonad (~iomonad@user/iomonad)
[19:09:41] *** Quits: iomonad (~iomonad@user/iomonad) (Client Quit)
[19:10:02] *** Joins: iomonad (~iomonad@user/iomonad)
[19:13:34] <EdwardIII> sorry bit of a babyland question. in the figwheel repl i'm getting: (find-ns 'imjur-js.upload-states-test) => nil.ii've got my test in test/imjur_js/upload_states_test.cljs. top looks like: (ns imjur-js.upload-states-test... and i've got :source-paths ["src" "test"] in project.clj
[19:13:48] <EdwardIII> what am i missing here?
[19:21:08] *** Quits: tomku (~tomku@user/tomku) (Ping timeout: 252 seconds)
[19:21:16] *** Joins: tomku (~tomku@user/tomku)
[19:26:08] *** Quits: son0p (~ff@181.136.122.143) (Remote host closed the connection)
[19:26:08] <ridcully> have you required the namespace there?
[19:28:40] *** Joins: son0p (~ff@181.136.122.143)
[19:30:05] *** Quits: son0p (~ff@181.136.122.143) (Remote host closed the connection)
[19:30:26] <EdwardIII> ridcully: hrm do i need to do that if it's all part of the same namespace? for example i can say (find-ns 'imjur-js.core) or (find-ns 'imjur-js.dom) and they both return #object[cljs.core.Namespace]. although mabye the repl is somehow already doing that
[19:32:17] <ridcully> because something along the lines required them?
[19:32:35] <ridcully> find-ns does not load code
[19:32:52] <ridcully> so most likely something else has loaded those packages
[19:33:05] <ridcully> e.g. you can find-ns 'clojure.string in a fresh clojure repl
[19:33:21] <ridcully> but that is because some tooling along the lines loaded it
[19:33:32] <Para> re: FSMs, this is a fairly new release and seems interesting https://lucywang000.github.io/clj-statecharts/
[19:34:08] <EdwardIII> hrm yes ridcully i think that's it, thank you :)
[19:35:27] <EdwardIII> also how do you folks run your clojurescript test suites? some kind of test runner or something?
[19:36:47] <Para> kaocha is du jour these days
[19:37:02] <Para> Which, in fairness, does seem to work quite well
[19:37:16] <EdwardIII> well it has pixel art graphics in the README, this is a huge plus
[19:37:37] <Para> Just like the Swiss flag.
[19:40:33] *** Quits: nighcoder (~ciumbi@45.58.87.61) (Remote host closed the connection)
[19:41:39] <EdwardIII> hmm looks like they also built a test runner into figwheel maybe https://figwheel.org/docs/testing.html
[19:44:53] *** Quits: tomku (~tomku@user/tomku) (Ping timeout: 252 seconds)
[19:45:01] *** Joins: tomku (~tomku@user/tomku)
[19:45:31] *** Joins: nighcoder (~ciumbi@45.58.87.61)
[19:47:45] *** Quits: yoonkn (~user@175.197.208.79) (Read error: Connection reset by peer)
[19:51:46] <ridcully> another option: write your core functionality using cljc files and then run your tests with the java side of the world
[19:52:25] <ridcully> and if you end up with something running on a browser you most likely want to look into some proper end-to-end testing like selenium/cypress/...
[19:53:32] <EdwardIII> MORE functionally than i already do? impossible ;)
[19:54:27] <EdwardIII> (for the purpose of this joke i mean my main functionality doesn't do any stateful changes to the dom etc) 
[19:55:05] <ridcully> it clearly depends on what your application does
[19:56:00] <EdwardIII> not a bad idea though
[19:56:05] <ridcully> you mentioned struggling with uploads (iirc?)
[19:56:15] <ridcully> so my guess was, that you will do things with this file
[19:56:21] <EdwardIII> ridcully: yeah just making a crappy imjur clone to learn the language
[19:56:42] <EdwardIII> the backend is in clj so running tests for that is comparitvely quite simple
[20:00:16] <Para> There's a plugin for cypress which allows you to write the tests in cljs ;)
[20:00:44] <ridcully> ah good to know.  ill check this out
[20:01:17] *** Quits: Trieste (T@user/pilgrim) (Ping timeout: 252 seconds)
[20:01:55] <ridcully> modern js at least is not the worst language and in the end all the code is just "assert cy.command.chain()" anyway
[20:07:00] *** Joins: wallymathieu (~wallymath@81-234-151-21-no94.tbcn.telia.com)
[20:07:13] *** Quits: lunik1 (~lunik1@cpc77339-stav19-2-0-cust1016.17-3.cable.virginm.net) (Quit: :x)
[20:16:05] *** Joins: lunik1 (~lunik1@cpc77339-stav19-2-0-cust1016.17-3.cable.virginm.net)
[20:35:49] *** Quits: lunik1 (~lunik1@cpc77339-stav19-2-0-cust1016.17-3.cable.virginm.net) (Quit: :x)
[20:38:25] *** Quits: DrBob (~drbobbeat@c-24-14-127-107.hsd1.il.comcast.net) (Quit: Textual IRC Client: www.textualapp.com)
[20:52:23] *** Quits: xulfer (uid452788@id-452788.charlton.irccloud.com) (Quit: Connection closed for inactivity)
[20:53:08] *** Joins: Trieste (~T@user/pilgrim)
[20:54:19] *** Joins: lunik1 (~lunik1@cpc77339-stav19-2-0-cust1016.17-3.cable.virginm.net)
[20:55:09] *** Joins: seschwar (~seschwar@user/seschwar)
[20:57:07] *** Joins: Trieste_ (T@user/pilgrim)
[20:57:38] *** Quits: Trieste (~T@user/pilgrim) (Ping timeout: 255 seconds)
[20:59:04] *** Joins: xulfer (uid452788@id-452788.charlton.irccloud.com)
[21:14:46] *** Quits: iomonad (~iomonad@user/iomonad) (Quit: [1]    28823 segmentation fault (core dumped)  weechat)
[21:15:06] *** Joins: iomonad (~iomonad@user/iomonad)
[21:15:59] *** Quits: selfsymmetric-mu (~matt@c-73-10-148-139.hsd1.nj.comcast.net) (Remote host closed the connection)
[21:17:00] *** Joins: gyim (~user@51B6A4CF.unconfigured.pool.telekom.hu)
[21:22:23] *** Quits: libertyprime (~libertypr@124.197.60.232) (Ping timeout: 255 seconds)
[22:14:34] *** Quits: op2 (~op@user/op2) (Quit: rcirc on GNU Emacs 28.0.50)
[22:17:01] *** Joins: arca0 (~tesuji@91.193.4.172)
[22:23:50] *** Joins: selfsymmetric-mu (~matt@c-73-10-148-139.hsd1.nj.comcast.net)
[22:26:22] *** Quits: faxmodem (~faxmodem@82-65-124-102.subs.proxad.net) (Ping timeout: 268 seconds)
[22:59:27] *** Quits: nighcoder (~ciumbi@45.58.87.61) (Remote host closed the connection)
[23:03:25] *** Joins: nighcoder (~ciumbi@45.58.87.61)
[23:35:59] *** Joins: drbobbeaty (~drbob@c-24-14-127-107.hsd1.il.comcast.net)
[23:40:27] *** Quits: jonys (~jonys@user/jonys) (Remote host closed the connection)
[23:40:27] *** Quits: Yaser_Amiri (~yaser@5.211.22.180) (Read error: Connection reset by peer)
[23:40:51] *** Joins: jonys (~jonys@user/jonys)
[23:49:35] *** Joins: IPmonger (~IPmonger@c-69-242-83-226.hsd1.pa.comcast.net)
[23:49:50] *** Quits: IPmonger (~IPmonger@c-69-242-83-226.hsd1.pa.comcast.net) (Remote host closed the connection)
