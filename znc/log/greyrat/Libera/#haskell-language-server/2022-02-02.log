[00:14:59] <maerwald> hm, TH is still busted for me, no matter how I build HLS :D
[01:02:03] <Guillaum[m]> https://github.com/haskell/haskell-language-server/pull/2669/commits/48e5704231e3a39ba4b604025d7b05ebf463945c << I'm so happy with this commit. I was starting to write a huge `case` on the complete AST in order to look for comments, and I recalled that the GHC Ast have a Data and Typeable instances, so we can use scrap your boilerplate on it.
[01:06:56] *** Quits: libertyprime (~libertypr@118-92-72-229.dsl.dyn.ihug.co.nz) (Quit: leaving)
[01:14:48] *** Joins: coot (~coot@213.134.190.95)
[02:09:02] *** Quits: coot (~coot@213.134.190.95) (Quit: coot)
[03:17:44] *** Quits: fendor (~fendor@91.141.70.82.wireless.dyn.drei.com) (Remote host closed the connection)
[04:13:59] *** Joins: kokobd (~kokobd@103.121.208.235)
[04:14:06] *** Quits: kokobd (~kokobd@103.121.208.235) (Client Quit)
[09:08:12] *** Quits: Heffalump (~ganesh@urchin.earth.li) (*.net *.split)
[09:08:12] *** Quits: wz1000 (~zubin@static.11.113.47.78.clients.your-server.de) (*.net *.split)
[09:08:13] *** Quits: Lierdakil (~lierdakil@94.158.171.19) (*.net *.split)
[09:08:13] *** Quits: dminuoso (~dminuoso@user/dminuoso) (*.net *.split)
[09:08:14] *** Quits: Morrow (~user@bzq-110-168-31-106.red.bezeqint.net) (*.net *.split)
[09:08:14] *** Quits: agander_m (sid407952@id-407952.tinside.irccloud.com) (*.net *.split)
[09:08:15] *** Quits: liskin (~liskin@xmonad/liskin) (*.net *.split)
[09:08:15] *** Quits: tnks (sid412124@id-412124.helmsley.irccloud.com) (*.net *.split)
[09:22:45] *** Joins: Morrow (~user@bzq-110-168-31-106.red.bezeqint.net)
[09:22:45] *** Joins: agander_m (sid407952@id-407952.tinside.irccloud.com)
[09:22:45] *** Joins: liskin (~liskin@xmonad/liskin)
[09:22:45] *** Joins: tnks (sid412124@id-412124.helmsley.irccloud.com)
[09:23:34] *** Joins: Heffalump (~ganesh@urchin.earth.li)
[09:23:34] *** Joins: wz1000 (~zubin@static.11.113.47.78.clients.your-server.de)
[09:23:34] *** Joins: Lierdakil (~lierdakil@94.158.171.19)
[09:23:34] *** Joins: dminuoso (~dminuoso@user/dminuoso)
[10:55:46] *** Quits: juhp (~juhp@bb121-6-118-149.singnet.com.sg) (Ping timeout: 245 seconds)
[11:07:29] *** Joins: fendor (~fendor@91.141.70.82.wireless.dyn.drei.com)
[11:21:06] *** Joins: arrowd (~arr@2.93.163.158)
[11:42:01] *** Joins: coot (~coot@213.134.190.95)
[12:18:07] *** Quits: coot (~coot@213.134.190.95) (Quit: coot)
[12:19:38] *** Joins: juhp (~juhp@128.106.188.82)
[12:48:10] <fendor> maerwald, I think I have misunderstood the purpose of the Makefile. I thought this is only for binary installations for users, e.g. something only ghcup has to worry about
[14:34:27] <maerwald> fendor: no, this is for general bindists
[14:34:48] <maerwald> GHC distributes dynamically linked code as well... it's basically the same
[14:35:17] <fendor> yeah, but doesn't need the makefile to be executed on the user-machine? just like ghc?
[14:35:30] <maerwald> for cabal installed libraries, we can just use patchelf on the binaries to fix the rpath, then bundle the .so from the store
[14:35:43] <maerwald> for GHC shipped libraries we need to use LD_LIBRARY_PATH hacks
[14:36:02] <maerwald> fendor: there are two makefiles, one for building the bindist and one for installing
[14:39:05] <fendor> ok and installation basically requires to find some ghc version on the PATH? Or rather, it requires the libdir
[14:40:13] <maerwald> yeah, 1. use GHC_LIBDIR if set, 2. use `ghcup whereis ghc <ver>`, 3. use `ghc-<ver>` in PATH, 4. use `ghc` in PATH
[14:40:59] <maerwald> not yet sure how this would play along with stack...
[14:41:22] <fendor> right, so what does the workflow look like for ghcup then? That basically requires that we can only install HLS if a fitting ghc version can be foudn
[14:41:26] <fendor> right?
[14:42:53] <maerwald> we could also bundle GHC libs and fall back to those when no ghc in PATH is found
[14:45:00] <fendor> if we bundle them already, couldn't we always use them? 
[14:46:10] <fendor> and with already I mean, assuming we would bundle GHC libs and fall back to those
[14:46:18] <maerwald> Is it possible that it creates incompatibilities?
[14:46:44] <fendor> I don't know, but doesn't it basically entail that we ship a whole ghc with hls?
[14:46:52] <maerwald> e.g. hls invokes cabal with a different GHC than is bundled
[14:47:14] <maerwald> I don't understand enough of hls compilation pipeline
[14:47:39] <maerwald> afaiu the project is built with system ghc and individual modules are recompiled with an internal ghc?
[14:48:46] *** Quits: m5zs7k (aquares@web10.mydevil.net) (Ping timeout: 260 seconds)
[14:49:31] <fendor> yeah, we basically compile dependencies with the same compiler cabal would, but hls compiles modules with essentially a statically linked ghc (e.g. we invoke the GHC API)
[14:49:46] *** Joins: m5zs7k (aquares@web10.mydevil.net)
[14:54:19] <maerwald> and the "GHC API" are .so's from shipped GHC or a separate hackage package/
[15:00:34] <maerwald> https://hackage.haskell.org/package/ghc
[15:06:21] <fendor> hackage package, afaict
[15:06:37] <maerwald> well, but the .so is in the GHC libdir
[15:06:40] <maerwald> libHSghc-8.10.7-ghc8.10.7.so
[15:06:59] <maerwald> so, imo... it's better to not ship it
[15:08:00] <maerwald> HLS doesn't work without a ghc binary in PATH, right?
[15:08:53] <maerwald> afair, even if cabal.project specifies a custom PATH to a ghc binary, HLS will choke and assume `ghc` in PATH is the same
[15:09:37] <fendor> yeah, HLS doesn't work without a ghc binary
[15:10:11] <maerwald> so then it may be ok for the wrapper script to require that as well
[15:10:17] <fendor> tbf, hie-bios rather chokes on cabal.project ghc versions
[15:10:52] <maerwald> so even when you use stack with HLS, it requires a ghc binary in PATH?
[15:11:45] <fendor> yeah, but it asks stack for the ghc binary
[15:11:51] <fendor> which subsequently installs it
[15:13:02] <maerwald> haskell-language-server or haskell-language-server-wrapper?
[15:14:20] <fendor> hie-bios which is called by both of them
[15:16:22] <fendor> hls needs from hie-bios the libdir, hls-wrapper needs the ghc version of the project to launch the correct hls version
[15:17:26] <maerwald> hm, that's a problem... it could be solved in hls-wrapper, because that one can be statically linked... then we could shove the "ghc libdir detection" logic into hls-wrapper
[15:20:13] <fendor> and hls-wrapper would then execute `make install`? 
[15:20:21] <maerwald> what? 
[15:20:55] <maerwald> no, hls-wrapper just detects ghc binary to use for the project, then figures out the libdir of that ghc, then adjusts LD_LIBRARY_PATH to invoke actual hls binary
[15:21:13] <fendor> ok sure that's easily possible
[15:21:34] <maerwald> but that would mean we don't expose the actual hls binary to the user...
[15:21:42] <maerwald> to avoid the wrapper script
[15:22:36] <fendor> you wouldn't be able to launch hls without the wrapper then, I presume? At least not without explicitly setting LD_LIBRARY_PATH?
[15:23:15] <maerwald> yeah... a workaround would be to add a --print-libdir switch to hls-wrapper binary and re-use that in the hls wrapper script (I guess this sounds confusing)
[15:24:10] <maerwald> so we would have: 1. statically linkd hls-wrapper binary that calls dyn hls binary, 2. dyn hls binary, 3. hls binary wrapper script that calls hls-wrapper to find ghc
[15:24:48] <maerwald> so ghc detection logic is only in statically linked hls-wrapper binary
[15:30:40] <maerwald> where is the ghc binary detection logic? I can't see it in hie-bios API
[15:33:00] <maerwald> ah https://hackage.haskell.org/package/hie-bios-0.8.1/docs/HIE-Bios-Environment.html#v:getRuntimeGhcVersion
[15:33:14] <maerwald> but that's just the version
[15:33:39] <maerwald> https://hackage.haskell.org/package/hie-bios-0.8.1/docs/HIE-Bios-Environment.html#v:getRuntimeGhcLibDir
[15:35:29] <maerwald> yeah, this looks easy
[15:43:05] *** Joins: coot (~coot@213.134.190.95)
[15:51:16] <jneira[m]> we have a contributor in windows using stack, for the record 
[15:51:25] <jneira[m]> lets take care of them :-) 
[15:51:55] <jneira[m]> fendor: they have some problems with the cradle :-/ 
[15:52:42] <jneira[m]> jneira[m]: for when we discuss changes based on what kind of contributors exists or dont
[15:52:58] <jneira[m]> https://github.com/haskell/haskell-language-server/issues/2683
[16:22:23] <fendor> maerwald, yeah, the logic is rather simple
[16:41:10] *** Joins: fendor_ (~fendor@178.165.184.56.wireless.dyn.drei.com)
[16:43:42] *** Quits: fendor (~fendor@91.141.70.82.wireless.dyn.drei.com) (Ping timeout: 256 seconds)
[16:58:40] <fendor_> jneira[m], do we run the tests with stack even?
[17:00:35] <jneira[m]> in ci no, contributors using stack would have done it i guess (and hope!)
[17:00:53] <jneira[m]> i did not for long time
[17:02:49] <jneira[m]> the question is about 2683? btw thanks for taking a look in anycase
[17:03:02] <jneira[m]> they wrote: `Every single file, both source and test, gives the following error:`
[17:03:53] <fendor_> jneira[m], yeah I am looking into it at the moment
[17:04:19] <fendor_> Not sure what to make of the bug report at the moment, I've asked some questions for clarification
[17:05:18] <jneira[m]> nice, they are needed indeed
[17:08:54] <fendor_> well, I can at least reproduce the error message on cli
[17:11:00] <fendor_> damn, the cli tool seems to be broken af
[17:11:30] <jneira[m]> ugh
[17:11:36] <jneira[m]> beyond the known bug?
[17:12:00] <jneira[m]> (`Maybe.fromJust: Nothing` one)
[17:12:33] <jneira[m]> i've lost track of what pr could habe broken it tbh
[17:12:39] <jneira[m]> s/habe/have/
[17:12:46] <fendor_> yeah, that it fails to load this testdata file...
[17:13:11] <fendor_> that could have been me though, since we no longer canonicalise all paths, maybe something slipped through
[17:14:27] <fendor_> lol, no, the testdata files are probably only missing the .hs extension
[17:15:06] <jneira[m]> ?? in the local copy of bradn?
[17:15:19] <jneira[m]> or the code is doing that?
[17:15:23] <fendor_> no, in the master
[17:15:31] <jneira[m]> wtf in both cases
[17:15:42] <fendor_> https://github.com/haskell/haskell-language-server/blob/master/test/testdata/redundantImportTest/hie.yaml
[17:15:49] <fendor_> these are not proper source ifles
[17:15:52] <fendor_> *files
[17:16:02] <fendor_> should be "src/CodeActionRedundant.hs"
[17:16:18] <jneira[m]> uh
[17:16:21] <fendor_> then it works for me
[17:16:31] <fendor_> for this file at least (which is the one in the bug report)
[17:16:38] <jneira[m]> and how is working in the tests runs?
[17:16:40] <fendor_> but I don't understand how the tests didnt fail
[17:16:42] <jneira[m]> not changed for 14 months
[17:16:54] <jneira[m]> many months are those
[17:17:04] <jneira[m]> hie-bios change?
[17:17:15] <jneira[m]> or how hls uses it?
[17:17:26] <fendor_> https://github.com/haskell/haskell-language-server/blob/master/test/functional/FunctionalCodeAction.hs#L169 should fail
[17:17:37] <fendor_> no idea, there were no module loading changes afaik
[17:19:01] <fendor_> where are the test flows?
[17:19:21] <fendor_> found them
[17:20:25] <fendor_> that test-case is green in CI
[17:20:49] <fendor_> are we writing additional hie.yaml's in some test step maybe?
[18:19:13] <maerwald> fendor_: https://github.com/haskell/haskell-language-server/pull/2675/commits/91e7915d1b4d8cbcd243f358e47ebdc46a8ddb05#diff-c439338faccfcf78b6713535ed01a419e4c01852e7c94004e1bec2d536098642R114-R119
[18:20:22] <maerwald> I tried such a bindist in a clean fedora 34 container... it worked
[18:21:49] <fendor_> maerwald, pretty cool!
[18:21:57] <maerwald> I'm gonna try with stack
[18:26:40] <maerwald> seems to work as well, even with all system GHCs deleted
[18:39:32] <fendor_> one issue are the error messages, for example when a user is oom
[18:39:42] <fendor_> I mean disk space
[18:39:48] <fendor_> and the stack download fails
[18:40:53] <maerwald> well, that's not my problem :D
[18:41:53] <fendor_> true
[18:41:55] <maerwald> here's a bindist https://downloads.haskell.org/~ghcup/tmp/hls-dyn/haskell-language-server-Linux-1.6.1.0.tar.xz
[18:42:03] <maerwald> built on fedora 34
[18:45:23] <fendor_> looks very promising to me! It is a bit tricky though, for debugging purposes we usually tell people to run `haskell-language-server` directly which is then no longer possible, right?
[18:45:51] <maerwald> it is
[18:46:14] <maerwald> that will invoke `haskell-language-server-wrapper --print-libdir`
[18:46:29] <maerwald> which just prints the ghc libdir and exists
[18:46:32] <maerwald> *exits
[18:48:28] <maerwald> I explained it here https://github.com/haskell/haskell-language-server/pull/2675#issuecomment-1028034778
[18:48:46] <fendor_> lol, so HLS launches HLS-wrapper (for print-libdir), and HLS-wrapper's purpose is to launch the correct HLS version?
[18:49:29] <fendor_> I see in the comment
[18:49:32] <fendor_> well explained
[18:49:52] <maerwald> hls-wrapper is multi-purpose so to speak
[18:50:07] <fendor_> now it is multi-purpose
[19:33:40] *** Quits: Morrow (~user@bzq-110-168-31-106.red.bezeqint.net) (Ping timeout: 250 seconds)
[19:34:44] *** Joins: shapr (~user@pool-173-73-44-186.washdc.fios.verizon.net)
[19:35:30] *** Joins: Morrow (~user@bzq-110-168-31-106.red.bezeqint.net)
[19:44:56] *** Quits: Morrow (~user@bzq-110-168-31-106.red.bezeqint.net) (Ping timeout: 250 seconds)
[19:46:39] *** Joins: Morrow (~user@bzq-110-168-31-106.red.bezeqint.net)
[20:28:57] <michaelpj[m]> I really like being able to just run `haskell-language-server` if I know what I'm doing
[20:29:12] <michaelpj[m]> I guess this magic will only affect the binary distributions, not building HLS from source?
[20:32:02] <maerwald> michaelpj[m]: just running `haskell-language-server` works flawlessly
[20:32:16] <maerwald> and yes, these wrappers are just used when installing from such a bindist
[20:32:38] <maerwald> it is not much different from how GHC packages itself
[21:29:01] *** Quits: shapr (~user@pool-173-73-44-186.washdc.fios.verizon.net) (Read error: Connection reset by peer)
[21:30:15] *** Joins: shapr (~user@pool-173-73-44-186.washdc.fios.verizon.net)
[21:34:24] *** Quits: Morrow (~user@bzq-110-168-31-106.red.bezeqint.net) (Ping timeout: 256 seconds)
[21:36:23] *** Joins: Morrow (~user@bzq-110-168-31-106.red.bezeqint.net)
[22:05:32] <wz1000> maerwald: I'm a little confused, how do system libraries work with your patch?
[22:05:45] <maerwald> wz1000: what do you mean?
[22:06:00] <wz1000> how is glibc linked?
[22:06:25] <wz1000> I downloaded the binaries linked at the top of the MR and its a fully static executable
[22:06:28] <maerwald> dynamically... the idea is to ship for all major distros like GHC itself does
[22:06:53] <maerwald> see these tarballs: https://gitlab.haskell.org/maerwald/haskell-language-server/-/pipelines/46874
[22:07:23] <wz1000> ok, that makes sense
[22:07:39] <maerwald> for linux debian 10: https://gitlab.haskell.org/maerwald/haskell-language-server/-/jobs/925891/artifacts/raw/out/haskell-language-server-1.6.1.0.tar.xz
[22:07:50] <wz1000> so the earlier binaries are busted?
[22:08:12] <maerwald> which one
[22:08:42] <maerwald> I didn't build any fully static executables
[22:08:50] <maerwald> I'm on fedora, that's not even possible here
[22:09:14] <wz1000> https://downloads.haskell.org/ghcup/tmp/hls-dyn/
[22:09:31] <maerwald> maybe you checked ldd on the wrapper script?
[22:10:02] <maerwald> anyway... the CI ones should work
[22:10:39] <wz1000> nevermind me, I used the wrong binary...
[22:10:46] <maerwald> is there an integration test for hls executable?
[22:10:52] <maerwald> I'd like to add a dogfood test
[22:11:03] <wz1000> all the tests call the hls/ghcide executables
[22:11:53] <maerwald> yeah, but I mean without the repo/haskell tests, just the exe
[22:12:43] <wz1000> I don't think so. You can run the benchmark script on the executables
[22:12:55] <wz1000> with an appropriate config
[22:13:04] <wz1000> It can pull in sources from github or hackage
[22:13:56] <maerwald> shake-bench?
[22:14:01] <wz1000> yeah
[22:16:19] *** Quits: arrowd (~arr@2.93.163.158) ()
[22:27:53] <maerwald> I have no idea how to run those. There's not even an exe
[22:30:43] <wz1000> ghcide/bench
[22:32:00] <maerwald> I think I'll rather run it on a small project
[22:40:30] <wz1000> is github 500ing for anyone else?
[22:40:52] <maerwald> I don't see `ghc-pkg describe`... where is that from
[22:41:11] <wz1000> oh, ghc-pkg field
[22:41:35] <wz1000> `ghc-pkg field ghc-8.10.7 abi` for example
[22:42:45] *** Quits: Morrow (~user@bzq-110-168-31-106.red.bezeqint.net) (Ping timeout: 256 seconds)
[22:43:00] *** Joins: Morrow (~user@bzq-110-168-31-106.red.bezeqint.net)
[22:44:41] <maerwald> hm... I think we can solve this much easier... the build machine will just recored the output of `ghc-pkg field ghc abi` in the bindist, namely in the wrapper script
[22:45:26] <maerwald> the Makefile produces the wrappers and already does some variable substitution
[22:46:46] <wz1000> not just ghc, but its dependencies too
[22:52:42] <maerwald> that can be done via shell script yeah
[22:53:21] <maerwald> ghc-pkg field ghc depends --simple-output
[23:03:37] <maerwald> now I wonder how stable the abi is
[23:05:19] <maerwald> ok, so abi between debian10 and fedora bindist match
[23:05:36] <maerwald> I get a mismatch between alpine and fedora (unsurprisingly)
[23:13:55] *** Quits: Morrow (~user@bzq-110-168-31-106.red.bezeqint.net) (Ping timeout: 256 seconds)
[23:15:27] *** Joins: Morrow (~user@bzq-110-168-31-106.red.bezeqint.net)
[23:33:44] <maerwald> ghc -e 'import System.Environment; getExecutablePath' <-- how to make this work again?
[23:33:56] <maerwald> yields "error: expecting a single import declaration"
[23:35:41] *** Quits: juhp (~juhp@128.106.188.82) (Ping timeout: 256 seconds)
[23:37:29] *** Joins: juhp (~juhp@128.106.188.82)
[23:54:14] <wz1000> you can just use `ghc -e System.Environment.getExecutablePath`
[23:55:04] <maerwald> it's a little hairy, because HieBios exposes getRuntimeGhcLibDir and getRuntimeGhcVersion but not the path to ghc :o
[23:59:48] <wz1000> maerwald: btw for 9.0.2 atleast, the ABI hashes for each official distribution are different
