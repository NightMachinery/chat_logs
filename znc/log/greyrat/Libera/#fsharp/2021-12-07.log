[02:18:01] *** Quits: kuribas (~user@ptr-25vy0i7z7uknhuz4b8c.18120a2.ip6.access.telenet.be) (Quit: ERC (IRC client for Emacs 26.3))
[07:34:02] *** Quits: biberu (~biberu@user/biberu) (Ping timeout: 240 seconds)
[07:42:15] *** Joins: biberu (~biberu@user/biberu)
[08:47:01] *** Quits: biberu (~biberu@user/biberu) (Ping timeout: 240 seconds)
[08:54:32] *** Joins: biberu (~biberu@user/biberu)
[16:26:07] *** Quits: stenno (~stenno@user/stenno) (Ping timeout: 252 seconds)
[17:28:16] *** Joins: stenno (~stenno@user/stenno)
[22:00:39] <MatthiasVance> Hm I guess I keep coming back to this, is there a neat way to pipe forward if the output is a task?
[22:01:33] <MatthiasVance> someFunctionThatReturnsTask |> someOtherFunctionThatTakesRawOutput
[22:01:53] <akronymus[m]> `>>` ?
[22:02:10] <akronymus[m]> Oh wait.
[22:02:18] <akronymus[m]> Task.bind maybe?
[22:05:24] <MatthiasVance> Is there such a thing ?
[22:05:26] <MatthiasVance> :o
[22:05:43] <akronymus[m]> Dunno, tbh.
[22:05:56] <akronymus[m]> Altough, wouldnt await work?
[22:07:08] <akronymus[m]> https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/task-expressions nvm, async await is something different
[22:07:37] <MatthiasVance> Usually you wrap your code in another task and do let! or something, but that is ugly, I want pipelines!
[22:07:45] <MatthiasVance> Especially since this code becomes laaarge
[22:08:33] <akronymus[m]> btw, you by chance doing advent of code?
[22:08:42] <MatthiasVance> nope not this year
[22:11:05] <akronymus[m]> Oh. Fair.
[22:11:25] <akronymus[m]> Some of them so far were quite annoying to solve with f#
[22:13:01] <MatthiasVance> akronymus[m]: Why is that?
[22:13:12] <MatthiasVance> biberu: Do you have any idea btw?
[22:13:37] <akronymus[m]> VERY imperative challenges at some pointm
[22:13:51] <akronymus[m]> Lots of bitbashing in one
[22:14:15] <MatthiasVance> ahh
[22:15:16] <akronymus[m]> but others were basically free with f#
[22:28:59] <biberu> MatthiasVance: what was the question?
[22:29:25] <biberu> MatthiasVance: piping task?
[22:29:49] <MatthiasVance> Yeah
[22:30:17] <MatthiasVance> I am thinking I could just have the task as input for the next but that's weird
[22:30:24] <MatthiasVance> Because then you can't reuse it
[22:31:01] <biberu> in the past I've converted it to async and made helpers for Async.map, Async.bind etc, with 6 i suppose it just leave it as a Task but make the corresponding helpers 
[22:33:25] <biberu> e.g. module Async = let map fn av = async { let! v = av; return fn v }
[22:33:37] <biberu> pardon the formatting, on a phone
[22:39:53] <biberu> then it should become someFunctionThatReturnsTask |> Task.map someOtherFunctionThatTakesRawOutput (or possibly .bind if that returns a task too)
[22:40:04] <biberu> is that what you meant MatthiasVance?
[22:40:07] <MatthiasVance> Ohh right you just wrap them but return the result of the function!
[22:40:18] <MatthiasVance> This will help tomorrow, thank you!
[22:40:36] <biberu> np, happy to help :)
[22:42:55] <biberu> MatthiasVance: that is easy to combine to create e.g. AsyncOption.foo and so on btw
[22:48:53] <biberu> MatthiasVance: another option for piping could be to lift the next function
[22:50:00] <biberu> if you have e.g. f :: a -> b, then Task.lift f would create a function Task<a> -> Task<b>
[22:51:23] <biberu> someFunctionThatReturnsTask |> Task.lift someOtherFunctionThatTakesRawOutput (which looks the same in this case)
[22:52:09] <biberu> it becomes more interesting if you lift a -> b -> ... -> r
[22:53:12] <MatthiasVance> I would have to look into that
[22:53:25] <MatthiasVance> How would one write a lift function?
[22:53:45] <biberu> https://fsharpforfunandprofit.com/posts/elevated-world/#lift
[22:54:25] <biberu> there's an example for option there
[22:55:29] <biberu> it allows you to bring regular functions into other contexts, pretty cool
[22:56:38] <biberu> got add? need to add option? result? task? just use the proper lift
[23:31:42] <MatthiasVance> Ah right, thanks a lot biberu!
[23:32:04] <MatthiasVance> I saw all these matches and knew it could be rewritten so much cleaner
[23:32:14] <MatthiasVance> (In the code I was viewing)
[23:43:08] <Deide> MatthiasVance: You can sometimes reach for the "kleisli composition operator" - otherwise known as the fish (>=>). There's actually a small section on it in the article biberu linked, under `Kleisli world`.
[23:45:53] <Deide> If you search for >=> here: http://fsprojects.github.io/FSharpPlus/tutorial.html you can see a small example
[23:46:05] <biberu> fish operator <3
[23:46:51] <biberu> MatthiasVance: yeah, I've found it useful to be suspicious of matching
