[00:05:43] *** Joins: kariosfox (~kariosfox@176.221.124.50)
[00:06:28] <kariosfox> hello
[00:06:34] <kariosfox> ?
[00:11:19] *** Quits: ss4 (~wootehfoo@user/wootehfoot) (Ping timeout: 258 seconds)
[00:30:24] *** Joins: markong (~kvirc@213.146.188.203)
[00:34:41] <Alipha> kariosfox: hi
[00:35:12] <Alipha> i just got here. i'm looking
[00:36:29] <kariosfox> looking at what
[00:36:36] <Alipha> kariosfox: at your code
[00:36:44] <Alipha> kariosfox: eh. = is assignment in c++. you want == to compare for equality
[00:36:50] <Alipha> all your = in your if statements should be ==
[00:39:24] *** Quits: CodeMouse92 (~CodeMouse@user/codemouse92) (Quit: Oh freddled gruntbuggly | Thy micturations are to me | As plurdled gabbleblotchits | On a lurgid bee)
[00:40:55] <Alipha> kariosfox: so besides that, what's your problem?
[00:41:00] <Alipha> (i see several problems)
[00:42:24] <Alipha> i mean, the compiler gives you error messages. do you not understand them?
[00:44:23] <kariosfox> It worked when I only had it read the file and check the length. I guess I nessed up with the  for loop for checking for the individual characters but I don't know what exactly I did wrong.
[00:45:19] <Alipha> kariosfox: i already said you need to change = to ==
[00:45:31] <kariosfox> I did.
[00:45:37] <kariosfox> it did nothing.
[00:46:04] <kariosfox> *didn't change the result
[00:48:25] <Alipha> `int let[5];` allocates an array with 5 elements, numbered let[0] to let[4] with _unspecified_ initial values. presumably you want to initialize them to 0, and you're accessing let[6], so you need at least an array of size 7. so `int let[7] = {};` will initialize a 7-element array to all zeros
[00:49:13] <Alipha> otherwise, it seems to work to me
[00:49:49] <kariosfox> ah
[00:50:20] *** Quits: kylese (~kylese@p5dd8b9e7.dip0.t-ipconnect.de) (Quit: Leaving)
[00:50:25] <kariosfox> I  was meaning to increment a value within an array.
[00:51:21] <kariosfox> by let[5] I meant the 6th  cell of the array.
[00:53:28] <Alipha> kariosfox: if you're compiling using g++ or clang++, I strongly recommend compiling with these flags: -W -Wall -pedantic -D_GLIBCXX_DEBUG -fsanitize=address,undefined,leak
[00:54:21] <Alipha> The first 3 will give you compile warnings. Pay attention to them--the compiler is smart. The last 2 will catch mistakes at runtime
[00:56:27] <kariosfox> I'm using gcc. 
[00:59:45] <kariosfox> thing is I don't understand the warning I'm getting . presumably, it's not liking that i'm using size_t instead of int (had it recommended here)
[01:05:22] <kariosfox> i realised a few things I did wrong thing is it's still not  compiling.
[01:06:55] <kariosfox> tbh, after I added the flags to the compiler the warning are way more cryptic
[01:07:58] <FuzzyBottom> I am just learning C++ so I probably cannot sort it out, but if you update your file for us to look at, that would help.
[01:10:13] <Alipha> Unfortunately, "I don't understand the warnings" doesn't mean you should ignore them :-)
[01:10:53] <FuzzyBottom> This compiles, but not sure if what you want is what I got working: https://www.online-ide.com/ObJrfqap58
[01:11:09] <FuzzyBottom> Sorry if I am totally on the wrong page.
[01:11:58] <kariosfox> WTF I JUST ADDED A \n in a cout and now it compiles
[01:12:49] <kariosfox> however one of the values is way off
[01:15:55] *** Joins: Raziel (~Raziel@user/raziel)
[01:16:20] <kariosfox> https://ideone.com/rcUfvj here's the new  code
[01:17:49] <kariosfox> so now we need to figure out what's throwing off the let[5]
[01:18:19] <kariosfox> the value seems random,
[01:21:35] <FuzzyBottom> I think you messed up the == again. If I am on let[5] you have let[5] = 1 + let[] (which I believe is correct), the the others you have let[#] == (which is comparing the two)
[01:21:57] <FuzzyBottom> *If I am right...
[01:24:18] <kariosfox> yeah, i fixed it
[01:24:31] <kariosfox> it's still way off though
[01:24:39] <kariosfox> *that
[01:25:07] <cbreak> let is uninitialized
[01:25:08] <kariosfox> might have soemthign to do with the fact that the eamount is exactly 10
[01:25:56] <cbreak> you must initialize it before reading from it
[01:28:32] <kariosfox> why does it affect only let[5] then?   apparently it was initialized for all of the others.
[01:29:08] <kariosfox> if it somehow became unintialized, i don't know how.
[01:30:19] <cbreak> no
[01:30:30] <cbreak> kariosfox: the whole array is uninitialized
[01:30:36] <cbreak> what do you expect to be stored in it?
[01:35:11] <kariosfox> i want the array to store the number of times chosen letters were used in the string, every time  the given character matches  with  a letter it increments a value within a cell.
[01:35:11] *** Quits: PJBoy (~PJBoy@user/pjboy) (Ping timeout: 264 seconds)
[01:35:32] <cbreak> you should initialize it with 0 then
[01:35:52] <cbreak> unsigned let[7] = {};
[01:37:48] <kariosfox> now they're  all zeros.
[01:38:15] <louiz> yes, thatâ€™s the point
[01:38:23] <cbreak> kariosfox: that's good
[01:38:27] <cbreak> that's what you want
[01:38:46] <cbreak> kariosfox: also, you discard all the "false" your comparison of let[x] and let[x] + 1 returns
[01:38:58] <cbreak> since, obviously, comparing those two values will never be true.
[01:39:26] <cbreak> (this is an other hint in the same direction as what FuzzyBottom previously mentioned)
[01:40:27] <kariosfox> ah
[01:41:56] <kariosfox> I was confused  I thought I remembered == wrong.
[01:42:37] <cbreak> kariosfox: do you know ++?
[01:43:32] <kariosfox> well yeah
[01:43:59] <kariosfox> since I've used it in the for loops
[01:44:22] <cbreak> it'd be good to use it there too
[01:45:18] <kariosfox> idk
[01:45:26] <cbreak> { std::map<char,unsigned> histogram; for (char c : "pizza napoli") histogram[c]++; std::cout << histogram; }
[01:45:27] <geordi> {{'\0', 1}, {' ', 1}, {'a', 2}, {'i', 2}, {'l', 1}, {'n', 1}, {'o', 1}, {'p', 2}, {'z', 2}}
[01:45:51] <kariosfox> It could prove confusing both to me and the compiler
[01:48:46] <kariosfox> thing is I don't know how would I convert a c++ string into a c-string if I needed.
[01:49:20] <cbreak> std::string has a c_str() member function
[01:52:31] *** Joins: ss4 (~wootehfoo@user/wootehfoot)
[01:52:40] <kariosfox> ah
[01:52:55] <kariosfox> thanks everyone
[01:56:29] *** Joins: smallville7123 (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au)
[02:20:47] *** Quits: kariosfox (~kariosfox@176.221.124.50) (Remote host closed the connection)
[03:13:15] *** Quits: markong (~kvirc@213.146.188.203) (Ping timeout: 260 seconds)
[03:23:02] *** Quits: spaceangel (~spaceange@ip-89-176-181-220.net.upcbroadband.cz) (Remote host closed the connection)
[03:33:49] *** Quits: DSpider (DSpider@86.127.147.103) (Quit: Leaving)
[03:47:31] *** Joins: ferdna (~ferdna@user/ferdna)
[04:59:35] *** Quits: The_Jag_ (~The_Jag@host-87-11-42-170.retail.telecomitalia.it) (Ping timeout: 258 seconds)
[05:01:05] *** Joins: The_Jag (~The_Jag@host-95-252-5-94.retail.telecomitalia.it)
[05:20:30] *** Quits: bewees (~bewees@user/bewees) (Remote host closed the connection)
[05:26:51] *** Quits: gggpkm (~gggpkm@li2015-124.members.linode.com) (Read error: Connection reset by peer)
[06:12:08] *** Joins: DarkTrick (~DarkTrick@pl-749-047.bunbun.ne.jp)
[06:12:22] <DarkTrick> **Q** I'm searching mid grade C++ program analysis practices like "find the bug" or "what's the output of this program". Does anyone knows a site containing such?
[06:13:01] <DarkTrick> (mid grade = programs which are made of multiple files)
[06:14:55] *** Joins: gggpkm (~gggpkm@li2015-124.members.linode.com)
[06:57:39] *** Quits: NiKaN (sid385034@helmsley.irccloud.com) (Ping timeout: 258 seconds)
[06:58:25] *** Quits: ss4 (~wootehfoo@user/wootehfoot) (Ping timeout: 260 seconds)
[06:58:39] *** Joins: NiKaN (sid385034@id-385034.helmsley.irccloud.com)
[07:00:05] *** Quits: smallville7123 (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au) (Read error: Connection reset by peer)
[07:03:23] *** Joins: Fairy97 (~Fairy@2001:464a:4992:0:dd95:968b:982e:1ba9)
[07:07:37] *** Quits: Fairy (~Fairy@2001:464a:4992:0:9c0f:e957:8bda:88f) (Ping timeout: 258 seconds)
[07:29:11] *** Quits: DarkTrick (~DarkTrick@pl-749-047.bunbun.ne.jp) (Ping timeout: 264 seconds)
[07:52:36] *** Joins: ss4 (~wootehfoo@user/wootehfoot)
[08:02:58] *** Joins: DarkTrick (~DarkTrick@pl-749-047.bunbun.ne.jp)
[08:51:16] *** Joins: teut (~teut@182.64.45.94)
[08:51:33] <teut> https://godbolt.org/z/Y6TPn3nso    need to ask a few things in this code
[08:52:13] <teut> what does that  =default does?
[08:52:54] <teut> char const * message       , is it equal to       char & message    ?
[08:54:13] <teut> the second question's answer seems to be true , because I see that the assembly istructions are the same
[08:55:40] *** Quits: ss4 (~wootehfoo@user/wootehfoot) (Ping timeout: 260 seconds)
[08:59:03] <teut> and third thing is what does that virtual and override function in the derived class.  Why is it virtual? So that it can be overwritten in hierarchical inheritance? 
[08:59:10] *** Quits: ferdna (~ferdna@user/ferdna) (Quit: Leaving)
[08:59:38] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[09:05:30] *** Joins: smallville7123 (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au)
[09:07:18] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Remote host closed the connection)
[09:07:53] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[09:08:07] <DarkTrick> teut, (1) "=default" means it's using the default destructor. I.e. the generic one, that the compiler generates
[09:08:46] <teut> if you dont write the destructor, the compiler automatically generated one for you
[09:09:08] <teut> and what if I just have empty destructor?
[09:09:23] <DarkTrick> teut, (2) "char const *" (pointer to a constant char) is not equal to "char &" (reference to char)
[09:09:24] <teut> without =default I mean
[09:09:45] <teut> DarkTrick   , but the assembly is same
[09:11:03] <DarkTrick> teut, (1) AFAIK, default would generate an empty destructor for you. I'm not sure, but I think if you don't declare a destructor, it's NOT going to be virtual. So the point of "= default" here is: "I want a virtual destructor, but I want to spare me the hassle of defining one"
[09:11:49] <teut> ok, 1st is clear thanks
[09:12:16] <teut> whats the diff between pointer to a const char and reference to char?
[09:12:36] <DarkTrick> teut, (2) That might be due to optimizations of the code (I don't know how godbold works). 
[09:12:44] <teut> a reference is also a pointer its just that you do not need to derefrence
[09:12:58] <DarkTrick> teut, mom
[09:13:08] <teut> ??
[09:18:11] <DarkTrick> = moment = just wait a sec
[09:21:43] <DarkTrick> teut, (2) (ignoring the 'const' for a moment) maybe this helps: https://imgur.com/a/duhIEDu
[09:22:49] <DarkTrick> teut, (2) if you have a pointer you an an indirection. If you have a reference, you don't have an indirection
[09:23:35] <DarkTrick> teut, (2) you main problem is the distinction between pointers and references here. I think it's best to search the internet (especially youtube) regarding that
[09:26:16] <DarkTrick> teut, (3) AFAIK override does nothing with your compiled code. I think this is a good explanation: https://stackoverflow.com/a/18198377
[09:27:34] <DarkTrick> teut, (4) also giyf: search for what virtual does. You need it for this situation: Logger logger = new ConsoleLogger(); logger.LogMessage("asdf"); 
[09:28:29] <DarkTrick> If you don't have the method virtual, Logger::LogMessage would be called instead of Logger::ConsoleLogger. If you understand Java/Python/PHP: In these languages all methods are virtual.
[09:30:53] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[09:34:44] <teut> sorry was afk 
[09:35:44] <teut> ok so I understand by your img that , a ref is just like a pointer bit not it
[09:35:46] <teut> but
[09:37:29] <teut> so ref and ptr are two different states
[09:39:21] <teut> The compiler also knows that it's an override, so it can "check" that you are not altering/adding new methods that you think are overrides.   
[09:39:26] <teut> this point is bogus
[09:40:17] <teut> since I m the one whos writing override , then I already need to know that this is an overwritten virtual method
[09:40:53] <teut> you are not altering/adding new methods that you think are overrides     <<   so this is pointless
[09:42:09] <teut> yes , I ve done Python , in that first the method is looked in scope of current class, if not present then  the method from parent is called and then there is mro for MI
[09:42:41] <teut> but yes this all info was helpful, thanks for it DarkTrick
[09:45:00] <DarkTrick> teut, I didn't get the "bogus" part: you mean, you don't need override, because you already know which function you want to override?
[09:45:27] <teut> yes
[09:45:41] <teut> or it is that when I m reading the code again?
[09:45:48] <teut> lets say after a month
[09:46:06] <DarkTrick> teut, that's one example
[09:46:16] <teut> then ovverride can tell actually that this method is present in parent without going to parent
[09:46:27] <DarkTrick> teut, but also think of your program having a very difficult structure or has 1million lines of code
[09:46:28] <teut> I really like it the python way
[09:46:57] <teut> this is ok, but whatever is somewhat a dirty fix for some problem
[09:47:30] <teut> yes like the liunx kernel , 10 million lines of code ...  , too difficult to read 
[09:47:47] <DarkTrick> teut, override: think of it as a safety net the compiler generously provides to you
[09:48:03] <DarkTrick> teut, it helps preventing typos
[09:48:29] <teut> ya, that is what I saw is the thought in c++
[09:48:30] <DarkTrick> teut, talking about python means changing the topic to `virtual`
[09:48:37] <teut> while watching cppconf
[09:48:46] <teut> we dont think like this in js , python
[09:49:37] <DarkTrick> teut, you are free to make all methods in your code `virtual`. Making them non-virtual means 1) calling is faster 2) they cannot be overridden (so no `virtual` kind of means `final` in Java... but with technical differences)
[09:50:07] <DarkTrick> teut, c++ is a very technical language, while js and python are not. You need to keep that in mind when using C++
[09:50:28] <teut> final is in c++ too
[09:50:48] <teut> the meaning is actually the same,  final   virtual
[09:50:58] <DarkTrick> teut, pointer vs reference: A POINTER is a paper with your friends address on it. I is not your friends house. It just tells you where it is
[09:51:21] <DarkTrick> a REFERENCE is your friends house
[09:51:57] <DarkTrick> so essentially both leads you to your friends house, but it's two entirely different things
[09:52:31] <DarkTrick> I'm not sure, if that's technically 100% accurate, but I think thinking of it that way really helps understanding it
[09:52:32] *** Joins: ss4 (~wootehfoo@user/wootehfoot)
[09:53:52] <DarkTrick> teut, final in c++: that's where my example breaks. find out what a "virtual table" is. Then you will understand what `virtual` means and why `final` will give a little different result on a technical level
[09:53:57] <teut> yes , thanks I understand it
[09:54:33] <teut> the main thing is reference and pointer are two diffrent variables on the object that is managing an object
[09:54:49] <teut> yes I know virtual table
[09:55:04] <teut> I ve Bjarne's book
[09:58:43] <DarkTrick> teut, ah, then you know, that virtual creates an entry in the table
[09:58:55] <DarkTrick> teut, ah, then you know, that `virtual` creates an entry in the table
[09:59:27] <DarkTrick> teut, no `virtual` means no entry; I.e. no consideration of type hierarchy
[09:59:37] <teut> just a moment I m looking at that section again
[10:04:19] <DarkTrick> teut, `virtual` changes run-time behavior (virtual table entry yes/no). 
[10:05:08] <teut> the methods of the class lie freely that I understand and the vtable helps to find those functions
[10:05:11] <DarkTrick> teut, `final` is for compile-time (as far as I understand). I.e. if you method is `final` you cannot `override` it in a child. 
[10:05:23] <teut> otherwise I will need to read that chapter again
[10:07:51] <DarkTrick> teut, Note that you can have virtual overriding function in parent classes before you used  `final` 
[10:07:54] <DarkTrick> example:
[10:08:21] *** Joins: jemius (~jemius@2a01:4f8:c0c:8564::1)
[10:12:22] <teut> in a meeting
[10:12:46] <DarkTrick> teut, https://pastebin.com/785maQ07
[10:13:03] *** Joins: NovumDXW (~NovumDXW@183.12.239.113)
[10:14:19] *** Quits: NovumDXW (~NovumDXW@183.12.239.113) (Client Quit)
[10:24:20] *** Quits: DarkTrick (~DarkTrick@pl-749-047.bunbun.ne.jp) (Ping timeout: 260 seconds)
[10:28:22] *** Joins: meator (~meator@user/meator)
[10:43:37] *** Joins: PJBoy (~PJBoy@user/pjboy)
[10:50:39] *** Quits: unixpro1970 (~unixpro19@c-73-181-185-205.hsd1.wa.comcast.net) (Ping timeout: 260 seconds)
[10:54:36] *** Joins: unixpro1970 (~unixpro19@c-73-181-185-205.hsd1.wa.comcast.net)
[10:55:47] *** Quits: ss4 (~wootehfoo@user/wootehfoot) (Ping timeout: 260 seconds)
[10:59:52] *** Quits: meator (~meator@user/meator) (Quit: Leaving)
[11:00:31] *** Quits: unixpro1970 (~unixpro19@c-73-181-185-205.hsd1.wa.comcast.net) (Ping timeout: 245 seconds)
[11:00:50] *** Joins: unixpro1970 (~unixpro19@c-73-181-185-205.hsd1.wa.comcast.net)
[11:02:30] *** Joins: meator (~meator@user/meator)
[11:08:16] *** Quits: gggpkm (~gggpkm@li2015-124.members.linode.com) (Remote host closed the connection)
[11:08:44] *** Quits: unixpro1970 (~unixpro19@c-73-181-185-205.hsd1.wa.comcast.net) (Ping timeout: 258 seconds)
[11:09:51] *** Joins: unixpro1970 (~unixpro19@c-73-181-185-205.hsd1.wa.comcast.net)
[11:16:15] *** Quits: dld (~dld@2601:197:600:1210:d10e:482c:eb89:99b9) (Ping timeout: 260 seconds)
[11:19:28] *** Joins: dld (~dld@98.217.187.57)
[11:25:16] <teut>   public: foo(); // overrides A::foo, but doesn't work polymorphic
[11:25:21] <teut> what does this mean?
[11:25:37] <teut> https://pastebin.com/785maQ07  here
[11:25:43] <teut> line 35
[11:26:25] <teut> polymorphic is many forms
[11:26:44] <teut> what is non polymorphic here?
[11:35:20] <LangerJan> teut: I think that's factually wrong. class B does not derived from class A at all in this example, so it cannot override A::foo() at all
[11:35:44] <teut>  class B does not derived from class A???
[11:35:47] <teut> it does
[11:35:56] <teut> what line are you looking at?
[11:36:12] <LangerJan> teut: how do I read this paste? There is a VIRTUAL AND OVERRRIDEs section and a NO VIRTUAL section
[11:36:17] <teut> oh sorry
[11:36:21] <teut> you are right
[11:36:27] <teut> in the secong example it doesnt
[11:36:30] <teut> d*
[11:37:44] <teut> they actually forgot to write :B
[11:38:00] <teut> https://godbolt.org/z/EYWrh7558
[11:40:41] *** Joins: DSpider (~DSpider@82.79.237.129)
[11:43:24] <LangerJan> okay, are there any open questions?
[11:52:36] *** Joins: ss4 (~wootehfoo@user/wootehfoot)
[12:01:57] <teut> yes, so B().foo() ran B's foo
[12:02:07] <teut> so it did overwrite 
[12:02:29] <teut> why isnt this polymorphic?
[12:03:29] <teut> https://godbolt.org/z/Ervc9jKv7
[12:03:38] <teut> its completely polymorphic
[12:21:00] <jemius> folks, C++ vectors... If I create one without 'new', just as a variable. Than the memory behind the vector, storing its items, will be located on the Heap, correct
[12:21:02] <jemius> ?
[12:21:39] <jemius> So the vector itself, stored as a variable on the stack, is just some sort of struct/class, containing a few integers describing the capacity, a pointer to the memory etc.?
[12:22:17] <LangerJan> teut: well, in this example, there is no polymorpy going on
[12:22:59] <LangerJan> teut: polymorphy is happening with virtual methods being overridden, and having a base-class pointer calling such a method
[12:23:40] <teut> I m studying the vtable , will take time
[12:24:16] <LangerJan> geordi: { class A { virtual void foo(){cout << "A" << endl;} }; class B : A {virtual void foo(){cout << "B" << endl;} }; A *tst = new B(); tst->foo();
[12:24:16] <geordi> error: Unexpected end of request. Expected '}' or balanced code.
[12:24:17] <teut> each of A and B has vtable
[12:24:26] <LangerJan> geordi: { class A { virtual void foo(){cout << "A" << endl;} }; class B : A {virtual void foo(){cout << "B" << endl;} }; A *tst = new B(); tst->foo(); }
[12:24:27] <geordi> error: 'main(int, char**)::A' is an inaccessible base of 'main(int, char**)::B'
[12:24:37] <teut> and in the vtables there is  A::foo   B::foo
[12:24:52] <teut> what is overwriting ?
[12:27:23] <LangerJan> geordi: class A {public: virtual void foo(){cout << "A" << endl;} }; class B : public A {public: virtual void foo(){cout << "B" << endl;} }; int main(){A *tst = new B(); tst->foo();}
[12:27:24] <geordi> B
[12:27:53] <LangerJan> overriding, sorry
[12:28:41] <teut> oh georgi is the bot
[12:28:51] <teut> geordi*
[12:31:15] <teut> ya the compiler protects you from doing things wrongly
[12:31:54] <teut> that aspect , I m told several times but becomes difficult to realize when you just ve done python
[12:31:56] <LangerJan> jemius: if you instanciate a vector without new, it's scoped to live whereever you were doing it. C++ has no strict concept of "this is on the stack, this is on the heap".
[12:32:50] <LangerJan> jemius: the memory of the vector is likely to be allocated with new or something, I have no idea. You will have to check the sources/docs of your standard C++ library 
[12:32:57] <jemius> LangerJan, I'm asking because of this question: Do I have to worry about passing gigantic vectors directly as parameters, without pointers or references? Could this blow up my program?
[12:33:12] <jemius> What's the wise, idiomatic way of creating and passing vectors?
[12:33:58] <LangerJan> jemius: passing a vector by value will make a copy of its contents. So for big vectors, I'd not do that
[12:34:34] <LangerJan> jemius: pass it by reference or as a (smart) pointer
[12:34:51] <jemius> ok, check, thx
[12:42:41] *** Quits: teut (~teut@182.64.45.94) (Quit: Client closed)
[12:56:00] *** Quits: ss4 (~wootehfoo@user/wootehfoot) (Ping timeout: 260 seconds)
[13:15:56] *** Quits: LordKalma (~LordKalma@server.ruilvo.com) (Read error: Connection reset by peer)
[13:16:14] *** Joins: LordKalma (~LordKalma@server.ruilvo.com)
[13:41:21] *** Joins: markong (~kvirc@213.146.188.203)
[13:43:31] <cow_2001> is there a static analysis tool pointing at gotchas?
[13:44:09] <Raziel> clang-tidy has quite a few things that one could consider gotchas
[13:44:41] <cow_2001> someone said something about how it takes 20 years to master C++ and that is really disconcerting. is it really that bad?
[13:44:53] <cow_2001> Raziel: thanks!
[13:44:57] <Raziel> no, in actuality you can never master C++
[13:44:58] <Raziel> :p
[13:45:18] <cow_2001> :|
[13:50:16] <Raziel> "mastering" it is hard to define anyway. no, it doesn't take 20 years to be proficient and capable of making shit in C++.
[13:51:23] <cow_2001> clang-tidy complains about the "no member" std::optional and std::nullopt ~_~
[13:51:28] <cow_2001> i guess it is not the right version
[13:51:54] <cow_2001> Raziel: i am more than capable making shit in c++ ;p
[13:52:02] <cow_2001> of making
[13:52:12] <Raziel> then why do you have to ask if it is really that bad? :p
[13:52:32] *** Joins: ss4 (~wootehfoo@user/wootehfoot)
[13:52:44] <cow_2001> it is making gold that i want ;-;
[13:53:15] <Raziel> so you want to code an alchemical engine and/or fusion reactor?
[13:53:43] <cow_2001> that always reminds me the line out of The Holy Mountain where the alchemist tells the Jesus like guy that the jesus like guy is poop but the alchemist can turn him into gold
[13:53:51] <cow_2001> you know!
[13:55:07] <Raziel> Also, I'd recommend integrating clang-tidy into your editor of choice rather than running it on its own or such
[13:55:46] <cow_2001> i don't like running strange scripts from strange places
[13:56:48] <Raziel> you can find ones that you need to pay money for instead, I'm sure that guarantees their trustworthiness
[13:58:21] *** Joins: DarkTrick (~DarkTrick@pl-749-047.bunbun.ne.jp)
[13:59:16] <cow_2001> of course it does ~_~
[14:11:23] *** Joins: NiD27 (~nid27@49.205.148.101)
[14:29:07] <cbreak> if you're relaxed with your definition of mastery, it is possible to master c++ to some degree
[14:31:46] <jemius> I believe the only man who understands C++ is Stroustroup...
[14:32:26] *** Quits: meator (~meator@user/meator) (Quit: Leaving)
[14:37:03] *** Joins: spaceangel (~spaceange@ip-89-176-181-220.net.upcbroadband.cz)
[14:38:15] <Stryyker> Probably not now
[14:38:47] *** Quits: dld (~dld@98.217.187.57) (Ping timeout: 264 seconds)
[14:56:10] *** Quits: ss4 (~wootehfoo@user/wootehfoot) (Ping timeout: 260 seconds)
[15:37:53] *** Quits: artok (~azo@mobile-access-bcee2b-18.dhcp.inet.fi) (Ping timeout: 264 seconds)
[15:42:46] *** Joins: artok (~azo@mobile-access-bcee2b-18.dhcp.inet.fi)
[15:47:55] *** Quits: artok (~azo@mobile-access-bcee2b-18.dhcp.inet.fi) (Ping timeout: 260 seconds)
[15:52:32] *** Joins: ss4 (~wootehfoo@user/wootehfoot)
[16:03:07] *** Joins: joilerv_ (~joilerv@host86-191-93-41.range86-191.btcentralplus.com)
[16:04:45] *** Joins: kylese (~kylese@p5dd8b668.dip0.t-ipconnect.de)
[16:12:15] *** Joins: smallvil_ (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au)
[16:15:01] *** Quits: smallville7123 (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au) (Ping timeout: 258 seconds)
[16:16:15] *** Quits: smallvil_ (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au) (Remote host closed the connection)
[16:16:28] *** Joins: smallville7123 (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au)
[16:17:02] *** Quits: smallville7123 (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au) (Remote host closed the connection)
[16:21:41] *** Joins: dld (~dld@192.91.235.243)
[16:28:20] *** Joins: artok (~azo@mobile-access-bcee2b-18.dhcp.inet.fi)
[16:29:42] *** Quits: NiD27 (~nid27@49.205.148.101) (Remote host closed the connection)
[16:30:01] *** Joins: smallville7123 (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au)
[16:36:46] *** Quits: artok (~azo@mobile-access-bcee2b-18.dhcp.inet.fi) (Ping timeout: 245 seconds)
[16:41:58] *** Joins: artok (~azo@mobile-access-bcee2b-18.dhcp.inet.fi)
[16:49:58] *** Joins: night_wulfe (~wulfe@cpe-174-103-156-213.cinci.res.rr.com)
[16:54:00] *** Quits: night_wulfe_ (~wulfe@cpe-174-103-156-213.cinci.res.rr.com) (Ping timeout: 260 seconds)
[16:55:12] *** Joins: CodeMouse92 (~CodeMouse@user/codemouse92)
[16:55:35] *** Quits: ss4 (~wootehfoo@user/wootehfoot) (Ping timeout: 246 seconds)
[16:59:48] *** Quits: smallville7123 (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au) (Remote host closed the connection)
[17:00:01] *** Joins: smallville7123 (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au)
[17:00:05] <jessicara> not sure if this is the right channel to ask this. with modules-ts working now is it pretty much the same style expected or have people arrived on some kinda standard preferred style like single-file-module, seperate implementation or such?
[17:00:35] *** Quits: smallville7123 (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au) (Remote host closed the connection)
[17:03:26] <jessicara> seems like this whole thing might be somewhere between c++ itself and the particular build system too
[17:19:22] *** Joins: argonautx (~argonautx@i5E8673A7.versanet.de)
[17:28:47] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[17:29:50] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Client Quit)
[17:47:57] *** Joins: NiD27 (~nid27@49.205.148.101)
[17:52:37] *** Joins: ss4 (~wootehfoo@user/wootehfoot)
[18:00:56] *** Joins: bewees (~bewees@user/bewees)
[18:02:43] <bewees> Hi, what number of characters do you recommend to wrap code? I see that Google suggests 80 characters per line, Lockheed (Bjarne) style guide PDF suggested a maxmimum of 120 char per line. On Microsoft Github I see also lines exceeding 120 (such as https://github.com/microsoft/terminal/blob/main/src/renderer/gdi/gdirenderer.hpp#L81).
[18:05:03] <cow_2001> Stallman was right. https://gcc.gnu.org/codingconventions.html#Line
[18:06:56] <bewees> cow_2001, Linus argues hardware limitations shouldn't define the 80 cap length hmmm https://lkml.org/lkml/2020/5/29/1038
[18:08:55] <cow_2001> aren't there tools that do the wrapping for you so you wouldn't have to think about it? while editing set it to 80 and when committing to 120?
[18:09:10] <cow_2001> (that's speculation)
[18:09:47] <cow_2001> or the other way around, 120 when editing 80 when committing
[18:18:07] *** Quits: DarkTrick (~DarkTrick@pl-749-047.bunbun.ne.jp) (Ping timeout: 268 seconds)
[18:18:40] <bewees> Yeah, in times where everybody has a different monitor it's a good idea to change it to the specification of the project
[18:19:24] <bewees> I personally used 120 char/line in Python for a while, but I feel like <100 looks better, unless I buy a new monitor in the future where 120 might be better again :-)
[18:20:02] <cow_2001> long lines are hard to read anyways
[18:20:19] <cow_2001> no matter what monitor you have
[18:21:05] <bewees> Yeah that's also true
[18:23:37] <cow_2001> i've found that making everything as vertical as possible makes things very readable
[18:24:52] <cow_2001> but... this should be a feature of the editor, not a change in the source
[18:49:10] *** Quits: jemius (~jemius@2a01:4f8:c0c:8564::1) (Quit: Leaving)
[18:54:55] <bewees> Just tested it on my desktop on laptop. Having two windows side by side 90 is fine on my desktop, but only 80 is fine on my laptop (13.3")
[18:55:01] <bewees> s/on/and/
[18:56:21] *** Quits: ss4 (~wootehfoo@user/wootehfoot) (Ping timeout: 268 seconds)
[19:24:36] *** Parts: kylese (~kylese@p5dd8b668.dip0.t-ipconnect.de) (Leaving)
[19:52:42] *** Joins: ss4 (~wootehfoo@user/wootehfoot)
[19:57:26] *** Joins: RoKenn (~RoKenn@2001:a61:3505:d101:4932:1a64:e30d:3e70)
[19:57:26] *** Quits: RoKenn (~RoKenn@2001:a61:3505:d101:4932:1a64:e30d:3e70) (Changing host)
[19:57:26] *** Joins: RoKenn (~RoKenn@user/rokenn)
[19:58:09] *** Quits: RoKenn (~RoKenn@user/rokenn) (Client Quit)
[19:58:43] *** Quits: NiD27 (~nid27@49.205.148.101) (Quit: Leaving)
[20:21:23] *** Quits: artok (~azo@mobile-access-bcee2b-18.dhcp.inet.fi) (Ping timeout: 264 seconds)
[20:22:45] *** Joins: artok (~azo@mobile-access-bcee2b-18.dhcp.inet.fi)
[20:31:25] *** Joins: lionkor (~lionkor@beammp/staff/lionkor)
[20:55:55] *** Quits: ss4 (~wootehfoo@user/wootehfoot) (Ping timeout: 260 seconds)
[21:00:59] *** Joins: magla (~gelignite@55d48754.access.ecotel.net)
[21:02:11] *** Quits: markong (~kvirc@213.146.188.203) (Ping timeout: 264 seconds)
[21:22:49] *** Quits: raphi_nw (~raphi@static.81.107.21.65.clients.your-server.de) (Remote host closed the connection)
[21:52:33] *** Joins: ss4 (~wootehfoo@user/wootehfoot)
[21:57:00] *** Joins: kariosfox (~kariosfox@176.221.124.50)
[22:21:04] *** Joins: karios_fox (~kariosfox@176.221.124.50)
[22:24:10] *** Quits: kariosfox (~kariosfox@176.221.124.50) (Ping timeout: 260 seconds)
[22:25:59] *** Quits: karios_fox (~kariosfox@176.221.124.50) (Ping timeout: 260 seconds)
[22:32:56] *** Joins: wootehfoot (~wootehfoo@user/wootehfoot)
[22:36:23] *** Quits: ss4 (~wootehfoo@user/wootehfoot) (Ping timeout: 264 seconds)
[22:45:44] *** Joins: X-Scale` (~ARM@50.77.166.178.rev.vodafone.pt)
[22:46:47] *** Quits: X-Scale (~ARM@31.22.203.65) (Ping timeout: 258 seconds)
[22:47:54] *** X-Scale` is now known as X-Scale
[23:18:57] *** Quits: magla (~gelignite@55d48754.access.ecotel.net) (Quit: Stay safe!)
[23:21:44] <CodeMouse92> 80 really is a good limit, especially when you consider having your IDE tiled with a web browser.
[23:21:51] <CodeMouse92> Or having multiple panes open on your IDE
[23:25:58] *** Quits: lionkor (~lionkor@beammp/staff/lionkor) (Quit: quit)
[23:28:51] *** Quits: dld (~dld@192.91.235.243) (Ping timeout: 245 seconds)
[23:54:30] *** Joins: X-Scale` (~ARM@46.50.5.8)
[23:55:26] *** Quits: X-Scale (~ARM@50.77.166.178.rev.vodafone.pt) (Ping timeout: 268 seconds)
[23:56:38] *** X-Scale` is now known as X-Scale
[23:58:22] *** Vultyre is now known as BansheeVultyreee
