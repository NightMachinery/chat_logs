[00:02:41] *** Joins: spip (~bobo@37.166.180.80)
[00:02:57] *** Quits: Guest4969 (~bobo@37.166.180.80) (Ping timeout: 268 seconds)
[00:03:05] *** spip is now known as Guest4376
[00:04:06] <rgrinberg> Lwt isn't going anywhere
[00:04:57] <companion_cube> all i want is `wait : pool -> 'a Lwt.t -> 'a` ;-)
[00:05:01] <companion_cube> (with a domainslib pool)
[00:06:02] <companion_cube> rgrinberg: do you have more details? :D
[00:06:10] <rgrinberg> regarding Lwt?
[00:06:12] <companion_cube> yeah
[00:06:24] <companion_cube> curious to hear what you think will happen
[00:06:50] <rgrinberg> I know as much as you do, I just don't see all that Lwt code being thrown away over night.
[00:07:16] <companion_cube> right, I agree
[00:07:19] <d_bot> <Anurag> similarly i highly doubt async will go anywhere.
[00:07:30] <companion_cube> I'm just worried that eio will fragment further
[00:07:42] <companion_cube> and with dubious architectural choices, too
[00:08:52] *** Quits: jlrnick (~josephler@42.118.113.78.rev.sfr.net) (Remote host closed the connection)
[00:12:41] <rgrinberg> Given that we're OCaml programmers, fragmentation is inevitable :)
[00:13:17] <rgrinberg> More seriously, it seems easy to make Lwt play nice with eio apps
[00:13:21] <companion_cube> realistic, or pessimistic?
[00:13:24] <rgrinberg> at the cost of some overhead of course
[00:13:26] <companion_cube> I think eio should play with lwt
[00:13:30] <companion_cube> not the other way ðŸ˜ 
[00:13:53] <Armael> ðŸ¤”
[00:14:38] <companion_cube> I can't wait to be the grumpy curmudgeon who sticks with lwt just because I find it less annoying than eio :D
[00:15:25] <d_bot> <Anurag> At the moment the one option I can see myself switching to (instead of lwt at work, and async at home) is dune's fiber ðŸ™‚
[00:17:38] *** Joins: jlrnick (~josephler@42.118.113.78.rev.sfr.net)
[00:18:52] <d_bot> <Anurag> I also think that the io runtimes not being in the stdlib seems to be working well for Rust as well. They have `tokio` , `async-std` , and a couple other newer options designed for linux and using io_uring. Not sure if the interop story in the rust ecosystem has improved, but each alternative is approaching problems from different sides and they all seem to have their own active set of users.
[00:19:20] <companion_cube> it hurts rust as well imho
[00:19:23] <companion_cube> fragmentation is bad
[00:19:30] <companion_cube> but most people seem to be using tokio afaict?
[00:19:52] <companion_cube> (and at least they have a common future type, that's already better than OCaml :/)
[00:20:17] *** Quits: gravicappa (~gravicapp@178.214.248.83) (Ping timeout: 240 seconds)
[00:20:34] <rgrinberg> Tbh, we don't need a common future type
[00:20:57] <rgrinberg> we need a way to write code polymorphic over future implementations that isn't functors
[00:21:19] <companion_cube> I fail to see how that can happen without a common type
[00:21:48] <rgrinberg> There will never be agreement on a common future type. I see eio decided to bake in exceptions into its promise like lwt, which means that async will likely need its own thing
[00:22:08] <rgrinberg> a future has a well defined interface, write your code against that interface
[00:22:22] <companion_cube> which requires a functor
[00:22:37] <rgrinberg> hence my caveat "that isn't functors"
[00:23:18] <companion_cube> I'm not sure what you're implying, it seems impossible to me :)
[00:23:38] <rgrinberg> you don't think modular implicits would help the issue?
[00:24:12] <companion_cube> if every single function returning a future needs a `let f {Fut:FUTURE.S} : 'a Fut.t = â€¦` , then probably not
[00:24:27] <companion_cube> (not that I think this will ever happen.)
[00:24:38] <companion_cube> s/ever/in the next 10 years/
[00:24:38] <rgrinberg> Hmm, well I see nothing wrong with that signature :)
[00:24:52] <companion_cube> well it's just a local functor for every single symbol, it's also too heavy
[00:24:52] *** Joins: mro (~mro@port-92-195-182-85.dynamic.as20676.net)
[00:25:28] <rgrinberg> if it's heavy syntactically, surely that can be addressed?
[00:25:55] <d_bot> <Anurag> wouldn't you still need some form of consistency in how the various systems prefer to deal with exceptions, errors etc. The part that's always left me a little unsatisfied when abstracting over lwt and async has been the different handling of exceptions in the two systems.
[00:25:56] <companion_cube> let+future f = â€¦ ? :D
[00:27:58] <rgrinberg> yes, to write generic code you will always need to think about error handling. I don't see how that can ever be avoided until lwt and async agree
[00:28:13] <rgrinberg> luckily it's not a huge issue in practice
[00:29:44] *** Quits: jlrnick (~josephler@42.118.113.78.rev.sfr.net) (Remote host closed the connection)
[00:29:50] *** Quits: Haudegen (~quassel@178.115.237.87.static.drei.at) (Quit: Bin weg.)
[00:30:10] *** Joins: jlrnick (~josephler@42.118.113.78.rev.sfr.net)
[00:30:40] *** Quits: jlrnick (~josephler@42.118.113.78.rev.sfr.net) (Remote host closed the connection)
[00:31:50] *** Joins: jlrnick (~josephler@42.118.113.78.rev.sfr.net)
[00:35:32] <rgrinberg> companion_cube I think that the "common promise type" you suggested is actually the less practical option
[00:35:50] <rgrinberg> For example, eio's promise is thread safe while lwt's isn't
[00:35:53] <companion_cube> rgrinberg: alternatively, a common effect
[00:36:04] <companion_cube> and various implementations of `'a fut -> 'a` based on this effect :p
[00:37:37] <rgrinberg> companion_cube sure that's good too. if we had typed effects, it would also pollute your type signatures though :)
[00:37:50] <companion_cube> ðŸ¤·
[00:38:20] <companion_cube> I think we're still fucked, but well
[00:42:06] *** Joins: Haudegen (~quassel@178.115.237.87.static.drei.at)
[00:42:35] <rgrinberg> i don't know, i'm much more optimistic
[00:42:38] <rgrinberg> my only worry is JS really
[00:45:18] <d_bot> <Anurag> I probably have a naive optimistic view that even the current situation is not as bad as it might look like. Yes there are multiple libraries that are now being written in a way that the core logic is in a IO Independant library that then gets wrapped in lwt/async etc. The same libraries will now also be easy to port to eio, <new io library here> as a result.
[00:46:13] <companion_cube> sure, we can keep doing the functor thing
[00:47:06] <d_bot> <Anurag> I meant more like the approach take by httpaf, jsonm etc (where applicable).
[00:47:58] <companion_cube> I guess, it's a lot of supplementary work though
[00:48:41] <rgrinberg> Hmm, effect continuations don't capture the C stack, right?
[00:49:01] <companion_cube> I'm not sure
[00:49:31] <d_bot> <Anurag> `decompress` is another good example I guess. Its more upfront work for the core library, but in turn you get something that works really well with any kind of IO layer.
[00:52:35] <rgrinberg> Looks like C frames aren't captured. A bit of a shame
[00:53:31] *** Quits: jonasbits (~quassel@2a00:66c0:1:1::58) (Quit: No Ping reply in 180 seconds.)
[00:55:09] *** Joins: jonasbits (~quassel@2a00:66c0:1:1::58)
[01:04:12] <d_bot> <antron> markup.ml also works with any i/o library. it's internally written in cps to support that
[01:04:52] <d_bot> <antron> as opposed to a functor
[01:05:12] <companion_cube> @antron you should write on how that's done
[01:05:18] <companion_cube> I imagine it's just a particular monad
[01:06:17] <d_bot> <antron> it's probably a monad but i doesn't explicitly use `bind`
[01:06:34] <d_bot> <antron> (or map)
[01:06:55] <companion_cube> do you use a continuation every time you need to read a char, or a string?
[01:07:05] <d_bot> <antron> it's just a bunch of fairly disciplined and consistent cps with an adapter to synchronous i/o or lwt at the very outer surface
[01:07:26] <d_bot> <antron> yes
[01:08:11] <companion_cube> like that: https://github.com/aantron/markup.ml/blob/master/src/kstream.mli ?
[01:08:32] <d_bot> <antron> yes
[01:08:47] <companion_cube> I see a map function ;)
[01:08:50] <companion_cube> but ok, that's cool
[01:08:57] *** Quits: jlrnick (~josephler@42.118.113.78.rev.sfr.net) (Ping timeout: 240 seconds)
[01:08:59] <companion_cube> I have some parser combinators that also use CPS
[01:09:05] <companion_cube> (with a success and error continuations)
[01:09:10] <d_bot> <antron> that's a `map` for streams ðŸ™‚
[01:09:21] <d_bot> <antron> not for `'a cps` ðŸ™‚
[01:09:41] <companion_cube> I don't see 'a cps
[01:09:56] <companion_cube> ah, in Common
[01:10:06] <companion_cube> ahah also the double continuation
[01:10:11] <companion_cube> nice
[01:10:49] <d_bot> <antron> `type 'a cont = 'a -> unit`, `type 'a cps = exn cont -> 'a cont -> unit`
[01:11:25] <d_bot> <antron> yep it seems like "the right way" to do it ðŸ™‚
[01:11:35] <rgrinberg> without the exn cont, that is definitely a monad
[01:11:43] <rgrinberg> i'm pretty sure it's a monad even with exn cont
[01:12:07] <companion_cube> it is, yes
[01:12:34] <companion_cube> https://github.com/c-cube/ocaml-containers/blob/master/src/core/CCParse.ml#L271-L273 <-- like that for example :D
[01:12:42] <companion_cube> (this only parses strings though, easier for backtracking)
[01:25:03] *** Joins: Anarchos (~Anarchos@lfbn-ren-1-82-241.w83-205.abo.wanadoo.fr)
[01:38:52] *** Quits: Anarchos (~Anarchos@lfbn-ren-1-82-241.w83-205.abo.wanadoo.fr) (Ping timeout: 256 seconds)
[01:44:43] *** Quits: rgrinberg (~textual@2806:101e:1:83af:8095:9213:668b:97a8) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[01:47:48] *** Quits: mro (~mro@port-92-195-182-85.dynamic.as20676.net) (Quit: Leaving...)
[01:47:52] *** Quits: Guest4376 (~bobo@37.166.180.80) (Quit: Konversation terminated!)
[01:51:52] <sadiq> companion_cube, this is out of my area so I may have misunderstood but I think someone's trying to figure out how to get Lwt and Eio to coexist.
[02:12:03] *** Joins: rgrinberg (~textual@187.223.144.204)
[02:13:04] *** Quits: tizoc (~user@li296-221.members.linode.com) (Quit: Coyote finally caught me)
[02:18:48] <companion_cube> rgrinberg: also struck me : JS is already broken today
[02:18:57] <companion_cube> CPS won't work well with jsoo
[02:19:40] *** Joins: tizoc (~user@li296-221.members.linode.com)
[02:21:23] *** Joins: rgrinberg_ (~textual@187.223.144.204)
[02:22:30] *** Quits: rgrinberg (~textual@187.223.144.204) (Ping timeout: 256 seconds)
[02:22:40] <companion_cube> @antron btw the record solution is better because you can return any type, not just unit
[02:22:58] *** Quits: rgrinberg_ (~textual@187.223.144.204) (Client Quit)
[02:23:06] <d_bot> <rgrinberg> Yes, and one cannot simply capture the stack with existing JS anyway
[02:24:06] *** Joins: rgrinberg (~textual@187.223.248.37)
[02:29:37] *** Quits: rgrinberg (~textual@187.223.248.37) (Ping timeout: 240 seconds)
[02:41:23] *** Joins: rgrinberg (~textual@187.223.248.37)
[02:46:18] *** Quits: rgrinberg (~textual@187.223.248.37) (Ping timeout: 256 seconds)
[02:52:44] *** Quits: Colt (~Colt@user/colt) (Remote host closed the connection)
[02:53:14] *** Joins: Colt (~Colt@user/colt)
[02:58:51] *** Joins: rgrinberg (~textual@187.223.144.204)
[02:59:24] *** Quits: Colt (~Colt@user/colt) (Remote host closed the connection)
[02:59:50] *** Joins: Colt (~Colt@user/colt)
[03:08:17] *** Quits: rgrinberg (~textual@187.223.144.204) (Ping timeout: 240 seconds)
[03:38:17] *** Quits: xenu (~xenu@carychium-tridentatum.xenu.pl) (Read error: Connection reset by peer)
[03:41:20] *** Joins: xenu (~xenu@carychium-tridentatum.xenu.pl)
[03:57:42] *** Quits: Haudegen (~quassel@178.115.237.87.static.drei.at) (Ping timeout: 256 seconds)
[04:34:04] <d_bot> <EduardoRFS> I'm working on an IR for JS that works with tail call optimization in general so it should work with CPS, the hope is to be able to add the trampoline only when the depth of the stack is not small and bounded
[04:57:45] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 250 seconds)
[04:58:11] *** Joins: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se)
[05:22:19] *** Quits: Tuplanolla (~Tuplanoll@91-159-68-169.elisa-laajakaista.fi) (Quit: Leaving.)
[06:23:54] *** Quits: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se) (Ping timeout: 256 seconds)
[06:58:38] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[07:05:28] *** Quits: zebrag (~chris@user/zebrag) (Quit: Konversation terminated!)
[07:39:48] *** Joins: xd1le (~xd1le@user/xd1le)
[08:07:28] *** Joins: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb)
[08:08:59] *** Joins: rgrinberg (~textual@2806:101e:1:83af:75fb:59a:2ee:28fe)
[08:17:42] *** Joins: gravicappa (~gravicapp@178.214.248.83)
[08:27:38] *** Joins: Haudegen (~quassel@178.115.237.87.static.drei.at)
[08:31:17] *** Quits: shawnw (~shawn_w@152.44.212.188) (Ping timeout: 240 seconds)
[09:51:17] *** Joins: jlrnick (~josephler@2a01cb09d07580b40136b1f9438dee35.ipv6.abo.wanadoo.fr)
[09:57:38] *** Joins: shawnw (~shawn_w@c-73-225-121-73.hsd1.wa.comcast.net)
[10:08:14] *** Joins: mbuf (~Shakthi@171.61.232.157)
[10:28:32] *** Quits: gravicappa (~gravicapp@178.214.248.83) (Ping timeout: 240 seconds)
[10:37:07] *** Quits: jlrnick (~josephler@2a01cb09d07580b40136b1f9438dee35.ipv6.abo.wanadoo.fr) (Remote host closed the connection)
[11:11:25] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Ping timeout: 268 seconds)
[11:12:42] *** Quits: sagax (~sagax_nb@user/sagax) (Ping timeout: 260 seconds)
[11:18:09] *** Joins: jlrnick (~josephler@42.118.113.78.rev.sfr.net)
[11:23:45] *** Quits: jlrnick (~josephler@42.118.113.78.rev.sfr.net) (Remote host closed the connection)
[11:28:32] *** Joins: jlrnick (~josephler@42.118.113.78.rev.sfr.net)
[11:35:40] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[12:17:03] *** Quits: chrisz (sy6hubxsvn@55d4ac5c.access.ecotel.net) (Remote host closed the connection)
[12:30:55] *** Quits: grobe0ba (~grobe0ba@mars.pulpie.xyz) (Quit: ZNC 1.8.2 - https://znc.in)
[12:33:41] *** Joins: grobe0ba (~grobe0ba@mars.pulpie.xyz)
[12:42:34] *** Quits: grobe0ba (~grobe0ba@mars.pulpie.xyz) (Quit: ZNC 1.8.2 - https://znc.in)
[12:43:59] *** Joins: grobe0ba (~grobe0ba@mars.pulpie.xyz)
[13:20:08] *** Quits: rgrinberg (~textual@2806:101e:1:83af:75fb:59a:2ee:28fe) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[13:29:44] *** Joins: chrisz (sdi1gsakni@55d4d1b2.access.ecotel.net)
[13:51:21] *** Joins: Tuplanolla (~Tuplanoll@91-159-68-169.elisa-laajakaista.fi)
[13:52:16] *** Joins: mro (~mro@port-92-195-225-100.dynamic.as20676.net)
[14:04:46] <d_bot> <orbitz> Has anyone thought about a way to unify all the `with_*` patterns in various libraries and make them composable?  And would anyone adopt it?
[14:06:22] <d_bot> <orbitz> One way to do it would be an applicative interface: `With.((fun io -> output_string io "hi") <$> with_in "somefile")`
[14:06:24] *** Joins: bartholin (~bartholin@158.110.70.210)
[14:07:37] <d_bot> <orbitz> But maybe the closure overhead is unpleasant?
[14:21:42] <d_bot> <Continuation Calculus> hi
[14:21:58] <d_bot> <Continuation Calculus> does anyone have any example of usage of ephemerons?
[14:22:16] <d_bot> <Continuation Calculus> just trying to add some metadata to fragments of AST without changing its type
[14:30:04] <d_bot> <hhugo> https://github.com/janestreet/sexplib0/blob/9c8f845fd9abc461129ad055d2eb10fd8fb07cb7/src/sexp_conv.ml#L130
[14:31:37] *** Joins: gravicappa (~gravicapp@178.214.248.83)
[14:32:30] <d_bot> <Continuation Calculus> does this assume that there is already a way to index data? I thought ephemerons would be built on top of pointers
[14:35:20] <d_bot> <hhugo> I don't understand your question
[14:39:49] <d_bot> <Continuation Calculus> I have a type t, I want to create a table of `t -> metadata`. I want this table to be indexed with OCaml pointers, rather than through a `compare : t -> t -> int` or a `hash : t -> int`
[14:41:27] *** Quits: mro (~mro@port-92-195-225-100.dynamic.as20676.net) (Remote host closed the connection)
[14:49:37] <d_bot> <hhugo> Do you really need Ephemerons ? Isn't weak enough for your usecase ? Anyway, Weak.Make / Ephemeron.K1.Make should do what you want
[15:44:20] <d_bot> <Continuation Calculus> ooh, I only saw `Ephemeron.K!` and I was like "but a single value -> data isn't that useful", hahaha
[15:44:20] <d_bot> <Continuation Calculus> I'll try it thx
[15:45:59] <d_bot> <Continuation Calculus> Given that things get removed whenever the matched key is GC'd, there is no downside to making a `Ephemeron.K1.Make(...).t` a global reference, right?
[16:33:27] *** Joins: sagax (~sagax_nb@user/sagax)
[16:56:09] *** Joins: xiongxin (~Thunderbi@113.116.33.221)
[17:03:10] *** Quits: chrisz (sdi1gsakni@55d4d1b2.access.ecotel.net) (Ping timeout: 260 seconds)
[17:04:42] *** Joins: chrisz (hr5cdsa7gj@55d4ea4e.access.ecotel.net)
[17:06:36] *** Quits: Haudegen (~quassel@178.115.237.87.static.drei.at) (Quit: Bin weg.)
[17:16:09] *** Joins: cedric (~cedric@2a01:cb11:821:7c00:a172:6c71:a419:e6a4)
[17:23:20] *** Quits: xiongxin (~Thunderbi@113.116.33.221) (Remote host closed the connection)
[17:23:32] *** Joins: xiongxin1 (~Thunderbi@113.116.33.221)
[17:25:50] *** xiongxin1 is now known as xiongxin
[17:31:21] <d_bot> <VPhantom> Here's an odd one: anyone know why type `Bigarray.kind` is a GADT instead of a regular variant? Since it's just used as a kind selection flag I don't see the benefit.
[17:32:11] <d_bot> <VPhantom> (IRC users: I deleted my previous message. It's to restrict the combinations to a valid subset.)
[17:36:36] *** Quits: cedric (~cedric@2a01:cb11:821:7c00:a172:6c71:a419:e6a4) (Quit: Konversation terminated!)
[17:49:25] *** Joins: Anarchos (~Anarchos@lfbn-ren-1-82-241.w83-205.abo.wanadoo.fr)
[17:50:12] <Anarchos> i am looking for examples of color in logs (within framework Logs of dbÃ¼nzli), but in the text message, not in the header.
[17:50:21] *** Joins: mro (~mro@port-92-195-225-100.dynamic.as20676.net)
[17:55:15] *** Quits: gravicappa (~gravicapp@178.214.248.83) (Ping timeout: 256 seconds)
[17:55:33] *** Joins: spip (~bobo@37.164.34.220)
[17:55:47] *** spip is now known as Guest6754
[18:03:21] *** Quits: shawnw (~shawn_w@c-73-225-121-73.hsd1.wa.comcast.net) (Remote host closed the connection)
[18:12:03] *** Quits: mro (~mro@port-92-195-225-100.dynamic.as20676.net) (Remote host closed the connection)
[18:16:08] *** Quits: Guest6754 (~bobo@37.164.34.220) (Quit: Konversation terminated!)
[18:17:18] <companion_cube> @orbitz I'm not convinced it'd be a progress
[18:22:14] *** Joins: spip (~bobo@37.164.34.220)
[18:22:16] *** spip is now known as Guest7910
[18:27:22] *** Quits: xiongxin (~Thunderbi@113.116.33.221) (Quit: xiongxin)
[18:32:01] *** Joins: Haudegen (~quassel@91.114.49.10)
[18:37:38] <d_bot> <orbitz> @companion_cube Why so?
[18:38:06] <d_bot> <orbitz> I find implementing `with_*` functions annoying and I find mixing and matching them, especially with monad code, the pits
[18:38:10] <d_bot> <orbitz> The pits, I say!
[18:38:17] <companion_cube> heh
[18:38:20] <companion_cube> don't use monads ;) ;)
[18:38:45] <d_bot> <orbitz> Ha or I could just get my monad `withs` for free
[18:38:54] <companion_cube> more seriously, sounds like the problem is mixing monads and other effects
[18:39:04] <companion_cube> lwt has some `with` functions
[18:39:07] <companion_cube> they work well
[18:40:13] <d_bot> <orbitz> I don't think the problem is actually moandic, for example I may want to do : `CCWith.(fun inp outp -> let x = readline inp in output_string outp x) <$> open_in somethign <*> open_out somethign)`
[18:40:58] <companion_cube> ah, so a `_ t` that is basically resource tracking?
[18:41:04] <d_bot> <orbitz> yes
[18:41:07] <companion_cube> ('a -> unit) * (unit->unit) I guess
[18:41:11] <d_bot> <orbitz> that is what all the ad-hoc with stuff is?
[18:41:27] <companion_cube> the ad-hoc stuff is not reifying anything, it's just very concrete functions
[18:41:49] <d_bot> <orbitz> I'm not sure what you mean in terms of what I'm saying by that.  I'm just presenting a structure for doing with that isn't ad-hoc
[18:42:18] * qwr thinks that the algebralic effects should remove some need for monads by providing another way for managing the control flow
[18:42:35] <companion_cube> I don't know if I want a non ad-hoc thing, I don't think it brings much to the table
[18:42:39] <d_bot> <orbitz> I think the functions would have a type `('a * ('a -> unit))` and the runner (in this case applicative) would call the cleanup function when unwinding
[18:43:53] <d_bot> <orbitz> The upside is implementors don't have to care about all the ways things can fail and what to do, they just need to know how to make the thing and clean the thing up
[18:44:02] <d_bot> <orbitz> And you could functorize it over a monadic interface as well
[18:48:42] <companion_cube> not sure how, the cleanup would have to be tied to a given monad anyway (or no monad)
[18:49:37] *** Quits: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb) (Ping timeout: 240 seconds)
[18:50:08] <d_bot> <orbitz> Are you saying you don't see how a this could be useful or just whether it could be functorized over a particular monadic interface?
[18:50:48] <companion_cube> I don't see how it can be functorized over monads
[18:51:04] <companion_cube> and without that, I still don't see it being really better than ad-hoc functions :)
[18:52:03] *** Joins: x88x88x (~x88x88x@149.28.53.172)
[18:52:08] <d_bot> <orbitz> To be clear, I'm not saying the same piece of code could be, but that the `CCWith` interface could be, so you could easily make versiosn of it for different monadic interfaces
[18:52:18] <d_bot> <orbitz> So you'd have like `CCWith_lwt`
[18:52:54] *** Joins: mro (~mro@port-92-195-225-100.dynamic.as20676.net)
[18:54:00] <d_bot> <Continuation Calculus> About `Ephemeron.K1.Make`, I have to pass in both a `hash : t -> int` and an `equal : t -> t -> bool`. Which one is finer than the others? As in, does `hash a = hash b -> equal a b`, `equal a b -> hash a = hash b`, or `equal a b <-> hash a b`?
[18:57:33] <d_bot> <orbitz> What value do you believe the ad-hoc functions have?  I find this view surprising as what i'm proposing is pretty common in a number of languages (`with` in Python, `using` in C#, RIAA in C++, Java has something similar).  It seems to me that most `with_*` functions are doing the exact same thing in terms of policy, it's just different based on resource, but perhaps I'm incorrect.
[18:57:35] *** Quits: mro (~mro@port-92-195-225-100.dynamic.as20676.net) (Ping timeout: 256 seconds)
[18:58:06] <d_bot> <VPhantom> For what it's worth this is what I ended up with for a "with_" pattern (untested) with the monadic let syntax: <https://gist.github.com/vphantom/3993d4129c22fae6ec4e9a165e82d257>
[18:58:57] <d_bot> <VPhantom> Those are the relevant bits of a slightly fancier file which has generic, Unix and Lwt implementations.
[18:59:06] <d_bot> <orbitz> ohhh fancy
[18:59:21] <companion_cube> well, all of these languages have custom features for that, @orbitz
[18:59:23] <companion_cube> we don't
[18:59:38] <companion_cube> the ad-hoc functions are the simplest approximation we have
[18:59:51] <companion_cube> (I'd love to have a `using` version of let, like F#, but well)
[18:59:52] <d_bot> <orbitz> @companion_cube We don't need custom language features for that
[19:01:32] <d_bot> <VPhantom> I'm pretty happy with how my little `let&` turned out. The toughest part was getting the Lwt version behaving as intended. I know those automatic "finally" are frowned upon in some circles but they greatly simplify my day to day needs.
[19:01:56] <companion_cube> I think we do need a language feature to make it clean
[19:03:28] <d_bot> <orbitz> @companion_cube So is your push back because you believe unifying resource management doesn't add value or because you believe the only way it could add value is by modifying the Ocaml?
[19:04:46] <companion_cube> I think it'd be good if OCaml had a feature to support it (a special kind of `let`) but even that is not clearly defined
[19:04:50] <Corbin> It sounds like regardless of the value added, it requires redesigning part of the language.
[19:04:51] <companion_cube> we don't have "disposable" or anything like that
[19:05:12] <companion_cube> and I don't believe it can be unified much without language support
[19:06:06] <Corbin> Resource-management syntax only makes sense in the presence of resources. The languages you mentioned (Python, Câ™¯, C++, Java) all primarily use it for memory and atomic/exclusive access; OCaml abstracts memory, removing the biggest motivation.
[19:06:07] <d_bot> <orbitz> What is missing in @VPhantom 's implementation?
[19:07:01] <companion_cube> nothing particular, it's tied to a specified monad is all
[19:07:05] <Corbin> (Also, what would be cleaned up? e.g. Python only cleans up exception-handling state. In e.g. Haskell, the same cleanup is done with ordinary functions, and it isn't a problem.)
[19:07:15] <companion_cube> I can do the same with `let@` and regular ('a -> 'b) -> 'b with_ functions
[19:07:22] <d_bot> <orbitz> That is not true in my experience, generally i use `with` in Python for managing anything that needs to be cleaned up ,liek files, temporary dirs, all the same stuff I see `with_*` used in Ocaml for
[19:07:29] <companion_cube> it's just not much better than `with_foo @@ fun foo ->\nâ€¦`
[19:07:51] <companion_cube> python has objects with a cleanup method
[19:07:57] <companion_cube> OCaml resources often are not objects
[19:08:02] <d_bot> <orbitz> They do not need to be
[19:08:03] <companion_cube> (and ofc python has a special construct)
[19:08:14] <companion_cube> there's nothing on a `in_channel` that tells you how to clean it up
[19:08:24] <d_bot> <orbitz> Nor does there need to be
[19:08:35] <d_bot> <orbitz> I proposed the create function would return the object + cleanup
[19:09:07] <Corbin> It sounds strange, but from a language-design point, Python `with` is about memory. Like, `with open(...):` is mostly about reducing GC and FD pressure; the file object will eventually get cleaned up either way, and the cleanup is not because of `with` but because of GC finalizers on file objects.
[19:09:10] <d_bot> <orbitz> `('a * ('a -> unit))`
[19:09:31] <companion_cube> Corbin: with is aboutâ€¦ resources?
[19:09:36] <d_bot> <orbitz> No, `with` gurantees your file is closed by the end of the block
[19:09:38] <companion_cube> FDs are not memory
[19:09:52] <companion_cube> and the cleanup is definitely because of with
[19:10:28] <Corbin> The FD might not actually get closed. All that's guaranteed is that Python will forget about the FD and release any associated memory. But I see your point.
[19:10:51] <d_bot> <VPhantom> The main point in my case was indeed to guarantee that a resource will be freed.
[19:10:56] <d_bot> <orbitz> No, `with` guarantees it is closed
[19:11:19] <companion_cube> Corbin: wrong
[19:11:25] <d_bot> <orbitz> Just as in `with tempfile.TemporaryDirectory() as dname: ..` it gurantees the tempdir is cleaned up at the end
[19:11:44] <companion_cube> https://paste.isomorphis.me/tRv
[19:11:50] <companion_cube> this displays "true" at the end
[19:11:53] <companion_cube> f still exists, but it's closed
[19:14:41] <d_bot> <orbitz> @VPhantom  Thanks for sharing your implementatino
[19:14:56] <d_bot> <VPhantom> Yeah `with` and the `contextmanager` to create our own contexts was the main positive remember from my stint with Python a couple years ago. Very clean.
[19:15:59] <Corbin> companion_cube: Lucky 10000: https://github.com/python/cpython/blob/f4c03484da59049eb62a9bf7777b963e2267d187/Modules/_io/iobase.c#L225-L253 `.closed` is just a Boolean flag. In CPython, an IO handle is just flushed and then marked as closed; the actual closure of the FD happens in a GC finalizer.
[19:16:02] <d_bot> <VPhantom> Thanks @mmatalka. I'd share the whole thing but it hasn't been tested much yet. Let me know if you need the Lwt equivalent though, it was a bit of a pain to get right.
[19:16:12] <companion_cube> Corbin: seriously?
[19:16:16] <d_bot> <octachron> @Continuation Calculus : the `hash` part is used to reduce the number of calls to  `equal` (to avoid an O(n) lookup). Thus `equal` should be finer than `hash` `(equal x y â‡’ hash x = hash y)` (and `let hash _ = 0` is always valid and inefficient).
[19:16:41] <Corbin> I grok and agree with y'all about the *intent* of `with` and similar tools in various languages. What I'm trying to emphasize is how the actual implementation details are worked out; "resource" ends up being a very limited thing.
[19:17:29] <companion_cube> that's the most braindead thing I've seen in a while
[19:17:34] <companion_cube> why not close the FD
[19:17:42] <d_bot> <VPhantom> huh
[19:18:57] <companion_cube> Corbin: TIL cpython is even worse than I thought
[19:19:18] <Corbin> If you read the following procedures (and it's hard to do, so don't force yourself!) then you'll see how the GC provokes the IO object to finish cleaning itself up, "closing" and then closing for real.
[19:19:53] <companion_cube> yeah it's super ugly
[19:20:00] <companion_cube> but I don't understand why they do that?
[19:20:14] <d_bot> <Continuation Calculus> so ppx_hash would defeat the purpose right?
[19:20:15] <d_bot> <orbitz> https://github.com/python/cpython/blob/f4c03484da59049eb62a9bf7777b963e2267d187/Lib/_pyio.py#L512-L514
[19:20:16] <d_bot> <orbitz> they didn't
[19:20:39] <d_bot> <Continuation Calculus> @octachron do you mean `O(n)` in the size of the data, or in the number of elements?
[19:21:21] <d_bot> <orbitz> Oh wait I take that back
[19:22:06] <companion_cube> Corbin: still means `with` has the correct behavior
[19:22:10] <companion_cube> it's `close()` that's fucked up
[19:22:57] <d_bot> <orbitz> https://github.com/python/cpython/blob/f4c03484da59049eb62a9bf7777b963e2267d187/Lib/_pyio.py#L1759-L1770 -- this is the FileIO object which calls the `os.close`, I still believe Python is doing the correct thing for files
[19:23:37] <d_bot> <octachron> O(n) in the number of elements in the table at the time of the lookup. `ppx_hash` will allow you to derive hopefully good hashing function rather than the terrible `hash _ = 0` one.
[19:23:53] <Corbin> No worries. I'm not saying that Python is wrong. I'm saying that the conception of what resource-management syntax does is too wide, given what actually ends up being implemented.
[19:23:54] <d_bot> <orbitz> But I agree with you @companion_cube , even if Python is doign th wrong thing for fd's, the semantics of its `with` feature are clear about when it executes the resource cleanup for a context manager
[19:24:29] <companion_cube> Corbin: I'm saying python is wrong
[19:24:31] <d_bot> <orbitz> Although I believe Python does the correct thing for files, as can be seen in the lnes I linked to
[19:24:46] *** Joins: gravicappa (~gravicapp@178.214.248.83)
[19:24:55] <d_bot> <octachron> (with an ideal hashing function distributing all keys uniformly across any integer range)
[19:24:59] <companion_cube> ahhh
[19:25:01] <companion_cube> it's overloaded?
[19:25:16] *** Quits: xd1le (~xd1le@user/xd1le) (Quit: xd1le)
[19:25:23] <d_bot> <orbitz> Yes
[19:25:24] <companion_cube> @octachron which ppx_hash are we talking about?
[19:26:00] <Corbin> companion_cube: Python just implements `with` in terms of existing syntax. I'm not sure if this is always possible, but it provokes examining an assumption: could we just implement resource management with ordinary library code?
[19:26:20] <companion_cube> err, no
[19:26:25] <companion_cube> `with` is a special form of python
[19:26:36] <d_bot> <orbitz> `with` was not existing syntax
[19:27:00] <d_bot> <octachron> I was looking at https://github.com/janestreet/ppx_hash .
[19:27:18] <Corbin> Anytime you `with r() as h: f(h)` you can `h = r(); h.__enter__(); try: f(h);; except e: h.__exit__(e);; else: h.__exit__()`
[19:27:34] <d_bot> <Continuation Calculus> yup, this is the one i had in mind
[19:27:40] <Corbin> Or something like that. This sort of thing was crucial to getting `with` into RPython, where it's gotta be statically typeable.
[19:28:47] <Corbin> My point, if I have one, is: resource management can be implemented as a library with no language changes iff this sort of desugaring is possible. The proof in both directions is in the pudding; just write the library.
[19:28:48] <companion_cube> ah you mean `with` rewrites to another form internally?
[19:28:57] <companion_cube> that doesn't matter, it's still special syntax
[19:29:25] <d_bot> <VPhantom> Yeah mine is based around `try` and `Fun.protect`.
[19:29:26] <companion_cube> we can arleady do that, it's the with_ functions mentioned above; it's just not ergonomic
[19:29:38] <Corbin> Sure. And in languages that don't allow users to add new syntax, or that don't allow making new barewords that act like keywords, this could be a problem.
[19:30:07] <d_bot> <VPhantom> Wait, OCaml allows creating new barewords that act like keywords?
[19:30:13] <Corbin> Functions starting with "with_" in their names don't have anything in common, other than the name, right? You'd have to give them some common feature if you wanted to isolate them.
[19:30:49] <d_bot> <Continuation Calculus> unrelated question: in iso-recursivity, `unfold (x : mu v . body) : body[v := mu v . body]` simply requires a substitution/unfolding. but how do you implement `fold` ?? In `fold (mu v . body) (x : t[v := mu v . body]) : mu v . t`, to inverse the substitution, you have to like pattern match the whole type `t` to find instances of `mu v . body`, is that correct?
[19:31:02] <d_bot> <orbitz> "with_" functions almost always create and destroy a resource
[19:31:05] <Corbin> VPhantom: OCaml is one of many languages where a bare identifier surrounded by whitespace can act as an operator. Ruby's another, but through a totally different mechanism.
[19:31:33] <d_bot> <VPhantom> I didn't know other strings besides "mod" had that potential.
[19:31:43] <Corbin> Maybe "can act as" is ambiguous. I'm not talking about magic syntax; I'm just saying that `f x` is one bareword somehow applied to another with whitespace, so you could pick creative names like `with resource`.
[19:32:28] <d_bot> <VPhantom> Oh. Or possibly `with @@ resource ...` in a more realistic context. It's already a little bit less ergonomic.
[19:32:40] <companion_cube> `with_resource @@ fun resource -> â€¦` is my go-to
[19:32:53] <companion_cube> we don't have particularly lightweight function syntax
[19:32:57] <companion_cube> unlike ruby or kotlin, say
[19:32:59] <d_bot> <VPhantom> I considered doing that, but then the let syntax is so nice...
[19:33:11] <d_bot> <VPhantom> The wrapper just melts away.
[19:33:54] <companion_cube> with @@ it does, too
[19:33:58] <companion_cube> it doesn't indent more
[19:34:15] <companion_cube> sometimes I have 3 or 4 `foobar @@ fun () ->\n` in a row :D
[19:34:30] <companion_cube> (resource, resource, profiling guard, exception wrapper)
[19:34:34] <companion_cube> fun times
[19:34:38] <d_bot> <VPhantom> Sure, but I find `let& fd = with_file ... in` more ergonomic than the `@@` equivalent. It conveys the intention more obviously to me.
[19:35:20] <d_bot> <VPhantom> I do use my little exception trap `catch @@ fun () ->` though in a few places.
[19:35:43] <companion_cube> fun stuff: `let (let@) f x = f x;;`
[19:35:53] <companion_cube> `let@ fd = CCIO.with_in "file" in CCIO.read_all fd`
[19:35:56] <d_bot> <VPhantom> (I use `Result.t` all over, including its binding and thus I trap exceptions into results.)
[19:35:56] <companion_cube> that works :D
[19:36:21] <companion_cube> I've tried, and now I do the opposite (in my own side project, note): exceptions everywhere
[19:36:31] <d_bot> <VPhantom> Yeah but that "with" doesn't have the associated resource freeing.
[19:36:33] <companion_cube> but with an exception type that emulates traces a bit
[19:36:50] <companion_cube> CCIO.with_in does the freeing :)
[19:37:02] <companion_cube> it's just sugar for `CCIO.with_in "file" (fun fd -> CCIO.read_all fd)`
[19:37:16] <d_bot> <VPhantom> I kinda took Jane Street's lead re: exceptions. Meshes better with Lwt for me anyway.
[19:37:37] <d_bot> <VPhantom> Nice.
[19:37:55] <companion_cube> lwt kind of meshes well with exceptions actually
[19:38:03] <companion_cube> `try%lwt` and all that
[19:38:13] <d_bot> <VPhantom> I hadn't thought of using a let binding for partial application like that. Very creative.
[19:38:36] <companion_cube> it's stolen from an old discuss post of gasche
[19:38:41] <companion_cube> but it does make a lot of sense
[19:39:39] <d_bot> <VPhantom> Yeah I avoid "try" so far. Since my "business logic" stuff returns results, I just want a surprise exception to make my function return early with an error result. With Multicore I might do a 180Â° and end up with exceptions everywhere, but so far that's what I do.
[19:41:11] <companion_cube> I use exceptions but barely any `try`, I guess
[19:41:30] <companion_cube> in a context where most exceptions trickly down to the root and are logged/displayed/accumulated, I mean.
[19:41:40] <d_bot> <VPhantom> Ah, yes.
[19:42:22] <companion_cube> fwiw, the error type: https://github.com/sneeuwballen/benchpress/blob/master/src/core/Error.ml
[19:42:41] <companion_cube> (it has context, i.e. a chain link of other errors for context;  and locations to report errors wrt some input)
[19:44:56] <d_bot> <VPhantom> Interesting. So you wrap exceptions withâ€¦ where do you get the extra message?
[19:45:43] <companion_cube> I have stuff like:
[19:46:02] <d_bot> <VPhantom> Actually it says wrap needs "msg" before "e" but it's invoked with an error so I'm confused.
[19:46:05] <companion_cube> `Error.guard (Error.wrapf "we are doing foobar %s" "some stuff") @@ fun () ->`
[19:46:13] <d_bot> <VPhantom> Ah!
[19:46:25] <companion_cube> any error in the `@@ fun () -> â€¦` will be caught, wrapped, and re-raised
[19:46:29] <d_bot> <VPhantom> That reminds me of my good old C "debug_printf()" macros back in the day. ðŸ˜‰
[19:46:39] <companion_cube> well here it's all values :)
[19:49:30] <sadiq> 4
[19:49:50] <sadiq> sorry, different laptop and sketchy net connection
[19:54:37] *** Quits: x88x88x (~x88x88x@149.28.53.172) (Ping timeout: 240 seconds)
[19:57:50] *** Quits: mbuf (~Shakthi@171.61.232.157) (Quit: Leaving)
[20:01:55] *** Joins: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb)
[20:10:27] *** Quits: Anarchos (~Anarchos@lfbn-ren-1-82-241.w83-205.abo.wanadoo.fr) (Quit: Vision[]: i've been blurred!)
[20:14:01] <d_bot> <VPhantom> I would've said 3, so, you were close.ðŸ˜›
[20:16:02] *** Quits: bartholin (~bartholin@158.110.70.210) (Quit: Leaving)
[20:31:31] *** Quits: Haudegen (~quassel@91.114.49.10) (Quit: Bin weg.)
[20:36:17] *** Quits: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb) (Ping timeout: 240 seconds)
[20:52:38] *** Joins: x88x88x (~x88x88x@149.28.53.172)
[21:10:17] *** Quits: Tuplanolla (~Tuplanoll@91-159-68-169.elisa-laajakaista.fi) (Ping timeout: 240 seconds)
[21:26:35] *** Joins: Tuplanolla (~Tuplanoll@91-159-69-214.elisa-laajakaista.fi)
[21:29:38] *** Quits: x88x88x (~x88x88x@149.28.53.172) (Ping timeout: 260 seconds)
[21:36:54] *** Joins: x88x88x (~x88x88x@149.28.53.172)
[21:43:52] *** Quits: wingsorc__ (~wingsorc@user/wingsorc) (Quit: Leaving)
[21:48:18] *** Quits: gravicappa (~gravicapp@178.214.248.83) (Ping timeout: 260 seconds)
[21:56:59] *** Joins: Haudegen (~quassel@178.115.237.87.static.drei.at)
[22:28:53] *** Joins: kaph (~kaph@net-2-47-236-216.cust.vodafonedsl.it)
[22:43:57] *** Quits: x88x88x (~x88x88x@149.28.53.172) (Ping timeout: 240 seconds)
[22:53:14] *** Joins: mro (~mro@port-92-195-225-100.dynamic.as20676.net)
[22:55:57] *** Joins: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb)
[22:58:07] *** Quits: mro (~mro@port-92-195-225-100.dynamic.as20676.net) (Ping timeout: 268 seconds)
[23:13:02] *** Quits: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb) (Ping timeout: 240 seconds)
[23:21:16] *** Joins: x88x88x (~x88x88x@149.28.53.172)
[23:43:29] *** Joins: vicfred (~vicfred@user/vicfred)
[23:46:21] *** Joins: GaikTamazian[m] (~gtcomgeno@2001:470:69fc:105::1:54f5)
[23:50:45] *** Joins: rgrinberg (~textual@2806:101e:1:83af:75fb:59a:2ee:28fe)
[23:50:55] *** Parts: GaikTamazian[m] (~gtcomgeno@2001:470:69fc:105::1:54f5) ()
