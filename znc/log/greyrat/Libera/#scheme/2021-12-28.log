[00:12:13] *** Quits: xaltsc (~xaltsc@user/xaltsc) (Quit: WeeChat 3.3)
[00:19:22] *** Joins: TCZ (~tcz@91.150.178.124)
[00:21:26] *** Joins: xaltsc (~xaltsc@user/xaltsc)
[00:30:39] *** Joins: jao (~jao@211.68.17.95.dynamic.jazztel.es)
[00:31:29] *** Quits: xaltsc (~xaltsc@user/xaltsc) (Quit: WeeChat 3.3)
[00:32:58] *** Joins: xaltsc (~xaltsc@user/xaltsc)
[00:42:44] *** Quits: rito_ (~rito_gh@45.112.243.219) (Quit: Leaving)
[01:02:38] *** Quits: TCZ (~tcz@91.150.178.124) (Quit: Leaving)
[01:05:16] <karlosz> is there some summary of the state of the macro ecosystem in scheme?
[01:05:41] <dpk> in what sense?
[01:06:05] <karlosz> in the sense that, as someone new to scheme, i have no idea how to actually define any macros portably
[01:06:19] <karlosz> i find myself just wanting to reach for defmacro
[01:06:39] <karlosz> syntax-rules seems quite limited
[01:07:07] <karlosz> ive found stuff like syntactic closures, which seem way cleaner, in my opinion, but nary a mention in any sstandard referennce
[01:08:04] <dpk> the standard systems are syntax-rules (supported by everyone and their mother) and syntax-case (mostly in R6RS implementations)
[01:08:07] <Zipheir> Syntactic closures seem to be on the way out, IMO.
[01:08:25] <Zipheir> syntax-case is very nearly standard.  ER/IR are common, though not standardized.
[01:08:35] <karlosz> ER/IR?
[01:08:44] <Zipheir> Explicit/implicit rewrite macros.
[01:08:57] <Zipheir> karlosz: Also, have you read JRM's syntax-rules guide?
[01:09:05] <karlosz> nope
[01:09:15] <Zipheir> It is more powerful than you might think.
[01:09:21] <Zipheir> One sec, I'll paste it.
[01:10:47] <dpk> syntax-rules is quite powerful but fiddly. explicit renaming and syntactic closures have all the power of Scheme but are both endlessly fiddly. syntax-case hits a real sweet spot between power and usability
[01:11:55] <Zipheir> karlosz: http://www.sigwinch.xyz/misc/jrms_syntax-rules_primer.txt
[01:12:16] <dpk> i recommend learning syntax-rules well then syntax-case. the latter is very similar to the former, except that expansions are created by ordinary, arbitrary Scheme code instead of simple template replacement
[01:13:00] <Zipheir> It looks like R7RS-large is going to have ER.  Whatever that means.
[01:13:26] <Zipheir> Well, whatever flavor of ER that means.
[01:14:03] <dpk> syntax-case is currently leading the ballot, but ER also has a majority of votes
[01:14:29] <karlosz> ah yes, ER is actually essentially what i came up with myself from a defmacro background. looks pretty njatural
[01:14:34] <karlosz> cool, i didn't know about it
[01:14:35] <Zipheir> Here's the Clinger-Rees paper on ER, for another guide https://3e8.org/pub/scheme/doc/lisp-pointers/v4i4/p25-clinger.pdf
[01:14:51] <dpk> i think it was a great mistake to formulate the ballot such that both can get in
[01:14:59] <Zipheir> Or neither.
[01:15:31] <Zipheir> Of course, you can screw up hygiene completely with ER.  It's a little harder with syntax-case.
[01:15:56] <Zipheir> syntax-case, AKA the syntax monad.
[01:16:15] <karlosz> from the point of view of a language primitive, ER can expres the other macro DSLs right? since its just scheme
[01:16:39] <Zipheir> Yes.  Clinger and Rees proposed it as a building block for syntax-rules.
[01:16:40] <karlosz> i think i found something like syntax rules couldnt really emulate plain defmacro
[01:16:54] <Zipheir> That's a feature, not a bug.  defmacro is broken as hell.
[01:17:04] <dpk> ER can express syntax-rules, but not any other hygienic macro system
[01:17:20] <Zipheir> dpk: Interesting!
[01:17:22] <karlosz> why is that?
[01:17:26] <karlosz> that seems counter intuitive
[01:17:34] *** Quits: zwr (~zwr@2804:d45:b966:fb00:393a:ffee:2e04:d088) (Ping timeout: 260 seconds)
[01:17:47] <karlosz> also, gensym doesn't exist in recent schemes, right?
[01:18:07] <Zipheir> Many implementations provide a gensym procedure, but it's never been standard.
[01:18:22] *** Joins: zwr (~zwr@2804:d45:b966:fb00:9a15:fa56:81f7:4afc)
[01:18:37] <Zipheir> dpk: Do you mean that it's designed to implement the Friedman, et al hygienic expansion algorithm?
[01:19:12] <Zipheir> I'm not familiar with systems *not* based on that algorithm, so I'd be interested to know what else is out there.
[01:19:26] <dpk> because explicit renaming only gives you free-identifier=?, no bound-identifier=?, and no way to inject identifiers at arbitrary timestamps (the first argument to datum->syntax)
[01:20:07] <dpk> among other minor issues (no pattern variable ‘namespace’)
[01:20:20] <karlosz> when i was pondering how to make macros, i was thinking it would just be easy to do something like (define-macro swap! (let-syntax ((set! (syntax 'set!)) (let (syntax 'let)) (,temp (make-gensym))) (lambda (x y) (,let ((,temp ,x)) (,set! ,temp ,x) ...))))
[01:20:29] <karlosz> but i guess thats essentially just ER
[01:21:04] <karlosz> and it seems like the standard doesn't specify what to do when you have an actual transformer object in operator position
[01:21:08] <amazigh> karlosz: syntax rules is similar to defmacro except unhygenic and the syntax is different, it terms of power of description it is the same?
[01:21:30] <karlosz> so (<procedure +> 1 2) is processed by the evaluator correctly into 3
[01:21:51] <Zipheir> amazigh: Well, yes, though syntax-rules is a Turing tarpit.
[01:22:09] <karlosz> but the standard doesn't say anything about (<transformer my-macro> foo bar)?
[01:22:32] <Zipheir> karlosz: What do you mean?  The evaluator will never see such a form.
[01:22:52] <dpk> karlosz: procedures in macro expansions is undefined behaviour in Scheme
[01:23:03] <karlosz> oh really?
[01:23:05] <dpk> afaik
[01:23:13] <Zipheir> "procedures in macro expansions"?
[01:23:16] <karlosz> i tried it in mit-scheme and the evaluator seems to be happy with it
[01:23:29] <sham1> Still undefined behaviour
[01:23:36] <karlosz> like if i evaluated + by itself
[01:23:47] <karlosz> then pasted that procedure object into the opeartor position of a form
[01:23:54] <amazigh> I did not fully backlog, karlosz you want to write macro, or implement a macro machinery?
[01:24:14] <karlosz> i want to understand how macros work in scheme in general
[01:24:22] <dpk> Zipheir: dropping a raw procedure value into the expansion of a procedural macro
[01:24:29] <Zipheir> Something like (syntax-rules () ((foo f x) (f x))) ?
[01:25:00] <karlosz> i mean something like (define-macro (foo x y) `(,+ ,x ,y))
[01:25:21] <karlosz> i.e. the macro would simply capture the value of the + procedure binding
[01:25:37] <Zipheir> Oh, a procedural macro.
[01:25:59] <karlosz> if you did (define-macro (foo x y) (let ((+ +)) `(,+ ,x ,y))) then the macro would be hygienic
[01:26:18] <dpk> karlosz: https://dl.acm.org/doi/10.1145/3386330 is a good place to stay for a history and literature review re hygienic macros, mostly in Scheme though it touches on recent developments in other languages
[01:26:30] <karlosz> my question is `) is that well specified? 2) would a similar thing work for a syntax object like let instead of a proceudre like +?
[01:26:33] <dpk> * to start
[01:26:34] <sham1> Compilation phases will come crashing down whenever syntax-case makes it into R7-large. Can't wait
[01:26:34] <amazigh> karlosz: then I think starting with def-macro is good, then look into unsyntax.org (or psyntax)
[01:26:57] <amazigh> karlosz: look into alexapander, there is a copy of it in chicken-spock
[01:27:07] <Zipheir> The truth is you don't see a ton of macro use in most Scheme programs.
[01:27:10] <amazigh> karlosz: syntax-case is... a nightmare :)
[01:27:33] <karlosz> i can see why. it doesnt seem like theres a coherent story when it comes to macros...
[01:27:43] <Zipheir> There is.  So far, it's syntax-rules.
[01:27:45] <karlosz> maybe when r7rs large chooses one there will be
[01:27:46] <amazigh> karlosz: did you read the SRFI?
[01:27:47] <Zipheir> And syntax-case.
[01:28:24] <karlosz> amazigh: which one?
[01:28:38] <karlosz> Zipheir: didn't you guys  just say syntax case isn't yet in the standard?
[01:28:43] <Zipheir> It is.
[01:28:44] <sham1> It's in R6
[01:28:45] <Zipheir> R6RS.
[01:28:46] <karlosz> im worried about writing portable code
[01:28:48] <sham1> Just not R7
[01:28:59] <karlosz> i see.
[01:29:04] <Zipheir> It's going to be in R7RS-large, based on the polling.
[01:29:07] <karlosz> so what's the story with that? has r6rs just been retconned?
[01:29:17] <amazigh> retconned?
[01:29:45] <karlosz> https://en.wikipedia.org/wiki/Retroactive_continuity
[01:29:47] <sham1> Nah. It's just a parallel standard now
[01:29:48] *** Joins: livoreno (~livoreno@user/notzmv)
[01:30:44] <amazigh> without updates since 10 years :)
[01:31:10] <Zipheir> It's done.
[01:31:27] <Zipheir> Standards aren't buggy GitHub projects.  Usually.
[01:31:30] <amazigh> it is off-topic the current convo anyway
[01:31:56] <amazigh> karlosz: try to implement def-macro, then syntax-rules, and dive into syntax.org
[01:32:08] <amazigh> syntax.org implements all the things in modern r7rs
[01:32:29] <karlosz> so i want to,  like everyone and their pet cat, write  another scheme implementation. i'd like to write the loader, dumper, compiler in portable scheme, so that it can be bootstrapped from any implementation. (in the style of many common lips implementations). should i target r6rs, r7rs, r5rs, and which macro systems would it make sense to use?
[01:32:30] <amazigh> read the documentation first
[01:32:35] <Zipheir> Some of the best (IMHO) macros in Scheme are just syntax-rules.  Consider minikanren's `run'.
[01:32:44] <karlosz> i guess syntax-rules is the in r5rs, r6rs, and r7rs, so it amkes sense to use that
[01:33:03] <Zipheir> Yes.
[01:33:04] <karlosz> im just afraid syntax-rules might not be able to implement all the standardized syntax forms in r5/7rs
[01:33:23] <amazigh> how so?
[01:33:25] <karlosz> for example, cond has that unhygeinic => bit
[01:33:40] <sham1> => isn't unhygienic iirc
[01:33:42] <dpk> that’s not unhygienic
[01:33:42] <Zipheir> That's totally fine in syntax-rules.
[01:33:55] <Zipheir> I do not think it means what you think it means...
[01:34:33] <karlosz> the concept of hygiene is still new to me. my mental model is still: any identifier that gets introduced that isn't in the lexically apparent environment
[01:34:33] <Zipheir> karlosz: (syntax-rules (=>) ...) declares => to be a literal symbol.  That's all you need.
[01:34:46] <sham1> Anyway, if you want to implement a Scheme, I'd probably go R7RS if I were you, while lifting syntax-case from R6RS since syntax-case gives you syntax-rules for free
[01:35:16] <karlosz> that makes sense
[01:35:30] <karlosz> and it sounds like it might make it into to r7rs large
[01:36:42] <Zipheir> Go R4RS and dump macros. :)
[01:37:04] <dpk> hygienic means (a) identifiers have lexical scoping, so any identifiers used in the macro implementation have a meaning determined by the definition and definition site of the macro, not by the invocation site, and (b) no identifiers *not explicitly passed to the macro by its invoker* can be bound
[01:37:06] <Zipheir> Nah, I think they can be very expressive.  They're just very tricky to get right.
[01:37:44] <amazigh> karlosz: many scheme do not implement macros..
[01:37:46] <sham1> Did R4RS even have dynamic-wind?
[01:37:47] <karlosz> Zipheir: i did think about dumping macros entirely! would be a pain to write stuff like (and ....) or (or ...) without coming up with some equivalent concept though
[01:37:50] <amazigh> unpopular fact
[01:38:47] <Zipheir> sham1: No, dynamic-wind was an R5 addition.
[01:39:10] <dpk> all the special forms defined in all the RnRS standards are hygienic, afaik
[01:39:22] <karlosz> somewhat related question: is there any movement to ditch call/cc? i keep reading articles saying how much of a mistake it is
[01:39:31] <amazigh> karlosz: my recommendation is to implement R7RS-small as single namespace, and then think about how to implement syntax-case and the library thing, both a related
[01:39:41] <dpk> (i say afaik only because i don’t know R6 that well)
[01:40:19] <sham1> Can't ditch call/cc in R7-large but I at least wouldn't feel sad if it was made an optional feature
[01:40:34] <sham1> Like in any future standard
[01:40:40] <dpk> karlosz: we can’t ditch it, but we can fix it: see SRFI 226
[01:41:04] <Zipheir> It's firmly entrenched.  But delimited continuations are commonly implemented, and now SRFIfied.
[01:42:07] <sham1> Although if call/cc can be made better then do that rather than making it an optional thinf
[01:44:10] <sham1> Being able to teleport within the program continuations makes some things difficult. Including making call/cc efficient if one uses the platform control stack because suddenly you need to keep a copy of it
[01:45:39] <karlosz> yes. i'm familiar with implementing dynamic-extent continuations (one-shot), but making it indefinite extent makes things trickier from an implementation standpoint
[01:45:46] *** Quits: xaltsc (~xaltsc@user/xaltsc) (Quit: WeeChat 3.3)
[01:46:32] <Zipheir> Yes, and of dubious utility if you've got delimited conts..
[01:46:39] <karlosz> the only real difference is not needing to clean it up at a scope boundary, and saving the stack on the heap somewhere so its always accessible, until maybe the gc can figure out its not accessible anymore
[01:47:32] <karlosz> with delimited conts, the implementation strategy is still the same, right? still need to save the delimited segmenet, and you can't clean up the continuation at a scope boundary, only via GC
[01:47:40] <karlosz> or maybe you can clean it up at the prompt tag?
[01:48:41] <Zipheir> Possibly.  I haven't tried implementing them yet.
[01:49:00] <amazigh> delimited continuation are like raise?
[01:49:14] <amazigh>  with guard
[01:49:23] <amazigh> they look alike
[01:49:35] <karlosz> also, heap allocating all set! bindings is a bit annoying. im not too sure on whether theres an easy way to figure out if there are cases where set variables don't need heap allocated cells
[01:50:15] <karlosz> typically compilers can elide value cells for set! variables since whether they are also closed over is lexically apparent
[01:50:34] <karlosz> i suppose with call/cc they unconditionally need to go into value cells
[01:50:59] <karlosz> (this is assuming a flat closure representation)
[01:53:01] *** Quits: xgqt (~xgqt@gentoo/developer/xgqt) (Ping timeout: 256 seconds)
[01:53:47] *** Joins: xgqt (~xgqt@gentoo/developer/xgqt)
[01:54:44] <sham1> Escape analysis usually helps with set!s
[01:56:13] *** Quits: jao (~jao@211.68.17.95.dynamic.jazztel.es) (Ping timeout: 240 seconds)
[01:58:03] <karlosz> in what way? im only used to thinking about values cells being allocated when they are lexically closed over
[01:58:36] <sham1> For example (let ((foo 1)) (set! foo 2)), foo doesn't need to be boxed in the heap because it never escapes
[01:59:03] <karlosz> right, but the second there;s any procedure call we're hosed, right?
[01:59:11] <karlosz> since that procedure call may invoke call/cc
[01:59:29] <sham1> Although a sufficiently smart compiler™ could just see that the initial value is never used, and thus replace that value with 2, or in this case just eliminate the whole block
[01:59:41] <sham1> Well the local value foo in this case can just exist on the stack
[01:59:44] <karlosz> so even (let ((foo 1)) (f) (set! foo 2) foo) may cause foo to get a value cell
[01:59:44] <sham1> For exMpler
[02:00:28] <sham1> foo in this exists in the activation record and thus doesn't necessarily need a heap box
[02:00:44] <karlosz> since (f) may call call/cc, saving the stack onto the heap, meaning reentering the continuation and mutating it needs to update foo
[02:01:05] <karlosz> so i don't see how you can avoid heap boxing here
[02:01:54] <karlosz> or i guess if the activation record is on the heap too, and we ensure it gets updated across all possible reentries...?
[02:02:46] <sham1> Oh, so calling the continuation multiple times
[02:02:47] <sham1> Hm
[02:03:00] <karlosz> yeah
[02:03:39] <sham1> (let ((foo 1)) (f) (write foo) (newline) (set! foo 2)) that would make it observable
[02:04:24] <sham1> In that case it would indeed get a box
[02:04:25] <karlosz> but i guess you're right, in simple situations where we can figure out that no call to any procedure that could also call call/cc happens within the scope of the (let ...) means we can avoid heap boxing foo
[02:04:31] <sham1> Yeah
[02:04:41] <karlosz> even delimited continuations wouldnt avoid that mess
[02:04:54] <sham1> You inline if you know that you can get away with it, but one needs to be conservative with it
[02:05:00] <karlosz> its only in the case of one-shot continuations that you would be able to guarantee no heap boxinfg
[02:05:22] <sham1> Eh. A delimited continuation shouldn't be able to jump back to the let-block unless it comes from under f
[02:05:34] <karlosz> (as in the block and tagbody special forms in common lisp, which get invalidated after one-shot use)
[02:05:48] <karlosz> yes, but a compiler wouldnt be able to know that right?
[02:06:02] <karlosz> (whether the prompt comes from under f)
[02:06:08] <karlosz> since thats a runtime thing
[02:07:01] <sham1> Well you need to do more analysis on f to see if it has a prompt or call/cc or whatever to further allow for optimising and suxh
[02:08:01] <sham1> Same thing with stuff like type analysis for inlining operations and operating on unboxed values
[02:08:18] <karlosz> oh yeah, i mean if you're allowed to do whole program analysis (block compilation), then thats a different story
[02:08:39] <karlosz> actually, come to think of it, it doesn't seem like the secheme specifications talk about redefinition of functions at all
[02:09:46] <sham1> Mmhm. The procedures get captured at the lambda evaluation time iirc, and thus if a function name gets reassigned, the lambda still refers to the old procedure iirc
[02:10:45] <dpk> karlosz: note the module systems of R6RS and R7RS allow much more static analysis of what procedure calls do, because imported bindings are immutable
[02:11:20] <karlosz> does that imply (define foo 3) (define (bar) foo) (set! foo 4) (bar) is allowed to return 3 still?
[02:11:46] <dpk> no, within a module bindings are mutable
[02:11:51] <sham1> I think that's a box
[02:12:18] <karlosz> okay, that makes more sense
[02:12:49] <sham1> Meanwhile I'm not sure if (define (foo) 3) (define (bar) (foo)) (set! foo (lambda () 4)) (bar) would return 3 or 4. Either case seems reasonable
[02:12:55] <karlosz> i think that would only be the case if the global environment were "hyper static" in the terminology of Lisp in Small Pieces
[02:13:22] <karlosz> sham1: huh. if it returned 4 that would be quite inconsistent with the above case methinks
[02:13:34] <karlosz> just because then procedures seem to be treated in a privelieged manner of other values
[02:13:41] <karlosz> *over other values
[02:14:33] <sham1> I'd hope that it is treated special. Would allow for neat things like more aggressive inlining and stuff like dispatching on optional arguments and keyword arguments and such at the call site rather than at the callee
[02:15:07] <karlosz> you could definitely do that with local functions and stuff like internal defines
[02:15:34] <karlosz> some common lips implementations and iirc chicken scheme allow block compilation to declare regions of code where thats the case
[02:29:10] *** Joins: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net)
[03:08:49] *** Quits: Avichi (~Avichi@2001:980:1b5c:1:57b4:71e2:c0ba:b86c) (Ping timeout: 256 seconds)
[03:15:19] *** Joins: s-liao (~s-liao@101.86.96.21)
[03:17:17] *** Quits: yewscion (~yewscion@52.94.133.128) (Ping timeout: 240 seconds)
[03:26:14] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[03:26:50] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Ping timeout: 260 seconds)
[03:34:38] *** Quits: seninha (~seninha@user/seninha) (Quit: Leaving)
[03:37:57] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[04:06:03] *** Quits: Everything (~Everythin@37.115.210.35) (Quit: leaving)
[04:12:59] *** Quits: neceve (~quassel@2.26.93.228) (Ping timeout: 256 seconds)
[04:33:10] *** Quits: m455 (~m455@user/m455) (Quit: WeeChat 3.0)
[04:34:16] *** Quits: livoreno (~livoreno@user/notzmv) (Read error: Connection reset by peer)
[04:42:44] *** Joins: s-liao (~s-liao@101.86.96.21)
[04:46:10] *** Quits: klovett (~klovett@107.115.32.130) (Quit: ZZZzzz…)
[04:52:39] *** Joins: frost (~frost@user/frost)
[05:02:02] *** Quits: frost (~frost@user/frost) (Quit: Connection closed)
[05:16:43] *** Joins: frost (~frost@user/frost)
[05:18:01] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[05:23:48] *** Quits: sp1ff (~user@c-73-189-25-64.hsd1.ca.comcast.net) (Remote host closed the connection)
[05:24:32] *** Joins: sp1ff (~user@c-73-189-25-64.hsd1.ca.comcast.net)
[05:45:55] *** Quits: schulze (~schulze@dynamic-095-116-058-071.95.116.pool.telefonica.de) (Ping timeout: 256 seconds)
[05:54:41] *** Joins: livoreno (~livoreno@user/notzmv)
[05:54:52] *** Joins: s-liao (~s-liao@101.86.96.21)
[05:57:59] *** Joins: jao (~jao@211.68.17.95.dynamic.jazztel.es)
[06:26:45] *** Joins: xaltsc (~xaltsc@user/xaltsc)
[06:49:55] *** Quits: jao (~jao@211.68.17.95.dynamic.jazztel.es) (Remote host closed the connection)
[06:57:47] *** Joins: jao (~jao@211.68.17.95.dynamic.jazztel.es)
[06:58:37] *** Joins: klovett (~klovett@107.115.32.130)
[07:13:24] *** Quits: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net) (Ping timeout: 240 seconds)
[07:22:30] *** Quits: skapata (~Skapata@user/skapata) (Remote host closed the connection)
[07:22:35] *** Quits: terrorjack (~terrorjac@2a01:4f8:1c1e:509a::1) (Quit: The Lounge - https://thelounge.chat)
[07:24:47] *** Joins: terrorjack (~terrorjac@2a01:4f8:1c1e:509a::1)
[07:46:49] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 268 seconds)
[07:50:59] *** Quits: szkl (uid110435@id-110435.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[07:52:28] *** Quits: jao (~jao@211.68.17.95.dynamic.jazztel.es) (Remote host closed the connection)
[07:52:31] *** Joins: m455 (~m455@user/m455)
[07:56:05] *** Joins: jao (~jao@211.68.17.95.dynamic.jazztel.es)
[08:01:55] *** Quits: amk (~amk@109.255.169.126) (Ping timeout: 256 seconds)
[08:05:15] *** Joins: amk (~amk@109.255.169.126)
[08:07:37] *** Quits: jao (~jao@211.68.17.95.dynamic.jazztel.es) (Ping timeout: 240 seconds)
[08:31:23] *** Quits: livoreno (~livoreno@user/notzmv) (Read error: Connection reset by peer)
[09:06:24] *** Quits: lockywolf (~lockywolf@vultr-seoul-openbsd.lockywolf.net) (Quit: ZNC 1.8.2 - https://znc.in)
[09:06:40] *** Joins: lockywolf (~lockywolf@vultr-seoul-openbsd.lockywolf.net)
[09:51:09] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[09:52:53] *** Quits: m455 (~m455@user/m455) (Quit: WeeChat 3.0)
[09:55:49] *** Joins: zacque (~zacque@175.139.232.25)
[09:58:01] *** Quits: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb) (Remote host closed the connection)
[09:58:50] *** Joins: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb)
[10:02:18] *** Joins: notzmv (~zmv@user/notzmv)
[10:20:11] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Ping timeout: 256 seconds)
[10:45:01] *** Joins: s-liao (~s-liao@101.86.96.21)
[10:48:13] *** Joins: sdu (~doo@185.44.146.214)
[10:52:12] *** Joins: taiju (~taiju@61.127.163.30)
[11:06:36] *** Quits: taiju (~taiju@61.127.163.30) (Ping timeout: 268 seconds)
[11:22:22] *** Quits: zacque (~zacque@175.139.232.25) (Quit: Goodbye :D)
[11:26:22] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[11:37:00] *** Quits: gioyik (~gioyik@gateway/tor-sasl/gioyik) (Quit: WeeChat 3.3)
[11:54:58] *** Joins: gproto23 (~gproto23@user/gproto23)
[11:56:55] *** Joins: Avichi (~Avichi@2001:980:1b5c:1:49bd:7bc5:78f2:8fae)
[12:32:04] *** Joins: klovett_ (~klovett@107.115.32.130)
[12:32:33] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[12:35:03] *** Quits: klovett (~klovett@107.115.32.130) (Ping timeout: 256 seconds)
[13:22:36] <amazigh> hello all :)
[13:24:34] <sham1> Hello
[13:33:21] *** Joins: s-liao (~s-liao@101.86.96.21)
[13:49:49] *** Joins: schulze (~schulze@dynamic-077-003-089-208.77.3.pool.telefonica.de)
[13:55:26] <amazigh> ah ah I will try to optimize my faux-texte generator
[14:01:01] <dpk> sham1: (bar) should return 4 in a compliant Scheme
[14:01:11] <sham1> Yeah
[14:01:33] <sham1> I realised it this morning after a night's sleep. My god, maybe the toplevel is hopeless
[14:02:02] <sham1> Why don't we have define-constant or something like that
[14:03:06] <dpk> well, again, modules are your friend
[14:03:57] <dpk> if i have (define (foo) 3) in one module (dpk foo), imported into another (dpk bar), then (set! foo ...) is an error in (dpk bar) to begin with
[14:04:07] <sham1> Yes, and for cross-module imports you can indeed do that thing of inlining and such based on the top-level identifier. But if you're in the same module...
[14:04:38] <dpk> well, within a module you can analyse which variables actually get set!
[14:04:51] <dpk> so that's not really an issue either
[14:05:26] <sham1> That is true
[14:06:03] <sham1> Although I'd still like define-constant or something like it for a semantic marking or such. Something where I know that it will be a constant and changing it will be an error even if it's not a different module
[14:06:21] <dpk> if anything is hopeless, it's REPL semantics. but there you care more about flexibility than speed anyway, probably
[14:06:36] <s-liao> what is your faux-texte generator?
[14:06:41] <s-liao> amazigh
[14:07:11] <sham1> Yeah. REPL is for prototyping and thus one wants flexibility
[14:09:35] <dpk> you can add a define-constant yourself with identifier-syntax, fwiw
[14:10:15] <dpk> but all it will do is make sure you don't "accidentally" mutate it yourself
[14:10:30] <dpk> which seems sufficiently unlikely as not to be worth doing
[14:10:54] <sham1> Hm
[14:11:06] <sham1> I need to look into it
[14:22:19] <amazigh> sham1: it is a markov chain, based on previously seen sentence, it generates hopefully new sentences ("faux texte" is french for "fake text")
[14:22:37] <sham1> s-liao: ^
[14:24:46] *** Joins: gproto23_ (~gproto23@user/gproto23)
[14:25:00] *** Quits: gproto23_ (~gproto23@user/gproto23) (Remote host closed the connection)
[14:25:19] *** Joins: gproto23_ (~gproto23@user/gproto23)
[14:25:57] *** Quits: gproto23 (~gproto23@user/gproto23) (Ping timeout: 240 seconds)
[14:30:18] <s-liao> Okay
[14:32:55] *** Quits: gproto23_ (~gproto23@user/gproto23) (Ping timeout: 256 seconds)
[14:34:03] *** Joins: seninha (~seninha@user/seninha)
[14:37:56] <s-liao> sham1 ^~^
[14:41:11] *** Quits: klovett_ (~klovett@107.115.32.130) (Quit: ZZZzzz…)
[14:51:24] <amazigh> apparantly I was not thinking clearly when I wrote that code
[14:51:43] <amazigh> I started with a hash-table, then I switched to an alist
[14:52:20] <amazigh> the alist contains all the words mapped to their continuation word e.g. "a" -> "cat"
[14:52:54] <amazigh> that is not a mere optimization I need, it is a *bug fix*
[14:53:25] <amazigh> (one might argue an optimization is a bug fix)
[15:05:38] *** Joins: rito_ (~rito_gh@45.112.243.151)
[15:13:34] *** Joins: gproto23 (~gproto23@user/gproto23)
[15:38:41] <amazigh> Given that yet surprising discovery, I aleviate myself from the burden, and obligation here, now and forever to write perfect code...
[15:38:56] <amazigh> ... I just need to remember it.
[15:52:33] *** Quits: gproto23 (~gproto23@user/gproto23) (Read error: Connection reset by peer)
[15:58:25] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[15:58:31] <ASau> sham1: I'd say, if you want heavy math, you want something like Scratchpad/Aldor rather than APL.
[15:59:18] <sham1> Hm, interesting
[15:59:59] <ASau> As for this infix-prefix-postfix thing, my opinion is that after invention of LL(1) in 1970(!!) the whole point is rather stupid.
[16:01:35] <ASau> If you think a little about all those "prefix is better" or "postfix is better" languages (Lisp and Forth), you see that they were invented before LL(1).
[16:02:25] <ASau> Sure, back in that time it made sense to have fully parethesised prefix or non-parenthesised postfix.
[16:02:43] <sham1> While having nice parsing theory is good and all, there's still problems there. I mean, ambiguity with the order of operations even though they are pretty standardised thanks to mathematical and now programming language convention
[16:02:47] *** Joins: neceve (~quassel@2.26.93.228)
[16:02:51] <ASau> As of today, it is better to have readable code.
[16:03:04] <sham1> You also get problems with stuff like user-defined operators
[16:03:19] <sham1> Like how do you parse that, especially with a batch compiler
[16:03:46] *** Joins: gproto23 (~gproto23@user/gproto23)
[16:04:18] <ASau> As for me, non-parenthesised postfix is the worst in this respect.
[16:05:02] *** Joins: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net)
[16:05:24] <ASau> sham1: ambiguity is complicated, sure, yet it is easier to handle.
[16:05:53] *** Quits: frost (~frost@user/frost) (Quit: Connection closed)
[16:06:30] <ASau> sham1: the point is that some operators denote associative operations traditionally, and it is bad idea to redefine them otherwise.
[16:06:41] <ASau> Even if you can do the latter.
[16:08:37] <ASau> It is also not a good idea in general to redefine operators that traditionally denote ring, field or vector space operations not to follow distributivity.
[16:12:54] <ASau> In that aspect, even though the solution of APL or J is somewhat elegant, it is still bad.
[16:13:22] *** Joins: thevishy (~Nishant@2405:201:f005:c007:1d22:93e8:b240:6332)
[16:16:29] <ASau> Zipheir: the primary problem with "concatenative" languages is that _actually_ they are not "concatenative".
[16:17:28] <ASau> For instance, subroutines, conditionals and loops have to be implemented in essentially non-"concatenative" ways.
[16:18:11] <ASau> Sometimes you can work around by implementing anonymous code blocks, yet then those anonymous code blocks are not "concatenative".
[16:18:32] <ASau> The worst thing is actually inline comments.
[16:18:48] <ASau> In FIG-Forth they were implemented in such a way that
[16:19:44] <ASau> This( is( not( a( comment(, ( )))))) this is inside comment) and this is not.
[16:21:18] <ASau> Oh, year, it was even worse in external storage!
[16:31:58] *** Joins: montxero` (~user@1.145.194.51)
[16:40:46] *** Quits: neceve (~quassel@2.26.93.228) (Read error: Connection reset by peer)
[16:43:42] *** Quits: montxero` (~user@1.145.194.51) (Remote host closed the connection)
[16:52:20] *** Parts: pranavats (3fba1d1b34@jabberfr.org) ()
[16:55:37] *** Quits: lockywolf (~lockywolf@vultr-seoul-openbsd.lockywolf.net) (Ping timeout: 240 seconds)
[17:06:08] *** Joins: lockywolf (~lockywolf@vultr-seoul-openbsd.lockywolf.net)
[17:07:08] *** Joins: s-liao (~s-liao@101.86.96.21)
[17:15:33] *** Joins: skapata (~Skapata@2804:14c:87b0:a6f9:a892:5f2f:3801:1e1e)
[17:15:33] *** Quits: skapata (~Skapata@2804:14c:87b0:a6f9:a892:5f2f:3801:1e1e) (Changing host)
[17:15:33] *** Joins: skapata (~Skapata@user/skapata)
[17:19:13] *** Quits: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net) (Ping timeout: 250 seconds)
[17:19:54] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Ping timeout (120 seconds))
[17:20:24] *** Joins: s-liao (~s-liao@101.86.96.21)
[17:43:42] *** Quits: xsperry (~xs@user/xsperry) (Remote host closed the connection)
[17:58:37] *** Joins: klovett (~klovett@107.115.32.130)
[18:06:15] <amazigh> ASau: re readability: ymmv. Not all natural language are like english Subject Verb Ojbect ...
[18:06:44] <amazigh> and whether SVO is optimal even for NL is debatable
[18:09:02] <ASau> amazigh: my native langauge is not English, so I know it very well.
[18:09:19] <ASau> Readability with flexible (I mean, _really_ flexible) word order is tricky itself.
[18:09:59] <ASau> We have at least one book (relatively famous) on that topic.
[18:21:34] <ASau> amazigh: my native language, unlike English or German or French or Turkish, allows any permutation in sentence like "cat [nom., sing.] eats [present, 3rd, sing.] mice [acc., pl.]" retaining primary meaning.
[18:23:05] <amazigh> I guess that is the Saphir-... hypothesis
[18:24:56] <amazigh> Wortf that is Sapir-Whorf hypothesis, in particular whether the grammar influence or determine the way one thinks about reality
[18:25:03] <amazigh> Worf!
[18:25:12] <amazigh> I give up on spelling
[18:26:53] <Zipheir> Qapla'!
[18:27:06] <ASau> famazigh: forget it, it was essentially refuted already.
[18:36:20] *** Joins: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net)
[18:45:13] *** Quits: xaltsc (~xaltsc@user/xaltsc) (Read error: Connection reset by peer)
[18:49:19] *** Joins: xaltsc_ (~xaltsc@user/xaltsc)
[18:51:55] *** xaltsc_ is now known as xaltsc
[19:01:58] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[19:08:08] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[19:08:48] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Quit: Quit)
[19:09:17] *** Joins: taiju (~taiju@240b:253:ec40:2400:bd6b:dfac:c8bb:c6d4)
[19:24:37] *** Quits: taiju (~taiju@240b:253:ec40:2400:bd6b:dfac:c8bb:c6d4) (Quit: Quit)
[19:32:25] <amazigh> hmm
[19:32:52] *** Quits: sdu (~doo@185.44.146.214) (Quit: leaving)
[19:33:30] <amazigh> Despite recommending people to read r7rs.pdf, I just figured I never read it from front to back
[19:36:18] <amazigh> I started converting the .pdf into .md by hand
[19:36:31] <amazigh> now I wonder if i'd rather fix the .tex instead
[19:36:56] *** Joins: livoreno (~livoreno@user/notzmv)
[19:39:59] <Zipheir> amazigh: What happened to the HTML copy?
[19:41:01] <amazigh> the html copy does not have semantic markup
[19:41:11] <amazigh> it is only <p> tags with styles
[19:42:33] <amazigh> It is readable but not... perfect!
[19:42:38] <amazigh> oops I did it again.
[19:42:42] <Zipheir> Semantic markup?  Like bibliography refs, etc.?
[19:43:04] <amazigh> no
[19:43:17] <amazigh> there is no h1, h2, h3, h4, or code / pre
[19:43:46] <Zipheir> Currently there's no non-PDF version of R7RS-small available over the net.  That's something we can remedy without having to make it perfect, I think.
[19:44:04] <Zipheir> Oh, that's a bigger issue, then.
[19:44:26] <amazigh> yeah, also I will learn a few latex tricks, not bad
[19:44:49] *** Quits: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net) (Ping timeout: 250 seconds)
[19:45:28] <Zipheir> amazigh: If you could post a tarball/repo of the raw htlatex-generated HTML that would be a good place to start.
[19:46:10] <Zipheir> We can work on it as opposed to debating the perfect way to generate it (someday).
[19:50:12] <amazigh> the code is at https://github.com/johnwcowan/r7rs-spec/pull/2/files
[19:50:27] <amazigh> I will give pandoc another try
[19:51:05] <Zipheir> I'm trying to avoid installing the mess of stuff that comes with htlatex. :)
[19:51:27] <Zipheir> Eventually, though, I will just do this myself...
[19:51:46] <Zipheir> pandoc does not like the flavor of LaTeX.
[19:52:10] *** Joins: taiju (~taiju@240b:253:ec40:2400:bd6b:dfac:c8bb:c6d4)
[19:53:05] *** Quits: Noisytoot (~noisytoot@sourcehut/user/noisytoot) (Ping timeout: 256 seconds)
[20:08:34] <ASau> DocBook...
[20:08:52] * ASau hides.
[20:10:07] <sham1> AsciiDoc then, because XML? No
[20:12:11] <Zipheir> All of these formats don't seem to be helping much.  We'll probably end up just hand-hacking the LaTeX sources.
[20:12:45] <sham1> Here's a ludicrous idea. org-mode
[20:13:01] <Zipheir> Another one.
[20:13:16] <sham1> Well you can have inline LaTeX, you can compile to HTML
[20:13:32] <sham1> One gets the full power of Emacs behind it
[20:14:25] <Zipheir> The big questions are: (1) Can we convert the LaTeX to FORMAT easily and (2) can we directly compile FORMAT to a nice-looking hosting-ready bunch of pages a la r6rs.org?
[20:15:18] <Zipheir> I'd just like to solve the problem of sending people to a PDF when we talk about R7RS.
[20:15:49] <Zipheir> It's kind of silly that the standard is 14 years old and isn't available on the Web.
[20:15:57] <sham1> Well one thing would be that next time one needs to write a standard, one needn't necessarily go with LaTeX
[20:16:45] <Zipheir> Agreed.  But this is where we are at the moment.
[20:17:16] <Zipheir> So I guess Step 1 is to convert the LaTeX to Scribble, Org, texinfo, whatever.
[20:18:04] <Zipheir> That would be a major Good Thing in itself.  Then, generate a site from that markup.
[20:19:19] <Zipheir> If we can decide on a format, I'm willing to get the translation going.
[20:19:42] *** Quits: livoreno (~livoreno@user/notzmv) (Read error: Connection reset by peer)
[20:36:27] *** Joins: sdu (~doo@185.44.146.214)
[20:41:39] *** Joins: winning-luser (~wl@2601:8c1:80:70d0::414b)
[20:41:46] *** Quits: winning-luser (~wl@2601:8c1:80:70d0::414b) (Remote host closed the connection)
[20:52:28] *** Quits: clacke (88d96f2df3@knopi.disroot.org) (Read error: Connection reset by peer)
[20:53:22] *** Joins: livoreno (~livoreno@user/notzmv)
[20:58:37] *** Joins: xsperry (~xs@user/xsperry)
[21:18:44] *** Joins: paul_j (~user@67.26.169.217.in-addr.arpa)
[21:27:00] *** Joins: tohoyn (~tohoyn@mobile-access-2e8465-250.dhcp.inet.fi)
[21:27:56] <amazigh> Going through pandoc --mathjax r7rs.tex -o r7rs.html yields many errors, but fixigin them one by one delivers better results more quickly
[21:28:37] <amazigh> BUT I made a large change that was no good, so I need to restart from scratch!
[21:32:10] *** Parts: opalvaults[m] (~opalvault@2001:470:69fc:105::1:51f6) ()
[21:38:26] *** Quits: tohoyn (~tohoyn@mobile-access-2e8465-250.dhcp.inet.fi) (Quit: Leaving)
[21:41:25] *** Quits: thevishy (~Nishant@2405:201:f005:c007:1d22:93e8:b240:6332) (Quit: Leaving)
[22:02:28] *** Joins: clacke (88d96f2df3@knopi.disroot.org)
[22:12:39] *** Joins: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net)
[22:23:00] *** Quits: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net) (Ping timeout: 240 seconds)
[22:34:02] *** Quits: epony (epony@user/epony) (Ping timeout: 240 seconds)
[22:35:39] *** Joins: epony (epony@user/epony)
[22:50:39] *** Joins: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net)
[23:19:40] *** Joins: ZombieChicken (~weechat@user/zombiechicken)
[23:29:41] *** Quits: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net) (Ping timeout: 268 seconds)
[23:31:37] *** Quits: xgqt (~xgqt@gentoo/developer/xgqt) (Ping timeout: 240 seconds)
[23:32:04] *** Joins: xgqt (~xgqt@gentoo/developer/xgqt)
[23:32:07] <amazigh> Zipheir: check out the branch html-take-three, there is also a r7rs.md, I think it easier to work with .md than .html or latex, but the rendering is not as good as the official .pdf, in particular all the formal semantic was lost in translation
[23:32:51] *** Quits: seninha (~seninha@user/seninha) (Remote host closed the connection)
[23:45:58] *** Joins: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net)
[23:46:57] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 240 seconds)
