[00:01:46] *** Quits: lottaquestions (~nick@2607:fa49:503e:3000:cd5:c174:4b11:9477) (Ping timeout: 260 seconds)
[00:02:06] *** Joins: CptKirk (~CptKirk@70-57-27-195.hlrn.qwest.net)
[00:02:42] *** Joins: abrante95 (~abrantesa@177.79.123.227)
[00:04:19] <pve> greyrat: I don't know for a fact that you won't run into strange behaviour if your temp variables collide with your "normal" ones, which is why I put the prefix
[00:04:35] <lisp123> How often do you guys use q to record macros?
[00:04:43] <lisp123> (sorry wrong chat - plz ignore)
[00:04:50] *** Joins: hisacro (~OBSD@my.displ.nl)
[00:05:51] <pve> like will (setf x 1) make x a special variable? I'm not sure..
[00:05:53] *** Joins: cosimone (~user@93-44-185-198.ip98.fastwebnet.it)
[00:06:47] <pve> no I mean (setf (symbol-value 'x) 1)
[00:06:58] <greyrat> Hmm
[00:08:14] <pve> because unless I'm mistaken, you might inadvertently refer to x somewhere else, and not get a "undefined variable" warning
[00:09:13] <greyrat>  Oh, that's kind of unavoidable; x will be exported globally.
[00:09:16] <pve> which could lead to a debugging nightmare
[00:09:38] <White_Flame> greyrat: the compiler determines at compile-time what setf is storing into.  If it's declared special at that time, it compiles a special var setf.  else it compiles a local one
[00:09:59] <greyrat> pve: I will condition the macro on *repl-p*, so that it won't export the vars if we are not in a repl.
[00:09:59] <White_Flame> (assuming a symbol/variable name)
[00:10:16] <greyrat> I can use a global var in the macro definition, can't I?
[00:10:31] <pve> greyrat: anyway, that's why I used the %
[00:10:37] <greyrat> (BTW, I manually set *repl-p* to t when I am in a REPL.)
[00:12:33] <pjb> greyrat: a string to ~A is ok.
[00:13:52] <greyrat> White_Flame: I am confused; `setf` is setting a global variablein `(let ((b "sth")) (setf (symbol-value 'b) b))`, where `b` is not special.
[00:14:20] <pjb> greyrat: the symbol-value of a symbol is global.
[00:14:36] <White_Flame> yeah, and also that's not setting a global variable.  That's setting a slot on a symbol object
[00:14:52] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Quit: ec)
[00:14:53] <pjb> greyrat: that gives you access to the dynamic binding of a special variable named by this symbol.
[00:15:04] <Bike> white_flame was talking about what (setf x b) does, i.e. where the place being set is a variable name
[00:15:20] *** Quits: Skyfire (~pyon@user/pyon) (Quit: WeeChat 3.3)
[00:15:41] *** Joins: Skyfire (~pyon@user/pyon)
[00:15:42] <pjb> (progn (setf (symbol-value 'foo) 42)  (locally (declare (special foo)) foo)) #| --> 42 |#
[00:16:06] <pjb>  (progn (setf (symbol-value 'foo) 42)  (locally (declare (special foo)) (setf foo 33))  (symbol-value 'foo)) #| --> 33 |#
[00:16:44] <greyrat> Hmm. I guess all global variables are special?
[00:16:52] <White_Flame> the term "global" isn't often used
[00:17:03] <pjb> pve: you could also intern your symbols in your one of own packages, or a temporary package.
[00:17:47] <White_Flame> for instance, SBCL has a defglobal, which creates a variable that cannot have any dynamic LET bindings, only its singular value
[00:18:14] <pve> pjb: sure, probably safest that way
[00:18:20] <pjb> greyrat: not necessarily. If you mean defvar/defparameter variables yes. But there are also constant variables (defconstant), that are not special, no dynamic binding (but also it doesn't matter, because we cannot bind locally constant variables.  But there is also global symbol-macros that can be used to define global lexical variables. symbol macros are lexical.
[00:19:37] <pjb> pve: anyways, once there's a %, it also indicate that it's a private symbol and you need to know what you're doing to use it. So %foo or *%foo* or %*foo* don't make much difference.
[00:20:10] *** Joins: scymtym (~user@ip-94-114-248-79.unity-media.net)
[00:21:10] <pve> pjb: right, it's not everyday I consider private special variables
[00:21:11] *** Quits: abrante95 (~abrantesa@177.79.123.227) (Read error: Connection reset by peer)
[00:21:32] <White_Flame> there also used to be global lexical variables, and all sorts of other weird names
[00:25:16] *** Joins: abrantesasf (~abrantesa@187.36.170.211)
[00:35:47] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[00:36:29] <greyrat> I found how to write this exflitration macro in Clojure at least: https://paste.gnugen.ch/paste/22Md . Now I have it in Python, Julia, and Clojure. And this CL's `letd` is close enough. ^_^
[00:38:00] *** Quits: cosimone (~user@93-44-185-198.ip98.fastwebnet.it) (Remote host closed the connection)
[00:42:00] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[00:42:17] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[00:42:48] *** Joins: lisp123 (~lisp123@5.30.23.247)
[01:01:38] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Remote host closed the connection)
[01:02:41] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[01:03:14] *** Quits: shka (~herr@109.231.6.176) (Ping timeout: 245 seconds)
[01:11:15] *** Joins: elderK (uid205007@id-205007.helmsley.irccloud.com)
[01:14:12] *** Quits: pve (~pve@37-33-27-173.bb.dnainternet.fi) (Quit: leaving)
[01:14:38] *** Quits: gaqwas (~john@dynamic-095-118-089-174.95.118.pool.telefonica.de) (Ping timeout: 252 seconds)
[01:21:22] *** Parts: contrapunctus (a75f5b1571@jabberfr.org) ()
[01:22:55] *** Quits: NeoCron (~NeoCron@p200300c4cf1c96002e5e9f24316d1b2a.dip0.t-ipconnect.de) (Quit: Leaving)
[01:22:58] *** Joins: _abrantesasf_ (~abrantesa@187.36.170.211)
[01:23:38] *** Quits: _abrantesasf_ (~abrantesa@187.36.170.211) (Remote host closed the connection)
[01:23:53] <dim> Fade: are you referring to pgloader's `make pgloader` target or the newer `make save` target which is written in Common Lisp?
[01:23:54] *** Quits: abrantesasf (~abrantesa@187.36.170.211) (Quit: -a- IRC for Android 2.1.59)
[01:24:31] *** Joins: abrantesasf (~abrantesa@187.36.170.211)
[01:31:10] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 252 seconds)
[01:54:24] *** Joins: hajovont` (~user@BC9C833A.catv.pool.telekom.hu)
[01:57:14] *** Quits: hajovonta (~user@BC9C833A.catv.pool.telekom.hu) (Read error: Connection reset by peer)
[02:01:32] *** Quits: Spawns_Carpeting (~pi@user/spawns-carpeting/x-6969421) (Quit: ZNC 1.7.2+deb3 - https://znc.in)
[02:02:31] *** Quits: attila_lendvai (~alendvai@catv-213-222-131-28.catv.broadband.hu) (Ping timeout: 252 seconds)
[02:04:08] *** Joins: dec0d3r (~dec0d3r@2001:8003:480a:e00:e07:e7c3:7efc:ed0f)
[02:13:08] *** Quits: frgo (~frgo@p200300deef0cee00c939094f51644eb3.dip0.t-ipconnect.de) (Remote host closed the connection)
[02:13:37] *** Joins: frgo (~frgo@p200300deef0cee00c939094f51644eb3.dip0.t-ipconnect.de)
[02:27:20] *** Quits: loskutak (~loskutak@gw.mecom.cz) (Ping timeout: 246 seconds)
[02:31:11] *** Joins: zazzerino (~user@2600:1700:6004:8470::43)
[02:33:52] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Ping timeout: 252 seconds)
[02:38:46] *** Quits: Krystof (~user@81.174.155.115) (Ping timeout: 252 seconds)
[02:52:23] *** Joins: dre (~dre@2001:8003:c932:c301:b1a7:f172:e0ac:f5a0)
[02:55:01] *** Joins: contrapunctus (a75f5b1571@jabberfr.org)
[03:00:44] *** Parts: contrapunctus (a75f5b1571@jabberfr.org) ()
[03:00:56] *** Joins: contrapunctus (a75f5b1571@jabberfr.org)
[03:03:30] *** Joins: igemnace (~ian@user/igemnace)
[03:05:29] *** Quits: Inline (~Inline@2a02:908:1252:7a80:89dc:6a58:9f2a:ff3d) (Ping timeout: 246 seconds)
[03:05:39] *** Quits: kevingal (~quassel@2a02:8084:4140:f300:68dc:c10c:d421:9fd7) (Remote host closed the connection)
[03:13:53] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[03:25:15] <dieggsy> greyrat: letd?
[03:29:49] *** Quits: scymtym (~user@ip-94-114-248-79.unity-media.net) (Remote host closed the connection)
[03:36:11] *** Joins: scymtym (~user@ip-94-114-248-79.unity-media.net)
[03:51:22] *** Quits: Oddity (Oddity@user/oddity) (Remote host closed the connection)
[03:52:14] *** Joins: notzmv (~zmv@user/notzmv)
[03:58:22] *** Quits: random-nick (~random-ni@87.116.183.117) (Ping timeout: 250 seconds)
[04:01:35] *** Joins: Oddity (Oddity@user/oddity)
[04:10:42] *** Quits: Jach (~Jach@2601:600:8600:307:7e31:e7a7:f1f3:a96b) (Remote host closed the connection)
[04:17:56] *** Quits: makomo_ (~makomo@user/makomo) (Ping timeout: 246 seconds)
[04:19:17] *** Quits: makomo (~makomo@user/makomo) (Ping timeout: 264 seconds)
[04:45:31] *** Quits: CptKirk (~CptKirk@70-57-27-195.hlrn.qwest.net) (Ping timeout: 256 seconds)
[05:08:33] *** Quits: taiju (~taiju@240b:253:ec40:2400:e069:cea0:b66b:350c) (Ping timeout: 268 seconds)
[05:08:47] *** Quits: abrantesasf (~abrantesa@187.36.170.211) (Remote host closed the connection)
[05:14:34] *** Quits: Catie (~user@2603:3023:523:400:82e8:2cff:fed9:cc84) (Quit: Leaving work)
[05:17:34] *** Quits: jealousmonk (~user@2804:431:e7c4:cbd0:ae30:e39b:f4a:15d4) (Quit: ERC (IRC client for Emacs 27.1))
[05:18:41] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[05:49:30] *** Quits: jkordani (~jkordani@c-69-255-2-251.hsd1.md.comcast.net) (Quit: Client closed)
[05:56:16] *** Joins: taiju (~taiju@240b:253:ec40:2400:e069:cea0:b66b:350c)
[06:02:05] *** Joins: prxq_ (~quassel@dynamic-077-012-169-187.77.12.pool.telefonica.de)
[06:02:12] *** Quits: prxq (~quassel@x4db5ab29.dyn.telefonica.de) (Ping timeout: 268 seconds)
[06:12:02] *** Quits: terrorjack (~terrorjac@static.3.200.12.49.clients.your-server.de) (Quit: The Lounge - https://thelounge.chat)
[06:32:17] <beach> Good morning everyone!
[06:43:28] *** Quits: zazzerino (~user@2600:1700:6004:8470::43) (Ping timeout: 250 seconds)
[06:45:25] *** Quits: spec (~mrSpec@user/spec) (Quit: ZNC - http://znc.in)
[06:45:44] *** Joins: mrSpec (~mrSpec@user/spec)
[06:46:12] *** Quits: les (whome@user/les) (Quit: Adios)
[06:46:14] *** Quits: derwolf (~DerWolf@2a01:4f8:c0c:554a::1) (Quit: Bye)
[06:46:17] *** Quits: ullbeking (sid5364@user/ullbeking) (Read error: Connection reset by peer)
[06:46:25] *** Joins: les (znc@user/les)
[06:46:33] *** Joins: derwolf (~DerWolf@2a01:4f8:c0c:554a::1)
[06:46:44] *** Joins: ullbeking (sid5364@user/ullbeking)
[06:46:52] *** Quits: froggey (froggey@2a01:7e00::f03c:92ff:fe7c:ec68) (Remote host closed the connection)
[06:48:06] *** Joins: froggey (froggey@2a01:7e00::f03c:92ff:fe7c:ec68)
[06:48:08] *** Quits: katco (~katco@2001:470:69fc:105::2b8) (Ping timeout: 265 seconds)
[06:48:08] *** Quits: Duuqnd (~duuqnd@2001:470:69fc:105::e9c0) (Ping timeout: 265 seconds)
[06:48:08] *** Quits: CodeBitCookie[m] (~code-bit-@2001:470:69fc:105::a2f) (Ping timeout: 265 seconds)
[06:48:08] *** Quits: Arcsech (~arcsechma@2001:470:69fc:105::1:797) (Ping timeout: 265 seconds)
[06:48:09] *** Quits: akater[m] (~akatermat@2001:470:69fc:105::ccef) (Ping timeout: 265 seconds)
[06:48:37] *** Quits: loke[m] (~loke@2001:470:69fc:105::237) (Ping timeout: 265 seconds)
[06:48:37] *** Quits: MatrixTravelerb4 (~voyagert2@2001:470:69fc:105::22) (Ping timeout: 265 seconds)
[06:48:38] *** Quits: dualinverter[m] (~dualinver@2001:470:69fc:105::16a7) (Ping timeout: 265 seconds)
[06:48:38] *** Quits: luis` (~luismboma@2001:470:69fc:105::cc7) (Ping timeout: 265 seconds)
[06:49:07] *** Quits: saltrocklamp[m] (~elementio@2001:470:69fc:105::5065) (Ping timeout: 265 seconds)
[06:50:18] *** rdrg109_ is now known as rdrg109
[06:51:50] *** Joins: akater[m] (~akatermat@2001:470:69fc:105::ccef)
[06:55:18] *** Joins: MatrixTravelerb4 (~voyagert2@2001:470:69fc:105::22)
[06:55:29] *** Quits: Josh_2 (~user@37.25.47.130) (Remote host closed the connection)
[06:59:38] *** Joins: Arcsech (~arcsechma@2001:470:69fc:105::1:797)
[06:59:53] *** Joins: katco (~katco@2001:470:69fc:105::2b8)
[07:00:28] *** Joins: CodeBitCookie[m] (~code-bit-@2001:470:69fc:105::a2f)
[07:00:57] *** Joins: Duuqnd (~duuqnd@2001:470:69fc:105::e9c0)
[07:05:24] *** Joins: loke[m] (~loke@2001:470:69fc:105::237)
[07:06:03] *** Quits: Bike (~Glossina@71.69.170.70) (Quit: Lost terminal)
[07:06:20] <dieggsy> beach: mernin
[07:06:30] *** Joins: dualinverter[m] (~dualinver@2001:470:69fc:105::16a7)
[07:06:33] *** Joins: luis` (~luismboma@2001:470:69fc:105::cc7)
[07:09:22] *** Joins: saltrocklamp[m] (~elementio@2001:470:69fc:105::5065)
[07:11:37] *** Quits: taiju (~taiju@240b:253:ec40:2400:e069:cea0:b66b:350c) (Ping timeout: 252 seconds)
[07:12:30] *** Quits: semz (~none@user/semz) (Ping timeout: 268 seconds)
[07:24:30] *** Joins: semz (~none@user/semz)
[07:24:32] *** Quits: Psybur (~Psybur@mobile-166-170-32-197.mycingular.net) (Remote host closed the connection)
[07:34:41] *** Joins: taiju (~taiju@240b:253:ec40:2400:e069:cea0:b66b:350c)
[07:39:32] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 246 seconds)
[07:59:15] *** Joins: Nilby (~Nilby@2601:603:1481:30a0:82fa:5bff:fe66:4b49)
[07:59:33] <gin> beach: Good morning!
[08:09:53] *** Joins: kuler (~kulernil@gateway/tor-sasl/kuler)
[08:10:37] *** Quits: kuler (~kulernil@gateway/tor-sasl/kuler) (Remote host closed the connection)
[08:18:53] <jmercouris> Good morning
[08:19:17] *** Joins: karlosz (~karlosz@135-180-102-220.fiber.dynamic.sonic.net)
[08:19:59] *** Quits: karlosz (~karlosz@135-180-102-220.fiber.dynamic.sonic.net) (Client Quit)
[08:20:29] *** Joins: wilfred (uid159@id-159.uxbridge.irccloud.com)
[08:21:44] <jmercouris> I should probably use symbol-name rather than format with aesthetic directive
[08:21:53] <jmercouris> I had never considered it until the conversation above
[08:37:57] *** Joins: karlosz (~karlosz@135-180-102-220.fiber.dynamic.sonic.net)
[08:57:36] *** Joins: gaqwas (~john@dynamic-077-004-075-231.77.4.pool.telefonica.de)
[08:59:40] *** Joins: robin_ (~robin@user/terpri)
[09:02:10] *** Quits: robin (~robin@user/terpri) (Ping timeout: 252 seconds)
[09:05:31] *** Quits: robin_ (~robin@user/terpri) (Ping timeout: 245 seconds)
[09:06:25] *** Joins: robin_ (~robin@user/terpri)
[09:15:06] *** Quits: taiju (~taiju@240b:253:ec40:2400:e069:cea0:b66b:350c) (Ping timeout: 245 seconds)
[09:16:58] *** Quits: karlosz (~karlosz@135-180-102-220.fiber.dynamic.sonic.net) (Quit: karlosz)
[09:31:23] *** Joins: pve (~pve@37-33-64-6.bb.dnainternet.fi)
[09:31:25] *** Joins: karlosz (~karlosz@135-180-102-220.fiber.dynamic.sonic.net)
[09:32:29] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 268 seconds)
[09:41:30] *** Joins: makomo (~makomo@user/makomo)
[09:47:24] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Ping timeout: 245 seconds)
[09:48:38] *** Joins: amb007 (~a_bakic@59.13.23.93.rev.sfr.net)
[09:53:07] *** Quits: karlosz (~karlosz@135-180-102-220.fiber.dynamic.sonic.net) (Quit: karlosz)
[09:53:57] *** Joins: Cymew (~ante@c-e989225c.023-1144-7570702.bbcust.telenor.se)
[10:07:21] *** Joins: shka (~herr@83.175.151.96.piasta.pl)
[10:07:38] *** Joins: taiju (~taiju@240b:253:ec40:2400:e069:cea0:b66b:350c)
[10:29:01] *** Quits: gaqwas (~john@dynamic-077-004-075-231.77.4.pool.telefonica.de) (Ping timeout: 265 seconds)
[10:29:22] *** Quits: amb007 (~a_bakic@59.13.23.93.rev.sfr.net) (Ping timeout: 265 seconds)
[10:29:57] *** hajovont` is now known as hajovonta
[10:30:26] *** Joins: amb007 (~a_bakic@193.36.22.93.rev.sfr.net)
[10:31:32] *** Quits: dec0d3r (~dec0d3r@2001:8003:480a:e00:e07:e7c3:7efc:ed0f) (Remote host closed the connection)
[10:34:22] *** Joins: makomo_ (~makomo@user/makomo)
[10:35:21] *** Quits: makomo_ (~makomo@user/makomo) (Client Quit)
[10:35:30] *** Joins: makomo_ (~makomo@user/makomo)
[10:37:25] *** Joins: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3)
[10:38:54] <gin> is (return-from func nil) the only way to return from the middle of a func? is repeating the function name 'func' necessary?
[10:40:06] <beach> Yes, because you can have nested functions with different names, so the compiler would have to guess otherwise.
[10:40:55] <gin> no macro in CLHS to just return NIL (or a value) from the innermost function?
[10:41:44] <beach> No.  I suggest you get over it and move on.
[10:42:18] <gin> ok :) thanks beach
[10:42:22] *** Quits: amb007 (~a_bakic@193.36.22.93.rev.sfr.net) (Read error: Connection reset by peer)
[10:42:51] *** Joins: amb007 (~a_bakic@193.36.22.93.rev.sfr.net)
[10:42:51] *** Quits: amb007 (~a_bakic@193.36.22.93.rev.sfr.net) (Read error: Connection reset by peer)
[10:43:08] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[10:44:46] *** robin_ is now known as robin
[10:47:31] *** Joins: iamFIREcracker (~iamFIREcr@user/iamfirecracker)
[10:49:30] *** Quits: iamFIREc1 (~iamFIREcr@user/iamfirecracker) (Ping timeout: 260 seconds)
[10:55:09] <mfiano> Often times you can use control flow operators to restructure a function use RETURN or RETURN-FROM, and it may or may not make the functionality clearer.
[10:55:28] *** Quits: hajovonta (~user@BC9C833A.catv.pool.telekom.hu) (Ping timeout: 252 seconds)
[10:55:35] <mfiano> s/use/that uses/
[10:56:07] <flip214> gin: you can have (BLOCK nil ..... (return nil))
[10:56:25] <flip214> RETURN is a shorthand for RETURN-FROM NIL
[10:56:39] <mfiano> I wouldn't rely on that, if "..." had some macro implicitly also defining a "closer" NIL block
[10:57:35] <flip214> mfiano: well, the macro should warn about that (in the docstring, for example)
[10:59:05] <mfiano> I would prefer
[10:59:07] <mfiano> (block #1=#:nil ... (return-from #1# nil))
[10:59:12] <mfiano> But that's just me
[11:00:21] <beach> mfiano: Then you might as well do (block #1=#.(gensym)...)
[11:00:34] <mfiano> I have no desire for a gensym
[11:00:50] <mfiano> Just a freshly allocated symbol that is not identical to any other
[11:00:56] <beach> I guess yours works if there is no other reference to the label.
[11:01:01] <beach> Sure.
[11:01:38] <flip214> mfiano: you can'
[11:02:22] <flip214> mfiano: you can't run individual subforms in there, as the #1# definition must be visible.
[11:03:02] <flip214> ie. with forms like (+ 1 (* 3 4)) during debugging/testing I sometimes only evaluate inner forms (like "(* 3 4)"), your example would produce a reader error
[11:04:07] <mfiano> Err, what?
[11:05:05] <hayley> Such an expression probably would only signal an error if there is a RETURN to an unknown block name.
[11:05:08] *** Joins: cosimone` (~user@93-47-229-247.ip115.fastwebnet.it)
[11:05:49] <Nilby> It's too bad that to fix this little wart one would have to add at least 2 more confusing operators: (defun hi () (block hi (return-from hi nil)) (print 'hi))
[11:06:11] *** Quits: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3) (Remote host closed the connection)
[11:06:28] <Nilby> or silly options to return or return-from?
[11:08:04] <Nilby> maybe one could add a return-from-defun or something
[11:18:51] *** Quits: iamFIREcracker (~iamFIREcr@user/iamfirecracker) (Ping timeout: 245 seconds)
[11:20:50] *** Joins: iamFIREcracker (~iamFIREcr@user/iamfirecracker)
[11:21:59] <jackdaniel> Nilby: defun most likely expands to (setf (fdefinition hi) (lambda () (block hi …))) so unless you want to impose a specific expansion from defun you can't tell whether the function is defined with defun or otherwise
[11:22:03] *** Joins: Inline (~Inline@2a02:908:1252:7a80:89dc:6a58:9f2a:ff3d)
[11:22:15] <jackdaniel> s/most likely/could/
[11:25:02] <jackdaniel> if you could guarantee that each function exapnds to (lambda () (block some-internal-symbol …)) then escaping from the innermost function would be trivially (return-from some-internal-symbol …)
[11:25:23] <Nilby> Yes, defun would have to be unfortunately more complex.
[11:26:37] <jackdaniel> the complexity increase would be minute, but good luck convincing all implementers to add such feature with a limited usefulness
[11:29:23] <Nilby> Yes, there are so many more important issues.
[11:29:44] *** Quits: wilfred (uid159@id-159.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[11:35:57] *** Joins: hendursa1 (~weechat@user/hendursaga)
[11:39:06] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[11:40:33] *** Quits: flip214 (~marek@user/flip214) (Read error: Connection reset by peer)
[11:41:09] *** Joins: flip214 (~marek@user/flip214)
[11:42:48] <Nilby> I don't know why I'm still midly amused at RMS being the single NO on many CL committee votes. elisp seesm to embody them. https://gist.github.com/agumonkey/777c2a289aa3afc2d814b38adbf5da9b#file-cl-history-txt-L2492
[11:44:05] *** Joins: notzmv (~zmv@user/notzmv)
[11:48:40] *** Joins: tfb (~tfb@88.98.95.237)
[11:54:34] <Cymew> I wonder if you are seeing something different than me, because I don't see that. He does abstain (which is what I guess - means) uitq often, but he does not vote N more often than anyone else.
[11:54:51] <Cymew> s/uitq/quite/
[11:57:56] <Nilby> Cymew: Maybe I'm thinking of a different document I read, where I think he was opposed to lexical scope and keyword arguments.
[11:58:06] *** Joins: iamFIREc1 (~iamFIREcr@user/iamfirecracker)
[11:58:26] *** Joins: selwyn (~selwyn@user/selwyn)
[12:00:06] *** Quits: iamFIREcracker (~iamFIREcr@user/iamfirecracker) (Ping timeout: 245 seconds)
[12:04:48] *** Joins: attila_lendvai (~alendvai@catv-213-222-131-28.catv.broadband.hu)
[12:04:54] *** Quits: cosimone` (~user@93-47-229-247.ip115.fastwebnet.it) (Quit: ERC (IRC client for Emacs 27.1))
[12:05:16] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[12:12:29] *** Joins: loskutak (~loskutak@gw.mecom.cz)
[12:16:10] <lisp123> Nilby: Thanks for sharing that link
[12:18:32] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[12:21:54] *** Quits: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 250 seconds)
[12:22:21] <Cymew> It was an interesting document, though.
[12:23:39] *** Quits: loskutak (~loskutak@gw.mecom.cz) (Ping timeout: 245 seconds)
[12:24:43] <Cymew> What I find interesting is that RMS and someone else mentioned they were opposed to a change where they would have to find all instances of a construct in old code and change it, and I at once though of a bash loop over a file tree using sed.
[12:25:13] <Nilby> I find it helpful to see why things are they way they are and thought, debate, and other paths considered. There must be other copies of it, but that's what I could easily find.
[12:27:10] <Nilby> Cymew: bash wasn't done until seven years later in 1989 :)
[12:28:33] <jackdaniel> "so to morph elisp to common lisp I've written bash, but then I've run out of steam" -- Bash Secret Files
[12:28:38] <Cymew> Yeah, but looping over files and manipulating them was done in 1983, in lisp. ;)
[12:29:15] <Cymew> Sorry, my math was off, but you get the point.
[12:30:15] <Nilby> and now I have a shell and sed in CL, so I can do both
[12:30:39] <Cymew> I think I've seen KMP argue convincingly why keyword arguments are bad, but now we have them.
[12:30:39] <Nilby> at the same time
[12:30:45] <Cymew> :)
[12:31:41] * Nilby is unconvinced 
[12:32:57] <gin> Cymew: who is KMP? any article I can read about why keyword arguments are bad?
[12:33:04] <Cymew> Kent Pitman
[12:33:16] <Nilby> I love the keyword arguments, and wish they were in elisp too. They're not perfect, but they enable amazing compatibility.
[12:33:42] <Cymew> I just have a vague recollection of it, but most things written by Pitman on lisp is worth your time.
[12:34:01] <gin> I like keyword arguments too because the keywords act like self-documentation for the arguments.
[12:34:16] *** Quits: taiju (~taiju@240b:253:ec40:2400:e069:cea0:b66b:350c) (Ping timeout: 245 seconds)
[12:34:18] <Cymew> Yeah, I disagree with RMS on those as well.
[12:34:27] <lisp123> jackdaniel: Is that true?
[12:34:39] <jackdaniel> lisp123: of course not
[12:34:47] <lisp123> oh lol
[12:35:02] <jackdaniel> still, I like think of my silly remarks as witty (or at least funny)
[12:35:10] <lisp123> I was going to edit awesome-cl-list and include bash as originating from CL :D
[12:35:11] <Nilby> very few copies of "Bash Secret Files" have been leaked
[12:35:38] <lisp123> Cymew: I used to love keyword arguments but I have been moving against them lately
[12:35:56] *** Quits: makomo_ (~makomo@user/makomo) (Ping timeout: 245 seconds)
[12:36:13] <lisp123> Do you have a link to the article?
[12:36:55] *** Joins: iamFIREcracker (~iamFIREcr@user/iamfirecracker)
[12:37:47] *** Joins: taiju (~taiju@240b:253:ec40:2400:e069:cea0:b66b:350c)
[12:38:14] *** Quits: iamFIREc1 (~iamFIREcr@user/iamfirecracker) (Ping timeout: 245 seconds)
[12:40:05] <Cymew> I can't find any bigger works by KMP on keywords, so maybe I misremembered or is was on usenet.
[12:40:36] <lisp123> No worries, will have a look myself too
[12:43:08] <gin> lisp123: why do you not like keyword arguments anymore?
[12:45:30] <beach> I was about to ask the same question.
[12:46:03] <lisp123> gin: I'll put it the other way, what are the main benefits of keyword arguments?
[12:46:55] <gin> lisp123: flexibility in apis in future, function calls are easier to read because the keyword argument tells what the argument means
[12:47:18] <beach> Reasonable defaults, shorter function-call forms in the general case, extensible interfaces.
[12:47:49] <beach> Possibility for "intermediate functions" to ignore arguments irrelevant to them.
[12:47:58] *** Quits: Mandus_ (~aasmundo@0.51-175-33.customer.lyse.net) (Ping timeout: 268 seconds)
[12:48:17] <lisp123> flexibility in apis I agree with
[12:48:25] <beach> Possibility for :AROUND methods to supply specific versions of keyword arguments without knowing about all of them.
[12:48:26] <lisp123> My issue has been towards the reasonable defaults
[12:48:48] <lisp123> Feels like that is embedding assumptions into the parameter list (lambda list?)
[12:48:55] <beach> More readable function-call forms.
[12:49:50] <_death> defaults are part of the interface (and should therefore be documented)
[12:50:08] <beach> Instead of (f t t nil 234 11 nil t t #\a), you get (f :from-end t :remove-duplicates t...)
[12:50:09] *** Joins: Mandus_ (~aasmundo@0.51-175-33.customer.lyse.net)
[12:50:37] <lisp123> beach: what if one creates a separate function (f2 t t) for that use case
[12:50:57] <beach> lisp123: You will have an exponential number of functions then.
[12:51:25] <lisp123> Fair point
[12:51:40] <beach> (defun f-with-from-end-true-and-remove-duplicates-true-as-well...)
[12:51:41] <_death> bare "t"s are a pet peeve
[12:52:01] <beach> (defun f-with-from-end-true-and-remove-duplicates-false...)
[12:52:03] <beach> etc.
[12:53:32] <_death> imagine a better world, where encode-universal-time took keywords
[12:53:34] <lisp123> what if instead that information was passed in via an argument (e.g. (f arg1 arg2) --> arg1 is a class with various components, then in the body of f, you check if certain propertiers are met
[12:54:23] <beach> lisp123: For one thing, you would then allocate memory for each call.
[12:54:29] *** Quits: Mandus_ (~aasmundo@0.51-175-33.customer.lyse.net) (Ping timeout: 245 seconds)
[12:54:54] *** Joins: Mandus_ (~aasmundo@0.51-175-33.customer.lyse.net)
[12:55:11] <beach> lisp123: And you would turn every function call into the creation of a standard object (or at least a struct), with the battery of initialization that is then required.
[12:55:13] <_death> lisp123: and how would you create an instance of this class?
[12:55:41] <beach> lisp123: I am not sure where you pick up all these strange ideas.
[12:55:50] <_death> (let ((instance (create-foo))) #| long list of setfs |# ...) ?
[12:57:07] <beach> And there would have to be a SETF for each slot, since we don't like defaults.
[12:57:09] <lisp123> I don't think its that strange. Right now, a keyword argument with a default value has an implicit if statement (if supplied use-arg otherwise-use-default), making it explicit within the body of the function and then passing in those details via an argument, even if inefficient, doesn't sound strange
[12:58:21] <lisp123> By not supplying a keyword argument, there is an implicit assumption to use the default, so my thought was whether this should be made explicit
[12:58:37] <lisp123> Given sometimes the issues &key has when used in macros etc.
[12:58:51] <beach> Er, what?
[12:58:54] <_death> lisp123: the compiler can often eliminate these IFs (the procedure can have multiple entry points)
[12:59:04] <tfb> It just means that instead of letting the language do the work for you you need to do it all yourself rather than relying on CL's very nicely designed keyword-argument system
[13:00:14] <beach> tfb: Exactly, and in doing so, defeating all the compiler optimizations adapted to the language.
[13:00:14] <lisp123> _death: Yes
[13:00:46] <_death> it's true that macros should use &key with care, to preserve order of evaluation (usually by help of an additional &rest arg)
[13:01:42] <Nilby> The supplied-p-parameter can let you make more explict decisions.
[13:01:58] <beach> The fact that it is hard to get the semantics right with writing macros seems like a weak reason for eliminating keyword arguments everywhere.
[13:02:20] <lisp123> Not to eliminate, but to be judicious in their use
[13:02:33] <lisp123> I think any external-facing API definitely benefits greatly from them
[13:02:54] <lisp123> And in certain cases (many casees?) what you just said makes perfect sense
[13:02:57] <jackdaniel> lisp123: highly optimized internal functions rarely use keywords indeed
[13:03:10] <_death> you can see elisp for an example of rejection of keyword arguments.. where many functions have a bunch of optional parameters, and you need to pass arguments up to the ones you're actually interested in
[13:03:11] <jackdaniel> so there is nothing to solve, just to discover the contemporary style
[13:03:12] <jackdaniel> :)
[13:03:32] <lisp123> But I think sometimes it can be a shortcut and its better to write out the code more explicit (I think I've written some bad code that relies on keyword arguments, so that's where its coming from)
[13:04:03] <beach> jackdaniel: But that's probably because they couldn't figure out a way to get rid of the argument parsing.
[13:04:47] <beach> lisp123: That's what I meant by strange ideas.  You seem to make an isolated observation and then you draw very broad conclusions from it.
[13:05:23] <jackdaniel> beach: probably; or they could but getting rid of the argument parsing introduces some minimal overhead to allow that
[13:05:42] <beach> lisp123: A better idea would be to give some more thought as to the reason for the isolated case being bad, and just make a much more narrow conclusion.
[13:05:57] <jackdaniel> either way keyword arguments are in the standard for good and they are really nice for various uses
[13:06:55] *** sm2n_ is now known as sm2n
[13:07:16] <lisp123> beach: Well, all I said was "I used to love keyword arguments but I have been moving against them lately", I never said they are categorically bad or anything ;)
[13:07:54] <beach> The common use case: (defmethod mumble :around (... &rest args &key foo) (apply #'call-next-method :foo <altered> args)) is fantastic.
[13:08:09] <beach> lisp123: Got it.
[13:08:13] <sm2n> I like what s7 scheme does, which is that they got rid of keyword arguments, kept optional ones, and let refer to the optional ones with keywords at a callsite
[13:08:20] <sm2n> s/let/let you/
[13:08:31] <sm2n> basically merging the two
[13:09:14] <jackdaniel> I think that scheme doesn't have clear function redefinition semantics so they wouldn't care much about redefined argument lists - do I miss something?
[13:09:20] <_death> what happens if you want to pass a keyword as the value?
[13:10:06] *** Quits: Mandus_ (~aasmundo@0.51-175-33.customer.lyse.net) (Ping timeout: 245 seconds)
[13:10:12] <beach> Good catch!
[13:11:10] <sm2n> you have to do it as a pair with the argument name, unless you :allow-other-keys
[13:11:37] *** Joins: Mandus_ (~aasmundo@0.51-175-33.customer.lyse.net)
[13:12:17] <sm2n> that's a good point though, it's kind of confusing in the latter case, I didn't know that could work
[13:12:23] <sm2n> jackdaniel, I'm not sure how that is related
[13:13:24] <sm2n> https://ccrma.stanford.edu/software/snd/snd/s7.html#define* see the note about error checks here
[13:13:34] <jackdaniel> sm2n: (defun xxx (foo &optional a b c) …)  (defun yyy () (xxx 42 :b 13)) (defun xxx () (foo &optional b a c) …)
[13:13:38] <jackdaniel> the order of optional arguments changed
[13:14:14] <jackdaniel> so if it has been "preprocessed" when yyy was defined, and then xxx is redefined, then yyy's :b 13 will be essentially :a 13 (because a is now the second optional parameter)
[13:14:46] <sm2n> oh, I see
[13:14:49] <sm2n> that makes sense
[13:15:26] <sm2n> I was wondering if there would be something that would make it hard to compile when I saw it, and I guess I was right
[13:21:26] *** Quits: Mandus_ (~aasmundo@0.51-175-33.customer.lyse.net) (Ping timeout: 265 seconds)
[13:21:48] *** Quits: tfb (~tfb@88.98.95.237) (Quit: died)
[13:29:39] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[13:30:24] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[13:31:20] *** Joins: Mandus_ (~aasmundo@0.51-175-33.customer.lyse.net)
[13:39:27] *** Joins: random-nick (~random-ni@87.116.183.117)
[13:40:54] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Ping timeout: 265 seconds)
[13:43:46] *** flip214 is now known as flip768
[13:49:54] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[13:50:17] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[13:51:15] *** Joins: makomo_ (~makomo@user/makomo)
[13:52:22] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[13:53:52] *** Joins: amb007 (~a_bakic@108.15.23.93.rev.sfr.net)
[13:56:21] *** Quits: Mandus_ (~aasmundo@0.51-175-33.customer.lyse.net) (Ping timeout: 245 seconds)
[13:57:20] *** Quits: Inline (~Inline@2a02:908:1252:7a80:89dc:6a58:9f2a:ff3d) (Ping timeout: 265 seconds)
[13:57:27] *** Joins: Mandus_ (~aasmundo@0.51-175-33.customer.lyse.net)
[13:59:41] *** Joins: heisig (~heisig@p508b531b.dip0.t-ipconnect.de)
[14:06:21] *** Quits: amb007 (~a_bakic@108.15.23.93.rev.sfr.net) (Read error: Connection reset by peer)
[14:09:29] *** Quits: Mandus_ (~aasmundo@0.51-175-33.customer.lyse.net) (Ping timeout: 245 seconds)
[14:10:13] *** Joins: Mandus_ (~aasmundo@0.51-175-33.customer.lyse.net)
[14:11:12] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[14:13:07] *** Quits: frgo (~frgo@p200300deef0cee00c939094f51644eb3.dip0.t-ipconnect.de) (Remote host closed the connection)
[14:13:34] *** Joins: frgo (~frgo@p200300deef0cee00c939094f51644eb3.dip0.t-ipconnect.de)
[14:17:07] *** Joins: Inline (~Inline@2a02:908:1252:7a80:89dc:6a58:9f2a:ff3d)
[14:17:59] *** Quits: Mandus_ (~aasmundo@0.51-175-33.customer.lyse.net) (Ping timeout: 265 seconds)
[14:18:24] *** Joins: Mandus_ (~aasmundo@0.51-175-33.customer.lyse.net)
[14:23:24] *** Joins: Lord_of_Life (~Lord@user/lord-of-life/x-2819915)
[14:30:20] *** Joins: loskutak (~loskutak@gw.mecom.cz)
[14:30:33] *** Quits: Mandus_ (~aasmundo@0.51-175-33.customer.lyse.net) (Ping timeout: 265 seconds)
[14:30:47] <gin> do you use LOOP in all its glory? LOOP feels like its own DSL. anything wrong with using just plain (loop (something) (something) ... (when cond (return))?
[14:32:07] <hayley> (loop collecting complaints-about-loop)
[14:33:20] <hayley> But, really, it's too much of a hassle to write a macro which collects values into a list, without PUSHing each value and calling REVERSE.
[14:33:26] <gin> didn't know there was collecting clause. what's the difference collecting and collect?
[14:33:36] <hayley> Nothing.
[14:35:04] *** Parts: pranavats (3fba1d1b34@jabberfr.org) (Disconnected: Replaced by new connection)
[14:35:37] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[14:37:35] *** Joins: Mandus_ (~aasmundo@0.51-175-33.customer.lyse.net)
[14:41:38] <gin> both these lists appear the same in REPL: (defparameter *a* (list 1 2 3)) (defparameter *b* '(1 2 3)). is there some way to print in different ways so that I know which one was created using LIST and which one was created as a literal?
[14:42:06] <hayley> I don't believe there's any way you can tell them apart.
[14:52:11] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[14:52:48] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[14:56:26] *** Joins: cranium (~cranium@user/cranium)
[14:57:31] <gin> is there any naming convention to separate internal functions from exposed functions?
[14:57:40] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[14:57:44] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Quit: Laa shay'a waqi'un moutlaq bale kouloun moumkine)
[14:58:23] *** Quits: frgo (~frgo@p200300deef0cee00c939094f51644eb3.dip0.t-ipconnect.de) (Remote host closed the connection)
[14:58:45] <hayley> But, a "counter-example" to that idea: how would you print (cons 4 (rest *b*))?
[14:58:47] <hayley> The package system?
[15:00:16] <gin> hayley: good point. hadn't thought about such cases if we need to tell literal list apart from constructed list.
[15:07:51] *** Quits: specbot (~specbot@common-lisp.net) (Remote host closed the connection)
[15:07:52] *** Quits: minion (~minion@common-lisp.net) (Remote host closed the connection)
[15:08:14] *** Joins: specbot (~specbot@common-lisp.net)
[15:08:52] *** Joins: minion (~minion@common-lisp.net)
[15:09:37] <jackdaniel> you may compare forms with (constantp '(list 1 2 3)) vs (constantp '(quote 1 2 3)) ; but this doesn't have much utility for runtime data
[15:10:26] <jackdaniel> (quote (1 2 3)) °
[15:12:53] *** Quits: Everything (~Everythin@37.115.210.35) (Ping timeout: 268 seconds)
[15:14:22] *** Joins: Everything (~Everythin@37.115.210.35)
[15:26:20] *** Joins: kpoeck (~kpoeck@80.149.96.222)
[15:30:28] *** Joins: Jach (~Jach@2601:600:8600:307:7e31:e7a7:f1f3:a96b)
[15:32:20] *** Quits: jackdaniel (~jack@user/jackdaniel) (Remote host closed the connection)
[15:34:10] *** Joins: jackdaniel (~jack@user/jackdaniel)
[15:34:11] *** ChanServ sets mode: +o jackdaniel
[15:35:07] *** Quits: srhm (~srhm@user/srhm) (Read error: Connection reset by peer)
[15:35:34] *** Joins: srhm (~srhm@user/srhm)
[15:38:13] *** Joins: Krystof (~user@81.174.155.115)
[15:55:55] *** Joins: frgo (~frgo@77.81.98.70)
[15:56:29] *** mrSpec is now known as spec
[16:05:53] *** Quits: spec (~mrSpec@user/spec) (Quit: ZNC - http://znc.in)
[16:07:00] *** Joins: mrSpec (~spec@user/spec)
[16:08:13] *** Quits: mrSpec (~spec@user/spec) (Client Quit)
[16:08:56] *** Joins: spec (~spec@user/spec)
[16:14:55] *** Quits: frgo (~frgo@77.81.98.70) (Remote host closed the connection)
[16:15:42] *** Joins: frgo (~frgo@2a03:2260:3016:1306:25ef:cb97:c1b3:c829)
[16:20:45] *** Quits: frgo (~frgo@2a03:2260:3016:1306:25ef:cb97:c1b3:c829) (Remote host closed the connection)
[16:25:18] *** Joins: frgo (~frgo@185.66.193.56)
[16:26:02] *** Joins: Psybur (~Psybur@mobile-166-170-32-197.mycingular.net)
[16:28:25] <gin> need help with this - https://plaster.tymoon.eu/view/2661#2661 - in my code each COLLECT returns a list, so I get a list of lists in the end. is there a way to merge all the lists from collect into a single list?
[16:29:16] <beach> Use APPEND instead of COLLECT on the outer level.
[16:29:19] <hayley> Use APPEND instead of COLLECT
[16:29:48] <gin> wow! thanks
[16:29:56] *** Quits: frgo (~frgo@185.66.193.56) (Ping timeout: 265 seconds)
[16:30:04] *** Joins: Bike (~Glossina@71.69.170.70)
[16:30:04] *** ChanServ sets mode: +o Bike
[16:30:42] <gin> so LOOP really is powerful. still cannot shake off that feeling that I am using something non-Lispy while using LOOP features.
[16:31:15] <beach> How can something that is part of the Lisp standard be "non-Lispy"?
[16:32:22] <hayley> Names name me (and my programming style) not.
[16:33:23] <gin> poor choice of words by me. I mean for so long I was used to the (verb arg1 arg2 arg3) syntax but with LOOP the syntax changes very much that I feel like I am learning a new language.
[16:33:44] <hayley> "This is true of me: no concept expresses me, nothing that is said to be my essence exhausts me; they are only names." But I an still inclined to agree with beach.
[16:33:58] <beach> gin: You are learning a DSL and that's fine.
[16:34:23] <gin> ok. will keep practicing.
[16:34:29] *** Quits: random-nick (~random-ni@87.116.183.117) (Ping timeout: 245 seconds)
[16:34:31] <gin> hayley: where you got that quote from?
[16:34:53] <hayley> Then it should be strange for DEFUN, DESTRUCTURING-BIND, RESTART-CASE, and so on to have more "syntax". But LOOP is notably lacking in parens.
[16:35:16] <hayley> gin: The Unique and Its Property
[16:35:31] <flip768> gin: you can use ITERATE, that's nearly like LOOP only with parens.
[16:36:48] *** Joins: NeoCron (~NeoCron@p200300c4cf16e40089f16fffa0577f49.dip0.t-ipconnect.de)
[16:36:48] <beach> I refuse to define "Lispy" as "must have parentheses".
[16:37:11] <hayley> Say, in (defun f (x) x) the (x) does not represent a function call, rather it is a lambda list. I think beach called these additional grammars a "two level syntax" or something like that.
[16:37:32] <beach> That term was invented by Paul Wilson.
[16:37:50] <hayley> Noted.
[16:39:46] <gin> beach: how would you define "Lispy" if you were to define it?
[16:40:37] <hayley> Otherwise, it seems normal to me to introduce new grammar to Lisp. A macro I wrote has "infix" arrows like (chain (x <- some-effect) (y = (f x)) (list x y)) but it isn't "un-Lispy" to me.
[16:42:09] <beach> gin: Dynamic (i.e. semantics defined by a suite of interaction), dynamically typed, using uniform reference semantics, homoiconic, and very likely more.
[16:43:15] <edgar-rft> hayley: it were more Lispy if the arrow would like like (- instead of <-
[16:43:45] <gin> hayley, beach, thanks for sharing your views on this. helps me to appreciate the underlying ideas that I otherwise dont think about
[16:44:29] <beach> Sure.
[16:45:41] <hayley> edgar-rft: Maybe I should use the Unicode left arrow character instead of <-. People have compose keys these days, no?
[16:53:43] *** Joins: cage (~cage@dynamic-adsl-84-220-249-98.clienti.tiscali.it)
[16:55:23] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[16:56:11] *** Joins: frgo (~frgo@p200300deef0cee0048aa85568a8f61b1.dip0.t-ipconnect.de)
[16:57:53] <jackdaniel> I don't think that being lispy is as much about parenthesis but loop semantics are not crystal clear (because it is a complex dsl); format is also very complex
[16:58:11] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[16:58:39] *** Joins: frgo_ (~frgo@p200300deef0cee0031f0804abc79a7d2.dip0.t-ipconnect.de)
[16:58:41] <jackdaniel> I don't think that any syntax that could be implemented as dsl in lisp is "lispy" by definition
[16:58:56] <jackdaniel> uh, so many "I don't think that", I'll keep quiet ,P
[17:00:16] <jackdaniel> that said both loop and format are widely used by lisp programmers, so they could be considered "lispy" for that reason alone
[17:00:31] *** Quits: frgo (~frgo@p200300deef0cee0048aa85568a8f61b1.dip0.t-ipconnect.de) (Ping timeout: 265 seconds)
[17:01:41] *** Joins: Josh_2 (~user@37.25.47.130)
[17:06:47] <aeth> LOOP is not easily handled by Lisp tools (even a fully configured Emacs+SLIME with the LOOP additions doesn't properly indent more advanced LOOPs), which suggets that it probably has gone too far as far as the non-Lispiness DSLs go
[17:07:36] <beach> Nah, that just suggests that Emacs+SLIME are not as great as they could be.
[17:07:59] <beach> Or, rather, not as great as a preferred tool should be.
[17:08:15] <aeth> I mean, if supporting your DSL is harder than supporting the rest of the language combined when a few extra parentheses in the design could have avoided that whole issue...
[17:08:50] <aeth> but, unfortunately, ITERATE is not just "LOOP with parens" no matter how many times people say it, so I use LOOP, not ITERATE
[17:09:02] <beach> Well, the entire technique used by Emacs+SLIME is mediocre for Lisp.  Not just LOOP indentation.
[17:15:26] *** Joins: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca)
[17:16:17] *** Joins: Lord_of_Life (~Lord@user/lord-of-life/x-2819915)
[17:20:00] <ahlk> Are there any tools that use a better technique than Emacs+Slime do for Lisp?
[17:20:06] *** Quits: Nilby (~Nilby@2601:603:1481:30a0:82fa:5bff:fe66:4b49) (Ping timeout: 245 seconds)
[17:22:58] <beach> ahlk: Maybe the IDE of Lispworks.  But we are working on better tools.  It's a bit slow though.
[17:23:11] *** Quits: frgo_ (~frgo@p200300deef0cee0031f0804abc79a7d2.dip0.t-ipconnect.de) (Remote host closed the connection)
[17:24:23] *** Joins: frgo (~frgo@p200300deef0cee0031f0804abc79a7d2.dip0.t-ipconnect.de)
[17:41:18] *** Joins: azimut_ (~azimut@gateway/tor-sasl/azimut)
[17:43:06] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Ping timeout: 276 seconds)
[17:44:10] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[17:48:05] <lisp123> The Emacs IDE is pretty advanced but requires a lot of customisation to get it where you want. Which can get trying at times
[17:49:59] <beach> I think it's the best we have, but it's pretty bad.
[17:50:50] <beach> Indentation does not work properly.  Syntax highlighting and completion does not take symbol roles into account. etc., etc.
[17:51:37] <lisp123> All true
[17:52:24] <beach> To see syntax errors, you have to issue an explicit command (C-c C-c for instance) whereas it would be much better to see them as they happen when you type.
[17:56:55] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Quit: Laa shay'a waqi'un moutlaq bale kouloun moumkine)
[17:58:00] <lisp123> I guess Emacs is too slow for that
[17:59:01] <lisp123> I get stack overflows pretty frequently for any type of live (on buffer change) functions
[18:00:39] *** Joins: rain3 (~rain3___@2a02:2f09:d003:5800:b41c:c37:1705:91bc)
[18:01:26] <beach> It is possible that Emacs could keep up, but since the entire IDE is based on transmitting bytes between Emacs and the Lisp image, either you need to transmit lots of bytes for each character you type, or you need a very sophisticated (read complicated) communication protocol.
[18:01:47] *** Joins: kevingal (~quassel@2a02:8084:4140:f300:bc92:daad:e13a:3716)
[18:03:04] <lisp123> Yes
[18:04:34] <lisp123> What is holding Climacs back from production use?
[18:05:11] <lisp123> (Production being define as the basic features of SLIME & Emacs, excluding all the packages)
[18:06:28] <lisp123> Once the basics are up, the rest can follow if mass adoption is reached
[18:06:48] <beach> Available time for me and some others like scymtym.
[18:07:38] <beach> But then, if you create an IDE that runs in the same image as your Common Lisp implementation, you have to deal with the fact that the Common Lisp implementations available to us are way too easy to crash, so then you crash your IDE as well.
[18:08:10] <beach> The main issue for Second Climacs is indentation.  I still have to figure out how to compute it.
[18:08:39] <lisp123> So currently the editor will crash if the main image crashes?
[18:09:08] <beach> If they both run in the same image, then obviously yes.
[18:09:45] <beach> I mean, if the editor runs in the application image, then yes.
[18:11:01] <lisp123> Hmmm, not possible to have a main editor image and an inferior image or will that lose the benefit of information sharing between the editor & the user's image?
[18:11:43] <beach> How would the two communicate?  You would be back to bytes being transmitted between the two.
[18:12:04] <lisp123> Yeah, was hoping there was some magic :)
[18:12:26] <Bike> maybe you could do something funny with shared memory.
[18:12:43] <beach> Possibly.
[18:12:43] <lisp123> I had a look at Emacs indentation before, but I guess you don't want to port their indentation as a starting point
[18:13:15] <beach> lisp123: Emacs indentation sucks, which is why I want something better.
[18:14:06] <beach> lisp123: (first) Climacs indentation is already better than that of Emacs in many respects, but it is horribly complicated, and still doesn't work in the general case.
[18:14:23] <lisp123> I might have a look later at it, I wrote (what I thought were) some nice parsers which could help attack the problem
[18:14:54] <beach> lisp123: The only true parser for Common Lisp code is READ.  So unless that is what you use, it is not going to work right.
[18:15:09] <beach> That is why Emacs and (first) Climacs indentation doesn't work in the general case.
[18:15:17] *** Joins: Lord_of_Life (~Lord@46.217.216.227)
[18:15:18] *** Quits: Lord_of_Life (~Lord@46.217.216.227) (Changing host)
[18:15:18] *** Joins: Lord_of_Life (~Lord@user/lord-of-life/x-2819915)
[18:16:56] <lisp123> I wrote a parser that looks n tokens ahead and behind to calculate how to treat words (sorry if my terminology is off), then it has multiple passes, so one solves for the unambiguous case to begin, and then one uses defaults for the ambiguous cases
[18:18:12] <lisp123> Each pass resolves more ambiguity (because certain words can be parsed for certain based on previous results)
[18:20:18] *** Quits: igemnace (~ian@user/igemnace) (Quit: WeeChat 3.3)
[18:20:20] <beach> lisp123: Let me give you a simple example.  Suppose you have (<some-operator> (let ((x 10))<newline> (+ x 10))), how do you indent (+ x 10)?
[18:21:13] <beach> lisp123: It is possible that <some-operator> is a macro so that (let ...) is not a form but data.  How does your parser determine that situation?
[18:21:30] *** Joins: patrice (~patrice@2603:301c:604:2a00:497b:b585:b1cb:7915)
[18:23:17] <lisp123> How would you like it to look?
[18:23:40] <lisp123> (if you have a pastebin)
[18:24:05] <beach> Probably, the (+ x 10) should be aligned with the symbol LET.
[18:24:15] <beach> But only if it is not a form.
[18:24:29] <beach> If it is a form, it should be indented as a LET would normally be indented.
[18:25:00] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Quit: Laa shay'a waqi'un moutlaq bale kouloun moumkine)
[18:25:04] <lisp123> Ok
[18:25:26] <beach> And, which one it is, is determined by <some-operator>.  If it is a function or a macro that expands it into a position of evaluation, then it should be indented as a LET form.  Otherwise not.
[18:25:40] <beach> So my question is, how do you determine the difference in your parser?
[18:26:07] <lisp123> One of the starting points would be to loop through each token and see what it is
[18:26:11] <beach> The only way I can see how to do it, is to run it through READ and then the first pass of a compiler-like tool.
[18:26:18] <lisp123> Yes exactly
[18:26:27] <lisp123> So one would map it to a macro then
[18:26:51] <dieggsy> ....never forget your time zones lol. I just spent way too long chasing down an off by one day date conversion cause i'm a fool
[18:27:02] <beach> So if you say "exactly" and your parser doesn't use READ, I don't see how you resolve that conflict.
[18:27:28] <lisp123> No, it should use READ & a code-walker as a starting point
[18:27:42] <lisp123> Then over multiple passes one resolves ambiguity
[18:27:55] <beach> That's precisely what we are doing.
[18:28:04] <lisp123> and resorts to defaults where it can't be resolved
[18:28:42] <beach> But I don't think that is what your current parser is doing, at least not judging from your description of it.
[18:28:55] <lisp123> Mine is not a lisp parser, its an english to math parser
[18:29:14] <lisp123> But the concept was nice --> multiple passes, looking ahead & behind, resolving certain words at each pass
[18:29:32] <beach> So I spent all this time thinking you are parsing Common Lisp.  Oh, well.  Back to work.
[18:30:10] <lisp123> Sorry
[18:30:48] <gin> A: (sort some-list (lambda (x y) (...)))  B: (sort some-list #'(lambda (x y) (...))) <- is one considered to be better style than the other?
[18:31:05] *** Quits: cranium (~cranium@user/cranium) (Quit: Leaving)
[18:31:23] <beach> The first one is better.
[18:31:58] <gin> to be fair, i too thought this was a common lisp parsing discussion. when did it become english parsing discussion and how is indentation relevant in english parsing?
[18:32:19] <lisp123> The algorithm for parsing can be applied anywhere
[18:32:39] <beach> lisp123: Yes, but it won't work for Common Lisp code.
[18:32:53] <beach> Because it doesn't use READ.
[18:33:12] <gin> beach: thanks! I use the first style but got confused by looking at the examples at http://www.lispworks.com/documentation/lw51/CLHS/Body/f_sort_.htm
[18:33:41] <lisp123> Well, an algorithm parses based on certan rules --> read is used for classification of tokens
[18:33:46] <beach> gin: The examples have not been scrutinized.  Sometimes they are not even conforming.
[18:34:00] <gin> ok
[18:34:05] *** Joins: lottaquestions (~nick@2607:fa49:503e:3000:254f:a774:c45b:8133)
[18:34:49] <lisp123> A lisp expression is just a finite (nested) list of tokens at the end of the day
[18:35:57] <lisp123> So there needs to be a table of the indentation rules based on the patterns, READ & associated functions to assist with classifications, and a general algorithm which does the parsing
[18:35:57] <beach> lisp123: Most parsers have a fixed set of rules, but READ can be altered by user code anytime.  So for instance if you have (<some-operator> #.<code-that-modifies-the-read-table> ...) then you need to alter the parser rules for ...
[18:36:32] <beach> lisp123: I give up.  You don't seem to get it.  Sorry.
[18:37:37] <lisp123> Yes, but at any point in time you have the state of the image
[18:38:00] <lisp123> If that changes in the next time step, then you can (in theory) reparse the whole document
[18:40:39] <gin> no offence intended but i think it is a good time to end the parsing discussion. when one party has indicated that they don't want to continue it is good to end the topic cordially.
[18:41:07] <lisp123> Sure
[18:41:12] *** Quits: lisp123 (~lisp123@5.30.23.247) (Quit: Leaving...)
[18:59:04] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Ping timeout: 245 seconds)
[19:00:26] *** Quits: srhm (~srhm@user/srhm) (Read error: Connection reset by peer)
[19:00:53] *** Joins: srhm (~srhm@user/srhm)
[19:03:46] *** Quits: kpoeck (~kpoeck@80.149.96.222) (Quit: Client closed)
[19:03:56] *** Joins: _patrice (~patrice@2603:301c:604:2a00:f255:29f2:c2a4:cea8)
[19:07:20] *** Joins: Devon (~devon@pool-108-28-172-103.washdc.fios.verizon.net)
[19:07:56] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[19:09:09] *** Quits: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[19:10:06] *** Quits: lottaquestions (~nick@2607:fa49:503e:3000:254f:a774:c45b:8133) (Ping timeout: 245 seconds)
[19:12:43] *** Joins: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca)
[19:12:49] *** Quits: makomo_ (~makomo@user/makomo) (Ping timeout: 265 seconds)
[19:15:24] *** Quits: ggoes (~gregf@fsf/staff/ggoes) (Quit: ZNC 1.8.2+deb2+b1 - https://znc.in)
[19:16:31] *** Joins: ggoes (~gregf@fsf/staff/ggoes)
[19:24:48] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[19:24:54] *** Quits: Mandus_ (~aasmundo@0.51-175-33.customer.lyse.net) (Ping timeout: 265 seconds)
[19:25:12] <waleee> Anyone else that has started to get weird build errors like https://0x0.st/-gIk.txt with sbcl master from git?
[19:25:15] *** Quits: srhm (~srhm@user/srhm) (Read error: Connection reset by peer)
[19:25:40] *** Joins: Mandus_ (~aasmundo@0.51-175-33.customer.lyse.net)
[19:25:45] *** Joins: srhm (~srhm@user/srhm)
[19:26:54] <gin> is one considered a better style than the other here: https://plaster.tymoon.eu/view/2662#2662 ? The first one has: if fancy collect this else collect that. The other has: collect (if fancy this that)
[19:29:07] <beach> gin: The second is usually better.  And it also works if you have something more complicated than IF, say for instance collect (let ((....)) (if ...))
[19:29:29] <gin> beach: thanks
[19:29:52] *** Joins: Catie (~user@2603:3023:523:400:82e8:2cff:fed9:cc84)
[19:29:55] <beach> On the other hand, if your collect is conditional, you must use the first one, or use an APPEND that sometimes returns the empty list.
[19:33:10] *** Quits: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[19:34:01] <gin> ok
[19:35:18] <_death> waleee: the commit responsible is from today.. might want to alert sbcl devs
[19:37:35] <waleee> ok will pop in to #sbcl
[19:43:24] *** Quits: Inline (~Inline@2a02:908:1252:7a80:89dc:6a58:9f2a:ff3d) (Ping timeout: 265 seconds)
[19:43:53] *** Quits: Cymew (~ante@c-e989225c.023-1144-7570702.bbcust.telenor.se) (Ping timeout: 265 seconds)
[19:47:15] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[19:48:24] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[19:48:31] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[19:49:55] *** Joins: jealousmonk (~user@2804:431:e7c4:cbd0:ae30:e39b:f4a:15d4)
[19:57:00] *** Quits: hendursa1 (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[20:00:40] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Ping timeout: 265 seconds)
[20:01:19] *** Joins: amb007 (~a_bakic@76.15.23.93.rev.sfr.net)
[20:05:29] *** Joins: hendursaga (~weechat@user/hendursaga)
[20:13:39] *** Quits: amb007 (~a_bakic@76.15.23.93.rev.sfr.net) (Ping timeout: 245 seconds)
[20:14:28] *** Joins: amb007 (~a_bakic@187.37.22.93.rev.sfr.net)
[20:18:27] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[20:20:37] <dieggsy> macros that evaluate a defun at macro expansion time rather than expand to a defun are kind of odd. is there a use case for this
[20:21:11] <Josh_2> For functions used in macro generation?
[20:21:20] <Josh_2> sorry functions that are used within macros
[20:21:28] *** Joins: kpoeck (~kpoeck@80.149.96.222)
[20:42:31] *** Quits: kpoeck (~kpoeck@80.149.96.222) (Quit: Client closed)
[20:44:06] *** Parts: _dave (~user@2600:1700:38a0:3d40::40) (ERC (IRC client for Emacs 27.2))
[20:46:00] <dieggsy> Josh_2: oh, yeah, that'd be. yep. we just have an actual outward facing function being generated this way and i found it odd
[20:46:32] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[20:47:41] *** Quits: Everything (~Everythin@37.115.210.35) (Quit: leaving)
[20:50:31] *** Quits: amb007 (~a_bakic@187.37.22.93.rev.sfr.net) (Read error: Connection reset by peer)
[20:52:32] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[20:55:22] <gin> for keeping a list of pair of delimiters what is a better data structure: '(("<" . ">") ("{" . "}") ("[" . "]")) or '(("<" ">") ("{" "}") ("[" "]"))? list of alists? or list of lists?
[20:56:16] <Bike> what are you using it for?
[20:56:58] *** Quits: JeromeLon (~jerome@2a00:23c7:99da:6600:b753:77aa:9ca8:5ffa) (Remote host closed the connection)
[20:57:20] *** Joins: JeromeLon (~jerome@2a00:23c7:99da:6600:ea86:291:a20e:c7f3)
[20:57:39] <Catie> gin: I would think the list of cons cells is more idiomatic, owing to the popularity of the (cdr (assoc ...)) construct
[20:58:09] <gin> Bike: for checking balanced delimiters in a string
[20:58:13] <pjb> dieggsy: there's no good use case for such a thing.  use (eval-when (:compile-toplevel)  (defun foo …)) to define functions usable at macro-expansion time.
[20:58:34] <pjb> dieggsy: you can define local functions in macros with flet or labels.
[20:58:34] <Bike> i guess conses seem fine. i don't see any reason to make them lists
[20:58:49] <gin> thanks Bike, Catie
[20:59:30] <dieggsy> pjb: well, they're doing both eval-when but also evaluating at expansion time.... it's. yeah. I'm gonna "if it aint broke don't fix it" but i won't follow that for my own use cases. not that i would have anyway lol. thanks
[20:59:39] <pjb> Bike: the reason to make them list is to make it easier to write the literal.
[21:00:14] <_death> gin: you can just use a string like "<>{}[]" and even/odd indices
[21:00:15] <pjb> But then, you can just use a flat list: ("<" ">" "{" "}" "[" "]")
[21:00:19] <pjb> or a string indeed.
[21:00:53] <pjb> Sometimes, they are multi-char: ("(*" "*)" "<:" ":>" "<" ">" "{" "}" "[" "]")
[21:01:17] <gin> _death: I thought about it but did not do it because then I would not be able to support multi-character delimiters. Like '(("{{" . "}}) ("<<" . ">>"))
[21:01:38] <_death> a hash-table is another option
[21:01:51] <pjb> Not easy to write a hash-table literal!
[21:02:26] <_death> alexandria has plist-hash-table
[21:02:41] <pjb> (loop for (left right) on '("<" ">" "{" "}" "[" "]") by #'cddr do (format t "~A yay ~A  " left right)) #| < yay >  { yay }  [ yay ]   --> nil |#
[21:03:03] *** Quits: _patrice (~patrice@2603:301c:604:2a00:f255:29f2:c2a4:cea8) (Quit: Leaving)
[21:03:04] *** Joins: patrice__ (~patrice@2603:301c:604:2a00:f255:29f2:c2a4:cea8)
[21:03:06] <pjb> _death: that doesn't make it a literal. You'd need to add #. and ensure the hash-table literal has a load-form!
[21:03:34] <_death> pjb: why do you need a literal
[21:03:44] <Josh_2> gin: I think I would personally go with an alist
[21:04:03] <pjb> gin: do you need a literal? Or is the bag mutable?
[21:04:18] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Quit: WeeChat 3.3)
[21:05:06] <gin> pjb: literal is fine because the list of delimiters is known in advance and can be hardcoded in the code as a literal
[21:06:01] <gin> I like the idea of making it a flat list (no alist, no list of lists) and then looping over it with (loop for (left right) on delimiters) ...
[21:06:39] <Catie> gin: You can treat it as a plist and use getf with it in that case
[21:06:47] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[21:07:13] <_death> not really.. a plist means keys are symbols (that's also why alexandria:plist-hash-table isn't such a good name)
[21:07:41] <Catie> _death: ah, you're right. my bad on that one
[21:07:42] <pjb> Catie: getf uses eql so it wouldn't work well with strings, but you can write your own accessor, or use symbols.
[21:08:10] <_death> getf uses EQ..
[21:08:46] <pjb> (getf '(< > { } [ ] \( \)) '<)  -->  >
[21:10:52] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Read error: Connection reset by peer)
[21:10:54] <pjb> right EQ
[21:12:12] *** Joins: Inline (~Inline@2a02:908:1252:7a80:89dc:6a58:9f2a:ff3d)
[21:13:22] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[21:15:39] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[21:16:45] <Josh_2> An alist would also mean you can easily search by the cdr with rassoc
[21:16:59] <Josh_2> lists are cool
[21:18:15] <pjb> (loop for (left right) on '(< > { } [ ] \( \)) by #'cddr until (eq '} right) finally (return left)) -> {
[21:19:10] <pjb> but indeed, alist are useful, when you want to be able to mutate an entry.
[21:21:05] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[21:22:29] <Josh_2> Tbf if its a constant then you can probably use compiler macros to make things go zoom zoom
[21:25:01] <pjb> Indeed.
[21:25:36] *** Joins: charles_ (~charles@cpe-76-186-124-165.tx.res.rr.com)
[21:26:57] *** Quits: srhm (~srhm@user/srhm) (Quit: Konversation terminated!)
[21:33:36] *** Joins: molson_ (~molson@2001-48F8-704A-CA1-0-0-75F-100E-static.midco.net)
[21:37:04] *** Quits: molson (~molson@2001-48F8-704A-CA1-0-0-75F-1009-static.midco.net) (Ping timeout: 268 seconds)
[21:37:32] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[21:49:34] *** Joins: selwyn (~selwyn@user/selwyn)
[21:49:50] *** Quits: selwyn (~selwyn@user/selwyn) (Remote host closed the connection)
[21:50:06] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[21:50:14] *** Joins: selwyn (~selwyn@user/selwyn)
[21:50:23] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[21:57:50] *** Quits: kevingal (~quassel@2a02:8084:4140:f300:bc92:daad:e13a:3716) (Remote host closed the connection)
[21:57:54] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[22:04:39] <jeosol> Good morning guys.
[22:05:53] <Josh_2> Mornin'
[22:05:59] <jeosol> I am trying to test my local workflow on a simple, cheap and remote cloud instance. Those running CL in a cloud vendor, what do you recommend. I know it's depends, but I just want to run SBCL (only), that a server remote and send jobs to it
[22:07:04] <jeosol> Second question: how might I start a repl remotely. I used ssh to test with my second box. Ideally, I want to run the command so it launches a repl remote and then I can send computations to it.
[22:11:07] <Xach> jeosol: i was not very happy with connecting a local emacs to a remote sbcl. i could not always get tramp things working properly, and network delays were frustrating. i switched to using a remote emacs. a wide screen split vertically, plus xterm-mouse-mode, plus mosh, made it work pretty well for my purposes.
[22:11:41] <Xach> also screen (some use tmux but i'm used to screen)
[22:11:53] <Josh_2> I have a VPS with many local images that I can connect to with sly, I actively develop many of these applications as they are run and are in use
[22:11:59] <Josh_2> I have all the source code on my own machine
[22:12:33] <Josh_2> so I dont worry have to worry about tramp or delays. They are barely noticeable with sly
[22:12:56] <Xach> Josh_2: interesting. stuff like M-. works without tramp when using sly?
[22:13:00] <jeosol> Xach: Thanks for that input. I tried a long time ago, but could not get it to work then, but I wasn't an expert at those things. Network impacts is something I am trying to evaluate. I can perform the computation on a local box in same network here around 3 seconds
[22:13:23] <Josh_2> Yes
[22:13:26] <Josh_2> Just tried it
[22:13:28] <Xach> Josh_2: i will have to revisit it sometime
[22:13:29] <Josh_2> oh wait
[22:13:33] <Josh_2> no I didn't try it sorry lemme go try it
[22:13:45] <sm2n> hmm, reading http://clhs.lisp.se/Body/02_df.htm and it seems that it's implementation-defined whether backquote produces literal data or not?
[22:13:52] <Josh_2> yes it does work on a remote image
[22:14:13] <Josh_2> first time I was hacking on a local image :P
[22:14:30] <Josh_2> C-c C-k does not work, you have to highlight the entire file then C-c C-c
[22:14:52] <Josh_2> At that point though I normally just change the image
[22:14:59] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[22:16:29] <etimmons> Do you compile the image locally? If not, do your source files have the same paths remotely and locally?
[22:17:06] *** Quits: rain3 (~rain3___@2a02:2f09:d003:5800:b41c:c37:1705:91bc) (Ping timeout: 265 seconds)
[22:19:28] <jeosol> etimmons: not sure if that was directed at me. But my for my use case, my two boxes I test on, everything matches. I don't edit files on second box though so as not to mess up git etc. I push from one machine to other (for computations only)
[22:19:48] <etimmons> Sorry, was aimed at Josh_2
[22:19:53] <jeosol> no worries
[22:20:23] <Josh_2> etimmons: I compile locally and I do not have any source files on my remote machine
[22:20:43] <etimmons> Ahhh, so I think that's why it works without Tramp
[22:21:02] <etimmons> The paths compiled in the image are valid on your local machine
[22:21:12] <Josh_2> My upload is pretty fast so only takes about 10 seconds to upload my 120mb sbcl image
[22:21:15] <Josh_2> yeh
[22:22:28] *** Joins: opcode (~nathan@user/opcode)
[22:23:19] *** Quits: cage (~cage@dynamic-adsl-84-220-249-98.clienti.tiscali.it) (Quit: rcirc on GNU Emacs 27.1)
[22:25:16] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[22:40:47] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Read error: Connection reset by peer)
[22:43:19] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[22:50:38] *** Joins: lottaquestions (~nick@2607:fa49:503e:3000:322e:8bf4:aff1:3553)
[22:51:21] <jmercouris> is there a way to specialize against nil?
[22:51:32] <jmercouris> so I have (defmethod seeds ((tomato tomato))) for example
[22:51:43] <jmercouris> can I also write (defmethod seeds ((empty nil))) ?
[22:52:04] <Josh_2> Yes null
[22:52:05] <_death> the class of nil is null
[22:52:08] <jmercouris> OK
[22:52:16] <jmercouris> that clears it up
[22:52:21] <jmercouris> thank you
[22:53:57] *** Quits: mgxm (~mgxm@user/mgxm) (Quit: ....)
[22:54:21] *** Joins: mgxm (~mgxm@user/mgxm)
[23:00:44] *** Quits: selwyn (~selwyn@user/selwyn) (Ping timeout: 245 seconds)
[23:00:57] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[23:01:55] *** Quits: heisig (~heisig@p508b531b.dip0.t-ipconnect.de) (Ping timeout: 265 seconds)
[23:02:10] *** Joins: charles__ (~charles@cpe-76-186-124-165.tx.res.rr.com)
[23:03:14] *** Joins: selwyn (~selwyn@user/selwyn)
[23:04:08] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[23:04:41] *** Quits: charles_ (~charles@cpe-76-186-124-165.tx.res.rr.com) (Ping timeout: 245 seconds)
[23:05:38] *** Joins: tfeb (~tfb@88.98.95.237)
[23:18:40] *** Joins: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca)
[23:25:10] *** Quits: azimut_ (~azimut@gateway/tor-sasl/azimut) (Remote host closed the connection)
[23:25:11] *** Quits: hendursaga (~weechat@user/hendursaga) (Remote host closed the connection)
[23:25:28] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[23:25:34] *** Joins: hendursaga (~weechat@user/hendursaga)
[23:39:26] *** Quits: tfeb (~tfb@88.98.95.237) (Quit: died)
[23:40:16] *** Joins: random-nick (~random-ni@87.116.183.117)
[23:44:53] *** Joins: gaqwas (~john@dynamic-077-004-075-231.77.4.pool.telefonica.de)
[23:45:09] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[23:47:46] <Psybur> Lets say I want to create a hash set of lists, and the order of elements in the list do not matter. How should I go about this? I dont see a way to specify a hash function for make-hash-table
[23:48:18] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[23:51:37] <_death> you can have the key be the list in a canonical order
[23:52:42] <Psybur> sort is giving me issues heh, i was thinking it would be easier to figure out a clever hash function than figure out why my code only works when I use sort combined with copy-list heh
[23:52:53] *** Joins: terrorjack (~terrorjac@static.3.200.12.49.clients.your-server.de)
[23:52:55] *** Quits: lottaquestions (~nick@2607:fa49:503e:3000:322e:8bf4:aff1:3553) (Quit: Konversation terminated!)
[23:53:03] <Bike> sort destroys lists. that's why
[23:53:09] <_death> a hash function is insufficient, you also need an equality operator in case of collisions
[23:53:16] *** Joins: lottaquestions (~nick@2607:fa49:503e:3000:df6f:9927:833b:d516)
[23:53:45] <Psybur> Bike, I know, and Im trying to use dynamic variables in my recursive calls to avoid copy-list but its still inefficient
[23:56:07] <Psybur> *insufficient
[23:57:11] <Psybur> Basically finding all unique depth first paths in a tree, where order of nodes doesnt matter
[23:58:20] <Psybur> Creating the path, then when I hit null, sort it and put it in a hashtable. I was able to get my alg working for small datasets of the problem, now trying to improve performance as i scale
[23:59:41] *** Quits: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
