[00:12:20] *** White__Flame is now known as White_Flame
[00:31:37] *** Quits: tanners (~tanners@2600:1003:b11a:a16f:d0aa:19cc:13f7:58b7) (Ping timeout: 240 seconds)
[00:32:38] *** Joins: tanners (~tanners@pool-71-127-59-41.washdc.fios.verizon.net)
[01:03:37] *** Quits: lagash (lagash@lagash.shelltalk.net) (Ping timeout: 240 seconds)
[01:03:42] *** Quits: JoshYoshi (~user@37.25.47.130) (Remote host closed the connection)
[01:04:00] *** Joins: Josh_2 (~user@37.25.47.130)
[01:10:13] *** Quits: mrmr (~mrmr@user/mrmr) (Ping timeout: 240 seconds)
[01:16:44] *** Quits: Kyuvi (~Kyuvi@dsl-hkibng31-58c38d-219.dhcp.inet.fi) (Ping timeout: 256 seconds)
[01:32:38] *** Quits: artchad (~user@public-gprs230031.centertel.pl) (Read error: Connection reset by peer)
[01:36:14] *** Joins: Oladon (~olad@98.43.81.226)
[01:48:54] *** Joins: lagash (lagash@lagash.shelltalk.net)
[02:08:42] *** Quits: lagash (lagash@lagash.shelltalk.net) (Ping timeout: 250 seconds)
[02:09:00] *** Quits: random-nick (~random-ni@87.116.181.150) (Ping timeout: 256 seconds)
[02:16:15] *** Joins: mrmr (~mrmr@user/mrmr)
[03:00:55] *** Joins: lagash (lagash@lagash.shelltalk.net)
[03:06:31] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[03:07:47] *** Quits: tanners (~tanners@pool-71-127-59-41.washdc.fios.verizon.net) (Ping timeout: 256 seconds)
[03:08:02] *** Joins: tanners (~tanners@2600:1003:b10c:b4b6:4e2:294a:11a:8db2)
[03:41:38] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[03:50:38] *** ryanbw1 is now known as ryanbw
[03:54:17] *** Quits: tanners (~tanners@2600:1003:b10c:b4b6:4e2:294a:11a:8db2) (Ping timeout: 240 seconds)
[03:54:20] *** Quits: selwyn (~selwyn@user/selwyn) (Quit: WeeChat 3.3)
[03:54:36] *** Joins: selwyn (~selwyn@user/selwyn)
[03:58:24] *** Joins: tanners (~tanners@pool-71-127-59-41.washdc.fios.verizon.net)
[04:19:44] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[04:41:10] *** Joins: sjl (~sjl@cpe-66-66-5-59.rochester.res.rr.com)
[05:37:00] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[05:56:00] *** Quits: lagash (lagash@lagash.shelltalk.net) (Remote host closed the connection)
[06:00:23] *** Joins: lagash (lagash@lagash.shelltalk.net)
[06:16:04] *** Joins: beach` (~user@lfbn-bor-1-623-116.w86-213.abo.wanadoo.fr)
[06:17:37] *** Quits: beach (~user@2a01:cb19:150:3400:a173:2cef:ba0f:9b68) (Ping timeout: 240 seconds)
[07:23:53] *** beach` is now known as beach
[07:26:37] *** Quits: sts-q (~sts-q@91.200.108.171) (Ping timeout: 240 seconds)
[07:30:31] <beach> Good morning everyone! 
[07:39:27] *** Joins: sts-q (~sts-q@212.53.219.138)
[07:56:39] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 250 seconds)
[08:20:53] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[08:39:10] *** Quits: bandali (~bandali@jir.shemshak.org) (Changing host)
[08:39:11] *** Joins: bandali (~bandali@gnu/bandali)
[08:48:09] <Demosthenex> woo! i'm keen, i was able to iterate over my text files recursively and abused file-position to allow movement instead of peek
[08:48:17] <Demosthenex> hoping that doesn't break any rules ;]
[08:49:09] * White_Flame calls interpol
[08:49:12] <beach> What is your reason for using recursion? 
[08:53:55] <Demosthenex> beach: loop feels weird. its like shoving python into a sexp.
[08:54:32] <Demosthenex> i'm trying to stay functional, and want to rely on raising conditions (got a new book)
[08:54:48] <beach> I am sorry you see it that way.  This attitude of yours is going to make your code more complicated, probably slower, and also more likely to blow that stack. 
[08:55:18] <beach> Conditions are not "raised" in Common Lisp.  They are "signaled". 
[08:57:00] <Demosthenex> beach: i'm not completely anti-loop hostile. its more of "can i write it differently"
[08:57:11] <Demosthenex> i don't like loop style, so i'm experimenting.
[08:57:20] <Demosthenex> i saw iter, i may try that later
[09:28:32] *** Joins: malaclyps (~mala@user/malaclyps)
[09:28:35] *** Quits: mala (~mala@user/malaclyps) (Read error: Connection reset by peer)
[10:09:57] *** Joins: Jing (~hedgehog@240e:390:7c53:a7e1:91de:85f0:a816:591c)
[10:29:30] *** Joins: st_iron (uid370243@id-370243.uxbridge.irccloud.com)
[10:30:21] <st_iron> good morning
[10:32:17] <beach> Hello st_iron 
[10:32:27] <st_iron> hi beach 
[10:33:02] <st_iron> not realy common lisp related, but when you have a lot of tasks, notes, etc. how do you manage them? do you have some tool or notebook?
[10:33:29] <st_iron> i'm doing a research on productivity for improving my workflow that's why i'm asking it
[10:33:55] <beach> I never write things on paper, because 1. I can't read my own handwriting, and 2. I can't use `grep' then.
[10:34:43] <st_iron> i've been using emacs org mode for many years
[10:34:55] <beach> That sounds like a good option.
[10:35:29] <st_iron> when i needed a lot of precision in work time and estimations i wrote a ton of custom code for it
[10:36:12] <st_iron> then some of my packages started to fail and i introduced a paper notebook to my system
[10:37:02] <st_iron> my input and sorting of  "stuff" works  as in GTD
[10:37:36] <st_iron> and now i'm about 1/3 org mode based and 2/3 paper 
[10:38:09] <st_iron> but i feel it's not ideal, i'm looking for remedies for some issues
[10:39:36] <beach> I should let others help.  I don't often have many simultaneously active tasks, and I frequently forget to work on some of them.
[10:41:33] <st_iron> oh, i see
[10:46:19] <Demosthenex> st_iron: org-mode.
[10:47:16] <Demosthenex> st_iron: maintain key files in your agenda and use capture (ie: biz and personal). one file per project otherwise.
[10:47:57] <st_iron> i do something like this: https://gitlab.com/tmolnar0831/emacs-config
[10:48:18] <st_iron> my custom agendas can sort and narrow to projects
[10:48:31] <st_iron> my project is when a task has children 
[11:18:05] *** Joins: artchad (~user@public-gprs230031.centertel.pl)
[11:56:16] *** Quits: Jing (~hedgehog@240e:390:7c53:a7e1:91de:85f0:a816:591c) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[11:56:31] *** Joins: random-nick (~random-ni@87.116.167.125)
[11:57:43] *** nimiux_ is now known as chealjo
[12:12:57] *** Joins: Jing (~hedgehog@240e:390:7c53:a7e1:1910:eb62:16d3:8874)
[12:15:08] *** Joins: Jing_ (~hedgehog@240e:390:7c53:a7e1:dddb:2811:79d2:379)
[12:18:17] *** Quits: Jing (~hedgehog@240e:390:7c53:a7e1:1910:eb62:16d3:8874) (Ping timeout: 240 seconds)
[12:50:46] <Demosthenex> beach: so for learning i'm trying to recreate my recursive file reading in loop, and it's just painful swapping to infix syntax :P
[12:53:29] *** Quits: artchad (~user@public-gprs230031.centertel.pl) (Remote host closed the connection)
[14:20:09] *** Quits: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb) (Remote host closed the connection)
[14:21:05] *** Joins: x88x88x (~x88x88x@149.28.53.172)
[14:41:30] <Demosthenex> beach: ok, so the iter version is significantly shorter and reads alright.
[14:41:56] <Demosthenex> i get recursion and stack is often an issue, and it makes for difficult reading. am i missing something? loop, iter, and recursion, is about all my options?
[14:42:19] <Demosthenex> typically i use lots of map*'s, database queries, in memory lists, etc.
[14:42:28] <Demosthenex> so i haven't needed loops as much
[15:16:35] *** Joins: nij- (~jin@2001-48F8-9021-806-0-0-0-619B-dynamic.midco.net)
[15:19:50] <nij->  The function RPLACA does not seem to be a special form. Yet, (rplaca *X* 2) does something out of my expectation. I thought during a function call, each entry in the cdr is evaluated and the result (as values) are passed to the function. In this model, why should #'RPLACA know where *X* points to, instead of what value *X* is stored at where *X* points to?
[15:33:52] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[15:36:40] <edgar-rft> nij-: because the SYMBOL-VALUE of *X* must be a cons, so evaluating *X* returns a pointer to the CAR of that CONS
[15:41:38] <nij-> I'm worried about the pointer semantics. Why doesn't (setq *Y* (car *X*)) let *Y* receive a pointer to the car of that cons, but rather the value?
[15:45:21] <beach> Demosthenex: Those are the usual options.  But I don't know your problem. 
[15:46:12] <beach> nij-: You still seem to be confused (assuming it was you the last time as well).
[15:46:41] <nij-> Yes, I'm still confused.
[15:46:52] <nij-> Last time was about setf, and I thought the macro does some magic.
[15:46:54] <beach> nij-: Common Lisp uses what I call "uniform reference semantics".
[15:46:59] <nij-> But this time.. rplaca is a function.
[15:47:48] <beach> So the value of *X* is a pointer (or a reference) to a CONS cell.
[15:48:19] <beach> The specification of RPLACA is to store something different in the CAR of the CONS cell that it is given (a pointer to).
[15:48:33] <nij-> Yes. Why doesn't (setq *Y* *X*) makes *Y* point to the same location?
[15:48:40] <nij-> But why*
[15:49:36] <beach> It does.  It modifies the value of *Y* so that whatever it contained before is lost, and after it contains the same values as *X*, that is the same reference to the same object. 
[15:50:10] <beach> SETQ is a special operator, so *Y* is not evaluated.
[15:51:54] <nij-> Oh.. it does. Indeed.. I thought not. (setf *X* (list 0 1)) (setq *Y* *X*) (rplaca *X* 9) *Y* ;; => (9 1)
[15:52:29] <beach> Right.
[15:52:52] <nij-> I have been playing fire :<
[15:59:51] <nij-> Is there a function ???? that does:
[16:00:03] <nij->  (defvar *X*) (defvar *Y* 0) (setq *X* 0) (setq *Y* *X*) (???? *X* 9) *Y* ; => 9
[16:00:39] * nij- feels like whatever ????, it should be avoided.
[16:01:19] <beach> That would not be possible.  
[16:02:00] <beach> Since functions are called with the values of the arguments, the ???? function would receive the values 0 and 9.
[16:02:23] <beach> There is no trace of where those values came from.
[16:03:06] <beach> And since the values are numbers, and there is no operator for mutating numbers, you can't do that either.
[16:08:17] <beach> nij-: Does that make sense to you?
[16:09:55] <nij-> Yes.
[16:10:04] <nij-> I'm thinking of another case that looks strange.
[16:11:17] <nij-> I see. The difference is that there's no internal function that allows mutating numbers, but there are that mutate lists.
[16:11:42] <beach> Correct.
[16:11:43] <nij-> So I should keep track of a list of data structures in Lisp that are not mutable.
[16:12:12] <bremner> or just don't reach for mutation first (says the schemer)
[16:12:23] <beach> nij-: All lists are mutable unless they are literals. 
[16:13:37] <nij-> in which case it's undefined behavior?
[16:13:53] <beach> Yes.
[16:13:56] <nij-> (rplaca '(0 0) 3) ; => (3 0)
[16:14:01] <nij-> on sbcl
[16:14:07] <beach> *sigh*
[16:14:17] <Demosthenex> beach: didn't have a problem. you said i shouldn't pursue the recursive option. i was trying alternatives =]
[16:14:27] <nij-> What makes you sigh, beach?
[16:15:14] <beach> nij-: Try (defun f () '(0 0)) then (rplaca (f) 3) then (f)
[16:15:39] <beach> Demosthenex: Great.
[16:15:43] <Demosthenex> i was only discussing because i'm trying to learn functional styles of lisp, and curious what other options i missed
[16:15:55] <nij-> ; => (3 0)  beach
[16:16:01] <beach> nij-: I know.
[16:16:49] <nij-> !! However, (defun f () (list 0 0)) (rplaca (f) 3) (f) ; => (0 0)
[16:17:05] <beach> Demosthenex: You will find a functional style in macro expanders in Common Lisp.  The reason is that they are executed at compile time, so performance is usually not an issue, and that macro expanders should not have side effects anyway.
[16:17:20] <beach> nij-: That behavior is well defined.
[16:17:42] <nij-> You mean the one you gave (defun with literal list)?
[16:17:59] <beach> No, the one you gave.
[16:18:07] <beach> The one I gave is undefined, but very strange. 
[16:18:14] <nij-> Gotcha. I'm trying to uderstand why (0 0) in my case.
[16:18:30] <nij-> Oh I see. Everytime (f) is evaluated, it generates a new list.
[16:18:34] <beach> In your case, the function creates a fresh list for eavery call.
[16:19:11] <nij-> (let ((l (list 0 0))) (defun f () l)) (rplaca (f) 3) (f) ; => (3 0)
[16:19:24] <nij-> Nice. Thanks for your patience!
[16:19:37] <beach> Sure.  That behavior is also well defined.
[16:20:39] <nij-> So to use immutable lists, I need to avoid calling rplaca or other list APIs that mutate the list.
[16:21:16] <beach> Yes, it's as simple as that.
[16:21:20] <nij-> Or I should create a new data type and provide no API that mutate it.
[16:21:31] <beach> Also some standard functions mutate.  In particular SORT, so be careful.
[16:22:03] <nij-> I'm sure some people really want immutability in CL. What's their best practice?
[16:22:20] <nij-> It seems that trying to avoid is kinda dangerous..
[16:22:35] <nij-> Better to create a new type of list, that doesn't allow any mutating API right?
[16:22:58] <beach> People who want immutability in Common Lisp want Common Lisp to be something that it is not. 
[16:24:08] <nij-> I get that.. but CL is also a programmable language, so I find that a legitimate thing to hope for..
[16:26:36] <beach> I don't understand how some programmers think.  Do they not trust themselves?  Do they not trust their team mates?  If you want to write functional code, then write functional code and don't use mutating operators.  If you don't like complex numbers, don't use complex numbers.  Etc.
[16:29:03] <nij-> When the team is too big, or the code base is too big, it becomes hard to trust.
[16:29:57] <nij-> When there's a bug, practically it helps to know that nothing would every mutate a data structure. If that makes sense.
[16:30:08] <beach> Then, how can you trust *anything* about the resulting code base?  I mean, for the result to be acceptable, it has to be inspected, verified, tested, etc.  
[16:30:43] <beach> I would not want to use any software written by a team whose members don't trust one another. 
[16:30:50] <nij-> While testing is a way to prove, it's dynamic but not static.
[16:31:17] <nij-> A code that's theoretically proven to be correct, it is something desired.
[16:31:42] <nij-> in short Tests != Proofs
[16:32:21] <beach> That's not my point.  Defects can creep in by mistake, and anyone can make mistakes.  But using a mutating operator when there is a rule that you are not allowed to do that is not a mistake.  It's a violation of explicit team rules.
[16:33:02] <beach> You could have Trojan horses and other malware in it that you can't test for.
[16:33:10] <nij-> I see. But then one needs to keep a list of operators not to be used in their brain.
[16:33:18] <nij-> Including libraries that could call those operators.
[16:33:52] <beach> Of course.  Just like you would need to know which libraries don't contain malware.
[16:33:54] <empwilli> there's always the section of "undefined behaviours" in every programming language. you'd be shocked what is undefined behaviour in c/c++ and what is commonly used
[16:34:17] <nij-> beach: I see your point. Hmm
[16:35:05] <beach> empwilli: Not as shocked as I was to find out how much undefined behavior that is in the Common Lisp standard.
[16:35:29] <nij-> So there are two approaches when it comes to "not mutating lists". One is to use your method, namely to be careful not to use anything that mutates list. Two is to create a new data type that doesn't expose any possibility of mutation.
[16:35:31] <beach> minion: Please tel empwilli about WSCL.
[16:35:33] <minion> watch out, you'll make krystof angry 
[16:35:37] <beach> Aww.
[16:35:53] <nij-> I see both of them legit. Sometimes it feels like the second one is easier.
[16:36:05] <beach> nij-: If you can't trust your team mates, they can get around that.
[16:36:34] <beach> nij-: They can use (SETF SLOT-VALUE) or REINITIALIZE-INSTANCE just to make your life difficult.
[16:36:37] <nij-> Yeah.. e.g. they can transform the new list into the old, use their stinky code that mutates, and transform them back.
[16:37:14] <nij-> Oh got it.. you mean whatever immutable lists I invent, they can always go under the hood and mess it around?
[16:37:23] <beach> Yes.
[16:37:29] <nij-> After all, my implementation must be based on the mutable ones.
[16:38:14] <beach> I think it is the totally wrong approach to attempt to write trustworthy code in the presence of team mates you can't trust. 
[16:38:25] <nij-> Same us that anyone can hack sbcl and make a function that mutates integers there. But then that's not conforming to the standard.
[16:38:29] <beach> Same thing in the presence of incompetent team mates. 
[16:39:07] <nij-> Yeah agree. incompetent => untrustable
[16:39:26] <beach> You could potentially mutate bignums, complex numbers, and double floats, but not fixnums or single floats (in SBCL).
[16:39:50] <nij-> Even if I hack the code of SBCL?
[16:40:03] <nij-> There must be some forbidden function that allows us to do that, right ?!
[16:40:16] <beach> Nope.
[16:40:23] <nij-> ?!
[16:40:43] <nij-> Why can't I mutate fixnums in SBCL, even if I really want?
[16:41:04] <empwilli> beach must be a big fan of the MISRA standard then ;>
[16:41:42] <beach> Because it is just a value the way it is represented.  Fixnums are not implemented as references.  That's how we can have uniform reference SEMANTICS without uniform references.
[16:43:53] <nij-> Unless I go to the assembly level?
[16:43:58] <beach> Nope.
[16:44:03] <beach> nij-: So when you do (SETQ X Y) and Y is a fixnum, X is not going to be a pointer to the same object as Y points to, because it is not a pointer (for performance reasons). 
[16:44:15] <beach> nij-: Do you know C?
[16:45:23] <beach> nij-: If you have x = 3; y = x; f(x); there is no way y can have a value other than 3 after the call.
[16:45:36] <beach> You can't write such a function in C, nor in assembly.
[16:47:44] <beach> Or this: f(3); and then print 3, could something other than 3 be printed?
[16:50:01] <nij-> Hmm (thinking)
[16:50:54] <nij-> So is it fair to say that it's ultimately because assembly does not provide functions that mutate fixnum?
[16:51:25] <beach> No, that's not fair to say.
[16:52:10] <beach> But a function call in C or Common Lisp like f(3) in this case, does the following: it evaluates the argument, and then sends a COPY of the value to the function f.
[16:52:47] <beach> Now if the value of the argument is a pointer to (say) a list, obviously f can modify the contents of the CAR or the CDR.
[16:53:15] <beach> But if the value is not a pointer, as is the case with fixnums, there is no longer any relation between the value of the argument, and what f received.
[16:53:25] <nij-> I get that. I'm thinking why fundamentally a list and a fixnum are treated differently.
[16:54:00] <beach> Because a fixnum is represented in the pointer itself, and not *as* a pointer to some memory.
[16:54:07] <beach> But those are implementation details. 
[16:54:49] <nij-> Well, you mean 1 points to the fixnum 1 itself?
[16:55:02] <nij-> That fixnum 1 must be stored at some place in the memory right?
[16:55:12] <beach> I mean there is no pointer involved when there is a fixnum.
[16:55:23] <nij-> If we go sufficiently low level, can't we mutate what's stored in that memory?
[16:55:24] <nij-> oh
[16:55:26] <nij-> hm
[16:55:30] <beach> Try this in SBCL: (eq 10 10) then (eq 10000000000000000000000000000000000 10000000000000000000000000000000000)
[16:55:56] <nij-> t; nil
[16:56:00] <beach> I know.
[16:56:19] <nij-> Because the larger one is not a fixnum.
[16:56:25] <beach> Right. 
[16:56:40] <beach> A fixnum in SBCL is represented as a 64-bit machine value where the last bit is 0.
[16:57:02] <beach> A bignum is represented as a pointer (so the last bit is not 0) to some memory.
[16:57:27] <beach> When you call EQ with 10 and 10, you get two copies of the same 64-bit machine value.
[16:57:40] <beach> So EQ returns true. 
[16:58:11] <nij-> I see. Here the machine values are the fundamental truth.
[16:58:25] <nij-> If I want to break this, I need to go further down.. which doesn't seem to exist.
[16:58:28] <beach> In the second case, EQ is passed two different pointers, because the reader created two different bignums in memory.
[16:58:46] <beach> You would have to change the way functions are called.
[16:59:15] <beach> In early versions of Fortran, you could actually do f(3) and then have 3 not be 3 after the call.
[16:59:24] <bremner> imho eq should not be your first choice unless you really know that you care about object identity or similar
[16:59:44] <beach> bremner: But I am trying to illustrate implementation details here.
[16:59:48] <bremner> ack
[17:00:01] <bremner> but the original observation was about eq
[17:00:05] <nij-> It's a good lesson. Thanks :)
[17:00:18] <pjb> edgar-rft: you're wrong. In most implementations, the "pointer" to a cons cell, actually points to the cdr slot.  More precisely, implementations often put the cdr at lower address than the car, so that walking the cdr-chain may be more efficient on such processors. cddr -> movea.l (a0),a0 ; movea.l (a0),a0
[17:01:18] <beach> pjb: I doubt that.  In both cases, the pointer would have tag bits, so you would either have to add a small value or subtract a small value before dereferencing. 
[17:01:27] <edgar-rft> I'm always wrong
[17:01:37] <pjb> edgar-rft: you're wrong again, because actually the reference to the cons cell contains the cons type tag, so actually the pointer points to some offset, so that you may have to use a negative offset to access the car, or the cdr: caddr --> lea -1(a0),a0 ; lea -1(a0),a0 ; move.l 3(a0),d0
[17:01:57] <pjb> beach: depending on the tag value, of course.
[17:02:04] <pjb> implementation choices.
[17:02:34] <beach> The reason was that Fortran always passed a pointer to a location containing the value, so that subroutines could modify the arguments being passed.  But then if a constant was passed, they stored that constant in a shared memory cell and passed a pointer to that cell.
[17:02:55] <pjb> anyways, the lesson here is that it's dangerous to talk of pointer when we talk about lisp. references it'll be.
[17:03:27] <nij-> pjb you mean it's better to use the word "reference" than "pointer"?
[17:03:32] <nij-> in our context (lisp)?
[17:03:42] <pjb> nij-: the two words refer to different concepts.
[17:03:52] <beach> nij-: Yes, because "pointer" usually means an explicit language feature.
[17:03:54] <pjb> nij-: pointers are machine addresses. references may be more complex.
[17:04:11] <nij-> I see.
[17:05:23] <edgar-rft> in the context of Lisp it's better to talk about references, because whether references are implemented as pointers or not is left to the specific Lisp implementation
[17:05:45] <edgar-rft> ...at least in most cases
[17:09:57] <nij-> Gotcha.
[17:10:48] <nij-> So to create real immutable lists, I have to make it so that each list points to a specific machine code...
[17:11:10] <nij-> How is that even possible, by the nature of list..? Even in other language.. how is that possible?
[17:12:28] <pjb> nij-: In the CL package, there are very few immutable data structures. numbers and characters are immutable, and closure are self-controlled.  All the other data structure are mutable AFAICR.
[17:13:05] <nij-> Yep. I'm thinking of how to create my own lists that are truly immutable.
[17:13:33] <pjb> nij-: for example, (complex 42 33) #| --> #C(42 33) |# gives you a number, ie. an immutable structure: (let ((c  (complex 42 33))) (values (realpart  c) (imagpart c))) #| --> 42 ; 33 |# there's no (setf realpart) or (setf imagpart).
[17:13:44] <pjb> but of course, you're limited to ratio or floats…
[17:14:29] <pjb> if you stored the elements of the list and the complexes in a vector, you could use integer complexes as cons cells.
[17:14:56] <pjb> But then, of course, the vector wouldn't be immutable, so that would break.
[17:15:49] <pjb> Now, you can use closures, but while CL doesn't provide any operators to access the inner of a closure, nothing prevents an implementation to provide "debugging" operators to do so. For example, all debuggers let you see the local variables in frames, and most allow you to mutate them.
[17:15:53] <pjb> But still.
[17:17:56] <pjb> nij-: https://termbin.com/e6xy
[17:18:30] <pjb> nij-: of course, once you've defined cons car cdr, you will have to redefine all the lisp list operators to be able to use them.
[17:18:53] <pjb> nij-: you may prefer to patch an implementation.
[17:19:48] <nij-> I see
[17:20:55] <pjb> More work than useful. Just don't use (setf car) or rplaca…
[17:21:28] <pjb> (defpackage "IMMUTABLE-CL" (:use "CL") (:export "CONS" "CAR" "CDR" #|NOT setf, NOT rplaca|# …))
[17:21:36] <nij-> I see. Can I summarize as - If one really wants to mutate fixnum, they need to change how the machine interprets the 64bit machine value. But most people aren't going to do that.
[17:21:43] <pjb> and (:use "IMMUTABLE-CL") instead of (:use "CL")
[17:27:21] <nij-> pjb what makes you prefer ccl than sbcl?
[17:54:30] <edgar-rft> probably Apple computers :-)
[18:09:06] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[18:23:20] <edgar-rft> Most of the fixnum arithmetic is hardwired in the CPU core, there's no way to change that without modifying the hardware. Of course you can create your own mutable nij-nums, e.g. by mapping fixnums to user-definable values via some lookup-table, but most of the builtin CL math functions wouldn't work with these numbers out of the box, so you would have to implement your own nij-math funtions, too.
[18:24:35] <beach> Again, I think the entire quest is misguided, so therefore a waste of time.
[18:30:12] <edgar-rft> I only wanted to tell rthat Lisp *is* a programmable programming language that can be programmed even to the weirdest non-Lisp behaviour ever, but you're right in saying that this then would not have mutch to do with Lisp anymore at all :-)
[18:30:17] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[18:39:41] <CodeBitCookie[m]> Hello Everyone!
[18:40:20] <CodeBitCookie[m]> Super newbie question, How do I pass arguments by reference. I learnt this one but forgot about it. When tried to search online, I couldn't find a solution that worked for me without a macro.
[18:40:48] <beach> You can't pass argument to a function by reference.
[18:40:58] <beach> Common Lisp is uniformly call-by-value.
[18:41:09] <CodeBitCookie[m]> but you can with a macro?
[18:41:29] <beach> Macros are called with forms as arguments, so that's very different.
[18:42:31] <CodeBitCookie[m]> So what can I do?
[18:42:38] <CodeBitCookie[m]> My problem is,
[18:43:59] <CodeBitCookie[m]> I have a function that sets up a texture for me. To avoid code duplication, I put that in its own function. The problem was, I had to give it a variable to store the texture into. So I had to pass that variable.
[18:44:09] <CodeBitCookie[m]> Wait a minute,
[18:44:24] <CodeBitCookie[m]> Can't I just return the variable after doing all operations to it?
[18:44:32] <CodeBitCookie[m]> and then set a variable to that?
[18:45:07] <beach> You don't pass or return variables.  You may pass and return VALUES of variables, but not the variables themselves (usually).
[18:46:14] <beach> But, yes, you don't pass a variable to store anything in, because that is not possible.  You assign the value returned by the function to the variable you want to initialize.
[18:46:49] <CodeBitCookie[m]> What do you mean by usually?
[18:46:50] <CodeBitCookie[m]> beach: ^
[18:48:16] <beach> Special variables are named by symbols, and you can get from the symbol to the value of the special variable, so in that sense you can say that you pass/return a variable.  No such thing is possible with lexical variables of course. 
[18:48:55] <CodeBitCookie[m]> Oh.
[18:49:55] <CodeBitCookie[m]> So we copy the value EVERY TIME? Even when there is a huuuuuuge vector with a lot of data?
[18:50:10] <beach> Call by reference is an efficiency kludge used in languages such as C++ because they copy everything by default, so you might want to avoid that, and because they don't allow for multiple return values, so if you want to return more than one thing, that kludge is sometimes necessary.
[18:50:20] <beach> GODDAMMIT!!!!!
[18:50:37] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 240 seconds)
[18:51:06] <beach> CodeBitCookie[m]: Common Lisp uses "uniform reference semantics", meaning that arguments are evaluated before passed to callee functions, but the values are references so no object is ever implicitly copied.
[18:51:23] <beach> CodeBitCookie[m]: Surely, you must have seen this before since you have been here for some time, no?
[18:52:56] <beach> CodeBitCookie[m]: I am sorry.  I just spent the better part of an hour explaining the details of all this to nij-.
[18:53:03] *** Joins: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se)
[18:53:18] <beach> CodeBitCookie[m]: And it seems I explain it all over again once a week or so.
[18:55:00] <beach> Common Lisp uses the only sane semantics for function calls, and it seems all newbies assume that it uses the absolute most stupid one.  I guess that means that most newbies have used only languages with stupid function-call semantics. 
[18:55:23] <beach> No wonder the computing industry is in such a mess.
[18:55:42] <CodeBitCookie[m]> <beach> "GODDAMMIT!!!!!" <- Oops, I am very sorry. Its just that I can never understand it. I remember I even read that website you told me to read and understood it all. It just doesn't stick in my head. :(
[18:56:12] <CodeBitCookie[m]> I still don't remember it fully.
[18:57:23] <beach> I will retire in less than a month, but I always thought I was not too bad as a teacher.  It seems I must have been wrong about myself all these years, because I seem unable to explain something so fundamental. 
[18:57:42] <beach> CodeBitCookie[m]: Do you know C?
[18:59:09] <CodeBitCookie[m]> Yes
[18:59:11] <beach> CodeBitCookie[m]: Imagine every Common Lisp object is of type `void *' then, and that every operation allocates a chunk of memory on the heap and returns a void * to it.  Then you have a pretty good approximation of Common Lisp semantics.  
[19:00:17] <beach> Notice the word "semantics".  Which means "it works as if", not "it does that".
[19:01:42] <beach> So in Common Lisp, something like (setq y x) is an assignment of a single word, typically a register operations.  In a language like C++, the default is to copy the object instead, so C++ is much less efficient.
[19:02:43] <CodeBitCookie[m]> so basically, everything works as a pointer, and the values through arguments are pass-by-value but are not copied. Right?
[19:03:12] <beach> Right, the values that are passed are references.
[19:04:56] <beach> "call by value" has never meant that objects are copied.  The term just means that arguments are evaluated and the values are passed to the function being called.  In C++, by default, the values are the objects themselves.  In Common Lisp, the values are references.  C++ is that stupid because it does not have automatic memory management. 
[19:07:58] <CodeBitCookie[m]> wait, let me try to understand this. It's not that I am not active, I am just processing.
[19:16:44] <beach> Take your time. *sigh* :)
[19:23:23] <Kabriel> Perhaps you could program one of the bots with a link to your essay on uniform reference semantics and then start with "bot tell person about URS".
[19:27:46] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[19:29:03] *** Joins: Kyuvi (~Kyuvi@dsl-hkibng31-58c38d-219.dhcp.inet.fi)
[19:29:03] <beach> I thought we had done that, but I can't seem to find the keyword. 
[19:31:31] <beach> Maybe someone cleared out the terms known by minion. 
[19:35:35] <edgar-rft> minion: semantics?
[19:35:35] <minion> semantics: For a concise definition of the Common Lisp semantics of assignments and function calls, please see http://metamodular.com/common-lisp-semantics.html
[19:35:58] <edgar-rft> beach: is this what you were looking for?
[19:36:14] <bremner> that sounds like a bit much
[19:36:24] <bremner> oh, I should read first, I guess
[19:39:35] <edgar-rft> minion: tell bremner semantics
[19:39:35] <minion> bremner: look at semantics: For a concise definition of the Common Lisp semantics of assignments and function calls, please see http://metamodular.com/common-lisp-semantics.html
[19:39:45] <edgar-rft> :-)
[19:39:46] <bremner> mp i
[19:39:51] <bremner> err. no u!
[19:47:01] *** Joins: Oladon (~olad@98.43.81.226)
[20:00:44] *** Joins: nexeq (~nexeq@user/nexeq)
[20:01:56] <beach> edgar-rft: Thanks.
[20:01:56] *** Quits: nexeq (~nexeq@user/nexeq) (Read error: Connection reset by peer)
[20:02:20] <beach> bremner: "much"?
[20:03:06] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[20:06:21] *** Joins: nexeq (~nexeq@user/nexeq)
[20:07:57] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Client Quit)
[20:09:55] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[20:19:39] <bremner> beach: it's a fair amount to take in for a FAQ answer, but maybe that cannot be helped
[20:20:45] <beach> I see.  If you find a shorter explanation, let me know.
[20:21:42] <bremner> fair enough.
[20:29:09] <nij-> edgar-rft: Got it :)
[20:32:51] <beach> Anyway, I'm off for today.  It is time to go fix dinner for my (admittedly small) family.
[20:33:11] <bremner> bye, thanks for your contributions
[20:38:08] <nij-> Thank you beach !
[20:38:35] <nij-> CodeBitCookie[m]: Try this: (setf *X* (list 0 1)) (setq *Y* *X*) (rplaca *X* 9) *Y* ;; => (9 1)
[20:48:44] <pjb> CodeBitCookie[m]: you can pass arguments "by reference" using C-like "pointers",  cf.  http://informatimago.com/articles/usenet.html#C-like-pointers-in-Lisp
[20:50:33] <pjb> beach: teaching in front of a black board with student in the same room, is not the same thing as trying to teach thru irc.  We're all bad at teaching thru irc.
[20:51:38] <White_Flame> CodeBitCookie[m]: fundamentally, if you want to pass something that will be changed, you're passing a composite and will change a slot/element of it
[20:52:02] <pjb> CodeBitCookie[m]: so about those huge vectors, the thing is that we don't store vectors in variables.  We only store references in variables.  And it's those references that are copied to the parameter variables.
[20:52:04] <White_Flame> if you have (let ((a 3)) ...) then you can't pass the "location of A" and have something from the outside mutate it to 4
[20:53:03] <White_Flame> but, (let* ((a 3) (changer (lambda (new) (setf a new))) ....) you can pass the changer function/closure around and it can change A
[20:53:21] <pjb> CodeBitCookie[m]: so while arguments are passed by value (copying the value), since those values are actually references to the actual objects that are ALL stored in the heap, you get a kind of pass the objects by reference.
[20:53:23] <White_Flame> because it has A in its lexical scope
[20:53:36] <pjb> CodeBitCookie[m]: but indeed, not pass the variable by reference.  
[20:54:07] <pjb> CodeBitCookie[m]: White_Flame is right, only you can, using C-like-pointers, see links above.
[20:55:22] <White_Flame> now, if (let ((a (list 1 2 3)) ...) you can pass A around (which is a reference to the 1st cons cell) and those other functions can mutate the car/cdr of those cons cells
[20:55:35] <White_Flame> *pass the value of A around
[20:55:53] *** Joins: lisp123 (~lisp123@5.30.23.247)
[20:56:04] <White_Flame> and each place that the value of A is passed around refers to that exact same (1 . ...) cons cell
[20:56:43] <White_Flame> in the (let ((a 3)) ...) case, the value 3 is primitive and immutable
[20:57:17] <White_Flame> in the (let ((a (list ...))) ...) case, the list value is composite and mutable
[20:58:03] <pjb> In both cases, it's the same: A:[*]--->3   A:[*]--->(1 . [*])--->…
[20:58:44] <White_Flame> right, hence the thing being described is the "value"; the "variable" just names some slot on the stack where that value can be stored
[20:58:57] *** Quits: tanners (~tanners@pool-71-127-59-41.washdc.fios.verizon.net) (Ping timeout: 256 seconds)
[20:59:01] <pjb>  The only difference is that since 3 is immutable (numbers and characters are),    the implementations are allowed to copy them instead of keeping the same reference.
[20:59:45] *** Joins: tanners (~tanners@2600:1003:b127:bfd4:fcb8:9a4c:c23:f972)
[20:59:54] <pjb> after (let ((a 3) b)  (setf b a)  you can have A:[*]--->3<---[*]:B  or A:[*]--->3   B[*]--->3  a different copy of 3.
[21:00:25] <pjb> you can detect it with (let ((a 3)) (eq a a)) -> nil (or t, depends).
[21:00:50] <pjb> Hence you should not use EQ.
[21:07:01] <nij-> are strings mutable in CL?
[21:13:50] <White_Flame> yes, they are just arrays
[21:14:03] <White_Flame> hence you have to be careful about mutating literals
[21:15:32] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[21:16:35] *** Quits: Jing_ (~hedgehog@240e:390:7c53:a7e1:dddb:2811:79d2:379) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[21:22:13] <nij-> Indeed.. (defvar *S* "Help!") (setf (elt *S* 3) #\l) *S* ; => "Hell!"
[21:22:40] <nij-> Hmm.. is this UB?
[21:22:56] <White_Flame> I believe so
[21:24:03] <White_Flame> "The consequences are undefined if literal objects (including quoted objects) are destructively modified."
[21:24:40] <White_Flame> (from the QUOTE page http://www.lispworks.com/documentation/HyperSpec/Body/s_quote.htm )
[21:29:20] *** Joins: lisp123 (~lisp123@5.30.23.247)
[21:29:26] <edgar-rft> I'm not 100% sure but what would be the point of having arrays if I can't mutate them?
[21:32:43] <nij-> shorter lookup time?
[21:34:39] <edgar-rft> CLHS 5.1.2.2 mentions CHAR as SETF-able function call what I think would not be possible if strings were immutable.
[21:36:07] <edgar-rft> ...what means that this is valid behaviour according to CLHS: (defvar *S* "Help!") (setf (char *S* 3) #\l) ; => "Hell!"
[21:36:48] <edgar-rft> and if I'm not totally wrong then ELT calls CHAR if the sequene is a string
[21:37:26] <nij-> It boils down to this - does "Help!" generate a literal string or not?
[21:43:02] *** Quits: nexeq (~nexeq@user/nexeq) (Read error: Connection reset by peer)
[21:43:07] <White_Flame> it's not valid, because it's mutating a string that originally came from a literal
[21:43:13] <White_Flame> nij-: yes
[21:43:58] *** Joins: nexeq (~nexeq@user/nexeq)
[21:44:05] <White_Flame> (copy-seq "Help!") would give you a mutable copy
[21:45:00] <White_Flame> and of course any string gotten at runtime from I/O would be mutable
[21:45:13] <White_Flame> just not those which directly exist in the source code
[21:45:57] <White_Flame> there's no guarantee that the one you're mutating is going to be reused or not on subsequent calls to the same code built from it
[21:50:59] <nij-> White_Flame: Got it.
[21:52:53] <edgar-rft> White_Flame: thank you
[22:16:20] *** Quits: nexeq (~nexeq@user/nexeq) (Read error: Connection reset by peer)
[22:17:16] *** Joins: nexeq (~nexeq@user/nexeq)
[22:18:37] *** Quits: tanners (~tanners@2600:1003:b127:bfd4:fcb8:9a4c:c23:f972) (Ping timeout: 240 seconds)
[22:18:58] *** Joins: tanners (~tanners@pool-71-127-59-41.washdc.fios.verizon.net)
[22:19:03] *** Quits: tanners (~tanners@pool-71-127-59-41.washdc.fios.verizon.net) (Client Quit)
[22:50:03] *** Quits: nexeq (~nexeq@user/nexeq) (Read error: Connection reset by peer)
[22:50:46] *** Joins: nexeq (~nexeq@user/nexeq)
[23:04:01] *** Quits: nexeq (~nexeq@user/nexeq) (Ping timeout: 256 seconds)
[23:11:38] *** Parts: nij- (~jin@2001-48F8-9021-806-0-0-0-619B-dynamic.midco.net) (Using Circe, the loveliest of all IRC clients)
[23:12:26] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[23:14:39] *** Joins: lisp123 (~lisp123@5.30.23.247)
[23:19:29] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[23:26:27] *** Joins: nexeq (~nexeq@user/nexeq)
[23:34:30] *** Quits: nexeq (~nexeq@user/nexeq) (Read error: Connection reset by peer)
[23:35:46] *** Joins: nexeq (~nexeq@user/nexeq)
[23:37:52] *** Quits: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se) (Ping timeout: 250 seconds)
[23:52:12] *** Quits: Kyuvi (~Kyuvi@dsl-hkibng31-58c38d-219.dhcp.inet.fi) (Ping timeout: 256 seconds)
[23:55:37] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
