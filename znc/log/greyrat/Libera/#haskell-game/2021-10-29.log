[02:56:21] *** Quits: Inst__ (~Inst@2601:6c4:4080:3f80:258f:7b54:f932:b719) (Ping timeout: 245 seconds)
[03:05:07] <f-a> https://itch.io/jam/game-off-2021 ffs ManofLetters[m] you famous
[03:07:57] <ManofLetters[m]> yeah, just scrambling to publish 0.10.3 ASAP that works around freefont 2.11 breaking all bitmap fonts
[03:08:01] <ManofLetters[m]> the cost of fame
[03:08:17] <ManofLetters[m]> publish before the Game Off
[03:08:33] <f-a> I hope you can get new players
[03:08:45] <ManofLetters[m]> me too :) and new contributors
[03:08:53] <f-a> were you aware of it?
[03:08:59] <f-a> I suppose so
[03:09:08] <ManofLetters[m]> yes, it's third year in a row or something
[03:09:14] <f-a> oh, ohhh
[03:09:21] <f-a> good bribing that first year then :P
[03:09:32] <ManofLetters[m]> yeah, then blackmailing only
[03:09:49] <sm> where's the fame ?
[03:10:12] <f-a> C-f for Â«haskellÂ»
[03:10:12] <ManofLetters[m]> close to the bottom of the page
[03:10:23] <sm> ah, "Hack on a Roguelike dungeon crawler in JavaScript or Haskell."
[03:10:31] <f-a> link sends to AotS
[03:10:45] <sm> LambdaHack. cool.
[03:10:57] <f-a> sorry lambdahack, yeah
[03:11:19] <ManofLetters[m]> thought that order, JS first, is still something to strive to change :)
[03:11:25] <ManofLetters[m]> so can't retire in glory yet
[03:12:13] <sm> finding and networking with game jams is a great way to market
[03:12:46] <f-a> enter with hledger
[03:13:04] <sm> I like their graphic!
[03:13:12] <f-a> Â«discover the shenanigans of a shady foundation by helping the IRSÂ»
[03:15:32] <ManofLetters[m]> ugh, I've cut corners in the release checklist and it shows https://github.com/LambdaHack/LambdaHack/issues/76
[03:15:43] <ManofLetters[m]> I'm about to release tomorrow and I'm still finding bugs
[03:16:18] <sm> should be a "- Happy in Haskell ? Try FunGEn or sdl2"
[03:16:21] <ManofLetters[m]> the worst is bugs caused by fixes to other bugs, because it implies I should start over testing after each major fix
[03:16:37] <sm> Man of Letters: ack.. releasing is the worst!
[03:16:57] <sm> especially haskell apps, I will say
[03:17:12] <ManofLetters[m]> why especially?
[03:18:23] <sm> I'll have to think about it a little.. the complexity of the tools.. all the ways to get dependencies wrong.. the fast (yet slow) moving compiler..
[03:18:28] <sm> intense automation is the only way to stay sane I find
[03:19:04] <ManofLetters[m]> right, e.g., your changelog system must be helping
[03:19:08] <sm> the slow build times..
[03:19:12] <sm> it sure is
[03:20:05] <ManofLetters[m]> re tools, indeed, I'm skipping web browser release this time, but otherwise, GHCJS/Closure Compiler/JS libraries sure is a pain
[03:20:28] <f-a> hledger is one of the cosiest builds in the whole haskell ecosystem
[03:21:42] <sm> smooth building has been a goal since day 1, and with haskell stuff it isn't easy
[03:24:28] <sm> I think most haskellers don't really aim for that, so things don't improve very fast
[03:26:40] <f-a> we have an ecosystem problem
[03:26:48] <f-a> and a monoculture (*nix) problem
[03:27:30] <sm> I think haskell handles windows really quite well, but it can always be better
[03:31:40] <sm> doh! let me correct my earlier comment. "- Happy in Haskell ? Try ansi-terminal-game or FunGEn or sdl2"
[03:31:58] <f-a> :)
[03:33:07] <sm> wait, do we have to add LambdaHack to that ? I assume it's not a general game engine
[03:33:18] <sm> and ic.rbow 's ?
[03:34:03] <ManofLetters[m]> ic.rbow's is
[03:34:09] <sm> Keid, right ?
[03:34:23] <ManofLetters[m]> I think there are many
[03:36:07] <sm> I imagine for other languages they picked the top 1 or 2 engines, for which probably the best measure is number of games built, and in haskell the leader there would be, I guess, sdl2
[03:36:27] <f-a> sdl2 is far from an engine tho, I suspect
[03:36:55] <sm> does it not include a basic game loop, ie enough to make a game ?
[03:36:55] *** Quits: terrorjack (~terrorjac@static.3.200.12.49.clients.your-server.de) (Quit: Ping timeout (120 seconds))
[03:37:37] <ManofLetters[m]> not a loop, but the event handling would be enough, it was thread-safe, which it isn't on OSX
[03:37:45] <ManofLetters[m]> *if it was
[03:37:48] <f-a> nope you have to do it yourself. You *have* lots of examples tho (lazyfoo, which are in the haskell repo too, translated to haskell)
[03:38:02] *** Joins: terrorjack (~terrorjac@static.3.200.12.49.clients.your-server.de)
[03:38:28] <sm> right I guess it doesn't come with a game loop like a-t-g or fungen.. just the parts to build your own
[03:38:49] <sm> what's that Man of Letters, sdl2 doesn't work on mac ? I thought it does
[03:39:08] <ManofLetters[m]> it does, but it's not thread-safe there
[03:39:12] <ManofLetters[m]> just as OpenGL
[03:39:28] <ManofLetters[m]> so you can't use the SDL non-blocking and non-polling event system
[03:39:35] <ManofLetters[m]> the one that all examples use
[03:39:40] <ManofLetters[m]> but instead you need to poll
[03:39:52] <f-a> I loved fungen for that
[03:39:54] <sm> hmm.. what does that mean in practice ? I played eg dinorush, and didn't notice
[03:39:56] <ManofLetters[m]> unless you are fine not using threads
[03:40:07] <ManofLetters[m]> or letting SDL2 hog the OS thread
[03:40:39] <sm> https://github.com/jxv/dino-rush I mean
[03:42:03] <ManofLetters[m]> I don't remember (I read the source)
[03:42:22] <f-a> there was an explanatory blogpost
[03:43:55] <ManofLetters[m]> perhaps they let SDL2 hog the OS thread, both for drawing and input (events) and move their main game loop there as well, instead of keeping it on a thread where it's nicely separated from frontend and where it's faster communicating with many other threads than when it's on the OS thread
[03:44:22] <ManofLetters[m]> (OS thread has overhead in communication so you normally spawn an async from it ASAP and branch your threads from there)
[03:44:29] <ManofLetters[m]> (but with SDL2 you can't)
[03:44:50] <ManofLetters[m]> (unless you hack terribly as I do and poll for events, which is tragic)
[03:45:26] <ManofLetters[m]> (OS thread is also called "bound" thread)
[03:45:55] <ManofLetters[m]> (for -N1 apps, it's the main thread)
[03:46:25] <sm> Man of Letters: interesting stuff. You have a sdl2 version of AOTS that runs on mac, right ?
[03:46:47] <ManofLetters[m]> yes, except with freetype 2.11 it doesn't run
[03:46:53] <ManofLetters[m]> will do in a couple of days, though
[03:47:12] <sm> which polls, and plays fine, but it's maybe a bit less efficient/precise than it could be on non-mac ?
[03:47:13] <ManofLetters[m]> (Homebrew has the broken freetype version)
[03:47:53] <ManofLetters[m]> yes, it's bit less efficient due to the poll, when the game is idle, it's not 0%CPU, but some non-zero value, which is annoying
[03:48:00] <ManofLetters[m]> and, most of all, the code is hacky
[03:48:06] <sm> gotcha
[03:48:41] <ManofLetters[m]> the polling and an unsafePerformIO that injects control somewhere to draw on the OS thread out of the OS thread lopp
[03:50:09] <sm> is it something that requires a bit more love on the sdl2 package, or totally infeasible due to macos, do you think ?
[03:51:03] <ManofLetters[m]> the hack I've made can be added to sdl2 package, but it's useless for porting SDL2 demos that happily put all business login into the main UI loop
[03:51:14] <ManofLetters[m]> so it doesn't sound like it's be popular
[03:51:17] <ManofLetters[m]> actually
[03:51:30] <ManofLetters[m]> OSX specifically, a couple of years go, added the breakage
[03:51:38] <ManofLetters[m]> in order to discourage "bad practice"
[03:51:51] <ManofLetters[m]> of drawing from outside the frontend main loop on main thread
[03:52:20] <ManofLetters[m]> because, obviously, with bad programming languages, concurrency is error-prone
[03:52:23] <ManofLetters[m]> so they are right
[03:52:27] <ManofLetters[m]> but not with Haskell
[03:53:02] <ManofLetters[m]> here we can separate frontend completely via threads and channels and not drawn in bugs
[03:53:08] <ManofLetters[m]> *drown
[03:53:23] <sm> do you do that on windows/linux ? or do they use the same mac hack ?
[03:53:37] <ManofLetters[m]> actually, right now, in the same exe, I have 3 frontends and they could even all work at once
[03:53:40] <ManofLetters[m]> try that in C++
[03:54:25] <ManofLetters[m]> all use the same hack except web frontend, because JS is too slow already, so an extra overhead would be bad
[03:54:57] <ManofLetters[m]> and I'm aware Windows can easily break OpenGL the same
[03:55:10] <ManofLetters[m]> or perhaps some old versions of the drivers for some cards do
[03:55:19] <ManofLetters[m]> so, it's safer to have that hack for all
[03:55:33] * sm makes a note to study AOTS/LH if he ever makes a sdl/fungen game
[08:59:47] *** Quits: hamishmack (sid389057@hampstead.irccloud.com) (Ping timeout: 264 seconds)
[08:59:47] *** Quits: awpr (uid446117@lymington.irccloud.com) (Ping timeout: 264 seconds)
[09:02:17] *** Joins: awpr (uid446117@id-446117.lymington.irccloud.com)
[09:02:59] *** Joins: hamishmack (sid389057@id-389057.hampstead.irccloud.com)
[13:42:08] *** Joins: __monty__ (~toonn@user/toonn)
[19:15:27] *** Joins: tzh (~tzh@c-24-21-73-154.hsd1.wa.comcast.net)
[21:04:40] *** Quits: tzh (~tzh@c-24-21-73-154.hsd1.wa.comcast.net) (Quit: djvksd)
[21:11:46] *** Joins: chomwitt (~chomwitt@2a02:587:dc12:b600:12c3:7bff:fe6d:d374)
[21:26:07] *** Joins: tzh (~tzh@c-24-21-73-154.hsd1.or.comcast.net)
[22:53:03] <f-a> should not refactor
[22:54:14] * ManofLetters[m] whispers: you know you want to improve this code --- just a little tiny bit
[22:54:58] <f-a> now I see why ruby people claim to be productive
[22:55:03] <f-a> they do not have types
[22:55:12] <f-a> hence refactoring is a pain in the proverbial butt
[22:56:12] <icrbow[m]> "Rubber-typing the proverbial butt: a study in productivity"
