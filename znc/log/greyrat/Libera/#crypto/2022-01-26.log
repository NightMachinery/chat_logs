[00:03:01] *** Quits: gabriel1 (~gabriel1@user/gabriel1) (Remote host closed the connection)
[00:03:24] *** Joins: gabriel1 (~gabriel1@user/gabriel1)
[00:12:50] *** Quits: Nucleos (~Nucleos@user/Nucleos) (Quit: Client closed)
[00:13:52] *** Quits: zer0bitz (~zer0bitz@2001:2003:f444:a000:2055:673d:3155:da63) (Ping timeout: 250 seconds)
[00:24:52] *** Quits: pergaminho (~pergaminh@user/pergaminho) ()
[00:33:57] *** Quits: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net) (Ping timeout: 240 seconds)
[00:35:29] *** Joins: sdfgsdfg (~dfghsfgs@user/sdfgsdfg)
[00:39:10] *** Joins: _mikey (~mikey@user/mikey/x-4335048)
[01:37:27] *** Quits: Guyver2 (~Guyver@2001:985:f3f:1:4113:d133:680c:9b66) (Quit: Going offline, see ya! (www.adiirc.com))
[01:38:25] *** Joins: Nucleos (~Nucleos@user/Nucleos)
[01:56:33] *** Joins: jarthur (~jarthur@2603-8080-1540-002d-6889-d743-d7bf-132c.res6.spectrum.com)
[02:09:22] *** Quits: sdfgsdfg (~dfghsfgs@user/sdfgsdfg) (Quit: your partner prefers dildos)
[02:13:54] *** Quits: gproto23 (~gproto23@user/gproto23) (Ping timeout: 250 seconds)
[02:17:20] *** Joins: Pythayr` (~pither195@76-214-97-148.lightspeed.dybhfl.sbcglobal.net)
[02:18:16] *** Quits: lord| (~lordpipe@user/lordpipe) (Read error: Connection reset by peer)
[02:19:32] *** Quits: Pythayr (~pither195@64.42.181.51) (Ping timeout: 240 seconds)
[02:20:15] *** Joins: lord| (~lordpipe@user/lordpipe)
[02:26:37] *** Quits: Pythayr` (~pither195@76-214-97-148.lightspeed.dybhfl.sbcglobal.net) (Ping timeout: 240 seconds)
[02:26:53] *** Joins: Pythayr` (~pither195@64.42.181.51)
[02:28:06] *** Quits: byteskeptical (~amnesia@user/byteskeptical) (Quit: Lost terminal)
[02:33:31] *** Quits: etolier (~somewhere@122-199-44-127.ip4.superloop.com) (Quit: No Ping reply in 180 seconds.)
[02:34:55] *** Joins: etolier (~somewhere@122-199-44-127.ip4.superloop.com)
[02:35:19] *** Quits: ua__ (~ua@public-gprs226755.centertel.pl) (Ping timeout: 256 seconds)
[02:44:39] *** Quits: dude12312414 (~test@gateway/tor-sasl/dude12312414) (Quit: THE RAM IS TOO DAMN HIGH)
[02:45:25] *** Quits: machinedgod (~machinedg@24.105.81.50) (Ping timeout: 240 seconds)
[02:49:00] *** Joins: ua__ (~ua@public-gprs264209.centertel.pl)
[03:02:17] *** Quits: ua__ (~ua@public-gprs264209.centertel.pl) (Ping timeout: 240 seconds)
[03:05:46] *** Joins: d1cor (~diego@179.63.242.120)
[03:06:42] *** Quits: Nucleos (~Nucleos@user/Nucleos) (Quit: Client closed)
[03:17:00] *** Joins: ua__ (~ua@public-gprs225747.centertel.pl)
[03:19:37] *** Quits: gabriel1 (~gabriel1@user/gabriel1) (Remote host closed the connection)
[03:20:12] *** Joins: gabriel1 (~gabriel1@user/gabriel1)
[03:48:11] *** Joins: smach (~savio@177.12.44.211)
[03:49:57] *** Quits: d1cor (~diego@179.63.242.120) (Ping timeout: 240 seconds)
[03:50:47] *** Quits: boxframes (~Saloframe@2607:9000:2000:15::a45d) (Quit: Leaving)
[03:59:31] *** Joins: boxframes (~Saloframe@2607:9000:2000:15::a45d)
[04:15:01] *** Quits: Wulf (~Wulf@user/wulf) (Ping timeout: 240 seconds)
[04:16:59] *** Joins: Wulf (~Wulf@user/wulf)
[04:22:37] *** Quits: gabriel1 (~gabriel1@user/gabriel1) (Ping timeout: 240 seconds)
[04:26:23] *** Joins: gabriel1 (~gabriel1@user/gabriel1)
[04:40:48] *** Quits: instantp10neer (~instantp1@user/instantp10neer) (Ping timeout: 250 seconds)
[04:59:21] *** Quits: Seirdy (~Seirdy@sourcehut/user/seirdy) (Quit: exiting 3.3)
[05:10:58] *** Quits: dez (uid92154@user/dez) (Quit: Connection closed for inactivity)
[05:24:57] *** Quits: PJBoy (~PJBoy@user/pjboy) (Ping timeout: 256 seconds)
[05:34:32] *** Quits: gabriel1 (~gabriel1@user/gabriel1) (Ping timeout: 240 seconds)
[05:52:53] *** Quits: x88x88x (~x88x88x@149.28.53.172) (Read error: Connection reset by peer)
[06:06:01] *** Joins: cwebber (~user@user/cwebber)
[06:06:50] *** Joins: Seirdy (~Seirdy@sourcehut/user/seirdy)
[06:08:13] *** Joins: ic3blx_ (~ic3blx___@user/ic3blx/x-0942740)
[06:17:01] *** Quits: Ivii (~Ivyy@2001:a62:4c3:8e01:c2b8:b157:be3f:ced2) (Remote host closed the connection)
[06:25:59] *** Quits: halosghost (~halosghos@user/halosghost) (Quit: WeeChat 2.5-rc1)
[06:52:59] *** Parts: curium (~curium@mail.clouded.monster) ()
[07:06:27] *** Joins: vj-- (~vj@bras-base-toroon3514w-grc-83-174-93-56-58.dsl.bell.ca)
[08:31:46] *** Quits: cwebber (~user@user/cwebber) (Ping timeout: 250 seconds)
[08:35:34] *** Joins: FlorianBad (~FlorianBa@cpe-67-49-107-16.dc.res.rr.com)
[08:37:27] <FlorianBad> Hi there! If I encrypt a file in AES-256, and let's say I save that as file.aes, when I decrypt it I have no way to tell where it ends, correct? Because it may not be a multiple of 16 and if I filled up with \x00 or whatever, these characters might as well have been part of the original file? Is there any way around this without making some kind of
[08:37:28] <FlorianBad> custom format?
[08:37:28] *** Joins: FelixFish[m] (~felixfish@2001:470:69fc:105::1:2e23)
[08:37:28] *** Joins: MarkWatson[m] (~markwatso@2001:470:69fc:105::1:5be8)
[08:38:07] <FlorianBad> s/characters/bytes/
[08:40:37] *** Quits: zro (~zro@user/zro) (Ping timeout: 240 seconds)
[08:42:47] *** Joins: zro (zro@user/zro)
[08:44:24] <Peng> There are standard unambiguous padding schemes. E.g. if you have 5 bytes of padding, you could make them 5 0x05 bytes.
[08:44:28] <ericonr> FlorianBad: the usual padding schemes add a whole block of padding if the message length is a multiple of block size 
[08:44:35] <Peng> And e.g. CTR mode doesn't have that issue.
[08:44:55] <int-e> ciphertext stealing is a thing too... though really not intended for file encryption
[08:45:02] <Peng> And if you're using a higher level primitive, that should be specified or already taken care of.
[08:45:22] <Peng> And if you're using an even higher level file encryption program like age, that's definitely taken c\are of for you. :D
[08:45:25] <int-e> (with file encryption one would usually assume that there's room for an extra header and/or padding)
[08:45:55] <int-e> (oh and a signature or MAC while we are at it)
[08:45:57] <FlorianBad> peng: so if that's only one byte it would be 0x01? But ... not so reliable then, 1 of 256 changes of screwing up
[08:46:05] <Peng> FlorianBad: How?
[08:46:16] <FlorianBad> Because it could be part of the original file
[08:46:25] <Peng> No it couldn't
[08:46:26] <FlorianBad> (rather than a padding)
[08:49:20] <maroon> yes, the padding would be N repeats of byte value N, where N is <= the AES block length of 16
[08:49:34] <int-e> FlorianBad: the padding wouldn't be allowed to be empty; if the file length is a multile of 32 bytes, you'd add one more block full of 0x20 characters.
[08:49:40] <maroon> and if you dont find any of those 16 alternatives, you can choose to either decrypt with a warning, or refuse to decrypt at all
[08:50:10] <int-e> uh, 16 bytes
[08:50:10] <ericonr> (please choose to not decrypt at all)
[08:50:21] <FlorianBad> Oh I see, so you would ALWAYS have an extra 16 bytes then?
[08:50:23] <ericonr> or hm
[08:50:35] <ericonr> have a HMAC and make it not an issue lol
[08:51:23] <maroon> for certain types of plaintext, like UTF8 text, you could get away with appending 0-15 0x00's if your decryptor knows how to see that
[08:51:58] <maroon> because in that situation the padding remains unambiguously different than the message
[08:52:36] <maroon> or, if your plaintext is 100% going to always have a length that's already a multiple of 16, where no padding is ever needed
[08:57:52] <Alipha> FlorianBad: there would always be an extra 1 to 16 bytes of padding. There would never be 0 bytes of padding
[09:00:14] <FlorianBad> Alipha: but it has to be a whole block of 16 then, otherwise anything else is ambiguous
[09:00:34] <maroon> yes, anywhere from one 0x01 through sixteen 0x10's
[09:01:23] <maroon> you can also have padding be a single 0x80 followed by 0-15 0x00's, that's an alternate padding method known as 'one-and-zeroes', it also has 1-16 bytes of padding
[09:01:42] <FlorianBad> hmm I see, it's because of the possibility of 16 that you know a single final 0x01 cannot be part of the file
[09:01:46] <maroon> that's the kind of padding you'll find in sha256
[09:01:55] <Alipha> FlorianBad: yes
[09:02:12] <FlorianBad> ok I get it now:)  thanks
[09:17:43] <FlorianBad> Would it make sense in terms of security to use a passphrase converted to SHA-256 as AES key? (since the passphrase can have any length)
[09:18:00] <ericonr> no
[09:18:11] <ericonr> use a proper key derivation function
[09:18:15] <ericonr> (say, argon2id)
[09:18:30] <FlorianBad> hmm, why would that be a mistake? No one does that?
[09:19:03] <ericonr> because it means an attacker has a really easy time brute forcing your password
[09:19:17] <ericonr> in order to find the key being used
[09:19:35] <FlorianBad> really? What makes it easy?
[09:19:44] <ericonr> passwords
[09:19:53] <ericonr> .... usually have low entropy
[09:20:24] <FlorianBad> so you'd not blaming SHA-256 then but the original password?
[09:20:31] <ericonr> yes
[09:20:37] <ericonr> well, that and sha-256 is fast
[09:20:41] <ericonr> a kdf is slow
[09:20:47] <ericonr> uses up RAM, CPU and threads
[09:21:03] <ericonr> so any attacker that wants to test multiple passwords has a way harder time
[09:21:10] <FlorianBad> Ah! hmm I see
[09:21:55] <ericonr> using a KDF also means using a salt
[09:22:20] <ericonr> so rainbow tables / etc aren't viable shortcuts
[09:23:07] *** Quits: ic3blx_ (~ic3blx___@user/ic3blx/x-0942740) (Quit: Leaving)
[09:24:00] <FlorianBad> ok, that I don't understand.. but, by using a kdf I still have the possibility of building something very standard and repeatable? Meaning that if I lose my programs it's easy to rebuild the same thing that will decrypt just fine?
[09:24:14] <FlorianBad> something quite "standard"
[09:24:56] <ericonr> yes. you need to keep the salt around, but yes
[09:25:19] <FlorianBad> salt? lol (new to encryption;)  )
[09:25:31] <FlorianBad> ah, 16 bytes of random?
[09:26:39] <FlorianBad> so when a program makes a derivative of the key it always has a fixed salt? And in order to be compatible with that program we must use the same?
[09:27:43] <FlorianBad> hmm.... the "time cost" factor:)  I like that, can crank it all the way up then
[09:27:46] <ericonr> no, each password must use its own salt
[09:28:42] <ericonr> I think it's mostly safe to keep the salt with the encrypted objects, but don't quote me on that :P
[09:29:17] <maroon> the salt needs to be sent along with the ciphertext, otherwise the decryptor wont be able to generate the salted-key
[09:30:08] <maroon> salt is a public string, best if it's unique, which is mixed with the master key, so that each message uses a different AES key
[09:31:01] <maroon> for a stream cipher, the salt is called a 'nonce', for number used once, because for stream ciphers the key MUST MUST MUST be different each message
[09:31:34] <maroon> otherwise you can XOR 2 plaintexts together, and the result is the same as the 2 plaintexts xor'ed together - and if 1 of the 2 plaintexts is known...
[09:31:57] <FlorianBad> ok I see, so if I encrypt backups and I know I won't change their name then the salt could be the SHA-256 of the filename?
[09:32:52] <FlorianBad> or filename + filesize (next multiple of 16) e.g.
[09:33:09] <maroon> your backup is not encrypting the file headers?
[09:34:09] <maroon> the salt could techically be of any length, but all the examples i've seen are that it either matches the block length, or can be shorter
[09:34:17] <FlorianBad> no, I just want to end up with a single file.tgz.aes  I won't rename it but I don't want to have to keep anything with it or start building too custom formats. Everything is already in the tgz anyway
[09:34:45] <maroon> though the chances of a collision between 1st 128 bits of sha256(filename1) is probably low
[09:36:16] <maroon> if any length of salt is allowed, you could have salt be 1st 128 bits of HMAC(filename|uncompressed.size|compressed.size|filedate|filetime|whatever else in the header you want)
[09:36:45] <maroon> or soon people will be shouting that it should use argon instead of hmac
[09:37:23] <FlorianBad> no, because I don't know the uncompressed size or anything else when I just get the  file.tgz.ecc to decrypt, and don't even know the exact size of the tgz file (because of padding bytes)
[09:37:38] <FlorianBad> all I know really is the filename and the next multiple of 16 of the file size
[09:39:38] <maroon> oh yeah, i remember that i can't ever get the original timestamp from something that's gzip'ed
[09:40:17] <maroon> but using the path\filename may not be perfect, but since you cant alter the format, it's better than a static session key
[09:44:53] <maroon> or can you alter the format since you can restore the decrypted ciphertext to the original gzipped data? it will be obvious that the data is encrypted because you're encrypting the compression headers too
[09:46:13] <maroon> or you can't afford to change the filesize since you're applying a post-gzip layer?
[09:53:06] <int-e> maroon: there's an mtime field in the gzip header
[09:54:01] <maroon> hrm, every time i open a .gz in my filemanager, it always shows the inside file as having the current timestamp, and that's what it gives when extracting it
[09:54:57] *** Quits: rqsd (~rqsd@user/rqsd) (Ping timeout: 240 seconds)
[09:56:08] *** Joins: rqsd (~rqsd@user/rqsd)
[10:03:36] *** Joins: BOKALDO (~BOKALDO@user/bokaldo)
[10:04:17] <FlorianBad> maroon: that's right, that's because there's a post-gzip encryption.
[10:04:54] <maroon> FlorianBad, is gzip already rounding the filesize to a multiple of 16?
[10:05:25] <maroon> or that's fine because this would never cause the file.gz to use an extra disk sector?
[10:05:31] <FlorianBad> Let's say there's a big EMP and we all lose our computers data. Now I have these Blu-Ray discs in the safe. All I have in that is my set of programs that I'm writting, and each backup that is filename.tgz.aes
[10:06:01] <FlorianBad> so all I can use as salt really is the filename and the encrypted size (meaning the next multiple of 16 of the non-encrypted data, but I don't know that)
[10:06:33] <FlorianBad> I doubt gzip rounds it up, but I will for AES, using the padding scheme mentioned earlier
[10:07:00] <int-e> however gzip does know where the gzip data ends
[10:07:04] <FlorianBad> besides, I'm writing these programs to encrypt ANY file, so it should work for non-gzip anyway
[10:08:09] <FlorianBad> And what I "forgot" ;) to mention was that in fact it will be   file.tgz.aes.ecc :D  I'll wrap the whole thing in ECC-521
[10:08:22] <maroon> if doing this with files already pkzip'ed, that header contains timestamp, uncompressed+compressed size, path\filename, and either a crc32 or a longer crypto hash of the original contents
[10:08:49] <FlorianBad> maroon: sure but you don't know that at the moment you get the file and want to decrypt it
[10:09:20] <maroon> FlorianBad, but you do know it as soon as the file has been compressed
[10:10:06] <FlorianBad> yes but I don't want to have to store anything else than the file itself, and I don't want to start messing around with custom formats, the padding bytes is as far as I want to go. It has to be simple
[10:10:36] <maroon> the ecc-521 is doing what, encrypting the key that's used? being an appended signature?
[10:11:01] <FlorianBad> no, wrapping the whole data into a second encryption lol
[10:11:21] <FlorianBad> file.tgz.aes is encrypted into file.tgz.aes.ecc
[10:11:36] <maroon> a 2nd layer of AES?
[10:11:57] <FlorianBad> no, a second later *on top of* AES
[10:12:02] <FlorianBad> layer
[10:12:58] <maroon> ecc itself is for signing short hashes etc, it's like saying you're applying a 2nd layer of RSA
[10:13:00] <FlorianBad> I also has the advantage of being public/private encryption so I never really have to type the password when I make new backups
[10:13:49] <FlorianBad> maroon: what? no!
[10:14:15] <FlorianBad> ECC is a pretty damn good encryption method, for data
[10:16:07] <maroon> for 512 bits of data
[10:17:00] <maroon> public key is very slow, so it's used to transport the actual key used for a real stream/block cipher like aes/salsa etc
[10:17:34] <maroon> if you're encrypting 100mb of data with pure ECC, RSA, etc, you'll be here til the cows come home
[10:17:47] <FlorianBad> ok, then encrypt 512 bytes at a time, and since the encrypted data is already aes encrypted this is very random so that doesn't make things easy to have 100GB of it
[10:18:03] <FlorianBad> hmm
[10:18:48] <FlorianBad> ok now you make me think I need to do some testing;)   I have a pretty good i7 and I always assumed it would be fast, but... these files will be dozens of GB each
[10:20:16] <maroon> what 'mode of operation' would you use? ctr? cbc? cfb? other?
[10:23:19] <FlorianBad> CBC
[10:23:46] <maroon> also, it sounds like you can't have an authentication MAC because you're not wanting to alter the filesize other than padding to a multiple of 16 which can't crash into a new sector length?
[10:25:06] <maroon> even the AEAD ciphers with the authentication built into them - they have the authentication string appended to the ciphertext
[10:25:37] <FlorianBad> well, it will be quite obvious when gzip fails to decrypt if there's anything corrupted. And if you store on Blu-Ray M-discs you know no one changed the stuff ;)
[10:25:58] <FlorianBad> I will keep the md5s somewhere too, but I don't want to count on that and be unable to decrypt without it
[10:26:14] <maroon> md5?
[10:27:38] <FlorianBad> of the encrypted file, not the decrypted version
[10:28:05] <maroon> so you're just using md5 as a checksum to warn of defect?
[10:28:22] <FlorianBad> These are just backups, I'm not worried at all about malicious corruption, only data corruption from bad storage, so that would be obvious if something is wrong
[10:29:17] <maroon> cbc mode needs an IV whose length matches the 128-bit block length of AES, what were you planning to use with that?
[10:30:02] <FlorianBad> uh?
[10:30:13] <FlorianBad> "IV" ?
[10:30:14] <maroon> <FlorianBad> CBC
[10:30:36] <maroon> cbc needs to use a previous block of ciphertext, so it needs an IV to be the 'fake' ciphertext preceding block#1
[10:31:08] <maroon> 'initial vector'
[10:33:15] <FlorianBad> hmmm, to be honest I am using this implementation, which I don't everything about: https://metacpan.org/pod/Crypt::OpenSSL::AES
[10:34:43] <maroon> have you tested it to see what the size of the encrypted data for plaintext length = 16? if the size increases to more than 32 (padding), you've got an IV in there. if it's even longer, then you've got MAC authentication
[10:36:02] <maroon> and does it encrypt identical data into identical ciphertext each time?
[10:36:37] <FlorianBad> it's always 16
[10:36:46] <maroon> the ciphertext is 16?
[10:37:00] <maroon> for plaintext=16?
[10:37:35] <FlorianBad> Yeah I never noticed that it was different based on the previous data, but to be honest I never thought of verifying that
[10:37:53] <maroon> if you give it plaintext=15, does it pad to 16, or does it complain?
[10:38:08] <FlorianBad> it crashes, you need to pad it with something
[10:38:35] <maroon> if plaintext is 16 bytes of constant plus 16 bytes that changes, does only the 2nd group of 16 ciphertext change?
[10:38:43] <FlorianBad> the encrypt() function always wants 16
[10:38:59] <maroon> always 16 or multiple of 16?
[10:39:07] <FlorianBad> exactly 16
[10:39:11] <FlorianBad> for each encrypt() call
[10:40:12] <maroon> so it sounds like there's either CBC encryption using a fixed IV, or it's ECB mode, either of which is bad especially without a MAC
[10:40:36] <maroon> ie i dont see the function accepting a salt or an iv
[10:41:17] <FlorianBad> Hmm, damn I never thought about that. Yeah I'm pretty sure that a same set of 16 bytes results in the same output regardless of when it comes, because otherwise the module would need something to initialize/reset/etc the AES object
[10:41:27] <maroon> "This module is compatible with Crypt::CBC (and likely other modules that utilize a block cipher to make a stream cipher)." dunno what this means, since a stream cipher REQUIRES a unique key for each message, and shouldnt need to be padded to multiple of 16
[10:41:57] <FlorianBad> yeah, that's why I told you CBC, but maybe it isn't after all
[10:42:05] <FlorianBad> (if what you're saying is true) ;)
[10:42:57] *** Quits: zro (zro@user/zro) (Ping timeout: 240 seconds)
[10:45:07] *** Joins: zro (~zro@user/zro)
[10:46:11] <FlorianBad> I have to sleep unfortunately, but thanks again for all the info and we'll continue that tomorrow if possible.
[10:46:18] <maroon> i've had some experiences with mIRC borrowing some Blowfish routines from crypt::cbc, and before you trust this, you'd want to see some test vectors to be sure of what it's actually doing - i'm having trouble drilling into this site to find the actual encryption routine to see what it does with your function-call
[10:46:22] <maroon> ok l8r
[10:46:38] <FlorianBad> Libera web chat has a tendency to make me disconnect so I probably won't see replies unfortunatly but I will reconnect if it does
[10:46:44] * FlorianBad reading that
[10:47:28] <FlorianBad> I see, yeah I'd rather know what I'm really doing lol
[10:48:50] <FlorianBad> good night. thanks again all.
[10:50:41] *** Quits: Gallomimia (~Gallomimi@node-1w7jra2a2gqpw6fy074dbu4nj.ipv6.telus.net) (Remote host closed the connection)
[10:51:41] *** Joins: Gallomimia (~Gallomimi@node-1w7jra2a2gqpzeza34afif1to.ipv6.telus.net)
[11:23:39] *** Joins: sdfgsdfg (~dfghsfgs@user/sdfgsdfg)
[11:31:26] *** Quits: jarthur (~jarthur@2603-8080-1540-002d-6889-d743-d7bf-132c.res6.spectrum.com) (Quit: jarthur)
[11:38:35] *** Joins: Major_Biscuit (~MajorBisc@86-88-79-148.fixed.kpn.net)
[12:08:20] *** Quits: Major_Biscuit (~MajorBisc@86-88-79-148.fixed.kpn.net) (Ping timeout: 268 seconds)
[12:15:28] *** Parts: _mikey (~mikey@user/mikey/x-4335048) (WeeChat 3.4)
[12:17:51] *** Quits: FlorianBad (~FlorianBa@cpe-67-49-107-16.dc.res.rr.com) (Ping timeout: 256 seconds)
[12:20:21] *** Joins: machinedgod (~machinedg@24.105.81.50)
[12:23:41] *** Quits: sdfgsdfg (~dfghsfgs@user/sdfgsdfg) (Quit: your partner prefers dildos)
[12:31:22] *** Joins: Major_Biscuit (~MajorBisc@c-001-019-027.client.tudelft.eduvpn.nl)
[12:44:46] *** Joins: sdfgsdfg (~dfghsfgs@user/sdfgsdfg)
[12:58:21] *** Quits: kish` (~aqua@user/aqua) (Ping timeout: 276 seconds)
[13:02:13] *** Quits: Neoon (~Neoon@2607:5300:60:23a5::1111) (Ping timeout: 240 seconds)
[13:17:17] *** Quits: sdfgsdfg (~dfghsfgs@user/sdfgsdfg) (Ping timeout: 240 seconds)
[13:18:12] *** Joins: Guyver2 (~Guyver@guyver2.xs4all.nl)
[13:25:07] *** Joins: PJBoy (~PJBoy@user/pjboy)
[13:34:13] *** Quits: PsyZeus (~TheLight@user/psyzeus) (Ping timeout: 240 seconds)
[13:41:43] *** Joins: PsyZeus (~TheLight@2001:1af8:4700:b0e0:e00::)
[13:41:43] *** Quits: PsyZeus (~TheLight@2001:1af8:4700:b0e0:e00::) (Changing host)
[13:41:43] *** Joins: PsyZeus (~TheLight@user/psyzeus)
[13:46:36] *** Joins: gabriel1 (~gabriel1@user/gabriel1)
[13:52:16] *** Joins: andreasbuhr (~quassel@p549db3ef.dip0.t-ipconnect.de)
[13:53:00] *** Joins: Haohmaru (~Haohmaru@195.24.53.110)
[13:59:49] *** Joins: Neoon (~Neoon@2607:5300:60:23a5::1111)
[14:06:48] *** Joins: Ivii (~Ivyy@2001:a62:4c3:8e01:82f1:438:bc8a:caef)
[14:13:44] *** Quits: Ivii (~Ivyy@2001:a62:4c3:8e01:82f1:438:bc8a:caef) (Remote host closed the connection)
[14:13:58] *** Joins: Ivii (~Ivyy@2001:a62:4c3:8e01:777e:e76b:1130:2573)
[14:19:19] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 256 seconds)
[14:19:34] *** Joins: Lord_of_Life (~Lord@user/lord-of-life/x-2819915)
[14:28:55] *** Quits: Deknos (~someone@user/menace) (Quit: Deknos)
[14:29:09] <yawkat> https://community.letsencrypt.org/t/2022-01-25-issue-with-tls-alpn-01-validation-method/170450
[14:34:05] <yawkat> wonder what was wrong
[14:34:20] <yawkat> theres two patches https://github.com/letsencrypt/boulder/commits/main
[14:34:50] <yawkat> i dont see how the OID could have been exploited. i guess it must be an attack on tls 1.1?
[14:37:30] *** Joins: gproto23 (~gproto23@user/gproto23)
[14:39:38] <Peng> Speculating, the OID was probably a policy violation regardless of whether it was exploitable.
[14:41:24] *** Joins: kish` (~aqua@user/aqua)
[14:41:51] <yawkat> if it wasnt exploitable i wouldnt expect them to be cagey about the details
[14:42:13] *** Quits: kish` (~aqua@user/aqua) (Remote host closed the connection)
[14:42:31] <Peng> The TLS 1.1 thing was also an RFC violation apparently; dunno if it was a BR violation: https://github.com/letsencrypt/boulder/commit/aac900e20a1f04c734170ea7907136749ff21db9
[14:43:01] *** Joins: aqua (~aqua@user/aqua)
[14:45:12] <maroon> their zero-tolerance scorched earth policy had demanded someone re-issue certs because of a 1 seconds diff
[14:46:05] <Peng> Let's Encrypt further violated the BRs by not revoking quickly over that.
[14:46:38] <maroon> and another time the serial number had 63 bits of entropy instead of 64, recall!
[14:46:50] <Peng> That wasn't Let's Encrypt. :D
[14:47:35] <Peng> Ya know, serial numbers don't even have to be random now that everyone uses SHA-2. It was only necessary to make exploiting hash collisions harder while using MD5 and SHA-1.
[14:47:52] <maroon> but the serial is still 160 bits?
[14:48:11] <Peng> What?
[14:48:38] <maroon> wait im thinking of 2 things, the rsa cert has a 160 bit serial, and another place there's a 64 bit item
[14:50:48] *** Quits: aqua (~aqua@user/aqua) (Ping timeout: 276 seconds)
[14:58:26] *** Joins: kish` (~aqua@user/aqua)
[15:25:04] *** Joins: mjoerg (~user@user/mjoerg)
[15:26:50] *** Quits: mjoerg (~user@user/mjoerg) (Remote host closed the connection)
[15:29:26] *** Joins: dez (uid92154@user/dez)
[16:08:03] *** Joins: d1cor (~diego@179.63.242.120)
[16:10:57] *** Quits: gabriel1 (~gabriel1@user/gabriel1) (Ping timeout: 256 seconds)
[16:48:32] *** Quits: Major_Biscuit (~MajorBisc@c-001-019-027.client.tudelft.eduvpn.nl) (Ping timeout: 240 seconds)
[16:49:48] *** Joins: TheCoffeMaker (~TheCoffeM@user/thecoffemaker)
[16:54:23] *** Quits: rg (~r-g@51.159.55.86) (Ping timeout: 256 seconds)
[16:54:37] *** Quits: TheCoffeMaker (~TheCoffeM@user/thecoffemaker) (Ping timeout: 240 seconds)
[16:55:15] *** Joins: Major_Biscuit (~MajorBisc@86-88-79-148.fixed.kpn.net)
[16:56:32] *** Joins: citizen_stig (~citizen_s@2001:982:9f64:1:443c:7bd0:8f3c:6772)
[17:09:42] *** Quits: Ivii (~Ivyy@2001:a62:4c3:8e01:777e:e76b:1130:2573) (Quit: Leaving)
[17:10:27] *** Quits: pieguy128 (~pieguy128@bras-base-mtrlpq5031w-grc-52-65-93-194-105.dsl.bell.ca) (Ping timeout: 256 seconds)
[17:12:20] *** Joins: gabriel1 (~gabriel1@user/gabriel1)
[17:13:55] *** Joins: pieguy128 (~pieguy128@bas1-montreal02-65-92-163-251.dsl.bell.ca)
[17:18:06] <ms7821> don't CAs usually email mdsp or cabforum when doing this sort of thing?
[17:19:52] *** Joins: aleck (~aleck@user/aleck)
[17:21:44] *** Quits: gabriel1 (~gabriel1@user/gabriel1) (Remote host closed the connection)
[17:21:55] *** Joins: Ivii (~Ivyy@2001:a62:4c3:8e01:777e:e76b:1130:2573)
[17:22:05] *** Joins: gabriel1 (~gabriel1@user/gabriel1)
[17:24:30] *** Joins: rustycl0ck (~ircuser@gateway/tor-sasl/rustycl0ck)
[17:30:31] *** Joins: halosghost (~halosghos@user/halosghost)
[17:31:22] <dostoyevsky2> What's odd in Python when I do machine learning I can just do something like `np.random.seed(42)' to make sure my model always trains the same way... but I learned that in terms of crypto a secure RNGs should be reseeded every N seconds, right?  So PRNGs are typically not reseeded?
[17:35:12] <halosghost> dostoyevsky2: where did you hear that you should reseed secure RNGs every N seconds?
[17:35:14] <ms7821> a secure RNG shouldn't need reseeding
[17:35:42] <ms7821> and it's probably worth using terms like repeatable RNG and CSPRNG rather than an umbrella
[17:37:32] *** Quits: pieguy128 (~pieguy128@bas1-montreal02-65-92-163-251.dsl.bell.ca) (Ping timeout: 240 seconds)
[17:37:32] <dostoyevsky2> https://github.com/torvalds/linux/blob/master/drivers/char/random.c#L510 <- the linux kernel seems to use a reseeding interval for its chacha20 implementation
[17:38:11] <halosghost> hmm
[17:38:13] <halosghost> I wonder why
[17:38:47] <ms7821> don't hold random.c up as an example of what to do
[17:39:26] <ms7821> also, where are you seeing a reseeding interval?
[17:40:41] <MacGyver> A secure RNG *is* often reseeded.
[17:40:45] <int-e> ms7821: it's there, line 725
[17:41:07] <MacGyver> There's arguments for and against that both ways.
[17:41:17] <MacGyver> The argument for is that state compromise shouldn't persist.
[17:41:32] <MacGyver> The argument against is that it gives the attacker some modicum of control over the state.
[17:41:32] <ms7821> oh yeah, 992. my browser wasn't searching properly
[17:41:48] <MacGyver> Personally I think the argument for reseeding is stronger.
[17:42:22] <ms7821> if your csprng's state can be compromised once, it can be compromised again
[17:42:49] <MacGyver> Sure. So?
[17:43:05] <ms7821> so the argument for isn't very strong
[17:43:24] <MacGyver> Still stronger than the argument that reseeding gives an attacker control over the state.
[17:44:19] <halosghost> MacGyver: that's a very helpful high-level overview of the question
[17:44:23] <MacGyver> There's actually a paper somewhere that lays out a few stronger requirements on CSPRNGs that pretty much demands constant reseeding.
[17:44:25] <ms7821> my argument against is just that it shouldn't be needed
[17:44:51] <dostoyevsky2> https://github.com/openbsd/src/blob/master/sys/dev/rnd.c#L332 <- OpenBSD also seems to have reseeding...
[17:44:57] <MacGyver> (I.e. one shouldn't be able to predict future outputs from current state. Only current output. Something like that.)
[17:45:06] <ms7821> current state isn't exposed though?
[17:45:14] <halosghost> ms7821: imo, “don't do it if it's unnecessary” is only a good argument in cryptography if the “it” is likely to introduce the possibility of additional bugs
[17:45:18] <MacGyver> That's one of the ones analyzing the Linux RNG.
[17:45:19] <dostoyevsky2> I guess they have known for the last decades what they are doing in terms of security
[17:45:54] <ms7821> well this reseeding still calls arch_get_random_long which I dislike
[17:47:30] <ms7821> and on the general against side http://blog.cr.yp.to/20140205-entropy.html
[17:48:49] *** Joins: pieguy128 (~pieguy128@bas8-montreal02-65-93-195-202.dsl.bell.ca)
[17:48:50] <halosghost> mmm
[17:49:48] <MacGyver> Yes. I still think the argument *for* reseeding is stronger.
[17:50:43] <MacGyver> I don't have time to look up the paper right now, but the case for "current state should not allow you to predict RNG output into perpetuity" was made well.
[17:51:06] <MacGyver> And *both* these arguments have the (quite reasonable) "Really now? Get real." counter.
[17:51:17] <ms7821> again, how can someone get the state?
[17:51:39] <ms7821> it's not exposed by the kernel
[17:51:58] <MacGyver> How can someone manipulate the kernel CSPRNG using the attack Dan lays out?
[17:52:05] <dostoyevsky2> ms7821: What's the state when you boot a computer?  
[17:52:31] <ms7821> and what if we're talking about cloud computers that allegedly have no real entropy
[17:53:23] <MacGyver> So what if?
[17:53:26] <dostoyevsky2> ms7821: Google at least wrote some kernel drivers for linux... so you have more entropy on google cloud...
[17:54:08] <MacGyver> If you can't trust your cloud hosting provider then the CSPRNG is compromised from the get-go anyway.
[17:54:19] <MacGyver> It's much more likely someone reads out kernel memory than it is to influence the internal CSPRNG state by feeding it bad entropy.
[17:54:28] <MacGyver> I don't disagree that you should *think* about this.
[17:54:50] <MacGyver> But I find the balance in real kernel RNGs lies in favour of reseeding.
[17:55:01] <ms7821> I'm just saying it's not that a secure RNG should be reseeded, just that they usually are
[17:55:32] <dostoyevsky2> The problem with seeding is always booting, this is e.g. why OpenBSD maintains a .openbsd.randomdata which will be read during booting
[17:56:00] <TimMc> dostoyevsky2: The big problem is first boot.
[17:56:01] <ms7821> yeah, all that is another massive reason not to copy random.c
[17:56:23] <TimMc> Subsequent boots are easier, for the reason you give.
[17:57:03] <dostoyevsky2> TimMc: I guess one could provide a .openbsd.randomdata before the first boot if necessary.  IIUC it's just a normal file
[17:57:21] <TimMc> I've done so, on Linux.
[17:57:40] <MacGyver> Just don't put that in your ansible :P
[17:58:09] <MacGyver> (Though making ansible *generate* one every time isn't the worst idea in the world)
[17:58:31] <TimMc> Bit of a chicken-and-egg there.
[17:58:55] <MacGyver> Not really, the system that's doing the provisioning has a seeded RNG.
[17:59:28] <TimMc> The thing that worries me is the randomness used to create the SSH keys before you can even run Ansible.
[18:00:04] <TimMc> I'm not sure if there are other pre-Ansible strong-randomness-consumers as well.
[18:00:19] <MacGyver> The ssh-keys don't need to be unique at the receiving end.
[18:00:55] <TimMc> So, you're thinking of a situation with a pre-baked VM image, and the VM always comes up with the same host keys?
[18:01:19] <MacGyver> The host keys aren't going to be trustworthy anyway if they *are* unique, because your only option there is TOFU.
[18:01:38] <MacGyver> You either generate those from the provisioning system RNG as well, or just don't care.
[18:01:55] <dostoyevsky2> TimMc: In a vm case usually they have drivers that pass on entropy from the host to the guest 
[18:02:01] <TimMc> There are two separate issues -- verifying the public key, and making sure the keys were made with good entropy.
[18:02:12] <TimMc> (i.e. secure private key)
[18:03:36] *** Joins: dude12312414 (~test@gateway/tor-sasl/dude12312414)
[18:05:48] <TimMc> dostoyevsky2: Ah, nice.
[18:06:13] <TimMc> /var/lib/systemd/random-seed, that's what it is on Linux
[18:06:37] <ms7821> you can also use virtio-rng or something like pollinate
[18:07:02] *** Quits: Ivii (~Ivyy@2001:a62:4c3:8e01:777e:e76b:1130:2573) (Quit: Leaving)
[18:07:02] <ms7821> would be nice to see an article covering what all the different cloud providers do
[18:07:09] <MacGyver> TimMc: If using systemd's seed service.
[18:07:12] *** Joins: Ivii (~Ivyy@2001:a62:4c3:8e01:777e:e76b:1130:2573)
[18:07:12] <TimMc> yeah
[18:07:32] <MacGyver> (Makes you wonder which init systems don't do this at all)
[18:08:11] <ms7821> a lot used not to, which was super frustrating
[18:08:22] <ms7821> and I blame the whole "entropy" mythos for that
[18:08:46] <TimMc> When I reinstall a raspberry pi, I write the disk image out, then mount it and set some config options but also write out the random seed file. It sets up SSH keys on first boot.
[18:09:11] <ms7821> it's only since mind your p's and q's that people started thinking about it differently
[18:09:12] <TimMc> (I can then harvest the public key back off the card, if I like)
[18:10:11] <ms7821> https://factorable.net/weakkeys12.extended.pdf see "Repeated keys due to low entropy"
[18:10:45] <dostoyevsky2> MacGyver: In general when it comes to security a lot of OSes just copy over the features that OpenBSD had in place for a while... Especially as they usually have finished with all the necessary heavy lifting in the userland by then...  but I don't think there was any for storing the initial entropy on disk
[18:11:22] <TimMc> "mining your ps and qs", haha
[18:11:52] <TimMc> I think I remember when this came out, but I didn't remember the title.
[18:29:02] *** Quits: Ivii (~Ivyy@2001:a62:4c3:8e01:777e:e76b:1130:2573) (Quit: Leaving)
[18:29:32] *** Joins: ivii (~ivan@2001:a62:4c3:8e01:777e:e76b:1130:2573)
[18:32:54] <MacGyver> dostoyevsky2: Well that's just not true.
[18:33:03] <MacGyver> dostoyevsky2: In Linux, they don't *just* copy over the features.
[18:33:21] <MacGyver> dostoyevsky2: They first have a decade-long discussion over how broken security can't be fixed by breaking userspace.
[18:41:53] <ms7821> heh
[18:42:29] *** Joins: cvmn (~caveman@gateway/tor-sasl/caveman)
[18:42:30] <ms7821> and then linus gets quoted saying security experts are just out to waste his time or seomthing
[18:42:34] *** Joins: FlorianBad (~FlorianBa@cpe-67-49-107-16.dc.res.rr.com)
[18:43:36] <halosghost> “the more things change” and all that
[18:44:14] *** Joins: llorllale (~llorllale@198.98.119.85)
[18:46:22] *** Quits: ivii (~ivan@2001:a62:4c3:8e01:777e:e76b:1130:2573) (Quit: Konversation terminated!)
[18:47:06] *** Joins: ivii (~ivan@2001:a62:4c3:8e01:777e:e76b:1130:2573)
[18:49:05] *** Quits: ivii (~ivan@2001:a62:4c3:8e01:777e:e76b:1130:2573) (Client Quit)
[18:49:18] *** Joins: ivii (~ivan@2001:a62:4c3:8e01:777e:e76b:1130:2573)
[18:50:31] *** Joins: jarthur (~jarthur@2603-8080-1540-002d-6889-d743-d7bf-132c.res6.spectrum.com)
[18:56:30] *** Quits: cvmn (~caveman@gateway/tor-sasl/caveman) (Ping timeout: 276 seconds)
[19:00:17] *** Quits: citizen_stig (~citizen_s@2001:982:9f64:1:443c:7bd0:8f3c:6772) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[19:04:07] *** ivii is now known as the_ivii
[19:04:54] *** the_ivii is now known as ivii
[19:04:57] *** Quits: rustycl0ck (~ircuser@gateway/tor-sasl/rustycl0ck) (Ping timeout: 276 seconds)
[19:05:13] *** Quits: ivii (~ivan@2001:a62:4c3:8e01:777e:e76b:1130:2573) (Quit: Konversation terminated!)
[19:05:26] *** Joins: ivii (~ivan@2001:a62:4c3:8e01:777e:e76b:1130:2573)
[19:07:43] *** Joins: cvmn (~caveman@gateway/tor-sasl/caveman)
[19:07:45] *** Quits: d1cor (~diego@179.63.242.120) (Ping timeout: 256 seconds)
[19:17:11] *** Quits: AsenMx (~asen@user/asenmx) (Ping timeout: 256 seconds)
[19:27:08] *** Joins: Narrat (~omnius@p200300df5f4aae4f06ea56fffe2e7cdc.dip0.t-ipconnect.de)
[19:36:16] *** Joins: Tangent-Man (~Tang3nt-M@cpc145602-basl14-2-0-cust33.20-1.cable.virginm.net)
[19:40:49] *** Joins: citizen_stig (~citizen_s@2001:982:9f64:1:41f3:70b3:46bb:841e)
[19:42:54] *** Joins: AsenMx (~asen@user/asenmx)
[19:44:21] <FlorianBad> maroon: I can confirm that this implementation encodes each block of 16 bytes the same way regardless of their position   https://metacpan.org/pod/Crypt::OpenSSL::AES
[19:44:39] <FlorianBad> I tested with 10 loops encrypting the same 16 bytes, all of them have the same output
[19:45:13] <FlorianBad> Which is then pretty damn bad for encrypting large files lol
[19:45:18] *** Joins: byteskeptical (~amnesia@user/byteskeptical)
[19:47:57] <FlorianBad> So let's reset for a second and maybe ask another question:  Now that I have a password modified with Argon2 (using a salt that is the filename+filesize), what would be a completely overkill encryption algorithm to use for extra large files (and this 32 bytes key) that is still quite standard so I know I will still be able to find some libraries
[19:47:57] <FlorianBad> 20 years from now?
[19:48:38] <FlorianBad> Because it seems that my AES-256 followed by EC-521 is not really it as it isn't appropriate for large files anyway
[19:48:45] <FlorianBad> ECC-521
[19:49:40] <FlorianBad> My files are going to be up to 100GB
[19:50:49] *** Quits: dude12312414 (~test@gateway/tor-sasl/dude12312414) (Quit: THE RAM IS TOO DAMN HIGH)
[19:58:16] *** Joins: cwebber (~user@user/cwebber)
[19:59:07] <TimMc> I'm curious what your use-case is that has you writing crypto instead of reaching for a standard tool like age or gpg.
[20:00:00] <FlorianBad> Well, I'm writing my own scripts to take care of the backups, so I guess they COULD call gpg then, would you rather do that?
[20:00:54] <halosghost> that seems far more likely to go well
[20:01:10] <halosghost> (when in-doubt, writing your own crypto is probably not a good first choice ☺)
[20:01:12] <FlorianBad> Hmm, well, it has to be open source too
[20:01:30] <TimMc> Definitely. GnuPG (and PGP in general) has its problems, but it's very well-implemented -- you'll always be able to find a tool to handle it.
[20:02:46] <TimMc> For backups, you might also considered using borgbackup, which does remote backups that are deduplicated and encrypted locally.
[20:03:09] <TimMc> (it can back up to whatever server you want, or to a locally mounted drive)
[20:04:12] <FlorianBad> ok, I don't really need any special feature, my scripts will take care of everything, I just need a very robust way of encrypting 100gb-file.tgz into 100gb-file.tgz.someenc
[20:04:24] <FlorianBad> With a 256 key
[20:05:04] *** Joins: rg (~r-g@51.159.55.86)
[20:08:14] *** Joins: AllMyNames_2 (~AllMyName@pool-71-186-156-227.bflony.east.verizon.net)
[20:08:14] *** Quits: AllMyNames_2 (~AllMyName@pool-71-186-156-227.bflony.east.verizon.net) (Client Quit)
[20:08:17] *** Quits: AllMyNames (~AllMyName@user/allmynames) (Quit: Leaving)
[20:08:38] *** Joins: AllMyNames (~AllMyName@user/allmynames)
[20:12:54] <FlorianBad> Ok so if I was using GPG, and I want a symmetric key (so that I don't have to expose that private key every time I encrypt), what would be the most overkill algorithm that will most likely hold another 50 years?
[20:13:09] <TimMc> Should be as simple as `gpg --encrypt --recipient KEY_ID < 100gb-file.tgz > 100gb-file.tgz.someenc`
[20:13:33] <TimMc> FlorianBad: When you use asymmetric encryption, you only use the public key during the encryption process.
[20:13:56] <FlorianBad> yeah, but what type of key would you use then?
[20:14:08] <TimMc> It's symmetric encryption that would require exposing a secret/private key to the backup process.
[20:14:20] <FlorianBad> oh, sorry, I meant asymmetric
[20:14:50] <TimMc> (going afk, back in a bit)
[20:20:21] *** Quits: cvmn (~caveman@gateway/tor-sasl/caveman) (Ping timeout: 276 seconds)
[20:26:57] *** Quits: cwebber (~user@user/cwebber) (Ping timeout: 250 seconds)
[20:30:44] *** Parts: wsb (~wsb@user/wsb) ()
[20:31:24] *** Joins: wsb (~wsb@user/wsb)
[20:34:18] <MacGyver> FlorianBad: You can also look at LUKS in this case, though that's block-device-based and not file-based, and for integrity there's some fancy new hoops to jump through.
[20:34:34] <MacGyver> But it definitely handles terabytes of data just fine.
[20:43:01] *** Joins: Guyver2_ (~Guyver@guyver2.xs4all.nl)
[20:45:24] *** Quits: Guyver2 (~Guyver@guyver2.xs4all.nl) (Ping timeout: 250 seconds)
[20:45:26] *** Guyver2_ is now known as Guyver2
[20:52:10] *** Quits: gabriel1 (~gabriel1@user/gabriel1) (Remote host closed the connection)
[20:53:11] <TimMc> FlorianBad: By "hold for another 50 years" do you mean that you will still be able to decrypt it (tools available) or that no one else will (algorithm and implementation still considered secure)?
[20:53:51] *** Joins: gabriel1 (~gabriel1@user/gabriel1)
[21:17:47] *** Quits: gproto23 (~gproto23@user/gproto23) (Ping timeout: 268 seconds)
[21:24:23] *** Quits: citizen_stig (~citizen_s@2001:982:9f64:1:41f3:70b3:46bb:841e) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[21:25:33] *** Malvolio is now known as Guest1315
[21:25:33] *** Quits: Guest1315 (~Malvolio@user/malvolio) (Killed (strontium.libera.chat (Nickname regained by services)))
[21:25:56] *** Quits: gabriel1 (~gabriel1@user/gabriel1) (Remote host closed the connection)
[21:26:25] *** Joins: gabriel1 (~gabriel1@user/gabriel1)
[21:26:46] *** Joins: Malvolio (~Malvolio@user/malvolio)
[21:28:33] *** Joins: citizen_stig (~citizen_s@2001:982:9f64:1:5026:c2b3:b8b7:fca4)
[21:29:48] *** Quits: Haohmaru (~Haohmaru@195.24.53.110) ()
[21:35:00] <Alipha> FlorianBad: so, the state-of-the-art of encrypting a file with a passphrase would be to: generate a random salt. use argon2id (tuned appropriately) with your password and salt to create a symmetric key. encrypt the file using xchacha20-poly1305 (using a static IV/nonce such as 0 is okay IF you use a random salt, which means your symmetric key will be different each time). prepend/append the random salt to the
[21:35:02] <Alipha> encrypted file. if you wanted to encrypt the file twice with two different algorithms, then tell argon2id to produce a hash long enough for two keys (ie, 512 bits), use 256 bits for the xchacha20-poly1305 key and 256 bits for, say, AES-GCM. note that both these encryption algorithms are AEAD ciphers, and that your ciphertext will be slightly larger with the addition of the random salt and the MAC or MACs. but
[21:35:04] <Alipha> why does that matter?
[21:37:45] *** Joins: mouseghost (~draco@user/mouseghost)
[21:45:04] *** Quits: citizen_stig (~citizen_s@2001:982:9f64:1:5026:c2b3:b8b7:fca4) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[21:45:34] *** Joins: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net)
[21:47:23] *** Joins: cvmn (~caveman@gateway/tor-sasl/caveman)
[21:50:37] <maroon> Alipha, yesterday when i was talking with FlorianBad they were wanting to have encryption without increasing the size other than padding to next multiple of the blocksize 16, so that meant no nonce/iv attached to the file, and no MAC - hopefully that's changed by now
[21:53:13] *** Joins: citizen_stig (~citizen_s@2001:982:9f64:1:5cea:3a87:f03f:9696)
[21:56:21] <cvmn> let y[i] = f(x[i], y[i-1]) be a recursion, with base case y[1] = f(x[1], y[0]).  my question is, is there a function f, such that, when given y[n] and the base case, we can tell whether it's generated off the base case, even when we lack y[3], y[4], ..., y[n-1]?
[21:57:37] <maroon> you're asking that if we're given the 2nd and 3rd numbers in a series we can identify the 1st?
[21:58:13] <TimMc> I think it's "if you know f and y[0], can you verify that a proposed y[5] is valid"
[21:58:24] <maroon> or even worse, we're given only the 1st and the Nth
[21:58:29] <TimMc> yeah
[21:59:01] <TimMc> cvmn: It sounds like you can just run the series forward and check if you encounter y_n.
[21:59:20] <TimMc> so, you want constant-time or something?
[21:59:26] <maroon> that's how we'll solve DH! :)
[21:59:42] <cvmn> yes, it's closer to that worse one.  but it's even worse:  we don't know any x[i], except x[1].  only x[1] is known..  
[22:00:12] <TimMc> ah
[22:00:46] <maroon> it's like, 2 dots on a graph, and find the one-true-equation that intersects both?
[22:00:48] <cvmn> only knowns are:  y[2], x[1], y[0], y[n], f.  question is:  can we verify if y[n] came out of the series off the base case y[1] = f(x[1], y[0]) without having intermediate steps?
[22:00:52] <TimMc> maroon: just throw more GPUs at it, we'll reach the generator point eventually.
[22:01:15] <Alipha> maroon: which I don't understand. There's certainly applications where the ciphertext must be exactly the same size, but "can be up to 16 bytes larger" seems like an artificial constraint
[22:01:52] <TimMc> cvmn: Sure! f(x[i], y[i-1]) = y[i-1] will do the trick.
[22:02:34] <TimMc> Alipha: It makes me think of filesystem crypto, which someone has already suggested.
[22:02:41] <TimMc> (too lazy to scroll up and find it)
[22:03:08] <MacGyver> I did.
[22:03:22] <MacGyver> But the authenticated encryption hoops I talked about are basically a shadow volume with auth tags.
[22:03:35] <MacGyver> So it takes more space.
[22:03:54] <cvmn> TimMc: any hope for when, for any i, it's guaranteed that f(x[i], y[i-1]) does not equal y[i-1]?
[22:03:57] <MacGyver> (Significantly more than if you did this file-based, even)
[22:04:10] <TimMc> cvmn: Yes! y[i-1] + 1
[22:04:31] <cvmn> lel.
[22:05:13] <TimMc> I've got more where that came from.
[22:07:01] <TimMc> (This is the universe's way of saying "this seems underconstrained".)
[22:07:24] <cvmn> is it possible to say that f is constrained to be a hashing function?  e.g. its output seems random, except that we can say ``this is generated off the base case y[0]''.
[22:08:10] <maroon> are you told what 'n' is? ie the number of steps between the 2 knowns?
[22:08:53] <cvmn> yes.  n is number of steps between them.
[22:09:08] *** Joins: aleck1 (~aleck@user/aleck)
[22:09:45] <maroon> so you know step 0 not step 1?
[22:09:50] *** Joins: gabriel1_ (~gabriel1@mail.virebent.art)
[22:11:14] <cvmn> so, y=f(x,y)'s output is like a cryptographically secure hashing function.  e.g. change in x and y results in seemingly totally random output.  but the only catch is that:  can we make such that, when given y[n], to be able to tell if it came off the base case, say, y[0] = 1 (or any other number)?
[22:11:33] <holgersson> aczid: You're welcome! :-P
[22:11:54] <cvmn> maroon: true.  
[22:11:55] *** Quits: gabriel1 (~gabriel1@user/gabriel1) (Ping timeout: 256 seconds)
[22:12:03] *** Quits: aleck (~aleck@user/aleck) (Ping timeout: 268 seconds)
[22:14:35] <TimMc> cvmn: This feels very unlikely, *especially* if x is kept secret.
[22:15:26] <TimMc> unless... the output is composite, only *partly* acting like a hash, and another part has a validation element of some kind :-)
[22:18:14] <maroon> doesnt being a crypto hash mean the answer is no?
[22:19:00] <cvmn> yeah.  i guess at every iteration, information from x[i] will eventually guarantee to delete all information from the base case y[0], as number of iterations grows.
[22:19:07] <maroon> this is like, given input and output, can we derive an AES key that maps between them
[22:20:07] <maroon> crypto hashes usually involve some kind of 1-way function, so when x = or(y,z) ...
[22:20:59] *** Quits: Major_Biscuit (~MajorBisc@86-88-79-148.fixed.kpn.net) (Ping timeout: 256 seconds)
[22:22:34] *** a1 is now known as ekaj
[22:24:02] <cvmn> yeah.  no hope i guess.
[22:26:56] <maroon> you can always come up with 'something' that will work for f[0] and f[n], but it wont be the correct solution, and is unlikely to work for anything else
[22:27:30] <maroon> because it's like i was saying earlier, finding an equation for a graph that goes thru 2 specific points
[22:29:03] *** Quits: Malvolio (~Malvolio@user/malvolio) (Quit: it wasn't gonna turn into another winter of '22)
[22:29:29] *** Quits: machinedgod (~machinedg@24.105.81.50) (Ping timeout: 256 seconds)
[22:30:33] <FlorianBad> TimMc: I mean no one else, safe enough for a good many decades because it's too overkill
[22:31:18] <cvmn> maroon: yeah.  if f is a hashing function, then x[*] must not be secret.   if x[*] is a secret, then f cannot be a hashing function.
[22:32:45] <Alipha> FlorianBad: why does your ciphertext need to be the same size?
[22:33:01] <Alipha> (as the plaintext)
[22:33:19] <aczid> holgersson: :P
[22:33:46] <FlorianBad> Alipha: ok thanks for all that, I will google all these
[22:33:59] *** Joins: gproto23 (~gproto23@user/gproto23)
[22:34:44] <FlorianBad> maroon: Yeah if putting some headers or something is almost-absolutely necessary then... maybe I should
[22:35:05] <TimMc> FlorianBad: If you're concerned about the ciphertext being unmanageably big, I can assure you that most cryptosystems will leave it only *slightly* larger, by just a constant factor. Like... 64 bytes at most, probably.
[22:35:46] <TimMc> Some will chunk it and leave an authentication tag after each chunk, but again those are really small.
[22:35:58] <TimMc> (small linear factor)
[22:36:20] <maroon> the extra length of crypto is usually: +1-16 for padding to multiple of 16, +16+32 of authentication MAC, +8-16 for iv/nonce
[22:36:27] *** Joins: Malvolio (~Malvolio@user/malvolio)
[22:37:32] <FlorianBad> Alipha: it's not size (files will be up to 100GB lol) it's more to keep things as simple and pure as possible, and if I forgot how I did all that 30 years from now it should be obvious, that's why I wanted to avoid anything too sofisticated, unless necessary
[22:39:54] <Alipha> FlorianBad: xchacha20-poly1305 and aes-gcm are both wildly used currently, so you shouldn't have any problems finding something to decrypt with in 30 years
[22:40:16] <maroon> if your backup is 1 big gzip, are you wanting to be able to decrypt 1 file without decryptiong the whole 100gb?
[22:40:43] *** Quits: FlorianBad (~FlorianBa@cpe-67-49-107-16.dc.res.rr.com) (Quit: Client closed)
[22:41:00] *** Joins: FlorianBad (~FlorianBa@cpe-67-49-107-16.dc.res.rr.com)
[22:41:16] <FlorianBad> last message I saw:     maroon: if your backup is 1 big gzip, are you wanting to be able to decrypt 1 file without decryptiong the whole 100gb?
[22:41:21] <FlorianBad> Alipha: can gpg handle that well? like fileinput to fileoutput?
[22:42:37] <TimMc> Yeha, gpg can stream the file.
[22:42:40] <TimMc> *Yeah
[22:42:50] <FlorianBad> maroon: no I don;t, just want to get back that large tgz. I have a computer with large NVMe drives that is ONLY used to handle backups (prepare them, etc.) so I don't mind about dealing with heavy files
[22:43:27] <FlorianBad> Also, since they are just backups for redundancy there is 99% chance I will never have to decrypt/extract a single one of them
[22:43:49] <FlorianBad> TimMc: I meant xchacha20-poly1305 specifically
[22:45:49] <TimMc> Oh, I don't know what algorithms gpg supports. But xchacha20-poly1305 can handle large inputs.
[22:46:25] <TimMc> (I see one reference to a 256 GB limit for some variations, which I suppose has to do with running out of nonces or counters...)
[22:46:50] <FlorianBad> ok but then how would I implement it?
[22:47:29] <FlorianBad> My script is in perl so either there's a module for it (apparnetly not) or I call a reliable open-source program that handles that
[22:47:35] <maroon> yeah with xchacha there's 128 bits split of nonce|iv, sometimes it's 64:64 others it's 96:32
[22:47:59] *** Quits: mouseghost (~draco@user/mouseghost) (Quit: mew wew)
[22:48:32] <Alipha> i would just go with gpg's default?
[22:49:05] <FlorianBad> Alipha: for convenience/ease or because it technically be the best?
[22:50:44] <Alipha> convenience and should be sufficient
[22:50:47] <FlorianBad> I decided to INVEST some of my time writing scripts that will handle all hte backups I make. It will prepare them, take care of compression, then encryption, manage the keys correctly, etc.  So if I spend that time I want to do it as well as it could possibly be done, but of course without having to rewrite a whole encryption implementation.
[22:53:03] <MacGyver> Why not use age?
[22:53:03] <FlorianBad> I like your suggestion of some amazing algorithm, in fact I might even encrypt twice, like xchacha20, then aes on top, because... Why not? I don't see any reason to not do that, as long as it's not going to take me a week to figure it out
[22:53:20] <MacGyver> It's as convenient as gpg for this usecase, right.
[22:54:25] <FlorianBad> Alipha: if you wanted to encrypt file.tgz to file.tgz.xchacha20 today, what program would you use?
[22:56:20] *** Joins: Major_Biscuit (~MajorBisc@2a02:a461:129d:1:193d:75d8:745d:e91e)
[22:57:21] *** Quits: FlorianBad (~FlorianBa@cpe-67-49-107-16.dc.res.rr.com) (Quit: Client closed)
[22:57:31] <halosghost> MacGyver: it's, at least, trying to be easier for this usecase
[22:57:44] <halosghost> I haven't worked with it yet, so I have no idea if it's successful in that goal ☺
[22:57:46] <MacGyver> Yeah, hence why I was thinking, why not use age.
[22:59:15] <halosghost> ☺
[22:59:27] <halosghost> does seem a fair question
[22:59:40] <TimMc> "50 years" makes me think of postquantum crypto.
[22:59:52] <TimMc> I wonder what's happening in pq land these days.
[22:59:58] *** Joins: FlorianBad (~FlorianBa@cpe-67-49-107-16.dc.res.rr.com)
[23:00:08] <FlorianBad> disconnects me all the time.... hope I didn't miss anything
[23:00:12] <MacGyver> The NIST PQ competition.
[23:00:36] *** Quits: Major_Biscuit (~MajorBisc@2a02:a461:129d:1:193d:75d8:745d:e91e) (Ping timeout: 250 seconds)
[23:02:39] *** Joins: Major_Biscuit (~MajorBisc@2a02:a461:129d:1:193d:75d8:745d:e91e)
[23:03:31] *** Joins: mouseghost (~draco@user/mouseghost)
[23:05:01] <TimMc> Who's winning?
[23:05:28] <TimMc> More importantly, what team are we rooting for?
[23:05:32] <TimMc> I need to make some brackets.
[23:05:48] <sarnold> I for one welcome our new quantum overlords
[23:06:25] *** Quits: FlorianBad (~FlorianBa@cpe-67-49-107-16.dc.res.rr.com) (Quit: Client closed)
[23:06:45] *** Quits: cvmn (~caveman@gateway/tor-sasl/caveman) (Ping timeout: 276 seconds)
[23:07:04] *** Joins: FlorianBad (~FlorianBa@cpe-67-49-107-16.dc.res.rr.com)
[23:07:23] *** Quits: Major_Biscuit (~MajorBisc@2a02:a461:129d:1:193d:75d8:745d:e91e) (Ping timeout: 252 seconds)
[23:09:24] <TimMc> https://csrc.nist.gov/projects/post-quantum-cryptography/round-3-submissions
[23:11:46] <TimMc> I don't know what an "alternate candidate" is.
[23:13:45] <dostoyevsky2> Is there a chance for having NIST recommending post-quantum cryptography algorithms soon?
[23:14:15] <MacGyver> Define soon.
[23:14:30] <dostoyevsky2> next 3 seconds
[23:14:39] <MacGyver> Then no.
[23:14:42] <dostoyevsky2> I guess it's a no
[23:14:44] <MacGyver> Evidently not.
[23:14:56] <maroon> probably waiting for a quantum computer to be developed to help them create it
[23:15:16] <dostoyevsky2> I read latice based algorithms could work... 
[23:15:53] <TimMc> I'm rooting for supersingular isogenies but *only* because they have a cool name.
[23:15:56] <dostoyevsky2> https://github.com/ldsec/lattigo <- it has 621 stars, so I guess it could be good
[23:16:02] <TimMc> haha
[23:16:33] <maroon> "he was picked 2nd in the nfl draft, so he must be good"
[23:16:58] <dostoyevsky2> > Note that this comes out of a group at EPFL, a university known for cryptography research.
[23:17:23] *** Joins: ic3blx_ (~ic3blx___@87.116.166.221)
[23:17:23] *** Quits: ic3blx_ (~ic3blx___@87.116.166.221) (Changing host)
[23:17:23] *** Joins: ic3blx_ (~ic3blx___@user/ic3blx/x-0942740)
[23:20:19] *** Quits: holgersson (~quassel@user/holgersson) (Quit: “Format C:........[Done]“)
[23:20:38] *** Joins: holgersson (~quassel@user/holgersson)
[23:20:40] <dostoyevsky2> I heard the problem is that for crypanalysis, they haven't really done much with lattice-based algorithms in the past, so nobody really knows how they could be evaluated well, whereas for traditional AES candidates the gap wasn't that wide
[23:21:55] <FlorianBad> Alipha: it looks like ChaCha20 (not X ) is available in gpg in theory: https://www.gnupg.org/documentation/manuals/gcrypt/Available-ciphers.html    But I don't see any way to set it with --cipher-algo
[23:22:29] <halosghost> TimMc: I know it's probably not what you meant, but I like imagining that NIST is a competitor and that they might lose
[23:22:32] <halosghost> that just tickles me a bit
[23:23:05] <MacGyver> FlorianBad: age uses xchacha20-poly1305.
[23:24:44] <FlorianBad> MacGyver: this?   https://github.com/FiloSottile/age
[23:25:33] <MacGyver> Yes.
[23:25:36] <TimMc> halosghost: XD
[23:26:01] <Alipha> there's also the "scrypt" command line utility, but that uses AES-CTR + HMAC, it looks like
[23:26:14] <Alipha> not that that's bad... just not as modern
[23:26:16] <maroon> but if this is supposed to work in 50 years, how easy is it to decrypt something created in 1980's msdos?
[23:26:41] <TimMc> maroon: If it's a zip file, probably not too hard.
[23:26:41] <MacGyver> Well in that sense GPG is the safest option.
[23:27:02] <MacGyver> Because you just KNOW some misguided person thinking secure e-mail is achievable is still keeping it alive in 5 decades.
[23:27:06] <FlorianBad> maroon: well, I was thinking of putting a tgz bundle with every backup that contains absolutely all the tools, source and compiled, along with my own scripts and notes
[23:27:12] <MacGyver> But I'd *really* just use age here.
[23:27:30] <TimMc> maroon: They'll just need to drag-and-drop the 100GB file into a web page emulating a 2020's era laptop.
[23:27:34] <maroon> TimMc, what if it's on a 5.25" floppy?
[23:27:46] <TimMc> gpg.js
[23:27:56] <FlorianBad> 2020.js
[23:28:10] <MacGyver> Speaking of which, I think it's time for the yearly key expiry extension.
[23:28:36] <TimMc> My GPG key doesn't expire until 2026.
[23:28:54] <TimMc> I created it like... probably 10 years ago. I don't know why I set the expiry so far out.
[23:29:47] <dostoyevsky2> What kind of cryptographic algorithms where popular in the 1980s?
[23:30:13] <TimMc> rot13, lol
[23:30:20] <FlorianBad> dostoyevsky2: vigenere? :)
[23:30:21] <maroon> pgp
[23:30:34] <MacGyver> DES.
[23:30:50] <dostoyevsky2> > pgp: Initial release1991; 31 years ago
[23:30:51] <TimMc> Random-ass janky Excel and ZIP file encryption
[23:30:59] <maroon> things having "military grade encryption"
[23:30:59] <TimMc> or that sort of thing
[23:31:01] <MacGyver> TimMc: I just expire +1y every year.
[23:31:13] <MacGyver> So that if I lose control over it I can just not care.
[23:31:24] <MacGyver> Uh, not lose control.
[23:31:27] <MacGyver> If I *lose* it.
[23:31:38] <MacGyver> But I only really use it for `pass` anyway.
[23:31:39] <dostoyevsky2> DES was created in 1975... 
[23:32:12] <maroon> and was still popular til the late 90s when it was brute-force cracked
[23:32:35] <maroon> even when it died, they tried to keep it alive as 3-DES
[23:32:37] *** Quits: Narrat (~omnius@p200300df5f4aae4f06ea56fffe2e7cdc.dip0.t-ipconnect.de) (Quit: They say a little knowledge is a dangerous thing, but it's not one half so bad as a lot of ignorance.)
[23:32:46] <FlorianBad> MacGyver: where did you see that age supports xchacha20-poly1305 ?
[23:33:00] <MacGyver> FlorianBad: It doesn't just *support* xchacha20-poly1305.
[23:33:03] <dostoyevsky2> yeah, so if it's from the 1980's it might use DES... which one could crack, I guess
[23:33:03] *** Quits: jstoker (~jstoker@user/jstoker) (Remote host closed the connection)
[23:33:05] <MacGyver> FlorianBad: It's the only thing it implements.
[23:33:07] <TimMc> "we're gonna leapfrog the competition and go to 5-DES"
[23:33:13] <MacGyver> FlorianBad: It's in the format document.
[23:33:34] <maroon> my 2-rot13 is still in the development phase
[23:33:47] <TimMc> 3-ROT13
[23:33:49] <TimMc> lol
[23:33:59] <FlorianBad> MacGyver: really? How come it's not even mentioned once in the page? https://github.com/FiloSottile/age
[23:34:06] <TimMc> (but you run the middle one backwards, you see)
[23:34:15] <MacGyver> Because it links to the format document.
[23:34:20] <MacGyver> And you as a user shouldn't have to care.
[23:34:33] <MacGyver> Page 4, bottom, of the format specification linked there.
[23:35:35] *** Joins: sdfgsdfg (~dfghsfgs@user/sdfgsdfg)
[23:35:55] <MacGyver> The GPG frontpage also doesn't list all the algorithms it supports. That's in the documentation.
[23:36:32] <FlorianBad> MacGyver: actually I should care, I need to undertand what I'm doing to some extent
[23:36:47] <FlorianBad> interesting document BTW
[23:37:02] *** Joins: jstoker (jstoker@user/jstoker)
[23:37:14] <MacGyver> FlorianBad: The general philosophy of user-facing tooling is that users *shouldn't* have to care.
[23:37:20] <MacGyver> I understand that you do.
[23:37:39] <MacGyver> But a user that "just wants to encrypt a file" shouldn't have to see whether the tool implements a sane algorithm.
[23:38:12] <MacGyver> Hence why it's not considered essential to put on the front page what algorithm it uses.
[23:38:16] <FlorianBad> :)
[23:38:23] <FlorianBad> Then I'm more than a user
[23:38:34] <FlorianBad> user 2.0, maniac version
[23:38:57] <MacGyver> A major issue with PGP/GPG is that users *do* have to care about details that they *shouldn't* have to care about, which is where things break.
[23:39:29] <dostoyevsky2> Does age support yubikeys? 
[23:39:54] <MacGyver> That's in the "Later" section of the standard spec.
[23:39:59] <MacGyver> So by now, maybe?
[23:40:08] <FlorianBad> MacGyver: so age generates a RANDOM salt which it stores within the headers of the encrypted file, correct?
[23:42:21] <MacGyver> I think that depends on which public key type is used.
[23:42:56] <MacGyver> x25519 and scrypt recipient lines need it, but ssh-rsa recipient lines don't.
[23:43:28] <FlorianBad> ok, I need to install it and make some tests because I don't know that tool at all yet
[23:44:11] *** Quits: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
[23:44:26] <MacGyver> Urgh. The other thing I need to do today is roll new client certs for my machines.
[23:45:44] *** Joins: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net)
[23:46:14] *** Quits: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net) (Client Quit)
[23:47:05] <dostoyevsky2> https://github.com/FiloSottile/age/discussions/390 > Use fido2 extension "hmac-secret" for encryption  
[23:47:16] <dostoyevsky2> they've been discussing yubikey support so far
[23:47:45] <dostoyevsky2> > 
[23:47:45] <dostoyevsky2> fhilgers
[23:47:45] <dostoyevsky2> 7 days ago
[23:47:47] *** Joins: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net)
[23:47:50] <dostoyevsky2> oops
[23:48:02] <dostoyevsky2> ok, just someone describing an idea
[23:51:42] <FlorianBad> https://github.com/FiloSottile/age   > I'm using Slackware so I used the last option to build from source with go, it downloaded things but I don't see any file and the age command is sitll not there
[23:53:44] <FlorianBad> ah, the "latest" binaries work
[23:55:55] *** Quits: BOKALDO (~BOKALDO@user/bokaldo) (Quit: Leaving)
[23:59:56] *** Joins: cvmn (~caveman@gateway/tor-sasl/caveman)
