[00:00:23] *** Joins: amb007 (~a_bakic@102.215.76.86.rev.sfr.net)
[00:03:23] *** Quits: aartaka (aartaka@gateway/vpn/protonvpn/aartaka) (Ping timeout: 256 seconds)
[00:04:27] *** Joins: aartaka (aartaka@gateway/vpn/protonvpn/aartaka)
[00:07:43] *** Quits: hobo (~hobo@204.128.242.10) (Ping timeout: 256 seconds)
[00:07:43] *** Joins: hobo_ (~hobo@204.128.242.10)
[00:28:43] *** Quits: jpl01 (~user@2001:16b8:4916:9700:5e4a:1007:9979:b7a5) (Remote host closed the connection)
[00:31:57] *** Quits: aartaka (aartaka@gateway/vpn/protonvpn/aartaka) (Ping timeout: 240 seconds)
[00:32:33] *** Joins: hobo (~hobo@204.128.242.10)
[00:34:13] *** Quits: hobo_ (~hobo@204.128.242.10) (Ping timeout: 268 seconds)
[00:36:09] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Ping timeout: 276 seconds)
[00:38:03] *** Joins: pieguy128 (~pieguy128@bras-base-mtrlpq5031w-grc-37-70-24-250-33.dsl.bell.ca)
[00:39:42] <EdLangley[m]> Has anyone tried embedding ECL in a free pascal program?
[00:43:15] *** Quits: minion (~minion@common-lisp.net) (Remote host closed the connection)
[00:43:15] *** Quits: specbot (~specbot@common-lisp.net) (Read error: Connection reset by peer)
[00:43:31] *** Joins: specbot (~specbot@common-lisp.net)
[00:44:07] *** Joins: minion (~minion@common-lisp.net)
[00:48:24] *** Joins: lispy (~lispy3@84.69.59.93)
[00:55:57] *** Parts: drakonis (drakonis@user/drakonis) (WeeChat 3.1)
[00:56:28] *** Joins: gaqwas (~john@dynamic-077-004-123-063.77.4.pool.telefonica.de)
[00:58:32] *** Joins: drakonis (drakonis@user/drakonis)
[00:58:37] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[00:58:38] *** Joins: Algernon69 (~Algernon6@2a01:e0a:511:6ce0:8be:4e9f:c4fa:9e8c)
[01:13:54] *** Quits: Dynom (~niels@80-114-12-206.cable.dynamic.v4.ziggo.nl) (Quit: WeeChat 3.4)
[01:14:31] *** Joins: Algernon91 (~Algernon6@2a04:cec0:10ea:da13:60c1:b22:c476:dfef)
[01:15:25] *** Joins: fmozturk (~fmozturk@176.234.225.237)
[01:18:19] *** Parts: fmozturk (~fmozturk@176.234.225.237) ()
[01:18:37] *** Quits: Algernon69 (~Algernon6@2a01:e0a:511:6ce0:8be:4e9f:c4fa:9e8c) (Ping timeout: 268 seconds)
[01:23:56] <mfiano> _death: SUBLIS is pretty great, but unfortunately, it is pretty primitive, and I don't think it will work as well as TREE-LEAVES here.
[01:24:05] <mfiano> (if at all)
[01:28:26] <mfiano> I think what bothers me most is does not operate strictly on leaves, and thus, ignores the separate function/variable namespace for data that will be turned into code. For example (sublist '((s1 . foo)) '(+ s1 (* s1 s2) (s1 s3))) is probably not what you want in such a case.
[01:29:02] <mfiano> s/sublist/sublis/
[01:31:07] <_death> (i) sublis doesn't operate on leaves, right (ii) your definition of "leaf" is not what I would expect (iii) seems you want a code walker or a symbol macro
[01:31:17] *** Quits: gaqwas (~john@dynamic-077-004-123-063.77.4.pool.telefonica.de) (Remote host closed the connection)
[01:31:29] <mfiano> No I simply want TREE-LEAVES from LOL :)
[01:31:35] <_death> (not what I would expect when talking about conses and atoms as trees.. if you're talking about the abstract syntax tree, then sure)
[01:32:02] <_death> well, if you want it..
[01:32:21] <mfiano> Its definition of LEAF is what I would expect. I'm not sure what yours would be.
[01:33:05] <_death> do you know what a box and arrow diagram is?
[01:33:22] <mfiano> Do I know what a cons is? Yes.
[01:33:59] <_death> that's not what I asked.. anyway, if you draw a box and arrow diagram, then you can what the leaves in that tree are
[01:34:13] <White_Flame> mfiano: you want deep list elements, not leaves
[01:34:58] <mfiano> Sure, that does make a lot more sense.
[01:37:49] <White_Flame> (and that has a problem with NIL's duality)
[01:38:13] *** Quits: lispy (~lispy3@84.69.59.93) (Quit: Leaving)
[01:38:26] <White_Flame> does (1 2 nil 3) have 4 total/deep elements, or 3?
[01:39:18] <White_Flame> and if NIL is a notable element, then what about (1 2 . 3) vs (1 2 . nil)?
[01:39:35] *** Joins: hobo_ (~hobo@204.128.242.10)
[01:40:12] <White_Flame> (i have a LOT of library functions dealing with crap like that :-P)
[01:40:51] *** Quits: hobo (~hobo@204.128.242.10) (Ping timeout: 256 seconds)
[01:43:28] <mfiano> I was wrong anyway.
[01:43:28] *** Quits: cage (~cage@dynamic-adsl-84-221-50-16.clienti.tiscali.it) (Quit: rcirc on GNU Emacs 27.1)
[01:43:48] <mfiano> TREE-LEAVES behaves the same way. Shows how much I use the opinionated crap from LOL.
[01:44:50] <EdLangley[m]> The couple times I wanted code-walking, I used agnostic-lizard
[01:44:54] <EdLangley[m]> (for a macro)
[01:44:55] <mfiano> It was one of my favorite functions from that book, likely because I despise anaphora.
[01:45:09] <_death> if you're defining your own small subset of lisp (say for arithmetic expressions) then a simple (non-CL) code walker is easy
[01:45:44] <EdLangley[m]> I think I wanted a way to grab out a specific function
[01:46:15] <EdLangley[m]> HTMX has this concept of partials where you send the whole page from a web endpoint by default, but if there's a specific header you send out a partial
[01:46:35] <EdLangley[m]> I was experimenting with implementing this by having a macro that looked for a specific symbol in function position
[01:46:49] <EdLangley[m]> To reduce duplication
[01:47:19] <EdLangley[m]> Also, I wanted an excuse to try agnostic-lizard
[01:48:10] * mfiano changes his macro to use SUBLIS
[01:53:16] <EdLangley[m]> I go back and forth on anaphora
[01:53:24] <_death> EdLangley[m]: I still need an excuse to try it :).. I don't remember the last time I needed a code walker for more than playing around.. often I settled for a locally "suboptimal" solution that didn't need one
[01:53:29] *** Quits: Algernon91 (~Algernon6@2a04:cec0:10ea:da13:60c1:b22:c476:dfef) (Read error: Connection reset by peer)
[01:53:32] <EdLangley[m]> I like Clojure’s #(foo % 1)
[01:54:19] <EdLangley[m]> And all my code has a convention of using IT for variable names where I don’t really care about the name
[01:54:34] <White_Flame> I always pass in a variable name
[01:54:53] <_death> otherwise, I defined an interpreter/compiler for the subset I needed.. there, it may sometime be fruitful to try another approach with a code walker
[01:54:56] <EdLangley[m]> Because I generally end up using lambda as a way of delaying an argument
[01:55:30] <EdLangley[m]> Yeah, I like the idea of being compatible with arbitrary lisp
[01:55:42] <EdLangley[m]> Although it’s probably actually a lot harder than it sounde
[01:59:28] *** Joins: Devon (~devon@c-24-2-157-5.hsd1.ma.comcast.net)
[01:59:44] <EdLangley[m]> It would be nice to be able to use CL-CONT with less concerns about the supported special forms
[02:00:20] <_death> there are monad-based implementations of continuations that don't require code walking
[02:01:16] <EdLangley[m]> Yeah, but they sort of require restructuring all your code
[02:02:01] <_death> it's not so bad, in my experience.. I used https://8c6794b6.github.io/posts/Delimited-continuations-with-monadic-functions-in-Common-Lisp.html in a logo with multiple turtles
[02:04:04] <_death> procedures can look like (defun rdragon (size level) (if (zerop level) (progc (fd size) (returnc 'nil)) (progc (ldragon size (1- level)) (rt 90) (rdragon size (1- level))))) and that's without additional sugar
[02:04:23] <EdLangley[m]> That’s not bad
[02:04:40] <EdLangley[m]> Especially because CL has macros to hide stuff
[02:05:57] <qhong> _death: It starts to look bad when you have to write (letc ((x stuff)) (+ x 3)) instead of (+ stuff 3)... Basically have to write in ANF
[02:06:07] <qhong> which is IMO not much better than writing CPS directly
[02:06:17] *** Quits: hobo_ (~hobo@204.128.242.10) (Ping timeout: 240 seconds)
[02:06:36] <EdLangley[m]> You might be able to symbol-macro that away?
[02:06:55] <EdLangley[m]> Maybe that’s what letc is doing
[02:07:38] <_death> again, it's not that bad since the procedures are small
[02:08:14] <qhong> and in those cases CPS is also not that bad
[02:08:38] <_death> probably
[02:28:10] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[02:28:37] *** Quits: random-nick (~random-ni@87.116.167.125) (Ping timeout: 240 seconds)
[02:28:54] <mfiano> Wonder if there is anything like alexandria:ensure-list that optionally conses the atom onto an existing list. Maybe something like: (defun foo (thing &rest rest) (if (listp thing) thing `(,thing . ,rest)))
[02:29:58] <phoe> sounds a bit too specific
[02:30:04] <mfiano> I always feel like I am inventing these weird utility functions for an odd use-case only to find out years later that someone beat me to it.
[02:30:47] <EdLangley[m]> SERAPEUM:UNSPLICE?
[02:30:57] * mfiano checks
[02:31:00] <EdLangley[m]> Hmm, maybe not
[02:31:25] <mfiano> No, definitely not
[02:36:05] <moon-child> no ,@?
[02:36:32] *** Quits: varjag (~user@ti0040a400-5479.bb.online.no) (Ping timeout: 250 seconds)
[02:36:45] <EdLangley[m]> Hmm, is this LIST*?
[02:36:53] *** Quits: cosimone (~user@93-47-231-147.ip115.fastwebnet.it) (Quit: ERC (IRC client for Emacs 27.1))
[02:36:59] <phoe> it's like (if (listp thing) thing (cons thing some-other-list))
[02:37:07] <phoe> optionally s/cons/list*/
[02:37:18] <mfiano> more like no #'cons
[02:37:23] <mfiano> I wrote it funny
[02:46:16] *** Quits: qhong (~qhong@rescomp-21-400677.stanford.edu) (Quit: ZNC 1.8.2 - https://znc.in)
[02:46:26] *** Joins: qhong (~qhong@rescomp-21-400677.stanford.edu)
[02:46:30] *** Quits: pve (~pve@87-93-188-7.bb.dnainternet.fi) (Quit: leaving)
[02:53:32] *** Quits: masinter (~masinter@c-73-158-116-21.hsd1.ca.comcast.net) (Ping timeout: 240 seconds)
[02:58:52] *** Joins: masinter (~masinter@c-73-158-116-21.hsd1.ca.comcast.net)
[02:59:23] *** Joins: molson__ (~molson@2001:48f8:704a:123d::75f:1027)
[03:02:06] *** Quits: molson_ (~molson@2001-48F8-704A-123D-0-0-75F-1024-static.midco.net) (Ping timeout: 250 seconds)
[03:13:56] *** Quits: attila_lendvai (~alendvai@2a02:ab88:3710:7c80:9130:5abf:96b3:dc0c) (Ping timeout: 268 seconds)
[03:40:47] *** Quits: mgl (~mgl@cpc87455-finc19-2-0-cust234.4-2.cable.virginm.net) (Ping timeout: 256 seconds)
[03:49:46] *** Joins: dra (~dra@2a04:4540:6402:9000:510e:1ea2:84e8:475a)
[03:54:17] <qhong> White_Flame: turns out that load-time-value completely doesn't work for me -- it nukes the lexical environment and break nesting :(
[04:00:04] <White_Flame> well yeah, there's no lexical environment
[04:00:12] <White_Flame> this is effectively toplevel, which is what you needed?
[04:01:19] <White_Flame> I presume the expansion is something like `(lambda ,params (load-time-value (defun ,name ,params ,@body)) (,name ,@params))
[04:01:31] <moon-child> qhong: s7 has first-class lexical environments, which are accessible at macroexpansion time.  Just sayin
[04:01:51] *** Joins: mixfix41 (~homefame@user/mixfix41)
[04:01:57] <moon-child> :)
[04:02:02] <White_Flame> the whole point of the DEFUN is that it's separated from the lexical environment and replaceable
[04:02:43] <White_Flame> where the PARAMS are the closed-over variable names
[04:03:44] <White_Flame> hmm, no it would need more than that if the DEFUN needs to be able to write to those closures, too
[04:04:18] <White_Flame> so it'd have to generate a (load-time-value (let (,closure-vars) (defun ,name ,lambda-params ...)))
[04:04:51] <White_Flame> with a way of intializing them & passing them through on re-defun, which should all be possible
[04:05:10] <qhong> White_Flame: see https://github.com/BlueFlo0d/named-closure/issues/2
[04:05:33] <qhong> moon-child: so does MIT Scheme, and is even installable/modifiable at runtime. Scheme >> CL!
[04:05:49] <White_Flame> do both OUTER1 and INNER1 consider X to be closed over?
[04:06:05] <qhong> White_Flame: Yes
[04:06:28] <White_Flame> huh, well I would think it's just a plain bug, as you're manually constructing the lexical environment
[04:06:32] <qhong> I think the problem is that there's a with-slots form by outer1 wrapping around inner1
[04:06:52] <qhong> however, because all inner1 related code are inside ltv, the symbol macro bindings are discarded
[04:06:56] <moon-child> qhong: in mit, can I say: ((if x - quote) 7)?
[04:07:11] <moon-child> err, better example: ((if x - quote) y)
[04:07:21] <qhong> moon-child: I can't read this
[04:07:38] <White_Flame> ((if x '- 'quote) y) maybe?
[04:07:46] <moon-child> White_Flame: nope
[04:07:46] <qhong> White_Flame: I tried with eval inside macroexpansion and it works but we know this doesn't work during compilation
[04:08:00] <moon-child> it says: evaluate x.  If x is true, choose -.  Otherwise choose quote.  Apply whatever you chose to y
[04:08:08] <moon-child> in other words: it is not even known until runtime whether y is evaluated
[04:08:12] <qhong> oh i see, so you have F-expr
[04:08:20] <moon-child> no not really fexpr
[04:08:38] <qhong> what's the difference?
[04:08:44] <moon-child> it's not different from (quote y).  Special operators are just first class
[04:09:00] <qhong> that sounds like saying special operators are just F-exprs
[04:09:19] <qhong> Or is it different because you can't define your own F-expr?
[04:09:19] <moon-child> (define (f x) x) ((f quote) a)
[04:09:29] <moon-child> would you say that 'f' is an fexpr?
[04:09:49] <qhong> f is a function, quote is an fexpr
[04:10:23] <White_Flame> in other words, is the function-position expression required to be a plain function?
[04:10:24] *** Quits: raeda (~raeda@72.49.214.135) (Read error: Connection reset by peer)
[04:10:44] <moon-child> qhong: ok
[04:10:59] <qhong> White_Flame: what I get (they just have F-expr) is just that they have macros but at runtime
[04:11:03] <sveit> does anyone know why SBCL issues a warning when a destructive function is applied to a macro argument?
[04:11:19] <moon-child> sveit: because macro parameters are generally literal
[04:11:20] <qhong> sveit: modifying literals
[04:11:22] <moon-child> and literals may not be modified
[04:11:24] <mfiano> sveit: Well it is undefined behavior
[04:11:36] <opcode> I'm trying to query a postgres database and the query function requires you to do e.g. (query (:select '* :from 'schema.table)).  Is there a way to construct the 'schema.table symbol programatically, i.e. by combining two variables?
[04:11:44] <qhong> moon-child: But do you have *correct* (hygienic F-exprs)?
[04:11:48] <White_Flame> sveit:  a macro argument is literal source code, and modifying literals is undefined behavior
[04:12:09] <moon-child> qhong: I am aware of no built-in mechanisms for enforcing hygiene
[04:12:14] <qhong> moon-child: I assume you can define your own F-expr, then in most cases it also needs to capture call-site lexical environment to be useful
[04:12:33] <qhong> moon-child: the beauty of hygienic F-expr is just that it is not through enforcement
[04:12:56] <moon-child> qhong: see 'bacros' here https://ccrma.stanford.edu/software/snd/snd/s7.html#macros
[04:13:16] <qhong> moon-child: eww macros
[04:13:41] <moon-child> ¯\_(ツ)_/¯
[04:13:50] <White_Flame> opcode: interning a string into a symbol?
[04:13:51] <qhong> moon-child: so seems that s7 don't really have arbitrary F-exprs (which is hard to do right), just built-in special operators behave like F-exprs
[04:14:01] <mfiano> opcode: alexandria:format-symbol or alexandria:symbolicate
[04:14:12] <opcode> thanks, I'll try those
[04:14:48] <opcode> also, are 'these 'things "objects"? in lisp parlance?
[04:14:50] <qhong> moon-child: I also bet it runs hella slow, like any existing impl that have any flavor of F-expr
[04:15:03] <qhong> F-expr hard to compile
[04:15:34] <White_Flame> as in halting problem level of hard
[04:15:35] <moon-child> it claims to be similarly similarly fast to guile
[04:16:02] <moon-child> grep 'Speaking of speed' in docs page
[04:16:03] <mfiano> opcode: something like (alexandria:format-symbol "~a.~a" scheme-var table-var) or (alexandria:symbolicate symbol-var '#:. table-var)
[04:16:11] <Bike> compilation in general is halting problem level, so that's fine
[04:16:14] <qhong> guile used to be hella slow as well until ppl stuff JIT in
[04:16:15] <Bike> :v
[04:16:17] <moon-child> er, no, lot faster than guile
[04:16:24] <opcode> thanks mfiano
[04:16:43] <moon-child> comparable to chicken, that was it
[04:16:56] <White_Flame> symbolicate takes strings as well:  (symbolicate 'schema "." 'table)
[04:17:06] <mfiano> It does
[04:17:07] <White_Flame> (but you have to be careful about case
[04:17:11] <opcode> okay
[04:17:23] <opcode> and (novice lisper here) those quoted literals
[04:17:27] <opcode> 'these 'things
[04:17:28] <mfiano> As for scheme, I think that is #lisp material
[04:17:33] <opcode> are they "uninterned symbols"?
[04:17:35] <White_Flame> no
[04:17:42] <opcode> what are they called
[04:17:44] <White_Flame> they're in the "current package" that the source code was read in
[04:17:52] <mfiano> '#:foo is an uninterned symbol
[04:17:53] <White_Flame> so by default, 'foo => CL-USER::FOO
[04:18:01] <mfiano> a quoted one that is
[04:18:05] <White_Flame> because that's the package you start in
[04:18:19] <opcode> what do you call that syntax, quoting a symbol that hasn't been defined
[04:18:30] <White_Flame> it's just quoting a symbol.  Doesn't matter the nature of the symbol
[04:18:32] <mfiano> quoting a symbol
[04:18:33] <opcode> ok
[04:18:37] <White_Flame> symbols are just names, used for many things
[04:18:49] <opcode> yeah I just get tripped up on the nomenclature
[04:18:59] <White_Flame> symbols name functions, symbols name lexical variables, whatever.  A symbol isn't tied to any particular usage in defining something
[04:19:03] <opcode> you read about plists so I thought :these :things were called properties
[04:19:07] <mfiano> if it hasn't been defined yet, the Lisp Reader will "intern" it (put it in a lookup table for retrieving when seen again later)
[04:19:30] <White_Flame> if you came from other compiled language, the first-classness of symbols can be a bit weird
[04:19:55] <opcode> I cut my teeth on C++ in university in 2004, but most of my programming life has been in C# and Java
[04:20:03] <White_Flame> yep
[04:20:17] <White_Flame> their source code is not made of first-class symbols as lisp is
[04:20:21] <mfiano> Yes, prepare to forget a lot, or tuck it away some place safe
[04:20:31] <opcode> yeah it's a real paradigm shift
[04:20:49] <White_Flame> also, I'd recommend #clschool, as this place can be full of esoterica
[04:21:07] <opcode> cool
[04:21:08] <White_Flame> in particular for asking learner questions
[04:21:11] <mfiano> There is also #clschool if you want some more focused beginner help. Most people here may assume at least an intermediate level of CL
[04:21:15] <White_Flame> feel free to lurk here, too :)
[04:21:31] <opcode> should I take that to mean noob questions are off-topic here?
[04:21:45] <mfiano> No they aren't
[04:21:49] <opcode> ok
[04:22:08] <opcode> I will still direct them to #clschool to avoid clutter as this is a busy channel at times
[04:22:14] <opcode> thanks for the help
[04:22:20] <mfiano> You might get some responses that are hard to digest, leading to a lot of recursive questions.
[04:22:23] *** Quits: shka (~herr@109.231.0.226) (Ping timeout: 268 seconds)
[04:22:24] <White_Flame> there's more of an assumption than you know more here
[04:22:27] <White_Flame> hence answers can be extremely "complete" and obtuse
[04:23:24] <mfiano> opcode: Good luck with your learning. I hope you are having fun
[04:23:45] <mfiano> White_Flame: abtuse or obtuse?
[04:23:52] <Bike> noob questions are fine but you run the risk of me explaining make-load-form until you start crying
[04:24:03] <mfiano> err
[04:24:06] *** Joins: igemnace (~ian@user/igemnace)
[04:24:18] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 276 seconds)
[04:24:20] <mfiano> abstruse
[04:25:26] <White_Flame> obtuse as in way wider than expected
[04:25:34] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[04:26:03] <White_Flame> although yeah, probably crossed wires with abstruse
[04:27:20] <mfiano> TIL that the two are often confused to the point that the former now has a dictionary definition for the latter.
[04:27:23] <mfiano> Ignore me
[04:30:13] *** Quits: dra (~dra@2a04:4540:6402:9000:510e:1ea2:84e8:475a) (Remote host closed the connection)
[04:41:45] *** Joins: raeda (~raeda@72.49.252.109)
[04:55:12] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 250 seconds)
[04:57:51] *** Joins: karlosz (~karlosz@47.151.136.69)
[04:59:26] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[05:02:57] *** Quits: mixfix41 (~homefame@user/mixfix41) (Ping timeout: 240 seconds)
[05:03:43] *** Quits: karlosz (~karlosz@47.151.136.69) (Ping timeout: 256 seconds)
[05:05:04] *** Joins: mixfix41 (~homefame@user/mixfix41)
[05:08:17] *** Quits: masinter (~masinter@c-73-158-116-21.hsd1.ca.comcast.net) (Ping timeout: 240 seconds)
[05:09:28] *** Joins: gaqwas (~john@dynamic-077-004-123-063.77.4.pool.telefonica.de)
[05:15:46] *** Quits: unyu (~pyon@user/pyon) (Quit: WeeChat 3.4)
[05:15:49] *** Joins: parjanya (~esb@177.33.154.179)
[05:18:30] <qhong> There's another issue in named-closure but idk if I should even attempt to solve it https://github.com/BlueFlo0d/named-closure/issues/1
[05:19:19] <qhong> It's possible to simulate the "correct" environment sharing by indirection through a native closure, but this makes introspection and readble printing more complicated, moreover I think it nukes upgradability
[05:20:04] <qhong> While it's not unreasonable to ask user to fix up old closures using STORE-VALUE, it sounds pretty impratical to expect user to fix the sharing structure between different closures. Thoughts?
[05:24:22] *** Joins: unyu (~pyon@user/pyon)
[05:27:19] *** Quits: gaqwas (~john@dynamic-077-004-123-063.77.4.pool.telefonica.de) (Ping timeout: 256 seconds)
[05:27:57] *** Quits: occ (~occ@user/occ) (Remote host closed the connection)
[05:39:01] *** Joins: asen (~asen@2408:821b:618:1a0:2cc1:43d3:3642:45c4)
[05:41:14] *** Quits: morganw (~user@80.225.24.132) (Remote host closed the connection)
[05:47:49] *** Joins: s-liao (~s-liao@101.86.96.21)
[06:00:57] <Bike> not sure you could have them share environments without having your own binding form instead of let. or using native closures, but then you can't access the environment later like i think you want to do.
[06:02:08] <qhong> Bike: I know how to simulate. I just need to expand to basically a pair of (lambda () var) and (lambda (val) (setf var val)) in place, and use this pair of native closures as a "generalized variable".
[06:02:26] <Bike> yeah i was thinking about that, but it seems like you'd lose read syntax?
[06:03:48] <qhong> Bike: Given that I know all of my slots are storing such pairs, I can simply call the reader to print. And if *print-circle* = t, I can check the identity of the reader closure to reproduce the correct sharing
[06:04:20] <qhong> My actual problem is about given I can simulate it, should I? The major downside I see is upgradability.
[06:10:08] *** Parts: rotateq (~user@p200300e78706a00050f72feb644e2401.dip0.t-ipconnect.de) (ERC (IRC client for Emacs 27.2))
[06:14:47] <qhong> Is the `muffle-warning' restart ever implemented? http://clhs.lisp.se/Body/f_warn.htm
[06:15:07] <qhong> Neither SBCL or CCL seem to have it. CL implementors DGAF about language standard???
[06:15:30] <White_Flame> (let ,closure-vars (defun ,name ,params ,@body) (defun ,init-name ,param-vals ..(setf param param-val)..))
[06:15:49] <semz> qhong: Do you have an example where it isn't working?
[06:15:54] <White_Flame> hmm, maybe not.  that would imply a singleton closure per name
[06:16:17] <qhong> semz: (handler-case (warn "test") (warning (c) (print (list c (compute-restarts c)))))
[06:16:25] <qhong> semz: and I don't see any `muffle-warning' restart
[06:16:40] <semz> handler-case already unwinds beyond warn
[06:16:47] <semz> you're looking for handler-bind
[06:17:20] <qhong> semz: Hah, interesting, thanks!
[06:17:32] <qhong> condition/restart much more confusing than call/cc
[06:17:48] <semz> They take a bit of time to get used to.
[06:18:57] *** Joins: varjag (~user@ti0040a400-5479.bb.online.no)
[06:24:17] *** Quits: varjag (~user@ti0040a400-5479.bb.online.no) (Ping timeout: 240 seconds)
[06:29:18] <Bike> call/cc is a primitive operator whereas the condition system is a whole system, so it can be easier to understand
[06:38:57] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 240 seconds)
[06:45:52] *** Joins: Oladon (~olad@98.43.81.226)
[06:49:07] *** Quits: Devon (~devon@c-24-2-157-5.hsd1.ma.comcast.net) (Ping timeout: 256 seconds)
[06:49:14] *** Joins: myrrh (~markus@user/poet)
[07:07:10] *** Quits: igemnace (~ian@user/igemnace) (Remote host closed the connection)
[07:11:47] *** Quits: vats (~vats@103.216.143.18) (Ping timeout: 256 seconds)
[07:12:32] *** Quits: terrorjack (~terrorjac@2a01:4f8:1c1e:509a::1) (Quit: The Lounge - https://thelounge.chat)
[07:13:25] *** Joins: terrorjack (~terrorjac@2a01:4f8:1c1e:509a::1)
[07:24:11] <|smlckz|> what are some synonyms for cdr?
[07:24:26] <Bike> rest
[07:25:43] <ns12> |smlckz|: What is the reason behind your question?
[07:26:57] <ns12> Bike: Is CDR exactly the same as REST?
[07:27:06] <|smlckz|> i am using first second third, so thought cdr would not look nice along with them
[07:27:54] *** Joins: masinter (~masinter@c-73-158-116-21.hsd1.ca.comcast.net)
[07:28:20] <Bike> ns12: they do the same thing
[07:29:05] <|smlckz|> hmm.. ''rest performs the same operation as cdr, but mnemonically complements first.''
[07:30:50] <beach> Good morning everyone!
[07:31:06] <ns12> Bike: In every case where cl:cdr appears, can it be substituted with cl:rest without change in functionality, and vice versa?
[07:31:24] <ns12> Good morning beach.
[07:31:26] <beach> ns12: Yes.
[07:32:20] <beach> ns12: Also, the normal use of "substitute" is that if you "replace A by B", you "substitute B for A".
[07:33:41] <beach> |smlckz|: FIRST, REST etc. are preferable if you are dealing with lists.  CAR, CDR etc. are preferable if you are dealing with trees or with CONS cells as such.
[07:33:54] <ns12> beach: Okay. Here's a corrected version: "In every case where cl:cdr appears, can it be replaced by cl:rest without change in functionality, and vice versa?"
[07:34:11] <beach> Yes, again.
[07:34:30] *** Quits: luis (~luis@lisp/luis) (Quit: The Lounge - https://thelounge.chat)
[07:34:33] <beach> Er, let me modify that....
[07:35:03] <beach> (length (symbol-name 'cl:rest)) is not the same as (length (symbol-name 'cl:cdr)).
[07:35:19] <beach> But when you use it as a function to call, they have the same functionality.
[07:37:39] <pjb> |smlckz|: but note that NULL and ENDP don't do the same thing. If you use FIRST & REST you will probably want to use ENDP too.
[07:39:01] <Bike> ns12: they have exactly the same effect. the differences are stylistic. and, technically, in (eql #'cdr #'cdr) you'd probably get true but in (eql #'cdr #'rest) you'd get false, but that's probably not the kind of difference you were thinking of.
[07:39:31] *** Joins: luis (~luis@lisp/luis)
[07:39:31] *** ChanServ sets mode: +o luis
[07:41:47] <ns12> Bike: I was under the impression that CL:EQL should not be used on functions.
[07:42:11] <beach> ns12: What gave you that impression?
[07:42:28] <|smlckz|> so, non list argument to endp causes type-error
[07:42:29] <beach> clhs eql
[07:42:30] <specbot> http://www.lispworks.com/reference/HyperSpec/Body/a_eql.htm
[07:42:30] <Bike> it's a little big vague. that's why i said "probably". but i think every actual implementation will do (eql #'cdr #'cdr) => T.
[07:42:30] <pjb> (eql (lambda ()) (lambda ()) ) #| --> nil |#
[07:42:49] *** Joins: Colt (~Colt@user/colt)
[07:42:54] <pjb> But: (defun foo ())  (eql (function foo) (function foo)) #| --> t |#
[07:43:00] <pjb> ns12: so you can use it.
[07:43:17] <beach> clhs endp
[07:43:18] <specbot> http://www.lispworks.com/reference/HyperSpec/Body/f_endp.htm
[07:43:23] <ns12> So I can use it, but the results are implementation-dependent?
[07:43:46] <pjb> Yes, they indicate how rest is implemented vs cdr.
[07:43:56] <beach> |smlckz|: Yes, the standard says so: "Should signal an error of type type-error if list is not a list."
[07:44:07] <pjb> (setf (fdefinition 'bar) (fdefinition 'foo))   (eql (function foo) (function bar)) #| --> t |#
[07:44:22] <pjb> (defun baz ()) (eql (function foo) (function baz)) #| --> nil |#
[07:44:53] *** Quits: asen (~asen@2408:821b:618:1a0:2cc1:43d3:3642:45c4) (Quit: Leaving)
[07:45:15] <pjb> Another way is also: (function bar) #| --> #<Compiled-function foo #x302002FC69FF> |#   but this could be corrected by the implementation in the printer.
[07:45:38] <Bike> ns12: the only bit that's really vague is that you can't depend on closures produced by different evaluations being eq or not. something like #'eql should be fine regardless
[07:45:49] <Bike> since you're not producing a closure
[07:46:07] <mfiano> is there anything standard or in alexandria that will allow me to translate a list of lists of symbols to an alist: '((a b c) (1 2 3)) => '((a . 1) (b . 2) (c . 3)) ...or should I just write the simple code myself?
[07:46:09] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[07:46:28] <mfiano> list of list of atoms*
[07:46:36] <pjb> (apply 'mapcar 'cons '((a b c) (1 2 3))) #| --> ((a . 1) (b . 2) (c . 3)) |#
[07:46:38] <beach> (apply #'mapcar #'cons list)?
[07:47:19] <mfiano> Yeah I know how to do it. Was just curious if this was provided in any of the two sources :)
[07:48:19] <ns12> Is there a difference between (setf (fdefinition 'f) #'+) and (setf (symbol-function 'f) #'+) ?
[07:48:26] <mfiano> Yes
[07:48:32] <mfiano> The latter shouldn't be used
[07:48:41] <Bike> they have the same effect, though.
[07:48:51] *** Quits: masinter (~masinter@c-73-158-116-21.hsd1.ca.comcast.net) (Quit: ~ Trillian - www.trillian.im ~)
[07:48:51] <ns12> Ah, why should the latter be avoided?
[07:49:18] <Bike> symbol-function is just fdefinition that works on less stuff.
[07:49:35] <Bike> since it only handles symbols, whereas fdefinition can do symbols and also (setf whatever).
[07:49:36] <beach> ns12: It is a leftover from when function names could only be symbols.
[07:50:01] *** Quits: wheelsucker (~user@2600:8801:8c24:d000:25e1:aacc:8c79:dcd3) (Remote host closed the connection)
[07:50:15] *** Joins: wheelsucker (~user@2600:8801:8c24:d000::8e14)
[07:51:27] <mfiano> ns12: Symbols are objects with different cells that can be retrieved or modified. But a function can be named by a list of 2 specific symbols as well.
[07:52:39] <beach> Though, of course SICL symbols have only two cells, namely one for the name and one for the package.
[07:52:55] <beach> I guess "slots" would have been a better term.
[07:53:21] <ns12> mfiano: Could you give an example? I don't quite understand what you mean by "a function can be named by a list of 2 specific symbols as well".
[07:53:48] <beach> ns12: Bike told you.  (defun (setf foo) (x y) ...)
[07:53:52] <Bike> (setf foo) can be a function name
[07:54:46] <ns12> Oh I see, this is a special case for SETF.
[07:55:07] <mfiano> In that case, the actual name of the function is (setf foo), which a reference to the function object can be obtained with (function (setf foo)) or simply #'(setf foo)
[07:56:00] *** Quits: myrrh (~markus@user/poet) (Quit: leaving)
[07:56:04] <beach> I wish the standard hadn't mentioned "cells" like function cells and value cells.
[07:56:22] <beach> They are historical implementation details.
[07:56:37] <mfiano> ns12: No this is a special case for what is permitted to be a function name
[07:56:49] <ns12> mfiano: For (setf foo), #'fdefinition would work but #'symbol-function would not, which is why #'fdefinition is preferred. Is my understanding correct?
[07:56:58] <mfiano> It has not much to do with SETF. Infact your (setf foo) function doesn't even have to "set" anything.
[07:57:25] <mfiano> ns12: Yes
[07:58:05] <ns12> mfiano: Bike: beach: Thank you for the explanations.
[07:58:13] <Bike> no problemo
[07:58:18] <mfiano> Anytime
[07:58:23] <beach> ns12: Try (macroexpand '(setf (unknown-stuff x) 234)) and you will see the use of a function such as (SETF ...) It is what SETF expands to when given an unknown operator.
[08:00:08] <mfiano> Common Lisp isn't functional, but the standard and CDR's prefer acretion over mutability :)
[08:00:49] <mfiano> *accretion
[08:01:58] *** Joins: Guest23 (~Guest23@152.168.80.110)
[08:04:24] <mfiano> I'll take hysterical raisins any day, which some actually even come in useful at times, over the Python2/Python3 disaster, or anything inbetween.
[08:04:49] <light> Hi, I'm reading Practical Common Lisp and following along using SBCL. I'm getting unwanted new lines inserted before the y-or-n-p prompts in my code. What exactly causes this and how do I fix it? http://paste.debian.net/1228078/
[08:05:51] *** Quits: Guest23 (~Guest23@152.168.80.110) (Quit: Client closed)
[08:07:21] <beach> light: It is probably that the same stream is used for several things.
[08:09:43] *** Quits: wmblathers (~wmblather@162-199-148-123.lightspeed.mdsnwi.sbcglobal.net) (Quit: Ping timeout (120 seconds))
[08:10:48] <beach> light: I wouldn't count on detailed behavior like that for the REPL.  It might be well defined, but I don't know the details.
[08:10:50] <mfiano> There is also some ambiguities in the standard
[08:11:01] <light> Hm
[08:13:14] <mfiano> It is intended that the reply require the user to take more action than just a single keystroke, such as typing the full word yes or no followed by a newline. It does not say how that should be written to the stream.
[08:13:26] <mfiano> SBCL inserts a newline when enter is pressed. CCL does not.
[08:13:51] <beach> clhs y-or-n-p
[08:13:52] <specbot> http://www.lispworks.com/reference/HyperSpec/Body/f_y_or_n.htm
[08:13:56] <beach> clhs yes-or-no-p
[08:13:56] <specbot> http://www.lispworks.com/reference/HyperSpec/Body/f_y_or_n.htm
[08:15:21] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[08:19:04] *** Joins: semz_ (~semz@user/semz)
[08:20:23] <light> So y-or-n-p is using fresh-line to output a new line because it can't determine if it's already at the start of the line.
[08:21:28] *** Quits: semz (~semz@user/semz) (Ping timeout: 250 seconds)
[08:21:30] <beach> Maybe so.
[08:27:33] *** Quits: jstoddard (~Jeremiah@189.202.78.167.cable.dyn.cableonline.com.mx) (Quit: Leaving)
[08:28:33] *** Joins: igemnace (~ian@user/igemnace)
[08:42:26] <|smlckz|> given a function or lambda, is there a way to know how many (mandatory) arguments it takes?
[08:44:12] *** semz_ is now known as semz
[08:45:26] <ns12> |smlckz|: Interactively or programatically?
[08:45:52] <|smlckz|> programmatically
[08:46:10] <beach> |smlckz|: There is no such thing as "a lambda".  There is a "lambda expression" that, when evaluated, becomes a function.  And the term is "required arguments".  The only function that can answer that is FUNCTION-LAMBDA-EXPRESSION but there is no guarantee that it will.
[08:46:35] <beach> ns12: Why does it matter?
[08:47:32] <beach> |smlckz|: For generic functions, it is possible...
[08:47:40] <beach> mop generic-function-lambda-list
[08:47:40] <specbot> http://metamodular.com/CLOS-MOP/generic-function-lambda-list.html
[08:47:48] <beach> But you need the MOP.
[08:51:12] <|smlckz|> hmm
[08:53:12] <|smlckz|> now i remembered a good word instead of number-of-variables.. arity !
[08:53:20] <qhong> |smlckz|: there's also plenty of compatibility layers that just give you arglist
[08:53:41] <qhong> I think I mentioned it just earlier today, either `swank' or `trivial-arguments' will do
[08:54:24] <qhong> MIT Scheme has procedure-arity btw
[08:54:33] <Bike> implementations may not store the information, though. for example at space 3.
[08:54:59] *** Joins: [w] (~w]@2601:8c1:80:70d0::4b06)
[08:57:53] <mfiano> That macro I've been writing for two days _was_ finished, but I just found one particular call site it doesn't know how to handle. I'm not quite sure how to handle late binding with this...
[09:04:11] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[09:10:18] <|smlckz|> two days?
[09:10:31] <mfiano> Yes, I am slow, and just getting back into programming.
[09:10:32] <ns12> beach: "Why does it matter?" - #'describe prints the argument list.
[09:11:36] <mfiano> Here is what I'm up against. Test case 5 needs to be handled. That is, body forms may include references to previous bindings, and I am not sure how to know how to order the LET bindings correctly to account for that, or if that is even possible: https://gist.github.com/mfiano/3437b61317dd0c81710d77e3be29ea70#file-utils-lisp-L98
[09:18:06] <qhong> mfiano: why you ever need to SUBLIS? Why not just wrap your BODY with `(let (bindings) ,@body)?
[09:19:36] <mfiano> Because I need to substitute the user-supplied variables with the proper gensym'd parameters of the generated m-v-c function.
[09:19:53] *** Joins: vats (~vats@103.216.143.32)
[09:20:16] <qhong> Why you need to subsitute? `(let ((old-variable new-variable)) ,@body)?
[09:20:48] <qhong> Also I'm not sure why you need to gensym at all. You need gensym if you're creating new variables. Now user always supply bunch of symbols and you can use them just fine
[09:20:58] <qhong> always -> already
[09:21:07] <mfiano> Because old variables do not need to be unique across bindings.
[09:21:12] <mfiano> That is the whole point of the macro
[09:26:59] *** Joins: Jing (~hedgehog@240e:390:7c53:a7e1:c16c:1790:8bf6:b4b5)
[09:27:19] <beach> ns12: I see what you mean.  Still DESCRIBE is not required to show that information, and as Bike pointed out, the information may not be available.
[09:36:49] <|smlckz|> hmm, so passing arity along with the function is the way to go for now.. until i use objects or such..
[09:37:21] *** Quits: igemnace (~ian@user/igemnace) (Quit: WeeChat 3.4)
[09:40:21] <beach> You are already using objects.
[09:42:20] *** Quits: Bike (~Bike@71.69.170.70) (Quit: Connection closed)
[09:42:37] *** Joins: akoana (~ah@user/akoana)
[09:45:53] *** Joins: s-liao (~s-liao@101.86.96.21)
[09:53:21] <qhong> mfiano: I see your problem. I'm still pretty sure SUBLIS is unnecessary, but the bigger problem is that your syntax doesn't seem well defined. In your test case 5, what if there are 5 channel in total and someone write spec=((rgb 3) (a 2))? What will the `a's in your first form refer to?
[09:54:07] <mfiano> If you look at the macro definition, you can see in the spec normalization that it is guaranteed to be at most 4.
[09:54:15] *** Joins: myrrh (~markus@user/poet)
[09:54:39] <mfiano> I don't think you understand the full utility of the macro though. And I am too tired and about to go to sleep to fully explain it, so don't worry.
[09:55:46] *** Joins: aartaka (aartaka@gateway/vpn/protonvpn/aartaka)
[09:56:21] <qhong> mfiano: I see it, but I'm saying it's just a coincidence. A good syntax should work for any number channel. Also even just for 4 channels, what if someone write spec=((a 2) (b 2)) and do forms=(* a b) (+ a b)?
[10:00:39] *** Joins: varoun (~varoun@223.226.97.209)
[10:09:15] <ns12> |smlckz|: Try this library: https://github.com/Shinmera/trivial-arguments
[10:10:39] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[10:16:17] *** Quits: varoun (~varoun@223.226.97.209) (Ping timeout: 240 seconds)
[10:28:17] *** Joins: s-liao (~s-liao@101.86.96.21)
[10:42:04] *** Joins: igemnace (~ian@user/igemnace)
[10:51:43] *** Joins: mgl (~mgl@cpc87455-finc19-2-0-cust234.4-2.cable.virginm.net)
[10:52:32] *** Joins: [smlckz] (3329f5a75b@user/smlckz)
[10:53:37] *** Quits: aartaka (aartaka@gateway/vpn/protonvpn/aartaka) (Ping timeout: 240 seconds)
[10:54:27] *** Joins: aartaka (aartaka@gateway/vpn/protonvpn/aartaka)
[10:58:06] *** Joins: lisp123 (~lisp123@5.30.23.247)
[11:25:03] *** Quits: igemnace (~ian@user/igemnace) (Quit: WeeChat 3.4)
[11:57:42] *** Quits: iamFIREc1 (~iamFIREcr@user/iamfirecracker) (Ping timeout: 250 seconds)
[12:18:09] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[12:21:07] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[12:29:56] <pjb> |smlckz|: sometimes you can use function-lambda-expression, but implementations can drop the info, so you often just get NIL.
[12:30:06] *** Quits: rudi (~rudi@2001:470:69fc:105::dc4b) (Quit: You have been kicked for being idle)
[12:30:52] <pjb> |smlckz|: otherwise, a lot of implementation provide an implementation specific API to get it. You can use swank as a portability layer: (swank/backend:arglist (function sin)) #| --> (ccl::x) |#
[12:32:56] *** Joins: iamFIREcracker (~iamFIREcr@user/iamfirecracker)
[12:33:47] *** Joins: pve (~pve@178-55-168-197.bb.dnainternet.fi)
[12:36:12] *** Joins: lisp123 (~lisp123@5.30.23.247)
[12:36:13] *** Quits: rogersm (~rogersm@90.166.180.250) (Read error: Connection reset by peer)
[12:37:19] <pjb> mfiano: so for a specs of (a 1) you would want to expand to a (let ((a <something>)) …)  but for a specs of (rgb 3) you would want to expand to (let ((#:arg1 <something>) (#:arg2 <something>) (#:arg3 <something>)) …) ???
[12:40:37] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 240 seconds)
[12:46:21] *** Joins: gaqwas (~john@dynamic-095-117-092-244.95.117.pool.telefonica.de)
[12:48:17] *** Joins: shka (~herr@109.231.0.226)
[12:51:30] *** Quits: gaqwas (~john@dynamic-095-117-092-244.95.117.pool.telefonica.de) (Remote host closed the connection)
[13:03:49] *** Joins: rogersm (~rogersm@90.166.180.250)
[13:04:13] <mgl> |smlckz|: yes, swank-backend is pretty good
[13:17:01] <EdLangley[m]> Just used swank to get nicer "eldoc" in lispworks :)
[13:22:14] <EdLangley[m]> https://fwoar.co/pastebin/1aa39d6e100a3f0cff501f3cff7c443c61aab5ea.lisp.html
[13:22:31] <EdLangley[m]> Just a hack, so lots of ::
[13:22:51] *** Joins: rain3 (~rain3___@5-12-7-240.residential.rdsnet.ro)
[13:22:57] *** Joins: Algernon69 (~Algernon6@88.124.69.179)
[13:27:02] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[13:29:34] *** Quits: amb007 (~a_bakic@102.215.76.86.rev.sfr.net) (Ping timeout: 250 seconds)
[13:29:46] *** Joins: amb007 (~a_bakic@84.196.204.77.rev.sfr.net)
[13:30:07] *** Quits: Algernon69 (~Algernon6@88.124.69.179) (Ping timeout: 256 seconds)
[13:44:47] *** Quits: amb007 (~a_bakic@84.196.204.77.rev.sfr.net) (Read error: Connection reset by peer)
[13:45:19] *** Joins: amb007 (~a_bakic@102.215.76.86.rev.sfr.net)
[14:02:25] *** Quits: vats (~vats@103.216.143.32) (Ping timeout: 256 seconds)
[14:03:29] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Remote host closed the connection)
[14:06:28] *** Joins: Nilby (Nilby@2600:3c01::f03c:92ff:feeb:88ff)
[14:11:09] *** Joins: VincentVega (~user@212.97.0.240)
[14:16:22] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 250 seconds)
[14:16:31] *** Joins: Lord_of_Life_ (~Lord@user/lord-of-life/x-2819915)
[14:17:49] *** Lord_of_Life_ is now known as Lord_of_Life
[14:19:14] *** Joins: cage (~cage@dynamic-adsl-84-221-50-16.clienti.tiscali.it)
[14:20:11] *** Quits: amb007 (~a_bakic@102.215.76.86.rev.sfr.net) (Ping timeout: 256 seconds)
[14:20:53] *** Joins: amb007 (~a_bakic@84.196.204.77.rev.sfr.net)
[14:27:49] *** Quits: srji (~srji@static.43.141.203.116.clients.your-server.de) (Quit: leaving)
[14:28:38] *** Joins: varjag (~user@ti0040a400-5479.bb.online.no)
[14:32:24] *** Quits: molson__ (~molson@2001:48f8:704a:123d::75f:1027) (Ping timeout: 250 seconds)
[15:02:52] *** Quits: [w] (~w]@2601:8c1:80:70d0::4b06) (Quit: zzz)
[15:13:49] *** Joins: bonmlp (~user@dsl-141-182.bl26.telepac.pt)
[15:13:53] *** Joins: Dynom (~niels@80-114-12-206.cable.dynamic.v4.ziggo.nl)
[15:22:01] *** Joins: lisp123 (~lisp123@5.30.23.247)
[15:25:05] *** Joins: occ (~occ@user/occ)
[15:26:32] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 240 seconds)
[15:31:04] *** Joins: vats (~vats@103.216.143.14)
[15:37:10] *** Joins: attila_lendvai (~alendvai@2a02:ab88:3710:7c80:9130:5abf:96b3:dc0c)
[15:41:42] *** Joins: Devon (~devon@c-24-2-157-5.hsd1.ma.comcast.net)
[15:58:14] *** Quits: amb007 (~a_bakic@84.196.204.77.rev.sfr.net) (Read error: Connection reset by peer)
[15:58:47] *** Joins: amb007 (~a_bakic@102.215.76.86.rev.sfr.net)
[16:14:36] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[16:20:47] *** Joins: lisp123w (~user@80.227.170.170)
[16:20:54] *** Joins: random-nick (~random-ni@87.116.167.125)
[16:21:45] <lisp123w> I am thinking of writing some 'portable' code (specifically code that can work with both CLIM & CAPI), so at some point I need to access implementation specific functions
[16:22:23] <lisp123w> So my plan is to define the basic operations in terms of generic functions that take in an optional value, and then have the methods implement for each specific implementation
[16:22:33] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[16:23:12] <lisp123w> Is there a particular way I should approach this?
[16:25:08] <lisp123w> Right now, I can only think of having to have two functions, something like this: (defvar *impl* :clim) (defun insert-string-at-point (string) (%insert-string-at-point string *impl*)) .. (defgeneric %insert-string-at-point (string impl))
[16:25:14] <beach> lisp123w: Check out our libraries Eclector, Cluster, Trucler, etc.  They all use a CLIENT required parameter that can handle that situation.
[16:25:21] <lisp123w> beach: Thank you!
[16:25:30] <lisp123w> I will do that now
[16:25:42] <beach> This technique has turned out to be extremely flexible.
[16:25:48] <pjb> lisp123w: or: (defmethod foo (arg &optional (*impl* *impl*)) …)
[16:26:28] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Remote host closed the connection)
[16:26:32] <lisp123w> pjb: I was thinking that, but if I remember, can't dispatch on optionals?
[16:26:49] <phoe> it isn't an optional parameter
[16:27:24] <phoe> (defgeneric foo-with-client (client ...)) (defun foo (...) (foo-with-client *default-client* ...))
[16:27:59] <beach> Yes, we do that in Eclector for instance, where we can't alter the signature of READ.
[16:28:06] *** Joins: mingus (~jan-magnu@auth-146-195.anyconnect.uib.no)
[16:28:10] <phoe> where *default-client* is both something you provide and something that the clients of your library can rebind themselves as a dynavar
[16:28:16] <lisp123w> phoe: Yeah I was thinking just that
[16:30:19] <beach> So for Eclector, we can do (let ((eclector:*client* *sicl*)) (eclector:read...))
[16:31:24] <lisp123w> I see
[16:32:45] <beach> In our case, the default methods provided by the library do not specialize to the CLIENT parameter, but the same client code that binds *client* can provide extending or overriding methods that specialize to the class of their particular client.
[16:33:10] <beach> Like (defmethod eclector:interpret-token ((client sicl) ...) ...)
[16:34:08] <lisp123w> That's an interesting idea
[16:34:22] <lisp123w> Very interesting actually
[16:35:02] <beach> We are very pleased with this "discovery".  It allows for code for multiple clients to coexist in the same Common Lisp image.
[16:35:57] <Nilby> and to make it look nice, you can (defmacro foo (..) (foo-with-client *default-client* ...))
[16:36:58] <beach> Well, in the case of Eclector, READ is defined to be a function, so it can't be a macro.
[16:37:34] <phoe> Nilby: that'll badly break #'foo
[16:38:43] <lisp123w> beach: Is there a reason for the local binding (let ((client *client*))...) in particular?
[16:39:11] <phoe> lisp123w: where do you mean?
[16:39:28] <lisp123w> I am just looking at (defun read-aux ...) in read.lisp in Eclector
[16:39:48] <beach> Let me look at it...
[16:39:59] <lisp123w> I would have done it as &optional (client *client*), but maybe there's a particular reason (from what I understand they should be the same)
[16:40:26] <lisp123w> (well not actually the same, but the effect being the same if client is not supplied in as an optional)
[16:40:31] <phoe> it's surely a way to de-dynamify the binding, because CLIENT is a lexical variable
[16:41:14] <beach> lisp123w: It is a bit more expensive to access a dynamic variable than a lexical one.
[16:41:15] <phoe> which kind of makes sense because you only need the dynamic binding on the boundary of your system, so you can effectively pass extra function arguments this way
[16:41:34] <lisp123w> beach: Got it! Thanks (thakns phoe too)
[16:41:50] <phoe> so what beach said + you guard your code against some funky re-binding that can cause one part of your code to be executed with one client and another part with another
[16:41:57] *** Quits: vats (~vats@103.216.143.14) (Ping timeout: 240 seconds)
[16:42:22] <beach> Yes, you send a message to the person reading your code that you intend to use the same value of *client* in the entire function.
[16:42:24] <phoe> that's what you get when the client object becomes bound to a lexical variable instead of being accessed by a dynavar
[16:43:03] <lisp123w> phoe: Thanks, is that mostly an issue in multiple processes?
[16:43:08] <phoe> not really
[16:43:19] <phoe> every thread has its own set of dynamic bindings, so that isn't a problem
[16:43:51] <lisp123w> Ah so it is just taking a 'snapshot' of its value at that point in time?
[16:43:54] <phoe> yes
[16:43:55] *** Quits: mingus (~jan-magnu@auth-146-195.anyconnect.uib.no) (Quit: Lost terminal)
[16:44:02] <phoe> that's what I mean by de-dynamifying
[16:44:03] <lisp123w> Got it, thanks!
[16:44:06] <beach> lisp123w: Imagine you had (foo *client*) (bar) (baz *client*).
[16:44:23] <beach> You don't know whether BAR might do (setf *client* ...).
[16:44:29] <phoe> you cannot make a closure over a dynamic variable because it's too dynamic to be closed over™
[16:44:37] <lisp123w> beach: Nice example, I never really thought of this point until now
[16:45:08] <phoe> you need to grab the value and stuff it into a lexical variable which is less prone to dynamism such as random-seeming changes
[16:45:11] <phoe> which is what happens here
[16:45:19] <beach> It is not a big deal usually, and in read-aux I don't think this case can happen.
[16:45:50] <lisp123w> I see. Still a good practice to follow where relevant
[16:46:01] <beach> Indeed.
[16:46:55] <beach> lisp123w: Eclector is a great library to study, for many reasons.
[16:50:18] <lisp123w> beach: Thanks for the heads up, will do! I'm now at the stage where I'm trying to learn from other code vs. learning the concepts
[16:50:42] <phantomics> Looking for people's opinions on an engineering issue that's come up
[16:50:50] <beach> lisp123w: That's excellent!
[16:51:05] <lisp123w> Which Lisp makes it possible since its so open and easy to introspect :)
[16:51:15] <beach> Sure.
[16:51:38] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 268 seconds)
[16:52:17] <phantomics> In April, you can pass values into an April code invocation from outside. That includes arrays, naturally. APL isn't strongly typed so you can pass in an array, assign an element of an incompatible type, and April will automatically create a copy of the array with a compatible type to assign the new value into
[16:52:32] *** Joins: gaqwas (~john@dynamic-095-117-092-244.95.117.pool.telefonica.de)
[16:52:46] <phantomics> The problem is this: If you pass in an outside array and assign a compatible value into it, the array you passed in will be destructively changed
[16:53:14] <phantomics> But if you assign an incompatible value, the outside array will not be changed because April silently made a copy. This is confusing for some people
[16:54:18] <phantomics> There's an example here: http://ix.io/3N7N
[16:54:33] <phantomics> This code has a side effect, changing the "a" array that was passed in
[16:55:55] <sm2n> That seems fine to me? Just have to specify that April takes ownership of arrays passed in, and if you want the old one, make a copy
[16:55:58] <phantomics> But if that array is of a type incompatible with the 20 value, like (unsigned-byte 4), then the original array would be copied and the side effect would not occur. Confusing, obviously. What do you think is the best approach here? Always copy arrays passed in so that side effects don't occur?
[16:56:45] <phantomics> sm2n: The issue is with inconsistency, the original array could either be changed or not changed depending on what you're assigning into it, which can throw people for a loop
[16:56:49] *** Joins: notzmv (~zmv@user/notzmv)
[16:56:56] <phoe> make it configurable from the outside perhaps
[16:57:38] <phoe> let the user pass a dynavar that specifies the behavior: always copy an array/prevent all side effects, versus copy only when necessary due to array specializations, versus never copy and signal an error instead
[16:57:43] <phoe> s/pass/rebind/
[16:58:15] <phantomics> I could just warn users "don't count on April destructively changing arrays unless you know your array's type and exactly how assignment works, otherwise pass the value back out of April explicitly"
[16:58:46] <sm2n> I don't think a dynavar is a good idea
[16:59:07] <sm2n> because then you can't rely on a default
[16:59:11] <phoe> I mean, I think I can find use cases for the two "extreme" behaviors here - one is extreme side effect avoidance, useful for functional programming, one is extreme performance and a situation where the user *wants* to be notified of type errors because they want to fix them
[16:59:30] <phoe> sm2n: why not? make the dynavar have a default value, e.g. the current April behavior
[16:59:35] <phantomics> A more simple "configuration" would just be for users to use alexandria's copy-array on anything they want to pass in with no possible side effects
[17:00:44] <phantomics> I can't have type errors, APL is typeless so adding type errors would require extensive rethinking of the entire language, k is typed and has many lexical features dedicated to managing those types in contrast to APL
[17:00:44] <sm2n> Consider the case where you are using April and you have a library using April, every invocation in the library will have to rebind the config var if it relies on that behavior being consistent, because you could change it globally
[17:01:58] <phantomics> sm2n: correct, the dynvar approach has portability pitfalls
[17:02:45] <phoe> yep, I see
[17:03:06] <phoe> an explicit copy-array would then work I guess
[17:03:21] <sm2n> Yeah, I think that makes sense
[17:05:03] *** Joins: s-liao (~s-liao@101.86.96.21)
[17:05:50] <phantomics> That sounds reasonable, I'll just add a bit of documentation basically warning "If you assign values to an array passed into April from outside, make sure you know what you're doing as it may or may not have side effects."
[17:09:30] <phoe> "april is allowed to be destructive on the arrays it receives"
[17:09:51] <phoe> not unlike CL:SORT and friends
[17:25:34] *** Joins: morganw (~user@80.225.24.132)
[17:26:22] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[17:31:31] *** Quits: bonmlp (~user@dsl-141-182.bl26.telepac.pt) (Ping timeout: 256 seconds)
[17:33:38] *** Quits: gaqwas (~john@dynamic-095-117-092-244.95.117.pool.telefonica.de) (Remote host closed the connection)
[17:38:42] *** Joins: nij- (~jin@2001:48f8:9021:806::9e0b)
[17:39:13] *** Joins: lispy (~lispy3@84.69.59.93)
[17:39:50] *** Quits: lispy (~lispy3@84.69.59.93) (Remote host closed the connection)
[17:41:50] *** Joins: lispy (~lispy3@84.69.59.93)
[17:43:32] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 240 seconds)
[17:46:04] *** Quits: shka (~herr@109.231.0.226) (Read error: Connection reset by peer)
[17:49:58] *** Joins: shka (~herr@109.231.0.226)
[17:50:10] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[17:52:14] *** Quits: lispy (~lispy3@84.69.59.93) (Remote host closed the connection)
[17:52:30] *** Joins: lispy (~lispy3@84.69.59.93)
[17:54:46] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 250 seconds)
[18:02:51] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Read error: Connection reset by peer)
[18:03:05] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[18:03:37] *** Quits: lispy (~lispy3@84.69.59.93) (Quit: Leaving)
[18:04:23] *** Joins: lisp123 (~lisp123@5.30.23.247)
[18:04:57] *** Quits: parjanya (~esb@177.33.154.179) (Ping timeout: 256 seconds)
[18:09:41] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[18:21:02] *** Quits: psf (~pi@206.55.172.18) (Ping timeout: 240 seconds)
[18:21:09] *** Joins: wmblathers (~wmblather@162-199-148-123.lightspeed.mdsnwi.sbcglobal.net)
[18:22:23] *** Quits: wmblathers (~wmblather@162-199-148-123.lightspeed.mdsnwi.sbcglobal.net) (Client Quit)
[18:22:54] *** Joins: psf (~pi@206.55.172.18)
[18:26:48] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[18:27:20] *** Joins: Algernon69 (~Algernon6@2a01:e0a:511:6ce0:4913:9722:255a:81e4)
[18:29:30] *** Joins: attila_lendvai_ (~alendvai@catv-176-63-13-198.catv.broadband.hu)
[18:29:41] *** Quits: attila_lendvai (~alendvai@2a02:ab88:3710:7c80:9130:5abf:96b3:dc0c) (Ping timeout: 268 seconds)
[18:32:33] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 276 seconds)
[18:33:20] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 250 seconds)
[18:38:05] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[18:46:20] *** Quits: Algernon69 (~Algernon6@2a01:e0a:511:6ce0:4913:9722:255a:81e4) (Ping timeout: 268 seconds)
[18:48:28] *** Joins: domovod (~domovod@176.196.122.197)
[18:52:44] *** Quits: epony (epony@user/epony) (Quit: QUIT)
[18:52:53] *** Joins: vats (~vats@103.216.143.56)
[18:56:26] *** Joins: lisp123 (~lisp123@45.86.201.13)
[18:57:05] *** Joins: dra (~dra@2a04:4540:6402:9000:d8f9:f30:9793:747d)
[18:57:09] <lisp123> pjb: Do you remember what your lambda list parser was called? Trying to find it now as its v. useful for macro writing
[18:57:11] *** Joins: Bike (~Bike@71.69.170.70)
[18:58:15] <phoe> lisp123: for what kind of lambda lists?
[18:58:30] <phoe> alexandria:parse-ordinary-lambda-list is for ordinary ones, can't say anything about others though
[18:58:56] <lisp123> phoe: Just being able to split (required &optional &rest etc.)
[18:59:03] <lisp123> Oh thanks, I'll check that out too
[19:03:14] *** Quits: nij- (~jin@2001:48f8:9021:806::9e0b) (Ping timeout: 250 seconds)
[19:05:35] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Ping timeout: 256 seconds)
[19:06:25] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[19:14:08] *** Joins: kevingal (~quassel@176.61.88.240)
[19:14:37] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[19:20:08] *** Quits: mixfix41 (~homefame@user/mixfix41) (Ping timeout: 250 seconds)
[19:23:05] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[19:24:28] *** Joins: Algernon69 (~Algernon6@2a01:e0a:511:6ce0:4913:9722:255a:81e4)
[19:24:52] *** Joins: epony (epony@user/epony)
[19:24:54] *** Joins: Algernon91 (~Algernon6@2a04:cec0:10ea:da13:e1ef:bc39:bc07:40cb)
[19:29:30] *** Quits: Algernon69 (~Algernon6@2a01:e0a:511:6ce0:4913:9722:255a:81e4) (Ping timeout: 268 seconds)
[19:30:50] <jmercouris> lisp123: I think it is cesareum or something
[19:31:02] <jmercouris> The string isn’t coming to mind exactly
[19:31:03] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 276 seconds)
[19:31:19] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[19:31:19] <lisp123> jmercouris: Thanks! Yeah that must be it
[19:31:21] *** Quits: kevingal (~quassel@176.61.88.240) (Ping timeout: 268 seconds)
[19:31:37] <jmercouris> lisp123: if you want an example, we use Alexandria in the Nyxt codebase to split lambda lists
[19:31:58] <lisp123> jmercouris: Nice one, I will check it out
[19:32:58] <jmercouris> https://github.com/atlas-engineer/nyxt/blob/master/source/command-commands.lisp
[19:34:15] <lisp123> jmercouris: Thanks
[19:39:14] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[19:46:39] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[19:51:01] *** Joins: lisp123_ (~lisp123@5.30.23.247)
[19:51:07] *** Quits: lisp123_ (~lisp123@5.30.23.247) (Read error: Connection reset by peer)
[19:55:05] *** Quits: lisp123 (~lisp123@45.86.201.13) (Ping timeout: 256 seconds)
[19:58:23] *** Joins: nij- (~jin@2001-48F8-9021-806-0-0-0-9E0B-dynamic.midco.net)
[19:59:06] *** Quits: Jing (~hedgehog@240e:390:7c53:a7e1:c16c:1790:8bf6:b4b5) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[20:01:17] <pjb> lisp123w: com.informatimago.common-lisp.lisp-sexp.source-form:parse-lambda-list
[20:01:35] <pjb> it's easy: just load com.informatimago in your rc file, and then you can (apropos "whatever").
[20:02:37] *** Joins: mixfix41 (~homefame@user/mixfix41)
[20:10:51] *** Joins: igemnace (~ian@user/igemnace)
[20:10:58] *** Joins: wmblathers (~wmblather@162-199-148-123.lightspeed.mdsnwi.sbcglobal.net)
[20:12:08] *** Quits: aartaka (aartaka@gateway/vpn/protonvpn/aartaka) (Ping timeout: 250 seconds)
[20:13:23] *** Joins: aartaka (aartaka@gateway/vpn/protonvpn/aartaka)
[20:14:21] *** Joins: parjanya (~esb@177.33.154.179)
[20:34:14] *** Parts: nij- (~jin@2001-48F8-9021-806-0-0-0-9E0B-dynamic.midco.net) (#commonlisp)
[20:46:01] *** Joins: Algernon666 (~Algernon6@2a04:cec0:10ee:d77c:e1ef:bc39:bc07:40cb)
[20:49:40] *** Quits: Algernon91 (~Algernon6@2a04:cec0:10ea:da13:e1ef:bc39:bc07:40cb) (Ping timeout: 268 seconds)
[20:53:37] *** Joins: nij- (~jin@2001:48f8:9021:806::6f8b)
[21:03:59] *** Quits: domovod (~domovod@176.196.122.197) (Quit: WeeChat 3.4)
[21:19:01] *** Joins: Algernon91 (~Algernon6@2a01:e0a:511:6ce0:e50a:3c55:78b4:a27d)
[21:23:35] *** Quits: Algernon666 (~Algernon6@2a04:cec0:10ee:d77c:e1ef:bc39:bc07:40cb) (Ping timeout: 268 seconds)
[21:27:06] *** Quits: nij- (~jin@2001:48f8:9021:806::6f8b) (Ping timeout: 250 seconds)
[21:45:20] *** Quits: rogersm (~rogersm@90.166.180.250) (Quit: Leaving...)
[21:49:31] *** Joins: lispy (~lispy3@84.69.59.93)
[21:50:59] *** Quits: d4ryus (~d4ryus@ppp-188-174-84-16.dynamic.mnet-online.de) (Quit: WeeChat 3.4)
[21:52:36] *** Quits: vats (~vats@103.216.143.56) (Remote host closed the connection)
[21:52:53] *** Quits: Algernon91 (~Algernon6@2a01:e0a:511:6ce0:e50a:3c55:78b4:a27d) (Read error: Connection reset by peer)
[21:53:15] *** Joins: Algernon91 (~Algernon6@2a01:e0a:511:6ce0:e50a:3c55:78b4:a27d)
[21:54:08] *** Joins: d4ryus (~d4ryus@ppp-188-174-84-16.dynamic.mnet-online.de)
[21:55:35] *** Joins: kevingal (~quassel@176.61.88.240)
[21:57:37] *** Quits: varjag (~user@ti0040a400-5479.bb.online.no) (Ping timeout: 240 seconds)
[21:58:03] *** Joins: treflip (~user@user/treflip)
[22:09:08] *** Quits: mixfix41 (~homefame@user/mixfix41) (Ping timeout: 250 seconds)
[22:13:47] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Remote host closed the connection)
[22:13:50] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[22:14:13] *** Joins: kevingal_ (~quassel@176.61.88.240)
[22:16:40] *** Quits: lispy (~lispy3@84.69.59.93) (Quit: Leaving)
[22:17:18] *** Joins: lispy (~lispy3@84.69.59.93)
[22:18:10] *** Joins: rogersm (~rogersm@90.166.180.250)
[22:20:24] *** Quits: myrrh (~markus@user/poet) (Ping timeout: 250 seconds)
[22:22:03] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Remote host closed the connection)
[22:22:17] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[22:24:30] *** Joins: mixfix41 (~homefame@user/mixfix41)
[22:24:48] *** Joins: varjag (~user@ti0040a400-5479.bb.online.no)
[22:27:46] *** Quits: amb007 (~a_bakic@102.215.76.86.rev.sfr.net) (Ping timeout: 250 seconds)
[22:28:07] *** Joins: amb007 (~a_bakic@107.196.204.77.rev.sfr.net)
[22:34:46] *** Quits: ChanServ (ChanServ@services.libera.chat) (shutting down)
[22:34:59] *** Quits: treflip (~user@user/treflip) (Quit: good night)
[22:35:18] *** Joins: ChanServ (ChanServ@services.libera.chat)
[22:35:18] *** erbium.libera.chat sets mode: +o ChanServ
[22:37:53] *** Quits: lispy (~lispy3@84.69.59.93) (Quit: Leaving)
[22:41:35] *** Joins: lispy (~lispy3@84.69.59.93)
[22:53:57] *** Quits: aartaka (aartaka@gateway/vpn/protonvpn/aartaka) (Ping timeout: 240 seconds)
[22:57:25] *** Joins: Algernon666 (~Algernon6@2a04:cec0:10ae:adc1:b444:577f:22e3:730a)
[22:58:17] *** Quits: Devon (~devon@c-24-2-157-5.hsd1.ma.comcast.net) (Ping timeout: 240 seconds)
[23:01:38] *** Quits: Algernon91 (~Algernon6@2a01:e0a:511:6ce0:e50a:3c55:78b4:a27d) (Ping timeout: 268 seconds)
[23:01:51] *** Quits: lispy (~lispy3@84.69.59.93) (Quit: Leaving)
[23:03:00] *** Quits: wheelsucker (~user@2600:8801:8c24:d000::8e14) (Read error: Connection reset by peer)
[23:03:16] *** Joins: wheelsucker (~user@2600:8801:8c24:d000::8e14)
[23:22:41] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Remote host closed the connection)
[23:25:34] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[23:31:10] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[23:33:19] *** Quits: dra (~dra@2a04:4540:6402:9000:d8f9:f30:9793:747d) (Remote host closed the connection)
[23:37:09] *** Joins: xaltsc (~xaltsc@user/xaltsc)
[23:38:09] *** Quits: amb007 (~a_bakic@107.196.204.77.rev.sfr.net) (Ping timeout: 256 seconds)
[23:38:23] *** Joins: amb007 (~a_bakic@34.144.204.77.rev.sfr.net)
[23:42:37] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Remote host closed the connection)
[23:42:37] *** Joins: masinter (~masinter@c-73-158-116-21.hsd1.ca.comcast.net)
[23:42:44] *** Parts: masinter (~masinter@c-73-158-116-21.hsd1.ca.comcast.net) ()
[23:44:12] *** Quits: rain3 (~rain3___@5-12-7-240.residential.rdsnet.ro) (Remote host closed the connection)
[23:44:31] *** Joins: rain3 (~rain3___@2a02:2f09:d113:6d00:6f23:fba2:d834:1a7)
[23:44:48] *** Quits: Algernon666 (~Algernon6@2a04:cec0:10ae:adc1:b444:577f:22e3:730a) (Ping timeout: 268 seconds)
[23:46:36] *** Quits: rogersm (~rogersm@90.166.180.250) (Quit: Leaving...)
[23:51:37] *** attila_lendvai_ is now known as attila_lendvai
[23:56:01] *** Joins: huckleberry (~huckleber@2603-8000-4102-9b00-6ddf-6d6a-f05d-0f18.res6.spectrum.com)
[23:59:13] <huckleberry> I've been using closures as pseudo-streams (basically generators) in a lot of projects instead of separate state objects. I haven't really noticed an issue with speed but should I be doing that or should I be using separate state objects i.e. gray streams?
[23:59:21] *** Joins: Masinterlisp (~masinter@c-73-158-116-21.hsd1.ca.comcast.net)
