[00:03:32] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 252 seconds)
[00:04:38] *** Quits: rgrinberg (~textual@187.223.75.25) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[00:05:37] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[01:40:13] *** Joins: rgrinberg (~textual@2806:265:5401:9431:d03e:a2ca:3d77:ef5f)
[02:20:25] *** Quits: rgrinberg (~textual@2806:265:5401:9431:d03e:a2ca:3d77:ef5f) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[02:29:28] *** Joins: rgrinberg (~textual@2806:101e:7:def:8ca4:21b9:b555:2338)
[02:30:27] *** Quits: rgrinberg (~textual@2806:101e:7:def:8ca4:21b9:b555:2338) (Client Quit)
[02:50:02] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 268 seconds)
[02:51:03] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[03:17:59] *** Joins: rgrinberg (~textual@2806:101e:7:def:8ca4:21b9:b555:2338)
[03:20:48] *** Quits: rgrinberg (~textual@2806:101e:7:def:8ca4:21b9:b555:2338) (Client Quit)
[03:36:22] *** Joins: rgrinberg (~textual@2806:101e:7:def:8ca4:21b9:b555:2338)
[03:44:17] *** Quits: rgrinberg (~textual@2806:101e:7:def:8ca4:21b9:b555:2338) (Ping timeout: 268 seconds)
[04:05:15] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 268 seconds)
[04:06:39] *** Joins: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se)
[04:32:47] *** Joins: rgrinberg (~textual@2806:101e:7:def:f99c:f095:57cb:e173)
[04:42:05] *** Joins: yauhsien (~yauhsien@118-167-42-25.dynamic-ip.hinet.net)
[04:46:47] *** Quits: yauhsien (~yauhsien@118-167-42-25.dynamic-ip.hinet.net) (Ping timeout: 256 seconds)
[04:50:11] *** Quits: rgrinberg (~textual@2806:101e:7:def:f99c:f095:57cb:e173) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[05:22:10] *** Joins: Lycurgus (~juan@98.4.112.204)
[05:41:58] *** Quits: Lycurgus (~juan@98.4.112.204) (Quit: Exeunt)
[06:07:15] *** Quits: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se) (Ping timeout: 256 seconds)
[06:13:54] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[06:25:05] *** Quits: millido (~millido@84.210.150.128) (Quit: ZNC 1.8.2 - https://znc.in)
[06:38:43] *** Joins: millido (~millido@84.210.150.128)
[06:42:34] *** Joins: yauhsien (~yauhsien@118-167-42-25.dynamic-ip.hinet.net)
[07:13:37] *** Joins: rgrinberg (~textual@2806:265:5401:9431:e42d:e292:4d35:3f96)
[07:17:49] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 240 seconds)
[07:20:17] <ns12> krl: Did Symbolics Prolog actually have Prolog syntax, or was it a "Prolog" with Lisp syntax?
[07:23:09] <ns12> In "Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp" by Peter Norvig, section 12.10 ""Real" Prolog": "Other Prolog implementations using Lisp syntax include micro-Prolog, Symbolics Prolog, and LMI Prolog".
[07:45:37] *** Quits: yauhsien (~yauhsien@118-167-42-25.dynamic-ip.hinet.net) (Ping timeout: 240 seconds)
[09:16:55] <White_Flame> sounds like you have your answer from the quote?
[09:17:50] <White_Flame> I'm not sure about their prolog but they had a decent integration of a bunch of tools together, both symbolics-provided and 3rd party
[09:37:41] *** Quits: jealousmonk (~user@2804:431:e7c5:c99:3fd5:26ae:534:3723) (Quit: ERC (IRC client for Emacs 27.1))
[10:09:55] *** Quits: rgrinberg (~textual@2806:265:5401:9431:e42d:e292:4d35:3f96) (Read error: Connection reset by peer)
[10:11:12] *** Joins: rgrinberg (~textual@2806:265:5401:9431:e42d:e292:4d35:3f96)
[10:35:00] *** Quits: skapata (~Skapata@user/skapata) (Remote host closed the connection)
[10:43:11] <dmiles[m]> I wonder if a SBCL impleented prolog can be more performant than SWI-Prolog 
[10:43:19] <dmiles[m]> s/impleented/implemented/
[10:43:43] *** Joins: yauhsien (~yauhsien@118-167-42-25.dynamic-ip.hinet.net)
[10:48:13] *** Quits: yauhsien (~yauhsien@118-167-42-25.dynamic-ip.hinet.net) (Ping timeout: 240 seconds)
[11:32:36] *** Quits: PrologMUD (~PrologMUD@c-98-232-203-68.hsd1.wa.comcast.net) (Read error: Connection reset by peer)
[11:32:36] *** PrologMUD_7584 is now known as PrologMUD
[11:33:37] *** Quits: [relay]_ (~logicmoo@c-98-232-203-68.hsd1.wa.comcast.net) (Ping timeout: 240 seconds)
[11:41:45] *** Joins: PrologMUD_8057 (~PrologMUD@c-98-232-203-68.hsd1.wa.comcast.net)
[12:30:10] *** Quits: ttmrichter-M (~ttmrichte@user/ttmrichter) (Quit: You have been kicked for being idle)
[12:44:46] *** Joins: Tcl3r (~tcz@91.150.178.124)
[13:50:28] *** Quits: econo (uid147250@user/econo) (Quit: Connection closed for inactivity)
[13:54:32] *** Quits: rgrinberg (~textual@2806:265:5401:9431:e42d:e292:4d35:3f96) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[13:56:28] <ns12> White_Flame: But I don't know if Symbolics Prolog supported two kinds of syntax: Prolog-like and Lisp-like. Do you know?
[13:56:29] *** Joins: Lycurgus (~juan@98.4.112.204)
[14:12:07] <krl> Lycurgus: Tell us more about the Symbolics Prolog machine ^^
[14:13:07] <Lycurgus> I have been using genera 8 over the last week or so to get to some code and then decided to see if there was prolog support
[14:13:51] <Lycurgus> which is when I (re)encountered the stuff about the specific model that had prolog microcoding
[14:18:16] *** Tcl3r is now known as TCZ
[14:18:24] <krl> Which model was that?
[14:19:14] *** Quits: TCZ (~tcz@91.150.178.124) (Quit: Leaving)
[14:20:38] <Lycurgus> 35xx i think, should be a short search, that's how I ran into it
[14:21:00] <Lycurgus> some retro site/page
[14:21:36] <Lycurgus> krl, your queries have a mechanical sound
[14:22:15] <krl> Lycurgus: Am I accused for being a bot?
[14:23:13] <Lycurgus> no, the reference to comment I make a day or two ago makes that unlikely
[14:23:21] <Lycurgus> *made
[14:24:17] <Lycurgus> as does for that matter correctly parsing my observation
[14:24:43] <krl> I don't quite follow
[14:25:25] *** Joins: [relay]_ (~logicmoo@c-98-232-203-68.hsd1.wa.comcast.net)
[14:26:00] <Lycurgus> well Alice or the like could have formed your second to last comment in response to the observation I addressed to you but an actual NLP parse 
[14:26:20] <Lycurgus> would have been unlikely 
[14:39:28] *** Quits: Lycurgus (~juan@98.4.112.204) (Quit: Exeunt)
[17:57:55] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[18:10:16] *** Joins: skapata (~Skapata@2804:14c:87b0:a6f9:dd0e:2e16:85db:1081)
[18:10:16] *** Quits: skapata (~Skapata@2804:14c:87b0:a6f9:dd0e:2e16:85db:1081) (Changing host)
[18:10:16] *** Joins: skapata (~Skapata@user/skapata)
[19:53:23] *** Joins: Lycurgus (~juan@98.4.112.204)
[19:56:19] <White_Flame> dmiles[m]: I say yes, and in fact I've gotten thousands of times faster than SWI.  however, I had intentionally changed the model away from stock prolog to increase expressiveness and allow the machine to reorder things and optimize it more
[19:56:55] <White_Flame> plus, it's far easier to native code compile stuff in Lisp at runtime, say at inference assertion time you can fully compile it
[19:57:33] <White_Flame> but yeah, a Lisp implementation of WAM is going to have more low-level overhead than a C based one, because C takes advantage of raw pointers to index through the heaps and things
[20:08:29] <dmiles[m]> in your forward chaining system.. how far do you go with showing proofs?
[20:09:28] <White_Flame> we keep history, so you can browse & query in older versions about what was true then
[20:09:35] <dmiles[m]> erm retaining the data structure to be able to undo etc
[20:09:51] <White_Flame> the KB itself is a persistent data structure
[20:11:41] <dmiles[m]> i know it's faster than PFC.. wondewring if it has all the funcrtionality
[20:12:00] <White_Flame> oh, you don't mean GTS, you mean LFC
[20:12:04] <dmiles[m]> s/wondewring/wondering/, s/funcrtionality/functionality.. then again not sure i ever documented enouygh of the functionaity/
[20:12:13] <White_Flame> yeah, that is a pretty raw FC compiler
[20:12:17] <dmiles[m]> meant GTS
[20:12:29] <White_Flame> ah, yeah that's the fully persistent one
[20:12:40] <dmiles[m]> oh yeah i guess i meant LFC
[20:12:44] <White_Flame> heh
[20:13:18] <dmiles[m]> really either .. sinc esecretly my prolog code is all PFC code if i did itr correctly
[20:13:21] <White_Flame> LFC also does no pattern matching on fields (yet).  It's basically a proof of concept
[20:14:04] <dmiles[m]> PFC is able to emulat prolog enough that if i only had PFC io sould still write logicmoo
[20:14:22] <White_Flame> a "query" clause in LFC boils down to just a single hashtable lookup with a composite key
[20:15:09] <dmiles[m]> the "proof" of that query. the trace woudl be all that went into getting it forward chained
[20:15:31] <dmiles[m]> would be the trace
[20:15:44] <White_Flame> yeah, my trace would be degenerately simple
[20:16:11] *** Joins: bkhl (~bkhl@user/bkhl)
[20:16:13] <dmiles[m]> due to the fact that the pattern match is so simple?
[20:17:34] <White_Flame> yeah, I can basically post the Lisp that the FC compiles down to
[20:19:08] <White_Flame> if you have a(1,X),b(2,X) => c(X), then it generates 4 lisp bodies, which gets compiled into assert a/2, assert b/2, retract a/2, retract b/2 handlers
[20:19:23] <White_Flame> which directly lookup the other clauses and call the unified consequent handler function
[20:19:34] <White_Flame> it's very fast
[20:20:08] <White_Flame> of course, the consequent body could call the Lisp asset c/1 function, too, which can chain things
[20:20:14] <White_Flame> *assert
[20:21:05] <White_Flame> there's no unifier, no backtracking (but big compiled IF trees which do hop around), and no bytecode
[20:21:29] <White_Flame> and it can do everything that ops/clips/etc basically do
[20:21:35] <White_Flame> and more
[20:21:42] <dmiles[m]> so i assert a(1,3), b(2,3)  and ask why c(3) is true i get teh afsts and rule?
[20:21:56] <White_Flame> no
[20:22:01] <dmiles[m]> s/so i assert a(1,3), b(2,3)  and ask why c(3) is true i get teh afsts and rule?/so i assert a(1,3), b(2,3)  and ask why c(3) is true i get the 2 facts and rule?/
[20:22:14] <White_Flame> there's no explanation functionality in there
[20:22:26] <White_Flame> again, it's a proof of concept of the ability to compile it down that way
[20:22:37] <dmiles[m]> gotcha
[20:23:45] *** Quits: bkhl[m] (~bkhl@user/bkhl) (Quit: issued !quit command)
[20:24:53] <dmiles[m]> everytime though dream of switching away from prolgo or swi.. i realize i lose swish and other googies
[20:25:27] <dmiles[m]> s/everytime though dream of switching away from prolgo or swi.. i realize i lose swish and other googies/every time though dream of switching away from prolog or swi.. i realize i lose swish and other goodies/
[20:25:52] <White_Flame> yeah, tooling & debugging/introspection are valuable and long to develop & mature
[20:27:11] <White_Flame> but, those can also be golden handcuffs that keeps people from advancing into currently non-supported tech
[20:31:09] <dmiles[m]> the developer bottleneck in logicmoo i suppose is not based on it being in prolog
[20:31:26] <dmiles[m]> but writing the code myself in logicmoo i have a very well planned out 15 years
[20:31:34] <dmiles[m]> hehe
[20:32:59] <White_Flame> IMO, it's a documentation issue ;)
[20:34:08] <dmiles[m]> i might start by documenting in files the code that has to be written
[20:34:33] <dmiles[m]> rather than expecting peopel to read the documation for the existing code
[20:35:07] <dmiles[m]> rather than just documenting the existing code*
[20:37:32] <dmiles[m]> dmiles[m]: not that it is very funny but i can imagine it might take me 6 months to write that
[20:38:09] <White_Flame> and it's not just documenting the code, but documenting the system, organization, and data
[20:38:41] <White_Flame> that will give much better context to learning a project, than trying to build it up from the low level bits
[20:45:38] *** Quits: Lycurgus (~juan@98.4.112.204) (Quit: Exeunt)
[20:49:39] <White_Flame> dmiles[m]: when you do explanations, do you just dump the entire derivation or have some forms of simplifying nuance?
[20:50:12] <White_Flame> with FC systems, TMS chains can be very long, and non-TMS effects have long derivations over many rule firings
[20:51:26] <[relay]_> <dmiles> it prints into a bulleted tree
[20:51:48] <[relay]_> <dmiles> i ut it off at a certain level
[20:51:53] <[relay]_> <dmiles> cut*
[20:53:19] <[relay]_> <dmiles> that is 5 deep .. 5 wide etc
[20:53:41] <[relay]_> <dmiles> so it might display 25 proof nodes at first
[21:00:14] <[relay]_> <dmiles> dang my proof display is broken
[21:00:29] *** Joins: econo (uid147250@user/econo)
[21:00:43] <White_Flame> does it span non-monotonic rule firings?
[21:01:02] <[relay]_> <dmiles> yes.. it includes the rules that got involvoed
[21:01:39] <[relay]_> <dmiles> and the dynamic facts that .. so for example 5 deep was where a fact was involved that has it own one level of proof
[21:04:13] <[relay]_> <dmiles> https://cdn.discordapp.com/attachments/757420054089564203/926166297941786684/unknown.png
[21:05:57] <White_Flame> yeah, a pure dump of "facts" can be hard to winnow down into what's meaningful for the questino
[21:06:23] <[relay]_> <dmiles> things like 2.2 was a rule
[21:06:41] <[relay]_> <dmiles> 2.5 etc
[21:06:43] <White_Flame> some basis for determining what justifications are most recent, or "unique" (vs things that are commonly true) would be desirable
[21:06:44] *** Quits: Leone (~Leo@157.52.18.77) (Read error: Connection reset by peer)
[21:07:09] <White_Flame> for determining which unexpected chain of events led to an unexpected rule firing, for instance
[21:07:43] <[relay]_> <dmiles> for each rule i track how many children it has
[21:08:35] <[relay]_> <dmiles> need a UI written though that lets me/users decide to "show/hide" certain rules
[21:08:42] <White_Flame> yeah, I know
[21:08:53] <White_Flame> I hit those sorts of UI complexity issues often :-P
[21:09:11] <[relay]_> <dmiles> since it would be better to let that adapt from teh UI .. though i can often guess
[21:09:19] <White_Flame> the "big dump of everything" text console view can sink a ton of time in terms of finding related things
[21:10:08] <White_Flame> and then there's contextual stuff like "This justification branch does not interest me in this specific problem, ignore it temporarily"
[21:10:16] <White_Flame> across multiple justification reports
[21:11:07] <[relay]_> <dmiles> nex ti want that when the user sees a file like in kmy image they can click on it and edit the file
[21:11:17] *** Joins: rgrinberg (~textual@187.223.75.25)
[21:12:05] <[relay]_> <dmiles> also annotate the show always can be done from the file
[21:12:25] <[relay]_> <dmiles> i mean i can let it become perminant from there if they want
[21:12:57] <[relay]_> <dmiles> or hide rules below this rule in proofs
[21:14:43] <[relay]_> <dmiles> in my image there those are actualyl 3 proofs as to why that one fact is true
[21:15:40] <[relay]_> <dmiles> and so you can say that proof 1 is not allowed merely on it own
[21:16:13] <[relay]_> <dmiles> that is for exmaple say we made 2.7 false.. that would make the 1st proof impossible
[21:17:16] <[relay]_> <dmiles> ` 2.7 tRegion(iOfficeRoom7)  % [prologmud/prolog/prologmud/mud_startup.pl:114]`
[21:17:52] <[relay]_> <dmiles> if that is forced false then   `localityOfObject(iCommanderdata66,iOfficeRoom7)` cant be true
[21:18:33] <White_Flame> what does isRuntime mean?
[21:18:42] <[relay]_> <dmiles> means hte game is running
[21:18:56] <[relay]_> <dmiles> this allows restarting
[21:19:09] <White_Flame> and that's sufficient justification for teh localityOfObject fact?
[21:19:29] <White_Flame> eg, 1.1 justifies the queried fact directly, and 1.2 justifies 1.1?
[21:19:33] <[relay]_> <dmiles> it starts the forward chaing process
[21:19:45] <[relay]_> <dmiles> oh.. that is cuz isRuntime was the thing that made that file load
[21:19:59] *** Joins: jealousmonk (~user@2804:431:e7c5:c99:3fd5:26ae:534:3723)
[21:20:02] <[relay]_> <dmiles> and it remembers the last salient cause
[21:20:20] <White_Flame> hmm, that seems like it should be deeper down in the chain like 3.6 is, not direct
[21:20:34] <[relay]_> <dmiles> it was a sdailent cause due ot it was sititng in the proof mechaism at the time that becvame true
[21:21:07] <White_Flame> eg, to me a naive reading seems like it's saying there's a isRuntime() => localityOfObject(icommanderdata66,iOfficeRoom7) assertion in the file
[21:21:11] <[relay]_> <dmiles> for anyhting becomiing true due to code.. it is looking for introspectbalbe reason
[21:21:59] <[relay]_> <dmiles> yeah.. that is true ...
[21:22:17] <White_Flame> oh, ok
[21:22:34] <[relay]_> <dmiles> it needed the step  isRuntime() , isLoadedAtRuntime)
[21:22:34] <White_Flame> so its some testing initialization fact?
[21:23:21] <[relay]_> <dmiles> yes
[21:23:47] <[relay]_> <dmiles> if you retract isRuntime(0 the file gets unloaded and as it unloads each fact gets retracted
[21:24:47] <[relay]_> <dmiles> i meight have actualy meraly repressed tha tin the proof output
[21:25:22] <[relay]_> <dmiles> sinc ei can have a file load for every rule even
[21:25:40] <[relay]_> <dmiles> though the fileload for every rule is not isRuntime()
[21:26:17] <[relay]_> <dmiles> it has    isLoadTime()  isFullyLoaded() isRuntime()
[21:27:05] <[relay]_> <dmiles> problaby need  isRuntimeFullyup()
[21:29:15] <[relay]_> <dmiles> ah line 307 `:- after_boot(start_runtime_mud).`
[21:29:52] <[relay]_> <dmiles> which is the current line SWI was seeign when isRuntime got asserted
[21:30:31] <[relay]_> <dmiles> which called  https://github.com/logicmoo/prologmud/blob/master/prolog/prologmud/mud_startup.pl#L288-L297
[21:32:11] <[relay]_> <dmiles> asserting `isLoaded(iWorldData8)` causes the preliminaries such as things that made the world to be in that state
[21:32:28] <[relay]_> <dmiles> that is the data is loaded
[21:32:42] <[relay]_> <dmiles> so some of my rules are backchained like in that case
[21:32:48] <[relay]_> <dmiles> vs isRuntime is all fwd
[21:33:33] <[relay]_> <dmiles> that is if someone asserts something that is supposed to be a foward rule i propagate the facts that would lead to that truth
[21:34:27] <[relay]_> <dmiles> just as someone forces that false (not just removes it) it can find a matrix of unasserts
[21:34:39] <[relay]_> <dmiles> that removesd that truth but doesnt affect other truths
[21:34:59] <White_Flame> the first half of that is basically caching BC results, or converting them into FC re-checks?
[21:35:52] <[relay]_> <dmiles> it converts them to fwds sinc ethat fact now has itself created those backward truths
[21:37:40] <[relay]_> <dmiles> for is you asserted `localityOfObject(iCommanderdata66,iOfficeRoom7)`   and  the ` tRegion(iOfficeRoom7) `  wwas previopusly untue..  it becomes true supported  by `localityOfObject(iCommanderdata66,iOfficeRoom7)`
[21:38:10] *** Quits: jealousmonk (~user@2804:431:e7c5:c99:3fd5:26ae:534:3723) (Remote host closed the connection)
[21:39:55] <[relay]_> <dmiles> though technically i could/should limit some of those to  `<==>`  and not  `==>`
[21:40:34] <[relay]_> <dmiles> i actually have arguments types usually deductive
[21:40:53] <White_Flame> hmm, but that means the type system is basically "closed world"
[21:41:07] <[relay]_> <dmiles> as in it has a rule that says arg2 of localityOfObject/2 is a tRegion
[21:41:16] <White_Flame> it seems like the type inference above might have uninentional consequences
[21:41:29] <White_Flame> ok, so if that's an actual type assertion, then it's fine
[21:41:52] <[relay]_> <dmiles> yeah there are lots of tyep assertional stuff i used inspoired by cyc
[21:43:34] <[relay]_> <dmiles> other cases it not jsut type assertions.. it can be things like the weigth of the backpack might inspired some character to have been stronger than possible
[21:43:56] <[relay]_> <dmiles> has we asserted lots of heavy items
[21:44:42] <[relay]_> <dmiles> the fun of the system is that such unintended things happen
[21:45:07] <[relay]_> <dmiles> that past history gets rewritten .. etc
[21:45:16] <White_Flame> as long as corrections can come through in the same way
[21:45:30] *** Joins: jealousmonk (~user@2804:431:e7c5:c99:3fd5:26ae:534:3723)
[21:45:46] <[relay]_> <dmiles> yeah they have to pass thru the TMS
[21:45:56] <[relay]_> <dmiles> i mean pass in thru the same APIs
[21:47:13] <[relay]_> <dmiles> i realize, not that i did much on this front yet, is actualyl makeing the Event Calc part of this system
[21:47:59] <[relay]_> <dmiles> curretly its all SitCalc
[21:49:18] <[relay]_> <dmiles> so that   holdingInfomation(iDmiles,iSomeData8)  .. runs thru the steps of obstaiing the data
[21:49:30] <[relay]_> <dmiles> i wrote the cod ethat does that jsut not hooked it up
[21:50:40] <[relay]_> <dmiles> oops i have to take a cat in for deworming and shots.. i'll be arround for <@&813840064529432616> 3.66 hours
[21:51:32] <[relay]_> <dmiles> (2pm PST)
[22:21:47] *** Joins: yauhsien (~yauhsien@118-167-42-25.dynamic-ip.hinet.net)
[22:27:35] *** Quits: yauhsien (~yauhsien@118-167-42-25.dynamic-ip.hinet.net) (Ping timeout: 256 seconds)
[22:56:20] *** Quits: rgrinberg (~textual@187.223.75.25) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[23:10:14] *** Joins: yauhsien (~yauhsien@118-167-42-25.dynamic-ip.hinet.net)
[23:15:02] *** Quits: yauhsien (~yauhsien@118-167-42-25.dynamic-ip.hinet.net) (Ping timeout: 240 seconds)
[23:24:13] *** Joins: yauhsien (~yauhsien@118-167-42-25.dynamic-ip.hinet.net)
[23:48:39] *** Quits: yauhsien (~yauhsien@118-167-42-25.dynamic-ip.hinet.net) (Remote host closed the connection)
[23:49:29] *** Joins: yauhsien (~yauhsien@118-167-42-25.dynamic-ip.hinet.net)
[23:54:49] *** Quits: yauhsien (~yauhsien@118-167-42-25.dynamic-ip.hinet.net) (Ping timeout: 268 seconds)
