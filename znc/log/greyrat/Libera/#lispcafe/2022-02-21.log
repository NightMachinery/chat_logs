[00:05:38] *** Quits: mcoll (1cd8fbb055@2604:bf00:561:2000::160) (Ping timeout: 250 seconds)
[00:06:04] *** Quits: axvr (757f658d76@2604:bf00:561:2000::e1) (Ping timeout: 250 seconds)
[00:06:27] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[00:06:47] *** Joins: axvr (757f658d76@2604:bf00:561:2000::e1)
[00:07:22] *** Joins: mcoll (1cd8fbb055@2604:bf00:561:2000::160)
[00:15:35] *** Quits: shka (~herr@109.231.3.55) (Ping timeout: 256 seconds)
[00:19:04] *** Quits: payphone (dd09ba4109@2604:bf00:561:2000::20b) (Ping timeout: 250 seconds)
[00:19:53] *** Joins: payphone (dd09ba4109@2604:bf00:561:2000::20b)
[00:24:06] *** Joins: szkl (uid110435@id-110435.uxbridge.irccloud.com)
[00:44:26] *** Quits: kevingal (~quassel@2a02:8084:4140:f300:ec08:9ba4:bce:4350) (Ping timeout: 252 seconds)
[00:48:50] *** Joins: kevingal (~quassel@2a02:8084:4140:f300:a80d:ed30:9b2a:ad8a)
[00:56:54] *** Quits: kevingal (~quassel@2a02:8084:4140:f300:a80d:ed30:9b2a:ad8a) (Ping timeout: 260 seconds)
[01:07:49] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[01:09:58] *** Joins: parjanya (~esb@2804:14c:1ad:9351:a9f4:2cf3:2d0f:3397)
[01:10:57] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[01:14:13] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Quit: brb restarting to graphics test.)
[01:19:39] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[01:19:48] *** Joins: dra (~dra@2a04:4540:641c:6c00:74d9:8d1:b2db:e527)
[01:19:50] <dra> Hello!
[01:22:00] <selwyn> hi
[01:48:15] *** Quits: dra (~dra@2a04:4540:641c:6c00:74d9:8d1:b2db:e527) (Quit: Leaving)
[02:35:00] *** Quits: eugercek (~user@user/eugercek) (Ping timeout: 240 seconds)
[02:39:05] *** Quits: cosimone (~user@93-34-133-75.ip49.fastwebnet.it) (Quit: ERC (IRC client for Emacs 27.1))
[02:55:00] *** Joins: atw (~user@ool-18bf5678.dyn.optonline.net)
[03:34:31] <kakuhen> using people's self-hosted gitea instances is also good
[03:35:00] <kakuhen> the only issue i guess is it obscures your projects since most ppl will only search for github and gitlab
[03:57:32] *** Joins: vms14 (~user@29.red-79-153-202.dynamicip.rima-tde.net)
[04:42:12] *** Quits: random-nick (~random-ni@87.116.179.129) (Ping timeout: 240 seconds)
[05:35:55] <hayley> "[snip] is about to release smart contracts on cosmos SDK + hardenedJS opening the floodgates to the world of JS developers"
[05:35:56] <hayley> AAAAAAAAaaaaaaaaa
[05:37:59] <hayley> Come on, no one can even get smart contracts right, even with languages designed for this crap.
[05:42:55] *** Quits: Rue (~rue@2001-b011-1000-1496-cf3a-2116-83d3-2a18.dynamic-ip6.hinet.net) (Quit: WeeChat 3.4)
[05:43:17] *** Joins: Rue (~rue@2001-b011-1000-1496-cf3a-2116-83d3-2a18.dynamic-ip6.hinet.net)
[06:02:53] <hayley> Apparently you cannot use break or continue or goto in C++ classes at this university. lol
[06:05:05] <moon-child> ... ehh?
[06:05:30] * hayley uploaded an image: (29KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/htvkvXlrKSelWGKGFjuZAuWu/this-thing.png >
[06:05:35] <hayley> Well, continue is fine, but continute is not.
[06:05:53] <hayley> But cpp can work here. #define br bre ## ak
[06:06:41] <moon-child> hmm c++ has crappy closures, right?
[06:06:43] <moon-child> cps time!
[06:06:58] * hayley puts moon-child on the MTA
[06:07:29] <hayley> Alternately, use tail recursion for goto and exceptions for control flow.
[06:08:07] <moon-child> oh, exceptions are fine, but goto is not?
[06:08:09] <moon-child> lol
[06:08:21] <hayley> Seems so.
[06:09:06] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 260 seconds)
[06:15:25] * hayley watches intro to algorithms class
[06:16:08] <hayley> "Just imagine how cool it is to have a chat with your team mates about a problem, an algorithm to solve it, and evaluate the running time without having written down a single line of code"
[06:18:32] <hayley> https://www.youtube.com/watch?v=tG9lf_f74K8
[06:18:33] -ixelp- Thela Hun Ginjeet - King Crimson (8-Bit) - YouTube
[06:24:22] *** Joins: notzmv (~zmv@user/notzmv)
[06:43:20] <vms14> hayley: how is your job seeking journey?
[06:43:30] <hayley> vms14: Nothing yet.
[06:44:34] <vms14> did you: write the ugly cv and the shiny one, learnt django, make your website, cried to some recruiters for advice, shitpost in linkedin...
[06:45:26] <vms14> will you focus on python?
[06:45:52] <vms14> I don't see what other options you have for a way to get a programming job fast
[06:46:09] <vms14> considering you really want a programming job and not another tech related one
[06:46:30] <vms14> for me are those mainstream languages
[06:46:41] <vms14> which aren't an option btw
[06:47:26] <kakuhen> that reminds me i am messing with react & typescript stuff precisely to attempt getting some "quick" job that is at least one step above flipping burgers for the time being
[06:47:41] <vms14> i'm not interested in java, python, php, js, or alike
[06:47:46] <kakuhen> in one sitting i finished a toy rss daemon for tranmission
[06:47:53] <vms14> react can give you a job
[06:47:57] <kakuhen> but granted most of it was 'npm install solution' and figure out how to use the libraries
[06:48:06] <kakuhen> and then learning how to use async/await
[06:48:20] <vms14> specially if you go js fullstack
[06:48:28] <hayley> https://www.youtube.com/watch?v=6dBt3mJtgJc
[06:48:29] -ixelp- Joy Division - Transmission [OFFICIAL MUSIC VIDEO] - YouTube
[06:48:32] <kakuhen> have to say i like the syntactical sugar that js has for async stuff
[06:48:41] <kakuhen> back when I was messing with Core Audio, the callback functions were always ugly and repetitive
[06:48:51] <kakuhen> and there isn't a good way to "abstract" them since you're writing in pure C
[06:48:59] <vms14> kakuhen: async is always nice to have
[06:49:09] <vms14> specially when it's somethin "native"
[06:49:21] <vms14> js was forced to be async
[06:49:33] <kakuhen> yeah, because the control flow of web apps is not always "well-defined," so to speak
[06:49:42] <kakuhen> and js was kinda forced to evolve into a langauge for that kind of application
[06:49:58] <vms14> it cannot block the main thread
[06:50:11] <vms14> if it does the browser blocks
[06:50:26] <vms14> which is really a bad design of the browser 
[06:50:48] <kakuhen> also regarding python & django
[06:50:57] <hayley> lol no green threads
[06:51:01] <kakuhen> i think ill try it out because of how much i enjoy djula
[06:51:11] <kakuhen> with that said, cl-who is more powerful than djula will ever be
[06:51:15] <kakuhen> but the syntax is an acquired taste for me...
[06:51:17] <vms14> which reminds me people prefer to work with the road to make it able for a squared shaped wheel to move instead of reinventing the wheel
[06:51:49] <vms14> square*
[06:51:56] <kakuhen> cl-who is very close to how you'd create HTML elements with clojurescript, and i dont really like it tbh... i personally like the pseudo-XML syntax of HTML for templating, but at the same time, it does limit what you can do for making templates
[06:51:59] <vms14> squirtle
[06:52:21] <vms14> I always wanted to name the square function squirtle
[06:52:55] <vms14> (squirtle 3)
[06:53:27] <vms14> kakuhen: lisp will be always more powerful than X
[06:53:38] <kakuhen> well yes that's a given
[06:53:48] <kakuhen> i also really like s-expressions as syntax, but for some reason I just can't get myself to template HTML with cl-who
[06:53:50] <vms14> but you have to be a senior and lucky to get a job in cl
[06:53:58] <kakuhen> even though it's technically the most powerful templating engine you'll get ;)
[06:54:10] <kakuhen> and i really mean it
[06:54:21] <vms14> also I have the suspect lispers don't really exist and are only product of my imagination
[06:54:28] <kakuhen> for straters, iteration with cl-who is easily done with LOOP... so that alone gives you an idea of how much you can refine iteration inside templates
[06:54:40] <kakuhen> djula has its own iteration stuff, and it's much more primitive than LOOP
[06:54:42] <vms14> did you saw a lisper?
[06:54:46] <vms14> see*
[06:54:56] <vms14> some day I'll learn english
[06:55:04] <vms14> and programming 
[06:56:03] <vms14> and I have to answer the question "is forth more "powerful" than lisp"
[06:56:44] <vms14> in the metaprogramming sense plus the fact I can have it everywhere and make it interoperate with any language as long as I build it there
[06:57:15] <vms14> it's a language I can afford to implement
[06:57:31] <vms14> and seems to not envy lisp macros
[07:06:43] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 272 seconds)
[07:08:07] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[07:21:03] <clothespin> hello
[07:21:16] <ck_> is it me you're looking for
[07:31:04] <ck_> clothespin: I can see it in your eyes
[07:47:57] *** Joins: dave0 (~davezero@069.d.003.ncl.iprimus.net.au)
[08:04:28] *** Joins: semz_ (~semz@user/semz)
[08:07:04] *** Quits: semz (~semz@user/semz) (Ping timeout: 250 seconds)
[08:22:36] *** Quits: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se) (Ping timeout: 240 seconds)
[08:31:25] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Remote host closed the connection)
[09:14:54] *** Joins: SR-71 (~user@user/SR-71)
[10:00:53] <hayley> http://alexanderpruss.blogspot.com/2022/02/game-boy-wordle-how-to-compress-12972.html
[10:00:53] -ixelp- Alexander Pruss's Blog: Game Boy Fiver [Wordle clone]: How to compress 12972 five-letter words to 17871 bytes
[10:08:04] <vms14> I have a weird forth-like repl
[10:08:47] <vms14> https://termbin.com/8ph3n
[10:09:12] <moon-child> that is perl?
[10:09:13] <vms14> can actually execute shell commands change the color of the text open read and write files
[10:09:15] <vms14> yes
[10:09:20] <moon-child> I see
[10:09:27] <vms14> you can download it and just perl file.pl
[10:09:34] <moon-child> I think it is traditional to make forth implementations in 'threading-style', in c or assembly
[10:09:45] <Alfr> Why do I suddenly get that strange feeling, that hayley may want to encode those using a dfa.
[10:09:47] <vms14> but I'm thinking I'll try to implement real lisp macros
[10:10:13] <White_Flame> forth has no composite data structures, so what is an s-expression in forth?
[10:10:15] <vms14> instead of having a return stack I don't see the need 
[10:10:34] <vms14> White_Flame: a delimited stuff in the stack
[10:10:35] <moon-child> White_Flame: a sequence of words?
[10:10:42] <vms14> like nil 1 2 3 nil
[10:10:45] <moon-child> (or, rather, a pointer to the first in a sequence of words)
[10:11:02] <vms14> it's kind of funny this repl
[10:11:10] <vms14> "cyan bold" color
[10:11:14] <vms14> and it changes xD
[10:11:18] <vms14> "ls" shell
[10:11:24] <vms14> pushes the result on the stack
[10:11:32] <White_Flame> the equivalent of macros in forth are generally written like lisp reader macros, with access to stdin to get the stuff to expand
[10:11:34] <vms14> newlines are written with ~%
[10:12:09] <vms14> "file" ">" open "some random~%text" write
[10:12:42] <vms14> White_Flame: yes, but I think I can avoid everything and make a real lisp macro
[10:13:11] <hayley> Alfr: A trie? Probably not going to work. Though /me is now looking on if compressing a heap for a microcontroller is a good idea.
[10:13:15] <vms14> I think I can use the stack and convert what the macro returns on the stack as code
[10:14:14] <vms14> and I don't know why I want immediate defer postpone and alike if I have a lisp macro
[10:14:24] <vms14> nor even the return stack
[10:14:34] <Alfr> hayley, was actually thinking of a DAFSA, so that you can also collapse common suffixes.
[10:14:35] <vms14> so I can make the interpreter recursive
[10:14:47] <vms14> it's not cause the return stack
[10:15:00] <vms14> would be like the half of code
[10:15:17] <vms14> and the same functionality as long as macros work
[10:24:04] <vms14> as long as I don't care about efficiency I can do whatever I want
[10:24:21] <vms14> and I bet stills being faster than python
[10:25:02] <vms14> I'm kind of happy with this shit
[10:25:27] <vms14> but I want to remove all and just try to put macros
[10:26:04] <vms14> when a macro executes I can put stuff on the stack like a mark at the start of the macro and another at the end
[10:26:25] <vms14> so whatever the macro pushes is recognized, reversed and used as code
[10:28:05] <vms14> those things are what I like the most of programming
[10:28:15] <vms14> except the fucking parsers
[10:28:28] <vms14> but I'm lucky I just have to parse words
[11:30:45] *** Joins: shka (~herr@109.231.3.55)
[11:35:35] *** Quits: micro (~micro@user/micro) (Ping timeout: 256 seconds)
[11:37:07] *** Joins: micro (~micro@user/micro)
[11:39:33] *** Quits: rogersm (~rogersm@90.166.180.250) (Ping timeout: 256 seconds)
[11:44:19] <moon-child> 'the fact that linked lists are popularly diagrammed/depicted as anal beads really tells you everything you need to know about them'
[11:58:11] <ck_> but don't the diagrams contain arrows? I don't think those beads are barbed
[12:04:07] <vms14> I have some kind of prototype
[12:04:15] <vms14> https://termbin.com/o2dv
[12:05:31] <vms14> actually I'm supposing the macro will return code between *
[12:05:45] <vms14> but I don't have clear how
[12:05:54] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 256 seconds)
[12:06:45] <vms14> quote kind of exists, 'word is pushed on the stack without evaluating it
[12:07:30] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[12:07:54] <vms14> so it can * '1 '2 '3 'print * and that would end in the @macro_result which it's valuated as a list of words
[12:09:13] <vms14> I think I can make a general purpose delimiter
[12:15:03] *** Quits: vms14 (~user@29.red-79-153-202.dynamicip.rima-tde.net) (Remote host closed the connection)
[12:47:51] *** Quits: mcoll (1cd8fbb055@2604:bf00:561:2000::160) (Ping timeout: 245 seconds)
[12:48:13] *** Quits: sirufer (68f46fc7c3@user/sirufer) (Ping timeout: 240 seconds)
[12:48:37] *** Quits: jasom (f3e90f0325@2604:bf00:561:2000::3a6) (Ping timeout: 240 seconds)
[12:48:41] *** Joins: sirufer (68f46fc7c3@user/sirufer)
[12:48:55] *** Quits: sm2n (ae95cb1267@user/sm2n) (Ping timeout: 250 seconds)
[12:48:58] *** Joins: jasom (f3e90f0325@2604:bf00:561:2000::3a6)
[12:49:02] *** Quits: payphone (dd09ba4109@2604:bf00:561:2000::20b) (Ping timeout: 260 seconds)
[12:49:41] *** Joins: sm2n (ae95cb1267@user/sm2n)
[12:49:54] *** Joins: payphone (dd09ba4109@2604:bf00:561:2000::20b)
[12:49:59] *** Joins: mcoll (1cd8fbb055@2604:bf00:561:2000::160)
[12:54:17] <selwyn> https://www.youtube.com/watch?v=BNpPRVaTilY
[12:54:17] -ixelp- 기사식당 국밥을 먹어본 영국 택시기사들의 반응!? - YouTube
[12:57:46] <dave0> that's not-english crazytalk
[13:01:16] <hayley> https://www.youtube.com/watch?v=h9E52Su2Fn4
[13:01:16] -ixelp- who did the minions serve from 1933 to 1945? - YouTube
[13:03:30] <selwyn> hayley: wtf
[13:05:37] *** Quits: SR-71 (~user@user/SR-71) (Ping timeout: 240 seconds)
[13:14:36] *** Joins: cosimone (~user@93-34-132-33.ip49.fastwebnet.it)
[13:23:16] <dave0> https://news.ycombinator.com/item?id=30408924
[13:23:17] -ixelp- Neural nets are not “slightly conscious,” and AI PR can do with less hype | Hacker News
[13:27:48] <hayley> https://developer.arm.com/documentation/den0024/a/The-A64-instruction-set/Memory-access-instructions/Prefetching-memory
[13:27:48] -ixelp- Documentation â Arm Developer
[13:27:59] <hayley> "Policy: KEEP or STRM (keep in cache, or streaming data)." Interesting.
[13:30:49] <hayley> sljit knows about prefetching, but PCRE2 doesn't use it.
[13:31:20] *** Joins: rogersm (~rogersm@90.166.180.250)
[13:32:42] <hayley> https://community.arm.com/support-forums/f/architectures-and-processors-forum/8510/accelerating-pcre-regex-matching-with-data-prefetch-on-arm-cortex-a7 suggests you can win on a Raspberry Pi 2 by prefetching, but when? After every load I guess?
[13:32:42] -ixelp- Accelerating PCRE regex matching with data prefetch on ARM Cortex-A7 - Architectures and Processors forum - Support foru [...]
[13:33:09] <hayley> "We extended one of the fast skipping algorithms with data prefetching and chose a few patterns whose are accelerated by the selected algorithm" Oh.
[13:36:57] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 240 seconds)
[13:37:01] <hayley> If we have a working NIBBLES library, I could still SIMD-within-a-register quite portably. Hmm.
[13:37:57] * hayley reads. We do not have working NIBBLES.
[13:38:23] <hayley> At least, it will coelasce reads as we'd like on anything other than x86-64/SBCL.
[13:38:44] <gilberth> Has (foo (setf (fdefinition 'foo) #'atom)) a defined behavior?
[13:39:12] <hayley> I recall hearing that the order of lookup and argument evaluation is undefined for CL.
[13:39:22] <moon-child> I seem to remember hearing that too
[13:39:29] <gilberth> Good. Thanks.
[13:39:42] * hayley uploaded an image: (4KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/ZuUiUITCHSIoskmytKbdWLmv/Screenshot_2022-02-21_20-55-51.png >
[13:39:48] <hayley> So is it "X on MMTk" or "MMTK on X"?
[13:42:44] <hayley> s/it will/it will not/ some time ago.
[13:45:30] <Alfr> clhs 3.1.2.1.2.3
[13:45:32] <Alfr> gilberth, ^
[13:45:56] <Alfr> Hmpf, specbot isn't here?
[13:46:37] <moon-child> ixelp enhancement time? :)
[13:49:24] <hayley> Holy shit, the style guide for that C++ class mandates having only one return statement in your function.
[13:51:36] <gilberth> I prefer <http://clim.rocks/gilbert/tex/dpans.0.txt> I ought to enhance my tool to make a bit more tidy. :-)
[13:52:01] <gilberth> Alfr: Many thanks!
[13:52:20] <hayley> Fortunately, you can simulate multiple return statements with try/catch as usual.
[13:52:44] <gilberth> How is specbot addressed?
[13:52:48] <Alfr> hayley, an opportunity to set up an end tag and use gotos.
[13:54:58] <Alfr> gilberth, what do you mean by addressed?
[13:55:27] <gilberth> What triggers specbot? How does it work?
[13:56:39] <edgar-rft> by satanic magic
[13:56:45] <Alfr> gilberth, it reacts to "clhs THING".
[13:57:05] *** semz_ is now known as semz
[13:57:11] <Alfr> edgar-rft, and that I guess, for once some working magic. :D
[13:57:38] <dave0> hayley: i think 'one return per function' is a misunderstanding of (was it dijkstra?) structured something something, which is really 'return to one place from a function' (ie. return to where it was called from)
[13:57:45] <gilberth> And it responds with what? A link? I say "clhs rplaca" and it gives me the url?
[13:58:00] <hayley> "When life gives you lemons, recreate the events of May 1968"
[13:58:06] <Alfr> gilberth, yes.
[13:58:16] <hayley> "What happened in May 1968?"
[13:58:22] <gilberth> That sounds easy enough.
[13:59:25] <gilberth> Although strictly speaking Lisp is off-topic here, isn't it?
[14:01:07] <edgar-rft> what means loosely speaking lisp is on-topic?
[14:01:13] <Alfr> gilberth, "chat about anything", can there be something off-topic by the your topic? :D
[14:01:26] <Alfr> s/the//
[14:01:37] <edgar-rft> sloppily speaking lisp :-)
[14:01:57] <gilberth> I haven't looked at the /topic.
[14:02:24] <edgar-rft> moi lischp schounds schid today
[14:02:29] <Alfr> gilberth, ... you set it. oO
[14:02:55] *** Joins: OlCe (~user@amontpellier-655-1-45-169.w109-210.abo.wanadoo.fr)
[14:03:11] <gilberth> Anyhow, I am here, because I annoyed people in #lisp by being off-topic all the time.
[14:03:40] <gilberth> Alfr: I copied it from freenode.
[14:03:52] <edgar-rft> it must be a long time ago, #lisp meanwhile is for *all* lisps
[14:04:26] <gilberth> Yeah, it's #commonlisp now, isn't it?
[14:04:33] <Alfr> gilberth, I'll accept that excuse, this time.
[14:05:59] <edgar-rft> yes it's #commonlisp now, #lisp has degenerated to stupid trash-talk, being be more off-topic than #lisp is impossible
[14:06:15] <gilberth> lol
[14:06:59] <dave0> i believe PL/1 would let you pass a label to a function, and the function could return to that label (on an error?) .. which sounds a bit like exceptions
[14:08:56] <gilberth> That's actually kind of nice, keeps the return value sane. No sentinels to check for the error case.
[14:10:40] <pl> ##lisp@freenode -> #lisp@libera, #lisp@freenode -> #commonlisp@libera
[14:10:52] <pl> there were some complaints in the past that CL hogged #lisp
[14:11:12] <shka> which was fair
[14:11:19] <shka> ##lisp was kinda silly
[14:12:08] <edgar-rft> ##lisp still exists at LiberaChat :-)
[14:12:11] <gilberth> Nah, Common Lisp is the one true Lisp.
[14:14:01] <edgar-rft> thou shall haveth no other Lithps bethide me!
[14:18:29] <Alfr> edgar-rft, what's wrong with a pantheon of Lisps; one for every common occasion?
[14:20:29] <moon-child> I need to implement a complex sin/expt/log/etc.
[14:20:37] <moon-child> on floating-point
[14:20:40] <moon-child> where do I go to learn about such things?
[14:21:38] <ck_> fortran 67?
[14:22:17] <Alfr> moon-child, what do you have to start with? And does it have to be fast?
[14:22:45] <gilberth> And isn't what CL has not suffice?
[14:23:05] <ck_> in a pinch, I'd just use sin(z) = (exp(z) - exp(-z))/(2i)
[14:23:23] <ck_> (and so on)
[14:23:48] <Alfr> ck_, and log?
[14:23:52] <semz> could check out some libc implementations. musl is really readable but I don't remember how well it supports complex math, glibc probably has a correct impl but tends to be much messier.
[14:24:03] <moon-child> obviously fast is better than not fast, but I'll settle for not-terribly-inaccurate
[14:24:54] <moon-child> to start with, I have a not-complex mathlib I stole
[14:25:00] <ck_> Alfr: use polar form
[14:25:40] <gilberth> Why read libc, when you can read the sources of your favorite CL? M-. sin /me is puzzled.
[14:26:03] <moon-child> gilberth: I bet you, it punts to the libc
[14:26:10] <Alfr> ck_, okay, let me rephrase: Where do you like to place the branch cut?
[14:27:15] <semz> Because I wouldn't rely on your favorite CL implementation being that deep into floating-point arcana
[14:27:42] <semz> whereas numerics people use C quite a bit so there's a bigger incentive to get it right
[14:27:57] <moon-child> as I discovered recently, most (all? forget) of them get floating-point reading wrong
[14:28:18] <gilberth> moon-child: Not here. At least not for the complex case as far as I could see. But, you're right you'd expect CL to bail out to libc.
[14:28:44] <semz> FP knowledge is generally piss-poor across programmers, to most it's just "real numbers but sometimes the results are wrong because demons"
[14:28:50] * moon-child wonders idly what sicl will do ... writing a math lib is hard
[14:29:10] <gilberth> C can't even print floating point numbers.
[14:29:20] <ck_> Alfr: I can offer information about branch cuts at a competitive consultation rate
[14:29:21] <moon-child> %f?
[14:29:33] <gilberth> I wonder if CLISP sources give some insight.
[14:30:00] <Alfr> ck_, I'm good.
[14:30:17] <gilberth> moon-child: Doesn't do the same as PRIN1, you get an overly long string.
[14:30:23] * Alfr wonders why ck_ likes to keep his preference for that secret.
[14:30:32] <moon-child> gilberth: right
[14:30:38] <moon-child> ck_: so, where do I go to learn this kind of stuff?
[14:31:09] <gilberth> I mean Bruno was into this sort of things. CLISP even has its own long float format whose size you could set at runtime.
[14:32:17] <gilberth> moon-child: Thus I have: <http://clim.rocks/gilbert/render_float.c>
[14:32:20] <ck_> moon-child: I don't really know what you mean. You have a real-valued math library and want to extend to complex numbers?
[14:32:48] <moon-child> ck_: yes
[14:33:40] <ck_> and what exactly is it you're worried about, speed, accuracy?
[14:34:00] <ck_> the fortran suggestion was not entirely in jest, "People in the sixties knew a thing or two about computing"
[14:34:44] <moon-child> I want something reasonably performant and accurate.  But mainly I want to know what I can read to learn what I would need to know to implement anything remotely reasonable
[14:36:28] <ck_> then just look up the (euler-) identities you need and go from there
[14:38:08] <ck_> bb lunch cucucu 
[14:38:18] *** Joins: qhong (~qhong@rescomp-21-400677.stanford.edu)
[14:38:34] <edgar-rft> <Alfr> ...what's wrong with a pantheon of Lisps; one for every common occasion?
[14:38:35] <edgar-rft> Alfr: for common occasions there's Common Lisp, other lisps are for uncommon occasions
[14:39:13] <Alfr> edgar-rft, I insist on lowercase "common" in this case.
[14:39:36] <qhong> I didn’t realize this before, but: is the standard macro expansion procedure in (Common) Lisp essentially a normal-order (lambda calculus) reducer?
[14:39:53] <qhong> Therefore, Common Lisp is a lazy-evaluated call-by-name language?
[14:40:43] <moon-child> I don't think you can define any useful macros without calling (eager) functions in the process
[14:42:19] <gilberth> Yeah, I wonder where the lazy part is. I mean, you could compute with macros if you wish, but no macro is expanded lazily.
[14:42:26] <qhong> moon-child: there isn’t eagerness or laziness for “primitive” functions, there’s only one way to reduce them
[14:42:57] <moon-child> not if they have side effects...
[14:43:48] <qhong> gilberth: in the sense that during macro expansion, the leftmost outermost redex get reduced, while in usual applicative language, it’s the leftmost innermost redex 
[14:44:05] <qhong> moon-child: let’s forget about side effect for now
[14:44:37] *** Joins: random-nick (~random-ni@87.116.167.125)
[14:44:53] <selwyn> https://www.youtube.com/watch?v=9JsMtqTioOE
[14:44:54] -ixelp- Why It Wasn't a Good Idea to Give Patrick Stewart Creative Control of Star Trek Picard - YouTube
[14:45:48] <gilberth> Right. But there still is no lazy part.
[14:46:17] <shka> selwyn: it had some creative freedom in TNG
[14:46:43] <qhong> gilberth: or, arguments of an macro are expanded only after the macro get expanded (if they survive and get into the expansion result), and in usual execution arguments are reduced before reducing the application
[14:46:58] <selwyn> it is a joke interview based off of one of ricky gervais' lesser known shows
[14:46:59] <shka> and honestly the dumbest part of picard is that space legolas
[14:47:01] <shka> xD
[14:47:30] <moon-child> qhong: I interpret 'lazy' as 'on-demand'.  The macro argumenst are simply not evaluated
[14:47:31] <qhong> gilberth: the definition of lazy evaluation is normal order reduction, which is just leftmost-outermost-redex first reduction
[14:48:04] <qhong> moon-child: I should say a subset of all macro use cases
[14:48:26] <qhong> That should mean one can have a fairly usable lazy language using only plain macros
[14:48:36] <qhong> (or abusing)
[14:48:45] <gilberth> Lazy works by facing a form like (IF NIL <a> <b>) only attending to <a>, which is not what happens during macro expansion with CL. If you have a form like that both <a> and <b> are expanded.
[14:49:08] <gilberth> * To <b> as the test is false.
[14:50:44] <qhong> gilberth: because if as a special operator at the object level is instead a primitive constructor at the macro level
[14:50:59] <qhong> And a constructor always need to fully evaluate its argument
[14:52:33] <gilberth> Do you suggest (defmacro if* (test cons alt) (if test cons alt))?
[14:52:34] <qhong> Well, I think I see the problem, there isn’t a “lambda” at the macro level, the best we have is “let” (which is just “symbol-macrolet”), so macro when regarding as a lazy language is too weak to do anything…
[14:53:43] <qhong> gilberth: if operator is not the right thing to do under a lazy context, in a lazy language if doesn’t need to be a primitive, one should be able to define it using just “lambda” and church encoded booleans 
[14:53:51] <qhong> but we don’t have lambda, game over
[14:55:26] <qhong> … but maybe I can define one? imma stop ranting and try some actual code now
[14:58:46] <gilberth> Well, macrolet could work. You need to bind sth to be applied for the usual true = (lambda (x y) x) and false = (lambda (y x) y) to work. Remember that with lambda calculus there are only lambda expressions. And what we don't have are anonymous macros. You can't say ((macro (x) ..) ...) in CL. Although that would make sense.
[14:59:30] <hayley> I suspect that would suggest that macros are first class objects.
[14:59:56] <hayley> Then you get near fexpr territory.
[15:00:19] <gilberth> Nah, that would be sane still.
[15:00:21] <qhong> fexpr pretty based, common lisp cringe
[15:00:57] * hayley uploaded an image: (13KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/GYRuByMsDwCyyPIfaCeCyzVw/cliff-click-cringe-department.jpg >
[15:00:58] <gilberth> Macros are expanded at macro expansion time. I don't expect (setq f #'(macro ...)) (funcall f ...) to work.
[15:01:36] <gilberth> I mean you already can say (macrolet ((frob ..)) (frob)) to get a similar effect.
[15:02:36] <gilberth> What is missing here with CL is that there are no macro expansions in the function name space.
[15:02:42] <qhong> gilberth: I'm stuck because macroexpansion only reduce outermost anything, not outermost redex, so for ((a b) c) there's no way to tell it to reduce (a b) first
[15:02:49] <qhong> gilberth: ha, we hit the same thing
[15:03:16] <qhong> gilberth: in CL I'm writing (funcall (funcall a b) c) instead, but it doesn't want to expand (funcall a b)
[15:04:05] <gilberth> So there is no (define-function-macro foo (lambda (x) (+ x 1))) and have (foo 41) => ((lambda (x) (+ x 1)) 41) => 42.
[15:04:17] <qhong> hmm, but I could add in more haxxxx using macroexpand-1
[15:04:39] <qhong> or just macroexpand, maybe that's it
[15:04:54] <gilberth> Sure, you could essentially define your own macro expansion process.
[15:05:11] <qhong> gilberth: I'll give up if i need >5 lines of code
[15:05:28] <gilberth> That's a brave limit.
[15:07:37] <qhong> gilberth: I did it!!!
[15:07:37] <gilberth> BTW there is an older(?) paper by JMC describing a Lisp interpreter in terms of SUBLIS. That is evaluating by successive substitution of arguments into the lambdas.
[15:07:38] *** Joins: vms14 (~user@29.red-79-153-202.dynamicip.rima-tde.net)
[15:08:11] <qhong> I got 4 lines of code
[15:08:38] <gilberth> qhong: What do they do?
[15:09:03] <qhong> watch this https://gist.github.com/BlueFlo0d/9a7959f7b7c5c45895b8d93c98acd41a
[15:09:03] -ixelp- lazy.lisp · GitHub
[15:10:36] <qhong> also just added an macroexpand-all trace, it helps telling what's going on
[15:10:42] <gilberth> Yep, classical lambda calculus. Nice.
[15:11:46] <gilberth> Can we define say FIB?
[15:12:28] <qhong> We must be able to, even using church encoding and Y combinators (or more pratically expanding to + instead), but I'm going to sleep for now
[15:12:43] <qhong> I think it's pretty funky stuff tho
[15:13:24] <gilberth> Take care then, I am looking forward to a FIB. ;)
[15:19:50] <vms14> gilberth: I have a funny forth like interpreter
[15:20:04] <vms14> but instead of return stack and immediate postpone etc
[15:20:23] <vms14> I "serialize" lists in the stack and I think I have macros
[15:20:29] <vms14> I have quote too
[15:20:53] <vms14> https://termbin.com/ahj8
[15:21:07] <vms14> you put | 1 2 3 | list
[15:21:19] <vms14> list looks for the | in the stack
[15:21:28] <selwyn> apparently bioses used to have forth interpreters
[15:21:31] <vms14> | puts a delimiter which can be changed at runtime
[15:21:38] <moon-child> selwyn: yes, openfirmware
[15:21:44] <moon-child> killed by uefi, RIP
[15:21:51] <vms14> with '<> delimiter
[15:21:56] <gilberth> I put | 1 2 | 3 4 | list | list
[15:22:02] <selwyn> f
[15:22:30] <moon-child> yeah that doesn't seem like it nests very well
[15:22:37] <moon-child> unless you escape, which is terrible
[15:22:53] <vms14> xd
[15:23:23] <vms14> it has nested it, didn't know it could xD
[15:23:45] <vms14> you can use elt and nth to access elements of the last list
[15:23:48] <vms14> 2 nth
[15:24:05] <vms14> elt works at the reverse
[15:24:35] <vms14> and idk about macros
[15:24:45] <vms14> I have interpret which will interpret a list
[15:24:54] <gilberth> But isn't that supposed to be macros? Doesn't it need to see unevaluated/unexpanded data?
[15:25:17] <vms14> gilberth:  I have quote
[15:25:34] <vms14> so I can decide if something evaluates
[15:25:36] <gilberth> And when I nest more, I have to quote quote?
[15:25:43] <vms14> I think yes
[15:25:47] <vms14> xD
[15:25:53] <vms14> quote does not exist as a word
[15:25:55] <vms14> but as '
[15:26:22] <gilberth> When I nest one more level is it '''foo or ''''foo?
[15:26:56] <vms14> what nesting are you talking about
[15:27:04] <vms14> you mean evaluation nesting?
[15:27:31] <gilberth> When I need to quote ''foo do have to write '''foo or ''''foo. That is: Do I need to quote the quote?
[15:28:06] <vms14> actually what the interpretes does is when it sees a word with ' pushes that word into the stack and removes one '
[15:28:33] <vms14> if you evaluate it again then yes, you can nest quotes
[15:29:07] <gilberth> You sould invent parenthesis and counting.
[15:29:08] <vms14> I'm not sure about what my language does :/
[15:29:24] <vms14> I like the delimiter
[15:29:36] <vms14> you can swap over dup the delimiters
[15:29:56] <vms14> and change it if you need to use a literal '|
[15:29:59] <gilberth> Yeah, but you're in the every-thing is a string or sequence of atoms realm.
[15:30:25] <vms14> gilberth: everything is a word or a string or a list
[15:30:39] <vms14> word being "functions"
[15:30:43] <vms14> well they are
[15:30:53] <gilberth> A list? Are lists first class?
[15:31:07] <vms14> it's a perl array ref
[15:31:21] <vms14> I just push it on the stack
[15:31:27] <vms14> it's a scalar
[15:31:33] <gilberth> Ok. And why isn't there a syntax for that?
[15:31:52] <vms14> the stack can have any scalar which means everything at the end
[15:32:12] <vms14> gilberth: I'm trying stuff and implementing what I think
[15:32:29] <vms14> actually I've tried it the forth way, implementing the return stack and immediate
[15:32:57] <vms14> but then I thought "why don't I just make it recursive and put lisp macros in that"
[15:33:25] <vms14> and then implemented that dirty quote and thought how to make a list
[15:33:38] <vms14> to make a list you push delimiters on the stack
[15:33:42] <vms14> then call list
[15:33:54] <vms14> list will find if from the left
[15:34:39] <gilberth> Ok. See. PS has vectors^Warrays. And the { } syntax is syntax, that is handled by the reader, what's inside it is not evaluated. While [ is just an operator pushing a mark and ] is an operator gathering everything to the next mark. When you could quote a whole list by sth similar at the reader level with your set of parentheses of your choice, it would be nice.
[15:34:58] <vms14> interpret expects a list on the stack and calls traverse_words which is the main interpreter
[15:35:33] <vms14> gilberth: do you mean I should use pair of delimiters instead?
[15:35:39] <vms14> yes, but I was lazy
[15:36:08] <vms14> and they are string literals could get in the way of the user
[15:36:16] <vms14> this is why I let him change it
[15:36:20] <gilberth> You could say that e.g. { would increment a quote level. If the quote level is > 0, you just push what you see without executing evaluators. } would look for the mark and create your list.
[15:36:35] <vms14> 'oh delimiter and not | will put oh and list will look for oh
[15:37:01] <vms14> s/not/now/
[15:37:58] <vms14> now I should think how to implement if and alike
[15:38:08] <vms14> but I like the quote stuff
[15:38:21] <vms14> do you think I need quasiquote?
[15:38:31] <vms14> does not seem to be a need
[15:38:32] <gilberth> I mean. In PS you could say [ 1 2 /add cvx ] cvx [ 3 4 /add cvx ] cvx if, if you wish. That's your quoting tokens approach. But nobody does that and instead says { 1 2 add } { 3 4 add } if. Just my two cents.
[15:38:35] <hayley> I missed the one year anniversary of myself getting so pissed at a "database popularity" chart that I changed university.
[15:39:27] * hayley uploaded an image: (268KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/HPmmIogyldArgBtytOEllIdS/screenshot_2021-02-17_12-05-45.png >
[15:39:35] <gilberth> Would you do the same, you could say { foo bar { baz } } instead of | 'foo 'bar '| ''baz '| 'list | list
[15:39:57] <vms14> yes it's not even readable 
[15:40:03] <vms14> I'll make a pair
[15:40:14] <gilberth> It's nasty because when I want to warp a list around, I need to add a single quote to every token. And I believe moon-child will not be happy about that.
[15:41:03] <vms14> I'll make it able to use 2 or 1 delimiters being two by default
[15:42:30] <gilberth> I suggest you look at PS for inspiration as it has a vector data type and the whole language is build around this as "procedures" are vectors. Called arrays in PS. Called lists in vms14lang.
[15:46:31] <hayley> Does anyone actually like commercial database offerings?
[15:46:57] <moon-child> I am told pointy-haired bosses do
[15:48:53] *** Joins: notzmv (~zmv@user/notzmv)
[15:50:50] <pl> hayley: depends on which one
[15:51:31] <pl> Oracle is a mess in that any good will due to it having nice features at times is overridden by Oracle Licensing & Litigation Complex
[15:51:54] <pl> so end effect is no one wants Oracle unless they can't avoid it
[15:52:29] <pl> SQL Server is pretty good, and generally has saner licensing than Oracle, but then you're mostly stuck with MS platform
[15:53:07] <shka> sql server has a very limited SQL 
[15:53:11] <pl> AllegroGraph is one of the best RDF-oriented databases out there - close to anything else will mean you're taking some serious hits
[15:53:26] <pl> shka: in what way? I found it quite good
[15:53:59] <shka> compared to PG it is bare bones
[15:54:08] <shka> no arrays
[15:54:47] <shka> or anything, really
[15:55:05] <shka> and the optimizer is much better on the Oracle
[15:55:12] <shka> but fuck that company 
[15:55:27] <pl> not many places truly have arrays in SQL
[15:55:36] <pl> Postgres is a bit of an outlier to be quite honest
[15:56:10] <shka>  i like postgres because it is feature rich 
[15:56:16] <shka> has geometric types and stuff
[15:56:22] <shka> which i found to be quite useful 
[15:56:52] <pl> postgres hits beyond its expected level by how easily extensible it is, which is how it could just... accrue some features\
[15:57:40] * shka still wants to put ECL as a PG language
[15:58:02] <pl> back to commercial databases... I don't have much to say about DB2, but I heard generally good things about it, but beware that there are 3 different DB2 versions that afaik are based on different codebase
[15:59:13] <pl> I have serious questions about sanity of anyone choosing InterSystems Caché for new code
[16:00:05] <pl> IBM IMS is limited in terms of deployment, but if you need a big iron K/V and/or CODASYL it might be of interest
[16:01:21] <pl> There are people quite happy with GemStone/S, and I can see why but /costs/
[16:03:04] <random-nick> wouldn't any real database popularity chart have sqlite3 at the top and everything else a tiny speck at the bottom?
[16:03:40] <pl> random-nick: depends on criteria and how it's calculated, and then you might have unexpected upsets with DBM family
[16:05:21] <vms14> gilberth: now you have two ways to create a list
[16:05:43] <vms14> (  1 2 3 ) will push the delimiters on the stack and then call list
[16:05:52] <vms14> so it directly returns a list
[16:06:14] <vms14> but I've preserved the manual way because I'm not sure if can be useful
[16:06:36] <vms14> so { 1 2 3 } would put the delimiters but not would call list
[16:09:49] <gilberth> Nicer.
[16:09:51] <vms14> and can still change the delimiters with '( ') delimiters
[16:10:03] <vms14> and no "one delimiter option" xD
[16:10:31] <vms14> but now I have to think in macros and the if and loop
[16:11:17] <vms14> I like the fact that quote let's me quote words and generate strings at same time
[16:11:21] <gilberth> vms14, do me a favor and read the PostScript language reference manual and play a bit with PS. Look at how "if" works there.
[16:11:42] <vms14> gilberth: don't they use a return stack?
[16:11:59] <gilberth> They do.
[16:12:17] <vms14> I have another version with return stack
[16:12:32] <vms14> but having macros I think I can get rid of the return stack
[16:12:53] <gilberth> But you could also do an expansion/rewrite route, if you wish. The return stack could be seen as an optimization.
[16:13:19] <vms14> for me is a noise that gets in the wat
[16:13:22] <vms14> way*
[16:14:07] <vms14> I'm not sure if the return stack version I have can last too much without crashing
[16:15:10] <vms14> https://termbin.com/zzia actually it's funny
[16:15:22] <vms14> you can change the color with "cyan bold" color
[16:15:49] <vms14> open a file witn "file" ">" open "stuff" write
[16:15:58] <vms14> and put newlines with ~%
[16:16:09] <vms14> and call the shell with "ls" shell
[16:16:27] <gilberth> Well, when PS sees "3 foo 42" it pushes 3 onto the value stack, sees "foo" and pushes the return pointer onto the control stack. This pointer points to the yet to do "42" part. And then switches the program pointer to what 'foo' is defined as.
[16:16:44] <vms14> but when I had this version I thought I prefer a recursive way and add macros
[16:17:17] <vms14> as long as the macro can use the language and generate a list to be interpreted I think I'm fine
[16:17:38] <vms14> and I don't think if I need reader macros with this quote
[16:17:56] <gilberth> In theory you could do instead: Push the 3, have "foo 42" left. Then expand the foo by its definition, say the definition is "4 add", you then go "foo 42" => "4 add 42", you push 4 and you add and push 42. Having a return stack is an optimization to this, as you don't need to copy.
[16:18:17] <vms14> in the lispy one I have set
[16:18:46] <vms14> 1 'oh set
[16:19:01] <vms14> creates a word named 'oh that when called returns that 1
[16:19:12] <vms14> but the value can be any object
[16:19:39] <vms14> if you want to change the value use set again
[16:19:50] <vms14>  set => sub { my ($word,$value)=(get(),get());$words{$word}=sub{put($value)};},
[16:20:17] <vms14> the word is a closure so it can save stuff
[16:20:18] <gilberth> "if" in PS is easy. It takes three arguments: test, consequence, and alternative. if the test is true the procedure consequence is invoked, if not alternative is invoked. This blends with anonymous procedures written with { ... }. So it's <test> { ... then part ... } { ... else part ... } if
[16:20:50] <vms14> gilberth: yes, forth does the same by using branch to implement if
[16:21:13] <vms14> but I'm using perl I don't see the need of a return stack
[16:21:17] <gilberth> Forth does not do the same as far as I can tell.
[16:21:19] <vms14> nor memorry allocation etxc
[16:22:48] <gilberth> In PS procedures are first class.
[16:23:46] <gilberth> You can implement e.g. "when" like cl:when as /def { false if } when. looping and mapping also work that way. Think MAPCAR e.g.
[16:23:47] <vms14> in my language everything is wrong and no one knows why isn't crashing yet
[16:24:13] <vms14> but is so dirty that I like it
[16:24:15] <dave0> i like forth it's interesting
[16:24:16] <vms14> ( ''oh 'print ) interpret
[16:24:19] <gilberth> Nah, it's the other way around /when { false if } def :-(
[16:25:20] <vms14> I don't need to implement colon I think
[16:25:26] <vms14> I think set will do
[16:25:26] <gilberth> I like PS, because procedures are first class and "if" and looping etc are implemented as regular procedures, no special syntax whatsoever needed for "if" as "if" isn't special in any kind.
[16:25:37] <vms14> I did in the forthy one
[16:25:52] <dave0> forths `if` lays down a conditional branch and pushes an unresovled forward pointer onto the stack, which is later filled in by `then`
[16:26:31] <gilberth> Yes. And in PS "if" is just a procedure of three arguments.
[16:26:38] <dave0> ah
[16:26:46] <gilberth> Like (defun ps-if (test cons alt) (funcall (if test cons alt)))
[16:27:03] <vms14> dave0: we're selling forth implementations
[16:27:08] <vms14> I have two
[16:27:19] <vms14> 1 cent 
[16:27:25] <dave0> really? with some business?
[16:27:29] <vms14> no xd
[16:27:52] <dave0> gilberth: i can't read lisp :-p
[16:27:57] <vms14> I'm just learning about forth and trying to implement it in perl
[16:28:16] <dave0> vms14: oh okay cool
[16:28:17] <gilberth> So what is <whatever> { 42 } { 69 } if is the procedure "if" applied to three arguments: <whatever>, the anonymous procedure { 42 } and the anonymous procedure { 69 }.
[16:28:19] <vms14> and tried it like the forth way by implementing a return stack
[16:28:41] <vms14> but then I thought I just can add macros and I don't even need a return stack
[16:28:46] <gilberth> Or with my PS-IF in Lisp (PS-IF <whatever> (lambda () 42) (lambda () 69))
[16:29:17] <dave0> gilberth: in forth you cant define procedure while you're already defining a procedure
[16:29:18] <gilberth> There too PS-IF would be just a function, no special operator of any kind.
[16:29:41] <gilberth> dave0: I am aware. I read the standard.
[16:29:49] <dave0> ah okay no worries
[16:30:52] <gilberth> Well, I tried to figure out if procedures^Wwords are first class with Forth. And they are not as far as I could tell. But I could well be missing sth.
[16:31:19] <dave0> vms14: https://github.com/search?q=perlforth
[16:31:19] -ixelp- Search · perlforth · GitHub
[16:32:36] <dave0> you can find a pointer to a word and pass it around and execute it (if that what first class means)
[16:32:51] <dave0> if that is*
[16:33:06] <vms14> dave0: I have https://termbin.com/9ld1
[16:33:15] <vms14> it's a repl you can try it xD
[16:33:19] <dave0> vms14: i cant real perl either
[16:33:26] <dave0> the only language i know is c :-/
[16:33:42] <vms14> just need to download and perl file.pl
[16:34:11] <vms14> it has print write read dup drop swap over shell open color close
[16:34:21] <vms14> it's the return stack version
[16:34:43] <vms14> but I have another much weirder
[16:35:09] <vms14> https://termbin.com/rdiz
[16:35:29] <vms14> has not much words atm, but I think it has the sense of a macro
[16:35:35] <vms14> and can quote stuff with '
[16:36:02] <dave0> sectorLISP had the cahones to boast about only taking 400 or so bytes for a fully functioning lisp interpreter saying it was shorter than sectorFORTH
[16:36:03] <vms14> no return stack, this one is recursive and just splits lines by spaces
[16:36:22] <dave0> i took that as a personal insult.. everyone knows forth is the most compact langauge ;-)
[16:36:33] <vms14> I think I don't need to attach to the forth way but just steal what is useful for me
[16:37:01] <vms14> the use forth can give me is the concept of a stack as it simplifies a lot the things
[16:37:13] <vms14> of*
[16:37:37] <vms14> but I'm not writing it in asm, so I don't even need to allocate memory
[16:37:55] <dave0> so i rolled my own sectorFORTH and it comes in at 484 bytes
[16:38:02] <vms14> it's 2022 no one allocates memory by hand
[16:39:13] <vms14> and perl it has a scalar type which can represent any perl object and that's the "cell size" of the stack
[16:39:42] <dave0> vms14: what built in data structures does perl support?
[16:40:10] <vms14> I think in my case would be an error to attach too much to the way forth does things, when what I want is macros and I can implement them
[16:40:16] <vms14> dave0: hashes and arrays
[16:40:19] <vms14> and objects
[16:40:29] <dave0> forth only needs an array of integers
[16:40:33] <vms14> typeglobs and more stuff
[16:40:48] <vms14> my language won't be forth
[16:40:50] <dave0> vms14: shouldn't be hard to make a stack out of an array
[16:40:55] <vms14> but reverse notation and a stack
[16:41:02] <vms14> yes
[16:41:10] <vms14> my stack is @stack;
[16:50:56] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[17:00:15] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 240 seconds)
[17:01:02] <vms14> my if: ( ''false 'print ) ( ''true 'print ) 1 if
[17:01:02] <vms14>  
[17:01:09] <vms14> xD
[17:01:35] <vms14> I could swap them except the if
[17:01:53] <vms14> and should provide something to quote lists
[17:02:43] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[17:07:06] *** Quits: euandreh (~euandreh@2804:14c:33:9fe5:41b:9f3:a75a:9b8b) (Ping timeout: 260 seconds)
[17:13:02] *** Quits: dave0 (~davezero@069.d.003.ncl.iprimus.net.au) (Quit: dave's not here)
[17:19:36] *** Joins: kevingal (~quassel@2a02:8084:4140:f300:b4d8:cb19:ba30:6fb5)
[17:20:17] *** Joins: eugercek (~user@user/eugercek)
[17:21:42] *** Quits: eugercek (~user@user/eugercek) (Read error: Connection reset by peer)
[17:27:17] *** Joins: eugercek (~user@user/eugercek)
[17:28:42] *** Quits: eugercek (~user@user/eugercek) (Read error: Connection reset by peer)
[17:29:17] *** Joins: eugercek (~user@user/eugercek)
[17:30:42] *** Quits: eugercek (~user@user/eugercek) (Read error: Connection reset by peer)
[17:33:44] <vms14> now looks a bit better 1 ( 'true print ) ( 'false print ) if 
[17:35:05] <White_Flame> vms14:  you should probably look at Postscript, not just Forth.  It adds a lot to the core language
[17:35:39] <White_Flame> in terms of flinging around code bodies and such, iirc
[17:35:47] *** Quits: jeosol (~jeosol@user/jeosol) (Quit: Client closed)
[17:38:24] *** Joins: treflip (~user@user/treflip)
[17:38:57] *** Joins: eugercek (~user@user/eugercek)
[17:40:22] *** Quits: eugercek (~user@user/eugercek) (Read error: Connection reset by peer)
[17:42:26] *** Joins: euandreh (~euandreh@2804:14c:33:9fe5:436f:e6b2:c8c4:a5a1)
[17:44:35] *** Joins: eugercek (~user@user/eugercek)
[17:46:17] <vms14> hmm
[17:46:42] <vms14> actually I got the simplicity I needed by using the stack and reverse polish notation
[17:47:32] <vms14> and I'm just splitting words by spaces and have no intention to support "this kind of strings"
[17:47:57] <White_Flame> you mean " this kind of string" ;)
[17:47:58] <vms14> 'quote actually makes the word be a string and I can have composition from that
[17:48:28] <vms14> White_Flame: yes, I should handle them as if I split by spaces I split also those strings
[17:48:40] <vms14> and I have 3 sets of parenthesis xDDD
[17:49:09] <vms14> () is at "read" time and is not a word so does not need spaces
[17:49:18] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 256 seconds)
[17:49:19] <vms14> also quotes everything you put in there
[17:50:26] <vms14> [] is a normal list and {} is a normal list but does not really populate a list
[17:50:44] <vms14> lists are constructed by pushing the delimiters on the stack
[17:50:59] <vms14> the word list finds those delimiters and builds a list
[17:51:42] <vms14> so [] calls list {} does not and () is a regex converting it to [] with quoted stuff
[18:09:24] *** Quits: euandreh (~euandreh@2804:14c:33:9fe5:436f:e6b2:c8c4:a5a1) (Ping timeout: 240 seconds)
[18:11:45] *** Joins: euandreh (~euandreh@2804:14c:33:9fe5:436f:e6b2:c8c4:a5a1)
[18:16:46] *** Quits: vms14 (~user@29.red-79-153-202.dynamicip.rima-tde.net) (Ping timeout: 272 seconds)
[18:25:02] *** Quits: euandreh (~euandreh@2804:14c:33:9fe5:436f:e6b2:c8c4:a5a1) (Ping timeout: 240 seconds)
[18:30:03] *** Joins: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se)
[18:34:17] *** Joins: jeosol (~jeosol@user/jeosol)
[18:43:14] *** Joins: Rue_ (~rue@61-231-132-119.dynamic-ip.hinet.net)
[18:54:49] *** Quits: chiselfuse (~chiselfus@user/chiselfuse) (Write error: Connection reset by peer)
[18:55:07] *** Joins: chiselfuse (~chiselfus@user/chiselfuse)
[19:02:05] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Quit: ec)
[19:19:52] *** Joins: euandreh (~euandreh@2804:14c:33:9fe5:436f:e6b2:c8c4:a5a1)
[19:29:08] *** Quits: kevingal (~quassel@2a02:8084:4140:f300:b4d8:cb19:ba30:6fb5) (Ping timeout: 250 seconds)
[19:41:50] *** Quits: axvr (757f658d76@2604:bf00:561:2000::e1) (Remote host closed the connection)
[19:41:50] *** Quits: sm2n (ae95cb1267@user/sm2n) (Remote host closed the connection)
[19:41:50] *** Quits: mcoll (1cd8fbb055@2604:bf00:561:2000::160) (Remote host closed the connection)
[19:41:50] *** Quits: sirufer (68f46fc7c3@user/sirufer) (Remote host closed the connection)
[19:41:50] *** Quits: jasom (f3e90f0325@2604:bf00:561:2000::3a6) (Remote host closed the connection)
[19:41:50] *** Quits: payphone (dd09ba4109@2604:bf00:561:2000::20b) (Remote host closed the connection)
[19:42:30] *** Joins: jasom (f3e90f0325@2604:bf00:561:2000::3a6)
[19:42:38] *** Joins: payphone (dd09ba4109@2604:bf00:561:2000::20b)
[19:42:38] *** Joins: sirufer (68f46fc7c3@user/sirufer)
[19:42:38] *** Joins: sm2n (ae95cb1267@user/sm2n)
[19:42:56] *** Joins: mcoll (1cd8fbb055@2604:bf00:561:2000::160)
[19:42:56] *** Joins: axvr (757f658d76@2604:bf00:561:2000::e1)
[20:05:28] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[20:05:42] *** Joins: domovod (~domovod@ec2-35-165-86-158.us-west-2.compute.amazonaws.com)
[20:06:59] *** Joins: iamFIREcracker (~iamFIREcr@user/iamfirecracker)
[20:09:33] *** Quits: iamFIREc1 (~iamFIREcr@user/iamfirecracker) (Ping timeout: 256 seconds)
[20:13:41] <shka> does anybody how SBCL load FASLs?
[20:13:45] <shka> also via mmap?
[20:18:01] *** Parts: Rue_ (~rue@61-231-132-119.dynamic-ip.hinet.net) (WeeChat 3.4)
[20:21:49] <gilberth> A fasl file is essentially a stream of things to execute.
[20:23:39] <ck_> shka: I think it has something to do with reading unsigned bytes.
[20:23:42] * ck_ computer scientist man
[20:23:52] <gilberth> And you can actually concatenate fasl files.
[20:23:57] <ck_> https://github.com/sbcl/sbcl/blob/master/src/code/load.lisp
[20:23:58] -ixelp- sbcl/load.lisp at master · sbcl/sbcl · GitHub
[20:23:58] <shka> *sigh*
[20:24:37] <shka> ok
[20:24:50] <shka> so it works differently from the image file
[20:25:13] <shka> very much so in fact
[20:28:11] *** Quits: sirufer (68f46fc7c3@user/sirufer) (Remote host closed the connection)
[20:28:11] *** Quits: sm2n (ae95cb1267@user/sm2n) (Remote host closed the connection)
[20:28:11] *** Quits: mcoll (1cd8fbb055@2604:bf00:561:2000::160) (Remote host closed the connection)
[20:28:12] *** Quits: axvr (757f658d76@2604:bf00:561:2000::e1) (Remote host closed the connection)
[20:28:12] *** Quits: jasom (f3e90f0325@2604:bf00:561:2000::3a6) (Remote host closed the connection)
[20:28:12] *** Quits: payphone (dd09ba4109@2604:bf00:561:2000::20b) (Remote host closed the connection)
[20:34:15] *** Joins: jasom (f3e90f0325@2604:bf00:561:2000::3a6)
[20:34:21] *** Joins: mcoll (1cd8fbb055@2604:bf00:561:2000::160)
[20:34:21] *** Joins: payphone (dd09ba4109@2604:bf00:561:2000::20b)
[20:34:26] *** Joins: sm2n (ae95cb1267@user/sm2n)
[20:34:31] *** Joins: sirufer (68f46fc7c3@user/sirufer)
[20:34:32] *** Joins: axvr (757f658d76@2604:bf00:561:2000::e1)
[20:35:58] *** Quits: domovod (~domovod@ec2-35-165-86-158.us-west-2.compute.amazonaws.com) (Quit: WeeChat 3.4)
[20:38:05] *** Joins: iamFIREc1 (~iamFIREcr@user/iamfirecracker)
[20:40:22] *** Quits: iamFIREcracker (~iamFIREcr@user/iamfirecracker) (Ping timeout: 260 seconds)
[20:44:58] *** Joins: Catie (~user@user/catie)
[21:01:39] *** Joins: vms14 (~user@29.red-79-153-202.dynamicip.rima-tde.net)
[21:08:00] *** Joins: iamFIREcracker (~iamFIREcr@user/iamfirecracker)
[21:09:26] *** Quits: iamFIREc1 (~iamFIREcr@user/iamfirecracker) (Read error: Connection reset by peer)
[21:09:29] <lagash> shka: there's also #sbcl but I guess your question is already answered :)
[21:09:41] <shka> yup
[21:28:35] *** Quits: chiselfuse (~chiselfus@user/chiselfuse) (Ping timeout: 240 seconds)
[21:29:33] *** Joins: chiselfuse (~chiselfus@user/chiselfuse)
[21:43:10] <pl> SBCL's image file closest relative is AFAIK Mach-O binary 
[21:45:22] <pl> (specifically, SBCL uses CMUCL image format, which inspired Mach-O format when Mach was developed at CMU) 
[21:49:46] <shka> pl: mach like OS?
[21:50:09] <pl> Yes, Mach the OS
[21:50:26] <shka> oh, wiki says that mach also came from the CMU
[21:50:29] <pl> And thus also Apple OSes outside of the RTKit, iirc 
[21:50:29] <shka> that's cool
[21:50:42] <shka> (i had to check)
[21:50:48] <shka> (sorry)
[21:51:07] <shka> maybe same people worked on both
[21:51:07] <pl> shka: I think Mach outgrew of a project for the same workstation that CMUCL targeted for s time (PERQ?) 
[21:51:08] <shka> cool
[22:13:02] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 240 seconds)
[22:40:54] *** Quits: treflip (~user@user/treflip) (Quit: good night!)
[22:41:37] <gilberth> I always wondered why it is custom to have image files instead of just writing a whole new binary and thus let the OS do the loading and possible relocation work.
[22:44:03] <gilberth> At least with ELF you could append a custom section for your Lisp heap dump.
[22:47:02] <gilberth> I watched a talk by Knuth about TeX's dumping and he said that operating systems often offered a dump function and means to revive such a core dump and that his implement of the fmt files, which are also just dumps of TeX heap are there basically only because this became out of fashion. And because loading plain.tex and all the font metrics took a long time.
[22:51:06] <gilberth> TeX has a variable called ready_already which when all is loaded is set to pi. The main program would first check that variable to figure out if TeX already is ready. With my TeX compiled to CL, this actually works. I could load plain.tex and all the other stuff, break out of the input loop and say SAVE-LISP and have a Lisp image with a booted TeX image inside :-)
[22:52:08] <shka> gilberth: perhaps it is easier to support multiple host systems this way
[22:53:14] <gilberth> shka: Was this a concern? And yes, of course that is easier. And a.out is not too flexible. Granted.
[22:53:42] <shka> i don't know if this was a concern, but i think that it is plausible 
[22:53:54] <gilberth> As you are fixed to the text + data + bss layout with a.out. Expand data and bss shifts.
[22:56:23] <gilberth> An alternative would be to use ld to create a new executable. With one of my toy Lisps, I dump a .c file with the heap, compile it and link to the core lisp.o to get a new binary. Completely portable :-)
[23:14:44] *** Quits: vms14 (~user@29.red-79-153-202.dynamicip.rima-tde.net) (Remote host closed the connection)
[23:15:45] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Remote host closed the connection)
[23:41:40] *** Quits: atw (~user@ool-18bf5678.dyn.optonline.net) (Ping timeout: 272 seconds)
[23:46:56] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
