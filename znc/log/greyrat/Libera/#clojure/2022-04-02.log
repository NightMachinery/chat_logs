[00:16:11] *** Quits: zmt00 (~zmt00@user/zmt00) (Ping timeout: 250 seconds)
[00:19:33] *** Joins: zmt00 (~zmt00@user/zmt00)
[00:29:48] *** Quits: ProfSimm (~ProfSimm@87.227.196.109) (Remote host closed the connection)
[00:29:58] *** Quits: Yaser_Amiri (~Thunderbi@188.122.99.40) (Read error: Connection reset by peer)
[00:41:15] *** Quits: shiranaihito_ (~textual@123.192.192.149) (Quit: My MacBook Air has gone to sleep. ZZZzzz…)
[00:42:03] *** Joins: ProfSimm (~ProfSimm@87.227.196.109)
[01:19:18] *** Quits: uncleyear (~ian@31.173.84.107) (Ping timeout: 260 seconds)
[01:24:16] *** Joins: schmudde (~schmudde@2001:b07:ae6:7d19:7e3d:fa13:b762:465e)
[01:24:16] *** Quits: schmudde (~schmudde@2001:b07:ae6:7d19:7e3d:fa13:b762:465e) (Client Quit)
[01:25:49] *** Joins: uncleyear (~ian@31.173.84.107)
[01:53:15] *** Quits: poselyqualityles (~whirl@user/poselyqualityles) (Ping timeout: 260 seconds)
[02:13:35] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 240 seconds)
[02:15:36] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[02:16:30] *** Quits: selfsymmetric-mu (~matt@c-73-29-248-41.hsd1.nj.comcast.net) (Read error: Connection reset by peer)
[02:24:12] <v3ga> are there any repl based tools that take advantage of tap>? similar to portal/reveal?  like cider-inspector
[02:31:58] *** Joins: super-pizza-cat (~super-piz@h184-61-213-185.wtfrwi.broadband.dynamic.tds.net)
[02:48:34] *** Joins: AlaskanEmily (~AlaskanEm@user/alaskanemily)
[02:56:12] *** Quits: uncleyear (~ian@31.173.84.107) (Ping timeout: 260 seconds)
[02:56:52] *** Joins: schmudde (~schmudde@2001:b07:ae6:7d19:a04a:738c:ec4e:9442)
[02:56:52] *** Quits: schmudde (~schmudde@2001:b07:ae6:7d19:a04a:738c:ec4e:9442) (Client Quit)
[02:58:44] *** Joins: MajorBiscuit (~MajorBisc@2a02:a461:129d:1:6d4c:38a4:18b7:4b48)
[03:03:49] *** Joins: poselyqualityles (~whirl@user/poselyqualityles)
[03:04:54] *** Quits: ProfSimm (~ProfSimm@87.227.196.109) (Remote host closed the connection)
[03:07:57] *** Joins: uncleyear (~ian@31.173.84.107)
[03:08:50] *** Quits: op2 (~op2@user/op2) (Remote host closed the connection)
[03:14:22] *** Quits: MajorBiscuit (~MajorBisc@2a02:a461:129d:1:6d4c:38a4:18b7:4b48) (Quit: WeeChat 3.4)
[03:36:56] *** Quits: uncleyear (~ian@31.173.84.107) (Ping timeout: 246 seconds)
[03:44:59] *** Quits: poselyqualityles (~whirl@user/poselyqualityles) (Ping timeout: 246 seconds)
[04:07:19] *** Joins: rawley (~rawley@216-197-141-102.nbfr.hsdb.sasknet.sk.ca)
[04:25:45] *** Quits: lunik1 (~lunik1@37.205.14.203) (Quit: :x)
[04:26:03] *** Joins: lunik1 (~lunik1@37.205.14.203)
[04:35:47] *** Quits: dbohdan[phone] (uid547665@id-547665.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[05:06:07] *** Joins: selfsymmetric-mu (~matt@c-73-29-248-41.hsd1.nj.comcast.net)
[05:24:22] *** Quits: selfsymmetric-mu (~matt@c-73-29-248-41.hsd1.nj.comcast.net) (Remote host closed the connection)
[05:41:53] *** Quits: rawley (~rawley@216-197-141-102.nbfr.hsdb.sasknet.sk.ca) (Ping timeout: 256 seconds)
[05:45:17] *** Quits: ltriant (~ltriant@194-223-10-27.tpgi.com.au) (Ping timeout: 256 seconds)
[05:58:27] *** Quits: seschwar (~seschwar@user/seschwar) (Quit: :wq)
[06:00:50] *** Quits: super-pizza-cat (~super-piz@h184-61-213-185.wtfrwi.broadband.dynamic.tds.net) (Quit: Leaving)
[06:10:19] *** Joins: yewscion (~yewscion@c-73-214-119-161.hsd1.pa.comcast.net)
[06:13:31] *** Joins: ltriant (~ltriant@194-223-10-27.tpgi.com.au)
[06:21:37] *** Quits: mala (~mala@user/malaclyps) (Read error: Connection reset by peer)
[06:22:53] *** Joins: mala (~mala@user/malaclyps)
[06:36:42] *** Joins: rawley (~rawley@216-197-141-102.nbfr.hsdb.sasknet.sk.ca)
[06:54:35] *** Joins: ahungry (~user@c-68-51-134-46.hsd1.mi.comcast.net)
[08:00:03] *** Quits: libertyprime (~libertypr@118-92-82-225.dsl.dyn.ihug.co.nz) (Ping timeout: 260 seconds)
[08:18:13] *** Quits: rawley (~rawley@216-197-141-102.nbfr.hsdb.sasknet.sk.ca) (Remote host closed the connection)
[08:26:44] *** Quits: yewscion (~yewscion@c-73-214-119-161.hsd1.pa.comcast.net) (Ping timeout: 272 seconds)
[08:51:35] *** Quits: ltriant (~ltriant@194-223-10-27.tpgi.com.au) (Ping timeout: 246 seconds)
[09:04:15] *** Joins: shiranaihito (~textual@123-192-192-149.dynamic.kbronet.com.tw)
[09:20:22] *** Joins: ltriant (~ltriant@194-223-10-27.tpgi.com.au)
[09:40:35] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Ping timeout: 240 seconds)
[09:41:16] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[09:47:00] *** Quits: v3ga (~v3ga@2603-6080-5204-3b35-0000-0000-0000-18ad.res6.spectrum.com) (Remote host closed the connection)
[09:56:56] *** Quits: ahungry (~user@c-68-51-134-46.hsd1.mi.comcast.net) (Remote host closed the connection)
[10:07:30] *** Joins: libertyprime (~libertypr@118-92-82-225.dsl.dyn.ihug.co.nz)
[10:15:23] *** Quits: libertyprime (~libertypr@118-92-82-225.dsl.dyn.ihug.co.nz) (Ping timeout: 260 seconds)
[10:24:46] *** Joins: v3ga (~v3ga@2603-6080-5204-3b35-0000-0000-0000-18ad.res6.spectrum.com)
[10:35:13] *** Joins: libertyprime (~libertypr@118-92-82-225.dsl.dyn.ihug.co.nz)
[10:50:58] *** Joins: puchka (~marius@165.73.242.53)
[11:02:38] *** Quits: zmt00 (~zmt00@user/zmt00) (Quit: Leaving)
[11:03:59] *** Joins: dbohdan[phone] (uid547665@id-547665.uxbridge.irccloud.com)
[11:06:45] *** Joins: zmt00 (~zmt00@user/zmt00)
[11:13:57] *** Joins: Xylon (~joseph@mail.xylon.me.uk)
[11:14:05] <Xylon> hi all
[11:14:47] <Xylon> the second example on this page: why do we need the (cons a ...) https://clojuredocs.org/clojure.core/lazy-seq
[11:15:01] <Xylon> if I remove the cons part it still works...
[11:35:38] <opqdonut> huh? if you remove the cons it won't generate a lazy sequence, it'll just be an infinite recursion
[11:37:13] *** Quits: DasBrain (~DasBrain@user/dasbrain) (Killed (NickServ (GHOST command used by DasBrain_)))
[11:37:19] *** Joins: DasBrain_ (~DasBrain@user/dasbrain)
[11:46:39] *** Quits: zmt00 (~zmt00@user/zmt00) (Quit: Leaving)
[11:48:31] *** Joins: zmt00 (~zmt00@user/zmt00)
[11:49:37] <Xylon> but why?
[11:50:41] *** Quits: lockdown (~lockdown@ec2-3-236-147-4.compute-1.amazonaws.com) (Quit: leaving)
[11:51:07] <Xylon> if I simply remove the cons bit it produces the same output in the same time
[11:53:42] *** Joins: lockdown (~lockdown@ec2-3-236-147-4.compute-1.amazonaws.com)
[12:01:53] <opqdonut> Xylon: not on my machine. are you sure you're running the right version of the code?
[12:02:14] <opqdonut> to be exact, this code: (defn fib ([] (fib 1 1)) ([a b] (lazy-seq (fib b (+ a b)))))
[12:02:31] <opqdonut> a) fails with throwIntOverflow in my clj repl
[12:02:47] <opqdonut> b) crashes the tab on https://tryclojure.org/
[12:03:15] <opqdonut> and how could it even produce a sequence of values since `a` isn't used anywhere? (except to add it to `b`)
[12:04:47] <opqdonut> here's a non-lazy version (that stops the recursion when `a` hits 50): (defn fib [a b] (when (< a 50) (cons a (fib b (+ a b)))))
[12:04:58] <opqdonut> now (fib 1 1) evaluates to (1 1 2 3 5 8 13 21 34)
[12:05:21] <Xylon> yep I know non-lazy version
[12:05:50] <Xylon> so turns out the code crashes in command-line clojure repl but not in the emacs cider-jack-in reply
[12:05:57] <Xylon> repl
[12:06:22] <Para> Always important to mention the runtime env :-)
[12:06:22] <opqdonut> that's unfortunate. cider is probably hiding the crash somehow
[12:30:50] <Xylon> not sure I have enough IQ points to understand these lazy sequences TBH
[12:33:09] *** Quits: shiranaihito (~textual@123-192-192-149.dynamic.kbronet.com.tw) (Quit: My MacBook Air has gone to sleep. ZZZzzz…)
[12:35:02] <Xylon> also FYI in emacs cider I can get rid of lazy-seq and cons and it still works (defn fibng2   ([]    (fib 1 1))   ([a b]    (fib b (+ a b))))
[12:37:06] <opqdonut> yeah that makes no sense, that function will be an infinite recursion
[12:37:12] <opqdonut> and it won't produce any sequence at all
[12:37:36] <opqdonut> you're not running the right code, your cider is in an inconsistent state, or something
[12:37:59] <opqdonut> does it "work" even if you define it using a completely new name?
[12:39:01] <Xylon> Indeed I did define it with a new name. I'll try restart emacs
[12:39:42] <opqdonut> are you sure you're evaluating (take 5 (fibng2)) and not (take 5 (fib)) or something?
[12:39:56] <Xylon> oh yeah oops
[12:40:16] <Xylon> no I mean look in the code it's not calling fibng2
[12:40:27] <opqdonut> ah heh, indeed!
[12:40:45] <opqdonut> I didn't notice that either
[12:40:49] <Xylon> sorry I can be really stupid sometimes
[12:41:06] <opqdonut> don't worry, it happens to the best of us
[12:46:35] *** Joins: shiranaihito (~textual@219.85.165.182)
[12:48:59] *** Joins: DasBrain (~DasBrain@user/dasbrain)
[12:50:46] *** Joins: uncleyear (~ian@31.173.84.107)
[12:52:53] *** Quits: DasBrain_ (~DasBrain@user/dasbrain) (Ping timeout: 256 seconds)
[13:02:47] *** Joins: mange (~user@n114-78-12-98.bla3.nsw.optusnet.com.au)
[13:02:47] *** Quits: mange (~user@n114-78-12-98.bla3.nsw.optusnet.com.au) (Changing host)
[13:02:47] *** Joins: mange (~user@user/mange)
[13:15:01] *** Quits: jespada (~jespada@cpc121022-nmal24-2-0-cust171.19-2.cable.virginm.net) (Quit: Textual IRC Client: www.textualapp.com)
[13:31:42] *** Quits: shiranaihito (~textual@219.85.165.182) (Quit: My MacBook Air has gone to sleep. ZZZzzz…)
[13:33:27] *** Quits: uncleyear (~ian@31.173.84.107) (Remote host closed the connection)
[13:33:40] *** Quits: AlaskanEmily (~AlaskanEm@user/alaskanemily) (Remote host closed the connection)
[13:34:20] *** Joins: uncleyear (~ian@31.173.84.107)
[13:36:33] *** Joins: Yaser_Amiri (~Thunderbi@188.122.118.52)
[13:43:34] *** Joins: jespada (~jespada@cpc121022-nmal24-2-0-cust171.19-2.cable.virginm.net)
[13:50:36] *** Joins: shiranaihito (~textual@219.85.41.227)
[13:54:50] *** Joins: ProfSimm (~ProfSimm@87.227.196.109)
[13:57:55] *** Quits: ProfSimm (~ProfSimm@87.227.196.109) (Remote host closed the connection)
[14:29:47] *** Quits: ltriant (~ltriant@194-223-10-27.tpgi.com.au) (Ping timeout: 260 seconds)
[14:46:03] *** Joins: ltriant (~ltriant@194-223-10-27.tpgi.com.au)
[14:54:35] *** Joins: seschwar (~seschwar@user/seschwar)
[14:58:59] <sobel> it happens to me, too
[14:59:26] <sobel> i've walked away from buggy code only to return, squint, delete one whole line, and then everything is golden again
[14:59:47] <sobel> E_CODEBLIND
[15:01:42] <sobel> something i'm grappling with, related to that: when i program in a DSL (SQL being the most common) that is not Turing-complete i can almost always grind out the errors while staring at code.
[15:02:36] <sobel> but it's common enough that a bug in a Turing-complete language escapes me until i flush that working session, switch modes (eat, sleep, take a walk, anything really)
[15:03:02] <sobel> then on return errors seem very obvious to me.
[15:03:16] <ridcully_> i think that goes with declarative things.  you can always reason about the results even if intermediate.  while some imperative code you will have to account for inner state all the time
[15:04:17] <sobel> i think i create inner state puzzles that are reasonable enough but i have to change modes for that reasoning to occur. maybe i'm just setting up bad puzzles. not sure yet.
[15:05:19] <sobel> SQL in particular is good about requiring i connect the dots. like, i get scolded if i select a column not found in the GROUP BY. etc.
[15:05:38] <sobel> so by the time i've made syntax i've probably also made the query i want.
[15:05:43] *** Quits: turlando (~turlando@user/turlando) (Ping timeout: 256 seconds)
[15:06:01] *** Joins: turlando (~turlando@93-42-250-112.ip89.fastwebnet.it)
[15:06:01] *** Quits: turlando (~turlando@93-42-250-112.ip89.fastwebnet.it) (Changing host)
[15:06:01] *** Joins: turlando (~turlando@user/turlando)
[15:20:48] *** Quits: shiranaihito (~textual@219.85.41.227) (Quit: My MacBook Air has gone to sleep. ZZZzzz…)
[15:59:29] *** Joins: kaisyu (uid37155@id-37155.ilkley.irccloud.com)
[16:37:53] <Xylon> FYI I think I understand lazy-seq now. But the third example is muche easier to understand than the second. https://clojuredocs.org/clojure.core/lazy-seq#example-542692d3c026201cdc326ff0
[16:38:43] *** Quits: libertyprime (~libertypr@118-92-82-225.dsl.dyn.ihug.co.nz) (Ping timeout: 260 seconds)
[16:39:03] <Xylon> it reminds me on linked lists how you create at entry that points to the next entry, except the next entry is a function
[16:39:22] *** Joins: libertyprime (~libertypr@118-92-82-225.dsl.dyn.ihug.co.nz)
[16:40:06] <Xylon> and lazy-seq is just there to stop it recursing like crazy and maxing out all CPU and RAM
[16:46:26] *** Quits: libertyprime (~libertypr@118-92-82-225.dsl.dyn.ihug.co.nz) (Ping timeout: 272 seconds)
[16:46:57] *** Joins: shiranaihito (~textual@2001-b011-4011-3e7f-e451-6332-74a7-ccb4.dynamic-ip6.hinet.net)
[16:47:10] <Para> Sometimes I wonder if teaching people by explaining everything using linked lists is something that should be proactively unlearned at later stage of education.
[16:48:22] <Para> But alas, I have nothing better to use in its place.
[16:54:21] *** Joins: mbuf (~Shakthi@171.61.151.80)
[17:13:29] *** Joins: op2 (~op2@user/op2)
[17:15:20] *** Quits: euandreh (~euandreh@2804:14c:33:9fe5:ac31:7ac1:bab2:710d) (Remote host closed the connection)
[17:15:22] *** Quits: Yaser_Amiri (~Thunderbi@188.122.118.52) (Read error: Connection reset by peer)
[17:15:44] *** Joins: euandreh (~euandreh@2804:14c:33:9fe5:67d2:d391:3f5:bf92)
[17:16:24] *** Joins: Yaser_Amiri (~Thunderbi@188.122.118.52)
[17:16:59] *** Quits: mange (~user@user/mange) (Ping timeout: 246 seconds)
[17:17:39] <Xylon> as a stupid person from a background on bash and python I think that linked-lists are really cool
[17:17:59] <Xylon> well maybe not stupid but uneducated
[17:22:59] *** Joins: Intelo (~Intelo@user/Intelo)
[17:25:05] *** Quits: Intelo (~Intelo@user/Intelo) (Client Quit)
[17:25:37] *** Joins: Intelo (~Intelo@user/Intelo)
[17:32:44] *** Joins: dadinn (~dadinn@cpc87065-finc18-2-0-cust67.4-2.cable.virginm.net)
[18:09:18] *** Quits: kaisyu (uid37155@id-37155.ilkley.irccloud.com) (Quit: Connection closed for inactivity)
[19:08:58] <sobel> linked lists were my first mind-blowing use of dynamic memory allocation
[19:11:43] *** Quits: Yaser_Amiri (~Thunderbi@188.122.118.52) (Quit: Yaser_Amiri)
[19:12:05] *** Joins: Yaser_Amiri (~Thunderbi@188.122.118.52)
[19:29:29] <shem> i very rarely use laziness in my daily coding
[20:10:31] *** Joins: shiranaihito_ (~textual@123-192-192-149.dynamic.kbronet.com.tw)
[20:12:49] *** Quits: shiranaihito (~textual@2001-b011-4011-3e7f-e451-6332-74a7-ccb4.dynamic-ip6.hinet.net) (Ping timeout: 250 seconds)
[20:26:16] *** Quits: Xylon (~joseph@mail.xylon.me.uk) (Quit: Konversation terminated!)
[20:43:28] *** Quits: mbuf (~Shakthi@171.61.151.80) (Quit: Leaving)
[20:47:02] <Yaser_Amiri> Hi, I'm reading a book named Programming Clojure and it uses a lot of samples like this: `::x/y` (double colon sign, something, slash, something) but clojure's REPL raises syntax error, can someone explain it to me please? is the book wrong (I think not) or what?
[20:47:31] <ridcully_> Yaser_Amiri: this is a aliased namespaced keyword
[20:47:50] <ridcully_> this will only work if you have previosly defined the x namespace alias
[20:49:36] <Yaser_Amiri> ridcully_: You mean if I create a ns named `x` and come back to `user` ns it would work?
[20:49:52] <Yaser_Amiri> it doesn't
[20:50:09] <ridcully_> i don't want to send you into a rabbit hole.  in your repl you can create an alias via `(alias 'cc 'clojure.core)`.  then e.g. `::cc/my-key` works
[20:50:18] <ToxicFrog> Does it? It doesn't work for me.
[20:50:27] <ToxicFrog> ::foo does, but that's sugar for :*ns*/foo
[20:50:37] <ridcully_> this is (roughly?) one of three ways to create an alias.  the others are around require
[20:50:37] <ToxicFrog> (note: single colon on the fully qualified keyword)
[20:50:44] <Para> If you require with alias, you can use ::foo/* keys as well.
[20:50:54] <Para> Was bitten by those this week, in fact :)
[20:51:25] <ToxicFrog> Huh. TIL.
[20:51:50] <ridcully_> ::alias/key needs to know the alias there.  this is primarily used to write inside your code.  it's even considered half of a smell
[20:52:08] <ToxicFrog> Ok, so: :foo is an unqualified kw; ::foo is a kw qualified by the current namespace; :bar/foo is a kw qualified with namespace bar; and ::bar/foo is a kw qualified with whatever ns bar is aliased to, iff the alias exists, otherwise parse error?
[20:52:29] <ridcully_> because once you use your ns/kw outside of your program (e.g. you store them in your db etc) changing namespaces might ruin your data/world/...
[20:53:01] <ridcully_> ToxicFrog: yes
[20:53:13] <Para> ridcully_: indeed, and now imagine a magic mapper which likes to use namespaced keys by default when loading data from a database...
[20:55:48] <ridcully_> Yaser_Amiri: a namespace does not to be created to make this work.  you have to create an alias.  creating an alias from an existing ns is very common in clj.  clj11 even added a helper to not not load the ns just to get the alias
[20:56:04] *** Joins: v88m (~Xiro@213.87.154.193)
[20:56:31] <ridcully_> *does not have to be
[20:56:48] <Yaser_Amiri> ridcully_: Yea I got that after your emphasizing on alias, I have to read more about them, Thanks.
[20:57:05] *** Joins: rlb (rlb@defaultvalue.org)
[20:59:01] <rlb> Hmm, it looks like maybe (:refer-clojure :exclude [try]) doesn't actually work.  It does work for with-open, for example, but not try.  i.e. if you do that in an ns form, try is still available in the ns.  I wonder if it's supposed to.
[20:59:13] <Para> It's worth mentioning that it's easy to overuse namespaced keywords, usually there's simply no need. I can see the added value of carrying some metadata in the namespace, eg. :uuid/v4 is more specific than :uuid, but even then I'm not sure if I like them in practice or not.
[20:59:53] <technomancy> I think the idea is that it allows you to have one map that can be used by multiple different pieces of code to store data in
[21:00:04] <technomancy> which ... is not a feature I have ever wanted
[21:00:45] <Para> rlb: `try` is a special form, so that probably interferes with what you're trying to achieve https://clojure.org/reference/special_forms#try
[21:00:56] <rlb> Hmm, so is with-open?
[21:01:47] <rlb> i.e. I believed ns :require's :exclude, :rename, etc. should work on macros too.
[21:01:48] <ridcully_> with-open is a macro
[21:04:34] <rlb> (fwiw, context is wanting to replace try with a slightly fancier version (superset) and use the same name so that indentation, highlighting, etc. will work the same: https://gitlab.com/clj-murphy/murphy/  Whether or not I *should* leave the name the same while augmenting the behavior is a different question, of course.)
[21:04:59] <rlb> But noticed the issue while toying with the replacement attempt.
[21:07:08] <Para> Special forms are always there afaik.
[21:07:13] <rlb> Interesting -- looks like try is special somehow.  i.e. at a repl evaluating with-open provokes the typical "Can't take value of a macro" complaint, but try doesn't.  It acts like its unbound.
[21:07:23] <rlb> Para :exclude works fine for with-open, fwiw.
[21:07:30] <Para> rlb: with-open is a macro
[21:07:40] <rlb> Oh, hmm.  I see.
[21:07:41] <Para> special form is a different thing than macro :)
[21:08:13] <rlb> I hadn't fully realized clojure/jvm might have a distinction there.
[21:08:20] *** Quits: v88m (~Xiro@213.87.154.193) (Ping timeout: 246 seconds)
[21:09:01] <Para> https://github.com/clojure/clojure/blob/658693f6cf97e6ab0ff789e096c9eb6654e4d3ab/src/jvm/clojure/lang/Compiler.java#L105-L138
[21:09:02] <rlb> Para: thanks much.  (Even says roughly that at the top of the page.)
[21:09:25] <Para> (do not ask about the indentation)
[21:10:18] <rlb> (Now, almost entirely unrelated,  I wonder if that's an important language requirement...  I didn't respect that in the dialect I've been working on, i.e. all those are implemented via scheme macros.)
[21:10:29] <rlb> Intersting.
[21:10:39] <rlb> "Interesting."
[21:11:55] <Para> There's always some bits that just have to be implemented as close to host platform as possible.
[21:11:57] <technomancy> it's weird that they get treated differently tbh
[21:12:06] <technomancy> acting like it's unbound is not ideal behavior
[21:12:31] <technomancy> obviously they have to be implemented differently but there's no reason that implementation detail should be visible
[21:12:36] <rlb> For anyone interested: https://github.com/lokke-org/lokke  Though it's still rough in many places.
[21:12:40] <Para> Although I'm not familiar with implementing compilers and such in general, so maybe it's a design issue that sort of creeped in and then got into shape where it can't be worked out anymore.
[21:12:45] <rlb> (or even completely broken)
[21:13:21] <technomancy> rlb: please do not follow Clojure's lead on how it reports errors in your dialect =)
[21:13:25] <technomancy> begging you
[21:13:41] <rlb> Hah, no worries, I'm sure lokke's much worse :)
[21:13:55] <technomancy> that would be ... a challenge
[21:13:55] <Para> wellllllllll, you sayt hat... :-)
[21:14:05] <rlb> (it almost certainly is right now)
[21:14:34] <technomancy> rlb: how is it working using gh and srht both?
[21:15:08] <rlb> For lokke?  Just fine?  But that's because it's mostly just me? :)
[21:15:25] <technomancy> "Symbols do not currently support metadata" <- oof, ok, I take it back; with this it's very likely the errors are worse than clojure
[21:15:26] <rlb> i.e. the only real effect for the moment is that I push to both places?
[21:15:31] <technomancy> ah, ok
[21:16:02] <technomancy> we are using sourcehut and github both for fennel but github is mostly just a read-only mirror and a way to allow people to report issues in a way they're comfortable with
[21:16:19] <rlb> Worth noting that right now lokke is very much more oriented (to the extent it's useful at all) toward batch work, or #! work, i.e. not toward repl work.
[21:16:58] <rlb> e.g. no vars, just direct bindings, and yeah, symbols are scheme symbols which are very efficient (just 4-8 byte pointers), but not as friendly.
[21:17:15] <technomancy> oh, no vars? wow. that's a tremendous difference.
[21:18:13] <technomancy> that's like ... much bigger of a difference than any of the differences actually listed in the readme, haha
[21:18:15] <rlb> Yep - might/could add them?, but haven't, and wasn't sure I wanted to since I think I may rarely rely on them in a lot of my clojure work, but no firm opinion.
[21:18:23] <rlb> Oh, yeah, I should probably mention that :)
[21:18:33] <rlb> (defn ...) translates directly to a scheme (define ...)
[21:18:35] <rlb> etc.
[21:18:36] <rlb> atm
[21:19:35] <technomancy> vars and metadata are like ... my two favorite clojure features honestly
[21:19:36] <rlb> For now there's a *very* thin wall between the scheme and clojure side.  In that sense it definitely "leans toward the platform".
[21:19:46] <technomancy> but no one will notice if you leave out refs and agents
[21:19:53] <rlb> Hah, well I've been adding *some* metadata, but not sure it's quite right yet.
[21:20:04] <Para> technomancy: STM!
[21:20:13] <technomancy> rlb: well, metadata that you can't attach to a var is ... not that useful
[21:20:13] <rlb> symbol metadata would be the more expensive choice.
[21:20:33] <technomancy> huh? how can you support stack traces without symbol metadata?
[21:21:42] <rlb> Right now, you just get whatever guile gives you, but scheme and clj are mostly interchangeable -- i.e. no symbol mangling, etc.  And any ns can be written (transparently as scheme or clj), etc.
[21:22:17] <technomancy> do you compile to scheme or directly to bytecode?
[21:22:23] <rlb> Two things I wanted were faster startup time, and better posix-ish interactions.
[21:23:59] <technomancy> Para: lol
[21:24:01] <rlb> Lokke just plugs in to guile's existing "language tower", built for this purpose.  Though it skips the scheme layer (i.e. it's not just a clj->scheme compiler that then lets the rest of the tower take over from scheme, it goes from clj->tree-il via macroexpansion (just like the scheme dialect does), if that means anything.
[21:24:18] <rlb> i.e. most of lokke's core is just hygenic scheme macros
[21:24:46] <technomancy> so you don't have source mapping problems; that's nice
[21:24:48] <rlb> (with some passes both before that and on the resulting tree-il to handle some other things)
[21:24:57] *** Quits: seebs (~seebs@24.196.59.174) (Ping timeout: 240 seconds)
[21:25:16] <rlb> And then it bottoms out in byte-code on disk, and some assembly via the new template jit at runtime.
[21:25:24] <technomancy> I guess I still don't understand how you could do stack traces without symbol metadata; where does the reader store line info?
[21:25:53] <rlb> As an example of a clj namespace written in scheme (fwiw): https://github.com/lokke-org/lokke/blob/main/mod/lokke/ns/clojure/string.scm
[21:25:59] <rlb> that's clojure.string in lokke
[21:26:32] <rlb> Did it in scheme because it's a touch more efficient that way, and it's a very thin shim over existing scheme functions.
[21:26:38] <rlb> (with one or two exceptions)
[21:26:55] <rlb> Oh, guile forms do have that info :)
[21:27:12] <rlb> i.e. guile syntax objects, which the macros trade in.
[21:27:28] <rlb> They don't have general purpose metadata, but they do have src file, line, etc. info.
[21:27:33] <technomancy> but if you had a macro written in clojure, its forms wouldn't have line info?
[21:27:55] <technomancy> because the clj macros will just return lists, not syntax objects
[21:28:09] <technomancy> so where does the line info live then?
[21:28:15] <rlb> Shoehorning clj-style macros in was one of the hardest bits :)
[21:28:17] <rlb> fwiw
[21:28:42] <Para> How do other lisps implement macros? Do I even want to know?
[21:29:07] *** Quits: matty_matt (~matt@137.184.142.205) (Ping timeout: 268 seconds)
[21:29:22] <technomancy> Para: non-schemes tend to be pretty similar to clojure's approach, but older ones don't have auto-gensym. schemes ... welllll. it's really complicated.
[21:29:24] <rlb> Well, schemes have standard "much fancier/safer" macros than say common lisp or clojure.  Clojure's are much closer to common-lisps, and both are "unsafe".
[21:29:39] <technomancy> Para: every so often I try to read up on it to understand it but it never sticks in my head for more than 15 minutes
[21:30:16] <technomancy> Clojure macros are technically unsafe but not in a way that really matters; like it's virtually impossible to accidentally do symbol capture due to the way that backtick qualifies symbols.
[21:31:06] <rlb> technomancy: wrt debugging, I've spent very little time on that and so it might well be varying degrees of unacceptable/useless to you in any given case...
[21:32:15] <technomancy> Para: basically CL has an extremely naive system with really serious hygiene/safety issues; Scheme created a baroque solution to make those issues completely impossible to arise, and Clojure said "wait, you can solve those problems with a couple tiny changes instead" and most lisps since Clojure have adopted the auto-gensym approach.
[21:32:19] <rlb> (i.e. on line numbers, backtraces, etc.; just ended up with whatever I got given the way it's implemented -- as a hopefully fairly efficient/slim guile dialect.
[21:33:07] <rlb> i.e. so far have just leaned toward efficiency/ease there, but might well (if this is ever anything but just a toy) need a lot more work to get some of the things you might want, and more than "just me" :)
[21:33:09] <Para> Alright so if the gulls are Common-LISP and Scheme and the rabbit is macros, I'm the magpie -> https://gfycat.com/simpleshinyaustralianshelduck
[21:34:32] <rlb> Though as another use case (which doesn't seem likely), if emacs ever did switch to guile, I've imagined having an emacs that could natively understand scheme, js, elisp, and clj might be interesting.  (The first three languages guile already does more or less.)
[21:34:42] <rlb> I won't hold my breath :)
[21:35:51] <rlb> Scheme's macros are also quite nice when they fit well (and nicer than clj/cl imo), i.e. when what you want to do fits the built-in pattern matching.
[21:37:04] <rlb> perhaps, for example: https://github.com/lokke-org/lokke/blob/main/mod/lokke/base/syntax.scm#L108
[21:37:22] <technomancy> Para: wow, incredible bird
[21:38:34] *** Joins: seebs (~seebs@24.196.59.174)
[21:39:23] <rlb> technomancy: wrt srht - be nice to have projects (which I think are pending)
[21:39:54] <Para> technomancy: gulls are kinda terrifying
[21:40:08] <rlb> yeah, I didn't realize they could do that...
[21:40:22] <technomancy> rlb: projects?
[21:40:43] <rlb> sourcehut projects rather than everything being just individuals.
[21:41:06] <technomancy> they do have a way of grouping together projects
[21:41:15] <technomancy> err-grouping repositories
[21:41:39] <technomancy> but it's always under one given account
[21:41:47] <rlb> Hmm, maybe I haven't been paying attention there?  Was of course thinking of things like ring-clojure, etc.
[21:41:57] <technomancy> https://sr.ht/~technomancy/fennel/sources
[21:41:59] <rlb> Where you can add members, etc.
[21:42:18] <technomancy> I guess I'd call that organizations
[21:42:31] <rlb> Oh, sorry, pretend that's what I said?
[21:42:38] <technomancy> and yeah I don't think that exists yet
[21:45:25] <rlb> Para: thanks again for pointing out the special forms distinction I'd clearly passed right over.  Glad to at least understand why the behavior would be different.
[21:50:55] <rlb> Oh, and wrt scheme macros, syntax-rules is discussed a bit here: https://www.scheme.com/tspl4/further.html#./further:h1 But that doesn't talk about the more powerful syntax-case, which you need for more complex situations, capturing, etc.: https://www.scheme.com/tspl4/syntax.html#./syntax:h0
[21:51:42] * rlb is not a expert there, but is quite a bit better at it after trying to get various bits of lokke working...
[21:54:14] <rlb> Oh, and technomancy one maybe interesting bit of overhead came from having to add the "keywords as functions" support.  guile itself, nor the metaobject system, has direct support for that, so there's a final tree-il pass that effectively injects an `invoke` call at *every* call site, i.e. (foo x) becomes ((invoke foo) x), and invoke is a generic function that's specialized for some things, e.g. keywords.  So (:foo x) becomes ((invoke
[21:54:14] <rlb> :foo) x), which can then handle it.
[21:54:57] <technomancy> yeah, that makes sense
[21:55:00] <rlb> But of course that's fairly pricey.  Might see about possible changes to guile to make that more efficient at some point, if we can.  Guile *does* already have the idea of "applicable structs".
[21:55:17] <technomancy> rlb: you mention in the "Known issues" that lazy seqs aren't counted but I don't understand how that's an issue
[21:55:27] <rlb> That's also nudged me to work more on the scheme side sometimes, since you avoid that cost entirely.
[21:55:33] <technomancy> lazy seqs can't be counted
[21:55:55] <rlb> Hmm, I thought they were in clj/jvm?, but now that I say that out loud...
[21:56:03] <technomancy> how could they be? =)
[21:56:06] * rlb tries to recall why he said that.
[21:56:07] <rlb> yeah...
[21:57:09] <rlb> Oh, I probably just scribbled that in after seeing this, and planned to consider it with any care later:
[21:57:11] <rlb> (class (seq [1 2 3]))
[21:57:11] <rlb> clojure.lang.PersistentVector$ChunkedSeq
[21:57:11] <rlb> (counted? (seq [1 2 3]))
[21:57:11] <rlb> true
[21:57:15] <rlb>  
[21:57:23] <rlb> i.e. that's clj-jvm
[21:58:07] <rlb> iirc I didn't get any further than that, just made the note...
[21:58:35] <technomancy> it's possible for a seq to be counted, yeah, but not if it's lazy
[21:58:55] <rlb> And "lazy seqs" are one of the other maybe fairly sketchy bits, i.e. they're currently just cons pairs...
[21:59:07] <technomancy> wait what
[21:59:26] <technomancy> how can cons pairs be lazy?
[21:59:40] <rlb> Well, not just that, sorry.
[22:01:19] <rlb> So '(1 2 3) is just cons pairs, and so technically mutable (thought that quoted list in particular won't be because it's const, and will be compiled into the ELF file in a RO section so guile can just mmap it (no parsing iirc) at startup.  And a lazy seq is just the typical trick iirc, i.e. roughly (cons item (promise ...))
[22:01:51] <technomancy> so cdr will transparently deref the promise?
[22:01:53] <rlb> I'd like to look in to https://srfi.schemers.org/srfi-41/srfi-41.html as a potential replacement.
[22:01:56] <rlb> yes
[22:02:02] <technomancy> nice
[22:02:03] <rlb> well cdr won't but clj functions will :)
[22:02:18] <technomancy> ah ok, that feels like a reasonable compromise tbh
[22:02:50] <technomancy> so you will still notice from the scheme side that lazy seqs are different from lists, because ... they *are* different
[22:03:25] <rlb> I also need to work on the reader at some point -- just stole guile's C reader and mangled it (which should be fast), but now guile's moved to a scheme reader, and mirroring that might be a lot cleaner for lokke too, if we're OK with the extra cost.
[22:03:55] <rlb> yeah, though using the srfi might mean that guile and clj could handle them in the exact same way, with standard apis (if that's useful)
[22:04:05] <rlb> dunno
[22:04:49] *** Joins: super-pizza-cat (~super-piz@h184-61-213-185.wtfrwi.broadband.dynamic.tds.net)
[22:04:59] <rlb> Lots of things are missing though -- the readme's likely only a partial set (and the DESIGN has more bits, and other things that are likely to make ones head hurt wrt the sneaky mess used to get this far)
[22:05:13] <rlb> no sorted-set sorted-map, etc.
[22:05:22] <rlb> But there's a man page?  :)
[22:05:48] <technomancy> sorted stuff is pretty niche honestly, much more minor than vars
[22:06:42] <rlb> What are the key things you want vars for?  i.e. mostly just for interactive/repl dev, or other things too?
[22:07:52] <rlb> Hopefully lokke has full tail recursion too (mutual, etc.), though I haven't recently tested that...
[22:08:11] <technomancy> "just" repl stuff, haha
[22:08:14] <rlb> (tested that it doesn't eventually crash)
[22:08:22] <rlb> Fair enough :)
[22:08:55] <technomancy> I mean... the repl is the most important part of the language IMO, but yeah it's just repl stuff and other dev-time tooling
[22:09:43] <technomancy> another big one is for test selectors; you flag deftest vars with ^:online or :^integration so you can run subsets of your entire test suite easily
[22:09:44] <rlb> I suppose as mentioned, I haven't been all that focused there, and hadn't assumed it might ever be as good as clj/jvm on that front.
[22:10:01] <rlb> Hah, clojure.test is currently *really* sketchy.
[22:10:37] <rlb> guile did recently add cross-module inlining, which is potentially interesting, particularly without vars...
[22:10:47] <technomancy> well, if you never used clojure and only heard that it was a lisp that ran on the JVM, you would probably assume it sucked at reloading and repl stuff too, given what you know about Java and the JVM, but somehow it manages to be world-class at it.
[22:10:58] <rlb> But of course, vars *could* be an optional thing I'd guess too.
[22:11:17] <rlb> Sure, clj/jvm is very strong there.
[22:11:18] <technomancy> (specifically because of the unique design of vars; afaict vars are *the* thing that make reloading work well.)
[22:12:10] <technomancy> all that to say that I don't think "because we target runtime X we probably won't be as good at reloading as Clojure" doesn't really seem to hold up
[22:12:17] <rlb> Of course guile does have a repl, and does allow interactive work (remote too), but it doesn't use vars, it just relies on traditional lisp mutability.
[22:12:26] <technomancy> unless you're saying "it'll never be as good at reloading as Clojure because it's not a priority"
[22:13:47] <rlb> For me personally, that might be true, but I'm not remotely opposed to improvements there, particularly if they can be done in a way that doesn't unconditionally make things more expensive, i.e. if you can opt-in/out, then there's no tension at all, etc.
[22:14:06] <rlb> cf. clj/jvm's direct linking...
[22:14:31] <technomancy> yeah it does seem like a close analogy to direct linking
[22:14:33] <rlb> but I've possibly been working the other way round :)  i.e. direct linking first, then maybe add the other bits :)
[22:15:00] <rlb> but as you say, mostly because to date I haven't been all that repl-focused.
[22:15:07] <rlb> (which I know is very strange)
[22:15:29] <rlb> But I was never happy with the security issues, on principle.
[22:15:47] <rlb> (and was perhaps far too lazy/stubborn?)
[22:15:50] <technomancy> security issues?
[22:16:01] <technomancy> personally I'm too lazy to not use a repl
[22:16:22] <rlb> The fact that anyone on a system can "rm -rf" any user's home directory who's running nrepl with a simple curl one-liner.
[22:16:41] <technomancy> oh, you mean with nrepl specifically
[22:16:55] <rlb> But now I've fixed it :)
[22:17:02] <rlb> (well, the ground work is there)
[22:17:22] <technomancy> yeah, that really sucks because the JVM did not ship with any mechanism for domain sockets until significantly after the repl tooling evolved
[22:17:36] <technomancy> but that's a JVM-specific flaw
[22:17:46] <technomancy> also not a language-level flaw
[22:17:46] <rlb> https://github.com/nrepl/nrepl/pull/204
[22:18:25] <rlb> We now support both pre and post jdk 16 sockets (the former if you're willing to add a junixsocket dependency).
[22:18:36] <rlb> (opportunistically noticed)
[22:18:37] <technomancy> good lord did it really not land until 16?
[22:18:42] <technomancy> that's incredibly depressing
[22:18:55] * rlb can't believe how stubborn the jvm upstream has been wrt some things
[22:18:58] <rlb> symlinks?
[22:19:00] <rlb> *finally*
[22:19:05] <rlb> not all that long ago
[22:19:37] <technomancy> but you can't use that as an excuse in guile =)
[22:19:44] <rlb> nope
[22:19:54] <Para> hmm? what about symlinks?
[22:20:09] <rlb> weren't acknowledged by the jvm as real until "way too long"
[22:20:51] <technomancy> for a VM that was originally developed by a company famous for its unix systems, the JVM sure sucks at unix things
[22:21:02] <rlb> Of course if you really want to be able to do system-level work reliably, you also have to go the extra mile (e.g. rust's String vs OsString) so you can actually handle *all* path names, user names groups -- i.e. still can't easily write tar in java?
[22:21:09] <rlb> (well maybe posix tar)
[22:21:36] <ridcully_> maybe the need to make run on windows just poisoned the well
[22:21:51] <rlb> Even guile "gets that wrong" atm, sadly, though you can hack around it by setting the LC_CTYPE to latin-1...
[22:22:06] <Para> ridcully_: Solaris also implementing things differently was a hindrance to old io classes.
[22:22:11] * rlb takes us way too far off into the weeds now, will attempt to stop.
[22:22:36] <Para> NIO does resolve symlinks with Path#toRealPath(), sooooo there's that at least.
[22:23:18] <rlb> ridcully_: well I'd have preferred some sensible practicality there, i.e. just have optional namespaces with (at least the glaringly obvious) platoform specific bits, where feasible, i.e. sockets.  a la python "os." or similar.
[22:23:52] <rlb> Para: yeah, they did add some support "a while back (years)", but it was not all *that* long ago.
[22:24:07] <technomancy> java.nonportable.DomainSocket
[22:24:32] <rlb> java.{posixish,windows}...
[22:24:35] <rlb> dunno
[22:24:43] <rlb> *something*
[22:24:45] <Para> rlb: Since Java 7, which was release in July 2011. We're not old :)
[22:24:56] <rlb> hah :)
[22:25:17] <Para> The NIO as a whole was a mixed bag, which is why we got NIO.2
[22:25:20] <rlb> yeah, I was more annoyed by the unix domain sockets issue lately anyway :)
[22:25:35] <Para> Bunch of good ideas and progression but as an API a sort of "you must love block deviced to care about all these things!"
[22:25:41] <Para> *devices
[22:26:03] <Para> The domain socket things has been a PITA, that should've landed way earlier.
[22:26:07] <rlb> Hopefully the mmap support is decent -- haven't really used it much yet...
[22:26:17] <ridcully_> rlb: that was how it was solved in the past.  there where jvm libs for e.g. sockets long before it got added to the jdk
[22:27:04] <Para> rlb: zero-copy memory mapping works wonderfully; that's literally the only trick of the Kafka pony :)
[22:27:20] <rlb> I suppose you might be able to pull out some of what we did in that pr (and the subsequent fixups) to create a unix domain socket "paperover" lib for clojure, i.e. so everyone doesn't have to.  Though not sure how much demand there'd be.
[22:27:54] <rlb> i.e. a lib that provides them with the same api across jvms via either jdk 16+ or junixsocket.
[22:28:09] <Para> junixsocket doesn't have a working build for several platforms
[22:28:12] * rlb doesn't expect the jdk to add file-descriptor forwarding any time soon, though :)
[22:28:28] <rlb> junixsocket does have that, which can be handy...
[22:28:55] <Para> That might go against JVM's design philosophy. There are parts which are decided against because of security.
[22:28:58] <rlb> (e.g. to let a server masquerade as a client with *no* overhead)
[22:29:08] <rlb> on the client's stdin/stdout/stderr/etc.
[22:29:18] <Para> JVM as a whole hates files though :)
[22:30:03] <rlb> (I toyed with that as a way to implement fast command line clients - complexity, but it does work)
[22:32:53] <Para> This whole discussion reminds me that one of the eternally dumbest things is that NTFS uses /nix/like/paths and the whole C:\what\ever is an enforced translation on top of everything because of the Win8x/WinNT kernel war Microsoft had internally 20+ years ago.
[22:33:35] <Para> Win9x, of course. Seems my bedtime is getting closer by the amount of typos I've been doing this evening.
[22:39:38] *** Joins: selfsymmetric-mu (~matt@c-73-29-248-41.hsd1.nj.comcast.net)
[22:45:06] *** Quits: super-pizza-cat (~super-piz@h184-61-213-185.wtfrwi.broadband.dynamic.tds.net) (Quit: Leaving)
[22:47:00] *** Quits: TonyStone (~TonyStone@cpe-74-76-51-197.nycap.res.rr.com) (Remote host closed the connection)
[23:16:27] *** Quits: Yaser_Amiri (~Thunderbi@188.122.118.52) (Read error: Connection reset by peer)
[23:25:53] *** Joins: super-pizza-cat (~super-piz@h184-61-213-185.wtfrwi.broadband.dynamic.tds.net)
[23:26:55] *** Quits: super-pizza-cat (~super-piz@h184-61-213-185.wtfrwi.broadband.dynamic.tds.net) (Client Quit)
