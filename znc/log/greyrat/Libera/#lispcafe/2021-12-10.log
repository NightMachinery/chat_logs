[00:00:00] *** Joins: phossil (~tophullyt@162.213.177.125)
[00:01:39] <GreaseMonkey> honestly though, Python is "OK I guess", i'm at least at the acceptance phase with it, but the caveat is i always have to shove it through mypy
[00:02:18] <selwyn> i don't like it but what i don't like more is the acceptance it gets amongst academics
[00:02:19] <sham1> Well if that's what you're paid to use then you better believe that you'll be using Python now
[00:02:56] <sham1> And as far as academics are concerned, it's because it's a language they know
[00:03:07] *** Quits: phossil (~tophullyt@162.213.177.125) (Client Quit)
[00:17:27] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Remote host closed the connection)
[00:17:51] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[00:18:11] *** Quits: zbrown[m] (~zbrownm]@2001:470:69fc:105::1:33db) (Ping timeout: 252 seconds)
[00:18:13] *** Quits: Duuqnd (~duuqnd@2001:470:69fc:105::e9c0) (Ping timeout: 240 seconds)
[00:19:19] *** Quits: Gnuxie (~gnuxie@user/gnuxie) (Ping timeout: 250 seconds)
[00:19:32] *** Quits: Arcsech (~arcsechma@2001:470:69fc:105::1:797) (Ping timeout: 250 seconds)
[00:19:45] *** Quits: hayley (~theemacss@user/hayley) (Ping timeout: 250 seconds)
[00:19:45] *** Quits: sp (~sp@user/susam) (Ping timeout: 250 seconds)
[00:19:50] *** Quits: sepanko (~sepanko@user/sepanko) (Ping timeout: 252 seconds)
[00:20:06] <kakuhen> selwyn: re: noncommutative algebra, i learned just enough for representation theory and the basics are ok
[00:20:24] <selwyn> cool
[00:20:51] <kakuhen> anything more complicated than Krull-Remak-Schmidt however seems even worse than the worst of commutative algebra ive encountered w
[00:23:04] <kakuhen> regarding krull-schmidt, the existence of the decomposition is pretty simple
[00:23:15] <kakuhen> but proving uniqueness is an awful mess of matrix calculations
[00:24:57] <kakuhen> too bad the uniqueness part of the theorem is why it's useful and we care about it :))
[00:25:25] <kakuhen> e.g. if you have kG modules with L + M = L + N then you can conclude M = N with it
[00:26:19] <kakuhen> more importantly, any finite dim. representation of a finite group G over k will be a direct sum of indecomposable representations, in a unique way, and this works regardless of char(k)
[00:31:37] *** Joins: Inline (~Inline@aftr-37-201-241-234.unity-media.net)
[00:32:24] <kakuhen> but yeah, once you know Maschke, Artin-Wedderburn, Krull-Schmidt, and maybe some non-commutative analogues of e.g. Nakayama's lemma, that's enough non-commutative algebra for life
[00:32:46] <kakuhen> i refuse to believe in the existence of non-commutative rings
[00:36:32] *** Joins: sp (~sp@user/susam)
[00:42:01] <Alfr> kakuhen, wait, you refuse to believe in the existence of n×n matrix multiplication?
[00:42:16] <kakuhen> only for n>1
[00:42:21] <Alfr> I see.
[00:45:14] <selwyn> in qm we have the baker campbell hausdorff formula which gets used all the time
[00:47:16] <selwyn> i enjoy the proof of the cayley-hamilton theorem using nakayama's lemma
[00:51:47] *** Joins: sepanko (~sepanko@user/sepanko)
[00:59:57] <shka> selwyn: of all of those people, i only know the hausdorff
[01:05:45] <shka> selwyn: statistical-learning random forest is much faster then the sk-learn
[01:05:55] <shka> and you don't even need that
[01:06:20] <selwyn> hayley: baker strikes again
[01:06:39] <shka> selwyn: https://github.com/masatoi/cl-random-forest
[01:06:40] -ixelp- GitHub - masatoi/cl-random-forest: Random forest in Common Lisp
[01:07:00] <shka> statistical-learning is very much like like cl-random-forest internally 
[01:07:02] <shka> but OO
[01:07:53] <selwyn> you must know hamilton :o
[01:08:16] <shka> oh, right
[01:08:25] <shka> hamilton as well
[01:18:13] <shka> selwyn: one thing that people tend to ignore when it comes to python, is that even calling C has a performance penalty 
[01:19:27] <shka> and you can't inline C library function calls either
[01:19:41] <shka> which is a problem if you are doing math
[01:21:34] <shka> also, this is, i think part of reason why sk-learn is not that fast
[01:21:49] <shka> because, you see, they actually compile subset of python into C
[01:21:53] <shka> which is all good
[01:23:50] <shka> but it is a problem because you are getting fetched numpy arrays
[01:24:10] <selwyn> right
[01:24:14] <shka> and you are using numpy functions to extract values out of those arrays
[01:24:15] <selwyn> sometimes i fear cffi is not fast enough
[01:24:24] <shka> so you can't even inline your array access
[01:25:49] <shka> which is, a think a great hindrance that python crowd tends to ignore 
[01:26:36] <shka> because, well, it is convenient to do so
[01:29:01] <shka> but i think that this is the lesser problem of python machine learning 
[01:29:12] *** Joins: clothespin (~awolven@c-73-209-95-92.hsd1.il.comcast.net)
[01:33:44] <selwyn> the greater problem is that it sucks
[01:34:44] <shka> mmm, the greater problem is that it is really "closed"
[01:34:52] <shka> you can't modify algorithms easily 
[01:35:35] *** Joins: zbrown[m] (~zbrownm]@2001:470:69fc:105::1:33db)
[01:35:38] <shka> not much in terms of code sharing
[01:44:31] *** Joins: dave0 (~davezero@069.d.003.ncl.iprimus.net.au)
[01:44:57] <dave0> maw
[01:46:23] <selwyn> i tried hacking a python algorithm once and it was horrible
[01:46:41] <selwyn> well, i suppose you could blame the codebase, but i don't think it was that badly maintained
[01:47:56] <dave0> bad codebase? uh-uh, bad language.
[01:48:42] <selwyn> amusing to think what would have happened if machine learning came of age in the 80s and everything was done on symbolics
[01:51:22] <Alfr> selwyn, you'd still have humans producing other bad code.
[01:52:07] *** Quits: zbrown[m] (~zbrownm]@2001:470:69fc:105::1:33db) (Read error: Connection reset by peer)
[01:52:09] *** Quits: sepanko (~sepanko@user/sepanko) (Write error: Connection reset by peer)
[01:52:10] *** Quits: sp (~sp@user/susam) (Read error: Connection reset by peer)
[01:53:19] *** Joins: sepanko (~sepanko@user/sepanko)
[01:58:39] *** Joins: sp (~sp@user/susam)
[01:58:39] *** Joins: zbrown[m] (~zbrownm]@2001:470:69fc:105::1:33db)
[01:58:39] *** Joins: hayley (~theemacss@user/hayley)
[01:58:39] *** Joins: Gnuxie (~gnuxie@user/gnuxie)
[01:58:39] *** Joins: Duuqnd (~duuqnd@2001:470:69fc:105::e9c0)
[02:02:29] <shka> selwyn: i think that the main problem is the very idea of "scripting language"
[02:02:47] <shka> over dynamic language, like CL
[02:03:17] <gilberth> "Inheritance has recently fallen out of favor [...] because it’s often at risk of sharing more code than necessary. Subclasses shouldn’t always share all characteristics of their parent class but will do so with inheritance. [...] It also introduces the possibility of calling methods on subclasses that don’t make sense or that cause errors because the methods don’t apply to the subclass." Really?
[02:03:59] <gilberth> Someone didn't get what a subclass is.
[02:04:00] <Alfr> shka, define "dynamic", as I don't think that you mean dynamic environments by that.
[02:04:35] <shka> Alfr: language which allows interactive development
[02:04:51] <shka> as opposed to simply being "scripting language"
[02:05:05] <hayley> What is Liskov substitution principle :S
[02:05:38] <gilberth> hayley: Another word with "sub"?
[02:06:31] <hayley> gilberth: So, which chapter are you up to?
[02:06:43] <Gnuxie> Rust traits are just mixins where all the symbols are namespaced, if that was rust book 
[02:06:59] <Alfr> gilberth, what are you reading? And apart from the authors' inheritance graph being wrong for the thing they try to model, I don't think that's inheritance's fault.
[02:07:19] <shka> Alfr: somehow, we were stuck with this weird idea that all compiled languages are supposed to be static
[02:07:42] <Alfr> shka, yes, but what does that mean? Does bash qualify?
[02:08:02] <shka> a scripting language?
[02:08:19] <Alfr> shka, no dynamic.
[02:08:24] <shka> yeah
[02:08:28] <shka> so is python
[02:08:33] <moon-child> it's statically typed though
[02:08:43] <moon-child> every variable is a string
[02:08:46] <gilberth> hayley: I skipped forward to so called smart pointers (chapter 15). That quote is from 17.1
[02:09:05] <shka> but the issue is, that  for some reason everyone assumed that all dynamic languages are supposed to be interpreted "scripting" languages
[02:09:17] <shka> and not that dynamic honestly
[02:09:24] <shka> because scripts are files
[02:09:36] <gilberth> Alfr: I read this wise Rust book at <https://doc.rust-lang.org/book/ch17-01-what-is-oo.html>
[02:09:37] -ixelp- Characteristics of Object-Oriented Languages - The Rust Programming Language
[02:09:48] * gilberth needs more coffee.
[02:09:58] <shka> encapsulation as the first point
[02:10:00] <shka> eeeeh
[02:11:58] <sham1> That part is written with Blub in mind
[02:12:17] <sham1> It probably doesn't consider Smalltalk or Common Lisp
[02:12:19] <shka> to quote alan kay
[02:12:26] <Alfr> shka, so far you've mentioned things that are not dynamic, but what's your definition for a dynamic language?
[02:12:51] <hayley> There's no mention of inheriting slots, of course.
[02:13:14] <gilberth> Well, I once argued for about 45min with a guy I met at a pub that what he believes would be the correct answer to his interview question "You have two classes, rectangle, and square. Which should be the subclass? (a) rectangle (b) square." he would ask applicants, is wrong. Many people confuse classes with modules.
[02:13:17] <shka> Alfr: dynamic language is a language that facilities redefinition of functions, types, and variables during the runtime 
[02:13:25] *** Quits: euandreh (~euandreh@2804:14c:33:9fe5:1b4:2cec:47c3:871e) (Ping timeout: 240 seconds)
[02:13:36] <shka> which, python technically does, but not very well
[02:13:43] <hayley> Foo, Ubuntu wants to install vi on my machine again.
[02:13:50] * gilberth nods to what shka said.
[02:14:02] <Alfr> shka, ah ... so you want an efficient dynamic language. ;)
[02:14:11] <selwyn> i met an ex c++ programmer in the pub who told me what it was like in the 90s
[02:14:14] <moon-child> gilberth: I am curious, what did he say?
[02:14:20] <shka> for instance, there is no way to update python class AND all of their instances
[02:14:27] <selwyn> 'it was easy money anyone could get it i don't know shit about programming'
[02:14:35] <selwyn> honesty from the c++ community
[02:14:39] <Alfr> shka, or something where you have the compiler (or a jit) handy at runtime?
[02:15:04] <gilberth> moon-child: He said that a rectangle must be the subclass of square because it has more slots.
[02:15:11] <shka> Alfr: honestly, i would rather use common lisp for everything
[02:15:20] <sham1> Well obviously you make the square a subclass of the rectangle and disable mutation. Indeed, changing width or height will always produce a new rectangle based on the old one, and then you could convert the rectangle to a square if it meets the requirements
[02:15:28] <shka> it already does 99% of things i want 
[02:16:29] <sham1> Same with circles and ellipses. It's only a problem if you have mutation
[02:16:34] <gilberth> moon-child: After I explained to him, why he is wrong, that guy bought me a beer and said "I'd hire you."
[02:17:06] <hayley> https://www.youtube.com/watch?v=6P4ELM0nB9M
[02:17:06] -ixelp- Messages (Remastered 2003) - YouTube
[02:17:08] *** Quits: sepanko (~sepanko@user/sepanko) (Quit: Client limit exceeded: 20000)
[02:17:37] <Alfr> sham1, there's also CHANGE-CLASS.
[02:17:58] *** Joins: sepanko (~sepanko@user/sepanko)
[02:18:14] <gilberth> Well, the set of squares is a subset of the set of rectangles. I could use a square for a rectangle but not vice versa.
[02:18:24] *** Quits: zbrown[m] (~zbrownm]@2001:470:69fc:105::1:33db) (Quit: Client limit exceeded: 20000)
[02:18:25] <shka> Alfr: and there is a very strong assumption that everything comes from files, somehow
[02:18:30] *** Quits: Duuqnd (~duuqnd@2001:470:69fc:105::e9c0) (Quit: Client limit exceeded: 20000)
[02:18:30] *** Quits: sp (~sp@user/susam) (Quit: Client limit exceeded: 20000)
[02:18:41] *** Joins: zbrown[m] (~zbrownm]@2001:470:69fc:105::1:33db)
[02:18:48] <shka> so in summary, i think that we could use CL for everything instead
[02:18:56] *** Joins: Duuqnd (~duuqnd@2001:470:69fc:105::e9c0)
[02:18:57] <sham1> with CL yes
[02:19:05] *** Joins: sp (~sp@user/susam)
[02:19:33] <shka> write low level, restricted CL for performance code, write interfaces in CL, write high level code for taming data in cl
[02:19:55] <Alfr> shka, I'm more curious about a non-lisp fitting your bill.
[02:20:06] <shka> well, julia i guess?
[02:20:17] <shka> or smalltalk
[02:20:23] <selwyn> julia is better in some ways, but tooling not mature enough imo
[02:20:33] <selwyn> wrt numerics
[02:24:02] <hayley> https://www.youtube.com/watch?v=M2irYat2wf4 ← Same album.
[02:24:03] -ixelp- Julia's Song (Remastered 2003) - YouTube
[02:27:42] <sham1> Futhark language is interesting if one wants parallel numerics on the GPU
[02:29:14] <moon-child> rc > uniqueness for numerics
[02:29:16] <moon-child> imo
[02:29:25] <moon-child> (cf apl, of course)
[02:29:40] <GreaseMonkey> [11:44:20] <shka> for instance, there is no way to update python class AND all of their instances <-- adding the mechanism in isn't particularly difficult but there's a good chance someone will yell at you for doing it w/ a metaclass
[02:30:12] <sham1> APL is an interesting notation, but it's also very weird
[02:30:23] <shka> GreaseMonkey: yes, but it is not present in python as is
[02:30:40] <sham1> Well Guido probably wouldn't approve
[02:30:52] <sham1> Gotta keep the language simple to a fault
[02:30:53] <GreaseMonkey> i'm largely hoping that at some point one of the macro PEPs will get approved
[02:31:10] <GreaseMonkey> but on the other hand... Nim exists
[02:31:29] <moon-child> sham1: julia is weird too
[02:31:35] <sham1> Hy also exists if one really wants to interact with the Python ecosystem
[02:31:35] <moon-child> as is lisp
[02:31:41] <GreaseMonkey> Hy is also slow as hell
[02:32:04] <sham1> Is it? Doesn't it compile to the same bytecode as ordinary python
[02:32:16] <GreaseMonkey> like sure, the code it produces will be of reasonable speed relative to regular Python, but it still takes about a second for a basic program to compile
[02:32:26] <sham1> So I don't know why it'd be that much slower
[02:32:32] <sham1> Ah
[02:33:12] <GreaseMonkey> and of course, part of why you'd want to use Hy is because of some dynamicness... but honestly, if you're in the Python ecosystem, then using Python directly in a dynamic way would be less painful
[02:34:51] <sham1> One thing I don't understand is why a lot of these alt-lisp dialects adopt the "fad" of using square brackets for some stuff. Is it really due to Clojure or is there something else there
[02:35:09] <GreaseMonkey> probably Clojure but it's also been used in a few Scheme dialects
[02:35:13] <sham1> I mean, Racket also uses square brackets in idiomatic code but they're not required
[02:35:36] <sham1> R6 also seems to explicitly allow them while R7 says that they're reserved
[02:35:46] <GreaseMonkey> not sure what came first though but i suspect the "we shouldn't use parens for everything because it scares people" thing has been around since long before Clojure
[02:36:52] <sham1> The option is fine, but to make them mandatory just feels odd
[02:55:47] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Quit: WeeChat 3.3)
[03:05:23] <hayley> https://www.cvedetails.com/cve/CVE-2021-38759
[03:05:23] -ixelp- CVE-2021-38759 : Raspberry Pi OS through 5.10 has the raspberry default password for the pi account. If not changed, att [...]
[03:05:38] <hayley> Ah, already linked it here. But still funny.
[03:06:06] <selwyn> didn't mac os x store a password in plaintext at some point
[03:15:44] *** Joins: euandreh (~euandreh@2804:14c:33:9fe5:9808:86a6:acca:9c5)
[03:17:33] * hayley fills out the state of Rust survey, cause she does write Rust technically
[03:17:40] * hayley uploaded an image: (32KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/onjdsWisltxmygIXDrvKBOGr/Screenshot%20from%202021-12-10%2010-44-51.png >
[03:17:42] <hayley> This is technically very correct!
[03:22:23] <hayley> According to the survey, CL is a "dynamic functional language".
[03:22:31] * hayley uploaded an image: (11KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/oipOUbstIlENWIwqOYoSXLQe/bruhcha.jpg >
[03:25:00] *** Quits: shka (~herr@109.231.0.226) (Ping timeout: 265 seconds)
[03:26:24] <gilberth> I still don't know what I should make of Rust. It feels like a low-level language, as you need to chose and constantly name your kind of pointer you need. What shall it be? A Box, an Rc, an Arc, a RefCell, or would a "reference" do? Why should a function care where an objected is allocated? What does this do to modularity?
[03:27:55] <gilberth> But I need further reading and hands-on experience to say.
[03:28:53] <hayley> People tend to pick one, so there's no modularity. Sometimes they pick Arc just to be the most useful, but that's also the slowest. 
[03:29:56] <hayley> "Anything else we should know?" "<pastes Design Principles of Smalltalk>" 
[03:30:54] <hayley> beach usually says that you are either not modular, or you're slow with C, and that still seems to be the case.
[03:38:46] <gilberth> Yes, milady, yes, indeed.
[03:39:37] <gilberth> Rust feels like a scam at this point.
[03:40:38] <Gnuxie> That or they write this bullshit to try convince themselves 
[03:40:49] <selwyn> this quantum natural language processing is something else
[03:44:30] <gilberth> Gnuxie: I don't know. Do people play scams to themself? I fear, they do.
[03:46:48] <Gnuxie> It's defending their own personal investment into the scam 
[03:46:58] <Gnuxie> It hurts to confront something like that 
[03:48:20] <gilberth> What makes me angry is that Rust is advertised as needing no GC, while they chose the worst GC ever namely reference counting. And that is the scam. Or at least I personally perceive it that way.
[03:49:57] <gilberth> And this book I am reading is full of false statements. This is either ignorant or dishonest. I am not sure which.
[03:56:19] <Gnuxie> To me the biggest scam is the claim that it is empowering. The language is about taking power away from individuals really
[03:56:43] * gilberth nods.
[03:58:09] <gilberth> Perhaps it's about job security? Who knows? I mean, when you lower productivity, you increase job demand, don't you? /me shrugs.
[04:02:04] <Gnuxie> Well according to stack overflow the majority of people who vouch for it (90+%?) Can't even program in it iirc 
[04:03:13] <gilberth> Gnuxie: Really? Oh. Can they program at all?
[04:06:31] <gilberth> I was making fun of Go. But compared to Rust, Go is a nice language. At least I managed to get up to speed with it real quick. Rust feels like an April's Fool Day prank. Or a wet dream of compiler makers on how to annoy users the most with verbose warnings and error messages while not doing their own homework.
[04:07:04] <Gnuxie> I think so, I think the question was like "what is favourite language" followed by "what language do you want to learn the.most" and a majority of respondents answered rust for both 
[04:07:22] <Gnuxie> Dunno if hayley remembers and can link to this 
[04:09:11] <gilberth> There are people who enjoy Rust? I could understand the latter as you may want to learn a language for other reasons than liking it. Heck, I learn Rust right now while I don't like it at all.
[04:10:16] <Gnuxie> Well a lot of programming just is masochistic by nature 
[04:10:31] <Gnuxie> Of course there will be people who enjoy that 
[04:11:02] * hayley looks through logs
[04:11:26] <hayley> It'd probably be on r/programmingcirclejerk.
[04:11:53] <gilberth> And in general I don't understand why learning a language is considered to be hard or time-consuming. Learning the available libraries, granted. But the language? They are all alike, you only have to memorize the syntax and vocabulary and restrictions imposed for whatever reason.
[04:12:08] <hayley> Prolog is like C to you?
[04:13:02] <gilberth> hayley: Prolog is very different indeed. I was taking about the family of procedural languages.
[04:13:05] <Gnuxie> *no-defun-allowed* It was on PCJ, I believe it was the 2019 survey 
[04:13:05] <hayley> I guess all the Von Neumann-ish languages are sort of similar, but looping is different to mapping is different to recursion is different to "fuck it, LEFT OUTER JOIN" to etc.
[04:13:26] * hayley searches
[04:13:54] <hayley> Aha! https://www.reddit.com/r/programmingcirclejerk/comments/gru9ym/rust_held_onto_its_spot_as_the_most_beloved/
[04:13:55] -ixelp- Rust held onto it’s spot as the most beloved language among the professional developers we surveyed. That said, the majo [...]
[04:13:57] <gilberth> hayley: Yes, but once you learned programming none of those will come as a surprise.
[04:15:18] <hayley> ixelp cut off the punchline.
[04:15:25] <Gnuxie> Thar's it 
[04:15:36] <hayley> "Rust held onto it’s spot as the most beloved language among the professional developers we surveyed. That said, the majority of developers who took the survey aren’t familiar with the language."
[04:17:18] <Gnuxie> Someone had actual numbers iirc 
[04:17:57] <hayley> No numbers in the blog post, just manufacturing consent to it.
[04:18:27] <hayley> "It has also brought some interesting features – like affine types and hygienic macros – into the mainstream discourse.  Coupled with an open development process, it makes sense that many programmers (even those that don’t use it) hold Rust in high esteem." o rly
[04:19:20] <hayley> https://insights.stackoverflow.com/survey/2020#technology-programming-scripting-and-markup-languages Only 5.1% of participants use Rust.
[04:19:49] <Gnuxie> Well there it is then 
[04:20:38] <gilberth> Ok. What is happening here? Some marketing campaign? Stupidity? Ignorance? Some secret agenda by a secret society?
[04:20:45] <hayley> Note that the definition of "loved" is very prone to survivorship bias, as it measures "% of developers who are developing with the language or technology, and have expressed interest in continuing to develop it."
[04:21:00] <hayley> Well, it is survivorship after all.
[04:21:13] <gilberth> lol
[04:21:52] <gilberth> What is it called again? Stockholm syndrome?
[04:22:24] <hayley> In the 2021 survey, Clojure is second most loved, and LISP is somewhere in the middle (somewhat better than Erlang though). Well, if I had to use a PDP 10 to work, I'd be pissed too.
[04:22:34] <selwyn> are affine types what you were talking about earlier
[04:22:39] <selwyn> objects cant get used more than once
[04:22:57] <hayley> Linear requires exactly one use, affine allows for one or zero uses.
[04:23:22] <selwyn> ok lol
[04:24:01] <hayley> But IIRC the Rust compiler effectively makes things linear by inserting calls to drop() which counts as a use.
[04:25:33] <selwyn> goodnight everyone
[04:25:44] <hayley> Take care.
[04:25:56] <dave0> byes selwyn 
[04:28:04] <hayley> https://www.reddit.com/r/programmingcirclejerk/comments/rbufhz/do_you_ever_avoid_submitting_something_on_hn_so/ A: yes, someone still wants me to add CL-PPCRE compatible functions to my RE engine
[04:28:06] -ixelp- Do you ever avoid submitting something on HN so devs won’t ruin it? : programmingcirclejerk
[04:30:44] <gilberth> hayley: Sounds good. I have not yet got around to have PCRE semantics. Tell me when that someone figured it out, as it makes my brain hurt.
[04:31:18] <hayley> gilberth: The question was about avoiding having people ruin projects.
[04:31:27] <hayley> PCRE would be ruining it, yes.
[04:31:51] <gilberth> Would it?
[04:32:46] <hayley> 50-50 chance, really.
[04:33:12] <gilberth> But, yes, milady. I noticed your point, I was trying to be somewhat funny or sarcastic as I believe nobody really grasps, that PCREs match different from POSIX REs.
[04:33:26] * hayley decides to reset her SICL repository before embarking on global value numbering.
[04:35:13] <gilberth> And I feel a bit like this with McCLIM. Ruined. Nah, almost.
[04:36:44] * gilberth gets an email that his keyboard is on its way. .oO(Now? In the middle of the night?)
[04:37:31] <hayley> "PS I was interested in how you found the bug [in the Handbook] - I read your tweets about it. What are you working on, if you don't mind my asking?"
[04:39:00] <gilberth> Heh.
[04:42:27] <hayley> Richard Jones, who I am in contact with, works on the Sapphire concurrent compacting collector. So I don't just want to say "beach wants to use the Doligez-Leroy GC, but I think it's a poor choice with mutability, so instead I think a Pauseless/Immix hybrid would probably get everyone what they want."
[04:49:43] <kakuhen> > the majority of developers who took the survey aren’t familiar with the language
[04:49:47] <kakuhen> hayley: didn't this happen last year too
[04:50:09] <hayley> That was the 2020 survey.
[04:53:12] <kakuhen> well its accurate
[04:53:48] <kakuhen> recently when drinking with some friends, some of them happen to be engineer-types, and at one point in some discussion on what languages they use, they were all blindly agreeing, without any explanation whatsoever, why rust would be great to use
[04:57:18] <kakuhen> i normally like to have fun conversations with friends, so i just stayed silent hoping they'd stop blindly praising rust
[04:57:25] <kakuhen> and it happened; overall fun night
[04:57:32] <kakuhen> note by recently i mean "two weeks ago"
[04:57:50] * hayley thinks she included too much life story in the response email.
[04:57:55] <gilberth> They did? Have you asked them, why Rust would be great to use?
[04:58:20] * gilberth does not believe hayley did.
[04:58:21] <moon-child> ehh probably fine
[04:58:26] <moon-child> strictly business relationships are no fun
[04:58:30] <hayley> TL/DR "I used to work on Netfarm, learnt concurrent hash tables, compiler diddling and GC, then I stopped working on Netfarm, and now I know a bunch about hash tables, compiler diddling and GC."
[04:58:50] <kakuhen> gilberth: i wasnt drunk enough to have fun in baiting people on rust
[04:59:12] <kakuhen> so i didnt say anything
[04:59:14] <gilberth> hayley: That's fine. You were asked, weren't you?
[04:59:31] <hayley> Oh, and "now beach wants to use Doligez-Leroy-Gonthier GC and I think it's not a good idea, but I don't know anything better."
[04:59:48] <hayley> gilberth: Yes, but I could just say the latter part.
[05:00:54] <gilberth> hayley: It's fine. You might get into a good discussion about GC and language runtime design in general.
[05:01:04] <hayley> Hopefully so.
[05:02:13] <gilberth> He was reading your tweets, didn't he? So there is some interest in what you say. And this email asks for more information about you. That's great.
[05:02:24] <moon-child> ^
[05:02:30] <hayley> Right.
[05:03:11] <gilberth> kakuhen: Oh yes, no point in arguing with the brain washed, I guess.
[05:10:41] * hayley getting her money's worth out of applied-langua.ge email, though doesn't pay for the server.
[05:11:39] <gilberth> This isn't your server?
[05:11:40] *** Quits: Catie (~user@user/catie) (Quit: going home)
[05:11:57] <hayley> I have ssh access, but Gnuxie pays for it.
[05:12:26] <gilberth> Ah, nice. But the domain is yours?
[05:12:40] <hayley> She also pays for the domain.
[05:13:20] <gilberth> But still yours? Or is it Gnuxie's?
[05:13:31] <hayley> My parents still sniff out my bank account, so it is hard to justify getting a VPS without describing why.
[05:13:54] <gilberth> Your parents do what?
[05:13:58] <hayley> As in, who chose it? IIRC I came up with the name "Applied Language" and the domain name, and I'd know cause it's a terrible name.
[05:14:06] <gilberth> Get another bank account, hayley.
[05:15:02] <gilberth> Grow up! /me shakes hayley.
[05:16:44] <gilberth> And applied-langua.ge is a fine name.
[05:23:19] * hayley spots a value numbering analysis in Cleavir from 2018.
[05:25:26] <hayley> Okay, it bit rotted.
[05:26:08] <hayley> Fine, I have the paper open, I can implement it again.
[05:30:13] *** Quits: random-nick_ (~random-ni@87.116.166.234) (Ping timeout: 252 seconds)
[05:47:03] <gilberth> Have I mentioned that rust-mode for Emacs is completely broken?
[05:51:03] <hayley> Checks out.
[05:55:43] *** Quits: clothespin (~awolven@c-73-209-95-92.hsd1.il.comcast.net) (Remote host closed the connection)
[06:01:01] <moon-child> hmm
[06:01:13] <moon-child> if I treat pixels as little squares for the purpose of antialising, no one will mind, right?
[06:01:15] <moon-child> right?
[06:01:57] * moon-child does _not_ want a cos() call in his fragment shader
[06:02:01] <hayley> One way to find out?
[06:02:42] <gilberth> Pixels are square, aren't they?
[06:03:25] <moon-child> gilberth: a pixel is a point sample
[06:03:44] <moon-child> buuuuut as rendered on most monitors, they're square-ish
[06:04:03] <gilberth> Yes, these days.
[06:05:25] <gilberth> Hmm, I never saw pixels as point samples. You get into trouble when you do. Hence filtering for scaling e.g.
[06:06:20] <moon-child> http://alvyray.com/Memos/CG/Microsoft/6_pixel.pdf
[06:07:29] <moon-child> also I just realised doing this aa thing properly is more complicated than I thought.  I need to integrate max(f(x),g(x)), so I need to solve on-the-fly for their intersections
[06:07:59] <gilberth> Yes, but ...
[06:08:34] <gilberth> I mean, even a camera does not really take point samples.
[06:08:38] <moon-child> that is, max(f(x),g(x),h(x)...).  But _most_ of the time there will only be one.  Some consolation!
[06:09:41] <gilberth> moon-child: What are you hacking?
[06:10:19] <moon-child> gpu text rendering still
[06:14:26] <gilberth> ok. But when you antialiase, don't you see pixels as squares and sum the values over that square to a get sample? /me is puzzled.
[06:15:29] <moon-child> depends on aa algorithm
[06:15:57] <gilberth> ok. I'll shut up.
[06:17:50] <Alfr> moon-child, how about sin(pi/2-p)?
[06:18:24] <hayley> 🤔
[06:18:54] <moon-child> gilberth: something like this, if you will excuse my terrible handwriting https://files.catbox.moe/wt1o4p.jpeg
[06:19:38] <moon-child> Alfr: what do you mean?
[06:20:01] <Alfr> moon-child, only quipping about you disliking cos.
[06:20:29] <moon-child> ._.
[06:22:00] <gilberth> moon-child: So you want to integrate over a circle? Makes sense.
[06:22:08] <moon-child> (except, hmm, I think if I take a circular sample I'm supposed to debias the parts farther away from the centre?  Something like that.)
[06:22:40] <hayley> What the hell is Φ? That someone's idea of the empty set/pool/etc?
[06:22:57] <hayley> Must be, I guess.
[06:24:17] <gilberth> moon-child: Do you take all your notes/thoughts with a note book?
[06:24:21] <moon-child> gilberth: yeah.  The circle is not the hard part--only annoying--the hard part is when there are multiple curves intersecting the sample
[06:24:43] <moon-child> gilberth: I rotate between three notebooks and a couple of text files, depending on what is closest to hand
[06:25:15] <gilberth> moon-child: I see. And those curves are what? Bezier patches?
[06:26:29] <moon-child> yeah.  I wanted to generalise to arbitrary quadratics(/cubics), but only because I do not know enough maths to take advantage of the fact that the curves are bezier curves
[06:26:32] * gilberth takes his scribblings on loose blank paper sheets.
[06:29:12] <gilberth> moon-child: Hmm, unfortunately for set operations one Bezier curves there are really only iterative approach. /me was thinking along the line that a circle has a good bezier approximation. But I am not particular good at calculus.
[06:30:01] <gilberth> And not at typing either, it seems.
[06:35:50] <moon-child> hmm, actually I think the situation may not be so bad
[06:36:06] <moon-child> I don't think the curves ever actually intersect each other in practice
[06:36:54] <moon-child> so I can probably(?) get away with just adding/subtracting them, and breaking up into multiple definite integrals for the case when a curve starts/stops in the middle of a sample
[06:40:54] <moon-child> (though maybe when I go to take care of the details something will be missing.  It'll still be more correct than slug, which lengyel keeps touting as 'perfect', so I'm happy either way)
[06:41:09] *** Joins: robin (~robin@user/terpri)
[06:41:55] <moon-child> https://graphics.cs.illinois.edu/wp-content/uploads/2019/09/paper1013-main.pdf  damn!  Looks like somebody beat me to it
[06:50:03] <hayley> Well, I have all of https://arxiv.org/pdf/1303.1880.pdf except confluence and a similarity relation which ignores value numbers. I've got an idea of how to approach the latter, as gilberth needs one to construct DFAs.
[06:56:54] <hayley> It spots (let* ((x 2) (y x)) (list x y)), which is straight-line code and thus doesn't need either function yet.
[06:57:42] <hayley> Better, I didn't check if the inputs were lexical locations or not, so I have accidental constant propagation too. :)
[07:40:41] *** Joins: dec0d3r (~dec0d3r@2001:8003:480a:e00:e07:e7c3:7efc:ed0f)
[08:08:14] *** Quits: semz (~none@user/semz) (Ping timeout: 265 seconds)
[08:20:41] *** Joins: semz (~none@user/semz)
[08:54:01] *** Quits: kakuhen (~kakuhen@user/kakuhen) (Remote host closed the connection)
[08:56:22] *** Quits: dec0d3r (~dec0d3r@2001:8003:480a:e00:e07:e7c3:7efc:ed0f) (Quit: Leaving)
[09:07:21] *** Quits: Alfr (~Alfr@user/alfr) (Quit: Leaving)
[09:15:55] *** Quits: MichaelRaskin (~MichaelRa@ipb21a9944.dynamic.kabel-deutschland.de) (Quit: MichaelRaskin)
[09:18:09] *** Quits: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de) (Quit: Leaving)
[09:26:56] * hayley decides it's time to visualise the results. "Oh, I'll just replace aliased locations with just one, and there will be fewer locations!"
[09:27:44] <hayley> Problem: which location do you pick? The definition of the location has to dominate all the others, else you've now just invented a use of an undefined location.
[09:34:39] <moon-child> wouldn't it make more sense to create a new location and make its lifetime a superset of all the aliasing ones?
[09:34:50] <moon-child> I guess--idk how you are representing control flow.  But that seems reasonable
[09:35:12] <hayley> I don't think there is a representation of lifetime to go by.
[09:35:38] <moon-child> in that case, why do you care who dominates whom?
[09:35:59] <hayley> Otherwise, yes, picking the location that dominates all other options would produce a location with a lifetime that is a superset of all locations.
[09:36:29] <hayley> Lifetimes and domination aren't explicitly represented, but I have to care about them because Cleavir IR is still an imperative program.
[09:36:54] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Ping timeout: 276 seconds)
[09:37:45] <moon-child> how can you perform register allocation without such information?  Or do you materialise it only in the register allocator?
[09:38:23] <hayley> Yes, currently liveness information is only computed before register allocation.
[09:41:54] <moon-child> those seem like useful things to represent, generally ... :)
[09:42:39] <moon-child> (but perhaps, like ssa, they are considered insufficiently powerful and so thrown out with bathwater?)
[09:43:44] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[09:48:27] <gilberth> I have a Rust question. Does { let x = <blah>; foo(x,x); } \eqv { foo(<blah>,<blah>); } hold? (Provided <blah> has no side effects). It does not in my case where x is a Rc<RefCell<T>>. Am I missing sth?
[09:49:58] <moon-child> gilberth: in that case, could you not say that <blah> has the side-effect of memory allocation?
[09:50:55] <moon-child> (memory allocation is a side effect iff you have mutation; hence why haskell gets to call itself pure)
[09:51:24] <gilberth> Which memory? This is like saying in C { int x = 5; foo (x, x); } is not the same as foo(5,5), because 'x' need to be allocate on the stack.
[09:51:38] *** Joins: Alfr (~Alfr@user/alfr)
[09:52:10] <moon-child> sure, but Rc<RefCell> is a pointer
[09:52:26] <moon-child> so it is more like  int x = 5; foo(&x, &x)  vs  foo(&(int){5}, &(int){5})
[09:52:46] <moon-child> that is, after the callee mutates through one parameter, it may observe that change through the other
[09:54:19] <moon-child> (or, for that matter, (let ((x (list 0))) (f x x))  vs  (f (list 0) (list 0)))
[09:56:02] <gilberth> Not happening. Here is my trivial code <http://termbin.com/o2xn> I am still learning things.
[09:56:37] <gilberth> I get a runtime error.
[09:57:29] <moon-child> oh, I see.  I think there is some rule about scoping and releasing of borrowed thingies?
[09:57:47] <moon-child> What happens if you wrap a layer of curly braces around the prints?
[09:58:20] <gilberth> One second. The runtime complains "already borrowed".
[09:58:46] <moon-child> oh, hmm.  Wrap braces around *(&mut *((*x).q).borrow_mut()) + 1?
[09:59:20] <gilberth> Braces?
[09:59:38] <moon-child> { }.  But I just tried and that has no effect
[10:00:45] <gilberth> Is my code just silly? I am still struggling to get around most basic concepts.
[10:00:46] <moon-child> if I change to 'let tmp = ...borrow_mut; *...borrow_mut = tmp', it works fine.  But I am not quite sure why
[10:01:34] <gilberth> See, moon-child, this is what puzzles me. I wonder what I am missing.
[10:04:42] <hayley> You can't have two mutable reference live at once. .borrow_mut() produces a mutable reference at runtime, and crashes if it'd break that rule.
[10:04:51] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 252 seconds)
[10:05:59] <moon-child> hayley: that makes sense, but then why does the failure happen after 'fails' returns, in the print?
[10:06:05] <hayley> idk, but I don't see why you want Rc<RefCell<blah>> instead of using Rc<blah>. Seems contrived.
[10:06:12] <moon-child> (or, I should say, right before the print)
[10:06:59] <hayley> On my machine I see lossage in fails.
[10:07:25] <gilberth> What I could understand is that there are two "open" .borrow_mut()s. That would make sense. But "*(&mut *((*x).q).borrow_mut()) = *(&*((*x).q).borrow()) + 1;" fails as well.
[10:07:36] <moon-child> oh--you are right.  I was misreading the line number
[10:08:13] <moon-child> I guess, you can not have any borrow open at the same time as another mutable borrow is open
[10:08:14] * gilberth regrets asking this question.
[10:08:19] <moon-child> (but you can have many immutable borrows at once)
[10:08:26] <hayley> Right.
[10:08:47] <moon-child> point is to maintain referential transparency.  Why they chose to do it in the worst possible way, I have no idea
[10:08:53] <hayley> That breaks the "shared ^ mutable" rule.
[10:08:53] <moon-child> (well, I do, but I try to avoid acknowledging it)
[10:08:57] <gilberth> moon-child: But why is it open?
[10:09:23] <moon-child> gilberth: I guess it is not guaranteed to close until the end of the lexical scope, and the compiler did not bother to close it earlier for you
[10:09:28] <hayley> Evaluation order, methinks.
[10:09:31] <gilberth> I mean, not both the lhs and the rhs of the '=' need to be evaluated in parallel.
[10:09:50] <hayley> borrow_mut is called first, and gets killed only after the assignment.
[10:10:02] <gilberth> moon-child: Gosh! Oh dear. Perhaps.
[10:10:15] <gilberth> hayley! Pillow, please!
[10:10:28] * hayley passes pillow
[10:10:40] * gilberth 's head falls save again.
[10:10:46] <gilberth> hayley: Thanks!
[10:10:52] <moon-child> my... https://internals.rust-lang.org/t/rust-expression-order-of-evaluation/2605
[10:11:04] <hayley> FWIW I believe you can drop the dereference, making (*x).q into x.q
[10:11:05] <gilberth> moon-child: Thanks for having patience with my "silly" question.
[10:12:22] <gilberth> hayley: Yes, by an infered deref which the compiler sneaks in. I am fine with it in there for now. I learn still.
[10:17:35] <hayley> Perhaps I can check how many locations some code makes. My silly Collatz conjecture code produces 19 locations without any alias removal, GVN reduces it to 7 numbers.
[10:18:09] *** Quits: phantomics (~phantomic@97-118-135-6.hlrn.qwest.net) (Remote host closed the connection)
[10:23:15] <hayley> Hm, no, I should be fine to just pick any location in an equivalence set, as I end up assigning to it from every instruction that performs an assignment.
[10:45:00] * hayley does that and all the assignment instructions disappear. Good start.
[10:47:34] <hayley> Though I think I need that damn adaptation from register allocation too now. Oh well.
[11:07:43] *** Joins: lisp123 (~lisp123@5.30.23.247)
[11:09:04] *** Joins: treflip (~user@95.79.32.99)
[11:10:13] *** Quits: makomo (~makomo@user/makomo) (Ping timeout: 240 seconds)
[11:11:37] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[11:26:30] <gilberth> Rust is driving me crazy as I am too impatient in implementing a simple s-expression data type.
[11:26:49] <hayley> How much Rc<T> have you used?
[11:27:57] <gilberth> hayley: One around the "Node" data type. It's an Rc<RefCell<Node>>.
[11:28:14] * hayley still doesn't get why we need a RefCell and Rc.
[11:28:22] <moon-child> for mutability
[11:28:46] <gilberth> I could throw in some boxes and some arcs. Ladies, gentlemen, I take a break.
[11:28:53] <hayley> Rc has mutable references though. Rc::get_mut(bla)
[11:29:19] <gilberth> And that works?
[11:30:07] <hayley> IIRC yes.
[11:30:37] <gilberth> Hmm.
[11:31:30] * hayley re-reads
[11:31:52] <hayley> Yes, the book says you can't modify the value stored in a shared one without Rc<RefCell<T>>. Ok
[11:32:25] <gilberth> Yep. But that book does not need to be to correct.
[11:32:53] *** Joins: v3ga (~v3ga@cpe-98-25-21-91.sc.res.rr.com)
[11:33:01] * gilberth contemplates to prepare food as the kitchen still is cleaned up.
[11:33:38] * hayley hurts her head, as she now has to factor in runtime refcounts too.
[11:34:03] <hayley> Now I guess why we know they still use LLVM and haven't written a compiler backend in Rust. :^)
[11:34:40] <gilberth> Because they didn't figure out how to have a tree data structure?
[11:34:55] <hayley> Yep.
[11:35:05] <hayley> Though a graph has doubly linked references, which is worse.
[11:35:31] <gilberth> Use Weak<T>, the book says so.
[11:36:04] <hayley> And that'll help you maintain predecessor and successor lists how?
[11:36:40] <hayley> Quite funny that you're supposed to decide which one is weak. Though I guess you tend to use both lists for the same lifetime.
[11:36:59] <gilberth> Nah, you have an error in your thinking! The compiler just points you to that! Adjust your mind and all will be taken care of!
[11:38:26] * hayley lines up hammer
[11:39:13] <gilberth> You just need to have faith!
[11:39:57] <gilberth> Is there even an EQ operation of Rc<T> or Rc<RefCell<T>> or do I need to number my conses?
[11:41:09] <hayley> Rc::ptr_eq
[11:41:29] *** Quits: OlCe (~user@lfbn-nic-1-117-213.w2-15.abo.wanadoo.fr) (Remote host closed the connection)
[11:41:35] <gilberth> Ah, thanks.
[11:42:10] <hayley> Funny to me that you need two refcounts, both with mutable/immutable checks, in order to mutate a cons.
[11:42:33] <hayley> That's gonna be a pretty expensive RPLACA.
[11:43:03] <gilberth> Yes? But isn't Rust soooo fast? And good for the climate?
[11:43:39] <hayley> Absolutely.
[11:43:41] <gilberth> Seriously, hayley, two refcounts? Where is the other?
[11:43:48] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[11:43:53] <hayley> RefCell has a refcount, no?
[11:44:04] <hayley> Needs to count your borrows at runtime.
[11:44:22] <gilberth> Oh yes! Now that you mention that.
[11:44:30] <moon-child> could just be a flag for whether it's borrowed mutably?
[11:44:41] <hayley> Given that there can only be one mutable borrow, you could have INT_MAX be the "count" for a mutable borrow though.
[11:44:42] <moon-child> hm, no, because if you have n immutable borrows then you make a mutable borrow
[11:44:56] <hayley> You need to count immutable borrows too.
[11:46:18] <hayley> Sadly I can't think of a better way to do "interior mutability", other than "fuck it, this mutation rule is dumb".
[11:46:48] * moon-child whispers: static proof checker
[11:47:16] <gilberth> Does a RefCell work across multiple threads? Or is there an ArefCell, too?
[11:47:33] <hayley> Nope, you want Arc<Mutex<T>> for that.
[11:48:31] <gilberth> And mutability?
[11:49:33] <hayley> It's mutual exclusion, so you can definitely have one writer.
[11:50:03] <gilberth> Hmm. Does rustc agree?
[11:50:08] * hayley wonders how people do lock-free in Rust, if you can only have one writer.
[11:50:16] <moon-child> they have coroutines, right?  Can I use an Rx<Mutex> (or just Mutex), and make it yield on lock?
[11:50:38] <hayley> There's async, but no "official" coroutines AIUI?
[11:50:56] <moon-child> eh
[11:50:57] <moon-child> weird
[11:51:48] <hayley> gilberth: https://doc.rust-lang.org/std/sync/struct.Mutex.html says *mutex.lock().unwrap() = foo works
[11:51:49] -ixelp- Mutex in std::sync - Rust
[11:52:16] <hayley> Can't even do a volatile write on pointers without unsafe though.
[11:54:22] <gilberth> This will be an interesting RPLACA.
[11:55:06] <hayley> Are you going to do threads then?
[11:55:37] <gilberth> hayley: I want to see what it would take to even have that.
[11:55:39] <hayley> Funny that some Rust hacker complained that pervasive mutability in (Emacs) Lisp makes multi-threading impossible...how the fuck do ya do it in Rust.
[11:56:00] <hayley> https://coredumped.dev/2021/04/07/when-pure-function-lie/
[11:56:13] <hayley> "You can’t share function between threads when “normal” code can change the behavior of functions being used in different threads. Functions that look pure might be changing under the hood. In this situation you are cross-pollinating your code with mutable data." Yeah, so?
[11:57:35] *** Joins: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de)
[11:58:17] *** Quits: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de) (Client Quit)
[11:59:08] <gilberth> lol
[11:59:57] <hayley> If they can ever write a half-decent NonBlockingHashMap, I might pay attention next time.
[12:00:07] <gilberth> And BTW CL allows for (setf (char (lambda () "foo") 0) #\b) to fail.
[12:00:35] <moon-child> yeah
[12:00:42] <moon-child> I wish implementations would kill you if you did that
[12:00:45] <moon-child> put literals in ro memory
[12:01:02] <hayley> SICL would, but here is a question...
[12:01:20] <moon-child> I thought sicl hates faults and refuses to try to recover from them
[12:01:24] <gilberth> I have seen CLISP to put literals at read-only memory.
[12:01:30] <hayley> (let ((x <something>)) (values x (compile nil `(lambda () ',x))))
[12:01:41] <moon-child> heh, yes, I have always had the same question
[12:01:45] <hayley> Is <something> literal or not?
[12:01:54] <moon-child> oh, not quite the same
[12:02:15] <moon-child> I think 'literal' is a property of an object that came out of the reader, so no
[12:02:40] * gilberth points to LOAD-TIME-VALUE
[12:02:43] <moon-child> (or at least, not necessarily)
[12:02:52] <moon-child> gilberth: weeellll
[12:03:07] <hayley> I mean, trapping on the more obvious cases is better than no trapping at all.
[12:03:38] <gilberth> Well, I don't remember the exact rules. But (eq '(a b) '(a b)) is allowed to be non-NIL.
[12:04:26] <gilberth> As is (defun foo () '(a b)) (defun bar () '(a b)) (eq (foo) (bar)) for that matter.
[12:06:45] * gilberth continues reading the article hayley posted and trips over more exclamation marks.
[12:07:29] <hayley> "Another part of it is that Common Lisp was conceived in a time when string where just vectors of ascii characters (Similar to C). That made modifying them like modifying normal arrays. But now with the advent of unicode, changing a “character” of string is not so easy." lol, strings are just UCS-4 vectors.
[12:08:20] <gilberth> lol
[12:08:40] <hayley> Apparently this guy works in hardware design for Intel. Now you know why their CPUs are shit!
[12:08:58] <gilberth> A Python example is posted with a function returning (list 1 2 3) and points out that this is cannot be harmed.
[12:10:05] <gilberth> Or rather the function. It will return (1 2 3) each time even when you (rplaca (foo) 42). Surprise! This is hilarious.
[12:10:46] <gilberth> This is so funny, hayley, you lightened my mood.
[12:10:53] <hayley> I have never managed to modify literals by mistake, as far as I remember.
[12:10:58] <hayley> Much ado about nothing!
[12:12:33] *** Joins: OlCe (~user@lfbn-nic-1-117-213.w2-15.abo.wanadoo.fr)
[12:13:01] <GreaseMonkey> if you don't want to admit how shit your CPUs are, just hide all the skeletons in a yellow book
[12:13:22] <gilberth> And, hayley, strings in CL are no UCS-4 vectors. We have a character data type. Would Unicode go out of fashion, our code will continue to run just fine.
[12:13:35] <hayley> Yes, I mean in representation.
[12:13:38] <GreaseMonkey> in terms of implementation they could be UCS-4
[12:14:01] <hayley> Hypothetically, you could make strings be UTF-8 vectors, and do a whole lot of bullshit to implement AREF/CHAR/etc. No one said AREF has to be O(1).
[12:14:04] <GreaseMonkey> iirc Chicken Scheme has a special type which fits into a primitive
[12:14:17] * moon-child wants characters to be grapheme clusters, using synthetic codepoints
[12:14:22] <gilberth> Sure, but could be anything. My point is: CL was speced before there even was Unicode.
[12:14:25] <moon-child> despite the popular fixnum tagging scheme, no one has adopted this
[12:14:37] *** Joins: notzmv (~zmv@user/notzmv)
[12:16:05] <gilberth> And code which worked in '84 with just US-ASCII works fine these days with Unicode. And that is great.
[12:16:23] <GreaseMonkey> i *think* chicken actually opts for something like a 21-bit value for a character even for 32-bit builds but i could be wrong on that, either way they've worked out a way to make it fit... and of course, AREF - sorry, i mean, uhh, whatever it is in Scheme can still be O(1)
[12:18:21] <gilberth> It's actually more complicated, as #xD800 is not an unicode code point. (CHAR-CODE #xD800) returns NIL with my favorite CL implementation.
[12:18:51] <GreaseMonkey> i like how at least my favourite CL implementation and my favourite Scheme implementation both handle UTF-8 names just fine
[12:19:10] <hayley> #\Car
[12:19:13] <hayley> #\Cat
[12:19:17] <GreaseMonkey> (defun ようこそ () (format t "ワールドへようこそ！~%"))
[12:19:29] <hayley> (write-char #\Cat) => 🐈
[12:19:30] <GreaseMonkey> grammar and choice of words is, as usual, probably incorrect
[12:22:19] * gilberth has #\Left, #\Right, #\Page-Up, #\Insert, #\Help, #\F1 etc.
[12:22:41] <GreaseMonkey> huh
[12:23:23] <gilberth> Cocoa^WNextStep as assigned those to a private use area and I made my CLIM define those for CCL.
[12:23:24] <GreaseMonkey> oh yeah also if you want an example of mutation of a list: (progn (defun foo (&optional (x (list 1 2 3))) x) (rplaca (foo) 42) (foo))
[12:23:41] <GreaseMonkey> CL and the Ruby equivalent will treat the argument as a constructor
[12:23:59] <GreaseMonkey> Python treats the argument default as an object, so in that case you *do* get the mutation
[12:24:42] <hayley> The initial form is evaluated at function definition time, e.g. def foo(x=print("foo")): pass
[12:25:01] <gilberth> Oh, so Python is like (let ((default (list 1 2 3))) (defun foo (&optional (x default) x))?
[12:25:07] <GreaseMonkey> yeap
[12:25:09] <hayley> Precisely.
[12:26:03] <gilberth> So (lambda (x &optional (y (+ x 1))) ...) doesn't work there?
[12:26:40] <hayley> Right.
[12:26:54] <gilberth> Why doesn't that surprise me?
[12:27:20] <GreaseMonkey> because Python still retains warts
[12:27:46] <GreaseMonkey> ...huh, but that arrangement apparently works in Ruby
[12:28:38] <GreaseMonkey> well, with def anyway... doing it with proc is a syntax error
[12:28:57] <hayley> https://www.youtube.com/watch?v=HuXl5LUN7TE
[12:28:57] -ixelp- Stories (Live 1980) - YouTube
[12:29:43] <GreaseMonkey> ...aaaaaaand it's the end of the day after i got my 5G top-up and my arm hates me right now
[12:29:47] <GreaseMonkey> it was fine for quite some time... but not now
[12:32:40] <gilberth> I wonder why the "foo" problem mentioned with (defun foo () "foo") goes away when FOO is instrumented? It must, because there is an exclamation mark behind that statement.
[12:36:40] <gilberth> GreaseMonkey: So 5G really is bad because of all the RF power they use?
[12:36:55] <GreaseMonkey> gilberth: i'm talking about my vaccine booster shot
[12:37:29] <GreaseMonkey> ...although that *could* be good for anecdotal evidence of 5G...
[12:48:11] <gilberth> Ok. Then what does the '5G' stand for?
[12:52:37] *** Joins: shka (~herr@109.231.0.226)
[13:06:26] <hayley> https://www.youtube.com/watch?v=WiyuG20bhO4
[13:06:27] -ixelp- Pink Floyd - Nothing Part 14 (Official Music Video) - YouTube
[13:30:17] * hayley just killed her first redundant assignment!
[13:40:23] <sham1> Sounds cruel
[13:41:07] <hayley> And guess what: SBCL doesn't do that!!!
[13:41:48] <hayley> (disassemble (lambda () (declare (optimize (speed 3))) (let ((x 1)) (setq x 2) (setq x 3) x)))
[13:42:31] <semz> It's a peaceful implementation.
[14:00:12] <selwyn> shka: last night i read about quantum natural language processing and it was a real mindfuck
[14:00:43] <selwyn> at least so far it promises to do nlp in a way that somewhat distantly resembles neural networks
[14:01:22] <selwyn> but instead of a black box of many millions of numbers, you have a much smaller quantum circuit that contains within it linguistic structure
[14:02:05] <shka> selwyn: huh, and you can't do that with a normal computer?
[14:02:15] <shka> do you have the article on hand?
[14:02:38] <selwyn> you can, and people have
[14:02:47] <selwyn> but you eventually run into a problem of exponential scaling
[14:03:01] <shka> oh, that sounds legit
[14:03:08] <selwyn> https://arxiv.org/abs/2012.03755
[14:03:46] <shka> thanks!
[14:04:00] <shka> i will read it eventually 
[14:04:34] <selwyn> what really got me, is that when they came up with this 'quantum' model they were simply trying to resolve some open questions in nlp
[14:04:46] <selwyn> and only later did it turn out to be a natural fit to quantum computing
[14:07:00] <selwyn> re classical vs quantum: a typical space requirement comparison is 8 x 10^22 bits vs. 73 qubits
[14:07:51] <shka> i see
[14:09:57] * hayley wonders where some of the locations disappeared to in her pools.
[14:15:22] <selwyn> hoping to run some of these algorithms over christmas
[14:15:27] <selwyn> which means... python
[14:16:13] <hayley> .oO(Quantum global value numbering?)
[14:18:30] <selwyn> tbh the fact that nlp is suited to quantum computers makes me reconsider my stance that you can't compile on them
[15:06:07] *** Quits: OlCe (~user@lfbn-nic-1-117-213.w2-15.abo.wanadoo.fr) (Ping timeout: 250 seconds)
[15:42:54] *** Joins: abrantesasf (~abrantesa@187.36.170.211)
[15:43:00] *** Joins: OlCe (~user@amontpellier-657-1-25-61.w109-210.abo.wanadoo.fr)
[15:45:19] *** Joins: random-nick_ (~random-ni@87.116.181.93)
[15:53:54] *** Joins: phantomics (~phantomic@97-118-135-6.hlrn.qwest.net)
[15:58:00] <selwyn> til finland has a catgirl prime minister
[15:59:08] <hayley> Minor exception on "all cats are beautiful"
[15:59:18] <selwyn> well
[15:59:22] <selwyn> would disagree with that
[16:01:09] <Gnuxie> https://www.youtube.com/watch?v=MticYPfFRp8 a classic 
[16:01:10] -ixelp- Coding Sucks: Why a Job in Programming Is Absolute Hell - YouTube
[17:10:35] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.3)
[17:10:58] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[17:27:51] *** Quits: Alfr (~Alfr@user/alfr) (Killed (strontium.libera.chat (Nickname regained by services)))
[17:27:55] *** Joins: Alfr (~Alfr@user/alfr)
[17:45:41] *** Quits: abrantesasf (~abrantesa@187.36.170.211) (Remote host closed the connection)
[17:47:16] <shka> yes, that's why i went into data
[17:47:25] <shka> and now i program data
[17:47:27] <shka> :(
[17:48:04] *** Joins: abrantesasf (~abrantesa@187.36.170.211)
[17:51:20] *** Quits: OlCe (~user@amontpellier-657-1-25-61.w109-210.abo.wanadoo.fr) (Remote host closed the connection)
[17:51:28] <pl> honestly, I think programming > data science, not because of specifics of programming or data science, but because of how data science in companies looks like
[17:53:33] <shka> yes
[17:53:38] <shka> that as well
[17:57:56] <shka> but on  the other hand
[17:58:11] <shka> pl: one word: blockchain 
[17:58:33] * pl grabs a rusty rake
[17:59:03] <shka> so, no, it is not all that much better in the programming startups world
[17:59:11] <shka> arguably, not better at all
[18:02:07] <selwyn> going into programming is my backup plan
[18:02:10] <selwyn> but i don't really want to
[18:02:16] <selwyn> everyone complains about it lol
[18:02:28] <ck_> it can be terrible, like most other jobs I guess
[18:04:37] *** Quits: abrantesasf (~abrantesa@187.36.170.211) (Read error: Connection reset by peer)
[18:05:46] <shka> selwyn: wanna teach me?
[18:13:22] *** Joins: abrantesasf (~abrantesa@187.36.170.211)
[18:13:42] *** Quits: abrantesasf (~abrantesa@187.36.170.211) (Remote host closed the connection)
[18:21:20] <shka> :(
[18:22:28] *** Joins: OlCe (~user@amontpellier-657-1-25-61.w109-210.abo.wanadoo.fr)
[18:39:13] <selwyn> programming?
[18:40:49] <selwyn> first step is to spend a day installing anaconda and resolving all broken dependencies
[18:58:44] *** Quits: random-nick_ (~random-ni@87.116.181.93) (Ping timeout: 256 seconds)
[19:03:07] *** Quits: euandreh (~euandreh@2804:14c:33:9fe5:9808:86a6:acca:9c5) (Ping timeout: 252 seconds)
[19:05:02] *** Joins: euandreh (~euandreh@2804:14c:33:9fe5:f0cf:5664:8ee5:8e87)
[19:07:33] *** Joins: christophergray (~christoph@190.148.51.17)
[19:09:26] <shka> selwyn: math actually
[19:10:24] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 265 seconds)
[19:11:34] <selwyn> are you reading the qnlp paper?
[19:12:11] *** Joins: aeth (~aeth@user/aeth)
[19:13:39] <shka> no
[19:13:48] <shka> i am trying to understand algorithm
[19:14:07] <shka> which is pretty simple, actually but somehow i struggle with it
[19:14:08] <shka> https://github.com/Adamdad/Orthogonal-Matching-Pursuit/blob/master/OMP.py
[19:14:09] -ixelp- Orthogonal-Matching-Pursuit/OMP.py at master · Adamdad/Orthogonal-Matching-Pursuit · GitHub
[19:14:19] <selwyn> read that as fursuit
[19:14:43] <selwyn> honestly i find python code very hard to read, harder than english pseudocode or e.g. lisp or java
[19:15:04] <shka> yeah, but here we are
[19:15:11] <selwyn> right
[19:16:09] <shka> anyway, i think that Y is the target, and this algorithm attempts to find columns in matrix that contribute the last to the result
[19:16:54] <selwyn> will have a look in a bit
[19:17:44] <selwyn> trying to remember the last time i tried to understand an algorithm
[19:17:57] <selwyn> i suppose it is important if you are an implementer :)
[19:18:21] <shka> yeah, i want to use this algorithm for tree pruning
[19:19:00] <selwyn> > M x N matrix with normalized columns drawn from N(0,1)
[19:19:06] <selwyn> what a strange object
[19:19:53] <shka> also, defines functions which are never used
[19:20:04] <selwyn> well, many of us have been there
[19:20:40] <shka> what honestly puzzles me is the line 57
[19:21:05] <selwyn> so define_x is not used
[19:21:45] <shka> namely it uses all measurements to calculate the score, even columns which were already eliminated
[19:23:33] <selwyn> i agree
[19:23:55] <selwyn> is that a problem?
[19:23:55] <shka> but i am fairly sure that this is the correct way to do it
[19:24:03] <shka> but i don't understand why 
[19:24:06] <shka> https://github.com/sai-bi/OrthogonalMatchingPursuit/blob/master/src/omp.cpp
[19:24:07] -ixelp- OrthogonalMatchingPursuit/omp.cpp at master · sai-bi/OrthogonalMatchingPursuit · GitHub
[19:24:11] <shka> same here actually
[19:25:35] <selwyn> i believe that the idea is that you are picking basis vectors one at a time
[19:25:54] <selwyn> not 'eliminating' them in any meaningful sense
[19:26:22] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 268 seconds)
[19:26:28] <selwyn> you pick the basis vectors one at a time, and upon each loop step you calculate in l.68 how good that basis is
[19:26:36] <shka> but what prevents the algorithm from picking same vector twice?
[19:26:56] <selwyn> hm good question
[19:27:02] <selwyn> you are updating the residual 'r'
[19:27:11] <selwyn> maybe that takes care of it
[19:27:34] *** Joins: aeth (~aeth@user/aeth)
[19:28:53] <selwyn> i suspect that the residual is perpendicular to all atoms chosen up to that point
[19:29:05] <shka> oh
[19:29:20] <selwyn> which means that the resulting score in the next iteration (calculated in l.57) for those atoms will be 0 due to orthogonality
[19:29:25] <selwyn> i haven't proved any of this though
[19:29:45] <shka> i mean, o in omp stands for orthogonal
[19:29:48] *** Joins: abrantesasf (~abrantesa@187.36.170.211)
[19:29:51] <shka> so... it sounds right
[19:31:19] <shka> screw this, i will tackle this next week
[19:33:06] <shka> but anyway, yeah, if i can pick the least important trees in random forest regressor (or gradient boosting ensemble) i can implement pruning/refinement of ensembles
[19:36:51] <selwyn> picking less important trees is the opposite problem?
[19:37:23] <shka> selwyn: well, it is the same problem as picking the most important :)
[19:37:34] <selwyn> oh right
[19:37:41] <shka> because the set is finite
[19:38:19] *** Quits: v3ga (~v3ga@cpe-98-25-21-91.sc.res.rr.com) (Ping timeout: 252 seconds)
[19:38:20] <shka> but in practice you want as few as possible for given performance 
[19:38:35] <shka> because memory, speed and so one
[19:39:00] <shka> this is the main advantage of random forests actually
[19:39:03] *** Quits: christophergray (~christoph@190.148.51.17) (Quit: WeeChat 3.3)
[19:39:12] <shka> they can be very hardware efficient
[19:39:35] <shka> and you can put such models on smart watches
[19:39:55] <shka> xbox kinect was using random forests for the body part detection for instance 
[19:41:50] *** Joins: v3ga (~v3ga@cpe-98-25-21-91.sc.res.rr.com)
[19:58:30] *** Quits: dave0 (~davezero@069.d.003.ncl.iprimus.net.au) (Quit: dave's not here)
[20:00:43] *** Joins: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de)
[20:15:43] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 252 seconds)
[20:17:34] *** Joins: aeth (~aeth@user/aeth)
[20:21:59] *** Quits: treflip (~user@95.79.32.99) (Quit: good night ✨)
[20:23:24] *** Joins: makomo (~makomo@user/makomo)
[20:34:02] *** Quits: abrantesasf (~abrantesa@187.36.170.211) (Remote host closed the connection)
[20:40:23] *** Joins: Catie (~user@user/catie)
[20:54:35] *** Quits: Inline (~Inline@aftr-37-201-241-234.unity-media.net) (Ping timeout: 252 seconds)
[21:06:48] *** Joins: lisp123 (~lisp123@5.30.23.247)
[22:13:29] *** Quits: mzan (~quassel@mail.asterisell.com) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
[22:14:38] *** Joins: mzan (~quassel@mail.asterisell.com)
[22:17:41] *** Quits: mzan (~quassel@mail.asterisell.com) (Client Quit)
[22:26:38] *** Joins: mzan (~quassel@mail.asterisell.com)
[22:27:50] *** Joins: vms14 (~user@45.red-83-47-205.dynamicip.rima-tde.net)
[22:27:53] <vms14> hi
[22:28:08] <vms14> I've discovered Perl has reader macros
[22:28:29] <vms14> you don't return a list, but a string
[22:28:55] <vms14> and you can read by lines or bytes 
[22:29:05] <vms14> they're called source filters
[22:29:41] <vms14> lisp macros are nicer, since you're not dealing with text, but I didn't know Perl had such metaprogramming features
[22:30:25] <vms14> I've done a test to check if I could remake something I did in lisp
[22:30:40] <vms14> https://paste.debian.net/1222946/
[22:30:51] <vms14> https://perl.bot/p/htt5su
[22:32:18] <vms14> one is the module and the other is the script using it. It just breaks lines of code until it finds a ; creates a function that calls every line of code in order, just incrementing a counter
[23:12:05] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[23:16:49] *** Quits: Alfr (~Alfr@user/alfr) (Remote host closed the connection)
[23:17:18] *** Joins: Alfr (~Alfr@user/alfr)
[23:35:47] <pjb> vms14: have a look at perligata.
[23:38:19] *** Joins: random-nick_ (~random-ni@87.116.160.199)
[23:53:42] <hayley> https://www.youtube.com/watch?v=M3SvAhjhbpA
[23:53:42] -ixelp- Gary Numan (TV, Live and Rarities) [06]. I Die: You Die (Kenny Everett) - YouTube
[23:59:38] <vms14> pjb: I had
[23:59:50] <vms14> was hard to just print one unum
[23:59:51] <vms14> xd
