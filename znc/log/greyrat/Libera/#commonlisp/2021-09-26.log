[00:09:45] *** Joins: terrorjack (~terrorjac@ec2-13-37-149-154.eu-west-3.compute.amazonaws.com)
[00:10:45] *** Quits: shka (~herr@109.231.62.239) (Ping timeout: 265 seconds)
[00:11:18] *** Quits: White_Flame (~quassel@user/white-flame/x-6930243) (Remote host closed the connection)
[00:12:31] *** Joins: White_Flame (~quassel@user/white-flame/x-6930243)
[00:13:32] *** Quits: cage (~cage@dynamic-adsl-84-220-249-98.clienti.tiscali.it) (Remote host closed the connection)
[00:21:46] *** Joins: scymtym (~user@ip-94-114-248-79.unity-media.net)
[00:30:57] *** Quits: kakuhen (~kakuhen@user/kakuhen) (Quit: Leaving...)
[00:32:10] *** Quits: taiju (~taiju@240b:253:ec40:2400:e069:cea0:b66b:350c) (Ping timeout: 260 seconds)
[00:34:05] *** Joins: lisp123 (~lisp123@5.30.23.247)
[00:35:28] <lisp123> Anybody use CMUCL on MacOS?
[00:37:39] *** Joins: taiju (~taiju@240b:253:ec40:2400:e069:cea0:b66b:350c)
[00:40:00] *** Joins: Lord_of_Life_ (~Lord@user/lord-of-life/x-2819915)
[00:41:02] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 260 seconds)
[00:41:17] *** Lord_of_Life_ is now known as Lord_of_Life
[00:45:29] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Ping timeout: 252 seconds)
[00:46:33] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[01:01:21] <rotateq> did you also try CCL, lisp123?
[01:03:32] <lisp123> rotateq: Yes, I got that working. My brain hurted trying to install CMUCL so I gave up
[01:03:51] *** Joins: kakuhen (~kakuhen@user/kakuhen)
[01:04:18] <rotateq> as long as you don't think it's just about you
[01:04:32] <rotateq> i mean that it didn't work out yet
[01:07:10] <lisp123> rotateq: Perhaps. Next up is LispWorks if I can save up enough money to try it out (outside of the Personal Edition), and perhaps AllegroCL too
[01:08:24] <lisp123> My goal is to have them all nicely installed, then switch between each in Emacs with (setq inferior-lisp-program ....)
[01:08:24] <rotateq> as you like it
[01:08:46] <rotateq> i see, but don't hop around too much
[01:09:06] <lisp123> Indeed :) I'm just procrastinating, better get back to something more productive
[01:09:26] <rotateq> like getting to know the thing itself better :)
[01:10:21] <rotateq> even wanting to be aware of the things *one* of the main implementations provide is immense
[01:10:41] *** Quits: dra (~dra@2a04:4540:640c:f100:8881:b96:6405:a162) (Ping timeout: 250 seconds)
[01:10:50] <rotateq> and ACL and LW then come with so much stuff on top
[01:11:42] <lisp123> That would be a productive idea :P
[01:11:53] <rotateq> just random thoughts of mine
[01:11:57] <rotateq> as always
[01:13:17] <rotateq> and you don't have to use the commercial ones to offer paid work
[01:14:39] <lisp123> Yes
[01:16:19] <rotateq> you have luck if your customer is getting what you tell him why you choose the thing itself in contrast to most competitors, trusts you and says "OK". so you don't have to tell him even more "oh and because of this and that better this implementation"
[01:17:12] <lisp123> Most customers I guess wouldn't care what language is used
[01:17:25] <rotateq> this can be stated in short if real user documentation is provided
[01:18:18] <rotateq> right, because they don't have an overview, so trust is of much worthness (you could tell them basically anything)
[01:18:39] <lisp123> I guess they pay the developer to choose something appropriate
[01:20:38] <rotateq> yes the payment will include that you do it to your best believing (justified by clear facts and some metrics). and thinking in the long run
[01:21:42] <lisp123> Indeed
[01:23:14] <rotateq> that kind of freedom often goes hand in hand with confidence, and confidence is grown by experience and experience is grown by practice
[01:24:23] <lisp123> Hardest part is getting the customers, but we are going off topic now :)
[01:24:33] <rotateq> yes
[01:25:01] <rotateq> I think you're maybe about going to sleep.
[01:25:18] <lisp123> You read my mind, nights :)
[01:26:15] *** Quits: lisp123 (~lisp123@5.30.23.247) (Quit: Leaving...)
[01:29:45] *** Joins: shka (~herr@109.231.62.239)
[01:49:13] *** Quits: Nilby (~Nilby@2601:603:1481:30a0:82fa:5bff:fe66:4b49) (Ping timeout: 252 seconds)
[02:10:03] *** Joins: Oladon (~olad@98.43.81.226)
[02:19:58] *** Quits: gaqwas (~john@dynamic-095-115-142-224.95.115.pool.telefonica.de) (Ping timeout: 252 seconds)
[02:35:22] *** Quits: shka (~herr@109.231.62.239) (Ping timeout: 252 seconds)
[02:38:11] *** Joins: dre (~dre@2001:8003:c932:c301:e5c5:40af:66d5:e309)
[02:42:36] *** Quits: rotateq (~user@p200300e787056600fdfeed040e17b750.dip0.t-ipconnect.de) (Quit: ERC (IRC client for Emacs 27.2))
[02:51:10] *** Quits: pve (~pve@87-93-135-144.bb.dnainternet.fi) (Quit: leaving)
[03:00:18] *** Joins: Psybur (~Psybur@mobile-166-170-32-197.mycingular.net)
[03:03:29] *** Quits: lotuseater (~user@p200300e7870566004b01295534bb48e2.dip0.t-ipconnect.de) (Quit: ERC (IRC client for Emacs 27.2))
[03:21:06] *** Parts: akoana (~ah@user/akoana) (Leaving)
[03:22:02] *** Quits: taiju (~taiju@240b:253:ec40:2400:e069:cea0:b66b:350c) (Ping timeout: 260 seconds)
[03:23:31] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[03:32:41] *** Quits: random-nick (~random-ni@87.116.183.216) (Ping timeout: 252 seconds)
[03:42:35] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Ping timeout: 252 seconds)
[03:42:57] *** Quits: Psybur (~Psybur@mobile-166-170-32-197.mycingular.net) (Remote host closed the connection)
[03:44:53] *** Joins: Nilby (~Nilby@2601:603:1481:30a0:82fa:5bff:fe66:4b49)
[03:45:00] *** Joins: asarch (~asarch@2806:10ae:7:90b4:3a21:5f21:67bd:fcd)
[03:46:32] *** Joins: taiju (~taiju@m014013236064.v4.enabler.ne.jp)
[03:57:52] *** Quits: taiju (~taiju@m014013236064.v4.enabler.ne.jp) (Ping timeout: 252 seconds)
[04:10:01] *** Joins: igemnace (~ian@user/igemnace)
[04:22:51] *** Quits: gioyik (~gioyik@gateway/tor-sasl/gioyik) (Ping timeout: 276 seconds)
[04:32:27] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[04:33:03] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[04:33:54] *** Quits: khrbt (~znc@user/khrbt) (Ping timeout: 260 seconds)
[04:34:35] *** Joins: khrbt (~znc@user/khrbt)
[04:37:05] *** Joins: karlosz (~karlosz@12.196.174.98)
[04:43:04] *** Quits: Everything (~Everythin@37.115.210.35) (Quit: leaving)
[04:45:54] *** Quits: brettgilio (~brettgili@x-node.gq) (Quit: Leaving...)
[04:47:25] *** Joins: brettgilio (~brettgili@x-node.gq)
[04:49:25] *** Quits: brettgilio (~brettgili@x-node.gq) (Client Quit)
[04:52:25] *** Joins: brettgilio (~brettgili@x-node.gq)
[04:53:37] *** Quits: karlosz (~karlosz@12.196.174.98) (Quit: karlosz)
[04:57:19] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 252 seconds)
[05:13:40] *** Quits: molson_ (~molson@2001-48F8-704A-CA1-0-0-75F-104D-static.midco.net) (Ping timeout: 250 seconds)
[05:15:26] *** Quits: igemnace (~ian@user/igemnace) (Ping timeout: 260 seconds)
[05:25:19] *** Quits: char (~charles@108-234-22-190.lightspeed.rcsntx.sbcglobal.net) (Ping timeout: 252 seconds)
[05:28:28] *** Joins: igemnace (~ian@user/igemnace)
[06:13:17] *** Quits: prxq (~quassel@x4db4ad07.dyn.telefonica.de) (Ping timeout: 252 seconds)
[06:13:23] *** Joins: prxq_ (~quassel@x4dbe4c0f.dyn.telefonica.de)
[06:29:23] *** Quits: hendursaga (~weechat@user/hendursaga) (Quit: hendursaga)
[06:29:48] *** Joins: hendursaga (~weechat@user/hendursaga)
[06:32:05] <beach> Good morning everyone!
[06:37:15] <semz> good morning
[06:42:44] *** Joins: karlosz (~karlosz@12.196.174.98)
[06:52:44] *** Joins: jemoka (~jemoka@user/jemoka)
[06:55:34] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[06:57:43] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Ping timeout: 265 seconds)
[06:58:49] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 252 seconds)
[07:00:33] *** Joins: taiju (~taiju@m014013236064.v4.enabler.ne.jp)
[07:07:07] *** Quits: semz (~none@user/semz) (Ping timeout: 252 seconds)
[07:12:41] *** Joins: char (~charles@cpe-76-186-124-165.tx.res.rr.com)
[07:13:11] *** Quits: igemnace (~ian@user/igemnace) (Quit: WeeChat 3.2.1)
[07:13:36] *** Joins: igemnace (~ian@user/igemnace)
[07:20:26] *** Joins: semz (~none@user/semz)
[07:26:24] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[07:27:39] *** Quits: igemnace (~ian@user/igemnace) (Quit: WeeChat 3.2.1)
[07:29:40] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 252 seconds)
[07:42:20] *** Joins: gioyik (~gioyik@gateway/tor-sasl/gioyik)
[07:48:54] *** Quits: gioyik (~gioyik@gateway/tor-sasl/gioyik) (Ping timeout: 276 seconds)
[07:57:43] <lukego> SLIME really needs a way to give you a hint when the long computation you're waiting for has stopped because SBCL ran out of heap space and discretely printed a nasty warning in *inferior-lisp* before waiting with the socket open at the ldb> prompt
[08:26:23] *** Quits: karlosz (~karlosz@12.196.174.98) (Ping timeout: 252 seconds)
[08:27:14] *** Quits: Nilby (~Nilby@2601:603:1481:30a0:82fa:5bff:fe66:4b49) (Ping timeout: 260 seconds)
[08:44:57] *** Joins: jealousm` (~user@2804:431:e7c5:e827:5c1c:24ea:7fec:c9e5)
[08:46:40] *** Quits: jealousmonk (~user@2804:431:e7c4:4247:75cd:c27b:296a:fb0f) (Ping timeout: 252 seconds)
[08:50:42] *** Joins: asarch_ (~asarch@2806:10ae:7:d6a7:a5c7:c5a7:d549:f585)
[08:53:16] *** Quits: asarch (~asarch@2806:10ae:7:90b4:3a21:5f21:67bd:fcd) (Ping timeout: 252 seconds)
[09:00:13] <beach> lukego: SLIME is good, but it is not great, and some of the limitations are probably due to intrinsic problems with the technique being used.
[09:13:34] *** Quits: taiju (~taiju@m014013236064.v4.enabler.ne.jp) (Ping timeout: 252 seconds)
[09:20:42] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[09:39:07] *** Quits: jealousm` (~user@2804:431:e7c5:e827:5c1c:24ea:7fec:c9e5) (Remote host closed the connection)
[09:47:38] <lukego> beach: True. But that sounds a bit like a fortune-cooking comment that could apply to any project :)
[09:49:29] <lukego> and in this case I'm not sure that it would be advantageous to have the tooling running inside that Lisp image that has run out of heap space (or e.g. heap corrupted) and landed at the LDB prompt. The fact that it's partitioned into a separate subprocess is kind of handy because I'm restarting the Lisp process multiple times per day but never losing my editor state, since my Emacs is a lot more stable than my Common Lisp :)
[09:50:47] <lukego> is the long term vision for mcclim ecosystem to run all of the Lisp code together in the same image? Or to partition it into multiple images e.g. the way HEMLOCK had REMOTE stuff to manage an "inferior" lisp process way back when?
[09:55:09] <lukego> This is btw the main topic on my mind this morning: where should the inter-process/inter-language boundaries in my system be? which parts are best integrated, which best separated, and which doesn't it matter? Interesting in the context of e.g. SMT solvers, machine learning toolkits, data visualization, etc, where the benefits of integration need to outweigh a *lot* of extra work reinventing stuff that's available separately
[09:56:33] <beach> Right, our Common Lisp implementations are not stable enough, or safe enough, to handle an IDE in the same image.
[09:57:08] <beach> But it seems like the wrong approach to take for granted that our Common Lisp implementations are not great, and work around it, rather than fixing the implementations.
[09:57:52] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[09:59:16] <beach> I don't think that there is an agreed-upon vision for McCLIM.  I know what I want, and I believe scymtym shares this vision.  I also know that Shinmera (for example) does not share it.  He once said something like "I will *never* use an editor that runs in the same image as my Common Lisp system".
[10:00:01] <lukego> My mental model of Lisp is also "I should restart the image at least once per day or week for the sake of hygeine" but I don't want ot restart my editor so often
[10:01:13] <hayley> My mental model of Lisp is that, would someone implement htop in CLOSOS for some reason, the machine should always have the exclamation mark that htop adds as a suffix to long uptimes.
[10:01:16] <beach> That is a weird model, but also probably due to restrictions of our Common Lisp implementations.  Just as I don't restart my operating system even once a month, I think I shouldn't be required to restart my Common Lisp system.  But the way things currently are, I pretty much have to.
[10:02:11] <hayley> "Uptime: 183 days(!), 01:51:23"
[10:03:16] <beach> lukego: Here is how I see it.  A Common Lisp implementation should have multiple first-class global environments, and instead of restarting your entire system, you might be required to trash the current first-class global environment if you (say) delete an essential function, and create a new one.
[10:03:23] <beach> But then, that would not affect the editor.
[10:06:12] *** Joins: gioyik (~gioyik@gateway/tor-sasl/gioyik)
[10:11:15] *** Quits: gioyik (~gioyik@gateway/tor-sasl/gioyik) (Ping timeout: 276 seconds)
[10:16:00] <lukego> I already have that though? with global environments mapped onto unix processes.
[10:16:40] <beach> That's a bit different from what I am thinking.
[10:17:01] <beach> I am thinking a single address space.
[10:17:21] <lukego> I know. I see lots of benefits to the fully integrated approach, and lots of benefits to the full separated approach. I'm not sure if your model is a best-of or worst-of both worlds approach?
[10:18:00] *** Joins: karlosz (~karlosz@12.196.174.98)
[10:18:15] <beach> Right, it's hard to tell.  But I know of only one way to figure it out, namely to try it and see.
[10:19:02] <lukego> The expected reward isn't high enough for me, but that's a very uncertain quantity of course.
[10:19:35] <beach> Yes, our situations are very different.
[10:20:48] <beach> This vision I have has resulted in 2 papers per year for 8 years, and I can't think of a better line of research than that.
[10:25:22] <lukego> same same but different. I am just fully occupied tilting at my own windmills :)
[10:27:59] <lukego> but this topic is at the top of my mind right now. mapping out my own personal computing ecosystem in terms of lisp, C, R, Julia, python, etc. what to use for which tasks, and how to make them interact? I spend a lot of time bothering about this stuff -- and that's a very real cost that you don't have when you focus on a pure Lisp stack.
[10:31:37] <lukego> in the machine learning landscape it seems to me like some things benefit hugely from tight integration, e.g. quickly iterating gradient descent optimization over automatically-differentiated functions written directly in the application's language e.g. accessing internal data structures to guide the process. Julia has this via Flux.jl and Zygote.jl and people rave about it.
[10:32:45] <lukego> I was tempted to write my application in Julia to access that stuff but current feeling is that reinventing it in Lisp would be less work than (inevitably) reinventing lots of Lisp-isms that I would miss in Julia e.g. Emacs integrations.
[10:34:32] <lukego> On the other hand it seems like MCMC and neural network kind of stuff doesn't necessarily have much advantage of doing inside the application. they are like extremely special-case virtual machines that you configure and run but don't really do any interesting application-specific things inside (from what I can see.) a bit like SMT solving. Maybe that stuff should just get shelled out to an off-the-shelf solver in C++/Python/ec.
[10:36:26] <lukego> beach: btw I respect the work that you are doing and I recognize the dream, having had the same one a long time ago, but I'm just in a different corner of this gigantic expanding computing universe these days. I regret having these nay-saying interactions with you, but it seems rooted in your value judgements of e.g. Emacs based on your own subjective criteria, so I'm not sure how to refrain from reacting :)
[10:45:17] <pjb> In any case, eventually this should lead to the same user experience: if you botch an environment in your CL image, you will still kill it and start a new envionment…
[10:45:26] <lukego> (Maybe I should try harder to avoid naysaying. SICL does look like the foundation for future generations of Lispers from where I sit and that's hugely important. I'm just a bit more myopic and not often seeing much beyond a ~ 5 year time horizon.)
[10:56:34] *** Joins: shka (~herr@109.231.62.239)
[11:05:20] <beach> lukego: You can be as much of a naysayer as you like.  Like water off a duck's back to me.
[11:06:05] <beach> lukego: And I am not trying to convince you.  What I write is for the benefit of all #commonlisp participants.  Otherwise, I would do it in a private exchange with you.
[11:07:54] *** Joins: gaqwas (~john@dynamic-095-114-152-198.95.114.pool.telefonica.de)
[11:10:21] <lukego> that's the thing, I don't like being a naysayer. I suppose that I feel baited. I'll take a break on that note :)
[11:10:22] *** Parts: lukego (sid312033@id-312033.lymington.irccloud.com) ()
[11:19:29] *** Joins: pve (~pve@37-33-35-187.bb.dnainternet.fi)
[11:25:26] *** Quits: karlosz (~karlosz@12.196.174.98) (Quit: karlosz)
[11:53:37] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Ping timeout: 252 seconds)
[11:54:07] *** Joins: amb007 (~a_bakic@23.135.22.93.rev.sfr.net)
[12:04:55] *** Joins: selwyn (~selwyn@user/selwyn)
[12:06:25] *** Quits: khrbt (~znc@user/khrbt) (Quit: ZNC 1.7.2+deb3 - https://znc.in)
[12:07:39] *** Quits: asarch_ (~asarch@2806:10ae:7:d6a7:a5c7:c5a7:d549:f585) (Quit: Leaving)
[12:07:41] *** Quits: selwyn (~selwyn@user/selwyn) (Remote host closed the connection)
[12:08:05] *** Joins: selwyn (~selwyn@user/selwyn)
[12:21:11] *** Joins: igemnace (~ian@user/igemnace)
[12:24:54] *** Joins: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3)
[12:29:27] *** Joins: khrbt (~znc@user/khrbt)
[12:39:53] *** Quits: kakuhen (~kakuhen@user/kakuhen) (Quit: Leaving...)
[12:42:51] *** Quits: dre (~dre@2001:8003:c932:c301:e5c5:40af:66d5:e309) (Quit: Leaving)
[13:04:55] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[13:08:25] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 252 seconds)
[13:14:17] *** Quits: igemnace (~ian@user/igemnace) (Quit: WeeChat 3.2.1)
[13:28:46] *** Quits: dim (~dimlibera@212.85.154.83) (Ping timeout: 252 seconds)
[13:39:42] *** Joins: attila_lendvai (~alendvai@2a02:ab88:370d:c380:4c15:c040:7494:7502)
[13:41:05] *** Quits: amb007 (~a_bakic@23.135.22.93.rev.sfr.net) (Read error: Connection reset by peer)
[13:41:18] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[13:45:40] *** Quits: SAL9000 (~SAL9000@shirakumo/sal9000) (Quit: WeeChat 3.1)
[13:45:56] *** Joins: SAL9000 (~SAL9000@shirakumo/sal9000)
[13:51:07] <greyrat> Lukego: I am migrating my Julia dev env from vscode to emacs, and I am quited pleased with eglot (whose non-REPL experience seems as good as vscode, or better for me since I can customize a lot of stuff in elisp) and Revise.jl (so that I can run a standalone REPL that automatically gets updated when I save my edits, i.e., an alternative to SLIME). (Not to mention, copy-pasting using evil text objects for 'cells' between '##' lines helps
[13:51:07] <greyrat> a lot with using a non-nitegrated REPL.) (jupyter-emacs and org-babel also used to work somewhat well, but recently have broken on my new emacs 28.)  
[13:51:58] <greyrat> What I still haven't found is how to launch a graphical REPL without firing up the whole vscode Electron machinary, as the TUI REPL isn't as nice for working with plots and images.
[13:59:27] <greyrat> lukego: another thing I am working on, is to create a general purpose HTTP API using Jupyter kernels that can eval code in any languages. So for example, I'll load up Julia kernels with the needed dependencies, and then I can easily "shell out" to them in any language. This seems the easiest way to interop between different languages that sometimes have expensive startup costs, to me. What are your thoughts? (I currently have a
[13:59:27] <greyrat> self-implemented (not using Jupyter) HTTP API for zsh, and it has been perhaps the single most useful thing I have ever built. Using that, I can easily execute zsh code in, e.g., elisp, with a syntax as nice as `(z custom-zsh-function (elisp-functions-are-evaled-and-their-results-quoted) (identity some-elisp-var) automatically-quoted-string)`: `(z mkdir -p (identity my-path))` . I currently use some zsh helpers for running pipes (or
[13:59:27] <greyrat> directly use `(z eval 'produce | consume')`, but it's just a matter of doing the work to support `(z produce | consumer)` directly.
[14:00:04] <greyrat> (The zsh HTTP API server: https://github.com/NightMachinary/BrishGarden )
[14:01:44] <greyrat> (I have a lot of zsh code, so zsh takes ~6 seconds to boot up on my machine, which is my I don't just use `zsh -c '...'`. The same problem applies to Julia; Python starts up fast enough that I have not needed a server for it yet.)
[14:03:03] *** Joins: random-nick (~random-ni@87.116.165.220)
[14:04:58] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Read error: Connection reset by peer)
[14:13:08] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[14:16:05] *** Joins: rain3 (~rain3___@2a02:2f09:d100:8700:1ae4:6be9:2a58:7de6)
[14:22:08] *** Quits: frgo (~frgo@p200300deef0cee00a1e1a53ca91ae2c8.dip0.t-ipconnect.de) (Remote host closed the connection)
[14:22:35] *** Joins: frgo (~frgo@p200300deef0cee0081ec75b54b122023.dip0.t-ipconnect.de)
[14:29:10] <greyrat> beach, pjb: After our previous discussion of the limits of scoping on eval, I have distilled my fundamental question to this: https://stackoverflow.com/questions/69334197/common-lisp-how-do-i-set-a-variable-in-my-parents-lexical-scope
[14:29:19] *** Quits: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3) (Ping timeout: 250 seconds)
[14:29:56] <hayley> You cannot.
[14:30:49] <hayley> This is intentional and done to preserve modularity (good luck debugging a function which diddles other stack frames) and the possibility of compilation (to an extent).
[14:32:07] <greyrat> hayley: So it's completely impossible, and not just discouraged? :(
[14:32:29] <greyrat> I really like having stuff to shoot my own feet with. Beats not having a gun. ^_^
[14:32:35] <hayley> Yes. I wouldn't be frowning.
[14:33:08] <hayley> To be fair, I made up the former part, I don't know if it's true (though I suppose it is). But the latter part is a common argument for why you can't do such things.
[14:33:46] <greyrat> It's a pro-big-corporation argument IMHO
[14:35:12] <seok-> hm, what does uiop/run-program:subprocess error mean ?
[14:35:15] <hayley> Dunno about that, myself and Gnuxie have written substantially about such things. It's plain unreasonable to expect everyone to implement such a feature to me.
[14:35:15] <seok-> getting it on windows
[14:35:17] *** Joins: tfeb (~tfb@88.98.95.237)
[14:36:24] *** Quits: tfeb (~tfb@88.98.95.237) (Client Quit)
[14:36:25] <greyrat> seok-: Can you post a snippet that produces the error and is runnable by us? 
[14:36:38] <seok-> I'm trying to run clog, heard of it ?
[14:36:42] <greyrat> BTW, why not try it on the WSL first?
[14:36:49] <seok-> trying to get it to work on portacle/windows
[14:36:54] <greyrat> No, I haven't heard of clog.
[14:37:13] <greyrat> If it has a linux version, do try it on WSL.
[14:37:13] <seok-> it's in awesome-lisp https://github.com/rabbibotton/clog
[14:37:51] <seok-> it says he tested it on windows, maybe not on portacle
[14:38:02] <seok-> run-program on portacle does cause issues
[14:39:23] <hayley> greyrat: The way I see things is that modular design makes individuals _more_ able to manage complex projects, and not less able. So corporations which want to make motivated individuals incapable of replicating corporate efforts would rather promote anti-modular concepts.
[14:44:07] <greyrat> hayley: Both approaches are valid, I do not say that non-modularity is somehow good. I am saying some places benefit from non-modularity. The costs of non-modularity can be much higher for corporations, and this coupled with their social elements of conservatism and conformity, produces the current world where big corporations are very bad positoned to use such non-modular, complex code. It's all about choosing the right tools for the
[14:44:07] <greyrat> requirements, and the differing requiremnts between indie, and big-tech work.
[14:45:18] <greyrat> seok-: No idea, if it's relevant to you, but Nyxt might be of interest. It doesn't even work well on macOS though, so you really want a Linux machine for this one.
[14:45:36] <seok-> nyxt doesnt work on windows
[14:45:49] <seok-> nyxt is a web browser though, clog is a web framework
[14:45:51] <greyrat> Why are you not dual-booting?
[14:46:02] * hayley uploaded an image: (11KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/JIAFDPcycpHnNgJEvfctzKkZ/bruhcha.jpg >
[14:46:10] <seok-> I have a linux machine just want to get this working on windows
[14:48:37] <hayley> On the contrary (again), big and established corporations can basically bail out bad design decisions. Whereas for mortals, such as myself, one would be wasting precious time trying to make it work.
[14:50:13] <hayley> Furthermore, such a situation is not fun, because I know I am wasting time.
[14:55:16] <greyrat> hayley: "bad design" is by definiton bad. I usually use such scoping hacks for well-behaved abstractions. Kind of like how Rust uses a lot of unsafe code in its internals, but presents a safe API to the user.
[14:58:18] *** Joins: dre (~dre@2001:8003:c932:c301:e5c5:40af:66d5:e309)
[14:59:31] *** Quits: dre (~dre@2001:8003:c932:c301:e5c5:40af:66d5:e309) (Client Quit)
[15:05:25] <hayley> Having written a smattering of unsafe performance hacks, that is still difficult to maintain.
[15:09:00] <Xach> greyrat: forbidding such things leads to better performance.
[15:12:57] <greyrat> xach: the best case scenario is to have different "dialects", ala racket, with different optimization needs and safety enforcement. "Glue" code that does not run in a hot loop can be very liberal with its (non)performativity.
[15:14:16] *** Quits: phadthai (mmondor@ginseng.pulsar-zone.net) (Ping timeout: 250 seconds)
[15:15:10] <Xach> Sure - if you don't like how the language is defined, you can make one more to your liking.
[15:15:28] <Xach> Common Lisp isn't like that but isn't bad for making new languages.
[15:16:30] <hayley> I don't think Racket even has the capabilities for such bogosity, unless your language is almost entirely interpreted.
[15:17:14] <Xach> Right, write your own EVAL and anything goes.
[15:17:45] <hayley> Still, even if performance wasn't an issue, this is just a bad idea.
[15:18:46] <Xach> sometimes personal experience is the only way to really grasp something is a bad idea
[15:26:31] *** Joins: gioyik (~gioyik@gateway/tor-sasl/gioyik)
[15:29:01] <beach> Wow, that is some very nasty code.  I guess the fact that it is possible in Python explains the factor 50 performance penalty of Python over Common Lisp.
[15:29:40] <Xach> It reminds me of how the naive idea of "if I compile 'slow' language X to 'fast' language Y, my program will run faster" is false
[15:29:54] <beach> I mean, that such things are generally possible.  Not that this particular possibility is responsible for it all.
[15:31:42] *** Quits: gioyik (~gioyik@gateway/tor-sasl/gioyik) (Ping timeout: 276 seconds)
[15:31:44] <beach> Right, there are language-design decisions that can make it extremely hard to write a compiler that generates fast code.
[15:32:20] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Quit: Laa shay'a waqi'un moutlaq bale kouloun moumkine)
[15:33:56] *** Joins: Lord_of_Life (~Lord@user/lord-of-life/x-2819915)
[15:35:00] <hayley> It probably could be done efficiently if you tried hard enough (you could use debugging information to diddle call frames, but then you would have to handle every inferred type possible being violated), but it is still a bad idea.
[15:35:58] <_death> greyrat: one way to do that in a principled way is to pass a closure that sets the variable, (lambda (new-value) (setf my-var new-value)).. you can create a macro so that you write (setter my-var) instead
[15:36:13] <beach> hayley: But you would also have to prevent the compiler from deleting dead variables.
[15:38:15] <hayley> beach: Also true. Would it affect performance substantially? You could spill dead variables and be done with them.
[15:38:18] <Xach> Hmm, can anyone reach https://www.lrde.epita.fr/~didier/ ? I can't get Didier's software.
[15:38:38] <hayley> Not me, sorry.
[15:39:36] <greyrat> xach: doesn't load for me either
[15:39:48] <beach> hayley: Not to bad in this case, as we decided the other day, but variables could also be replaced by strength reduction and such, so you would then have to keep them synchronized in loops.
[15:40:03] <hayley> Right.
[15:41:53] <beach> I think this question is another piece of evidence that it is a bad idea to let people without knowledge of compiler design make decisions about language design.
[15:49:08] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[15:55:32] <hayley> With regards to being careful with unsafe code: from experience at best I find I need a piece of paper, in order to convince myself that my code works as intended. At worst, I keep finding mistakes (as I have been today, while testing regular expression compilation), which is not something you want to be doing for long.
[15:57:28] <hayley> Somewhere in the middle is using external automation tools. For example, with concurrent programs, I implement a model in TLA+ and wait a few minutes for it to check that the program won't break certain invariants. From what I read, the miri interpreter for Rust can do vaguely similar things for unsafe code.
[15:59:12] *** Joins: Guest92 (~Guest92@2402:e280:2117:297:f5a4:1339:fd63:345a)
[15:59:33] <hayley> (The latter does not exhaustively check models, but it can detect races and mistakes in manual memory management. But, otherwise, you need tools outside the programming language to avoid problems that are usually not problems.)
[16:00:19] *** Parts: Guest92 (~Guest92@2402:e280:2117:297:f5a4:1339:fd63:345a) ()
[16:03:27] *** Quits: rain3 (~rain3___@2a02:2f09:d100:8700:1ae4:6be9:2a58:7de6) (Ping timeout: 240 seconds)
[16:05:42] *** Joins: etiago (~etiago@user/etiago)
[17:02:27] *** Joins: Psybur (~Psybur@mobile-166-170-32-197.mycingular.net)
[17:17:14] *** Joins: igemnace (~ian@user/igemnace)
[17:24:20] *** Joins: Nilby (~Nilby@2601:603:1481:30a0:82fa:5bff:fe66:4b49)
[17:24:30] *** Quits: Nilby (~Nilby@2601:603:1481:30a0:82fa:5bff:fe66:4b49) (Remote host closed the connection)
[17:24:55] *** Joins: Nilby (~Nilby@2601:603:1481:30a0:82fa:5bff:fe66:4b49)
[17:25:31] <attila_lendvai> is there a swank backend for scheme, and more specifically guile?
[17:26:21] *** Joins: jealousmonk (~user@2804:431:e7c5:e827:5c1c:24ea:7fec:c9e5)
[17:31:53] <attila_lendvai> hrm, there's at least contrib/swank-r6rs.scm
[17:46:00] *** Joins: lisp123 (~lisp123@5.30.23.247)
[17:52:29] *** Quits: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431) (Quit: Leaving)
[17:54:38] *** Joins: phadthai (mmondor@user/phadthai)
[17:56:21] <random-nick> there's an emacs package for interaction with scheme called geiser which is in some ways similar to slime
[17:56:45] <random-nick> though that doesn't have anything to do with common lisp
[17:57:29] *** Joins: yewscion (~yewscion@2604:ca00:16a:199e::661:b7e)
[17:57:44] *** Joins: lottaquestions (~nick@104.221.94.126)
[17:59:17] <pjb> greyrat: you can, with closures.
[18:00:26] <lucerne> pjb: So to confirm my understanding; I'll create a clojure that sets the var in the parent scope, then I can pass this closure around, and anyone can set the aforementioned var?
[18:01:53] <random-nick> rich hickey already created clojure
[18:01:57] <random-nick> :^)
[18:02:04] <lucerne> oh yes :))
[18:02:46] <lucerne> (I have typed his lang much more than "closures" ^_^)
[18:03:18] <beach> lucerne: yes, but then there is no violation of modularity.  The creator of the closure grants permission to modify the variable.
[18:03:33] <beach> And the compiler detects this situation, so does not optimize away the variable.
[18:03:59] <beach> So it does not correspond to the exact use case that greyrat wanted.
[18:06:31] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[18:08:13] *** Joins: X-Scale` (~ARM@50.77.166.178.rev.vodafone.pt)
[18:08:35] *** Joins: treflip (~user@95.79.32.99)
[18:09:14] *** Quits: treflip (~user@95.79.32.99) (Remote host closed the connection)
[18:09:33] *** Quits: X-Scale (~ARM@83.223.233.176) (Ping timeout: 265 seconds)
[18:09:51] <pjb> lucerne: exact.
[18:10:13] *** X-Scale` is now known as X-Scale
[18:14:14] *** Joins: cage (~cage@dynamic-adsl-84-220-249-98.clienti.tiscali.it)
[18:15:01] <pjb> greyrat: lucerne: https://termbin.com/jbkyy
[18:16:27] <lucerne> pjb: That's just awesome!
[18:19:14] <beach> pjb: You went to a lot of trouble to make that work! :)
[18:20:58] <_death> at that point, just use specials..
[18:22:28] <beach> Right, it didn't occur to me that greyrat perhaps didn't know about special variables.
[18:24:52] <beach> But it seems plausible now.  I mean, I guess Python doesn't have them?
[18:25:20] *** Quits: lottaquestions (~nick@104.221.94.126) (Ping timeout: 252 seconds)
[18:26:18] <_death> it does not
[18:30:33] <beach> greyrat: Do you know about special variables?
[18:31:06] <lucerne> beach: IIRC, they are just dynamic vars?
[18:31:07] <pjb> lucerne: it's not awsome: we implemented C-like operators, so we get the same problems than in C.  eg. cf. example foo* bar* in https://termbin.com/o8at
[18:32:01] <beach> lucerne: Yes, that's another name for them.
[18:32:04] <pjb> beach: it's an old solution, implementation of locative (aka C-pointers) in CL: http://groups.google.com/group/comp.lang.lisp/msg/d141c5636559ba3b  http://groups.google.com/group/comp.lang.java.programmer/msg/1c27cc14109db55f
[18:32:05] <pjb> ;-)
[18:32:39] <beach> pjb: I see.
[18:33:04] <lucerne> beach: I guess what I want is local dynamic vars (the macro pjb has supplied seems exactly this?). I don't like polluting the global env with special vars.
[18:33:45] <beach> You don't have to "pollute" the global environment.  Just declare the variable SPECIAL.
[18:33:47] <pjb> lucerne: if you want local dynamic variables, then just declare the variable special locally!
[18:34:07] <lucerne> How do I declare the variable special locally? :))
[18:34:18] <beach> (declare (special <var>))
[18:34:32] <lucerne> This would affect all mentions of this variable though?
[18:34:46] <lucerne> That's what I remember at least.
[18:34:47] <Nilby> I feel like lexical specials solve this issue.
[18:34:50] <beach> No, you have to declare it special in all places you want to refer to it.
[18:35:09] <lucerne> Nilby: What are lexical specials?
[18:35:24] <beach> lucerne: That's why it is not "polluting" the global environment.
[18:35:33] <pjb> lucerne: https://termbin.com/qquxi
[18:35:55] <beach> lucerne: There is no such thing as "lexical specials".
[18:36:06] <pjb> lucerne: it only affects mentions of this variable in the lexical scope of the special declaration.
[18:36:10] <Nilby> lucerne: ^ what pjb linked
[18:36:50] <pjb> special variables name dynamic variables that live in time, while lexical variable live in space.
[18:36:54] <_death> special variables have indefinite scope and dynamic extent
[18:37:06] <Nilby> I know beach won't approve of using the words "lexical special" because it's technically incorrect.
[18:37:33] <lisp123> pjb: special variables name dynamic variables that live in time, while lexical variable live in space. >>> best explanation I have heard yet
[18:38:18] <lisp123> Nilby: It's very incorrect, if you think about it a bit more :)
[18:39:41] *** Joins: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431)
[18:41:30] <Nilby> So what's the proper term? How does differentiate between a defvar and a (let (x) (declare (special x)) ...)
[18:41:43] *** Quits: Mandus (~aasmundo@0.51-175-33.customer.lyse.net) (Ping timeout: 252 seconds)
[18:41:56] <pjb> greyrat: anyways, beach's comment means: Why do you want do that? It's a bad idea, don't do that!
[18:42:00] <beach> "local" would be a better adjective.
[18:42:14] *** Joins: Mandus (~aasmundo@0.51-175-33.customer.lyse.net)
[18:42:37] <pjb> local is imprecise, it can be a textual (space) locality, or a temporal locality.
[18:43:10] <_death> Nilby: there isn't much of a difference.. defvar just declaims special
[18:43:21] <pjb> Nilby: defvar is eternal, while (let (x) (declare (special x)) ...) is temporary.
[18:44:00] <pjb> Nilby: define-symbol-macro is all-encompassing, while  (let (x)  ...) is a lexical scope.
[18:44:16] <beach> The difference is whether the variable is special in the global environment or not.  Hence my suggested "local".
[18:44:42] <pjb> Yes, but lexical scopes can also be qualified of local. Hence the confusion.
[18:44:51] <beach> "non-global" would be an alternative.
[18:45:40] <Nilby> I understand how it works, I just want to use words that won't bother or confuse people.
[18:46:23] <pjb> Also, lexical scopes are not always contiguous, hence the notion of locality can be topologically strange.  Similarly, temporary scopes (dynamic bindings) can be shadowed, and also, when threads are involved, can have strange topologies, since threads represent parallel times.
[18:47:07] <lisp123> Nilby: Have a think about what lexical means, hopefully that will help explain why that wording doesn't work
[18:47:16] <_death> since local declarations are used, I think "local special" would be ok
[18:47:50] <pjb> See for example, the lexical scope where functions defined with labels are visible (on the right): http://informatimago.com/~pjb/files/lisp/common-lisp/flet-or-labels.png
[18:48:04] <pjb> Notice the closing parenthesis between the two red areas.
[18:48:46] <Nilby> I do have a fondness for utilizing the thread topologies of "local" or "non-global" specials.
[18:52:22] <Nilby> lisp123: I don't like thinking. But, these variables are in fact introduced in a lexical scope, and then set somewhat but not totally free, by the declaration, so perhaps one should call them "free-lexicals".
[18:52:32] *** Joins: Oladon (~olad@98.43.81.226)
[18:52:41] *** Joins: tyson2 (~user@cpe44d9e795a64f-cm688f2e2dfaa0.sdns.net.rogers.com)
[18:53:51] <Nilby> Of course one doesn't want to imply that they're free in time or space cost, which is the nearly the opposite.
[18:53:51] <lisp123> I wouldn't do that since the meaning of lexical is most closely associated with the textual region - e.g. definition of lexical scope " Here references to the established entity can occur only within certain program portions that are lexically (that is, textually) contained within the establishing construct. "
[18:54:19] <beach> Why would you not use the word "special" to describe a restricted kind of special variable.
[18:54:22] <beach> ?
[18:54:59] <beach> An adjective can be used to indicate such a restriction.  But to use a completely different noun for it seems just so wrong.
[18:57:28] <pjb> Definitely. Special qualifies symbols naming dynamic variables.
[18:58:04] *** Quits: igemnace (~ian@user/igemnace) (Remote host closed the connection)
[18:59:10] <pjb> lisp123: true, but there's an operator that maps between time and space: it's eval (execution in general).  The "text" in a lexical scope is evaluated "during" a time period.  This is how dynamic environments come alive.
[19:00:11] <Nilby> I'll just say "local special" from now on. If beach approves, that's good enough for me.
[19:00:23] <pjb> I prefer temporarily special.
[19:01:05] <pjb> But granted a symbol that is locally declared special, let you name a dynamic variable temporarily.
[19:01:28] <lisp123> pjb: Makes sense, some though provoking ideas for sure
[19:01:40] <pjb> Note that the dynamic variable that is temporarily named depends on the dynamic scope: it can be an outer temporary dynamic variable, or the global dynamic variable.
[19:06:10] <lisp123> Adding (declare (special g)) gives an error here: (defun compose (f g)   #'(lambda (x) (declare (special g)) (funcall f (funcall g x))))
[19:08:06] <lisp123> Any ideas why? Too much concepts for me to process in one go
[19:10:26] *** Quits: yewscion (~yewscion@2604:ca00:16a:199e::661:b7e) (Ping timeout: 250 seconds)
[19:10:33] <lisp123> Is it because g now has dynamic extent - is it disestablished after the function is defined?
[19:13:02] <lucerne> lisp123: I don't understand your function at all. Can you explain what it is supposed to do in plain English?
[19:14:03] <Nilby> It's a differnt g
[19:15:01] <lucerne> pjb: I looked at your examples of failure modes. Indeed, the solution really only works if the names of the original functions are also supplied as strings. And these special vars seem to be just a better fit. I had misremembered `declare special` as global like `defvar`.
[19:15:07] *** Quits: brettgilio (~brettgili@x-node.gq) (Quit: Leaving...)
[19:16:13] <lucerne> BTW, can one inspect the "stack" of a special variable? To see what value it has at the grandparent scope, for example.
[19:16:26] *** Joins: brettgilio (~brettgili@x-node.gq)
[19:16:34] <beach> lucerne: Depends on your implementation.
[19:16:42] <lucerne> SBCL?
[19:17:04] <lisp123> lucerne: I'm not sure if I can explain it that well, https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node43.html goes through it a bit more
[19:18:52] <beach> lisp123: The G in the lambda list is not the same as the one you declared special.
[19:19:26] <beach> lisp123: And there is no error, just a warning.
[19:20:13] *** Quits: Devon (~devon@c-24-2-157-5.hsd1.ma.comcast.net) (Ping timeout: 252 seconds)
[19:20:30] <lisp123> If you call it you will get an error e.g. (funcall (compose #'sqrt #'abs) -9.0)
[19:21:04] <beach> Because G is unbound.
[19:21:30] <Nilby> lisp123: The special decl makes a new unbound g, which isn't the compose argument.
[19:22:02] <Nilby> It's nice and conveniently confusing.
[19:22:15] *** Joins: yewscion (~yewscion@2604:ca00:16a:199e::661:b7e)
[19:22:40] <beach> clhs special
[19:22:41] <specbot> http://www.lispworks.com/reference/HyperSpec/Body/d_specia.htm
[19:23:13] <beach> lisp123: See the phrase "special declarations can be either bound..."
[19:24:01] <beach> lisp123: Yours is a "free declaration" because it is not attached to the lambda-list variable G.
[19:24:37] <lisp123> beach: Its a bit confusing for me because there are references to both f & g within the funcalls
[19:26:35] *** Quits: yewscion (~yewscion@2604:ca00:16a:199e::661:b7e) (Ping timeout: 250 seconds)
[19:26:47] <beach> Why would you declare G special here?
[19:27:31] <beach> That seems to defeat the purpose of this function.
[19:28:39] <lisp123> Out of curiosity to see what would happen. From what I understand, f & g have indefinite extent (" The parameter bindings for f and g do not disappear because the returned function, when called, could still refer to those bindings."), so wanted to see what would happen if one adds in a special declaration which gives g dynamic extent? However, both you and Nilby say its a different G, but I can't seem to get my head around that
[19:29:01] *** Quits: Mandus (~aasmundo@0.51-175-33.customer.lyse.net) (Ping timeout: 252 seconds)
[19:29:23] <lisp123> My theory was: is it (g) disestablished after the function is defined?
[19:29:43] <pjb> lisp123: your lambda is calling now a function that should be bound to a dynamic variable named g.  The parameter of compose  named g is a lexical variable!
[19:29:44] <beach> OK, slow down...
[19:30:03] *** Quits: IlluminatedPileo (~heretical@2001:470:69fc:105::8054) (Quit: You have been kicked for being idle)
[19:30:39] <beach> lisp123: Your SPECIAL declaration is not "attached to" the lambda-list variable G, because for that to be the case, it has to be first in the DEFUN body.
[19:30:44] <pjb> lisp123: if you declare it special:  (defun compose (f g) (declare (special g))  #'(lambda (x) (declare (special g)) (funcall f (funcall g x))))  then the lambda will perhaps refer to the same dynamic variable  that is now the parameter of compose, but since it's not called WHEN compose is evaluated, it won't be!
[19:31:00] *** Joins: Mandus (~aasmundo@0.51-175-33.customer.lyse.net)
[19:31:30] <beach> lisp123: So it is a "free declaration", and it affects only references, as the Common Lisp HyperSpec page says.  Not any binding like the lambda-list variable is.
[19:31:35] <pjb> lisp123: on the other hand, if you call the anonymous function returned by compose WHEN there is a dynamic variable named g defined that moment (= temporal scope), then then it will be able to call it.
[19:31:52] <pjb> lisp123: but since in general, random dynamic variables are unbound, you get this error.
[19:32:45] <pjb> lisp123: closures can only exist over lexical variables.
[19:34:37] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Ping timeout: 265 seconds)
[19:35:15] <pjb> lisp123: you should read more Asimov!  eg. "Gimmick Three" https://en.wikipedia.org/wiki/Gimmicks_Three
[19:35:47] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[19:35:54] <pjb> lisp123: you cannot emprison the devil in a thick eternal bronze cube.  Because he can travel back in time, before the cube existed, and escape!
[19:36:08] <pjb> lisp123: similarly, there's no enclosing dynamic variables!
[19:36:14] <lisp123> beach & pjb: thanks, it doesn't make too much sense, but if I read it enough times hopefully it will
[19:36:34] <lisp123> pjb: nice analogy!
[19:37:01] <pjb> lisp123: in the case of this compose function, if you want g to be special, then you don't need it as a parameter to compose.
[19:37:38] <Nilby> Sometimes I wish I could move back in time to before I signed away my soul to Lisp.
[19:37:52] <lisp123> pjb: I was trying to break this "closures can only exist over lexical variables." by making it special
[19:38:30] <lisp123> But I haven't connected all the dots, so will re-read the above a few times
[19:39:47] <pjb> lisp123: an example could be: https://termbin.com/0b7d9
[19:41:15] <pjb> lisp123: https://termbin.com/d9vd
[19:41:42] <pjb> You can have a different tracer function depending on WHEN you call h.
[19:42:20] <pjb> If you call h in a loop, you can even change the *trace-composed-functions* binding in another thread (or in the body of the loop) >:-}~
[19:42:42] *** Joins: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3)
[19:43:34] <lisp123> Special variables are free as in freedom, there is not controlling them!
[19:44:11] <lisp123> This example I get pretty well
[19:45:46] <lisp123> Nilby: How long have you been programming in Lisp?
[19:50:48] <Nilby> lisp123: I was first exposed to lisp around the age of 10, and I am very old. I only stopped using other languages about 16 years ago.
[19:51:25] <lisp123> Nilby: Wow nice :)
[19:53:07] <Nilby> lisp123: My dad thought it would stop me from getting in trouble to put me in front of a teletype at MIT. He was very wrong.
[19:55:43] <lisp123> beach &
[19:56:08] <lisp123> Nilby: :) Very lucky to have been at MIT!
[19:56:48] *** Quits: attila_lendvai (~alendvai@2a02:ab88:370d:c380:4c15:c040:7494:7502) (Ping timeout: 250 seconds)
[20:01:01] *** Quits: tyson2 (~user@cpe44d9e795a64f-cm688f2e2dfaa0.sdns.net.rogers.com) (Quit: ERC (IRC client for Emacs 27.2))
[20:03:31] <Nilby> lisp123: In my case it didn't matter since I was born with a severe allergy to academia. It mearly gave me a warped and mostly incorrect ideas about robots, programming languauges, and the future.
[20:04:36] *** Quits: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3) (Ping timeout: 250 seconds)
[20:05:32] <lisp123> Nilby: I see, must have been a lot of hype as well back then
[20:05:45] <lisp123> (in AI and other stuff - hence AI Winter)
[20:06:17] <Nilby> exactly
[20:10:23] <etimmons> borodust: I noticed that in CLAW repos you like to include the foreign lib's repo as a submodule. Have you messed around at all with having ASDF build the foreign lib for you?
[20:12:25] <borodust> etimmons: i do link foreign lib repos in wrapper projects and primary reason is to have specific version of headers
[20:12:48] <borodust> etimmons: i'm totally not into idea of building foreign libraries from asdf ;p
[20:13:44] <borodust> etimmons: it's hard to get things goind in native way across different platorms (different knobs needed to be triggered to build properly), implementing that in asdf feels like being a total nightmare
[20:16:22] <etimmons> borodust: That's fair! Kind of just wondering how you ensure the header version matches the lib version if you use the system's lib
[20:16:52] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[20:17:34] <borodust> etimmons: btw, also when putting bindings into a quicklisp dist i strip everything foreign - no headers, no c/c++ code, no foreign project as a whole
[20:18:18] <borodust> meaning user won't be able to build foreign library at all by using system from a dist at all
[20:18:49] <borodust> etimmons: i ensure that by using bodge-blobs-support system
[20:19:07] <borodust> i keep prebuilt libraries as a separate system
[20:19:25] <borodust> e.g. https://github.com/borodust/alien-works-foundation
[20:19:49] <etimmons> ahhhhhh, that explains it
[20:20:03] <etimmons> I'll take a look at that!
[20:27:17] *** Joins: asarch (~asarch@2806:10ae:7:1568:4a81:d674:9e97:714f)
[20:36:03] *** Joins: gioyik (~gioyik@gateway/tor-sasl/gioyik)
[20:39:30] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[20:42:53] *** Quits: gioyik (~gioyik@gateway/tor-sasl/gioyik) (Quit: WeeChat 3.1)
[20:42:53] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[20:52:58] *** Joins: kevingal (~quassel@2a02:8084:4140:f300:21f8:1bca:b298:4ac4)
[20:58:09] *** Quits: kevingal (~quassel@2a02:8084:4140:f300:21f8:1bca:b298:4ac4) (Remote host closed the connection)
[21:21:43] *** Joins: attila_lendvai (~alendvai@catv-213-222-131-28.catv.broadband.hu)
[21:26:44] *** Joins: karlosz (~karlosz@12.196.174.98)
[21:27:30] *** Joins: yewscion (~yewscion@2604:ca00:16a:199e::661:b7e)
[21:29:28] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[21:32:46] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 252 seconds)
[21:38:14] *** Joins: rain3 (~rain3___@2a02:2f09:d100:8700:1ae4:6be9:2a58:7de6)
[21:43:02] *** yewscion is now known as yewscion_
[21:43:20] *** Quits: Mandus (~aasmundo@0.51-175-33.customer.lyse.net) (Ping timeout: 252 seconds)
[21:44:51] *** Joins: Mandus (~aasmundo@0.51-175-33.customer.lyse.net)
[21:47:37] *** Quits: karlosz (~karlosz@12.196.174.98) (Ping timeout: 252 seconds)
[22:10:13] *** Quits: Mandus (~aasmundo@0.51-175-33.customer.lyse.net) (Ping timeout: 252 seconds)
[22:11:13] *** Joins: Devon (~devon@c-24-2-157-5.hsd1.ma.comcast.net)
[22:12:47] *** Joins: Mandus (~aasmundo@0.51-175-33.customer.lyse.net)
[22:23:30] *** Quits: rain3 (~rain3___@2a02:2f09:d100:8700:1ae4:6be9:2a58:7de6) (Ping timeout: 260 seconds)
[22:24:34] *** Joins: karlosz (~karlosz@12.196.174.98)
[22:30:27] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[22:33:18] *** Quits: yewscion_ (~yewscion@2604:ca00:16a:199e::661:b7e) (Ping timeout: 260 seconds)
[22:33:56] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 265 seconds)
[22:35:02] *** Quits: Mandus (~aasmundo@0.51-175-33.customer.lyse.net) (Ping timeout: 252 seconds)
[22:36:37] *** Joins: Mandus (~aasmundo@0.51-175-33.customer.lyse.net)
[22:39:47] *** Quits: cage (~cage@dynamic-adsl-84-220-249-98.clienti.tiscali.it) (Quit: rcirc on GNU Emacs 27.1)
[22:59:14] *** Joins: X-Scale` (~ARM@92.250.96.13)
[23:00:13] *** Quits: X-Scale (~ARM@50.77.166.178.rev.vodafone.pt) (Ping timeout: 250 seconds)
[23:01:54] *** X-Scale` is now known as X-Scale
[23:02:27] *** Joins: rgherdt (~rgherdt@2a02:8109:86c0:d8d:e473:ba5e:85e3:6828)
[23:05:50] *** Quits: attila_lendvai (~alendvai@catv-213-222-131-28.catv.broadband.hu) (Ping timeout: 265 seconds)
[23:07:58] *** Joins: attila_lendvai (~alendvai@apn-94-44-248-97.vodafone.hu)
[23:11:03] *** Joins: lottaquestions (~nick@2607:fa49:503e:3000:4079:afdf:7e9e:c580)
[23:22:09] *** Joins: karlosz_ (~karlosz@12.196.174.98)
[23:24:43] *** Joins: rotateq (~user@p200300e787056600fdfeed040e17b750.dip0.t-ipconnect.de)
[23:25:38] *** Quits: karlosz (~karlosz@12.196.174.98) (Ping timeout: 252 seconds)
[23:25:38] *** karlosz_ is now known as karlosz
[23:25:51] *** Quits: karlosz (~karlosz@12.196.174.98) (Client Quit)
[23:27:59] *** Quits: hendursaga (~weechat@user/hendursaga) (Remote host closed the connection)
[23:28:25] *** Joins: hendursaga (~weechat@user/hendursaga)
[23:34:52] *** Quits: Mandus (~aasmundo@0.51-175-33.customer.lyse.net) (Ping timeout: 252 seconds)
[23:35:19] *** Quits: shka (~herr@109.231.62.239) (Ping timeout: 265 seconds)
[23:39:53] *** Joins: Mandus (~aasmundo@0.51-175-33.customer.lyse.net)
[23:44:06] *** Joins: karlosz (~karlosz@12.196.174.98)
[23:51:09] *** Quits: attila_lendvai (~alendvai@apn-94-44-248-97.vodafone.hu) (Read error: Connection reset by peer)
[23:56:53] *** Joins: attila_lendvai (~alendvai@catv-213-222-131-28.catv.broadband.hu)
[23:57:50] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
