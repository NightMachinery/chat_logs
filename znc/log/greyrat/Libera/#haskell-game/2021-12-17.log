[00:28:15] *** Quits: coot (~coot@2a02:a310:e03f:8500:933a:39ca:ef4e:37cb) (Quit: coot)
[02:32:16] *** Quits: chomwitt (~chomwitt@2a02:587:dc19:a500:12c3:7bff:fe6d:d374) (Remote host closed the connection)
[03:59:53] *** Quits: curiousgay (~curiousga@77-120-141-90.kha.volia.net) (Quit: Leaving)
[04:06:32] *** Quits: madjestic (~madjestic@88-159-247-120.fixed.kpn.net) (Ping timeout: 240 seconds)
[04:19:45] *** Quits: __monty__ (~toonn@user/toonn) (Quit: leaving)
[06:20:02] *** Quits: carter (sid14827@id-14827.helmsley.irccloud.com) (Ping timeout: 240 seconds)
[06:23:12] *** Joins: carter (sid14827@id-14827.helmsley.irccloud.com)
[07:27:35] <EvanR> so I'm doing the math for something like breakout / arkanoid. I think I have something that will work
[07:29:00] <EvanR> the level consists of a collection of elements, which are either line segments or circles (small ones, used for block corners). A free particle moves smoothly through space until it hits an element
[07:30:09] <EvanR> at the time and place there is a hit, the level also can provide the microsurface view of that point. A microsurface view is either a flat surface with a normal (even if it's formed from a complex abutting set of lines, or a line and a circle, or whatever), or it's an inside corner with two normals
[07:32:03] <EvanR> a particle that hits something momentarily goes through a collision state where the velocity interacts with the microsurface, then it exits the area by ignoring any elements named by the microview
[07:33:05] <EvanR> each collision generates an event, for later purposes
[07:34:36] <EvanR> law that would be nice: if a particle xv will hit y at time t, then microsurface lookup at y (and t) works. i.e. there is a microsurface at all there
[07:34:58] <EvanR> so far it works but I haven't proven it
[07:43:56] <EvanR> law that would be nice: the macroscopic behavior of the particle converges to what you'd expect as the resolution of microlookups goes to zero, i.e. you can't tell the difference if you hit a corner slightly off or exactly
[07:44:35] <EvanR> inside corner
[07:46:19] <EvanR> calculus = carefully controlled wrongness xD
[08:50:56] <sm> oh nice EvanR. I have bumped my head against that on a few occasions
[08:51:16] <sm> sounds like you are well beyond me
[08:52:52] <sm> it sounds very nice. I wonder how it'll feel if implemented so precisely
[08:53:01] <sm> count me as play tester
[09:24:20] <EvanR> yes on the gameplay aspect, I'm not sure what is supposed to happen if your ball hits the corner of a block
[09:27:42] <sm> I would guess it most often picks either the vertical or horizontal plane to bounce off (but, I can right away imagine trouble if there are concave walls and more collisions right away..)
[09:28:47] <sm> do we want the satisfaction of figuring this out, or do we consult the internet for standard breakout algorithms
[09:28:55] <EvanR> oh hell no
[09:29:08] <EvanR> NIH syndrome for the win
[09:29:30] <sm> and do you want standard or do you want physically accurate ultimate precision never before seen breakout
[09:30:21] <EvanR> if your ball hits an exposed corner, i imagined it would act like billiards and the result is sensitive to exactly where the ball hits the corner and how
[09:30:42] <EvanR> no idea if that's how it's normally done
[09:31:05] <sm> yes
[09:31:10] <sm> with one brick in isolation, that sounds not too hard
[09:31:37] <EvanR> an inside corner by comparison has a simpler result because there's less ways to hit, but then I had to invent this microview thing to stop crazy floating madness
[09:31:47] <sm> I guess you need to handle simultaneous contact with multiple bricks
[09:31:57] <EvanR> yes that was my original problem
[09:32:31] <EvanR> i fixed it by having a microview that doesn't know there are multiple bricks there
[09:32:40] <EvanR> it looks like a flat 
[09:33:01] <sm> hitting 2+ corners at once.. hitting corners and edges at once...
[09:33:47] <EvanR> you'll have to elaborate on that one
[09:33:53] <EvanR> 2 corners at once
[09:34:44] <sm> yes, maybe it's not possible if your bricks are bigger than the ball
[09:35:41] <sm> but if not, imagine two bricks with a one brick gap between them, the ball approaches the gap but makes contact with the brick corners on each side, at the same time
[09:36:09] <EvanR> yeah that can't be done with my model
[09:36:25] <EvanR> it crosses the boundary between micro and macro
[09:37:21] <EvanR> i was going to cheat and have a macro ball represented as a point particle located at the center, and have the radius be an illusion of moving the block boundaries out by r
[09:37:50] <EvanR> and the corners are circular arcs
[09:39:55] <EvanR> I will be nerd sniped in parallel though thinking how to do a large ball
[09:41:56] <sm> you think breakout is one of the simplest fun games to make, not realising you are about to enter a massive rabbit hole
[09:42:32] <EvanR> that's how I feel about basically any game
[09:42:48] <sm> I'm with you. Alas! :)
[09:43:37] <sm> I guess game devs who don't over think things just do an approximation, and players pay no attention
[09:44:11] <sm> philistines
[09:44:22] <EvanR> I was musing on the idea of, make it full of bugs and holes, then apply a small random offset to all velocities, nothing bad will ever happen:tm:
[09:44:41] <EvanR> or, wondering if that's how they do it IRL
[09:45:19] <sm> I suspect they avoid randomness wherever possible since it complicates reproducing and testing 
[09:45:26] <EvanR> exact real arithmetic algorithms are easy if you never encounter exact integers etc lol
[09:45:42] <EvanR> or rationals, in some cases
[09:47:16] <EvanR> as it stands, my particle that starts at 1 1 and has initial velocity 1 2 in a 10 x 10 box, with time steps = 1... bounces around like a knights tour on integer floats lol
[09:47:20] <EvanR> it's pretty cool
[09:53:08] <sm> fun!
[09:53:36] <sm> here's my last breakout attempt, https://github.com/simonmichael/breakout . Notice conspicuous lack of bricks
[10:01:59] <EvanR> oh nice
[10:05:55] <EvanR> i reviewed all the code
[10:06:07] <EvanR> the screenshot proves it does a lot without much code xD
[10:45:54] *** Quits: nek0 (~nek0@nek0.eu) (Quit: The Lounge - https://thelounge.chat)
[10:55:10] *** Joins: nek0 (~nek0@nek0.eu)
[11:06:37] *** Joins: coot (~coot@89-64-85-93.dynamic.chello.pl)
[12:57:38] *** Quits: coot (~coot@89-64-85-93.dynamic.chello.pl) (Quit: coot)
[12:58:23] <f-a> qohhh arkanoid
[13:12:19] *** Quits: tzh (~tzh@c-24-21-73-154.hsd1.or.comcast.net) (Quit: zzz)
[13:21:49] *** Joins: coot (~coot@89-64-85-93.dynamic.chello.pl)
[13:25:54] *** Joins: madjestic (~madjestic@88-159-247-120.fixed.kpn.net)
[13:28:53] *** Quits: coot (~coot@89-64-85-93.dynamic.chello.pl) (Remote host closed the connection)
[13:29:24] *** Joins: coot (~coot@2a02:a310:e03f:8500:933a:39ca:ef4e:37cb)
[13:38:39] *** Quits: coot (~coot@2a02:a310:e03f:8500:933a:39ca:ef4e:37cb) (Remote host closed the connection)
[13:40:02] *** Joins: coot (~coot@2a02:a310:e03f:8500:933a:39ca:ef4e:37cb)
[14:35:38] *** Joins: __monty__ (~toonn@user/toonn)
[16:15:25] *** Quits: madjestic (~madjestic@88-159-247-120.fixed.kpn.net) (Ping timeout: 240 seconds)
[19:17:24] *** Quits: coot (~coot@2a02:a310:e03f:8500:933a:39ca:ef4e:37cb) (Quit: coot)
[19:31:58] *** Joins: madjestic (~madjestic@88-159-247-120.fixed.kpn.net)
[20:10:37] *** Quits: madjestic (~madjestic@88-159-247-120.fixed.kpn.net) (Ping timeout: 240 seconds)
[20:25:50] *** Joins: madjestic (~madjestic@88-159-247-120.fixed.kpn.net)
[20:39:00] *** Quits: madjestic (~madjestic@88-159-247-120.fixed.kpn.net) (Ping timeout: 240 seconds)
[21:17:45] *** Joins: coot (~coot@89-64-85-93.dynamic.chello.pl)
[22:18:42] *** Quits: coot (~coot@89-64-85-93.dynamic.chello.pl) (Quit: coot)
[22:39:11] *** Joins: madjestic (~madjestic@88-159-247-120.fixed.kpn.net)
[22:44:57] *** Joins: tzh (~tzh@c-24-21-73-154.hsd1.or.comcast.net)
[23:27:44] *** Joins: coot (~coot@89-64-85-93.dynamic.chello.pl)
[23:29:45] *** Quits: coot (~coot@89-64-85-93.dynamic.chello.pl) (Client Quit)
[23:31:20] *** Joins: coot (~coot@2a02:a310:e03f:8500:933a:39ca:ef4e:37cb)
[23:34:08] <EvanR> cool float bug/issue, when a time delta ends up being too small but greater than zero, then when applied to a particle causes it to not move
[23:34:41] <EvanR> and in my case, that means remains on a wall, then escapes
[23:36:16] <sm> sticky wall! feature!
[23:37:31] <EvanR> so the law I apparently relied on, if dt > 0 and v > 0, then particle moves (out of a collision zone), was broken 
[23:38:05] <EvanR> it's because I was testing with random values
[23:38:26] <EvanR> and in one case it hits a wall right before the end of the turn
[23:38:55] <EvanR> at t=0.249999999 xD
[23:39:35] <EvanR> using Float helps uncover issues since it has less "room for error"
[23:46:30] <EvanR> maybe I can devise a test, is this time delta too small to safely get out of a collision
[23:46:44] <EvanR> if so, collision still happening at end of turn
[23:49:36] <sm> I wonder if dynamic systems implemented with floats can ever have 100% reliable/consistent behaviour. I guess so, but it's harder
[23:50:31] <f-a> I suspect they cheat
[23:53:19] <EvanR> I stuck a 0.001 buffer in there
[23:53:27] <EvanR> lol
[23:53:40] <EvanR> if you have less time than that, you're out of time
[23:56:18] <EvanR> after watching it bounce around for like 30 seconds... it bounced out again lol
[23:57:31] <ManofLetters[m]> that's why I only use good old integers
[23:57:41] <ManofLetters[m]> Int ought to be enough for everyone
[23:58:22] <EvanR> well I'm not sure Int solves this particular issue
[23:58:53] <ManofLetters[m]> for my turn-based, grid-based game it solves it
[23:59:35] <EvanR> imagine a grid of floats (in the region [1,2] x [1,2]), the topology is the same
