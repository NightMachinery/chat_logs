[00:01:36] *** Quits: Morrow (~quassel@bzq-110-168-31-106.red.bezeqint.net) (Remote host closed the connection)
[00:36:36] *** Quits: coot (~coot@2a02:a310:e03f:8500:933a:39ca:ef4e:37cb) (Quit: coot)
[00:39:45] <jneira[m]> <michaelpj[m]> "jneira: I notice that e.g. the..." <- yeah, they are not set so not send and the server defaults wins
[00:40:03] <michaelpj[m]> üëç
[00:41:06] <jneira[m]> <sm> "correction hls still gives the..." <- i think so, brew has a hls formula and it has support for arm iirc
[00:41:24] <jneira[m]> and also ghcup...
[00:41:44] <sm> thanks, I'll explore those next time
[00:51:14] *** Joins: Morrow (~quassel@bzq-110-168-31-106.red.bezeqint.net)
[00:58:59] *** Quits: Morrow (~quassel@bzq-110-168-31-106.red.bezeqint.net) (Remote host closed the connection)
[01:00:00] *** Joins: Morrow (~quassel@bzq-110-168-31-106.red.bezeqint.net)
[01:42:58] *** Joins: yoshitsugu (uid529929@id-529929.hampstead.irccloud.com)
[02:31:01] *** Joins: coot (~coot@89-64-85-93.dynamic.chello.pl)
[02:41:31] *** Quits: myShoggoth (~myShoggot@97-120-85-195.ptld.qwest.net) (Quit: Leaving)
[03:01:02] *** Joins: libertyprime (~libertypr@125-239-52-43-fibre.sparkbb.co.nz)
[03:22:22] *** Quits: coot (~coot@89-64-85-93.dynamic.chello.pl) (Quit: coot)
[03:56:12] *** Quits: libertyprime (~libertypr@125-239-52-43-fibre.sparkbb.co.nz) (Ping timeout: 256 seconds)
[04:12:09] *** Joins: libertyprime (~libertypr@222-154-245-111.adsl.xtra.co.nz)
[05:03:19] *** Quits: jiribenes (~jiribenes@rosa.jiribenes.com) (Remote host closed the connection)
[05:04:04] *** Joins: jiribenes (~jiribenes@rosa.jiribenes.com)
[05:10:09] *** Joins: shapr (~user@12.5.211.156)
[05:10:34] *** Quits: libertyprime (~libertypr@222-154-245-111.adsl.xtra.co.nz) (Quit: leaving)
[05:16:20] *** Quits: shapr (~user@12.5.211.156) (Remote host closed the connection)
[05:37:32] *** Joins: shapr (~user@12.5.211.156)
[05:42:10] *** Quits: shapr (~user@12.5.211.156) (Ping timeout: 260 seconds)
[06:02:21] *** Joins: shapr (~user@12.5.211.156)
[06:24:44] *** Quits: shapr (~user@12.5.211.156) (Ping timeout: 268 seconds)
[09:07:28] *** Quits: juhp (~juhp@128.106.188.82) (Quit: juhp)
[09:19:52] *** Joins: featurebug (~featurebu@49.205.122.91)
[09:20:30] <featurebug> Hi! Are there keyboard shortcuts to run actions like evaluate expressions?
[09:24:21] <jneira[m]> feat  urebug:  it is no one afaik, you could use the eval plugin, which involves start a line with `-- >> expression` and click on the code lens `evaluate`, the editor will print the result in the next line
[09:24:52] <jneira[m]> s/feat  urebug/featurebug/
[09:25:54] <featurebug> yes i am referring to this feature only. Is there a keyboard shortcut to do this instead of clicking evaluate with the mouse?
[09:27:32] <jneira[m]> hmm, not sure if you can link a keystroke to a code lens
[10:58:25] *** Joins: coot (~coot@89-64-85-93.dynamic.chello.pl)
[11:03:49] <jneira[m]> featurebug: maybe https://github.com/microsoft/vscode/pull/91232 ?
[11:07:53] <jneira[m]> hmm it seems to me that hls happly starts with no feedback when hie-bios fails to build the project
[11:08:26] <jneira[m]> pepeiborra: https://github.com/haskell/haskell-language-server/pull/2484 would fix that?
[11:08:27] <featurebug> jneira: thanks. I think this is what i was looking for
[11:08:48] *** Joins: arrowd (~arr@2.94.236.140)
[13:08:35] *** Quits: greyrat_ (~greyrat@ip202.ip-51-178-215.eu) (Bye)
[13:08:55] *** Joins: greyrat (~greyrat@ip202.ip-51-178-215.eu)
[13:11:11] *** Joins: Gowilla (~ganesh@urchin.earth.li)
[13:11:22] *** Server sets mode: +nt 
[13:11:28] *** Joins: pie_ (~pie_bnc@user/pie/x-2818909)
[13:14:36] *** Joins: adamCS_ (~adamCS@ec2-34-207-160-255.compute-1.amazonaws.com)
[13:16:45] *** Quits: pie__ (~pie_bnc@user/pie/x-2818909) (*.net *.split)
[13:16:45] *** Quits: greyrat_ (~greyrat@ip202.ip-51-178-215.eu) (*.net *.split)
[13:16:45] *** Quits: Heffalump (~ganesh@urchin.earth.li) (*.net *.split)
[13:16:46] *** Quits: adamCS (~adamCS@ec2-34-207-160-255.compute-1.amazonaws.com) (*.net *.split)
[13:16:46] *** adamCS_ is now known as adamCS
[14:52:43] *** Quits: yoshitsugu (uid529929@id-529929.hampstead.irccloud.com) (Quit: Connection closed for inactivity)
[15:36:14] *** Quits: featurebug (~featurebu@49.205.122.91) (Ping timeout: 260 seconds)
[16:03:27] *** Joins: featurebug (~featurebu@49.205.122.91)
[16:48:32] <Philonous> Is there a way to globally disable a HLS_plugin? One of them seems to msibehave and I'd like to see if the problem goes away if I turn it off
[16:49:39] <Philonous> I found the page that talks about configuring HLS and even gives the specific option, but it doesn't explain how to actually apply it, i.e. where does haskell-language server look for configuration files or what's the argument to set it
[16:53:38] *** Quits: coot (~coot@89-64-85-93.dynamic.chello.pl) (Quit: coot)
[16:54:08] *** Joins: coot (~coot@89-64-85-93.dynamic.chello.pl)
[17:28:36] <michaelpj[m]> Philonous: it's client-dependent, unfortunately
[17:28:42] <michaelpj[m]> client=editor
[17:29:29] <Philonous> I see, emacs' lsp-haskell doesn't seem to have an option for the plugin I want to disable
[17:31:20] <michaelpj[m]> Philonous: I just updated the options, so hopefully it should be more comprehensive now
[17:31:34] <michaelpj[m]> i.e. yesterday
[17:32:56] <Philonous> Ah, I updated all my emacs packages today, so I should have the newest one
[17:33:03] <Philonous> There seem to be more options
[17:33:08] <Philonous> But the one I'm looking for is hls-alternate-number-format-plugin
[17:34:18] <Philonous> Oh, that one seems to be newer than the latest release, which explains why it's not in lsp-haskell
[17:35:10] <michaelpj[m]> I guess that's probably it
[17:35:40] <Philonous> Also explains why I'm having trouble with it. I'll revert to the tagged release
[17:39:08] <Philonous> That solved my problem.
[18:24:20] <jneira[m]> uh, the plugin will be included in the next release, could you describe the problem briefly?
[18:58:23] *** Joins: juhp (~juhp@128.106.188.82)
[19:13:32] *** Joins: hololeap_ (~hololeap@user/hololeap)
[19:13:45] *** Quits: hololeap (~hololeap@user/hololeap) (Ping timeout: 276 seconds)
[19:26:56] *** Quits: featurebug (~featurebu@49.205.122.91) (Quit: Leaving)
[19:44:17] <fendor[m]> jneira: Are we using stack for anything mission critical in HLS?
[19:45:28] <fendor[m]> I want to make a push to reduce the amount of files we need to modify to update a dependency, reducing stack.yamls and nix seems to be worthwhile, but want to ask first here whether others think so as well
[19:48:16] <wz1000> I would love to reduce the number of stack.yamls we have to update
[19:49:43] <fendor[m]> I imagine having one cabal.project, one cabal.project.nightly, one stack.yaml and one stack-nightly.yaml would be feasible
[19:50:41] <fendor[m]> maybe even ditching stack-nightly, arguing you probably don't want to use stack for bleeding edge development anyway
[20:03:56] *** Quits: coot (~coot@89-64-85-93.dynamic.chello.pl) (Quit: coot)
[20:34:25] <sm> quite a lot of hls deps seem to not be in stackage.. if that could be improved, maintaining stack yamls might become much easier ?
[20:40:19] <michaelpj[m]> as a non-stack user, I am pro reducing the amount of stack files :p
[20:43:19] <sm> it might not be worth the cost for you folks, but in general it seems a good thing to have at least one documented repeatable build plan for each supported major GHC version, as a reference and fallback in times of trouble. If not stack.yamls, that means cabal freeze files, and stack yamls are easier.
[20:44:49] <sm> unrelated: I checked out haskell-language-server and vs code can't list the git commits. That's weird.. is it just me ?
[21:18:51] *** Gowilla is now known as Heffalump
[21:37:58] <fendor[m]> sm: if we check that there *is* a build-plan with cabal for each ghc version, you think we still need to check-in freeze-files?
[21:38:36] <sm> fendor: check when, how often ? cabal can find a new build plan each time you run it
[21:38:54] <fendor[m]> and what are the benefits in that case?
[21:38:54] <fendor[m]> I definitely see the disadvantage for stack users, if they truly want to develop GHC stuff and make sure it compiles with every GHC version, they have basically no way of doing that besides CI
[21:39:29] <fendor[m]> sm: we use an index-state, and the somewhat implicit assumption is that once you have an index-state, cabal should, per-platform, always find the same build-plan
[21:39:49] <fendor[m]> so if CI proves there is a build-plan (e.g. by building with cabal) wouldn't that suffice?
[21:40:03] <sm> I'm not too familiar with index-state, but isn't that also dependent on cabal version, eg
[21:40:53] <sm> also, even if truly repeatable, it's quite opaque - not easy to inspect and see which version of package X is known to work
[21:41:16] <fendor[m]> sm: don't think so, not sure though
[21:41:40] <sm> cabal's solving algorithm can and does change
[21:41:42] <fendor[m]> sm: way easier to inspect than stack.yaml files: `cabal freeze` -> look at the freeze file containing each dependency
[21:41:48] <fendor[m]> sm: that is true
[21:41:53] <sm> a  list of package versions, or a named snapshot plus exceptions, is much more explicit and future proof
[21:42:30] <sm> stack yaml files and cabal freeze files are presumably equivalent (I haven't used freeze files much), but I think stack yaml files can be much easier
[21:42:41] <sm> but that's just my experience, YMMV
[21:43:07] <fendor[m]> sm: what does future proof mean in this context? What does it protect us from?
[21:43:41] <fendor[m]> sm: since you have to maintain stack.yaml files manually, not sure if I consider that easier
[21:44:41] <sm> as I was saying earlier, I think it can be quite useful to have at least one reference build plan for each GHC version. When someone is having trouble getting cabal/stack to build hls at all, or when troubleshooting a tricky issue that might depend on some dependency version, you have a known-good plan to compare with
[21:45:46] <sm> I was also saying, if hls's dependencies were better packaged in stackage, the stack yaml files become quite easy - this also tends to mean hls deps will be included in linux distros, nix etc. and may help hls packaging overall
[21:45:55] *** Joins: coot (~coot@89-64-85-93.dynamic.chello.pl)
[21:46:12] <fendor[m]> I don't think the latter is really feasible, as long as HLS development doesn't slow down
[21:46:55] <fendor[m]> e.g., for old stackage snapshots, we will never get the recent versions, forcing us to manually maintain the build-plan
[21:48:33] <sm> aren't old stack yamls essentially frozen, requiring little maintenance ? Also you don't have to maintain them forever.. just as many recent ones as you want
[21:49:45] <fendor[m]> yeah, but if we upgrade an HLS dependency for various reasons, e.g. a new hie-bios release, we need to add hie-bios to the extra-deps of the old stack.yaml
[21:50:31] <fendor[m]> if that bumped some lower version for some reason, we need to add that extra-dep as well to stack.yam
[21:51:17] <sm> how often does that happen currently ?
[21:52:20] <fendor[m]> it used to happen quite often when hie-bios was less stable, I don't follow development that closely at the moment, hence my question to jneira who deals probably the most with such tasks
[21:53:41] <fendor[m]> however, I have seen that the amount of stack.yaml, cabal.project and nix turned away potential contributors twice already
[21:54:25] <fendor[m]> or at least, delayed their contribution
[21:54:47] <sm> cabal.project looks pretty easy.. just a list of local packages ?
[21:55:04] <fendor[m]> yeah, basically
[21:55:12] <fendor[m]> the cabal-ghc9.project is a bit more complex
[21:55:22] *** Quits: jade (jade@lfcode.ca) (Quit: meow)
[21:55:22] <sm> where's the nix config.. these flake files ?
[21:55:36] <fendor[m]> flake.nix
[21:55:53] *** Joins: jade (~jade@lfcode.ca)
[21:56:23] <sm> I can see how these would scare casual contributors.. I definitely wouldn't require them to deal with those. I think such packaging needs a specialist or senior contributor
[21:56:44] <fendor[m]> nix always needs a specialist üòÄ 
[21:56:46] <sm> (or, automation)
[21:57:21] <fendor[m]> that's the other idea, if we can automate the maintenance of stack/nix/cabal, I am also satisfied
[21:57:36] <fendor[m]> as lons as their is only one (or maybe two) sources of truth
[22:00:46] <sm> I could do a bit of stack yaml testing/cleanup, if they are going to stick around a while longer
[22:01:53] <sm> if you feel you're getting no benefit from them, you should certainly drop them. I'd be sad, as they always give me confidence I can build a project now and in future
[22:03:04] <fendor[m]> I think, they give us no tangible benefit, but that's just my opinion, although you gave me some things to think about
[22:03:56] <fendor[m]> we probably have to wait and see what other contributors think about it.
[22:05:18] <sm> üëçÔ∏è
[22:21:58] <jneira[m]> i am mostly a cabal user nowadays and never used only stack but to have a out of the box working stack.yaml for the ghc version you need, makes dramatically easier start to hack with stack 
[22:22:15] <jneira[m]> specially for beginners using stack
[22:22:43] <jneira[m]> * to hack hls with stack
[22:23:55] <jneira[m]> create a working stack.yaml  from zero or from one using a newer lts for beginners can be really painful
[22:24:35] <jneira[m]> you need a quite advanced knowledge of stack and cabal to do it
[22:25:53] <jneira[m]> but having a superficial knoweldge and a existing stack.yaml the update usually are mechanical
[22:26:36] <jneira[m]> i know, boring, cumbersome, but easy to do
[22:27:11] <jneira[m]> s/are/is/
[22:36:11] <jneira[m]> so i would say having stack.yaml's and make devs conjure one from the thin air would scare more possible stack contributors than the mechanical but easier to do work of update the existing ones could scare no stack contributors
[22:41:19] <jneira[m]> * would say not having stack.yaml's
[22:44:32] <jneira[m]> almost always when the stack build fails, you inspect it quickly and you can suggest to the non stack contributor: "add `xyz-1.2.3` to all stack.yaml's" or "update abc to 4.5.6"
[22:44:48] <sm> jneira, I agree, the stack yamls are really helpful for stack users, particularly with a project as complex and partially packaged as this one
[22:45:14] *** Quits: arrowd (~arr@2.94.236.140) ()
[22:45:38] <sm> in some projects I can trivially `stack init`, but in this one I would hate to have to recreate these from scratch
[22:45:58] <jneira[m]> i am afraid that chase all our dpendency tree to get it in stackage is a hopeless effort
[22:46:11] <sm> is it really ? 
[22:46:27] <sm> many things that once weren't in stackage, now are
[22:46:42] <jneira[m]> sm: really simply projects or with its dep tree already in stackage
[22:46:43] <sm> and it's not wasted effort.. stackage is used as the basis for other packaging systems
[22:46:47] <jneira[m]> i guess
[22:46:59] <jneira[m]> it would be useful indeed
[22:47:20] <jneira[m]> but i guess some maintainers simply dont want to be in stackage
[22:47:36] <sm> there is also a question of are so many deps really needed or wise.. there seems to be no restraint at all. I suppose with so many contributed plugins there's not much hope
[22:47:49] <jneira[m]> and chase all thse maintainers could consume all your time for several months :-P 
[22:48:32] <jneira[m]> s/thse/those/
[22:48:34] <sm> I know, but on the other hand it's work that is easy to crowd-source (a great way to tap contributor energy)
[22:50:12] <sm> I just cleaned up stack-9.0.1.yaml a bit, and it currently seems to require 19 extra deps, all on hackage
[22:50:27] <jneira[m]> nice
[22:51:02] <jneira[m]> old lts's dont need so much work as you mentioned above
[22:53:08] <sm> interesting.. I see just by pushing to my own fork of hls it has triggered a gigantic set of CI workloads. Is there a way to prevent that, other than altering the .github/workflow files ? Maybe [ci skip] in commit messages ?
[22:53:13] <jneira[m]> i am adding support for brittany and floskell + ghc-9.0.1 and aeson-2.0, it will need some changes in stack.yamls too
[22:54:13] <jneira[m]> sm: hmm it should skip the cabal and nix builds, they are started but skipped quickly
[22:54:34] <jneira[m]> (at least in theory ;-) )
[22:55:08] <sm> https://github.com/simonmichael/haskell-language-server/actions are the jobs, FWIW
[22:57:38] * sm tries to avoid gratuitous power waste and carbon emissions 
[22:59:03] <jneira[m]> oh you pushed to your fork master branch, i thought you opened a pr inthemain repo
[22:59:57] <jneira[m]> yeah those builds are triggered by commits on master but are useful in the main repo not in forks
[23:00:23] <jneira[m]> i usually push to feature branch in my repo and dont touch master
[23:00:39] <jneira[m]> but it is a matter of convenience
[23:00:54] <sm> I see
[23:00:57] <jneira[m]> * push to a feature branch
[23:01:23] <jneira[m]> s/oh you pushed to your fork master branch, i thought you opened a pr inthemain repo/oh you pushed to your fork master branch, i thought you opened a pr in the main repo/
[23:02:09] <jneira[m]> (well i sync master with the main repo from time to time)
[23:02:15] <fendor[m]> <jneira[m]> "i am mostly a cabal user..." <- I did not argue for now to completely remove stack files, just only one or two stack.yaml's
[23:02:59] <jneira[m]> so one for each ghc major version: 8.6.5, 8.8.4, 8.10.7 and 9.0.1?
[23:03:19] <jneira[m]> (and the default one :-P )
[23:03:50] <sm> I would certain remove 8.10.6, and possibly 8.6 ?
[23:03:57] <jneira[m]> would love to be able to automate its generation given a cabal-plan, bu i think we talked about that in the past
[23:04:08] <fendor[m]> no, one stack.yaml for some version and one for nightly, e.g. 9.2 or something
[23:04:34] <fendor[m]> so overall two stack.yaml's at most
[23:05:59] <jneira[m]> do you think you could make a new one for 8.6.5 easily given those? 
[23:06:22] <fendor[m]> probably not, since I was told we can't easily generate them from, e.g. a freeze file
[23:07:15] <jneira[m]> that is the problem, update the existing one is lot ot easier than generate a new one
[23:07:18] <jneira[m]> so removing them we lose value
[23:07:27] <jneira[m]> s/ot/lot/
[23:08:13] <fendor[m]> but maintaining them costs something too, is the value we gain worth it in your opinion?
[23:08:21] <jneira[m]> (and you are a expeirenced haskell developer with a fair knowledge of cabal and stack, imagine a beginner)
[23:09:09] <fendor[m]> I have watched a beginner trying to contribute a plugin, but these files discouraged them to not continue with the project indefinitely
[23:09:11] <fendor[m]> which is part of my motivation
[23:09:25] <fendor[m]> I think it will benefit beginners to not have so many files
[23:09:54] <jneira[m]> hmm he/she was not a stack user i guess
[23:10:08] <fendor[m]> and it looks like, all these files are definitely not meant for beginners but for hls maintenance in some way
[23:10:25] <fendor[m]> jneira[m]: no, and doesn't have nix even installed
[23:10:43] <fendor[m]> (actually former stack user, but only like, add depends to a package.yal)
[23:10:45] <fendor[m]> s/yal/yaml/
[23:11:57] <jneira[m]> mmm and update stack.yaml was hard?
[23:12:07] <fendor[m]> maybe we argue tooling beginners just have a hard time but I think that is ridicolous considering they finished the plugin itself, but satisfying stack and nix and cabal is a solid hassle
[23:12:58] <fendor[m]> jneira[m]: yeah it needs this Cabal bump to 3.6 due to cabal-fmt
[23:13:07] <jneira[m]> ya we are take for granted cabal cause it is used for most maintainers
[23:13:43] <jneira[m]> oh i remember, the cabal.fmt plugin, sad to read that
[23:13:54] <fendor[m]> yeah, I am pushing them again once the semester is over
[23:14:01] <jneira[m]> bump Cabal can be one of the most annoying changes you have to do
[23:14:59] <fendor[m]> indeed, and stack sometimes behaves weirdly. I remember this time where stack changed the Cabal version for some reason, back in HIE
[23:16:28] <fendor[m]> so, unfortunate first contribution as well
[23:19:45] <jneira[m]> but updating 6 stack yaml is not qualitative different of updating 2, no?
[23:20:25] <jneira[m]> i mean the difficulty is in how much old is the lts (specially for Cabal)
[23:20:46] <sm> jneira: what's more common, people needing to build hls with various ghc versions, or people contributing to hls (and being required to also maintain the stack yaml files) ?
[23:20:58] <sm> (I think contributors should not be expected to do that)
[23:21:26] <sm> sorry, I meant: fendor
[23:21:44] <sm> I say the people needing to build are much more numerous and less technical
[23:21:58] <sm> in fact, the new contributors are those people too
[23:22:22] <sm> if you make it harder for stack users to even build the project, no stack users will contribute
[23:23:17] <jneira[m]> I would be much more afraid of nix files than stack.yam's
[23:24:05] <sm> jneira, in ghcide.cabal " we can't use >= 1.7.10 while we have to use hlint == 3.2.*" - is this out of date ?
[23:24:47] <jneira[m]> cause i dont know nix! and i cantinstall it in my os... ü§∑
[23:24:56] <jneira[m]> well i installed it in wsl recently :-P 
[23:25:10] <jneira[m]> s/cause i dont know nix! and i cantinstall it in my os... ü§∑/cause i dont know nix! and i cant install it in my os... ü§∑/
[23:26:01] <jneira[m]> sm: nope, i moved that constraint to hls-hlint-plugin.cabal but hlint-3.2 does not support it
[23:26:16] <jneira[m]> and hlint-3.3 dont support ghc-8.6.5
[23:26:26] <jneira[m]> same for aeson-2.0
[23:26:41] <jneira[m]> jneira[m]: i moved in my actual work
[23:27:03] <jneira[m]> https://github.com/jneira/haskell-language-server/pull/54/files
[23:27:24] <jneira[m]> i have to open it as a wip in the main repo
[23:27:33] <sm> phew, this is complex
[23:27:45] <sm> when can you drop support for ghc 8.6 do you think ?
[23:28:00] <sm> is someone paying for that ?
[23:28:07] <jneira[m]> the issue is https://github.com/haskell/haskell-language-server/issues/2477
[23:28:45] <jneira[m]> tracking all upstream deps: floskell got aeson-2.0.1 and ghc-9.0.1 just today :-) 
[23:30:01] <jneira[m]> and i asked @ndmitchell for some backports: https://github.com/ndmitchell/hlint/issues/1328
[23:30:16] <jneira[m]> but i think hlint doesnt do those things
[23:30:31] <sm> jneira: is this related to my ghc 8.6 question ? not sure
[23:31:26] <jneira[m]> sm: theoretically when lts support 9.0.*
[23:32:57] <jneira[m]> https://haskell-language-server.readthedocs.io/en/latest/supported-versions.html#current-ghc-version-support-status
[23:32:58] <sm> why is that.. you try to support last 3 major-ghcs-with-lts-snapshots ?
[23:33:13] <jneira[m]> jneira[m]: sorry 9.2
[23:33:19] <sm> nice doc
[23:33:54] <jneira[m]> yeah michaelpj did a good job
[23:34:41] <sm> dropping 8.6 seems like the quickest way to remove some packaging complexity, so I wonder if someone is paying for the extra work it is generating
[23:34:59] <sm> given the long delays in ghc releases, I think it would be reasonable to drop 8.6 at this point
[23:35:26] <jneira[m]> nope, we discussed it and we agree in that
[23:35:27] *** Quits: juhp (~juhp@128.106.188.82) (Ping timeout: 256 seconds)
[23:35:41] <jneira[m]> 8.6.5 was a rock solid release for all supported os's
[23:35:52] <jneira[m]> it is the supported version for ghcjs
[23:36:43] <sm> you agreed to keep 8.6, ok I respect that. It's making packaging harder, but I guess you collectively decided it's worth doing, and/or someone has funded the work
[23:36:48] <jneira[m]> and it seems many workshops continue using it in private repos (i dot have nukbers)
[23:37:14] *** Joins: juhp (~juhp@128.106.188.82)
[23:37:35] <jneira[m]> sm: well in theory we should drop it with 9.0.1 in lts
[23:37:46] <sm> I'm just brainstorming possibilities while attempting to clean up stack 9.0.1 yaml, which is of course harder than it looks
[23:37:54] <jneira[m]> it is somewhat a exception
[23:38:46] <fendor[m]> <sm> "jneira: what's more common..." <- I don't think that many people build HLS from source anymore (at least I do not anymore). Since HLS is in stackage, I think people rather use something like `stack build hls` in their project, or is that possible?
[23:39:00] <fendor[m]> s/possible/impossible/
[23:39:51] <sm> fendor, people contributing to hls need to build it in the source repo, surely ?
[23:39:52] <fendor[m]> <sm> "I say the people needing to..." <- I am not sure, people building from source are contributors, and for a lot of contributions, one ghc version suffices
[23:40:28] <sm> remember many people are restricted in what ghc version is available or works correctly on their platform
[23:40:34] <fendor[m]> sm: yeah, and that is exactly my point/question. How many use stack for that and how often do they need the stack.yamls
[23:40:43] <sm> mac users can't use ghc < 8.10, for example
[23:41:01] <fendor[m]> mac m1 users, right? Not all mac users
[23:41:08] <jneira[m]> he
[23:41:13] <sm> I forget, I think it was pre m1 also
[23:41:24] <sm> there have been many issues, I don't remember the full detail
[23:41:43] <fendor[m]> iirc, 8.10.* series was pretty much busted on macos, except for the latest one...
[23:42:00] <sm> most ghc versions have been busted on at least one major platform :(
[23:42:01] <jneira[m]> yeah, buggy in x86 macs
[23:42:32] <jneira[m]> sm: hence the need to keep them, one for each os :-D 
[23:42:54] <fendor[m]> well, if that is an argument, I would like to have a matrix for that, because I am not sure when we drop a ghc version, that we consider that (e.g. can't remember when anybody asked that question)
[23:43:44] <jneira[m]> https://github.com/haskell/haskell-language-server/issues/2168
[23:43:53] <jneira[m]> long discussion there
[23:45:41] <fendor[m]> I see
[23:48:23] <fendor[m]> Well I yield for now üòÄ 
[23:48:38] <sm> anyway, I think it's admirable to keep supporting 8.6, but I hope that the companies wanting that are paying for it
[23:49:16] <fendor[m]> even if they are paying, have we even decided how the funds are spent? E.g. do they reach the relevant contributors?
[23:49:28] <sm> because it is complicating packaging for newer versions, eg making stack yamls more harder to maintain, which in turn is causing fendor to want to drop them
[23:49:53] <fendor[m]> true
[23:49:59] * sm doesn't know hls funding situation, but had the impression there was some
[23:50:54] <fendor[m]> there is some funding, but so far, I think only CI (or is that HF?) and my summer project was funded. But no maintenance funds, so far, I think?
[23:51:25] <sm> hls should really be getting some serious funding, via HF eg
[23:51:44] <fendor[m]> yeah I think so
[23:51:48] <sm> I'm sure some of HFs big sponsors are relying on hls heavily
[23:52:12] <fendor[m]> absolutely, but I just mean, HLS devs haven't fully decided yet how to spend them
[23:52:31] *** Quits: coot (~coot@89-64-85-93.dynamic.chello.pl) (Quit: coot)
[23:52:34] <sm> yes, that's a whole other challenge I agree
[23:53:37] <sm> Zig (programming language) has an interesting well organized funding model, where some number of core devs are paid some level of "salary"
[23:55:33] <fendor[m]> how are open-source core-devs defined? Sounds interesting
[23:56:03] <sm> they have a strong leader and maybe some kind of board, who selects and adds them
[23:56:34] <sm> when regular funding reaches a sufficient level, they add another funded dev
[23:58:04] <sm> organising and managing funding is a whole job by itself, of course
[23:58:23] <sm> if I'm not being too distracting here.. about how many active devs does hls have now ?
[23:58:51] <sm> I'm sorry to hear there isn't much funding at all. Makes me want to sponsor.
[23:59:28] <sm> I guess github would be the best way right now
[23:59:58] <sm> oh, or opencollective
