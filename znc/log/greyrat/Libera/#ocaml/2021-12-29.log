[00:02:16] *** Joins: mro (~mro@port-92-195-164-218.dynamic.as20676.net)
[00:11:17] *** Quits: gravicappa (~gravicapp@178.214.248.83) (Ping timeout: 240 seconds)
[00:13:24] *** Joins: greenbagels (~gb@user/greenbagels)
[00:45:38] *** Quits: kaph_ (~kaph@net-2-38-107-19.cust.vodafonedsl.it) (Remote host closed the connection)
[00:46:02] *** Joins: kaph_ (~kaph@net-2-38-107-19.cust.vodafonedsl.it)
[01:23:58] <d_bot> <Abbix> is this a bridge or what
[01:24:01] <d_bot> <Abbix> I mean the bot
[01:24:22] <d_bot> <NULL> Look at the channel description
[01:24:29] <d_bot> <Abbix> oh yea
[01:24:30] <d_bot> <Abbix> mb
[01:27:00] <d_bot> <VPhantom> We all get caught initially. ðŸ˜‰
[01:28:41] *** Quits: kaph_ (~kaph@net-2-38-107-19.cust.vodafonedsl.it) (Remote host closed the connection)
[01:29:06] *** Joins: kaph_ (~kaph@net-2-38-107-19.cust.vodafonedsl.it)
[01:31:11] <d_bot> <somebody> late but... technically both. i think most clients default to alerting when your own username is mentioned, but generally you can customize the list of keywords that notify you, which is pretty nice
[01:47:21] *** Quits: kaph_ (~kaph@net-2-38-107-19.cust.vodafonedsl.it) (Read error: Connection reset by peer)
[01:47:35] *** Joins: kaph (~kaph@net-2-38-107-19.cust.vodafonedsl.it)
[02:08:24] *** Joins: vicfred (~vicfred@user/vicfred)
[02:09:08] *** Quits: kaph (~kaph@net-2-38-107-19.cust.vodafonedsl.it) (Read error: Connection reset by peer)
[02:09:27] *** Quits: bartholin (~bartholin@2a01:cb11:1ef:d800:4fc6:aec1:8fb8:a2e1) (Quit: Leaving)
[02:10:41] *** Quits: mro (~mro@port-92-195-164-218.dynamic.as20676.net) (Quit: Leaving...)
[02:14:53] *** Joins: kaph_ (~kaph@net-2-38-107-19.cust.vodafonedsl.it)
[02:31:48] *** Joins: rgrinberg (~textual@2806:265:5401:9431:1190:319b:cdf4:fd53)
[02:48:14] *** Quits: hackinghorn (~hackingho@user/hackinghorn) (Ping timeout: 260 seconds)
[02:55:58] *** Joins: hackinghorn (~hackingho@user/hackinghorn)
[03:11:11] *** Quits: greenbagels (~gb@user/greenbagels) (Ping timeout: 252 seconds)
[03:24:43] *** Joins: greenbagels (~gb@user/greenbagels)
[03:43:51] *** daimrod2 is now known as daimrod
[03:51:52] <bgs> coming from imperative languages, I often wonder, how does Ocaml manage to be so fast despite lots of things in memory being copied very often (instead of being mutated)?
[03:54:48] <d_bot> <NULL> Few things are actually copied. Like list and tree operations don't need copying, they just need reorganisation of some nodes
[03:55:09] <d_bot> <NULL> (Except for list appending, that really copies the list on the left)
[03:55:22] <d_bot> <NULL> ~~copies~~ duplicates
[03:56:24] *** Quits: vicfred (~vicfred@user/vicfred) (Quit: Leaving)
[03:56:31] <d_bot> <NULL> And also, memory allocation is made really fast by how the runtime manages (part of) its heap like a stack so allocation is just increasing a value
[04:05:30] *** Quits: hackinghorn (~hackingho@user/hackinghorn) (Quit: Leaving)
[04:18:49] <companion_cube> You can also still use mutation in ocaml
[04:18:56] <companion_cube> The compiler does it a lot, for example
[04:19:46] <d_bot> <NULL> Unrelated: how are message edits conveyed to IRC ?
[04:21:39] *** Joins: manjaro-user (~manjaro-u@2a01cb088b41f700608ae66dcc23aba7.ipv6.abo.wanadoo.fr)
[04:24:05] <d_bot> <NULL> Apparently they're not
[04:26:12] *** Quits: manjaro-user (~manjaro-u@2a01cb088b41f700608ae66dcc23aba7.ipv6.abo.wanadoo.fr) (Client Quit)
[04:26:25] *** Joins: manjaro-user (~manjaro-u@2a01cb088b41f700608ae66dcc23aba7.ipv6.abo.wanadoo.fr)
[04:27:02] *** Quits: manjaro-user (~manjaro-u@2a01cb088b41f700608ae66dcc23aba7.ipv6.abo.wanadoo.fr) (Client Quit)
[04:41:21] <bgs> NULL: thanks
[04:42:03] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Quit: WeeChat 3.3)
[04:42:31] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[04:43:01] <bgs> companion_cube: I am aware of that. Sadly I have an assignment to solve and the glue code that I have to use is written in a fairly inefficient way, with almost no utilization of mutability, just copying everything
[04:44:01] <bgs> which would be fine, if the assignment weren't a competition in who writes the fastest solution
[04:48:28] <companion_cube> ah well, then look at Map/Set
[05:03:20] <bgs> I don't think I can use them to my advantage in this task, but thanks for the suggestion
[05:12:46] <Corbin> bgs: Something that wasn't quite said yet (although this is because I think NULL and companion_cube have internalized it) is that a large portion of computational time is simply spent scrolling through space without mutating anything.
[05:18:13] <companion_cube> scrolling through space?
[05:26:33] <Corbin> Like, navigating through address space. Chasing pointers, adding relative offsets, counting struct components, hashing structs, etc.
[05:27:54] <companion_cube> ah well, that depends on the language and program, doesn't it?
[05:28:04] <companion_cube> a reason why C++ and the likes are so fast is because they allow you to minimize that
[05:28:27] <companion_cube> (adding offsets is free, btw. pointers are indeed the expensive part)
[05:29:18] <bgs> well, chasing pointers and adding relative offsets is definitely a significant portion of every program
[05:29:25] <Corbin> Inasmuch as "space" and "time" are tied to Turing machines, yeah. But that also does describe our current CPUs, and it shows up in descriptive complexity a little, too.
[05:30:05] <bgs> relative offsets are important enough to have  a dedicated cpu instruction
[05:32:20] *** Quits: rgrinberg (~textual@2806:265:5401:9431:1190:319b:cdf4:fd53) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[05:39:21] <companion_cube> afaik the load instructions can bake an offset directly in them
[05:39:41] <companion_cube> all the cost is cache misses on pointer dereference
[05:39:58] <companion_cube> (as in, 100x or worse, compared to an addition)
[05:40:39] <bgs> yeah, absolutely
[05:41:39] <bgs> copying lots of stuff also makes this worse
[05:41:44] <Corbin> ...And the typical cost of any opcode. Even if it's a NOP, it costs a quantum of time. "It adds up, Jerry!" etc.
[05:41:48] <bgs> more memory -> more cache misses
[05:42:22] <companion_cube> Corbin: negligible quantities
[05:43:15] <d_bot> <NULL> ~0.4ns, assuming >2.5 GHz
[05:43:27] <companion_cube> one indirection or one test could cost you the equivalent of hundreds of additions
[05:43:27] <Corbin> companion_cube: At least in traditional complexity theory, on TMs or RAM machines, the time adds up. I grok and agree with your point that modern CPUs are very cache-dependent and a RAM-machine analysis isn't appropriate.
[05:43:53] <companion_cube> not just cache
[05:43:59] <companion_cube> branch prediction, pipeline, etc.
[05:44:27] <companion_cube> it's also why basic hashing (FNV and the likes, say) is basically free
[05:44:40] <companion_cube> but binary search might not be
[05:51:06] *** Quits: Tuplanolla (~Tuplanoll@91-159-68-119.elisa-laajakaista.fi) (Quit: Leaving.)
[05:52:42] <d_bot> <Et7f3> Cpu has read cache but does some cpu have write cache
[05:55:13] <companion_cube> the cache goes both ways afaik, and there's invalidation from other cores
[05:56:31] <d_bot> <EduardoRFS> yeah both ways
[05:56:41] <d_bot> <EduardoRFS> "there's invalidation fro other cores", not really, unless you flush it
[05:57:11] <d_bot> <Et7f3> And a pattern I like to do is reverse loop (The count variable can be used instead of 2 variables can be useful in some can where you do i < something.size() even if it is O(1) )
[05:58:20] <d_bot> <Et7f3> I should benchmark. But does this pattern can cause more cache invalidation ?
[05:58:38] <companion_cube> @EduardoRFS if there's an atomic in your cache that's modified by another core?
[05:59:18] *** Joins: rgrinberg (~textual@2806:265:5401:9431:1190:319b:cdf4:fd53)
[05:59:46] <d_bot> <EduardoRFS> @Et7f3 not really cache lines are 64 bytes aligned, so it doesn't matter the direction that you access
[06:03:11] <bgs> reverse loop is usually slower, but not because of cache
[06:03:58] <d_bot> <EduardoRFS> TLDR from what I understand / remember on x86 there is cache coherence, even across cores, but that's not true on ARM even under ARM64 IIRC
[06:04:32] <companion_cube> so what happens when two cores are trying to access the same atomic?
[06:04:43] <companion_cube> (with the stronger memory orderings)
[06:05:28] <d_bot> <EduardoRFS> on x86 they will always have the same data, on ARM one core can read a piece of data and another one can read a different piece of data
[06:05:45] <d_bot> <Et7f3> bgs: Why reverse loop is slower ? It also free one register
[06:07:07] <d_bot> <EduardoRFS> https://developer.arm.com/documentation/den0024/a/Multi-core-processors/Cache-coherency
[06:07:44] <d_bot> <EduardoRFS> BTW this is probably a big win for multiprocessor ARM
[06:09:40] <bgs> Et7f3 no idea about the underlying mechanisms, but the simple answer is "because it is optimized for the most common access pattern, which is looping forward over the memory"
[06:10:32] <bgs> one register more/less has much less impact than memory access latency
[06:10:40] <d_bot> <EduardoRFS> probably prefetching
[06:12:20] <bgs> and nowadays reasoning about register consumption is pretty much guesswork anyway
[06:12:28] *** Joins: hackinghorn (~hornhacki@137.132.213.131)
[06:12:36] *** Joins: hackhorn (~hornhacki@137.132.213.131)
[06:12:39] <d_bot> <EduardoRFS> https://www.agner.org/optimize/microarchitecture.pdf
[06:13:07] <d_bot> <EduardoRFS> well someone did gather the data for us, so you can actually predict register renaming on the CPU
[06:13:12] <hackinghorn> hi
[06:14:00] *** Quits: hackinghorn (~hornhacki@137.132.213.131) (Changing host)
[06:14:00] *** Joins: hackinghorn (~hornhacki@user/hackinghorn)
[06:17:14] *** Quits: zebrag (~chris@user/zebrag) (Quit: Konversation terminated!)
[06:18:59] *** Quits: hackhorn (~hornhacki@137.132.213.131) (Quit: Leaving)
[06:22:27] <companion_cube> @EduardoRFS that can't be the case, not with atomics
[06:22:33] <companion_cube> there are some strong guarantees
[06:23:00] <companion_cube> (if you do a compare and swap, there must be some form of cache invalidation, otherwise your atomics are broken)
[06:24:21] <d_bot> <EduardoRFS> oh yeah, there is memory barriers on ARM, mb, thought you were talking about general instructions like mov
[06:24:46] <companion_cube> oh, no
[06:24:48] <d_bot> <EduardoRFS> on x86 not only mov is atomic if memory aligned but hardware always have cache coherence
[06:24:56] <companion_cube> x86 is too strong indeed
[06:40:37] *** Quits: Haudegen (~quassel@178.115.237.87.static.drei.at) (Ping timeout: 240 seconds)
[06:50:59] *** Quits: kaph_ (~kaph@net-2-38-107-19.cust.vodafonedsl.it) (Ping timeout: 256 seconds)
[06:55:20] *** Joins: kaph (~kaph@net-2-38-107-19.cust.vodafonedsl.it)
[07:06:43] *** Joins: mbuf (~Shakthi@27.58.131.180)
[07:14:44] *** Joins: zebrag (~chris@user/zebrag)
[07:18:17] <d_bot> <minimario> in vscode is there an ocaml extension where you can hover on an object and jump to its type definition
[07:18:34] <d_bot> <minimario> like my extension does type inference and all
[07:18:38] <d_bot> <NULL> Well-configured OCaml Platform
[07:18:39] <d_bot> <minimario> but i want to see what the type actually is
[07:19:01] <d_bot> <minimario> how do you configure ocaml platform to do that lol
[07:20:22] <d_bot> <NULL> Assuming you use dune and the switch you use is the global one, simply building the project (and possibly lightly editing the file) should make all useful tooltips appear
[07:28:09] <d_bot> <minimario> can you easily go from a .ml to a .mli
[07:28:18] <d_bot> <minimario> and vice versa
[07:28:47] <d_bot> <NULL> Depends what you mean. If you just mean switching between existing files, there's an icon at the top-right corner
[07:29:07] <d_bot> <minimario> oh wow i didn't see this icon
[07:29:19] <d_bot> <minimario> this is useful
[07:29:43] <d_bot> <minimario> learning so much about my ide today
[07:31:18] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 268 seconds)
[07:41:43] <d_bot> <darrenldl> bgs: glue code is in ocaml?
[07:43:40] <d_bot> <minimario> is it possible to set up some hotkey to show the type of a value
[07:43:43] <d_bot> <minimario> rather than have to hover over it
[07:47:26] <d_bot> <NULL> A hotkey to have the tooltip appear ? I don't know any, but I imagine even a global extension might add this
[07:47:51] <d_bot> <minimario> yeah i kind of want a vim like environment
[07:47:57] <d_bot> <minimario> in the comfort of vscode
[07:48:00] <d_bot> <minimario> hehe
[07:48:09] <d_bot> <minimario> i downloaded the vim for vscode extension but
[07:48:27] <d_bot> <minimario> it would be nice to be able to fully use keyboard
[07:49:57] <d_bot> <NULL> I found `editor.action.showHover` which is by default bound to `Ctrl+K Ctrl+I` apparently
[07:54:16] <d_bot> <minimario> where's this?
[07:54:20] <d_bot> <minimario> i don't have this in my defaultSettings.json
[07:56:03] <d_bot> <NULL> It's a keybinding, look there
[07:57:18] <d_bot> <minimario> ah i see
[07:57:27] <d_bot> <minimario> maybe my vim extension does weird things to keybindings
[07:57:49] <d_bot> <NULL> It shouldn't remove the action though
[07:58:09] <d_bot> <NULL> You should always be able to remap it
[08:03:23] <remexre> is there an equivalent of Java ArrayList that I'm not seeing in the OCaml standard library? (a resizable, mutable collection of arbitrary type)
[08:04:18] <d_bot> <NULL> No, you can look for Vector in "augmented standard libraries"
[08:05:16] <remexre> hm, okay
[08:05:17] <d_bot> <NULL> If you are used to the Stdlib, CCVector should be easy to pick up
[08:05:50] <d_bot> <NULL> Oh wait, "of arbitrary type" ?
[08:06:03] <d_bot> <NULL> Like not knowing anything about the type of the elements ?
[08:06:12] <remexre> no, like "not just for byte vectors"
[08:06:34] <remexre> CCVector looks like the shape of thing I want
[08:07:21] <d_bot> <NULL> Okay, so that's how I read it before, so CCVector should be good
[08:08:55] *** Quits: zebrag (~chris@user/zebrag) (Quit: Konversation terminated!)
[08:27:25] *** Quits: shawnw (~shawn_w@152.44.212.188) (Ping timeout: 268 seconds)
[08:29:09] <d_bot> <minimario> hmm my opam 4.13.1 version has ocaml 4.12 installed
[08:29:14] <d_bot> <minimario> this is so weird
[08:29:26] <d_bot> <minimario> can i upgrade ocaml without like completely removing the opam switch lol
[08:39:33] *** Joins: gravicappa (~gravicapp@178.214.248.83)
[08:58:40] <companion_cube> yeah you should be able to
[08:58:49] <companion_cube> something about `--unlock-base`
[09:16:18] <d_bot> <minimario> can you get the type of a highlighted expression with ocaml platform
[09:17:16] <companion_cube> a full expression, not sure â€” LSP doesn't have that
[09:17:53] <d_bot> <minimario> ah ok
[09:17:55] <d_bot> <minimario> sad
[09:18:01] <companion_cube> yeah it's a pity
[09:18:54] <d_bot> <minimario> can you go from a .mli declaration straight to the definition somehow
[09:19:50] <rgrinberg> no, that feature is not implemented yet
[09:20:31] <d_bot> <minimario> ðŸ˜¦
[09:21:10] <d_bot> <minimario> are there plug-ins where i can ðŸ˜›
[09:30:52] *** Joins: jlrnick (~josephler@42.118.113.78.rev.sfr.net)
[09:44:38] *** Joins: hackhorn (~hornhacki@137.132.217.135)
[09:46:09] *** Joins: hornhack (~hornhacki@137.132.220.137)
[09:46:57] *** Quits: hackinghorn (~hornhacki@user/hackinghorn) (Ping timeout: 240 seconds)
[09:49:29] *** Quits: hackhorn (~hornhacki@137.132.217.135) (Ping timeout: 256 seconds)
[09:49:51] <d_bot> <travv0> by default the hover keybinding is `gh` with the vim extension
[09:51:08] *** Joins: hackhorn (~hornhacki@137.132.213.136)
[09:53:45] *** Quits: hornhack (~hornhacki@137.132.220.137) (Ping timeout: 268 seconds)
[09:58:58] *** Quits: jlrnick (~josephler@42.118.113.78.rev.sfr.net) (Ping timeout: 260 seconds)
[10:01:09] *** Joins: hornhack (~hornhacki@137.132.212.136)
[10:03:17] *** Quits: hackhorn (~hornhacki@137.132.213.136) (Ping timeout: 240 seconds)
[10:13:25] *** Joins: bobo_ (~bobo@37.171.88.201)
[10:13:51] *** Quits: spip (~bobo@37.168.45.238) (Ping timeout: 256 seconds)
[10:28:08] *** Joins: hackhorn (~hornhacki@137.132.220.132)
[10:30:45] *** Quits: hornhack (~hornhacki@137.132.212.136) (Ping timeout: 250 seconds)
[11:11:17] *** Joins: shawnw (~shawn_w@c-73-225-121-73.hsd1.wa.comcast.net)
[11:43:38] *** Joins: hornhack (~hornhacki@137.132.220.136)
[11:46:13] *** Quits: hackhorn (~hornhacki@137.132.220.132) (Ping timeout: 256 seconds)
[11:46:57] *** Joins: Haudegen (~quassel@178.115.237.87.static.drei.at)
[11:49:31] *** Joins: epony (epony@user/epony)
[11:57:05] *** Quits: kaph (~kaph@net-2-38-107-19.cust.vodafonedsl.it) (Read error: Connection reset by peer)
[11:58:07] *** Joins: kaph (~kaph@net-2-38-107-19.cust.vodafonedsl.it)
[11:58:43] *** Joins: jlrnick (~josephler@42.118.113.78.rev.sfr.net)
[12:08:20] *** Joins: bartholin (~bartholin@2a01:cb11:1ef:d800:4fc6:aec1:8fb8:a2e1)
[12:15:59] *** Quits: epony (epony@user/epony) (Quit: QUIT)
[12:18:42] *** Joins: epony (epony@user/epony)
[12:23:38] *** Joins: hackhorn (~hornhacki@137.132.213.132)
[12:26:11] *** Quits: hornhack (~hornhacki@137.132.220.136) (Ping timeout: 245 seconds)
[13:07:17] *** Quits: kolexar (~kolexar@user/kolexar) (Remote host closed the connection)
[13:23:17] *** Joins: xd1le (~xd1le@user/xd1le)
[13:47:09] *** Quits: rgrinberg (~textual@2806:265:5401:9431:1190:319b:cdf4:fd53) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[13:52:56] <hackhorn> hi
[13:54:36] <dmbaturin> Hi hackhorn!
[13:55:01] <hackhorn> can I use String.sub if I use Base?
[13:55:32] <hackhorn> argg, Base has a different String.sub
[13:55:41] <dmbaturin> You mean use the standard String.sub when it's shadowed by its Base version? You can call it as Stdlib.String.sub I think.
[13:57:13] <hackhorn> ahh thankss
[14:07:39] *** Joins: hornhack (~hornhacki@137.132.214.140)
[14:10:30] *** Quits: hackhorn (~hornhacki@137.132.213.132) (Ping timeout: 260 seconds)
[14:17:37] *** Joins: hackhorn (~hornhacki@137.132.214.138)
[14:18:44] *** Quits: hackhorn (~hornhacki@137.132.214.138) (Client Quit)
[14:19:57] *** Quits: hornhack (~hornhacki@137.132.214.140) (Ping timeout: 240 seconds)
[14:34:34] *** Joins: Tuplanolla (~Tuplanoll@91-159-68-119.elisa-laajakaista.fi)
[15:41:30] *** Quits: Tuplanolla (~Tuplanoll@91-159-68-119.elisa-laajakaista.fi) (Ping timeout: 260 seconds)
[15:54:36] *** Joins: Tuplanolla (~Tuplanoll@91-159-69-90.elisa-laajakaista.fi)
[17:25:39] *** Quits: jlrnick (~josephler@42.118.113.78.rev.sfr.net) (Ping timeout: 256 seconds)
[17:39:47] *** Joins: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se)
[18:08:56] *** Joins: hackinghorn (~hackingho@user/hackinghorn)
[18:30:15] *** Quits: shawnw (~shawn_w@c-73-225-121-73.hsd1.wa.comcast.net) (Ping timeout: 256 seconds)
[18:46:57] *** Quits: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se) (Ping timeout: 240 seconds)
[18:49:06] *** Quits: xd1le (~xd1le@user/xd1le) (Quit: xd1le)
[19:08:22] *** Quits: hackinghorn (~hackingho@user/hackinghorn) (Quit: Leaving)
[19:28:41] *** Quits: vsiles (~vsiles@topinambour.cristau.org) (Ping timeout: 245 seconds)
[19:41:32] *** Joins: zebrag (~chris@user/zebrag)
[19:50:40] *** Joins: gdd (~gdd@129.199.146.230)
[20:28:18] *** Quits: zebrag (~chris@user/zebrag) (Remote host closed the connection)
[20:31:57] *** Joins: zebrag (~chris@user/zebrag)
[21:12:38] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[21:13:51] *** Joins: dalek-caan (~Thunderbi@109-252-124-86.nat.spd-mgts.ru)
[21:26:33] <d_bot> <RegularSpatula> If you are using Base and want to stick to it, you can use the base string sub function, see here: https://ocaml.janestreet.com/ocaml-core/latest/doc/base/Base__/Blit_intf/index.html#type-sub
[21:35:07] *** Quits: mbuf (~Shakthi@27.58.131.180) (Quit: Leaving)
[21:51:23] *** Joins: rgrinberg (~textual@2806:101e:7:33a5:7059:f90b:c049:c6ca)
[22:13:10] *** Joins: spip (~bobo@37.171.38.231)
[22:13:37] *** Quits: bobo_ (~bobo@37.171.88.201) (Ping timeout: 240 seconds)
[22:22:17] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 240 seconds)
[22:24:42] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[22:33:46] *** Quits: rgrinberg (~textual@2806:101e:7:33a5:7059:f90b:c049:c6ca) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[22:38:02] *** Joins: rgrinberg (~textual@187.223.75.25)
