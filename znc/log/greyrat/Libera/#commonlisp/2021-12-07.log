[00:04:03] <resttime> Suppose we have generic functions on defstruct, is there any chance reimplementing either/both with closures would get higher performance?
[00:08:56] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[00:09:53] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[00:10:12] <pjb> resttime: implementation dependent. Probably not.
[00:10:19] <White_Flame> there's a lot of research into GF dispatch performance, and things like branching being faster than indirection in some cases
[00:10:28] <White_Flame> on modern hardware
[00:11:01] <White_Flame> unless you're in a really tight loop, and you're optimizing for your fixed environment, might not be worth it
[00:11:16] <pjb> resttime: the way structures are specified, gives the implementation opportunity to make it faster than the general CLOS standard-objects. But only the access to the structure slot. It's independent from the CLOS generic function method dispatching.
[00:11:59] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[00:12:05] <White_Flame> I presume the question was GFs with struct objects as parameters?
[00:12:13] <pjb> It seems, yes.
[00:13:52] <resttime> White_Flame: Yeah, context is that I'm writing a raytracer and  am trying to squeeze out as much performance as possible. Different structs would have different properties so currently that's handled with generic functions
[00:15:43] <White_Flame> semantically, that's reasonable for GFs
[00:17:41] <Shinmera> Guest74: the second selector will only select "tr" elements within the "th" elements. Why is that selector there?
[00:18:29] <Guest74> I only want tr elements from the th element that (contains "paramaters) but it doesn't work.
[00:18:54] <Shinmera> ? th elements are within tr elements, not the other way around
[00:19:12] *** Joins: poselyqualityles (poselyqual@user/poselyqualityles)
[00:19:26] *** Joins: tyson2 (~user@bras-base-toroon0240w-grc-51-65-92-155-88.dsl.bell.ca)
[00:19:30] <Shinmera> if you want the parent, use the PARENT function.
[00:19:32] <Guest74> huh, I must have been reading the source wrong.
[00:19:49] <Shinmera> Anyway, in other Lisp webdev news, Courier grew another feature tonight. https://twitter.com/Shinmera/status/1467957093961449480
[00:24:19] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Quit: ERC (IRC client for Emacs 27.1))
[00:25:54] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[00:27:19] *** Joins: cjb (~cjb@user/cjb)
[00:27:54] *** Joins: Lycurgus (~juan@98.4.112.204)
[00:28:47] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[00:30:34] *** Quits: cage (~cage@dynamic-adsl-94-34-12-161.clienti.tiscali.it) (Quit: rcirc on GNU Emacs 27.1)
[00:36:12] <Guest74> Thanks Shinmera: for pointing out it was just my stupidity for why it wasn't working.  I've got it working, now just wondering if there is a simpler way to write it.
[00:36:21] <Guest74> I've got (lquery:$ *doc* "section" (filter #'(lambda (e) (string= "params" (lquery-funcs:attr e :id)))) "table" "tr" (attr :id) (filter #'(lambda (s) (not (null s)))))
[00:38:49] <Shinmera> (lquery:$ (initialize "<section id=\"params\"><table><tr id>") "section#params table tr[id]")
[00:39:54] *** Joins: lisp123 (~lisp123@5.30.23.247)
[00:40:30] <Shinmera> Might be time to learn about CSS selectors.
[00:40:40] <Guest74> might be
[00:41:10] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[00:41:50] <Shinmera> dunno what document you have, but id attributes are supposed to be globally unique, so you might also be able to drop the section part.
[00:42:03] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[00:43:21] <Guest74> It's one of the api pages for youtube. just #params seems to work.
[00:44:09] *** Quits: Lycurgus (~juan@98.4.112.204) (Quit: Exeunt)
[00:44:30] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[00:45:16] <Guest74> Shinmera: thanks again. One step closer to auto generating the api.  I should probably read about css selectors first.
[00:45:24] <Shinmera> No problem
[00:47:00] *** Joins: Lycurgus (~juan@98.4.112.204)
[00:47:49] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 240 seconds)
[00:48:05] *** Quits: Lycurgus (~juan@98.4.112.204) (Client Quit)
[00:49:23] <theothornhill> What is the best way to handle nil vs null/false in common lisp?  I want to distinguish between boolean types, with true/false, null as a value and nil.
[00:50:03] *** Joins: aeth (~aeth@user/aeth)
[00:50:23] <Catie> My (very limited) understanding is that for the most part we just treat them as interchangeable
[00:50:30] <theothornhill> I could coerce values to :true/:false, and :null, then deal with it separately like that, but not sure how nice that is
[00:51:52] *** Quits: cranium (~cranium@user/cranium) (Quit: Leaving)
[00:52:13] <theothornhill> Catie: Yeah, but I don't see a very nice way to treat them as interchangeable here.  The domain I'm working on is to make values that can be valid json in the end
[00:53:32] <theothornhill> most importantly I need to distinguish between :null and :false, I think...
[00:56:53] <pjb> theothornhill: (values (eq 'nil 'null) (eq 'nil 'false) (eq 'null 'false)) #| --> nil ; nil ; nil |#  they already are distinct! What more do you want?
[00:57:48] <theothornhill> yeah, so just using the symbols is ok?
[00:57:57] <pjb> theothornhill: now, CL:BOOLEAN = (member CL:NIL CL:T)  so you don't mean CL:BOOLEAN.
[00:58:23] <theothornhill> yeah, now I made (deftype bool () '(or true false))
[00:58:38] <pjb> theothornhill: but: (defpackage "THEOTHORNHILL" (:use") (:export "BOOLEAN" "TRUE" "FALSE"))   (deftype THEOTHORNHILL:BOOLEAN () '(member THEOTHORNHILL:TRUE THEOTHORNHILL:FALSE))
[00:58:46] <pjb> Yes, or bool.
[00:59:30] <pjb> So you need functions to convert between CL:BOOLEAN and BOOL.
[00:59:57] <theothornhill> pjb: thanks! Is 'or' or 'member' the correct type specifier here?
[01:00:07] <pjb> (defun from-bool (bool) (ecase bool ((true) t) ((false) nil)))   (defun to-bool (generalized-boolean) (if generalized-boolean 'true 'false))
[01:00:32] <pjb> MEMBER is the correct one.  OR would take types.
[01:00:40] <theothornhill> ah
[01:01:17] <pjb> (deftype bool () '(or (eql true) (eql false))) (typep 'true 'bool) #| --> t |#  (typep 'nil 'bool)  #| --> nil |#
[01:02:26] * rotateq thought NULL is a built-in-class or function and not a value like NIL
[01:02:51] *** Quits: aartaka (aartaka@gateway/vpn/protonvpn/aartaka) (Ping timeout: 252 seconds)
[01:02:56] <pjb> rotateq: NULL is a symbol like any other symbol!  (type-of 'null) #| --> symbol |#
[01:03:22] <rotateq> a symbol, yes of course
[01:03:35] <pjb> rotateq: but it is used to designate a type, and to name a class, and a function: (subtypep 'null 't) #| --> t ; t |#   (find-class 'null) #| --> #<built-in-class null> |#  (fdefinition 'null) #| --> #<Compiled-function null #x3000000E39BF> |#
[01:03:38] <rotateq> but without a quote it is not bound by default like NIL
[01:03:44] <theothornhill> So I don't need to reexport null, right?  Just document how it is used in this condext?
[01:03:47] <pjb> It can be used to name other things too…
[01:04:03] <pjb> such as a block: (block null (return-from null nil))
[01:04:07] <rotateq> pjb: didn't doubt that
[01:04:20] <pjb> or a variable: (let ((null 0)) (+ null 1))
[01:04:53] <pjb> rotateq: indeed, NULL is not bound as a variable by CL. Which is why you are allowed to use it as a local lexical variable.
[01:05:04] <rotateq> i know
[01:05:16] <theothornhill> Thanks, pjb. I think I can roll with this
[01:06:55] <rotateq> ah interesting to see again its class precedence list: NULL, SYMBOL, LIST, SEQUENCE, T
[01:10:43] *** Joins: x88x88x- (~cheeg@156.146.57.109)
[01:12:31] *** Quits: x88x88x- (~cheeg@156.146.57.109) (Remote host closed the connection)
[01:13:10] *** Joins: x88x88x- (~cheeg@156.146.57.109)
[01:13:28] *** Quits: x88x88x- (~cheeg@156.146.57.109) (Remote host closed the connection)
[01:14:17] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[01:14:37] *** Quits: dre (~dre@60.229.45.121) (Ping timeout: 240 seconds)
[01:15:13] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[01:16:00] *** Quits: Algernon69 (~Algernon6@2a01:e0a:511:6ce0:5bc:bec3:27a0:99fc) (Remote host closed the connection)
[01:16:17] *** Joins: Algernon69 (~Algernon6@2a01:e0a:511:6ce0:5bc:bec3:27a0:99fc)
[01:17:10] *** Joins: x88x88x- (~cheeg@gateway/vpn/pia/x88x88x)
[01:17:23] *** Quits: x88x88x- (~cheeg@gateway/vpn/pia/x88x88x) (Remote host closed the connection)
[01:17:26] *** Quits: tyson2 (~user@bras-base-toroon0240w-grc-51-65-92-155-88.dsl.bell.ca) (Remote host closed the connection)
[01:19:59] <phoe> well, NIL is the only value of type NULL
[01:20:13] <phoe> and NIL is both a SYMBOL and a LIST, and a LIST is naturally a SEQUENCE
[01:20:16] <phoe> and then everything is a T
[01:20:45] *** Quits: nature (~nature@45.32.235.173) (Ping timeout: 265 seconds)
[01:21:43] <theothornhill> phoe: even nil?
[01:22:45] <theothornhill> (typep nil t) ;; T.  Huh
[01:28:37] <jackdaniel> mind that there is a type NULL that has a single element
[01:28:42] <jackdaniel> and there is a type NIL that has no elements
[01:28:48] *** Joins: Algernon91 (~Algernon6@2a04:cec0:11cc:d11e:4896:f185:52e9:c42b)
[01:31:59] *** Joins: pillton (~user@118-211-29-59.tpgi.com.au)
[01:32:21] *** Quits: Algernon69 (~Algernon6@2a01:e0a:511:6ce0:5bc:bec3:27a0:99fc) (Ping timeout: 265 seconds)
[01:35:51] *** Quits: theothornhill (~user@217.84-49-191.nextgentel.com) (Ping timeout: 252 seconds)
[01:36:42] *** Quits: shka (~herr@83.175.151.96.piasta.pl) (Ping timeout: 265 seconds)
[01:46:55] *** Joins: theothornhill (~user@217.84-49-191.nextgentel.com)
[01:47:28] <rotateq> jackdaniel: or "void" :P
[01:49:56] *** Quits: pl (sid98063@helmsley.irccloud.com) (Ping timeout: 245 seconds)
[01:49:56] *** Quits: gendl (sid100083@hampstead.irccloud.com) (Ping timeout: 245 seconds)
[01:50:11] *** Joins: pl (sid98063@id-98063.helmsley.irccloud.com)
[01:50:11] *** ChanServ sets mode: +o pl
[01:51:12] *** Joins: gendl (sid100083@id-100083.hampstead.irccloud.com)
[01:52:30] *** Joins: azimut_ (~azimut@gateway/tor-sasl/azimut)
[01:52:54] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Ping timeout: 276 seconds)
[01:53:19] *** Joins: _73` (~user@pool-96-233-64-53.bstnma.fios.verizon.net)
[01:54:55] *** Joins: dre (~dre@2001:8004:44e0:e2f7:4cb5:615f:6ecc:f9d3)
[01:55:03] *** Quits: _73 (~user@pool-96-233-64-53.bstnma.fios.verizon.net) (Ping timeout: 256 seconds)
[01:55:06] *** Quits: Catie (~user@user/catie) (Quit: Going home)
[02:00:13] *** Quits: varjag (~user@ti0040a400-5479.bb.online.no) (Ping timeout: 240 seconds)
[02:00:52] *** Quits: taiju (~taiju@240b:253:ec40:2400:651e:f83b:5890:99a6) (Ping timeout: 265 seconds)
[02:01:20] *** Joins: taiju (~taiju@240b:253:ec40:2400:651e:f83b:5890:99a6)
[02:10:37] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[02:10:52] *** Joins: aartaka (aartaka@gateway/vpn/protonvpn/aartaka)
[02:14:46] <dre> https://dpaste.org/ziDK#L35
[02:14:51] <dre> I know the dolist is naughty of me
[02:15:14] <dre> but how do I return the "winning row" out of it?
[02:15:26] <dre> do I have to wrap the inner dolist in a return statement?
[02:15:40] <dre> is there a better form I could use here?
[02:16:37] <mfiano> keep an accumulator and use the optional argument to dolist
[02:16:53] <Guest74> (dolist (item list thing-to-return
[02:18:16] <Guest74> ) do stuff)
[02:18:28] <Guest74> oops, oven timer went off
[02:19:05] <Guest74> ah, that doesn't apply to your question.
[02:19:49] *** Quits: aartaka (aartaka@gateway/vpn/protonvpn/aartaka) (Ping timeout: 240 seconds)
[02:20:10] <dre> thing-to-return?
[02:20:53] <dre> I think the (dolist () (return (dolist () return ....))) would work but it's yuck
[02:23:46] <Guest74> Was just mentioning that dolist takes and optional result-form but doesn't really apply to how you have it.
[02:24:23] <Guest74> unless you pushed the win somewhere outside the dolist's and then had the outer dolist return the place you pushed to.
[02:24:48] <Guest74> but the easiest thing, would be to use RETURN-FROM
[02:31:41] <rotateq> dre: in lines 39 and 40 maybe you better want to use a LET form for your inner function variables
[02:33:55] *** Quits: theothornhill (~user@217.84-49-191.nextgentel.com) (Remote host closed the connection)
[02:36:10] <dre> hmm, give me a sec I'm driving atm
[02:36:49] <dre> rotateq, yes you're right I'm just hacking things together I'm sorry
[02:37:26] <dre> Guest74, return-from sounds like something i might want, let me figure it out
[02:37:53] <Guest74> clhs return-from
[02:37:53] <specbot> http://www.lispworks.com/reference/HyperSpec/Body/s_ret_fr.htm
[02:37:59] <rotateq> ah don't be sorry, be proud of your progress :) it was just a silly tip of mine
[02:38:39] <rotateq> can always be called from inside a block
[02:41:18] *** Joins: lisp123 (~lisp123@5.30.23.247)
[02:41:25] *** Quits: gaqwas (~john@dynamic-077-002-117-079.77.2.pool.telefonica.de) (Ping timeout: 240 seconds)
[02:41:49] *** Quits: dre (~dre@2001:8004:44e0:e2f7:4cb5:615f:6ecc:f9d3) (Ping timeout: 240 seconds)
[02:42:02] *** Joins: VincentVega (~user@212.241.25.167)
[02:42:57] *** Quits: MichaelRaskin (~MichaelRa@ipb21a9944.dynamic.kabel-deutschland.de) (Ping timeout: 252 seconds)
[02:44:35] *** Joins: abrantesasf (~abrantesa@187.36.170.211)
[02:45:49] *** Quits: Algernon91 (~Algernon6@2a04:cec0:11cc:d11e:4896:f185:52e9:c42b) (Ping timeout: 265 seconds)
[02:45:53] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[02:46:57] *** Quits: azimut_ (~azimut@gateway/tor-sasl/azimut) (Remote host closed the connection)
[02:55:17] *** Joins: asdasdqweqweqweq (~MichaelRa@ipb21a9944.dynamic.kabel-deutschland.de)
[02:57:01] *** Quits: yewscion (~yewscion@72-21-196-64.amazon.com) (Ping timeout: 240 seconds)
[02:57:06] *** Quits: asdasdqweqweqweq (~MichaelRa@ipb21a9944.dynamic.kabel-deutschland.de) (Remote host closed the connection)
[02:58:28] *** Joins: MichaelRaskin (~MichaelRa@ipb21a9944.dynamic.kabel-deutschland.de)
[02:58:28] *** ChanServ sets mode: +o MichaelRaskin
[02:59:57] *** Quits: makomo (~makomo@user/makomo) (Ping timeout: 268 seconds)
[03:04:00] *** Quits: Alfr (~Alfr@user/alfr) (Killed (zinc.libera.chat (Nickname regained by services)))
[03:04:05] *** Joins: Alfr (~Alfr@user/alfr)
[03:04:29] <Xach> i like that dolist has an implicit tagbody
[03:10:28] *** Joins: dra (~dra@2a04:4540:6400:e300:a031:7dec:ad3:e1ac)
[03:11:07] *** Joins: Oladon (~olad@98.43.81.226)
[03:14:08] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[03:14:37] *** Quits: peterhil_ (~peterhil@dsl-hkibng32-54fb56-2.dhcp.inet.fi) (Ping timeout: 240 seconds)
[03:20:17] *** Joins: dre (~dre@2001:8003:c932:c301:97c2:3a80:30a5:4f30)
[03:23:38] *** Quits: pve (~pve@37-136-9-121.rev.dnainternet.fi) (Quit: leaving)
[03:24:01] *** Quits: attila_lendvai (~alendvai@2a02:ab88:3700:b180:6072:12a9:8472:9a8f) (Ping timeout: 252 seconds)
[03:25:48] <Guest74> i haven't figured that one out.
[03:26:57] *** Joins: s-liao (~s-liao@101.86.99.70)
[03:28:48] <dre> God dammit it really helps to read the problem definition before you try and write it
[03:33:38] *** Quits: VincentVega (~user@212.241.25.167) (Remote host closed the connection)
[03:34:50] <rotateq> dre: haha yes ^^
[03:36:57] *** Quits: dre (~dre@2001:8003:c932:c301:97c2:3a80:30a5:4f30) (Ping timeout: 268 seconds)
[03:53:00] *** Quits: random-nick (~random-ni@87.116.181.93) (Ping timeout: 265 seconds)
[03:55:06] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[03:55:24] *** Joins: dre (~dre@60.229.45.121)
[03:56:26] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[04:00:29] *** Quits: Guest74 (~Guest74@modemcable110.164-177-173.mc.videotron.ca) (Quit: Connection closed)
[04:01:38] *** Joins: dra_ (~dra@2a04:4540:640e:a200:a031:7dec:ad3:e1ac)
[04:03:06] *** Quits: dra_ (~dra@2a04:4540:640e:a200:a031:7dec:ad3:e1ac) (Client Quit)
[04:04:36] *** Quits: dra (~dra@2a04:4540:6400:e300:a031:7dec:ad3:e1ac) (Ping timeout: 265 seconds)
[04:12:23] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[04:12:25] *** Joins: karlosz (~karlosz@47.151.136.69)
[04:12:42] *** Joins: tfeb (~tfb@88.98.95.237)
[04:15:28] *** Quits: tfeb (~tfb@88.98.95.237) (Client Quit)
[04:17:25] *** Quits: karlosz (~karlosz@47.151.136.69) (Ping timeout: 240 seconds)
[04:26:13] *** Quits: GreaseMonkey (greaser@user/greasemonkey) (Remote host closed the connection)
[04:26:33] *** Joins: karlosz (~karlosz@47.151.136.69)
[04:30:40] *** Joins: karlosz_ (~karlosz@47.151.136.69)
[04:34:17] *** Quits: karlosz (~karlosz@47.151.136.69) (Ping timeout: 256 seconds)
[04:34:17] *** karlosz_ is now known as karlosz
[04:39:49] *** Joins: karlosz_ (~karlosz@47.151.136.69)
[04:43:03] *** Joins: lisp123 (~lisp123@5.30.23.247)
[04:43:21] *** Quits: karlosz (~karlosz@47.151.136.69) (Ping timeout: 256 seconds)
[04:46:53] *** Quits: karlosz_ (~karlosz@47.151.136.69) (Ping timeout: 252 seconds)
[04:47:25] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 240 seconds)
[04:52:52] *** Joins: karlosz (~karlosz@47.151.136.69)
[04:53:22] *** Quits: karlosz (~karlosz@47.151.136.69) (Client Quit)
[05:07:47] *** Quits: jeosol (~jeosol@76-238-186-228.lightspeed.hstntx.sbcglobal.net) (Ping timeout: 252 seconds)
[05:17:39] *** Joins: karlosz (~karlosz@47.151.136.69)
[05:19:07] *** Quits: karlosz (~karlosz@47.151.136.69) (Client Quit)
[05:28:52] *** Joins: Lycurgus (~juan@98.4.112.204)
[05:29:34] *** Joins: raeda_ (~raeda@72.49.249.241)
[05:29:58] *** Quits: raeda__ (~raeda@72.49.249.241) (Remote host closed the connection)
[05:31:30] *** Joins: karlosz (~karlosz@47.151.136.69)
[05:33:49] *** Quits: taiju (~taiju@240b:253:ec40:2400:651e:f83b:5890:99a6) (Ping timeout: 252 seconds)
[05:38:10] *** Quits: Lycurgus (~juan@98.4.112.204) (Quit: Exeunt)
[05:38:13] *** Quits: poselyqualityles (poselyqual@user/poselyqualityles) (Ping timeout: 252 seconds)
[05:38:20] *** Quits: karlosz (~karlosz@47.151.136.69) (Quit: karlosz)
[05:45:16] *** Joins: kennyd (~bc8165b6@cerf.good1.com)
[05:54:10] *** Joins: karlosz (~karlosz@47.151.136.69)
[06:00:20] *** Joins: peterhil (~peterhil@dsl-hkibng32-54fb56-2.dhcp.inet.fi)
[06:02:00] *** Joins: Guest74 (~Guest74@modemcable110.164-177-173.mc.videotron.ca)
[06:03:22] *** Parts: rotateq (~user@p200300e787097300818cd04b4ea1a4f3.dip0.t-ipconnect.de) (ERC (IRC client for Emacs 27.2))
[06:12:37] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 240 seconds)
[06:13:20] *** Joins: aeth (~aeth@user/aeth)
[06:32:54] *** Joins: pdietz (~pdietz@cpe-74-69-163-146.stny.res.rr.com)
[06:34:43] *** Quits: abrantesasf (~abrantesa@187.36.170.211) (Remote host closed the connection)
[06:37:46] *** Quits: pdietz (~pdietz@cpe-74-69-163-146.stny.res.rr.com) (Ping timeout: 256 seconds)
[06:38:15] *** Quits: karlosz (~karlosz@47.151.136.69) (Quit: karlosz)
[06:41:30] *** Joins: taiju (~taiju@240b:253:ec40:2400:651e:f83b:5890:99a6)
[06:42:01] *** Joins: dickba___ (~dickbaren@86-90-132-28.fixed.kpn.net)
[06:43:25] *** Quits: dickbar__ (~dickbaren@86-90-132-28.fixed.kpn.net) (Ping timeout: 240 seconds)
[06:44:29] *** Joins: lisp123 (~lisp123@5.30.23.247)
[06:48:59] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[06:54:26] *** Quits: ebrasca (~user@librepanther.com) (Remote host closed the connection)
[07:00:38] *** Quits: Bike (~Glossina@71.69.170.70) (Quit: Lost terminal)
[07:01:02] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Remote host closed the connection)
[07:01:24] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[07:06:57] *** Joins: lisp123 (~lisp123@5.30.23.247)
[07:24:18] *** Joins: blihp (~phil@c-68-43-233-92.hsd1.mi.comcast.net)
[07:30:14] <beach> Good morning everyone!
[07:32:31] *** Joins: akoana (~ah@user/akoana)
[07:35:48] *** Quits: z3t0 (~z3t0@146.71.14.98) (Read error: Connection reset by peer)
[07:37:07] *** Joins: z3t0 (~z3t0@146.71.14.98)
[07:45:27] *** Joins: jeosol (~jeosol@76-238-186-228.lightspeed.hstntx.sbcglobal.net)
[07:51:44] *** Quits: akoana (~ah@user/akoana) (Quit: leaving)
[07:53:27] *** Quits: cjb (~cjb@user/cjb) (Quit: rcirc on GNU Emacs 29.0.50)
[08:03:26] *** Joins: lisp123_ (~lisp123@5.30.23.247)
[08:05:05] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[08:08:24] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Quit: WeeChat 3.3)
[08:11:22] *** Quits: semz (~none@user/semz) (Ping timeout: 268 seconds)
[08:20:19] *** Quits: lisp123_ (~lisp123@5.30.23.247) (Remote host closed the connection)
[08:21:09] *** Joins: lisp123 (~lisp123@5.30.23.247)
[08:21:10] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[08:21:22] *** Joins: lisp123 (~lisp123@5.30.23.247)
[08:24:00] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[08:24:16] *** Joins: semz (~none@user/semz)
[08:26:14] <dre> it's 4pm and i must lisp
[08:26:17] <dre> good morning beach
[08:27:36] <pillton> I think the CLHS entry for REDUCE could be a bit clearer. I don't think I could implement it using the description alone.
[08:27:58] <Guest74> dre: what a wonderful timezone you're in.
[08:28:16] <hayley> Guest74: I agree.
[08:29:54] <dre> here here
[08:30:04] <dre> Guest74, you need a more friendly nick
[08:30:33] <dre> might I suggest GuestSeventyFour ?
[08:36:47] *** Joins: igemnace (~ian@user/igemnace)
[08:36:49] <beach> pillton: If you have time, you could create a WSCL "issue" for it.
[08:37:16] <pillton> beach: That is a good idea.
[08:37:17] <beach> That's precisely what WSCL is meant for.
[08:38:02] *** Quits: Lord_Nightmare (Lord_Night@user/lord-nightmare/x-3657113) (Read error: Connection reset by peer)
[08:39:58] *** Joins: Lord_Nightmare (Lord_Night@user/lord-nightmare/x-3657113)
[08:50:55] <Guest74> dre: it's past midnight here and my thinking is shot.  I kept trying to submit the wrong part of my correct answer.
[08:55:35] *** Quits: peterhil (~peterhil@dsl-hkibng32-54fb56-2.dhcp.inet.fi) (Remote host closed the connection)
[09:02:49] *** Quits: _73` (~user@pool-96-233-64-53.bstnma.fios.verizon.net) (Ping timeout: 265 seconds)
[09:05:19] *** Joins: karlosz (~karlosz@47.151.136.69)
[09:07:17] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[09:10:05] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[09:10:26] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[09:15:28] *** Joins: paul0 (~paul0@user/paul0)
[09:20:44] *** Joins: greaser|q (greaser@antihype.space)
[09:21:47] *** Quits: greaser|q (greaser@antihype.space) (Changing host)
[09:21:47] *** Joins: greaser|q (greaser@user/greasemonkey)
[09:21:51] *** greaser|q is now known as GreaseMonkey
[09:22:22] *** Joins: karlosz_ (~karlosz@47.151.136.69)
[09:24:28] *** Joins: lisp123 (~lisp123@5.30.23.247)
[09:25:49] *** Quits: karlosz (~karlosz@47.151.136.69) (Ping timeout: 240 seconds)
[09:29:01] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 240 seconds)
[09:29:35] *** Quits: karlosz_ (~karlosz@47.151.136.69) (Ping timeout: 252 seconds)
[09:31:09] *** Joins: treflip (~user@95.79.32.99)
[09:45:25] *** Quits: Guest74 (~Guest74@modemcable110.164-177-173.mc.videotron.ca) (Ping timeout: 240 seconds)
[10:00:14] *** Joins: karlosz (~karlosz@47.151.136.69)
[10:00:49] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 265 seconds)
[10:18:51] *** Quits: blihp (~phil@c-68-43-233-92.hsd1.mi.comcast.net) (Quit: Leaving)
[10:26:08] *** Joins: Nilby (Nilby@2600:3c01::f03c:92ff:feeb:88ff)
[10:27:19] *** Joins: gaqwas (~john@dynamic-095-114-098-056.95.114.pool.telefonica.de)
[10:28:31] *** Joins: lisp123w (~user@80.227.170.170)
[10:28:50] <lisp123w> What's the best way to implement large (i.e. lots of elements) sets (collections of distinct values)?
[10:29:51] <lisp123w> Hash tables?
[10:29:57] <hayley> I usually use a hash table, yes.
[10:30:05] *** Joins: Cymew (~ante@c-e989225c.023-1144-7570702.bbcust.telenor.se)
[10:30:18] <hayley> Adding an element can just be (setf (gethash table element) t), and then (gethash table element) gives you T or NIL.
[10:30:56] <lisp123w> hayley: Thanks. Do you do anything nifty for set operations like union / intersection etc.?
[10:32:28] <hayley> I'm not sure if there's a good way to handle all the set operations with one data structure efficiently.
[10:34:10] <lisp123w> Yeah, that's what I was feeling too
[10:36:01] <lisp123w> A related question, would there be a considerable performance benefit for using a hash table with EQ vs. EQL vs. EQUAL? (Equal I guess would be considerably slower, but wondering whether to use symbols as keys vs. numbers would help materially)
[10:37:59] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[10:39:31] *** Joins: shka (~herr@83.175.151.96.piasta.pl)
[10:40:40] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[10:42:10] <hayley> I would still pick the most specific test.
[10:42:42] *** Joins: Algernon69 (~Algernon6@2a04:cec0:11cc:d11e:294b:a29d:8c1f:dfa4)
[10:43:16] <hayley> Most hash tables are designed so that it is not so common that you have to call the test function on different keys. And EQL should be about as fast for numbers and symbols, so pick the representation you find nicest.
[10:46:04] <lisp123w> hayley: Great, thanks for the info
[10:54:51] *** Quits: kennyd (~bc8165b6@cerf.good1.com) (Quit: CGI:IRC (Session timeout))
[11:04:11] *** Quits: frgo (~frgo@p548a30d7.dip0.t-ipconnect.de) (Ping timeout: 252 seconds)
[11:10:47] *** Quits: jurov (~jurov@rev-81-92-255-36.radiolan.sk) (Ping timeout: 265 seconds)
[11:17:03] *** Joins: aartaka (aartaka@gateway/vpn/protonvpn/aartaka)
[11:17:23] *** Joins: attila_lendvai (~alendvai@catv-80-99-179-152.catv.broadband.hu)
[11:19:24] *** Joins: pillton` (~user@220.240.250.204)
[11:21:42] *** Quits: pillton (~user@118-211-29-59.tpgi.com.au) (Ping timeout: 260 seconds)
[11:22:51] *** Quits: amb007 (~a_bakic@102.215.76.86.rev.sfr.net) (Ping timeout: 256 seconds)
[11:23:13] *** Joins: amb007 (~a_bakic@4.39.22.93.rev.sfr.net)
[11:26:03] *** Quits: xantoz (~tewi_inab@c-c0bae255.013-124-73746f25.bbcust.telenor.se) (Read error: Connection reset by peer)
[11:26:33] *** Joins: lisp123 (~lisp123@5.30.23.247)
[11:27:25] *** Quits: karlosz (~karlosz@47.151.136.69) (Ping timeout: 240 seconds)
[11:28:15] *** Joins: xantoz (~tewi_inab@c-c0bae255.013-124-73746f25.bbcust.telenor.se)
[11:31:12] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[11:32:03] *** Quits: dickba___ (~dickbaren@86-90-132-28.fixed.kpn.net) ()
[11:32:39] *** Quits: gaqwas (~john@dynamic-095-114-098-056.95.114.pool.telefonica.de) (Ping timeout: 265 seconds)
[11:44:22] *** Joins: cranium (~cranium@user/cranium)
[11:55:26] *** Joins: cage (~cage@dynamic-adsl-84-220-241-149.clienti.tiscali.it)
[12:02:52] <pjb> lisp123w: define "best"
[12:03:28] <pjb> lisp123w: depends also on the kind of element, whether your sets are dense or not.
[12:04:10] <pjb> lisp123w: if you can map your elements to a range of integers, then using bit-vectors to represent those sets is a nice way.Short on memory, efficient (we have bit-operations).
[12:04:49] <pjb> lisp123w: but if your sets are sparse, it may become costly.  A more sophisticated representation may be in order.
[12:09:56] *** Joins: notzmv (~zmv@user/notzmv)
[12:13:21] *** Joins: pve (~pve@87-93-4-46.bb.dnainternet.fi)
[12:14:08] <beach> lisp123w: There is no such thing as a "set" in computer science.  You need to specify the operations on the collection for it to be possible to determine the best representation.  For example, if all you need is to add objects and then remove an arbitrary object, then a stack is fine.
[12:14:52] <beach> lisp123w: If your domain admits a total ordering, the best solution might be different than if it does not.
[12:15:27] <beach> lisp123w: If you need to find the "smallest" element, again the representation will be different.
[12:15:57] <beach> lisp123w: If all you need is "union" and "find the set of an element", then again, the solution is different.
[12:15:57] *** Quits: amb007 (~a_bakic@4.39.22.93.rev.sfr.net) (Read error: Connection reset by peer)
[12:16:07] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[12:18:05] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[12:18:28] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[12:19:15] <beach> lisp123w: And, as hayley pointed out, if you want all usual set operations, you are basically out of luck.  No efficient solution exists.
[12:22:47] <beach> lisp123w: And when you specify the operations that you need, you have a "protocol" for an "abstract data type", which is usually the best way to start.
[12:30:47] *** Quits: s-liao (~s-liao@101.86.99.70) (Ping timeout: 256 seconds)
[12:33:50] *** Quits: euandreh (~euandreh@2804:14c:33:9fe5:b36c:1fc0:956d:d06c) (Ping timeout: 252 seconds)
[12:33:54] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.3)
[12:35:05] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[12:35:35] *** Joins: euandreh (~euandreh@2804:14c:33:9fe5:da4:9ec6:5ef5:74d6)
[12:36:39] *** Joins: jpl01 (~user@2001:16b8:4931:c600:c1ba:14a6:b08d:c22)
[12:44:24] *** Joins: lisp123 (~lisp123@5.30.23.247)
[12:49:03] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[12:55:04] <Nilby> I'd like number sets that can do (union* #'evenp #'oddp) => #'identity or even (set-difference* #'identity (λ (< _ 5000))) => ( (>= _ 5000)                  (>= _ 5000)
[12:58:09] <Nilby> or rather (set-difference* #'identity (λ (x) (< x 5000))) => (λ (>= _ 5000))
[13:13:06] <semz> Nilby: Wouldn't that just be (defun union* (f g) (lambda (x) (or (funcall f x) (funcall g x)))), etc? Well, it would result in (constantly t) instead of #'identity, but otherwise I'm not sure what you're looking for.
[13:13:40] <semz> Set operations correspond to logical operations after all.
[13:16:26] <beach> semz: That trick works only if you don't need another operation such as |S|, i.e. the size of the set.  And that's just one example.
[13:17:33] <beach> It's a great trick when it works though, and it is at the center of the Haskell solution to the GeoServer problem in the paper by Hudak and Jones.
[13:18:13] <Nilby> I want a union for numbers to be little smarter than just ‘or’. It could of course falll back on that.
[13:18:58] <Nilby> Sort of like what an SQL query optimizer can do.
[13:19:12] <beach> Nilby: OR is very smart.  If you don't think so, you need to specify what it is you require as smarter.
[13:19:58] <beach> Let me say this again.  It is impossible to determine a good solution to set representations unless all the desired operations are specified.
[13:21:15] <beach> Nilby: In your case, if all you have are the functions, then you are probably out of luck, because you rapidly get into undecidable territory.
[13:21:21] <semz> I suspect it already becomes impossible when one adds set size, but I'd have to check.
[13:21:50] <beach> semz: Using the characteristic functions only, yes.
[13:24:39] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.3)
[13:25:32] <Nilby> theoretically uncomputable in the general case and impossible are different things
[13:29:39] <beach> Good luck.
[13:39:01] <hayley> One idea which gets bounced around #lispcafe every so often is to have a "profiling" set which changes representation based on what operations are more frequent.
[13:39:31] *** Quits: hobo (~hobo@2600:1700:8972:63f:3313:2d33:be9f:8246) (Quit: ZNC 1.8.2 - https://znc.in)
[13:39:46] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 265 seconds)
[13:39:46] *** Joins: hobo (~hobo@2600:1700:8972:63f:3313:2d33:be9f:8246)
[13:41:38] <Nilby> hayley: That's the kind of thing I'm thinking of. If your set is (zerop (mod (random _) 23))) you might have to use a bitmap, but you could say guess that the count is < 500 for a set of 10k.
[13:42:31] *** Joins: Lord_of_Life (~Lord@user/lord-of-life/x-2819915)
[13:44:30] <beach> Nilby: But you didn't say that you have a bitmap.  All you showed was the characteristic functions.  So your specification is changing, which is what makes all similar discussions frustrating and ultimately futile.
[13:44:54] <hayley> I have a sort of similar issue with character sets in my regular expression engine. I'd like the fastest procedure to test if a character is a member of some set. A set with one element E could be compiled down to (char= character E). A range of characters [A, B] could be (char<= A character B). The union of some ranges is also not too hard. But, if we have too many of those ranges, compiling such a test would result in code bloat, and we had
[13:44:54] <hayley> better use a bitmap.
[13:45:31] *** Joins: VincentVega (~user@212.241.25.167)
[13:45:42] <hayley> Oh, and then we want a relatively compact "bitmap", so that it will fit in cache, and so that we don't use too much memory to represent a compiled regular expression. Nitpicking all the way down!
[13:47:18] <Nilby> From my investigations most unicode set things use a combo of hardcoded ranges and hierarchical ranges / trees.
[13:47:58] <Nilby> But I guess a caller supplied set is harder.
[13:48:03] <hayley> And recall that the only operations I care about the performance of (at runtime) is set membership. I mean, a fast compiler is always nice, but it is not necessary to split hairs there.
[13:49:09] <Nilby> hmmm, is bloom filter or something overkill?
[13:49:16] <hayley> We probably do thousands of set operations in the compiler at worst, but we do at least one set operation per character scanned at runtime.
[13:50:56] <hayley> It's not overkill if you can make a fast Bloom filter. My current idea is to use a two-level bitmap, where one vector contains references to smaller bitmaps. We can reuse smaller bitmaps, so #*0000.... and #*1111.... will only exist once in an image.
[13:50:58] <pjb> Nilby: to do something like  (union* #'evenp #'oddp) => #'identity  you need a system that knows integers. Try ACL2, a theorem/program prover.
[13:52:27] <hayley> So, as pjb mentioned, the distribution of the elements in a set can also affect which representations are appropriate.
[13:52:28] <Nilby> For lisp text stuff I feel like half the speed and space is lost by converting from utf8. I've been eyeing the way python reaches into utf8 without decoding.
[13:53:12] *** Parts: pranavats (3fba1d1b34@2a00:c70:1:178:170:40:189:1) (Error from remote client)
[13:53:50] <hayley> From my own experience, you only notice a difference with SIMD. And the difference between Lisp characters and raw bytes is closer to 3× or so.
[13:55:40] <hayley> And, in the context of regular expression matching, you might find yourself having to decode UTF-8 on the fly, either by having the DFA simulator do that for you (introducing more branches), or by encoding UTF-8 characters into the DFA (creating a larger automaton). Having your text already decoded avoids both situations.
[13:55:41] *** Joins: pranavats (3fba1d1b34@2a00:c70:1:178:170:40:189:1)
[13:56:01] <Nilby> pjb: Yes, I know what I was dreaming of goes into the prover zone,
[13:57:40] <Nilby> hayley: That's an interesting idea. Decoding in the engine might even beat other approaches.
[13:58:14] <hayley> (If you hadn't seen it from r/programming or Hacker News, <https://applied-langua.ge/posts/omrn-compiler.html> might be of interest.)
[13:59:28] <hayley> Nilby: Most "other approaches" do decode in the engine. I had a short discussion with the author of the Rust regex engine, and he said that decoding in the DFA is quite annoying, and decoding in the simulator makes matching slower.
[13:59:48] <Nilby> I've already read your code, and I think it's quite amazing. It was fun to see you and phantomics on the the front of HN on the same day.
[14:00:27] <hayley> What he didn't tell me was that the engine he wrote attempts to match literal bytes where possible, and then falls back to UTF-8 parsing if the character lengths aren't constant. Or at least that's what I got from reading the source code.
[14:02:31] <Nilby> I can stomach reading C for a little bit but rust code makes me a little queasy.
[14:03:28] <hayley> But you then need to detect when byte matching can be used or not, which introduces more complexity to the compiler. There is also the option to hope that all your input is ASCII, and have UTF-8 processing be a slow path. But that option is too Anglocentric for me, as I solely speak Greek with some of my family.
[14:04:48] <hayley> Nilby: I found it nicer to call PCRE2 and Hyperscan from Rust, admittedly. But the reason for that is due to having to manually check allocation failures and other errors, which C is abnormally terrible with. And 70kLOC of anything is unreadable to me.
[14:04:55] <phantomics> Was April on the front of HN lately?
[14:05:15] <hayley> It might have been around when pne-more-re-nightmare [sic!] was.
[14:06:41] <phantomics> I see that was 5 days ago, don't see anything April-related around that time
[14:06:43] <pjb> Nilby: you can read utf-8 files as binary octet files, since that's what they are.  Then keep processing them using octet vectors, not lisp strings!
[14:07:10] <pjb> Nilby: have a look at: com.informatimago.common-lisp.cesarum.ascii ; something similar can be done for utf-8 octet vectors.
[14:07:46] <pjb> Nilby: of course, you can also go the other way, have a look at: https://github.com/informatimago/lisp/blob/master/future/unicode.lisp
[14:08:08] <Nilby> I guess maybe the encoding pre-scan way with SIMD might be faster. greek is in the two byte zone, so no too bad. But everything is littered with 8 byte emojies now.
[14:09:19] <hayley> That said, I would like to do a more Hyperscan-esque version of the compiler, which aggressively pulls apart more string literals and easy to optimise constructs, and then schedules those parts however appropriate.
[14:09:36] *** Quits: pillton` (~user@220.240.250.204) (Remote host closed the connection)
[14:09:47] <Nilby> pjb: Yes, I've found that technique is valuable for reading big things, giant CSV files, etc.
[14:10:19] <pjb> Sometimes you can even process files without reading them, just keeping lists of file positions around!
[14:10:23] <hayley> For example, a* could be compiled into a loop which loads a SIMD vector of characters, compares to #\a, and then reports the first character that doesn't match.
[14:11:06] <Nilby> hayley: Like schedules with threads or like with instructions?
[14:11:14] <hayley> With instructions.
[14:13:15] <hayley> One regex I mentioned in the article was [0-9]+x[0-9]+. This regex does not have a string prefix, but it does have...an infix, I guess, of the trigraph [0-9]x[0-9]. In a perfect world, we would scan for that trigraph using an optimised routine, and then search for [0-9]* on either side (and in either direction) to get a full match.
[14:16:25] <Nilby> I don't know SIMD very well. Maybe you could load every digit up into a register? I guess there is a limit to what you can fit.
[14:16:34] <Nilby> like every digit pattern
[14:17:16] <hayley> No, there wouldn't be enough registers. And [0-9]+ matches between one digit and infinitely many digits, so there are definitely not enough registers.
[14:17:55] <hayley> When there is a useful prefix, e.g. when surrounding that regular expression in quotes, I generate the SIMD equivalent of (char<= #\0 char #\9)
[14:20:11] <hayley> I _think_ that is the edge I have over other engines which use SIMD; I can generate optimised code for arbitrary ranges. Whereas, say, I know Rust regex only handles a single character (which isn't a good choice), a single string ("[0-9] denotes a set of 10 strings), or uses a more complex multiple substring matching procedure.
[14:20:59] <hayley> So, I just generate code for (and (char= #\" first-character) (char<= #\0 second-character #\9)) but with SIMD.
[14:21:09] <Nilby> I think there _must_ be an advantage to having the compiler so handy
[14:22:05] <hayley> There is a definite advantage if you have to run a DFA still.
[14:22:30] <Nilby> Before loooking at hyperscan I hadn't thought that people would be doing packet inspection with regexps, but I guess it hard to hand code all that.
[14:24:09] <hayley> Yes, moreso if you have to write a complex state machine or SIMD code. one-more-re-nightmare outperforms a simple hand-written scanner with just scalar code, and blows hand-written code out of the water with SIMD.
[14:24:31] <Nilby> It's exciting that we might have such a fast thing to use soon :)
[14:26:43] <hayley> You can try it out right now, but I would characterise it as a "glass cannon" sort of library.
[14:29:42] <hayley> Some regular expressions generate very large DFAs, which will lead to terribly slow compilation times, but gilberth and I suspect they are rare in practise. We don't know that, still.
[14:30:16] *** Joins: jurov (~jurov@rev-81-92-255-39.radiolan.sk)
[14:30:57] <Nilby> most poeple don't write "a*a*a*a*a*b"
[14:31:38] <hayley> Oh, I can handle that just fine. The worst case for a DFA compiler, from memory, is something like (a|b)*a(a|b){N} for large N.
[14:33:01] <Nilby> I guess that N can be like a multiplier
[14:33:27] <hayley> I recall that the size of a DFA for that expression is O(2^N).
[14:33:57] <Nilby> You probably know, but some elisp code has some of the worst re's i've seen, if tyou need tests.
[14:34:38] <hayley> "a*a*a*a*a*b" only compiles to a DFA with one more state than "a*b". Currently I don't think I simplify a*a*, but derivatives are smarter than such "tricks" for simpler engines.
[14:34:51] <hayley> I didn't know that, I haven't written much elisp.
[14:35:20] <Nilby> since so much elisp uses re's for language parsing
[14:35:45] <hayley> Sure.
[14:36:06] *** Quits: mrcom__ (~mrcom@99-73-215-70.lightspeed.irvnca.sbcglobal.net) (Quit: Leaving)
[14:37:57] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[14:39:11] *** Joins: amb007 (~a_bakic@38.39.22.93.rev.sfr.net)
[14:46:05] *** Joins: lisp123 (~lisp123@5.30.23.247)
[14:50:49] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[14:53:13] <Nilby> the use of trivia makes the code look very natural
[14:53:14] *** Quits: amb007 (~a_bakic@38.39.22.93.rev.sfr.net) (Read error: Connection reset by peer)
[14:53:24] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[14:54:29] <hayley> Yes, I wanted to copy the definitions from the papers as closely as possible, to minimize the risk of subtle transcription errors.
[14:54:29] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[14:55:11] *** Joins: random-nick (~random-ni@87.116.165.83)
[14:55:23] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[14:56:09] <Nilby> I think even more understandable to me in lisp notation
[14:57:47] <hayley> Quite likely. gilberth wrote some of his notes in postfix. "What's rφ going to do? Oh, right. That's a substitution."
[14:58:03] <Nilby> but see a few symbols in there, using ¬ was very popular in lisp machine days
[15:01:33] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[15:02:01] <hayley> Yes, I quite like my compose key. The surface notation for regular expressions was also a compromise betwen how Owens et al presented regexes in their paper, and the usual POSIX syntax.
[15:03:36] <hayley> (For what it's worth, I now know that punning off the name of a song from a relatively popular band does not make you immune to appearing in search results.)
[15:06:09] <hayley> Probably should use a POSIX parser, but I really like having angle brackets for submatches, so that we keep () for changing precedence, rather than using () for submatches and (?:) for just precedence.
[15:06:31] <hayley> () is easier to type than (?:) and it looks less weird to me.
[15:07:25] *** Quits: random-nick (~random-ni@87.116.165.83) (Ping timeout: 240 seconds)
[15:09:42] <Nilby> You'd need to add forbidden social/political keywords to really disappear. I think POSIX parser is overrated. There's already like 20 slightly different syntaxes, I use lisp commands instead of POSIX or emacs, so now I only know cl-ppcre's variant.
[15:10:01] <lisp123w> pjb & beach - many thanks, that's very helpful
[15:10:32] <hayley> I was told the PPCRE extensions to POSIX regular expressions are all parse errors for a POSIX parser, but I have never tested that.
[15:11:04] <Nilby> That seems true-ish.
[15:11:41] <Nilby> that explains the (?:)
[15:11:48] <hayley> It's ironic is that the syntax for regular expressions is not regular :)
[15:11:53] <hayley> s/is//
[15:12:13] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[15:12:58] <lisp123w> I was looking at a data structure where there is Integer IDs as keys and then an object as a value. So bit vectors could very useful? I'm mostly looking at set union / intersection / complement so was thinking using numbers as a key might be useful
[15:12:59] <Nilby> the irony is not lost on GNU's not unix or posix or linux or etc.etc.
[15:14:51] <hayley> But there are a few "save the user from themselves" points around RE engines. gilberth mentioned checking which variables are actually used in a scanner action, so as to avoid handling submatches where they are never observed. The Rust library has a special case for submatching where it will defer to the non-submatching path if there are no subgroups in the RE, with a comment like "save the user from themselves".
[15:15:10] <lisp123w> I will definitely start off with a protocol to abstract away the interface (thanks for reminding) and then will have a look at bit vectors. I saw Microsoft did something once where, say items 1 - 15 are populated in a set, they would create a "block" saying [start 1 ; End 15], and then if one is comparing two different sets, its a bit easier because you can compare the blocks and then drill down as necessary
[15:15:25] <hayley> But there is basically no overhead to submatching with this approach, except for more register pressure.
[15:16:09] <hayley> Hm, yes, gilberth gave me an implementation of that structure, called an isum. Apparently McCLIM uses a two dimensional version of it.
[15:16:22] <Nilby> hayley: pointless subgrouping does seem very common in the wild
[15:16:38] *** Joins: pdietz (~pdietz@216-59-66-162.static.firstlight.net)
[15:17:23] <hayley> https://github.com/telekons/one-more-re-nightmare/blob/master/Code/DFA-construction/sets.lisp
[15:18:33] <hayley> Nilby: So, it's nicer to make the better thing easier to do, which to me is to have () not submatch, and some other syntax for submatching.
[15:20:18] <pdietz> It really depends on what the sets look like, and what operations you want to perform.
[15:21:25] *** Quits: gxt (~gxt@gateway/tor-sasl/gxt) (Remote host closed the connection)
[15:21:45] *** Joins: gxt (~gxt@gateway/tor-sasl/gxt)
[15:21:53] <Nilby> hayley: ppcre got me used to () for submatch, but since you used nicely used esrap, maybe we swap syntaxes
[15:22:06] <hayley> lol
[15:25:26] *** Quits: Algernon69 (~Algernon6@2a04:cec0:11cc:d11e:294b:a29d:8c1f:dfa4) (Ping timeout: 252 seconds)
[15:27:28] <Nilby> (let ((esrap::*rules* (make-my-own-personal-re-nightmare))) (omrn:all-matches ...)))
[15:29:59] *** Quits: phantomics (~phantomic@97-118-231-120.hlrn.qwest.net) (Read error: Connection reset by peer)
[15:30:11] <lisp123w> pdietz: Looks like it. The background of my initial query was that I was lookin at some Swift code and they have sets. The beauty of lisp seems to be its much easier to build custom approaches to data than other languages
[15:30:34] <lisp123w> (at least compared to Swift)
[15:30:38] *** Joins: theothornhill (~user@217.84-49-191.nextgentel.com)
[15:33:21] <pdietz> You might look at the FSET package (available in Quicklisp).    It provides implementations and convenient syntax for sets, bags, and maps, and shadows some CL builtin functions with symbols that are fbound to generic functions that default to calling the CL functions.   This allows methods to be added for the new collection types, and for new
[15:33:21] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[15:33:21] <pdietz> collection types to be added.
[15:33:47] <theothornhill> How would you deal with case sensitivity in lisp? I can do trickery to convert from/to camelCase or PascalCase, but I need to do some inferencing on type names.  And in graphql case is important.  For example, I want the type
[15:34:14] <theothornhill> 'Query' to be that, and not 'QUERY'.  Sorry, misclick
[15:34:15] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[15:35:10] <theothornhill> I guess it is possible to have a class called |Dog|, but that is kinda ugly
[15:35:18] <lisp123w> pdietz: Thanks, will check it out.
[15:35:44] <pdietz> I normally just live with CL's conventional approach, and if I want case sensitive symbols I escape them.  The CL convention is to use kebab case.
[15:36:18] <pdietz> Not ThisIsAName or thisIsAName or this_is_a_name, but this-is-a-name
[15:37:02] <theothornhill> Ok, so you'd use it as kebab internally in your library, then convert when shipping it as json, etc?
[15:39:33] <pdietz> cl-json has a converter from camel case to "lisp" (i.e., kebab case) and back again, for example.
[15:40:03] <pdietz> Some json libraries for CL just leave things in strings (like jsown); this is often faster.
[15:41:19] <pdietz> The intern function can be annoyingly slow; when I want symbols out from json I found it was faster to use jsown and then write a custom string->symbol convertor for jsown using string-case to handle the common cases for the particular json I was working with.
[15:43:48] <pdietz> string-case plays some interesting games to get really fast code; I wonder if those regular expression libraries could learn a thing or two.
[15:44:58] <theothornhill> pdietz: thanks.  I'll see how I can work without dealing with casing, then!
[15:48:10] *** Joins: Algernon69 (~Algernon6@2a04:cec0:11cc:d11e:294b:a29d:8c1f:dfa4)
[15:49:40] <pdietz> To be clear: string-case has nothing to do with the upper or lower case, but rather with case as a switch-like control flow macro.
[15:50:21] *** Joins: frodef (~frode@46.212.93.4)
[15:50:49] <theothornhill> string-case from alexandria?
[15:51:45] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[15:52:09] <frodef> Hi all. My sbcl/asdf/quiclisp setup has somehow gone haywire since I tried to add an ~/.config/common-lisp/source-registry.conf
[15:53:06] <frodef> That is, (load "~/quicklisp/setup") results in a 'COMPILE-FILE-ERROR while compiling #<CL-SOURCE-FILE "asdf" "build" "asdf">' that I'm unable to make sense of.
[15:53:30] <frodef> ...even after I removed the .conf file completely.
[15:57:59] <frodef> (oh my, have to go, back in an hour or two..)
[16:02:19] <pdietz> No, from string-case.    (ql:quickload :string-case)
[16:03:03] <Nilby> frodef: As you may know, the "easy" way, which may induce some long recompiling, is probably to "rm -r ~/.cache/common-lisp" . The harder way is to figure out what went wrong, which is likely some conflict in compiled versions of asdf. Perhaps you ended up with another asdf in you source registry?
[16:04:15] <theothornhill> pdietz: ah ok. Thanks!  I'm actually thinking of just requiring for the user to supply a :name along with the types to define. Then that could just be a string, and I can operate more easily with kebab-casing guilt free
[16:29:47] *** Quits: theothornhill (~user@217.84-49-191.nextgentel.com) (Ping timeout: 252 seconds)
[16:33:49] *** Quits: attila_lendvai (~alendvai@catv-80-99-179-152.catv.broadband.hu) (Ping timeout: 252 seconds)
[16:47:50] *** Joins: lisp123 (~lisp123@5.30.23.247)
[16:52:13] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 240 seconds)
[16:55:29] *** Parts: danirukun[m] (~dpetrovsm@2001:470:69fc:105::7911) ()
[16:56:09] *** Joins: dpetrovs (~user@185.68.250.217)
[16:58:53] *** Quits: OlCe (~user@lfbn-nic-1-262-221.w90-116.abo.wanadoo.fr) (Ping timeout: 256 seconds)
[17:05:07] <frodef> Nilby: thanks, but I already tried removing the cache, to no apparent effect, even in terms of compilation time. I really don't get it.
[17:10:06] <frodef> Hm.. I was able to trace it, and it seems somehow it's loading/compiling asdf from ~/src/MBuild, which makes no sense. That's just a build system for Mezzano that's randombly lying around. sigh.
[17:10:54] <froggey> make sure it isn't linked from quicklisp's local-projects directory
[17:13:35] <frodef> So.. trying to make my code available for asdf, I'd made a symlink ~/common-lisp to ~/src and then the presence of ~/src/MBuild/ just broke everything.
[17:23:27] <frodef> ..and apparently any old library code found anywhere in ~/src will just override (and break) the quicklisp projects, without warning. Seems a bit brittle design to me.
[17:23:34] *** Joins: Bike (~Glossina@71.69.170.70)
[17:23:34] *** ChanServ sets mode: +o Bike
[17:27:06] *** Joins: OlCe` (~user@lfbn-nic-1-117-213.w2-15.abo.wanadoo.fr)
[17:35:36] *** Joins: attila_lendvai (~alendvai@catv-213-222-130-233.catv.broadband.hu)
[17:46:38] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[17:47:52] <cranium> I guess quicklisp lets you override things by putting them into the ~/quicklisp/local-projects folder (which makes sense imho), and it treats ~/common-lisp the same way (also makes sense).
[17:47:58] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[17:48:33] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[17:49:05] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[17:52:10] *** Joins: s-liao (~s-liao@101.86.99.70)
[17:54:09] <cranium> What confuses me is that it apparently loads enough of such code at startup to break things? ~/quicklisp/setup does some (re-)loading of asdf, which I guess conflicted with the hierarchy in <https://github.com/froggey/MBuild/tree/master/home>
[17:54:23] <cranium> and then all hell broke loose.
[17:55:33] *** Joins: kennyd (~bc8165b6@cerf.good1.com)
[18:03:03] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[18:07:12] <etimmons> ASDF attempts to eagerly upgrade itself. So QL probably used the ASDF bundled with your implementation, then when the QL client was loaded (via asdf:load-system), ASDF saw there was a newer version of itself available and tried upgrading
[18:15:08] <frodef> I found the errors and restarts extremely unhelpful, btw.
[18:18:36] *** Quits: kennyd (~bc8165b6@cerf.good1.com) (Quit: CGI:IRC (Ping timeout))
[18:19:50] *** Joins: kennyd (~bc8165b6@cerf.good1.com)
[18:21:38] *** Joins: lisp123 (~lisp123@5.30.23.247)
[18:24:28] *** Joins: Algernon91 (~Algernon6@2a04:cec0:11c9:46f0:294b:a29d:8c1f:dfa4)
[18:26:09] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[18:27:50] *** Quits: Algernon69 (~Algernon6@2a04:cec0:11cc:d11e:294b:a29d:8c1f:dfa4) (Ping timeout: 265 seconds)
[18:29:01] *** Quits: attila_lendvai (~alendvai@catv-213-222-130-233.catv.broadband.hu) (Ping timeout: 240 seconds)
[18:44:05] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[18:45:14] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[18:51:06] *** Joins: dlowe (~dlowe@user/dlowe)
[18:52:11] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Remote host closed the connection)
[18:54:36] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[19:01:13] *** Quits: pdietz (~pdietz@216-59-66-162.static.firstlight.net) (Ping timeout: 256 seconds)
[19:07:49] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[19:07:49] *** Joins: VincentV` (~user@212.241.25.167)
[19:09:01] *** Quits: VincentVega (~user@212.241.25.167) (Ping timeout: 240 seconds)
[19:09:11] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[19:09:31] <mfiano> How do I parameterize the number 1 in the FORMAT control string "~,1f" ?
[19:10:05] <adeht> (format t "~,VF" 1 1.234)
[19:10:10] *** adeht is now known as _death
[19:10:15] <mfiano> Thanks
[19:11:00] *** Quits: jpl01 (~user@2001:16b8:4931:c600:c1ba:14a6:b08d:c22) (Remote host closed the connection)
[19:14:01] *** Joins: Guest74 (~Guest74@modemcable110.164-177-173.mc.videotron.ca)
[19:18:13] *** Quits: Cymew (~ante@c-e989225c.023-1144-7570702.bbcust.telenor.se) (Ping timeout: 240 seconds)
[19:21:27] *** Joins: pdietz (~pdietz@216-59-66-162.static.firstlight.net)
[19:24:25] *** Quits: s-liao (~s-liao@101.86.99.70) (Quit: Client closed)
[19:28:09] *** Joins: Catie (~user@user/catie)
[19:30:05] *** Joins: ebrasca (~user@librepanther.com)
[19:32:53] *** Joins: frgo (~frgo@2a02:3038:409:e061:e968:af33:4743:5fa1)
[19:33:35] *** Quits: VincentV` (~user@212.241.25.167) (Ping timeout: 256 seconds)
[19:49:19] *** Joins: random-nick (~random-ni@87.116.165.83)
[19:53:36] *** Joins: makomo (~makomo@user/makomo)
[20:06:07] *** Quits: parjanya (~esb@2804:14c:1ad:8b70::1000) (Remote host closed the connection)
[20:07:04] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Remote host closed the connection)
[20:07:18] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[20:14:55] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 252 seconds)
[20:21:01] *** Quits: dpetrovs (~user@185.68.250.217) (Ping timeout: 240 seconds)
[20:23:16] *** Joins: lisp123 (~lisp123@5.30.23.247)
[20:27:25] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 240 seconds)
[20:27:31] <xaltsc> Hey, I'm trying to define and use a package with asdf/quicklisp/sbcl, however, when I load the package, it complains that some variables, used in functions, are not defined, even though they are, some, in the same file, others in other files.
[20:30:52] <jackdaniel> xaltsc: I think that you'll have a better chance for help if you include some possibly shortened source code that illustrates the issue
[20:31:57] *** Quits: Devon (~devon@pool-108-28-172-103.washdc.fios.verizon.net) (Read error: Connection reset by peer)
[20:32:31] *** Quits: hhdave (~hhdave@ip212.ip-193-70-71.eu) (Ping timeout: 252 seconds)
[20:34:22] *** Joins: hhdave (~hhdave@ip212.ip-193-70-71.eu)
[20:35:18] *** Joins: dpetrovs (~user@185.68.250.217)
[20:40:13] *** Quits: dpetrovs (~user@185.68.250.217) (Ping timeout: 252 seconds)
[20:40:39] <xaltsc> jackdaniel: http://paste.debian.net/1222456/
[20:41:30] <cranium> is it only in this example that there's no (in-package ...) in foo.lisp and bar.lisp?
[20:42:27] <dlowe> xaltsc: in-package forms only affect the file they're in - you need to have it in each
[20:42:48] <dlowe> (the truth is more subtle but the answer is to put in-package forms at the top of your file
[20:42:49] <jackdaniel> that. also you use the variable *bar* which is defined in the file compiled later - it will work but that will give you a warning
[20:43:03] <dlowe> worse, it will *sometimes* do what you want depending on the current package
[20:43:20] <xaltsc> I forgot to include them in this minimal example, but it doesn't change anything. It seems that the order of the components matter though. foo.lisp errors when bar.lisp is defined after, and the converse.
[20:44:05] <cranium> Yes, order does matter and sadly one has to define it manually.
[20:44:22] <xaltsc> ugh
[20:47:52] <cranium> but you also have a circular dependency. I'm not sure if that is smart or what the proper solution is that allows you to have that.
[20:49:28] <xaltsc> I added the circular dependency as an example, in the real project, the one thing that makes it fail is that the package is defined in main.lisp but I load this file last as it is supposed to have access to other files in the project
[20:49:47] <xaltsc> *to other symbols defined in other files
[20:49:49] *** Joins: karlosz (~karlosz@47.151.136.69)
[20:49:53] *** Joins: yewscion (~yewscion@52.95.4.12)
[20:50:09] <jackdaniel> xaltsc: usual approach is to have a file with packages (defined first)
[20:50:18] <jackdaniel> then you have source code, and then you may have a main file as the last one
[20:50:24] <cranium> oh, that isn't gonna work very well. Package needs to come first, particularly before (in-package ...) calls.
[20:50:52] <jackdaniel> if you have in-package in each file, then your example seems like something that hsould work
[20:51:33] <jackdaniel> but yeah, package needs to be defined before the rest is defined in that package
[20:52:18] <cranium> have a package.lisp file with only the defpackage that gets loaded first (i.e. first element in :components)
[20:53:03] *** Quits: taiju (~taiju@240b:253:ec40:2400:651e:f83b:5890:99a6) (Ping timeout: 252 seconds)
[20:53:16] *** Quits: karlosz (~karlosz@47.151.136.69) (Client Quit)
[20:53:42] *** Joins: dpetrovs (~user@185.68.250.217)
[20:55:24] *** Joins: Devon (~devon@pool-108-28-172-103.washdc.fios.verizon.net)
[20:56:22] <xaltsc> So, I've added a package.lisp file, now loading the project in the interpreter errors on defconstant s, which it says are being redefined (even though they are not)
[20:57:11] <jackdaniel> xaltsc: I gather that they are strings
[20:57:20] <xaltsc> jackdaniel: alists actually
[20:57:40] <jackdaniel> ah, OK. the thing is that they are not EQL to each other
[20:58:23] <jackdaniel> other implementations let it slide,  but sbcl is very scrupulate about that - if you evaluate defconstant twice with an object that is not eql to itself then it will cause an error
[20:58:51] <jackdaniel> there is a reason for that. either way just use defvar (or alexandria:define-constant that allows specifying the test)
[20:58:54] <xaltsc> So SBCL can only define constants for primitive types ?
[20:59:30] <cranium> does the violation also happen if you simply quickload a project twice? i.e. my-package:my-constant gets defined twice so it complains?
[20:59:30] <jackdaniel> no, it can define a constant for any type, but it will refuse to redefine it to another object that is not eql to the former one
[21:01:35] *** Quits: hhdave (~hhdave@ip212.ip-193-70-71.eu) (Ping timeout: 268 seconds)
[21:01:45] <jackdaniel> (i.e if you put a reference to the same object in multiple defconstant forms then there will be no problem)
[21:02:39] *** Joins: hhdave (~hhdave@ip212.ip-193-70-71.eu)
[21:06:30] <jackdaniel> i.e try (defvar *yyy* "zzz") and (defconstant +yyy+ *yyy*) multiple times - that shall work
[21:06:41] <jackdaniel> otoh (defconstant +yyy+ "zzz") multiple times won't
[21:08:29] <_death> http://www.sbcl.org/manual/#Defining-Constants
[21:09:39] *** Joins: Algernon666 (~Algernon6@2a01:e0a:511:6ce0:91bc:7f19:7ad4:1afd)
[21:09:41] *** Quits: Algernon91 (~Algernon6@2a04:cec0:11c9:46f0:294b:a29d:8c1f:dfa4) (Read error: No route to host)
[21:10:36] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[21:10:43] *** Quits: dpetrovs (~user@185.68.250.217) (Ping timeout: 265 seconds)
[21:11:02] <Guest74> is there any way to get the declarations in a defun?  Would like to use it for documentation and for autocomplete of args.
[21:12:59] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[21:13:12] <_death> cltl2 defined a FUNCTION-INFORMATION operator
[21:14:17] <edgar-rft> does it inform you when your code funtions?
[21:15:10] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[21:15:27] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[21:16:05] <Guest74> _death: welp, that told me it's a function :)
[21:16:20] *** Quits: sander (~sander@user/sander) (Ping timeout: 252 seconds)
[21:17:29] *** Quits: frgo (~frgo@2a02:3038:409:e061:e968:af33:4743:5fa1) (Remote host closed the connection)
[21:17:55] *** Joins: sander (~sander@user/sander)
[21:18:03] <jackdaniel> there are some environment operators documented in cltl2, you may look at them. in sbcl they are implemented in the package sb-cltl2
[21:22:48] *** Quits: yewscion (~yewscion@52.95.4.12) (Ping timeout: 265 seconds)
[21:23:28] *** Joins: yewscion (~yewscion@52.94.133.131)
[21:25:14] <jcowan> hayley: Scheme is moving away from string regular expressions toward combinators: see https://srfi.schemers.org/srfi-115/srfi-115.html#SRE-Syntax
[21:26:13] *** Quits: slyrus (~slyrus@192-184-223-165.static.sonic.net) (Ping timeout: 240 seconds)
[21:33:04] <yitzi> Guest74: Are you trying to get the lambda list? I assume you don't mean the declarations, i.e. '(declare (...)`
[21:33:30] <Guest74> i do mean the declarations
[21:33:50] *** Joins: karlosz (~karlosz@47.151.136.69)
[21:36:14] *** Joins: dpetrovs (~user@185.68.250.217)
[21:37:07] <yitzi> Ok then.
[21:38:22] *** Joins: Algernon91 (~Algernon6@2a04:cec0:11c9:46f0:756a:e8b7:3772:2555)
[21:39:15] *** Quits: yewscion (~yewscion@52.94.133.131) (Ping timeout: 252 seconds)
[21:40:03] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[21:41:54] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[21:42:11] *** Quits: Algernon666 (~Algernon6@2a01:e0a:511:6ce0:91bc:7f19:7ad4:1afd) (Ping timeout: 252 seconds)
[21:44:13] *** Quits: dlowe (~dlowe@user/dlowe) (Remote host closed the connection)
[21:44:22] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[21:45:05] *** Joins: amb007 (~a_bakic@53.151.22.93.rev.sfr.net)
[21:51:14] *** Quits: karlosz (~karlosz@47.151.136.69) (Quit: karlosz)
[21:51:32] *** Joins: slyrus (~slyrus@192-184-223-165.static.sonic.net)
[21:56:37] *** Quits: dpetrovs (~user@185.68.250.217) (Ping timeout: 240 seconds)
[21:57:55] *** Quits: treflip (~user@95.79.32.99) (Quit: good night)
[22:06:56] *** Joins: theothornhill (~user@217.84-49-191.nextgentel.com)
[22:07:21] *** Joins: lisp123 (~lisp123@5.30.23.247)
[22:10:40] *** Joins: rotateq (~user@p200300e787097300818cd04b4ea1a4f3.dip0.t-ipconnect.de)
[22:12:06] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[22:12:44] *** Joins: yewscion (~yewscion@52.94.133.131)
[22:22:32] *** Joins: rgherdt (~rgherdt@2a02:8109:86c0:d8d:f1ba:fd5a:67b3:b8c0)
[22:22:41] *** Joins: dpetrovs (~user@185.68.250.217)
[22:32:26] *** Joins: frgo (~frgo@p548a30d7.dip0.t-ipconnect.de)
[22:35:32] *** Quits: Algernon91 (~Algernon6@2a04:cec0:11c9:46f0:756a:e8b7:3772:2555) (Ping timeout: 252 seconds)
[22:39:50] *** Quits: amb007 (~a_bakic@53.151.22.93.rev.sfr.net) (Read error: Connection reset by peer)
[22:40:29] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[22:40:36] *** Joins: amb007 (~a_bakic@102.215.76.86.rev.sfr.net)
[22:41:09] *** Quits: robin (~robin@user/terpri) (Remote host closed the connection)
[22:41:33] *** Joins: robin (~robin@user/terpri)
[22:43:47] *** Quits: dpetrovs (~user@185.68.250.217) (Ping timeout: 252 seconds)
[22:51:17] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[22:51:44] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[22:53:11] *** Quits: igemnace (~ian@user/igemnace) (Ping timeout: 265 seconds)
[22:56:10] *** Joins: nature (~nature@45.32.235.173)
[23:09:22] *** Joins: dpetrovs (~user@185.68.250.217)
[23:13:12] *** Joins: lisp123 (~lisp123@5.30.23.247)
[23:14:00] *** Joins: gaqwas (~john@dynamic-095-114-098-056.95.114.pool.telefonica.de)
[23:14:13] *** Quits: dpetrovs (~user@185.68.250.217) (Ping timeout: 240 seconds)
[23:14:55] *** Joins: VincentVega (~user@212.241.25.167)
[23:17:49] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 240 seconds)
[23:19:52] *** Joins: tyson2 (~user@cpe44d9e795a64f-cm688f2e2dfaa0.sdns.net.rogers.com)
[23:22:47] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Remote host closed the connection)
[23:23:31] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[23:26:13] *** Joins: dpetrovs (~user@185.68.250.217)
[23:33:36] *** Quits: lagash (lagash@lagash.shelltalk.net) (Quit: ZNC - https://znc.in)
[23:34:16] *** Joins: lagash (lagash@lagash.shelltalk.net)
[23:36:53] *** Joins: igemnace (~ian@user/igemnace)
[23:38:27] *** Quits: lagash (lagash@lagash.shelltalk.net) (Client Quit)
[23:38:48] *** Joins: lagash (lagash@lagash.shelltalk.net)
[23:40:51] *** Joins: voltron (~voltrin_@ip4d16bdc6.dynamic.kabel-deutschland.de)
[23:41:01] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 240 seconds)
[23:44:32] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[23:47:32] *** Quits: lagash (lagash@lagash.shelltalk.net) (Quit: ZNC - https://znc.in)
[23:49:02] *** Quits: pve (~pve@87-93-4-46.bb.dnainternet.fi) (Quit: leaving)
[23:49:15] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[23:50:13] *** Quits: dpetrovs (~user@185.68.250.217) (Ping timeout: 265 seconds)
[23:56:38] *** Quits: cage (~cage@dynamic-adsl-84-220-241-149.clienti.tiscali.it) (Quit: rcirc on GNU Emacs 27.1)
[23:58:09] *** Quits: anticomputer (~anticompu@gateway/tor-sasl/anticomputer) (Remote host closed the connection)
[23:58:24] *** Joins: anticomputer (~anticompu@gateway/tor-sasl/anticomputer)
[23:59:12] *** Joins: lagash (lagash@lagash.shelltalk.net)
