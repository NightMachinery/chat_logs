[00:13:56] *** Joins: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl)
[00:48:27] *** Quits: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl) (Ping timeout: 256 seconds)
[00:55:24] *** Joins: Pickchea (~private@user/pickchea)
[01:17:05] *** Quits: jespada (~jespada@cpc121022-nmal24-2-0-cust171.19-2.cable.virginm.net) (Quit: Textual IRC Client: www.textualapp.com)
[01:22:51] *** Joins: romesrf (~romes@198.177.63.94.rev.vodafone.pt)
[01:24:06] *** Quits: geekosaur (~geekosaur@xmonad/geekosaur) (Remote host closed the connection)
[01:25:53] *** Joins: geekosaur (~geekosaur@xmonad/geekosaur)
[01:31:40] *** Quits: coot (~coot@213.134.190.95) (Quit: coot)
[01:34:17] *** Quits: hololeap (~hololeap@user/hololeap) (Excess Flood)
[01:35:37] *** Joins: hololeap (~hololeap@user/hololeap)
[01:42:34] *** Quits: Pickchea (~private@user/pickchea) (Quit: Leaving)
[01:55:11] *** Joins: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:ecfc:ebe1:b77a:f914)
[01:57:52] *** Quits: yrlnry (~mjd@67.205.255.173) (Ping timeout: 272 seconds)
[02:13:48] *** Quits: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:ecfc:ebe1:b77a:f914) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[02:18:10] *** Joins: jespada (~jespada@cpc121022-nmal24-2-0-cust171.19-2.cable.virginm.net)
[02:31:27] *** Quits: romesrf (~romes@198.177.63.94.rev.vodafone.pt) (Quit: WeeChat 3.4)
[02:49:19] *** Joins: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl)
[03:18:56] *** Quits: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl) (Ping timeout: 272 seconds)
[03:21:57] *** Quits: spider__ (~spider@vps-951ce37a.vps.ovh.ca) (Ping timeout: 240 seconds)
[03:48:31] *** Quits: hololeap (~hololeap@user/hololeap) (Write error: Connection reset by peer)
[03:48:31] *** Quits: ChaiTRex (~ChaiTRex@user/chaitrex) (Read error: Connection reset by peer)
[03:49:27] *** Joins: hololeap (~hololeap@user/hololeap)
[03:51:06] *** Joins: ChaiTRex (~ChaiTRex@user/chaitrex)
[03:51:44] *** liz_ is now known as liz
[03:56:47] *** Joins: da39a3ee5e6b4b0d (~textual@171.5.29.46)
[04:22:13] *** Quits: liz (~liz@2a00:23c5:9680:501:b62e:99ff:fee4:47fa) (Quit: Leaving)
[04:22:33] *** Joins: liz (~liz@2a00:23c5:9680:501:b62e:99ff:fee4:47fa)
[04:26:06] *** Quits: da39a3ee5e6b4b0d (~textual@171.5.29.46) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[04:27:19] *** Joins: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:f0a7:d746:8a92:8ad4)
[04:28:46] *** Quits: liz (~liz@2a00:23c5:9680:501:b62e:99ff:fee4:47fa) (Quit: Leaving)
[04:29:41] *** Quits: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:f0a7:d746:8a92:8ad4) (Client Quit)
[04:33:59] *** Joins: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:f0a7:d746:8a92:8ad4)
[04:38:10] *** Joins: liz (~liz@2a00:23c5:9680:501:b62e:99ff:fee4:47fa)
[05:01:20] *** Quits: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:f0a7:d746:8a92:8ad4) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[05:15:00] *** Joins: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl)
[05:18:04] *** Joins: strawburr (~user@172.56.40.24)
[05:24:49] *** Joins: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:f0a7:d746:8a92:8ad4)
[05:39:52] *** Quits: geekosaur (~geekosaur@xmonad/geekosaur) (Quit: Leaving)
[05:41:29] *** Joins: geekosaur (~geekosaur@xmonad/geekosaur)
[05:48:33] *** Quits: liz (~liz@2a00:23c5:9680:501:b62e:99ff:fee4:47fa) (Remote host closed the connection)
[05:48:57] *** Quits: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl) (Ping timeout: 240 seconds)
[07:45:42] *** Joins: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl)
[08:19:37] *** Quits: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl) (Ping timeout: 240 seconds)
[08:20:38] *** Quits: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:f0a7:d746:8a92:8ad4) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[08:49:17] *** Quits: mvk (~mvk@2607:fea8:5cc3:7e00::45ee) (Ping timeout: 240 seconds)
[09:10:57] *** Quits: boborygmy (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net) (Ping timeout: 240 seconds)
[09:10:57] *** Quits: soxen (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net) (Ping timeout: 240 seconds)
[09:20:34] *** Joins: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:f0a7:d746:8a92:8ad4)
[09:21:54] *** Quits: strawburr (~user@172.56.40.24) (Remote host closed the connection)
[09:26:44] *** Quits: mcglk (~mcglk@131.191.49.120) (Read error: Connection reset by peer)
[09:29:14] *** Joins: mcglk (~mcglk@131.191.49.120)
[09:51:37] *** Quits: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:f0a7:d746:8a92:8ad4) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[09:53:55] *** Joins: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:f0a7:d746:8a92:8ad4)
[10:08:41] *** Joins: coot (~coot@213.134.190.95)
[10:09:31] *** Joins: szkl (uid110435@id-110435.uxbridge.irccloud.com)
[10:16:25] *** Joins: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl)
[10:30:11] *** Quits: ChaiTRex (~ChaiTRex@user/chaitrex) (Remote host closed the connection)
[10:32:33] *** Joins: ChaiTRex (~ChaiTRex@user/chaitrex)
[10:33:17] *** Joins: libertyprime (~libertypr@118-92-82-225.dsl.dyn.ihug.co.nz)
[10:50:49] *** Quits: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl) (Ping timeout: 256 seconds)
[11:22:03] *** Quits: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:f0a7:d746:8a92:8ad4) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[12:00:27] *** Joins: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl)
[12:20:07] *** Joins: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:fc46:f60:614b:bd)
[12:42:32] *** Quits: libertyprime (~libertypr@118-92-82-225.dsl.dyn.ihug.co.nz) (Remote host closed the connection)
[14:05:42] *** Quits: coot (~coot@213.134.190.95) (Quit: coot)
[14:19:22] *** Quits: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:fc46:f60:614b:bd) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[14:19:23] *** Joins: coot (~coot@213.134.190.95)
[14:29:05] *** Quits: coot (~coot@213.134.190.95) (Quit: coot)
[14:31:34] *** Joins: benin (~benin@183.82.26.94)
[14:37:41] *** Quits: zaquest (~notzaques@5.130.79.72) (Remote host closed the connection)
[14:38:50] *** Joins: zaquest (~notzaques@5.130.79.72)
[14:52:32] *** Joins: coot (~coot@213.134.190.95)
[15:10:48] *** Quits: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl) (Ping timeout: 272 seconds)
[15:11:55] *** Joins: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl)
[15:16:25] *** Quits: benin (~benin@183.82.26.94) (Remote host closed the connection)
[15:46:46] *** Quits: geekosaur (~geekosaur@xmonad/geekosaur) (Killed (NickServ (GHOST command used by allbery_b)))
[15:46:48] *** Joins: allbery_b (~geekosaur@xmonad/geekosaur)
[15:46:51] *** allbery_b is now known as geekosaur
[15:59:56] *** Joins: romesrf (~romes@198.177.63.94.rev.vodafone.pt)
[16:09:58] *** Joins: strawburr (~user@172.56.40.24)
[16:25:17] *** Joins: vpan (~0@212.117.1.172)
[17:15:26] *** Joins: soxen (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net)
[17:15:26] *** Joins: boborygmy (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net)
[17:42:51] *** Quits: strawburr (~user@172.56.40.24) (Read error: Connection reset by peer)
[17:44:42] *** Quits: soxen (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net) (Ping timeout: 272 seconds)
[17:44:42] *** Quits: boborygmy (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net) (Ping timeout: 272 seconds)
[18:03:04] *** Quits: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl) (Ping timeout: 272 seconds)
[18:05:59] *** Joins: soxen (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net)
[18:06:00] *** Joins: boborygmy (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net)
[18:30:05] *** Quits: toulene (~toulene@user/toulene) (Quit: The Lounge - https://thelounge.chat)
[18:32:10] *** Joins: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl)
[18:36:53] *** Quits: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl) (Ping timeout: 252 seconds)
[19:09:25] *** Joins: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl)
[19:27:22] *** Quits: romesrf (~romes@198.177.63.94.rev.vodafone.pt) (Ping timeout: 256 seconds)
[19:44:00] *** Quits: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl) (Ping timeout: 252 seconds)
[20:11:06] *** Joins: toulene (~toulene@user/toulene)
[20:18:14] *** Joins: mvk (~mvk@2607:fea8:5cc3:7e00::45ee)
[20:37:50] *** Joins: liz_ (~liz@2a00:23c5:9680:501:b62e:99ff:fee4:47fa)
[20:40:15] <deadmarshal> https://paste.c-net.org/TendsSelves
[20:40:52] <deadmarshal> How should i resolve this?
[20:41:42] <geekosaur> well, yes. you have 3 cases which produce numbers and the fourth suddenly produces a list
[20:41:52] <geekosaur> how did you want the first three to work?
[20:42:53] <geekosaur> (also I wonder if that `n` is a placeholder, since it's otherwise going to create problems)
[20:42:56] <geekosaur> > 0 ^ 0
[20:42:58] <lambdabot>  1
[20:44:08] <deadmarshal> I want to append n to list whenever 'o' occurs in string. I don't think n ever be 0 though
[20:44:37] <geekosaur> `  where n = 0`
[20:45:20] <deadmarshal> oh no. i mean the second 0 in 0 ^ 0
[20:45:50] <deadmarshal> I mean the n gets incremented before that ^ happens
[20:45:54] <geekosaur> (I'd forgotten Haskell went for 0^0=1 instead of one of the other choices; it's kinda poorly defined)
[20:46:14] <geekosaur> uh, how do you plan to increment n?
[20:46:22] <geekosaur> it's not a box you can update
[20:46:55] <deadmarshal> 'i' -> (+1) n doesn't this do?
[20:47:04] <geekosaur> nope
[20:47:20] <geekosaur> it specifies the result of the case expression in that leg as n+1
[20:47:40] <deadmarshal> :/
[20:48:18] <geekosaur> haskell does not have variables, you can't increment them. and it has expressions, and case is an expression, not a list of procedures.
[20:49:30] <deadmarshal> right
[21:00:36] <geekosaur> what you would do in this case is use recursion, and pass the new n to each recursive invocation. here, you probably want a helper which does the actual recursion, with the wrapper kicking things off by providing the helper with 0 as the initial value
[21:06:23] <geekosaur> so if I understand what you're doing correctly, you want something like https://paste.tomsmeding.com/Q1gVgDRT
[21:06:42] <geekosaur> (I also added the base/end case you missed when the list of commands is empty)
[21:09:02] *** Quits: vpan (~0@212.117.1.172) (Quit: Leaving.)
[21:09:02] <deadmarshal> thank you
[21:11:50] *** Joins: romesrf (~romes@2001:8a0:6d13:9700:68ff:3f36:9684:1f6c)
[21:20:02] *** Quits: Kaipi (~Kaiepi@156.34.47.253) (Ping timeout: 272 seconds)
[21:38:57] *** Quits: soxen (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net) (Ping timeout: 240 seconds)
[21:39:05] *** Quits: boborygmy (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net) (Ping timeout: 256 seconds)
[21:40:03] *** Joins: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl)
[21:53:00] *** Quits: julm (~julm@user/julm) (Ping timeout: 240 seconds)
[22:03:51] *** Joins: julm (~julm@revolt129.abo.ilico.org)
[22:04:15] *** julm is now known as Guest1350
[22:09:02] *** Quits: romesrf (~romes@2001:8a0:6d13:9700:68ff:3f36:9684:1f6c) (Ping timeout: 240 seconds)
[22:14:32] *** Quits: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl) (Ping timeout: 256 seconds)
[22:15:32] *** Joins: yrlnry (~mjd@pool-74-109-20-19.phlapa.fios.verizon.net)
[22:15:44] *** Joins: Kaipi (~Kaiepi@156.34.47.253)
[23:06:28] *** Guest1350 is now known as julm
[23:06:57] *** julm is now known as Guest4339
[23:13:44] *** Joins: haskelln00b (~haskelln0@94.177.118.72)
[23:14:05] *** Joins: romesrf (~romes@44.190.189.46.rev.vodafone.pt)
[23:16:42] <haskelln00b> @yahb help
[23:16:42] <lambdabot> Drink up, me 'earties
[23:17:07] <geekosaur> heh
[23:17:16] <geekosaur> dunno what you expected that to do, but
[23:17:20] <geekosaur> @help yarr
[23:17:20] <lambdabot> yarr. Talk to a scurvy pirate
[23:17:26] <haskelln00b> wondering what I can say to it
[23:17:32] <haskelln00b> i.e., > % etc
[23:17:43] <geekosaur> yahb (% prefix) is ghci
[23:18:08] <geekosaur> the rest is lambdabot (> is @run, :t is @type, :k is @kind)
[23:18:50] <geekosaur> and lambdabot and yahb don't know about each other
[23:19:06] <geekosaur> which is why I had to enter the Num instance separately for both
[23:19:22] <haskelln00b> ic thx so do they recycle their ghci from time to time?
[23:19:28] <geekosaur> also yahb is only in #haskell, wheread lambdabot is in a bunch of channels
[23:19:31] <haskelln00b> or do users enter :q at some point to restart?
[23:19:36] <geekosaur> the latter
[23:19:49] <geekosaur> I'll probably do that shortly to clear out the function Num instance
[23:20:00] <geekosaur> since it causes surprises if you're not expecting it
[23:20:21] <haskelln00b> ic how do you know btw?  I couldn't find obvious web pages on these at a glance
[23:20:32] <haskelln00b> just from observation?
[23:20:35] <geekosaur> yes
[23:20:45] <haskelln00b> ah ok :)
[23:21:03] <geekosaur> also I used to run a lambdabot so I know it pretty well, and have discussed yahb with its owner
[23:22:24] <geekosaur> (someday I need to finish patching up my full help docs for using lambdabot and put it back online.I have partial docs but I removed most of the Haskell related plugins from the copy I was using)
[23:22:27] <haskelln00b> got it I'm all new to this very interesting
[23:24:04] <haskelln00b> and thx for the pointers - I guess your Num incantation from #haskell makes b->a a Num instnace and so + works for functions
[23:24:13] <geekosaur> yes
[23:24:34] <haskelln00b> is there a reason that's not standard?
[23:24:37] <geekosaur> it's also a specialization; the general one makes any Applicative instance including lists into Num instances
[23:24:58] <geekosaur> because it means things one would expect to be type errors suddenly work (sometimes inexplicably)
[23:26:16] <haskelln00b> fair enough - in the Num domain, I would think that it would be reasonable to expect monoid-ness of Nums would auto-extend to monoid-ness of functions yielding Nums , but perhaps some usages doesn't want that.
[23:26:50] <geekosaur> sometimes yes, usually it's just a type error though
[23:27:31] <haskelln00b> I guess easy enough to "lift" as you showed
[23:28:06] *** Quits: Midjak (~Midjak@82.66.147.146) (Quit: This computer has gone to sleep)
[23:29:07] <geekosaur> a small variation on that Num instance makes lists into Num instances; this means you get weord results instead of type errors if you accidentally feed something a list instead of a number (which is a relatively common error made even by experienced programmers)
[23:30:50] <geekosaur> > instance (Applicative t, Num a) => Num (t a) where (+) = liftA2 (+); (-) = liftA2 (-); (*) = liftA2 (*); negate = fmap negate; abs = fmap abs; signum = fmap signum; fromInteger = pure . fromInteger
[23:30:51] <lambdabot>  <hint>:1:1: error: parse error on input ‘instance’
[23:30:57] <geekosaur> @let instance (Applicative t, Num a) => Num (t a) where (+) = liftA2 (+); (-) = liftA2 (-); (*) = liftA2 (*); negate = fmap negate; abs = fmap abs; signum = fmap signum; fromInteger = pure . fromInteger
[23:30:58] <lambdabot>  Defined.
[23:31:04] <geekosaur> > [4] + [5]
[23:31:06] <lambdabot>  [9]
[23:31:14] <geekosaur> > (sin^2 + cos^2) 3
[23:31:16] <lambdabot>  0.9999999999999999
[23:31:59] <geekosaur> any Applicative including lists, functions, etc.
[23:32:09] <geekosaur> > Just 4 + Just 5
[23:32:11] <lambdabot>  Just 9
[23:32:32] <geekosaur> can be quite useful, but is usually just confusing when it doesn't work
[23:33:13] <geekosaur> and worse, if it does give you a type error it's likely to be in a completely different place from the actual mistake, as ghc happily infers weird types for as long as it can get away with it
[23:33:26] *** Joins: haskelln00b89 (~haskelln0@94.177.118.126)
[23:33:27] *** Quits: haskelln00b89 (~haskelln0@94.177.118.126) (Client Quit)
[23:33:38] *** Joins: haskelln00b2 (~haskelln0@94.177.118.126)
[23:33:53] <haskelln00b2> (got disconnected)
[23:34:41] *** Quits: haskelln00b (~haskelln0@94.177.118.72) (Ping timeout: 256 seconds)
[23:37:44] <geekosaur> typeinference can be very useful, but it's usually best to be specific about types so you get more sensible errors that are at least closer to where the actual bug is. this includes avoiding overly clever typeclass instances (like Applicative Num, or even function Num)
[23:38:20] <haskelln00b2> fair
[23:39:03] <haskelln00b2> when doing some exploratory programming, it seems useful to be able to be as laconic as possible sometimes
[23:39:30] <haskelln00b2> hence the adding functions etc to keep things short
[23:39:40] <haskelln00b2> but probably not a great practice for programming in the large, totally agree
[23:39:54] <geekosaur> including type signatures is actually a little more verbose, and requires a little more thinking. but it's much safer
[23:40:16] <haskelln00b2> yeah
[23:41:10] <haskelln00b2> maybe it would be useful to have haskell-mode show that in some way
[23:41:13] <haskelln00b2> to avoid surprises
[23:41:26] <haskelln00b2> maybe flash it in the mini buffer when writing a completed equation
[23:41:29] <geekosaur> @undef
[23:41:29] <lambdabot> Undefined.
[23:42:12] <geekosaur> well, it can show a type, but it'll always be the mostgeneral typepossible. whereas you helpthe compiler help you if you use the most *specific* type that does what you need
[23:42:26] <geekosaur> it can't guess that for you
[23:42:35] <haskelln00b2> ic what you mean
[23:43:11] <haskelln00b2> what you suggest is probably best for optimization etc as well
[23:44:32] <geekosaur> actually ghc is pretty good about optimization. and you can give it hints even if you use more general types (for example a SPECIALIZE pragma to tell it to optimize a generally-typed function for a more specific type)
[23:45:07] <haskelln00b2> interesting didn't know that
[23:45:21] <haskelln00b2> so specificity is more about catching errors and avoiding unintended "magic"
[23:45:28] *** Joins: soxen (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net)
[23:45:28] *** Joins: boborygmy (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net)
[23:45:30] <geekosaur> yes
[23:45:31] <haskelln00b2> type specificity
[23:45:52] <geekosaur> give the compiler enough rope and it'll hang you with it :) best to keep it short
[23:46:12] <haskelln00b2> :)
[23:46:31] <haskelln00b2> I'm still puzzling a bit over the last line : fromInteger = pure . fromInteger
[23:47:27] <haskelln00b2> I assume the two fromInteger identifiers on each side of that assignment refer to different functions
[23:47:33] <haskelln00b2> but with the same name
[23:47:36] <geekosaur> yes
[23:47:42] <haskelln00b2> is there a way to :t each of them?
[23:47:45] <haskelln00b2> to see the type
[23:47:52] <geekosaur> :t fromInteger
[23:47:53] <lambdabot> Num a => Integer -> a
[23:48:05] <geekosaur> each one is for a different Num instance
[23:48:05] <haskelln00b2> :t pure . fromInteger
[23:48:06] <lambdabot> (Applicative f, Num a) => Integer -> f a
[23:48:34] <haskelln00b2> so the one on the left is (Applicative f, Num a) => Integer -> f a ?
[23:48:44] <haskelln00b2> i.e., that's its fully qualified name so to speak?
[23:49:01] <haskelln00b2> well, I guess that's its type
[23:49:06] <haskelln00b2> what's its name?
[23:49:26] <geekosaur> that is the one being defined, which you know from: instance (Applicative t, Num a) => Num (t a)
[23:49:27] <haskelln00b2> or fully qualified name
[23:49:49] <geekosaur> then I supply definitions for all the instance methods of Num
[23:50:14] <haskelln00b2> ic so, there's no way to get the interpreter to print the type of that method?
[23:50:16] <geekosaur> in this case it uses fromInteger from a different Num instance (the one for Num a)
[23:50:52] <haskelln00b2> i.e., I have to locate and look at the definition of the typeclass to figure out the method's type
[23:51:00] <geekosaur> and pure is for the instance Applicative f
[23:51:05] <geekosaur> yes
[23:51:43] <haskelln00b2> that's too bad - seems like some missing reflection info
[23:52:13] <haskelln00b2> or is there a general way to ask the interpreter where it's loading from?
[23:52:36] *** Quits: yrlnry (~mjd@pool-74-109-20-19.phlapa.fios.verizon.net) (Ping timeout: 240 seconds)
[23:52:39] <haskelln00b2> I'll try to look that up ; but it's nice to be able to tell where the live definitions are being pulled from
[23:52:53] <haskelln00b2> ("live" as in loaded in the interpreter/repl)
[23:53:00] <geekosaur> it won't know in that case
[23:53:32] <geekosaur> allthe information it has is that I used Num a in the context, so the fromInteger on the right has to be referring to that instance
[23:54:07] <geekosaur> whereas the one on the left is for (Applicative f, Num a) => f a
[23:54:24] <geekosaur> this is a very abstract definition :)
[23:54:56] <haskelln00b2> I think it makes sense, but I'm just getting used to it :)
[23:55:36] <haskelln00b2> the reason I ask is b/c I'm staring at a line in a book
[23:55:42] <geekosaur> likewise the uses of pure, liftA2, and fmap all refer to the Applicative f in the context
[23:55:43] <haskelln00b2> and it shows
[23:55:58] <haskelln00b2> an example like: three :: Parser (Char, Char)
[23:56:25] <haskelln00b2> and it uses : three = pure g <*> item <*> item <*> item
[23:56:35] <haskelln00b2> with a where clause: where g x y z = (x,z)
[23:56:37] *** Joins: yrlnry (~mjd@pool-74-109-20-19.phlapa.fios.verizon.net)
[23:56:48] <haskelln00b2> so I'm manually tracing the types at each step of that applicative chain
[23:57:03] <haskelln00b2> and wondering if I can get the interpreter to auto-tell me what the types are
[23:57:30] <haskelln00b2> (this is form Graham Hutton's book)
[23:57:59] *** liz_ is now known as liz
