[00:07:58] *** Joins: nij- (~jin@2001-48F8-9021-806-0-0-0-619B-dynamic.midco.net)
[00:08:54] <nij-> Given an object, can I list all of its applicable methods (named) into a list? 
[00:16:04] <White_Flame> if somethign specializes on T (any type), should that be included?
[00:16:14] <White_Flame> or if it specializes on a subtype of your object?
[00:16:44] <White_Flame> I don't think there's such a function built in, but such questions would make it difficult to have a standard one
[00:18:54] <White_Flame> also, there's plenty of functions that might expect only an object of your given type as a parameter, which wouldn't be included
[00:18:59] <mfiano> This question is ill-specified. It makes me think they assume single-dispatch
[00:22:03] <nij-> Oh indeed mfiano. I should have said: Given a list of objects (list of args), can I list all of its applicable methods?
[00:23:06] <nij-> White_Flame: Yes, if something specializes on T, it should also be included. Hence, the real thing I want is a list of methods from the most specific to the least specific.
[00:23:30] <mfiano> You do realize that methods can dispatch not only on classes but values, right?
[00:23:32] <nij-> IIRC CLOS can compute the list, at least internally. I hope to get access to that list.
[00:23:59] <nij-> mfiano: Err.. perhaps not. (dispatching on values?? @@?)
[00:24:15] <mfiano> So your input specification would need to be altered to be able to distinguish classes from values.
[00:24:59] <White_Flame> and it'd have to literally scan every method in the image
[00:25:01] <mfiano> Yes, Common Lisp has EQL specialization built-in, which dispatches on an EQL-comparable value, in addition to the class name of an instance.
[00:25:18] <White_Flame> you could iterate all packages & symbols within them, looking for those which define methods, and poke into them with implementation-specifics
[00:25:29] <White_Flame> s/define/name/
[00:25:53] <nij-> White_Flame: Ah, so theoretical it's possible. But it's not exported explicitly.
[00:26:16] <nij-> mfiano: oh I do remember EQL specialization. Haven't used it though.
[00:26:35] <lisp123> Would MOP have something for this?
[00:26:38] <lisp123> I'd have to check
[00:26:49] <mfiano> Also good luck with a gensym class/value stored with #1
[00:26:54] <nij-> CLOS must know how to list them internally.
[00:27:04] <nij-> I wish there's an easy way to call the list.
[00:29:16] <lisp123> What does this function do? http://www.crategus.com/books/closer-mop/pages/sb-mop_fun_method-specializers.html
[00:30:51] <lisp123> ignore me
[00:31:03] <nij-> IN: a method. OUT: specializers of that method.
[00:31:08] <nij-> I dunno what specializers are @@
[00:31:49] <lisp123> http://www.crategus.com/books/closer-mop/pages/sb-mop_fun_generic-function-methods.html
[00:31:50] <lisp123> ?
[00:32:20] <lisp123> Ah you are after the methods on an object
[00:32:29] <mfiano> I suggest reading PCL before trying to study Lisp programming language implementation theory or the Common Lisp meta-object protocol.
[00:32:37] <paule32> sorry for idle lisp123 
[00:32:57] <paule32> i would bin the argument/parameter to a global variable
[00:33:35] <paule32> or i do not understand, how to make a instance of a class and bin this instance to a variable within a defmethod
[00:34:11] <mfiano> Using the #1= reader macro
[00:34:19] <nij-> mfiano: By PCL do you mean Practical Common Lisp or Portable impl of the CLOS?
[00:34:24] <mfiano> The former
[00:34:36] *** Quits: jeffrey (~jeffrey@2001:1c00:b1c:4100::ff16) (Quit: Client quit)
[00:34:45] <paule32> mfiano: sbcl
[00:35:07] <mfiano> paule32: This channel is about Common Lisp, not an individual implementation.
[00:35:34] <paule32> mfiano: sbcl isn't clisp compatible ?
[00:36:04] <mfiano> How can two implementations be compatible?
[00:36:16] <mfiano> clisp is not Common Lisp
[00:36:24] <paule32> that is clear
[00:36:44] <nij-> lisp123: Any luck?
[00:36:58] <paule32> some of the old rabbits suggest me to use sbcl instead clisp
[00:37:17] <White_Flame> sb-ext: stuff of course is sbcl-specific
[00:37:52] <lisp123> nij- & White_Flame: So building on White_Flame said, what you could do is first get all the functions in a package / image, then filter those for generic functions then use something like this (but might be another function, I really need to read it more carefully) http://www.crategus.com/books/closer-mop/pages/sb-mop_fun_specializer-direct-methods.html
[00:38:51] <paule32> does sbcl #1= support ?
[00:39:16] <mfiano> Does SBCL implement Common Lisp?
[00:39:53] <paule32> please make it me not to hard
[00:40:04] <mfiano> I can't understand that statement
[00:40:25] <paule32> how would you do this in clisp ?
[00:40:35] <mfiano> What do you mean by clisp?
[00:40:41] <lisp123> paule32: So coming back to my earlier question, the CREATE-GATE-NOT method doesn't use SYM anywhere, so I just wanted to understand its purpose in the parameter list
[00:41:58] <paule32> lisp123: (defparameter *account* (make-instance 'bank-account))
[00:42:24] <paule32> make a instance of class bank-account, and put the pointer to *account*
[00:42:28] <White_Flame> namespaces are fun: (defparameter defparameter (make-instance 'defparameter))
[00:43:03] <paule32> so i was search a way, to do the same, but within a class methode
[00:43:32] <paule32> input is integer
[00:43:34] <lisp123> paule32: Would this work? (defmethod create-gate-not ((input integer)) (setf *sym* (make-instance ...))
[00:43:53] <paule32> yes, this works
[00:44:13] <paule32> but i have to declare the *sym* as global variable, first
[00:44:20] <lisp123> Sure
[00:44:24] <lisp123> (defvar *sym*)
[00:44:32] <paule32> yes
[00:44:43] <White_Flame> why is this a defmethod?  are there other specializations for input other than integer?
[00:44:53] <paule32> but what is, when this variable is not bound, also not known
[00:45:05] <White_Flame> assuming this is a 0/1 valued boolean system
[00:45:07] <paule32> yes, a other gate
[00:45:18] <lisp123> Gotcha
[00:45:55] <paule32> O.o
[00:46:09] <lisp123> So you want to pass in a name like "paule32"
[00:46:20] <lisp123> and create a special variable paule32 with that object bound to it
[00:46:21] <lisp123> right
[00:46:31] <paule32> ehm, yes
[00:46:34] <White_Flame> in main, your (create-gate-not 0) already only uses 1 parameter, so that should indicate to you that SYM was unnecessary
[00:47:10] <paule32> yes, that create thing is for "create" also the first run initialization
[00:47:14] <White_Flame> it's very helpful to write usage like that first to determine what its interface should be
[00:47:37] <paule32> an other similar method i have to implement is "set-gate-not"
[00:48:02] <paule32> sorry
[00:53:38] <lisp123> I'm bit rusty on macros, but try something like this (or somebody will fix it): (defmacro create-gate-note (sym input)  (let ((symbol (intern (symbol-name sym))))  `(defvar ,symbol (make-instance 'gate-note :input-A ,input))))
[00:54:32] <nij-> lisp123:  thanks
[00:54:47] <nij-> --- ;; Are there hygienic macros (like that of Scheme) implemented for CL?
[00:55:01] <rotateq> *sigh*
[00:55:04] *** Parts: rotateq (~user@p200300e787097300818cd04b4ea1a4f3.dip0.t-ipconnect.de) (ERC (IRC client for Emacs 27.2))
[00:55:53] <paule32> lisp123: thank you, i will try
[00:56:03] <paule32> no other way as macro ?
[00:59:22] <lisp123> Probably, but I think this would be the easiest to read. I'm just not sure if there is a portable way to do it without a macro (SBCL & LW seem to have different implementations of DEFVAR for example) - good question though
[01:01:22] <White_Flame> if this question is ultimately about passing a "place" to set a new object into, then yes, you need a macro since a place is a syntactic construct only
[01:01:44] <White_Flame> there is no first-class form of it that you can pass around at runtime
[01:02:03] <White_Flame> (without making your own container for it and passing that, or a getter/setter pair of functions)
[01:02:38] <paule32> i dont plan a new dialect or version of any lisp version
[01:02:40] <lisp123> paule32: So just change the typo on 'note' and the macro will work (tested). 
[01:02:57] <paule32> but, i am a little bit angry about the size of .exe
[01:03:24] <White_Flame> then distribute it as source and call it with sbcl.exe, just like java/python/perl/etc do
[01:03:38] <paule32> yes
[01:03:50] <lisp123> paule32: But whilst I answered the question, I think you should carefully think about the code and do thins in a different / better way
[01:04:07] <paule32> i saw that fasl comes in 2 ways 1x as raw text, and 1x as binary
[01:04:30] <White_Flame> fasl is not distributable.  it's intimately tied to the specific build on your dev box
[01:04:41] <paule32> ok
[01:04:58] <lisp123> its not a very clean idea to be working too much with global variables. Better use local variables and redesign your code a bit
[01:06:06] <paule32> i would hear of you, but i have to learn programming design in lisp others than in different else dsl's
[01:06:30] <lisp123> because once you start working with global variables in this case, you are moving a route of writing code that works on side-effects (modifying the global variables), whereas a more functional style helps alot in avoiding unnecessary state management
[01:06:50] <White_Flame> and avoiding bugs of unintentional writes to global vars deep in the function calls
[01:07:21] <lisp123> paule32: Cool :-) Then carry on. I just didn't want to enable you to do bad habits, but if there's valid reasons you can carry on (keeping what we said in mind)
[01:07:53] <paule32> me it is clear, that global variables are not secure, so i have learn to put variabls into the class that are for, but this is more pascal or c++ code
[01:08:16] *** Parts: nij- (~jin@2001-48F8-9021-806-0-0-0-619B-dynamic.midco.net) (Using Circe, the loveliest of all IRC clients)
[01:09:01] *** Quits: nexeq (~nexeq@user/nexeq) (Ping timeout: 256 seconds)
[01:10:11] <paule32> so you are the same mind, that i should use a temporary class that holds the variables for a session ?
[01:10:17] <paule32> light full
[01:10:24] <paule32> i am dumb
[01:10:30] <paule32> sorry
[01:13:11] <lisp123> don't worry, we are all dumb ;) Without knowing too much of the code (and won't have time to either), hard to tell you exactly the best way.
[01:14:22] <lisp123> I would typically have each function return a fresh object and then have other functions work on those fresh objects
[01:14:33] <White_Flame> there are 2 problems to solve:  1) what classes & datastructures do you need, and 2) which functions should pass &return what data
[01:15:11] <paule32> so, now, i have this: https://dpaste.com/AQ6JXHW5J
[01:15:31] <paule32> of coursem, i can put *huhu* into scoped 
[01:15:41] <paule32> with (let  in main
[01:15:55] <lisp123> paule32: p.s. fix the typo in my macro (it should be 'not' and not 'note')
[01:16:10] <paule32> yes, all clear
[01:16:45] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[01:17:20] <paule32> but now, i have a second problem
[01:17:56] <paule32> when i use my variant, also:  (create-gate-not *huhu* 1)
[01:18:07] <paule32> then it seems the same as:
[01:18:12] <paule32> (create-gate-not 1 *huhu*)
[01:18:27] <paule32> both variants give me no error - also the compiler
[01:20:43] <lisp123> I'm not 100% sure on your error, but I'm assuming you corrected the macro name to create-gate-not right?
[01:21:28] <lisp123> so then when you run (create-gate-not *huhu* 1), it should bind a gate-not to *hulu*, which you can test with (input-A *hulu*) which should return 1
[01:21:42] <lisp123> (create-gate-not 1 *huhu*) SHOULD return you an error now
[01:22:17] <lisp123> which makes me to believe, you didn't rename the macro, so simply the DEFMETHOD is being called in both cases
[01:22:56] <lisp123> In which case, the first parameter of the method is being ignored (as you don't use it), so the first version sets 1 to the slot input1 and the second sets *hulu* to the input1 slot
[01:23:36] *** Parts: artchad (~user@public-gprs233196.centertel.pl) (ERC (IRC client for Emacs 27.2))
[01:23:37] <lisp123> Tbh, I think it might be worthwhile to take a step back and learn some of the basics of Common Lisp (two useful books - A Gentle Introduction to Common Lisp and ANSI Common Lisp)
[01:25:03] <paule32> that is unclear, when i have a methode  m(symbpl-container, integer)
[01:25:31] <paule32> then i would expect, that the dsl lisp expect at first parameter symbols-container
[01:25:43] <paule32> and as second parameter an integer like 1
[01:25:50] <paule32> and not backwards
[01:26:39] <paule32> here: https://dpaste.com/8FBJVSQY6
[01:27:01] <paule32> on line 21, i create a instance of symbols-container
[01:27:27] <paule32> will this instance be an integer, or a object of symbols-container ?
[01:27:35] <lisp123> Line 25 doesn't give you an error?
[01:28:29] <paule32> no
[01:28:43] <paule32> that the obscurum
[01:29:16] <lisp123> I ran it, I get an error
[01:30:16] <lisp123> I have to go, but good luck with it all. 
[01:38:28] <paule32> indeed
[01:38:31] <paule32> here: https://imgur.com/EjECceW
[01:39:16] <paule32> with the compile run, i get no error
[01:43:53] <lisp123> paule32: Ahhh :) Now I remember you, our friend using Notepad for Lisp xD
[01:44:08] <lisp123> You really need to move onto Emacs :P
[01:45:34] <paule32> the editor is not the problem
[01:46:02] <paule32> ah okay
[01:46:05] <paule32> the syntax
[01:46:09] <paule32> sorry
[01:46:34] <lisp123> Well it kinda is, because you don't see helpful messages like the fact that there is no method for *huhu* not being an integer
[01:53:01] *** Quits: shka (~herr@109.231.0.226) (Ping timeout: 240 seconds)
[01:53:30] <paule32> https://dpaste.com/5FKVUGFTK
[01:53:40] <paule32> okay, i will let clisp a try ...
[01:54:14] *** Joins: nexeq (~nexeq@user/nexeq)
[01:55:03] <lisp123> paule32: Hurray :)
[01:57:56] <paule32> hui, latest from 2010
[01:58:35] <lisp123> As long as it works, its good - Lisp is a very stable language
[02:00:23] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[02:32:35] *** Quits: White_Flame (~quassel@user/white-flame/x-6930243) (Remote host closed the connection)
[02:33:49] *** Joins: White_Flame (~quassel@user/white-flame/x-6930243)
[03:00:51] *** Joins: lisp123 (~lisp123@5.30.23.247)
[03:05:45] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[03:14:02] <paule32> hui
[03:14:06] <paule32> what a mess
[03:14:23] <paule32> i download source, try to compile, because i could not found clisp.exe
[03:14:31] <paule32> and now, i found a installer
[03:14:57] <paule32> and, the error occurs, yes, indeed, and it worked with right parameters
[03:20:09] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[03:58:13] *** Quits: random-nick (~random-ni@87.116.167.125) (Ping timeout: 240 seconds)
[04:55:49] *** Quits: beach (~user@lfbn-bor-1-466-226.w86-213.abo.wanadoo.fr) (Ping timeout: 240 seconds)
[05:19:37] *** Quits: pjb (~pjb@user/pjb) (Ping timeout: 240 seconds)
[05:28:20] <paule32> hello, how can i print the value of input-A ?
[05:28:22] <paule32> https://dpaste.com/4L3ZV5FUK
[06:10:54] *** Joins: Jing (~hedgehog@2604:a840:3::103c)
[06:29:49] <paule32> ok
[06:29:56] <paule32> i think i get it
[06:29:57] <paule32> https://dpaste.com/9SMZBFUFY
[06:30:14] <paule32> left side seems be the target or destination
[06:30:24] <paule32> right side the source
[06:30:41] <paule32> so the form give me:  dst/src
[06:30:52] <paule32> clever lispers
[06:30:57] <paule32> my respect
[06:38:23] *** Quits: sts-q (~sts-q@212.53.219.148) (Ping timeout: 256 seconds)
[06:52:29] *** Joins: sts-q (~sts-q@91.200.108.143)
[06:53:15] <paule32> what is better in use:  (input number)  or  (input integer) ?
[06:53:33] <paule32> (defmethod create-gate-not ((input integer))
[06:53:36] <paule32> pr
[06:53:38] <paule32> or
[06:53:46] <paule32> (defmethod create-gate-not ((input number))
[06:54:15] <White_Flame> it is a discriminator/test.  what is appropriate depends on what other values might be handled by other methods under the same name
[06:56:28] <paule32> ok
[07:09:59] *** Joins: pjb (~pjb@user/pjb)
[07:12:14] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Quit: ec)
[07:12:35] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[07:15:23] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Client Quit)
[07:15:35] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[07:29:49] *** Joins: beach (~user@2a01:cb19:150:3400:928b:3395:fe81:c0b2)
[07:30:14] <beach> Good morning everyone! 
[07:56:17] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 240 seconds)
[07:58:27] *** Joins: aeth (~aeth@user/aeth)
[08:07:12] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[08:14:54] <beach> I had to reboot so I missed a conversation.  Who asked about "all methods applicable to a certain object"?
[08:16:54] <beach> http://metamodular.com/CLOS-MOP/specializer-direct-methods.html might be the answer.
[08:29:55] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[08:52:05] *** Quits: Jing (~hedgehog@2604:a840:3::103c) (Remote host closed the connection)
[08:52:41] *** Joins: Jing (~hedgehog@115.207.57.60)
[09:26:44] *** Joins: lisp123 (~lisp123@5.30.23.247)
[09:31:01] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 240 seconds)
[09:42:06] <pjb> beach: it was nij- <21:52:03><nij-> Oh indeed mfiano. I should have said: Given a list of objects (list of args), can I list all of its applicable methods?
[09:57:25] <beach> Thanks!
[09:58:54] <beach> That's a bit different from what I suggested, and it's a bit strange, because the question suggests that a list of all methods, no matter to which generic functions they belong, should be returned.
[10:04:52] <pjb> Indeed.  We can scan all the (interned) symbols, see which ones are fbound, to a generic function, and search the corresponding methods.
[10:05:37] <beach> Yes, with names like (SETF <symbol>) as well.  I have done things like that in SICL bootstrapping.
[10:06:23] <beach> But then, some standard functions can be generic, so the result would depend on the implementation. 
[10:06:52] <beach> And you would get a lot of default method that "specialize" only to T.
[10:07:16] <beach> I can't see how such a list would be useful.
[10:13:58] <beach> Since we are at it, the AMOP book uses the preposition "to" for specialization, so I suggest using "on" for a method associated with a generic function, like "this is a method on the generic function FOO, that specialized to the classes BAR and BAZ"
[10:14:36] <beach> At first I thought that the choice of "to" was a result of the AMOP being written by non-native English speakers, but I was wrong about that.
[10:19:34] <paule32> hello beach
[10:19:43] <paule32> happy new year backward
[10:20:01] <beach> Thanks.  You too.
[10:23:29] <paule32> is it possible to make-instance at :initform in a class ?
[10:23:31] <paule32> https://dpaste.com/26YHDUWMG
[10:23:56] <paule32> line 27
[10:24:57] <beach> Please indent your code properly.
[10:25:20] <beach> If you want to expose your code, make sure you use conventions for code layout.
[10:25:52] <beach> ((make-instance ...) (...)) is not a valid form. 
[10:26:27] <beach> A compound form must have either a symbol or a lambda expression in its CAR.
[10:33:14] *** Joins: st_iron (uid370243@id-370243.uxbridge.irccloud.com)
[10:33:23] <st_iron> good morning
[10:33:27] <paule32> hi
[10:33:44] <beach> Hello st_iron.
[10:34:02] <paule32> compound form ?  you mean (let (... ?
[10:34:18] <beach> Look in the glossary.  It is defined there.
[10:35:16] <beach> compound form n. a non-empty list which is a form: a special form, a lambda form, a macro form, or a function form. 
[10:35:30] *** Joins: shka (~herr@109.231.0.226)
[10:35:41] <beach> You can then look up those terms as well.
[10:36:16] <beach> Then you will see that no valid form can start with (make-instance...) the way yours does.
[10:37:29] <paule32> thanks for the hint
[10:39:58] <paule32> i found two variants:
[10:40:00] <paule32> fboundp
[10:40:06] <paule32> and: boundp 
[10:47:38] <paule32> :initform	(function (lambda (x) (let (x (make-instance 'component))))))))
[10:47:49] <paule32> this bring me no error
[10:48:03] <paule32> but i dont sure if that the correct way
[10:52:58] <beach> I am sorry, but I can't do this.  It makes me very upset to see you in action, and getting upset is not good for my blood pressure. 
[10:59:03] <paule32> https://dpaste.com/9NC99VLCS
[10:59:22] <paule32> this is the result when i use two lambdas
[10:59:27] <paule32> one is okay
[11:01:32] <paule32> https://dpaste.com/686G7TUWT
[11:01:36] <paule32> line 28, and 29
[11:04:23] <paule32> https://dpaste.com/EAGCN7HL7
[11:04:29] <paule32> ^this will be okay
[11:25:00] *** Quits: nexeq (~nexeq@user/nexeq) (Remote host closed the connection)
[11:26:41] *** Joins: nexeq (~nexeq@user/nexeq)
[11:28:08] *** Joins: lisp123 (~lisp123@5.30.23.247)
[11:33:03] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[11:34:26] *** Joins: lisp123 (~lisp123@5.30.23.247)
[11:39:01] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 240 seconds)
[12:13:44] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[12:14:45] *** Quits: Jing (~hedgehog@115.207.57.60) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[12:45:15] *** Joins: lisp123 (~lisp123@5.30.23.247)
[12:49:22] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[12:49:34] *** Joins: lisp123 (~lisp123@5.30.23.247)
[12:54:47] <lisp123> Thinking of making good use of Standard Generic Function CHANGE-CLASS
[12:54:55] <lisp123> Any reason not to?
[12:56:00] <lisp123> for example I could have a (defclass word () ((word :initarg :word :accessor word))) and then (defclass english-word (word) ()) and (defclass spanish-word (word) ()), so if I want to recategorise a WORD to ENGLISH-WORD, simply change its class
[12:57:06] <mfiano> Side note: I would not name your slot the same as any accessors.
[12:58:27] <lisp123> mfiano: For now, I'm good. But I'm sure in 6 months I'll have that Eureka moment and agree with you :-)
[12:58:33] <mfiano> Because unlike most languages, in Common Lisp we do not export definitions, but symbols instead.
[12:58:53] <mfiano> It's not really hard to understand. Slots are always meant to be private.
[12:59:01] <mfiano> They are implementation details.
[13:04:25] <lisp123> Having slots and accessor as the same name doesn't preclude slots being private / implementation details. Yes, doing something like %word may be more clear to read to those starting off, but it also adds a bit of noise to the naming. Both ways are fine, its a stylistic preference
[13:05:45] <mfiano> It's not strictly a stylistic preference. It is about your protocol.
[13:05:56] <mfiano> beach may be able to help explain better.
[13:06:12] <lisp123> I understand the reasons fine :-)
[13:06:22] <mfiano> Then you should convey that in your argument.
[13:08:02] <lisp123> This discussion was had on #lisp yesterday, IIRC you noted it then too (sorry if I'm mistaken), so its already been discussed enough for this week
[13:08:54] <mfiano> It is never enough if people are doing it wrong.
[13:09:17] <mfiano> beach and I agreed that it should be continued to be brought up until it is common knowledge.
[13:09:33] <mfiano> This is very important and can't be stressed enough.
[13:12:19] <lisp123> Okay, I'll do %word. I guess if everyone does it it will reduce some confusion around slots vs. accessors
[13:15:45] <mfiano> If everyone did it, we wouldn't be so persistent. Leaky implementations are a sign of bad architecture.
[13:37:23] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[13:50:00] *** Joins: rain3 (~rain3___@2a02:2f09:d003:cb00:928d:3338:a339:f956)
[13:50:38] *** Joins: Jing (~hedgehog@2604:a840:3::103c)
[13:53:59] *** Joins: lisp123 (~lisp123@5.30.23.247)
[13:58:17] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 240 seconds)
[14:02:15] *** Joins: rotateq (~user@p200300e787097300818cd04b4ea1a4f3.dip0.t-ipconnect.de)
[14:46:02] <paule32> lisp123 ?
[14:46:27] <paule32> https://dpaste.com/GXF6RKAAZ
[14:46:47] <paule32> in line 29: can i make a second lambda function ?
[14:46:57] <paule32> to make two instances of a class
[14:53:40] *** Quits: shka (~herr@109.231.0.226) (Quit: Konversation terminated!)
[14:53:50] <rotateq> do you always layout your code that way?
[14:54:02] <rotateq> and the paste site thinks it's clojure :D
[14:56:41] <rotateq> and no i don't think with just line 29 it will be accepted by the DEFCLASS macro, or do i miss something out?
[14:56:53] <rotateq> ahhh wait
[14:56:57] <rotateq> sry ^^
[14:57:52] <rotateq> you could make :initform (list #'(lambda (x) ...) #'(lambda (x) ...))
[14:58:41] <rotateq> first I thought (by layout!) that the "function" is another slot for the class
[15:02:16] <paule32> hello rotateq 
[15:02:38] <paule32> defclass is a macro ? i think no
[15:02:53] <rotateq> hi paule32, wish you a new year too :) (as you did yesterday evening here for us)
[15:03:01] <rotateq> paule32: ehm yes?
[15:03:12] <rotateq> :D :D :D
[15:03:20] <paule32> no problem
[15:03:29] <paule32> no women, no cry :-)
[15:03:46] <rotateq> what did you thought?
[15:03:59] <paule32> hehe, self speaking :)
[15:04:30] <rotateq> Schon ok, aber ein wenig zum Schmunzeln hat es mich grad schon gebracht. ;)
[15:04:50] <paule32> yes, me and my english, very bad
[15:04:59] <rotateq> hihi
[15:05:33] <rotateq> but surely DEFCLASS is a macro, as DEFUN, DEFMETHOD, PUSH, POP, DEFGENERIC, DEFPARAMETER, ...
[15:05:34] *** Joins: random-nick (~random-ni@87.116.167.125)
[15:06:14] <paule32> you are the checker
[15:06:17] <paule32> :)
[15:06:51] *** Joins: Maija (~Maija@p5b00bf91.dip0.t-ipconnect.de)
[15:08:30] <rotateq> how do you mean?
[15:09:23] <paule32> the have strong knowledge of lisp
[15:09:24] <rotateq> and if your class name is already FOO it's not intended to give all slot names the prefix foo, but maybe their accessors
[15:09:33] <rotateq> ehm me? no
[15:09:38] <paule32> hehe
[15:10:18] <rotateq> and when you write (lambda (x) ...) it macroexpands to the function form
[15:10:38] <rotateq> but for intention using the #' i would say is better :)
[15:12:08] <paule32> ok
[15:12:38] <rotateq> paule32: oh interesting
[15:12:58] <rotateq> when i load the code into emacs it's better indented, so sorry
[15:13:06] <rotateq> weird paste board
[15:13:17] *** Joins: cranium (~cranium@user/cranium)
[15:13:35] <paule32> https://dpaste.com/5XKG2UT5K
[15:13:43] <paule32> this is redundant code
[15:13:47] *** Parts: Maija (~Maija@p5b00bf91.dip0.t-ipconnect.de) ()
[15:14:13] <rotateq> yes, what do you want with those lambdas?
[15:15:03] <paule32> a not-gate hss one input, and an and-gate have two inputs
[15:15:28] <paule32> so, it could be possible, that a component can hav more thae one
[15:15:34] <paule32> i think
[15:15:37] <rotateq> hmm
[15:16:07] <paule32> this is ugly code, but something simpler as doing loops
[15:16:23] <rotateq> ah, beside, when you take the class comments and store them into the :documentation option they're not gone after read time
[15:16:41] <rotateq> hmm
[15:17:33] <paule32> :documention is embeed lisp, to describe the defun or methode when it is pretty printed ?
[15:18:16] <rotateq> no it's an option for the class and also every slot to have it available after read time
[15:18:20] <paule32> because lisp eliminates comments starting with ; till end of line
[15:18:28] <rotateq> yes exactly
[15:20:54] <rotateq> clhs defclass
[15:20:58] <rotateq> ah okay :D
[15:21:08] <paule32> the next question could be: how do i come back to component-gate
[15:21:22] <paule32> by using 'component
[15:21:50] <rotateq> how do you mean exactly?
[15:21:52] <paule32> or must code provided for all forms of possibles
[15:22:08] <paule32> i have a superclass component
[15:22:33] <paule32> this can be a gate, a wire, a batterie port
[15:22:44] <paule32> in deeper level
[15:22:50] <rotateq> you mean redefining the class of an object?
[15:23:02] <paule32> ehm no, inherited
[15:23:25] <rotateq> that goes for classes
[15:23:32] <paule32> yes
[15:23:45] <paule32> see my paste: (defclass
[15:24:06] <rotateq> if it's like in your code every object of class component-gate will have also superclass component
[15:24:38] <paule32> yes, in Delphi OOP it was the mother of all classes:  TObject
[15:24:49] <paule32> TObject was/is a class
[15:24:51] <rotateq> but we're not in such OOP model :)
[15:25:17] <paule32> it contains a Component Array, to access them by name, ref, id ...
[15:26:06] <paule32> so, all component classes , when they reach to top (superclass) save the information
[15:26:08] <rotateq> hmm
[15:26:43] <paule32> you can then cast the superclass to the component class
[15:26:53] <paule32> and use the properties (slots)
[15:27:36] <paule32> like GNU Software principle: left the target, and right the source
[15:28:08] <paule32> or in other words, a operation like the addition of two numbers begin from top to bottom
[15:28:59] <rotateq> you mean that it looks which class for each number is most appropriate?
[15:29:20] <paule32> (+ 2 3)  ;;; = 5  first, the interpreter catch the 2, then the 3 as right side, and the (+ is a function, also the result, and this is the destination, also left side
[15:29:36] <paule32> yes
[15:30:11] <rotateq> yes the MOP does something similar
[15:30:47] <paule32> meta ? this simple lisp (ok a little harder as we can think at first glance
[15:30:49] <rotateq> how do you mean + is the result?
[15:31:11] <rotateq> yes sure, CLOS comes with the metaobjectprotocol
[15:31:14] <paule32> the + is a "operation" function, so the left side is defined
[15:31:37] <rotateq> OK
[15:31:54] <paule32> and each object in lisp commonly consist of 2 forms
[15:32:24] <rotateq> and what are those two forms in your point of view?
[15:33:00] <paule32> you can see it so: the computer gattering informations from right to left
[15:33:18] <paule32> 12345  also first, the computer get 5, then 4, 3, 2, 1
[15:33:44] <paule32> and then, when a operation is found (like (+
[15:33:59] <rotateq> ah you mean on asembly stack level :D
[15:34:11] <rotateq> now it makes more sense to me
[15:34:16] <paule32> yes, the computer read in the + and get the pushed values
[15:34:41] <paule32> as i can see, lisp ise pn
[15:34:47] <paule32> polish notation
[15:34:49] <rotateq> and you now learned that PUSH is also a macro :P
[15:34:57] <rotateq> yes sure
[15:35:10] <paule32> ehm. a low level operation
[15:35:20] <rotateq> yes PUSH is low level
[15:35:54] <paule32> you can push numbers, strings (but only pointers, that are "saved" into the stack at the memory position
[15:36:02] <rotateq> and when i do (reduce #'+ '(1 2 3 4 5)) instead of (+ 1 2 3 4 5) it also acts likewise the assembly model
[15:36:16] <rotateq> okay but we're now not on this level
[15:36:33] <paule32> this form would bring error
[15:37:01] <rotateq> really?
[15:37:04] <paule32> a operation simpliefied that you have only 2 forms like (+ 2 3)
[15:37:18] <paule32> you can then extend it
[15:37:20] <rotateq> jeez
[15:37:36] <paule32> (* 2 (+ 2 3))  ; would give you 10
[15:37:46] <rotateq> okay and?
[15:38:28] <paule32> left side (* 2  (the sub left side (* and 2, and the right result of right sub 
[15:38:53] <rotateq> i still wait what you're trying to say :)
[15:39:57] <paule32> you can see it so: the interpreter calculates the 2+3 as form (+ 2 3)  then you get a one form (result) = 3  then the next step is (* also the multiplication of 2
[15:40:04] <paule32> step by step
[15:40:32] <paule32> in this state it would be see, as you write: (* 2 5)
[15:40:56] <paule32> where 5 is the calculated result before
[15:41:05] <rotateq> yes I know
[15:41:13] <rotateq> but WHY do you meantion this now?
[15:41:43] <paule32> woops. verannt overdrived : )
[15:42:16] <paule32> we lost the red line
[15:42:22] <rotateq> yes, a bit ;)
[15:42:51] <rotateq> so did you get the similarity with REDUCE ?
[15:43:09] <paule32> what i can do, is, to create an array, that holds all classes with superclass component
[15:43:20] <paule32> hehe
[15:43:23] <paule32> yes i see
[15:43:36] <rotateq> ich wollt grad schon in die tischkante beissen :D
[15:43:43] <paule32> lisp is abstracter as other dsl's
[15:44:08] <paule32> i thinking to high
[15:44:11] <paule32> sorry
[15:44:17] <rotateq> no too low :)
[15:44:33] <paule32> yeah, my english is bad
[15:44:34] <rotateq> but lisp is none of those, it's what is built from it
[15:44:41] <rotateq> no problem, mine too
[15:46:07] <rotateq> you define a binary-operator that can also be specialized as a method and then you can put that with a sequence into an expression with REDUCE
[15:46:15] <paule32> also, i push the instances of sub classes to superclass array (also the pointers) and then i can use this array as universal container, as master super dupppa class computers :)
[15:48:13] <rotateq> but the MOP covers tracking your made instances for a class
[15:48:31] <rotateq> so when you redefine something all are updated automatically
[15:49:00] <paule32> yes, because you only save pointers to data
[15:49:11] <rotateq> sure, in the backstage
[15:49:30] <rotateq> but ok, with CFFI you can also handle pointer stuff and all
[15:49:54] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[15:56:01] *** Joins: lisp123 (~lisp123@5.30.23.247)
[15:56:59] *** Quits: nexeq (~nexeq@user/nexeq) (Ping timeout: 256 seconds)
[15:57:30] *** Joins: nexeq (~nexeq@user/nexeq)
[16:00:31] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[16:24:47] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 250 seconds)
[16:49:16] *** Quits: nexeq (~nexeq@user/nexeq) (Remote host closed the connection)
[16:49:32] *** Joins: nexeq (~nexeq@user/nexeq)
[16:52:13] *** Joins: lisp123 (~lisp123@5.30.23.247)
[17:20:09] *** Joins: abrantesasf (~abrantesa@187.36.170.211)
[17:21:20] *** Quits: nexeq (~nexeq@user/nexeq) (Remote host closed the connection)
[17:21:37] *** Joins: nexeq (~nexeq@user/nexeq)
[17:23:01] *** Quits: st_iron (uid370243@id-370243.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[17:37:36] *** Quits: abrantesasf (~abrantesa@187.36.170.211) (Read error: Connection reset by peer)
[17:40:27] *** Joins: abrantesasf (~abrantesa@187.36.170.211)
[17:46:31] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[17:54:37] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[18:04:39] *** Quits: rain3 (~rain3___@2a02:2f09:d003:cb00:928d:3338:a339:f956) (Ping timeout: 268 seconds)
[19:00:14] *** Quits: random-nick (~random-ni@87.116.167.125) (*.net *.split)
[19:00:14] *** Quits: rotateq (~user@p200300e787097300818cd04b4ea1a4f3.dip0.t-ipconnect.de) (*.net *.split)
[19:00:14] *** Quits: sts-q (~sts-q@91.200.108.143) (*.net *.split)
[19:00:15] *** Quits: CodeBitCookie[m] (~code-bit-@2001:470:69fc:105::a2f) (*.net *.split)
[19:00:15] *** Quits: sepanko (~sepanko@user/sepanko) (*.net *.split)
[19:00:15] *** Quits: vegai (vegai@kapsi.fi) (*.net *.split)
[19:00:15] *** Quits: mala (~mala@user/malaclyps) (*.net *.split)
[19:00:16] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (*.net *.split)
[19:00:16] *** Quits: mns (~mns@c-73-119-178-157.hsd1.ma.comcast.net) (*.net *.split)
[19:00:16] *** Quits: mfiano (~mfiano@li1282-157.members.linode.com) (*.net *.split)
[19:00:17] *** Quits: minion (~minion@common-lisp.net) (*.net *.split)
[19:00:17] *** Quits: gko (~user@user/gko) (*.net *.split)
[19:00:18] *** Quits: commandoline (~commandol@ubuntu/member/commandoline) (*.net *.split)
[19:00:19] *** Quits: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de) (*.net *.split)
[19:00:19] *** Quits: Kabriel (~Kabriel@user/kabriel) (*.net *.split)
[19:00:19] *** Quits: dbotton (sid492350@id-492350.lymington.irccloud.com) (*.net *.split)
[19:00:19] *** Quits: Riviera (Riviera@user/riviera) (*.net *.split)
[19:00:20] *** Quits: bldr (~bull@185.117.72.168) (*.net *.split)
[19:00:20] *** Quits: rdrg109 (~rdrg109@user/rdrg109) (*.net *.split)
[19:00:20] *** Quits: Gnuxie (~gnuxie@user/gnuxie) (*.net *.split)
[19:00:21] *** Quits: empwilli (~empwilli@faui48e.informatik.uni-erlangen.de) (*.net *.split)
[19:00:21] *** Quits: MetaYan (~MetaYan@c-7b5d235c.07-84-7462671.bbcust.telenor.se) (*.net *.split)
[19:00:21] *** Quits: epony (epony@user/epony) (*.net *.split)
[19:00:21] *** Quits: antoszka-r (~antoni@rozalia.antoszka.pl) (*.net *.split)
[19:00:21] *** Quits: GreaseMonkey (greaser@user/greasemonkey) (*.net *.split)
[19:00:21] *** Quits: pedro-delfino (sid507296@id-507296.helmsley.irccloud.com) (*.net *.split)
[19:00:21] *** Quits: copec (~copec@schrodbox.unaen.org) (*.net *.split)
[19:00:21] *** Quits: drakonis (drakonis@user/drakonis) (*.net *.split)
[19:00:22] *** Quits: emacsomancer (~emacsoman@136.60.128.68) (*.net *.split)
[19:00:23] *** Quits: sgithens (sid10659@id-10659.helmsley.irccloud.com) (*.net *.split)
[19:00:23] *** Quits: Schnouki (e7aa4cfb39@user/schnouki) (*.net *.split)
[19:00:23] *** Quits: phoe (~phoe@user/phoe) (*.net *.split)
[19:00:23] *** Quits: jfb4 (~jfb4@178.62.2.68) (*.net *.split)
[19:00:24] *** Quits: Duuqnd (~duuqnd@2001:470:69fc:105::e9c0) (*.net *.split)
[19:00:24] *** Quits: anddam (~anddam@user/anddam) (*.net *.split)
[19:00:24] *** Quits: selwyn (~selwyn@user/selwyn) (*.net *.split)
[19:00:26] *** Quits: fiddlerwoaroof (~fiddlerwo@user/fiddlerwoaroof) (*.net *.split)
[19:00:26] *** Quits: madnificent (~madnifice@static.210.74.63.178.clients.your-server.de) (*.net *.split)
[19:00:27] *** Quits: nimiux_ (~nimiux@freeshell.de) (*.net *.split)
[19:00:27] *** Quits: bremner (~bremner@notmuch/developer/bremner) (*.net *.split)
[19:00:27] *** Quits: Partmedia (~kevinz@097-086-181-165.res.spectrum.com) (*.net *.split)
[19:00:28] *** Quits: plexi (~orcabot@digital.sanctuary.org) (*.net *.split)
[19:00:28] *** Quits: conjunctive (sid433686@id-433686.helmsley.irccloud.com) (*.net *.split)
[19:00:28] *** Quits: lonjil (~quassel@user/lonjil) (*.net *.split)
[19:00:28] *** Quits: ChanServ (ChanServ@services.libera.chat) (*.net *.split)
[19:01:12] *** Joins: ChanServ (ChanServ@services.libera.chat)
[19:01:12] *** Joins: random-nick (~random-ni@87.116.167.125)
[19:01:12] *** Joins: rotateq (~user@p200300e787097300818cd04b4ea1a4f3.dip0.t-ipconnect.de)
[19:01:12] *** Joins: sts-q (~sts-q@91.200.108.143)
[19:01:12] *** molybdenum.libera.chat sets mode: +o ChanServ
[19:01:39] *** Joins: rain3 (~rain3___@86.127.204.59)
[19:01:56] *** Joins: sgithens (sid10659@id-10659.helmsley.irccloud.com)
[19:01:56] *** Joins: Schnouki (e7aa4cfb39@user/schnouki)
[19:01:56] *** Joins: phoe (~phoe@user/phoe)
[19:01:56] *** Joins: jfb4 (~jfb4@178.62.2.68)
[19:02:02] *** Joins: bldr (~bull@185.117.72.168)
[19:02:02] *** Joins: rdrg109 (~rdrg109@user/rdrg109)
[19:02:07] *** Joins: drakonis (drakonis@user/drakonis)
[19:02:07] *** Joins: Gnuxie (~gnuxie@user/gnuxie)
[19:02:07] *** Joins: empwilli (~empwilli@faui48e.informatik.uni-erlangen.de)
[19:02:07] *** Joins: MetaYan (~MetaYan@c-7b5d235c.07-84-7462671.bbcust.telenor.se)
[19:02:07] *** Joins: epony (epony@user/epony)
[19:02:07] *** Joins: antoszka-r (~antoni@rozalia.antoszka.pl)
[19:02:07] *** Joins: GreaseMonkey (greaser@user/greasemonkey)
[19:02:07] *** Joins: pedro-delfino (sid507296@id-507296.helmsley.irccloud.com)
[19:02:07] *** Joins: copec (~copec@schrodbox.unaen.org)
[19:02:07] *** Joins: emacsomancer (~emacsoman@136.60.128.68)
[19:02:13] *** Joins: Duuqnd (~duuqnd@2001:470:69fc:105::e9c0)
[19:02:13] *** Joins: anddam (~anddam@user/anddam)
[19:02:13] *** Joins: selwyn (~selwyn@user/selwyn)
[19:02:13] *** Joins: fiddlerwoaroof (~fiddlerwo@user/fiddlerwoaroof)
[19:02:13] *** Joins: madnificent (~madnifice@static.210.74.63.178.clients.your-server.de)
[19:02:19] *** Joins: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de)
[19:02:19] *** Joins: Kabriel (~Kabriel@user/kabriel)
[19:02:19] *** Joins: dbotton (sid492350@id-492350.lymington.irccloud.com)
[19:02:19] *** Joins: Riviera (Riviera@user/riviera)
[19:02:25] *** Joins: CodeBitCookie[m] (~code-bit-@2001:470:69fc:105::a2f)
[19:02:25] *** Joins: sepanko (~sepanko@user/sepanko)
[19:02:25] *** Joins: vegai (vegai@kapsi.fi)
[19:02:25] *** Joins: mala (~mala@user/malaclyps)
[19:02:48] *** Joins: gko (~user@user/gko)
[19:02:48] *** Joins: commandoline (~commandol@ubuntu/member/commandoline)
[19:03:03] *** Joins: nimiux_ (~nimiux@freeshell.de)
[19:03:03] *** Joins: bremner (~bremner@notmuch/developer/bremner)
[19:03:03] *** Joins: Partmedia (~kevinz@097-086-181-165.res.spectrum.com)
[19:03:03] *** Joins: plexi (~orcabot@digital.sanctuary.org)
[19:03:03] *** Joins: conjunctive (sid433686@id-433686.helmsley.irccloud.com)
[19:03:03] *** Joins: lonjil (~quassel@user/lonjil)
[19:03:07] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[19:03:07] *** Joins: mns (~mns@c-73-119-178-157.hsd1.ma.comcast.net)
[19:03:07] *** Joins: mfiano (~mfiano@li1282-157.members.linode.com)
[19:03:07] *** Joins: minion (~minion@common-lisp.net)
[19:03:32] *** Quits: Gnuxie (~gnuxie@user/gnuxie) (Ping timeout: 240 seconds)
[19:03:38] *** Quits: CodeBitCookie[m] (~code-bit-@2001:470:69fc:105::a2f) (Ping timeout: 252 seconds)
[19:03:38] *** Quits: sepanko (~sepanko@user/sepanko) (Ping timeout: 252 seconds)
[19:03:52] *** Quits: Duuqnd (~duuqnd@2001:470:69fc:105::e9c0) (Ping timeout: 268 seconds)
[19:23:42] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[19:47:40] *** Joins: Duuqnd (~duuqnd@2001:470:69fc:105::e9c0)
[19:57:32] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Quit: ec)
[20:04:00] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[20:20:36] *** Joins: Gnuxie (~gnuxie@user/gnuxie)
[20:22:59] *** Joins: sepanko (~sepanko@user/sepanko)
[20:23:00] *** Joins: CodeBitCookie[m] (~code-bit-@2001:470:69fc:105::a2f)
[20:31:57] *** Joins: lisp123 (~lisp123@5.30.23.247)
[20:34:20] *** Quits: Jing (~hedgehog@2604:a840:3::103c) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[20:34:44] *** Quits: cranium (~cranium@user/cranium) (Quit: Leaving)
[20:36:21] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[20:57:11] *** Joins: lisp123 (~lisp123@5.30.23.247)
[21:18:49] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[21:22:25] *** Joins: Oladon (~olad@98.43.81.226)
[21:30:22] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Quit: ec)
[21:30:45] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[22:47:59] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[22:57:42] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[23:05:49] *** Quits: rain3 (~rain3___@86.127.204.59) (Ping timeout: 240 seconds)
[23:33:19] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[23:37:14] *** Joins: lisp123 (~lisp123@5.30.23.247)
[23:42:13] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[23:49:58] *** Joins: aeth_ (~aeth@user/aeth)
[23:50:14] *** Quits: aeth (~aeth@user/aeth) (Killed (NickServ (GHOST command used by aeth_)))
[23:50:19] *** aeth_ is now known as aeth
