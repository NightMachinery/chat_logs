[00:01:08] *** Quits: pulseaudio (~pulseaudi@103.42.175.103) (Ping timeout: 250 seconds)
[00:01:16] *** Joins: mad_enz (~mad_enz@lnsm4-toronto12-50-101-118-206.internet.virginmobile.ca)
[00:10:55] *** Joins: pulseaudio (~pulseaudi@103.42.175.103)
[00:12:35] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Ping timeout: 240 seconds)
[00:16:02] *** Joins: Guest5 (~Guest@37.19.197.136)
[00:16:13] *** Quits: Guest5 (~Guest@37.19.197.136) (Client Quit)
[00:19:46] *** Quits: tseug (~Guest@pool-98-116-182-177.nycmny.fios.verizon.net) (Ping timeout: 250 seconds)
[00:20:24] *** Joins: zer0bitz_ (~zer0bitz@2001:2003:f750:a200:f9d1:c665:a064:ac5a)
[00:21:51] *** Quits: zer0bitz (~zer0bitz@2001:2003:f750:a200:d960:d98a:f624:8ef) (Ping timeout: 256 seconds)
[00:22:13] *** Joins: Tseug (~Tseug@37.19.197.136)
[00:22:38] *** Quits: machinedgod (~machinedg@24.105.81.50) (Ping timeout: 272 seconds)
[00:25:05] *** Joins: gproto23 (~gproto23@user/gproto23)
[00:29:18] *** Joins: machinedgod (~machinedg@24.105.81.50)
[00:34:44] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[00:45:52] *** Quits: zer0bitz_ (~zer0bitz@2001:2003:f750:a200:f9d1:c665:a064:ac5a) (Ping timeout: 260 seconds)
[00:46:32] *** Joins: Lord_of_Life_ (~Lord@user/lord-of-life/x-2819915)
[00:47:35] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 256 seconds)
[00:49:19] *** Lord_of_Life_ is now known as Lord_of_Life
[01:01:09] *** Quits: pulseaudio (~pulseaudi@103.42.175.103) (Remote host closed the connection)
[01:25:58] *** Quits: gabriel1_ (~gabriel1@2a01:cb19:8c9a:8200:2bec:35e2:397b:2e98) (Remote host closed the connection)
[01:31:00] *** Quits: Pythayr (~pither195@vps-1494dc6f.vps.ovh.us) (Ping timeout: 240 seconds)
[01:31:10] *** Joins: Pythayr (~pither195@072-238-180-064.res.spectrum.com)
[01:36:41] *** Quits: Pythayr (~pither195@072-238-180-064.res.spectrum.com) (Ping timeout: 246 seconds)
[01:36:57] *** Joins: Pythayr (~pither195@vps-1494dc6f.vps.ovh.us)
[01:50:19] *** Quits: sobkas (~sobkas@95.175.17.217) (Quit: sobkas)
[01:51:16] *** Joins: sobkas (~sobkas@95.175.17.217)
[01:53:00] *** Quits: geeknix (~pi@2001:e68:5432:716a:e867:9342:8ac3:7cf7) (Ping timeout: 240 seconds)
[01:57:04] *** Quits: ioxzev1z (~ioxzev1z@user/ioxzev1z) (Quit: Leaving)
[01:57:26] *** Joins: auk (auk@gateway/vpn/protonvpn/auk)
[02:04:48] *** Quits: gproto23 (~gproto23@user/gproto23) (Remote host closed the connection)
[02:09:38] *** Joins: geeknix (~pi@2001:e68:5432:518e:7d14:5ca5:9ed8:f278)
[02:13:02] *** Quits: Guyver2 (Guyver@guyver2.xs4all.nl) (Quit: Going offline, see ya! (www.adiirc.com))
[02:18:08] *** Joins: Insphere[m] (~inspherei@2001:470:69fc:105::1:eeeb)
[02:20:31] *** Parts: Insphere[m] (~inspherei@2001:470:69fc:105::1:eeeb) ()
[02:22:20] *** Quits: xx (~xx@user/xx) (Ping timeout: 272 seconds)
[02:31:17] *** Quits: noonien (~noonien@user/noonien) (Ping timeout: 256 seconds)
[02:45:46] *** Joins: varayu (~varayu@157.37.201.188)
[02:49:11] *** Quits: sobkas (~sobkas@95.175.17.217) (Read error: Connection reset by peer)
[02:49:58] *** Joins: sobkas (~sobkas@95.175.17.217)
[02:54:32] *** Joins: varayu4 (~varayu@157.37.201.188)
[02:54:38] *** Quits: varayu (~varayu@157.37.201.188) (Ping timeout: 272 seconds)
[03:00:58] *** Quits: varayu4 (~varayu@157.37.201.188) (Ping timeout: 272 seconds)
[03:08:00] *** Quits: pipapipapibo (~pipapipap@c-67-160-123-241.hsd1.wa.comcast.net) (Remote host closed the connection)
[03:08:43] *** Quits: Malvolio (~Malvolio@user/malvolio) (Quit: too many headaches)
[03:14:21] *** Quits: asalor (~asalor@user/asalor) (Ping timeout: 256 seconds)
[03:14:25] *** Joins: asalor_ (~asalor@85-70-151-113.rcd.o2.cz)
[03:14:35] *** Quits: sobkas (~sobkas@95.175.17.217) (Quit: sobkas)
[03:21:08] *** Joins: varayu4 (~varayu@157.37.201.188)
[03:26:54] *** Quits: igemnace (~ian@user/igemnace) (Remote host closed the connection)
[03:26:58] *** Quits: Tseug (~Tseug@37.19.197.136) (Ping timeout: 250 seconds)
[03:27:39] *** Joins: varayu47 (~varayu@157.37.201.188)
[03:29:23] *** Quits: varayu4 (~varayu@157.37.201.188) (Ping timeout: 246 seconds)
[03:33:35] *** Quits: varayu47 (~varayu@157.37.201.188) (Ping timeout: 246 seconds)
[03:39:14] *** Quits: Sofia (~sofia@user/sofia) (Remote host closed the connection)
[03:39:40] *** Joins: dez (uid92154@user/dez)
[03:39:40] *** Joins: Sofia (~sofia@user/sofia)
[03:40:08] *** Quits: ivii (~ivan@user/ivii) (Ping timeout: 252 seconds)
[03:53:32] *** Quits: Tangent-Man (~Tang3nt-M@mutantalien.plus.com) (Ping timeout: 246 seconds)
[04:01:50] *** Quits: aleck1 (~aleck@user/aleck) (Read error: Connection reset by peer)
[04:06:37] *** Quits: Klotz (~Klotzoman@gateway/tor-sasl/klotz) (Quit: Klotz)
[04:07:30] *** Joins: varayu47 (~varayu@157.37.201.188)
[04:11:23] *** Quits: Colti (Miramar-FL@user/host-pond) (Ping timeout: 260 seconds)
[04:16:17] *** Quits: PJBoy (~PJBoy@user/pjboy) (Ping timeout: 246 seconds)
[04:29:35] *** Quits: Wulf (~Wulf@user/wulf) (Ping timeout: 246 seconds)
[04:31:32] *** Joins: Wulf (~Wulf@user/wulf)
[04:34:13] *** Quits: Soni (~quassel@autistic.space) (Ping timeout: 240 seconds)
[04:36:34] *** Quits: spacenautx (~spacenaut@user/spacenautx) (Quit: WeeChat 3.4.1)
[04:42:13] *** Quits: brolin (~brolin@179.13.18.50) (Remote host closed the connection)
[04:43:00] *** Joins: brolin (~brolin@179.13.18.50)
[04:47:33] *** Quits: Alina-malina (~Alina-mal@user/alina-malina) (Ping timeout: 260 seconds)
[04:49:26] *** Joins: igemnace (~ian@user/igemnace)
[04:51:32] *** Joins: Alina-malina (~Alina-mal@user/alina-malina)
[05:14:58] *** Quits: varayu47 (~varayu@157.37.201.188) (Ping timeout: 260 seconds)
[05:16:22] *** Joins: varayu47 (~varayu@157.37.201.188)
[05:18:29] *** Quits: steam (~steam@user/steam) (Remote host closed the connection)
[05:27:17] *** Joins: Alina-ma- (~Alina-mal@37.252.83.224)
[05:27:31] *** Quits: Alina-malina (~Alina-mal@user/alina-malina) (Ping timeout: 256 seconds)
[05:39:23] *** Quits: machinedgod (~machinedg@24.105.81.50) (Ping timeout: 260 seconds)
[05:52:15] *** Joins: Dragoon (~Dragoon@user/dragoon)
[05:53:08] <Dragoon> Hello
[05:53:35] *** Quits: varayu47 (~varayu@157.37.201.188) (Ping timeout: 246 seconds)
[06:14:05] *** Quits: FlorianBad (~FlorianBa@cpe-67-49-107-16.dc.res.rr.com) (Quit: Client closed)
[06:22:49] <Dragoon> I am looking for help on cracking, or figuring out the feasibility of it, an IV/salt to get a very specific output of an AES algorithm (CryptoJS 3.1.2)
[06:24:23] <Dragoon> That is rather vague, so let me explain how I was an idiot in 2014 and lost my family quite a bit of money
[06:25:53] <Dragoon> So in 2014 we (dad, cousin, and me) mined LTC. Now I, in my all encompassing idiocy, decided it was a good idea to not just write down a password for the wallet, but to add extra steps to the equation so to speak
[06:26:46] <Dragoon> I figured, not knowing that the output would be different each time, that I would have some text that I'd encrypt with AES using a password to get the output that would be used as a password
[06:27:12] <Dragoon> Could've clicked the encrypt button more than once, but we already established that I was an idiot
[06:28:10] <Dragoon> So long story short, I am locked out of the wallet and lost my family a decent chunk of money, not gonna give specific numbers, but think enough to pay off student loans
[06:28:41] *** Quits: Gallomimia (~Gallomimi@node-1w7jra2a2gqpvtp4t2avkkz1n.ipv6.telus.net) (Ping timeout: 245 seconds)
[06:29:06] <Dragoon> I have a few things, I know roughly when the "password" was generated because of the last edited timestamp on the wallet file
[06:29:20] <Dragoon> I know which version of firefox was used, FF 21
[06:29:44] <Dragoon> And that it was generated with CryptoJS 3.1.2
[06:30:55] <Dragoon> It uses regular JS math.random and truncates them to 32 bit by means of (1 << 32) * Math.random() | 0, it does this twice to generate a 64 bit salt which is used to derive the key and IV
[06:32:45] <Dragoon> If it helps I can drop a godbolt link (C++) with a minimal example of how the FF21 random number generation works that you can look at if interested
[06:33:59] <Dragoon> I had hoped the random engine state would've been 32 bits as that would've made the problem much easier, but God spares no punches I guess
[06:36:24] <Dragoon> The random engine gets seeded with the number of nano seconds since epoch from what I can tell and is XORed with a nonce (atomic counter that is incremented by 1 for each thread(/tab?))
[06:38:57] <Dragoon> So knowing that the salt generation is the weakest link in the chain, and their random algorithm is not cryptographically secure, I am hoping that the engine has a very short cycle count or something
[06:39:26] *** Quits: joe7057 (~joseph@wnpgmb016qw-ds01-2-119.dynamic.bellmts.net) (Ping timeout: 246 seconds)
[06:50:43] *** Joins: Gallomimia (~Gallomimi@d75-152-217-169.abhsia.telus.net)
[06:52:10] *** Joins: Soni (~quassel@autistic.space)
[06:53:06] *** Joins: pulseaudio (~pulseaudi@223.223.136.192)
[06:54:48] <Dragoon> With the math of the random engine I assume it would be good to know if the internal state always converges to a "known" value, so I can figure out when it starts to repeat
[06:57:19] <Dragoon> Ideally I have the set of possible outputs after truncating to 32 bits in set S, and where set S_2 is the same as set S but shifted forwards, then the possible salts are just 2^31-1
[06:57:30] <Dragoon> Which can easily be brute forced with a GPU
[06:58:38] <Dragoon> At 10K guesses per sec it would only take about 60 hours to brute force, but something tells me I won't be this lucky
[06:59:13] *** Quits: dez (uid92154@user/dez) (Quit: Connection closed for inactivity)
[07:02:44] *** Joins: joe7057 (~joseph@wnpgmb016qw-ds01-2-119.dynamic.bellmts.net)
[07:04:43] <snappy> i don't even understand the issue, you used some cryptojs thing to encrypt a wallet using AES using some mode and there's some IV (what you call salt) guessing happening
[07:05:27] <Dragoon> Well yes, I don't know the mode, I am assuming it's the default mode that CryptoJS uses
[07:05:52] <Dragoon> Essentially I used the base64 output of the algorithm as the password for the litecoin wallet
[07:06:27] <Dragoon> But because the salt is randomized the base64 output is different each time you run it
[07:06:54] <iz> and you didn't write down the IV/salt that was used
[07:07:25] <Dragoon> I didn't know it was randomized at the time
[07:07:52] <Dragoon> I thought it was like a hash where you always get the same output
[07:08:38] <iz> it sounds like it's seeded with more than just time also, but do you even remember the time when you first used it to set the password?
[07:09:10] <snappy> i think you're shit outta luck
[07:09:35] <iz> yeah, it sounds like you are trying to do exactly what the cryptosystem is designed to prevent
[07:11:32] <Dragoon> https://godbolt.org/z/PzGo5rnj8 That's the random engine code that is present in FF21
[07:13:47] <Dragoon> I am basically just praying that the random algorithm is horribly flawed and somehow I can bruteforce it to get the 32 bit set S and S_2
[07:14:30] <Dragoon> iz: you are correct, I forget the name for the attack, but it's a known plaintext attack
[07:15:35] <Dragoon> oh that is actually the name lol
[07:15:38] <snappy> first i would find out what mode of AES was used, and if you entered a password - how was the key derived, and was it a 128-bit key, 192-bit key, or a 256-bit key
[07:15:53] <iz> you think the random seed for firefox 21 was horribly flawed?  if that were the case, there would have been vuln reports and patches
[07:16:11] <iz> search for vuln reports about the random seed in firefox 22
[07:16:31] <Dragoon> The source code states it makes no security guarantees for the seed and algorithm
[07:16:55] <Dragoon> And the library has vulnerability reports for getting the random data
[07:18:02] <iz> do you remember what time and date and year you first used it to set the password also?
[07:18:15] <iz> and yeah, figure out the mode
[07:18:22] <Dragoon> Roughly
[07:19:08] <Dragoon> Earliest timestamp I have is 12/01/2014 20:56 (MM/DD/YYYY)
[07:19:12] <iz> within how many nanoseconds?  do the math and see if it would even be feasible
[07:19:46] <Dragoon> If I have to bruteforce for even an hour it would be 3.6 trillion nanoseconds
[07:20:12] <Dragoon> At an estimated 10000 guesses per second it would be infeasible
[07:21:11] <iz> also are you sure in your usage rngstate is set to 0 before random_setSeed() ?
[07:21:23] <Dragoon> Nope
[07:21:39] <Dragoon> I don't remember how long I had the browser open, and how many tabs were open
[07:21:48] <iz> it seems like the way those functions were written, there would be a random state that is kept
[07:21:56] <iz> and loaded at launch and added to
[07:22:25] <iz> so without knowing the memory state of the browser when you were using it, probably already out of luck
[07:22:50] <Dragoon> yes, the ^ 4 in the initialization function call (random_setSeed) is an arbitrary number that is the nonce call in the browser code
[07:23:16] <iz> well, there is rngState and seed
[07:23:47] <iz> if rndState isn't set to 0 and you don't know what rngState was.. it doesn't even matter if you guess what the seed was
[07:24:47] <Dragoon> I am hoping the vulnerability is either in random_next or in Random (line 51 and 52)
[07:24:50] <iz> or did you write your own little thing that did this, where you set all those things up like that?
[07:25:17] <iz> or are just kinda kinda making up an example and hoping FF22 seeded the randomizer it uses in a broken way?
[07:26:03] <Dragoon> lines 18 to 42 are copied verbatim from the FF21 source code
[07:26:29] <snappy> i just don't get it, what UI wouldn't display the IV alongside the ciphertext
[07:26:35] <iz> yeah, but how the functions are used and where they are used and what memory they point to is what matters
[07:26:46] <Dragoon> snappy: many, but I didn't write it down back then
[07:26:47] <iz> not the fake main() where you use the functions in a broken way
[07:28:06] <iz> i mean, you can test it out.. get firefox22 installed in a VM, set the time to a certain time and run your weird java thing
[07:28:13] <Dragoon> so in jsmath.cpp in js::InitRandom there is the line random_setSeed(rngState, (uint64_t(PRMJ_Now()) << 8) ^ rt->nextRNGNonce());
[07:28:22] <iz> and then set the time in the VM back and do it again
[07:28:34] <iz> and see if you get the same result or not
[07:29:22] <Dragoon> PRMJ_Now() is essentially Now() but the windows version that more or less does the same thing, it's quite complex and deals with working around some weird time skew thing
[07:29:29] <Dragoon> It's made to mimic gettimeofday
[07:30:00] <Dragoon> rt is the runtime and the RNGNonce is an atomic that gets incremented for each...
[07:30:28] <Dragoon> compartment...?
[07:30:37] <Dragoon> I am assuming a compartment is a tab
[07:31:11] <Dragoon> actually it's not atomic, just a 64 bit unsigned int, but it starts at 0 and gets incremented by 1 for each compartment
[07:34:06] <iz> what about the rn->nextRNGNonce() output?  that sounds like a nonce value you don't have
[07:34:29] <Dragoon> That is correct
[07:35:06] <iz> then even if you knew the time to the exact nanosecond, it wouldn't matter, b/c you don't know that rngnonce
[07:36:03] *** Quits: pulseaudio (~pulseaudi@223.223.136.192) (Remote host closed the connection)
[07:38:19] <Dragoon> I do know that my seed gets truncated to 48 bits of randomness and the higher 8 bits of my timestamp are also stripped
[07:39:04] <iz> but it's xored w/ a nonce you don't know
[07:39:41] <Dragoon> yes, but I don't assume this nonce to be very high
[07:40:07] <Dragoon> An idea I have is to take the timestamp and wind it back by an hour
[07:40:11] <iz> that sounds like exactly what it was designed for and why it's called that
[07:40:43] <iz> it's saving and restoring some randomizer state to make sure the seeding is random
[07:40:50] <Dragoon> And then to generate about 1000 random numbers for each seed before moving to the next
[07:41:21] <iz> try to recreate the same randomizer output by just resetting the time in a VM
[07:42:53] <iz> if the random seed for firefox really was that broken, there would have been a lot of security vulnerabilities reported and fixed about it by now
[07:43:33] <Dragoon> Well it's not supposed to be cryptographically secure
[07:43:58] <Dragoon> You're generally supposed to use the RNG from something like OpenSSL
[07:44:03] <iz> it still would have huge security implications to like.. every web development framework that uses cookies or tokens
[07:44:20] <Dragoon> But afaicr they did replace it in a later version
[07:46:21] <iz> good luck and godspeed, but it seems very unlikely
[07:47:53] <iz> you may just be fooling and fueling yourself with false hope at this point..  i would recommend doing some testing on the randomizer seed state in FF22.. maybe run it in a debugger and see what that value nextRNGNonce() output really looks like
[07:49:51] <Dragoon> They definitely use something more robust now in the latest version
[07:53:09] <iz> yeah, look at FF22 in a debugger and see what exactly happens when the randomizer seeds..  the debugger will show you the truth
[08:00:49] <Dragoon> And yeah, I probably am giving myself false hope
[08:01:06] <Dragoon> Though that's why I am asking for help
[08:02:02] <gevreeen> is 0x36 and 0x5C selected on purpose for hmac?
[08:02:23] <gevreeen> would another duo work instead?
[08:05:25] *** Quits: auk (auk@gateway/vpn/protonvpn/auk) (Quit: Leaving)
[08:05:44] <TimMc> gevreeen: I recall something about the goal being an overlap in the bit pattern.
[08:07:05] <TimMc> 0011 0110 vs 0101 1100
[08:07:59] <gevreeen> some overlap, but not much
[08:08:06] <TimMc> Some discussion here: https://crypto.stackexchange.com/questions/20695/hmac-ipad-and-opad-choice
[08:08:44] <TimMc> Half the bits overlap.
[08:08:55] <TimMc> s/overlap/match/
[08:09:14] <gevreeen> ah, right. didn't count them zeroes
[08:10:40] <gevreeen> or just use keccak
[08:17:06] <Dragoon> Well if anybody else is interested in this problem and wants to help feel free to ping me or send me a PM
[08:17:51] <Dragoon> If we do end up cracking it open I am fine with giving you 10% of its contents
[08:34:20] *** Quits: brolin (~brolin@179.13.18.50) (Remote host closed the connection)
[08:38:49] *** Joins: Malvolio (~Malvolio@user/malvolio)
[09:03:46] *** Joins: chuudoku (~chuudoku@72.95.253.19)
[09:10:07] <Alipha> Dragoon: where's the cryptojs code?
[09:13:22] <Dragoon> https://github.com/brix/crypto-js/blob/svn-mirror/3.1.2/src/cipher-core.js#L753
[09:13:31] <Dragoon> https://github.com/brix/crypto-js/blob/svn-mirror/3.1.2/src/evpkdf.js#L55
[09:16:42] *** Quits: chuudoku (~chuudoku@72.95.253.19) (Quit: Leaving)
[09:17:01] *** Joins: chuudoku (~chuudoku@72.95.253.19)
[09:34:14] *** Joins: BOKALDO (~BOKALDO@user/bokaldo)
[09:34:24] *** Joins: sphertext_ (~sphertext@user/sphertext)
[09:35:50] <sphertext_> hey dose this sequence look like the output of a familiar algorithm? [8 alpha numeric]-[4]-[4]-[12]
[09:36:09] <sphertext_> they're all alpha-numerical characters 
[09:46:18] <Alipha> Dragoon: looks like the RNG state is only 48 bits, from your godbolt paste, which is still a large number, but much better than 64 bits
[09:47:56] <Dragoon> That's still 891 years of brute forcing at 10K guesses/s
[09:48:26] <Dragoon> who knows with modern medicine... lol
[09:56:34] *** Joins: [_] (~itchyjunk@user/itchyjunk/x-7353470)
[09:59:19] *** Quits: [itchyjunk] (~itchyjunk@user/itchyjunk/x-7353470) (Ping timeout: 260 seconds)
[10:14:17] *** Joins: Batata-Wada (~Batata-Wa@103.106.20.183)
[10:16:05] *** Quits: sphertext_ (~sphertext@user/sphertext) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[10:16:27] *** Joins: sphertext (~sphertext@user/sphertext)
[10:16:51] *** Quits: sphertext (~sphertext@user/sphertext) (Client Quit)
[10:25:42] *** Parts: Batata-Wada (~Batata-Wa@103.106.20.183) ()
[10:26:19] *** Quits: chasmo77 (~chas77@c-71-193-246-4.hsd1.or.comcast.net) (Quit: It's just that easy)
[10:51:58] *** Joins: Sofia_ (~sofia@user/sofia)
[10:53:15] *** Quits: Sofia (~sofia@user/sofia) (Ping timeout: 240 seconds)
[10:53:50] *** Sofia_ is now known as Sofia
[11:02:55] *** Quits: [_] (~itchyjunk@user/itchyjunk/x-7353470) (Remote host closed the connection)
[11:05:50] *** Joins: Nimrodel (~Nimrodel@ppp-94-69-16-130.home.otenet.gr)
[11:06:34] *** Quits: asalor_ (~asalor@85-70-151-113.rcd.o2.cz) (Changing host)
[11:06:34] *** Joins: asalor_ (~asalor@user/asalor)
[11:06:40] *** asalor_ is now known as asalor
[11:07:39] *** Joins: sphertext (~sphertext@user/sphertext)
[11:09:27] *** Quits: Lochnair (~Lochnair@wireguard/contributor/lochnair) (*.net *.split)
[11:09:27] *** Quits: ek0 (~vincent@2a01cb0003457d005bff511cba75fdd2.ipv6.abo.wanadoo.fr) (*.net *.split)
[11:09:27] *** Quits: son0p (~ff@181.136.122.143) (*.net *.split)
[11:09:27] *** Quits: martin02_ (~silas@141.84.69.76) (*.net *.split)
[11:09:27] *** Quits: aczid_ (~aczid@tuig.nikhef.nl) (*.net *.split)
[11:09:27] *** Quits: mcf (~mforney@netbsd/developer/mcf) (*.net *.split)
[11:09:27] *** Quits: _0ne (~one@user/0ne/x-2101768) (*.net *.split)
[11:09:27] *** Quits: koolazer (~koo@user/koolazer) (*.net *.split)
[11:09:27] *** Quits: nisstyre (wes@user/nisstyre) (*.net *.split)
[11:09:27] *** Quits: aweinstock (~aweinstoc@cpe-67-248-65-250.nycap.res.rr.com) (*.net *.split)
[11:09:27] *** Quits: sshine (~simon@zhen.eta.solutions) (*.net *.split)
[11:09:27] *** Quits: baakeydow (~baake@2001:41d0:203:b12c::) (*.net *.split)
[11:09:27] *** Quits: kristjansson (sid126207@id-126207.tinside.irccloud.com) (*.net *.split)
[11:09:28] *** Quits: MyWay (~MyWay@2001:41d0:8:be9a::1) (*.net *.split)
[11:09:28] *** Quits: elichai2 (sid212594@2a03:5180:f:4::3:3e72) (*.net *.split)
[11:09:28] *** Quits: hendi (sid489601@id-489601.lymington.irccloud.com) (*.net *.split)
[11:09:36] *** Joins: aczid (~aczid@tuig.nikhef.nl)
[11:09:37] *** Joins: mcf (~mforney@netbsd/developer/mcf)
[11:09:40] *** Joins: aweinstock (~aweinstoc@cpe-67-248-65-250.nycap.res.rr.com)
[11:09:53] *** Joins: ek0 (~vincent@2a01cb0003457d005bff511cba75fdd2.ipv6.abo.wanadoo.fr)
[11:09:55] *** Joins: sshine (~simon@exocortex.online)
[11:10:00] *** Joins: nisstyre (wes@2600:3c00::f03c:91ff:fe69:7f3d)
[11:10:05] *** Joins: martin02_ (~silas@141.84.69.76)
[11:10:05] *** Joins: baakeydow (~baake@2001:41d0:203:b12c::)
[11:10:29] *** Joins: hendi (sid489601@id-489601.lymington.irccloud.com)
[11:10:33] *** Joins: kristjansson (sid126207@id-126207.tinside.irccloud.com)
[11:10:35] *** Joins: elichai2 (sid212594@id-212594.hampstead.irccloud.com)
[11:10:36] *** Joins: joji (~jojo@86.4.72.180)
[11:10:59] *** Joins: MyWay (~MyWay@ns3290077.ip-5-135-183.eu)
[11:11:33] *** Joins: _0ne (~one@user/0ne/x-2101768)
[11:11:43] *** Joins: Colti (Miramar-FL@user/host-pond)
[11:12:33] *** Joins: xx (~xx@user/xx)
[11:13:11] *** Quits: EmmyNoether (~EmmyNoeth@yoke.ch0wn.org) (*.net *.split)
[11:13:11] *** Quits: mykhal (~m@user/mykhal) (*.net *.split)
[11:13:12] *** Quits: SrPx (sid108780@id-108780.uxbridge.irccloud.com) (*.net *.split)
[11:13:12] *** Quits: sword_smith (sword_smit@bitcoinfundamentals.org) (*.net *.split)
[11:13:12] *** Quits: Alanius (~alan@asdm.gmbh) (*.net *.split)
[11:13:12] *** Quits: mcfrdy (~mcfrdy@user/mcfrdy) (*.net *.split)
[11:13:12] *** Quits: _- (~orgg@user/orgg) (*.net *.split)
[11:13:18] *** Joins: Alanius (~alan@asdm.gmbh)
[11:13:21] *** Joins: EmmyNoether (~EmmyNoeth@yoke.ch0wn.org)
[11:13:22] *** Joins: sword_smith (sword_smit@bitcoinfundamentals.org)
[11:13:37] *** Joins: _- (~orgg@20.55.233.57)
[11:13:43] *** Joins: mykhal (~m@user/mykhal)
[11:13:44] *** Joins: SrPx (sid108780@id-108780.uxbridge.irccloud.com)
[11:14:05] *** Joins: mcfrdy (~mcfrdy@user/mcfrdy)
[11:14:46] *** Joins: koolazer (~koo@user/koolazer)
[11:15:57] *** Quits: Gallomimia (~Gallomimi@d75-152-217-169.abhsia.telus.net) (Read error: Connection reset by peer)
[11:16:08] *** Quits: nisstyre (wes@2600:3c00::f03c:91ff:fe69:7f3d) (Quit: WeeChat 3.4)
[11:16:17] *** Joins: nisstyre (wes@user/nisstyre)
[11:16:59] *** Joins: Gallomimia (~Gallomimi@node-1w7jra2a2gqpyotkbeu1hy1qf.ipv6.telus.net)
[11:32:13] *** Quits: yawkat (~yawkat@cats.coffee) (Ping timeout: 256 seconds)
[11:47:39] *** Quits: skaro (~skaro@2600:8807:180:80:c54d:c853:5ee8:f7d4) (Quit: KVIrc 5.0.1 Aria http://www.kvirc.net/)
[11:48:51] *** Quits: igemnace (~ian@user/igemnace) (Quit: WeeChat 3.5)
[12:16:19] *** Quits: cvmn (~caveman@gateway/tor-sasl/caveman) (Remote host closed the connection)
[12:16:53] *** Quits: Nimrodel (~Nimrodel@ppp-94-69-16-130.home.otenet.gr) (Quit: Leaving)
[12:17:00] *** Joins: cvmn (~caveman@gateway/tor-sasl/caveman)
[12:18:40] *** Joins: machinedgod (~machinedg@24.105.81.50)
[12:26:36] *** Joins: Guyver2 (~Guyver@guyver2.xs4all.nl)
[12:41:27] *** Quits: chuudoku (~chuudoku@72.95.253.19) (Quit: Leaving)
[12:44:21] *** Joins: Haohmaru (~Haohmaru@195.24.53.110)
[12:44:55] *** Joins: igemnace (~ian@user/igemnace)
[12:50:04] <gevreeen> where is the hmac part of EVP_aes_256_ctr() documented for libressl/openssl?
[12:51:09] <Wulf> gevreeen: There's no hmac?
[12:52:00] <gevreeen> maybe there is one, but this primitive takes no parameter, which is why I'm asking
[12:52:18] <Wulf> no, there is no hmac in aes.
[12:52:45] <gevreeen> but there should be one to specify for counter mode
[12:53:18] <Wulf> no
[12:54:00] *** Joins: MajorBiscuit (~MajorBisc@c-001-003-047.client.tudelft.eduvpn.nl)
[12:54:59] <Wulf> gevreeen: if you're looking for authenticated encryption, rtfm on EVP_EncryptInit
[12:55:14] <Wulf> chapter "AEAD Interface"
[12:55:24] <Wulf> but ctr mode is *not* authenticated.
[12:55:42] <gevreeen> the openbsd man would ask for _ex suffix, or that's deprecated
[12:56:24] <snappy> oh no, we're doing openssl docs again
[12:56:29] <Wulf> same manpage on my system. Its primary name is EVP_EncryptInit.3ssl.gz
[12:57:21] <gevreeen> searching for "aead interface" gives nothing on https://man.openbsd.org/EVP_EncryptInit
[12:57:31] <Wulf> snappy: exactly, we're still trying to figure out the encryption algorithm that was used on the docs.
[12:57:47] <gevreeen> but there is EVP_AEAD_CTX_init
[12:58:02] <snappy> gevreeen: any chance you can not use openssl?
[12:59:14] <gevreeen> well, I can, but I prefer some compatibility with libressl so I don't have to code it twice
[13:01:19] <snappy> highly recommend you stay away from the openssl and derivative apis and use something like libsodium
[13:02:42] <snappy> but if you must then the AEAD ciphers are what you want
[13:04:23] <gevreeen> yeah, looks like the openssl-built dll doesn't have EVP_AEAD_CTX_init. guess this is a breaking point
[13:09:05] <snappy> you can do it the oldschool way i guess, k1,k2 = hkdf(k), c = AES-CTR(k1, iv, m), tag = HMAC(k2, c)
[13:10:58] <snappy> er to be more specific hkdf using SHA256 and HMAC-SHA256
[13:12:28] *** Joins: aleck1 (~aleck@user/aleck)
[13:13:43] *** Joins: yawkat (~yawkat@cats.coffee)
[13:17:06] *** Joins: blarnath (~d34dh0r53@98.97.86.75)
[13:18:07] *** Quits: d34dh0r53 (~d34dh0r53@98.97.81.202) (Ping timeout: 260 seconds)
[13:18:17] <gevreeen> (always nice to keep a big picture somewhere when doing dovetailing. thank you, snappy)
[13:21:02] *** Joins: aleck (~aleck@user/aleck)
[13:22:46] *** Quits: aleck1 (~aleck@user/aleck) (Ping timeout: 268 seconds)
[13:22:58] *** Quits: Gallomimia (~Gallomimi@node-1w7jra2a2gqpyotkbeu1hy1qf.ipv6.telus.net) (Remote host closed the connection)
[13:23:45] *** Quits: blarnath (~d34dh0r53@98.97.86.75) (Ping timeout: 248 seconds)
[13:27:24] *** Joins: andreasbuhr (~quassel@p549dbec6.dip0.t-ipconnect.de)
[13:27:30] *** Quits: milkt (~debian@gateway/tor-sasl/milkt) (Remote host closed the connection)
[13:27:31] *** Joins: milkt_ (~debian@gateway/tor-sasl/milkt)
[13:34:36] *** Quits: e2 (e2@sponsored.by.bnc4you.xyz) (Ping timeout: 240 seconds)
[13:34:49] *** Joins: d34dh0r53 (~d34dh0r53@98.97.86.58)
[13:39:36] *** Joins: tuskkk____ (uid18470@id-18470.tinside.irccloud.com)
[13:42:30] *** Quits: d34dh0r53 (~d34dh0r53@98.97.86.58) (Ping timeout: 268 seconds)
[13:43:01] *** Joins: d34dh0r53 (~d34dh0r53@98.97.81.56)
[13:47:17] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Remote host closed the connection)
[13:47:32] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[13:49:36] *** Joins: PJBoy (~PJBoy@user/pjboy)
[13:50:14] *** Quits: sphertext (~sphertext@user/sphertext) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[13:50:36] *** Joins: sphertext (~sphertext@user/sphertext)
[13:51:00] *** Quits: sphertext (~sphertext@user/sphertext) (Client Quit)
[13:51:22] *** Joins: sphertext (~sphertext@user/sphertext)
[13:51:47] *** Quits: sphertext (~sphertext@user/sphertext) (Client Quit)
[13:52:29] *** Joins: sphertext (~sphertext@user/sphertext)
[13:52:35] *** Quits: sphertext (~sphertext@user/sphertext) (Client Quit)
[13:53:09] *** Joins: sphertext (~sphertext@user/sphertext)
[13:53:22] *** Quits: sphertext (~sphertext@user/sphertext) (Client Quit)
[13:54:50] *** Quits: d34dh0r53 (~d34dh0r53@98.97.81.56) (Ping timeout: 268 seconds)
[13:55:50] *** Joins: d34dh0r53 (~d34dh0r53@98.97.86.33)
[13:57:23] *** Joins: gproto23 (~gproto23@user/gproto23)
[13:58:03] *** Quits: gproto23 (~gproto23@user/gproto23) (Remote host closed the connection)
[13:58:51] *** Joins: gproto23 (~gproto23@user/gproto23)
[14:01:19] *** Joins: blarnath (~d34dh0r53@98.97.81.56)
[14:02:09] *** Quits: d34dh0r53 (~d34dh0r53@98.97.86.33) (Ping timeout: 248 seconds)
[14:27:32] *** Joins: llorllale (~llorllale@198.98.119.85)
[14:51:47] *** Joins: e2 (e2@sponsored.by.bnc4you.xyz)
[15:04:18] *** Joins: flooded (flooded@gateway/vpn/protonvpn/flood/x-43489060)
[15:09:23] *** flooded is now known as _flood
[15:13:08] *** Quits: dusk (~quassel@suki.ds7s.nl) (Remote host closed the connection)
[15:13:20] *** Joins: dusk (~quassel@suki.ds7s.nl)
[15:18:08] *** Joins: milkt (~debian@gateway/tor-sasl/milkt)
[15:19:55] *** Quits: milkt_ (~debian@gateway/tor-sasl/milkt) (Ping timeout: 240 seconds)
[15:22:28] *** Joins: ioxzev1z (~ioxzev1z@user/ioxzev1z)
[15:28:34] *** Quits: llorllale (~llorllale@198.98.119.85) (Ping timeout: 268 seconds)
[15:30:30] *** Joins: llorllale (~llorllale@198.98.119.85)
[15:35:19] *** Joins: gurkenglas (~gurkengla@dslb-178-012-018-212.178.012.pools.vodafone-ip.de)
[15:37:21] *** Quits: joji (~jojo@86.4.72.180) (Quit: Leaving)
[15:42:47] *** Quits: geeknix (~pi@2001:e68:5432:518e:7d14:5ca5:9ed8:f278) (Ping timeout: 260 seconds)
[15:46:11] <gurkenglas> If for any one of two functions it is difficult to figure out the input from the output, is this then automatically difficult for their composite? The hope being that one could compose different hash functions, and then if a published paper breaks one but not both of them, you are warned before you are vulnerable.
[15:48:28] *** Joins: Guyver2_ (~Guyver@guyver2.xs4all.nl)
[15:49:32] *** Quits: Guyver2 (~Guyver@guyver2.xs4all.nl) (Ping timeout: 268 seconds)
[15:50:20] <wasamasa> um
[15:50:26] <wasamasa> combining two hash functions is stupid
[15:51:22] <wasamasa> https://cryptopals.com/sets/7/challenges/52
[15:51:37] <wasamasa> don't do this
[15:51:49] <wasamasa> if you do, make sure to solve that exercise :P
[15:51:59] <wasamasa> so that you remember to not do this in actual code
[16:00:10] *** Joins: geeknix (~pi@2001:e68:5432:af1f:781b:3d59:e4b7:2808)
[16:04:49] *** Quits: llorllale (~llorllale@198.98.119.85) (Ping timeout: 248 seconds)
[16:04:57] *** Joins: noonien (~noonien@user/noonien)
[16:06:46] <Wulf> gurkenglas: your question is unclear. You can compute two different hash functions on the same input and concatenate the output, e.g. H = MD5(M) || SHA1(M). Even if MD5 is broken, you still can't create a collision. And even if SHA1 is broken too, you'd still need to find an input that creates a collision on both. I'm not aware that anyone succeeded yet.
[16:07:36] <river> perhaps there is a function X -> X which is both difficult to compute and it's inverse is difficult to compute 
[16:07:50] <river> i can't think of an example, but it feels like it could exist
[16:08:54] <Wulf> river: AES with an unknown key and with only some plain/encrypted pairs.
[16:11:01] <gurkenglas> river: most random functions are that, mathematically! :D
[16:11:13] <gurkenglas> (as in, selected uniformly at random from the set of all functions)
[16:11:15] <wasamasa> https://link.springer.com/chapter/10.1007/978-3-540-28628-8_19
[16:11:38] <wasamasa> paper behind that exercise
[16:11:39] <gurkenglas> wasamasa: i wasn't asking about collisions though
[16:12:17] <wasamasa> it's called a collision, be it whether you find the original input or something else resulting in the same output
[16:12:29] <Wulf> gurkenglas: you were asking about pre-image?
[16:12:33] <gurkenglas> right, im asking about the difficulty of finding the original input.
[16:12:46] <gurkenglas> Wulf, not pre-image
[16:12:52] <Wulf> gurkenglas: and composite means?
[16:13:03] <gurkenglas> Wulf, you apply the one function and then the other.
[16:14:01] <gurkenglas> Like, if one widget turns apples into bins and another turns bins into clowns then their composite turns apples into clowns.
[16:14:09] <river> so f and f' are hard to compute, but f o f' = id is easy!
[16:14:10] <Wulf> gurkenglas: H = A(B(M)). For hash functions A,B, a secret message M and a digest H, determine M?
[16:14:59] <gurkenglas> Wulf, yes. You may assume that this holds for one of A or B.
[16:15:02] *** Quits: milkt (~debian@gateway/tor-sasl/milkt) (Remote host closed the connection)
[16:15:22] *** Joins: milkt (~debian@gateway/tor-sasl/milkt)
[16:16:21] <Wulf> gurkenglas: river gave a good counter example.
[16:16:28] <gurkenglas> river, interesting! Now I also want to see such an f.
[16:17:16] <river> I guess you could call it a 'zero way function'
[16:17:51] <river> > Provably Hard Zero-Way Functions - Eikoh CHIDA, Li LI, Hiroki SHIZUYA
[16:18:04] <river> https://www.jstage.jst.go.jp/article/iis/8/1/8_1_57/_pdf
[16:19:03] <Wulf> One should add the restriction that A and B are cryptographic functions and they don't have any secret parts, i.e. no oracle.
[16:22:08] <gurkenglas> river, my guess before reading that of such a function where you can hold the secret to either without holding the secret to the other is, Alice signs her message then encrypts it so only Bob can verify it's from Alice, and then you repeat it vice versa, and that cycle has two halves that look like f and f^-1
[16:22:38] *** Joins: pulseaudio (~pulseaudi@223.223.136.192)
[16:22:48] *** Quits: pulseaudio (~pulseaudi@223.223.136.192) (Remote host closed the connection)
[16:23:00] <river> thats exactly it
[16:23:02] <gurkenglas> Wulf, what precisely do you mean by those?
[16:23:21] <gurkenglas> Nice :)
[16:23:27] <wasamasa> Wulf: MD5(M) || SHA1(M) is no better than the weakest part of the link
[16:24:17] <wasamasa> Wulf: see 4.2 in https://www.iacr.org/archive/crypto2004/31520306/multicollisions.pdf
[16:24:53] <gurkenglas> I think there's a question somewhere around here that makes sense... something like "What security property of functions holds for the composite when it holds for any component?"
[16:25:22] <Wulf> wasamasa: 4.2 "Preimage and second-preimage resistance". How's that related to collisions?
[16:26:33] <gurkenglas> (Once again, composite meaning "f(g(x))" not "f(x) concatenated with g(x)", which I'd call "pointwise concatenation" and which is a different way to combine functions for which it would also make sense to ask for the corresponding security property :) )
[16:26:51] <wasamasa> lol, one of you asking about collisions, the other not asking about collisions
[16:26:57] <Wulf> yep
[16:27:32] <Wulf> Concatenation helps against collisions, but is counterproductive against pre-image.
[16:27:40] <wasamasa> but yeah, the paper covers collisions and preimages
[16:31:31] *** Joins: llorllale (~llorllale@198.98.119.85)
[16:33:53] <gurkenglas> if you know that for one of f,g it is hard to find the original input from the output, can you construct a function for which this is also hard?
[16:39:06] <gurkenglas> one difficulty in replying to that question is that one reply one might give is "sure, use sha". So perhaps we could start with an assumption that no computable hash functions exist, but Fred and George will graciously act as oracles for one function each, one of which is a hash?
[16:39:28] *** Quits: Jam_ (uid548391@id-548391.hampstead.irccloud.com) (Quit: Connection closed for inactivity)
[16:39:51] <gurkenglas> (now i've accidentally gone and abbreviated my security property to "hash". what should i call functions with my property instead?)
[16:40:53] <river> there's a theoretical issue in representing the hardness of a hash function
[16:41:40] <gurkenglas> *moderately shakes in seat*
[16:41:48] <river> H may be easy to compute, because we have efficient code for it, but as far as math goes the inverse is just a finite set of mappings from hashes to (bounded length) bitstrings
[16:42:07] <river> in practice this is kind of absurd
[16:42:56] <gurkenglas> river, I don't follow. why is code relevant
[16:43:25] <river> we think sha256 is easier to compute than sha256-inverse, because we have efficient code for it
[16:43:58] <river> but there might exist efficient code that inverts it (this is extremely unlikely)
[16:44:46] <river> so in theory we use a random oracle model, to deal with this
[16:46:44] <cvmn> is grover's algorithm going to reduce key bit search space from O(N) into O(sqrt(N)), even for the one time pad?
[16:47:12] <gurkenglas> cwmn, what does the one time pad have to do with search spaces?
[16:47:27] <river> no grovers alg. does not affect one time pad
[16:47:50] <river> these is kind of an issue with cracking one time pads; You need a way to determine if you decrypted the message
[16:47:56] <river> this mechanism isn't part of the calculus
[16:48:00] <gurkenglas> Given the encrypted text and some cleartext you would like it to decrypt to you can always come up with the corresponding pad
[16:48:09] <river> but if it is, you can start to address the impact of quantum algorithms on /that/
[16:48:09] <cvmn> say i used a 256 bit random pad to encrypt 256 bits of cleartext.  will grover's algorithm manage to find that 256-bit pad?
[16:48:17] <river> no
[16:48:39] <gurkenglas> only given the cleartext and the encrypted text
[16:48:53] <gurkenglas> (and then you dont need grover's algorithM)
[16:49:16] <gurkenglas> cvmn, same goes if you had an infinitely powerful computer
[16:49:39] *** Joins: coloseau (~coloseau@bl4-167-102.dsl.telepac.pt)
[16:49:40] <river> the idea of decrypting a one time pad hardly makes sense
[16:49:54] <river> pad xor guess can be *any* binary string
[16:51:07] <river> put more clearly what i meant to say is:  pad xor guess  ranges over every binary string, as you change guess
[16:51:40] <gurkenglas> cvmn, i fear that may produce some unwarranted worship of mystery - suppose i roll a blue and a red ten-sided die and tell you the last digit of their sum. can you figure out what the blue die rolled?
[16:51:59] <gurkenglas> what if you had a quantum computer?
[16:53:30] <cvmn> gurkenglas: no.
[16:55:58] <gurkenglas> cvmn: Indeed! one implementation of one time pad is: you throw a zillion-sided die, your compatriot goes to russia, you put the second zillion-sided die on the number corresponding to whichever message you'd like to transmit, you add them and broadcast the last digit in base zillion of their sum across the ocean. your compatriot can figure out the message and putin can't
[16:56:13] <gurkenglas> (your compatriot remembers the result of the first die)
[16:57:23] <gurkenglas> (if you don't have a feel for base zillion, use "10" instead of "zillion")
[16:57:58] *** Quits: BOKALDO (~BOKALDO@user/bokaldo) (Quit: Leaving)
[16:59:21] *** Quits: tuskkk____ (uid18470@id-18470.tinside.irccloud.com) (Quit: Connection closed for inactivity)
[17:02:55] <gurkenglas> The usual implementation is: throw a coin where your compatriot sees it, send him away, put the second coin on a side of your choice, transmit whether the coins are on the same side, and he knows what side you put the coin on and putin doesn't; do this ~8000 times in parallel and you can transmit a kilobyte.
[17:04:14] *** coloseau is now known as coss
[17:06:00] <gurkenglas> river: I still don't understand the theoretical issue you're trying to point out about representing the hardness of a hash function
[17:12:16] *** Quits: gproto23 (~gproto23@user/gproto23) (Remote host closed the connection)
[17:15:57] *** Quits: llorllale (~llorllale@198.98.119.85) (Ping timeout: 260 seconds)
[17:21:58] *** Joins: brolin (~brolin@179.13.18.50)
[17:29:56] <river> as far as math is concerned, there is nothing harder about computing h^(-1)
[17:30:02] <river> both are just finite functions
[17:30:22] <river> in reality, a lookup table with roughly 2^256 elements isn't realizable
[17:30:28] <gurkenglas> then use not-finite functions
[17:30:43] <river> that isn't an option, because we're talking about a hash which has a finite output size
[17:30:50] <river> the solution is th erandom oracle model though
[17:31:03] <gurkenglas> sure, i'm talking about a function that takes in a finite input of any length, of which there are infintiely many
[17:31:05] <river> (so the inverse image of the codomain is finite too)
[17:31:17] <gurkenglas> (infinitely many finite inputs, i mean)
[17:31:39] <river> well, what i said is wrong.. but pick one representative from each fibre
[17:32:35] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Ping timeout: 240 seconds)
[17:34:18] <gurkenglas> river, if you pick the same representative from each fibre, the lookup table thing doesn't work
[17:34:37] <river> I see your point
[17:36:48] <gurkenglas> it's plausible that nobody ever manages to prove "none of these functions of finite description that take in an input of any finite length are the inverse of the hash under consideration" though.
[17:37:22] <gurkenglas> ("hash" referring to the function, not the output)
[17:38:47] *** Joins: llorllale (~llorllale@198.98.119.85)
[17:39:58] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[17:41:46] <river> https://www.cl.cam.ac.uk/teaching/1516/SecurityII/mgk/security2-slides.pdf slide 9 and 10 is what i was really trying to say/but unfortunately forgot the exact details. a fixed hash functions has collisions and they can in theory be found in constant time - so for modelling the security of these things we kind of need to use keyed hash functions or ROM
[17:42:19] <river> appreciate you finding the holes in what i said
[17:47:02] <yawkat> river: the 's' is NOT a key
[17:47:03] *** Joins: gabriel1 (~gabriel1@user/gabriel1)
[17:47:04] <yawkat> it is public
[17:47:11] <cvmn> is there any csprng that, guarantees via mathematical proofs, that if its seeds has, say, 128 bits of entropy, then the entropy of the entire sequence is going to be 128 bits?
[17:47:20] <cvmn> (sequence that it generates)
[17:48:13] <yawkat> cvmn: the identity function
[17:48:18] *** Quits: PJBoy (~PJBoy@user/pjboy) (Quit: Ping timeout: 252 seconds)
[17:48:33] <river> that's not random
[17:49:45] <gurkenglas> river, define random
[17:52:43] *** Joins: PJBoy (~PJBoy@user/pjboy)
[17:55:18] <cvmn> if a csprng has a seed that's randomly chosen and is made of 128 bits.  then, if we ask an adversary ``how many possible strings can this csprng generate before losing randomness (or repeating itself)?'', asymptotically his best answer will be ``2^128 many''  ---  am i right here?
[17:58:48] <yawkat> no, it can generate one string, that has length 128bits
[17:59:07] <cvmn> length 2^128 bits?
[17:59:20] <yawkat> no, length 128 bits
[17:59:36] <cvmn> asymptotically?  
[17:59:54] <cvmn> i.e. stuck at repeating that single 128 bit output forever?
[18:00:10] <yawkat> idk what you mean by asymptotically
[18:00:45] <yawkat> if you output more than 128 bits, the output is not going to be uniformly random anymore
[18:00:56] <yawkat> (assuming uniformly random input of 128 bits)
[18:01:20] *** Joins: powftw (uid448161@id-448161.lymington.irccloud.com)
[18:05:34] <gurkenglas> cvmn, at least half of all 129-bit strings are impossible to generate with a given pseudorandom number generator that takes a seed of length 128, yes?
[18:05:44] *** Joins: Guyver2__ (Guyver@guyver2.xs4all.nl)
[18:08:33] *** Quits: Guyver2_ (~Guyver@guyver2.xs4all.nl) (Ping timeout: 248 seconds)
[18:08:49] <cvmn> gurkenglas: that's my intuition, but not sure if i'm asking the right question, or if seeing it right.
[18:08:51] <cvmn> i'll rephrase:  a csprng with 128 bits internal state, and a seed that's choosen totally randomly:  how many bits can it generate before we tell the csprng ``ok, you can no longer be truly random any more''.
[18:08:53] <cvmn> ?
[18:09:58] <river> a random number generator with n-bits of state can produce a cycle of length 2^n (at best)
[18:10:54] <gurkenglas> you can have random number generators that don't literally cycle their output if you allow their state to grow
[18:10:55] <river> LFSR's exist that go through 2^n − 1 states (everything except 0)
[18:10:59] <gurkenglas> *pseudo
[18:12:18] *** Joins: ivii (~ivan@user/ivii)
[18:13:32] <gurkenglas> cvmn, one can try to rule out adversaries that have a lookup table containing all the strings your csprng can output depending on different seeds by bounding the ressources of the adversary
[18:15:01] *** Joins: BOKALDO (~BOKALDO@user/bokaldo)
[18:19:45] <yawkat> cvmn: a generator with 128 bits input can produce 128 bits of random output. anything beyond that might be "indistinguishable from random", but it wont be uniformly random anymore.
[18:20:54] <river> if we define an RNG to have internal state S, and operate by producing a bitstring based on that state & mutating the state .. it will loop after at most |S| invocations
[18:20:54] *** Quits: platta (~platta@pool-98-110-52-37.cmdnnj.fios.verizon.net) (Quit: The Lounge - https://thelounge.chat)
[18:21:14] *** Quits: llorllale (~llorllale@198.98.119.85) (Ping timeout: 268 seconds)
[18:21:40] <yawkat> river: you cannot say however how long that output will be after |S| invocations. if each invocation outputs 100000 bytes, it can be much longer than 2^|S|
[18:22:03] <yawkat> you could throw a busy beaver at it.
[18:23:05] *** Joins: platta (~platta@pool-98-110-52-37.cmdnnj.fios.verizon.net)
[18:24:59] <river> i dont understand
[18:25:14] <river> the output should always be the same length, e.g. 1 bit
[18:26:03] <TimMc> Probably easiest to assume it produces 1 bit per invocation, for this discussion.
[18:26:17] <yawkat> sure, if you introduce that limitation, then you can calculate the maximum output length
[18:26:50] <gurkenglas> river, your argument works for any algorithm with bounded state, so why not allow the algorithm to access space logarithmic in the amount of bits it's supposed to produce
[18:27:45] <gurkenglas> in practice we do have logarithmic-in-time amounts of space available :P
[18:28:21] <gurkenglas> every time our timestamps hit the maximum representable number we expand the space allocated to timestamps
[18:30:21] <iz> is there even anything in discrete mathematics that ever happens asymptotically?
[18:30:32] *** Joins: halosghost (~halosghos@user/halosghost)
[18:36:46] <river> yes prime counting function is O(x/log(x)) for example
[18:38:46] <iz> oh yeah, i guess anything going to infinity
[18:40:45] *** Quits: ivii (~ivan@user/ivii) (Remote host closed the connection)
[18:43:16] <Soni> at what point do you get to call yourself a cryptographer?
[18:45:30] <iz> you can call yourself whatever you want -- it's just a question of if other ppl scoff or nod in agreement
[18:54:09] <cvmn> Soni: i call myself chief crypto visionary.
[18:54:31] <river> lol
[18:57:05] *** Joins: Guyver2_ (~Guyver@2001:985:f3f:1:193e:e7da:78e5:da62)
[18:57:22] <cvmn> a seed csprng had 128 bit state, and was used to make 2^128 many bits.  then, the same csprng extended its own internal state's memory size into 129 bits (i.e. 1 bit extra), can it now theoretically produce one more 2^128 bits (i.e. 2^129 total)?
[18:57:24] <Soni> does "making an IRC client with built-in OTR that isn't completely wrong" make one a cryptographer?
[18:58:14] *** Quits: gurkenglas (~gurkengla@dslb-178-012-018-212.178.012.pools.vodafone-ip.de) (Ping timeout: 268 seconds)
[18:58:37] <cvmn> did he make the encryption algorithm?  or did he only use a library?
[18:59:00] <halosghost> note that I do not feel that anyone should refer to me as a cryptographer: I don't think that would be enough to be considered a cryptographer
[18:59:48] *** Quits: gabriel1 (~gabriel1@user/gabriel1) (Read error: Connection reset by peer)
[19:00:02] <cvmn> omnicryptotent.
[19:00:05] <halosghost> in my mind, formal training or a proven record of cryptographic work are required (where proven record would involve significant contribution to cryptographic papers, or X years/projects of work that are heavily cryptographically-focused (where X is some number >2 that I haven't figured out)
[19:00:05] *** Quits: Guyver2__ (Guyver@guyver2.xs4all.nl) (Ping timeout: 268 seconds)
[19:00:16] <halosghost> )
[19:01:44] <cvmn> imo if the hypothesis that you're a cryptographer has a p value is less than 0.05, then it's safe by the standards of computer science to reject the null hypothesis that you're a not a cryptographer.
[19:02:19] <cvmn> maybe, less than sigma-5, then physicists would accept that you're not a non-cryptographer.
[19:02:59] *** Quits: joe7057 (~joseph@wnpgmb016qw-ds01-2-119.dynamic.bellmts.net) (Ping timeout: 260 seconds)
[19:03:03] <halosghost> cvmn: I can't tell if that phrasing is just messing with me, but the way my brain is parsing that is that you're suggesting that the default assumption is that everyone is a cryptographer
[19:03:20] <halosghost> which isn't necessarily wrong, but I suspect isn't a widely-shared belief
[19:04:24] <cvmn> the default is that everyone is not a cryptographer, but anything else, that maybe got lucky by sheer dumb luck to sound like a cryptographer in some lucky moment.
[19:04:36] <cvmn> ^ null hypothesis.
[19:04:55] <cvmn> once we reject the null, what's left is that yer a cryptographer.  or, as i said it "not a non-cryptorapher".
[19:07:07] *** Quits: dusk (~quassel@suki.ds7s.nl) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
[19:07:11] <cvmn> repeating unanswered question: a seed csprng had 128 bit state, and was used to make 2^128 many bits.  then, the same csprng extended its own internal state's memory size into 129 bits (i.e. 1 bit extra), can it now theoretically produce one more 2^128 bits (i.e. 2^129 total)?
[19:07:20] *** Joins: dusk (~quassel@suki.ds7s.nl)
[19:07:40] <TimMc> Assumption is one bit output per invocation?
[19:07:59] <cvmn> yes
[19:08:33] *** Joins: byteskeptical (~amnesia@user/byteskeptical)
[19:08:47] <yawkat> sure why not
[19:09:06] <TimMc> I suppose it's possible. If the 2^129 algorithm with the extra bit set to zero is identical to the 2^128 algorithm, then yes... as long as that extra bit stays set to 1 after the transition. :-P
[19:09:21] <yawkat> (assuming csprngs exist ofc)
[19:09:46] <TimMc> I've never *seen* one 🤔
[19:10:11] <TimMc> If it's a totally different algorithm, then maybe you get another 2^129 instead.
[19:10:37] <TimMc> You can try playing around with some toy CSPRNGs with just 3 bits, then adding a 4th bit, just to build intuition.
[19:10:49] <cvmn> even if i initially selected the seed randomly from a space of 2^128?
[19:10:56] *** Quits: igemnace (~ian@user/igemnace) (Remote host closed the connection)
[19:11:27] <yawkat> sure, assuming csprngs exist
[19:11:51] <cvmn> csprngs are not known to exist?
[19:12:00] <yawkat> they dont if P=NP at least
[19:12:05] <halosghost> for my own clarity, is the use in specifying the assumption that csprngs exist specifically about the “cs”?
[19:12:19] <MacGyver> TimMc: I'd answer no, considering the stated order of events.
[19:12:33] <MacGyver> You can predict one bit of the state in that case.
[19:13:41] <TimMc> Sorry, brain fart.
[19:14:03] <TimMc> "Stays 1" doesn't make any sense, does it. All the state bits are mutable and dependent on previous state.
[19:14:43] <halosghost> (I mean, we definitely know that PRNGs exist, it's about whether or not those PRNGs can be cryptograhpically-secure, right?)
[19:14:44] <MacGyver> Yeah, in your description that bit is just an algorithm selector for which cycle you want.
[19:15:24] <MacGyver> So you don't expand the state, in effect you just use a different algorithm.
[19:15:52] <MacGyver> I'd start to get worried *way, way before* 2^128 bits have been output, btw.
[19:16:25] <cvmn> a csprng with a 128bit internal state, as it is producing random output bits, bit by bit, any idea how much of its entropy is reducing every time it outputs a bit?  say, an adversary is monitoring those outputted bits one by one, and trying to intelligently figure out csprng's internal state: how much information gain would adversary gain per bit that he gets?
[19:16:45] <MacGyver> cvmn: "Reducing entropy" may not be the right term, but yeah, that's the problem.
[19:17:14] <TimMc> Depends on whether you allow the adversary the ability to reverse engineer the state from the outputs.
[19:18:40] <yawkat> a problem here is that if you consider 2^|N| output, your adversary starts to have so much computing power (if she can scan the output), that she can simply reverse the CSPRNG state as is.
[19:18:55] <yawkat> if you give your adversary O(2^n) then ofc your csprng will not survive
[19:20:14] <MacGyver> I'd want to just hedge my bets and reseed before the birthday bound is reached.
[19:21:11] <cvmn> yawkat: what if P=NP, will the adversary still need O(2^n)?
[19:21:15] *** Joins: hqdruxn08_ (~hqdruxn08@user/hqdruxn08)
[19:21:42] <yawkat> if P=NP the definition for csprng goes down the drain
[19:21:55] *** Quits: chiselfuse (~chiselfus@user/chiselfuse) (Ping timeout: 240 seconds)
[19:21:58] <int-e> well... it might still be impractical
[19:22:12] <int-e> but sure, the definition fails.
[19:22:28] <TimMc> "Watch out for that constant factor, it's a doozy"
[19:22:54] <int-e> we'd need a new way to over-approximate feasibility, different from P
[19:23:05] <cvmn> yawkat: but with P=NP, what's the maximum number of truly random bits can a machine produce?
[19:23:42] <TimMc> None.
[19:23:48] *** Joins: gurkenglas (~gurkengla@dslb-178-012-018-212.178.012.pools.vodafone-ip.de)
[19:23:53] <TimMc> Same for P!=NP, though.
[19:24:04] *** Joins: chiselfuse (~chiselfus@user/chiselfuse)
[19:24:14] <cvmn> nitpick?
[19:24:25] <TimMc> Not really.
[19:24:38] <cvmn> i was thinking:  a csprng is a machine that's producing output based on some internal state.
[19:24:45] <TimMc> I suspect the correct question formulation would be probabilistic.
[19:24:57] <TimMc> how fast the attacker can determine the internal state
[19:25:00] *** Quits: hqdruxn08 (~hqdruxn08@user/hqdruxn08) (Ping timeout: 240 seconds)
[19:25:29] <MacGyver> cvmn: TimMc is pointing to your use of the words "truly random" as something a machine can *produce*.
[19:26:04] <halosghost> are there cstrngs?
[19:26:21] <halosghost> (or is that still subject to “CS” being assumed-to-exist?)
[19:26:30] <river> ??
[19:26:35] <MacGyver> Defining what is "truly random" is hard, and unsettled in physics afaik.
[19:26:47] <MacGyver> You don't *need* "cstrngs".
[19:26:51] <TimMc> I'll grant a truly random seed state, though.
[19:27:09] <MacGyver> The whole point of the cryptographically secure is that you only need "cryptographically secure" randomness.
[19:28:07] <yawkat> i am very happy with the "physically unpredictable" definition of trng, which physics is fairly certain about, despite philosophical arguments about what constitutes randomness
[19:28:30] <MacGyver> And the definition of cryptographically secure is something along the lines of "indistinguishable from random noise (with advantage smaller than epsilon)".
[19:28:54] <MacGyver> The issue with outputting 2^128 bits from an RNG algorithm, if you *don't* reseed, is that it *does* become distinguishable from random noise.
[19:29:21] <MacGyver> (Not every RNG algorithm, but anything based on a block cipher, for example)
[19:31:22] <MacGyver> And that's why CSPRNG designs like Fortuna explicitly reseed way before you ever reach the point where that becomes a concern.
[19:32:06] <river> ah yeah, and getentropy is constantly reseeding
[19:34:12] <halosghost> MacGyver: that's helpful clarification thank you; put another way “CSPR” is less-strong of a requirement than “TR”
[19:34:44] <halosghost> MacGyver: so then, TRNGs that exist are also theoretical (in the same way that one-way functions are)?
[19:35:00] *** Quits: chomwitt (~chomwitt@2a02:587:dc1b:d600:c3a8:b4dc:b642:1f2) (Ping timeout: 240 seconds)
[19:35:22] <MacGyver> halosghost: I don't know enough about the state of physics to answer whether we can extract true randomness from half-life events and the like.
[19:35:39] <halosghost> that seems fair ☺
[19:36:10] <MacGyver> halosghost: But if we can, you'd probably still want whitening.
[19:36:31] <cvmn> rephrased question:  suppose that a machine M was given 128 bits of entropy as input (somehow, let's assume physical randomness is possible).  M keeps producing output one bit a time, that's also being analysed by an adversary.  my question is: what's the maximum number of output bits can M produce before the adversary concludes ``entropy of the question "what's the next bit out of M going to be?"
[19:36:33] <cvmn> is zero''?
[19:38:23] <cvmn> the machine itself is publicly known.  the only part that's not known is the 128 bits of entropy that it was given as input initially.
[19:39:47] *** Joins: [itchyjunk] (~itchyjunk@user/itchyjunk/x-7353470)
[19:39:51] <halosghost> cvmn: wouldn't the better threat model (and the thing I beleive MacGyver is referring to about the birthday bound) be when the attacker begins to have better-than-coinflip odds of guessing the next bit?
[19:40:38] <MacGyver> cvmn: That's going to depend a lot on the algorithm used. E.g. if it's a PRP, and you're outputting the 128-bit blocks just 1 bit at a time, an adversary can "just" keep track of all the blocks already seen and start guessing with better-than-negligible probability what the next bit in the current block is going to be. For the last block, trivially, even.
[19:40:56] <MacGyver> Without ever having to learn the internal state.
[19:42:13] <cvmn> that's a very baseline programe that simply outputs the 128 bits of entropy it was given as-is, right?
[19:42:27] <cvmn> s/m/mm/
[19:42:55] <MacGyver> No, I was thinking e.g. using the 128 bits of entropy as a key for AES and then just encrypt in counter mode.
[19:43:21] <MacGyver> (I'm pretty sure that results in a PRP but not 100%)
[19:45:46] <MacGyver> cvmn: The key aspect that makes this possible, and also breaks the indistinguishability requirement I mentioned, is that you never output the *same* 128-bit sequence twice.
[19:45:54] <MacGyver> cvmn: Whereas *true* randomness would.
[19:46:21] <MacGyver> So the adversary can just discard all options already seen and only select from those not yet seen.
[19:47:45] <MacGyver> At some point this makes their probability of guessing correctly non-negligible, "greater than epsilon", "better than a cointoss".
[19:48:27] <MacGyver> Similar thing happens if you only use a single, but fixed, bit from each block.
[19:48:53] <MacGyver> Because in that case you'd run through all possible 2^128 *possible* outputs.
[19:49:10] <MacGyver> Half of which would have that bit on 1 and half of which on 0.
[19:49:33] <MacGyver> So the adversary can literally count the 1-bits seen and count the 0-bits seen and guess the one *less* seen for every next bit.
[19:49:40] <MacGyver> That'll give them a non-negligible advantage.
[19:50:42] <MacGyver> So... in general, your question isn't answerable for every possible RNG algorithm, but it's generally considered safe to re-seed before 2^(n/2) bits are generated.
[19:51:30] <MacGyver> Because that's where we expect to start seeing non-negligible advantages at distinguishing from random noise.
[19:52:02] <MacGyver> And most practical algorithms err on the side of caution and reseed *way* before that still.
[19:54:55] <gurkenglas> cvmn: if given random seed n < 2^128 you can output n 1s and then 0s forever, and then there if the adversary sees 2^128-2 1s then he doesn't know what the next bit is
[19:56:22] <TimMc> I think the question you want is: "After how many operations can an attacker who can spend 2^N operations guess the next bits with better than .5 + epsilon accuracy" where you choose epsilon to be some threshold of unacceptability.
[19:56:34] *** Joins: fanis30 (~anon@adsl-153.37.6.0.tellas.gr)
[19:56:39] <TimMc> and where you choose N based on your guess as to their capabilities
[19:58:30] <TimMc> For example, if you have an attacker with 2^128 computation available to them, they can just iterate through the entire list of possible states and find out which ones would have the initial outputs that your RNG is outputting, then guess by choosing among those.
[19:58:30] <gurkenglas> I think the question you want is "if Alice thinks every bit is independently 50% and will take any kelly bet Bob offers her, how quickly can Bob take her money?"
[20:04:10] <gurkenglas> If Charlie has infinite compute but no true randomness, do we have a strategy for him to turn n true-random bits into k>n bits that Donald, who doesn't have infinite compute, can't tell from k true-random bits?
[20:04:49] *** Quits: wsb (~wsb@user/wsb) (Remote host closed the connection)
[20:05:34] *** Quits: fanis30 (~anon@adsl-153.37.6.0.tellas.gr) (Quit: WeeChat 3.3)
[20:05:36] <MacGyver> (We do, every modern encryption algorithm under the sun depends on that)
[20:05:45] <gurkenglas> Can we prove that?
[20:05:49] <MacGyver> (But *not* 2^k where k>n)
[20:05:50] <edk> nope
[20:06:06] *** Quits: davutz (~davutz@d-138-207-232-76.paw.cpe.atlanticbb.net) (Ping timeout: 260 seconds)
[20:06:43] <gurkenglas> Do you predict that the Charlie-has-infinite-compute assumption doesn't help to prove that?
[20:07:13] <edk> anyone with infinite compute can obviously see through any apparent entropy increase
[20:07:33] <gurkenglas> edk, Charlie is the dude that *produces* the pseudorandom numbers
[20:07:44] <edk> oh right, oops
[20:07:46] <edk> no it doesn't help
[20:07:56] <cvmn> MacGyver: what if the blocksize dynamically changes based on things like initialisation vector?
[20:08:12] *** Joins: davjutz (~davutz@d-138-207-232-76.paw.cpe.atlanticbb.net)
[20:08:22] <river> if you have infinite computing power (which is impossible), you could run every sequence prediction algorithm on a sequence and pick the least common result every time
[20:08:45] <MacGyver> cvmn: I don't think that'd help you.
[20:09:10] <cvmn> <gurkenglas> cvmn: if given random seed n < 2^128 you can output n 1s and then 0s forever, and then there if the adversary sees 2^128-2 1s then he doesn't know what the next bit is   <--- at that point, will the adversary say ``1 bit of entropy is left''?
[20:09:35] <gurkenglas> cvmn: yeah. (assuming he knows your algorithm)
[20:10:03] <cvmn> MacGyver: won't that help against the adversary figuring out the boundaries to identify patterns that won't happen?
[20:11:12] <MacGyver> cvmn: I'm not sure how such an algorithm would even work in the first place. Which bit are you going to select? Can't we still map this into a fixed-blocksize space?
[20:11:43] <MacGyver> Instinctively you'd want to "select the bit at random" but how are you going to do that...
[20:12:05] <cvmn> i.e. if a block size is 128 bits, then we know that the 1st 128 bits will never repeat (if prp).  but if we vary the block size, e.g. sometimes 1 bit, sometimes 5, sometimes 1 megabits, etc, then the adversary won't be easily able to tell if a repeating pattern is within-block or inter-block?
[20:12:24] <edk> river: i am not sure if that's a well-defined thing to do given it's not computable whether a given algorithm is a sequence prediction algorithm
[20:12:46] <river> the point is its not computable
[20:12:48] <cvmn> in this case, block size varies at run-time, and the current block size is not revealed to the adversary, as the programme still outputs 1 bit at a time.  so information about the block size is secret, and is derived from the 128 bits of input entropy.
[20:13:32] <MacGyver> cvmn: Hmright, but how are you going to expand the 128 bits of input entropy into more than 128 bits of a block?
[20:13:52] <MacGyver> cvmn: I think you might just be moving the problem.
[20:13:53] <gurkenglas> edk: uncomputable doesn't imply not well-defined; also you can just pretend the program is a sequence prediction algorithm, if that makes you interpret its outputs as garbage it is apparently a bad sequence predictor
[20:14:05] <edk> gurkenglas: but you still have to use it
[20:14:17] <edk> uncomputable does imply that you can't use it just because you have infinite computation
[20:14:48] <gurkenglas> edk: oh, right. this is plenty computable though.
[20:15:09] <gurkenglas> You just run all the algorithms (exponentially many of those) for as long as whatever bound we placed on Donald
[20:16:44] <gurkenglas> wait, infinitely many of those. um. you can increase the maximum length of the possible Donald's you try as the sequence continues.
[20:17:10] <gurkenglas> then whatever program Donald uses is only gonna have a finite time within which to be not-yet-modelled by Charlie
[20:18:04] <edk> it doesn't really matter if donald is modelled by charlie since charlie is going to get every possible result
[20:18:34] <gurkenglas> actually we can bucket together all the infinitely many possible donalds into equivalence classes based on whether the donalds do the same thing within the first donald-bound many steps
[20:19:02] <river> although, i should say - hypercomputation is by no means logically inconsistent
[20:19:20] <river> its just stratified by turing jumps
[20:19:38] *** Quits: mad_enz (~mad_enz@lnsm4-toronto12-50-101-118-206.internet.virginmobile.ca) (Ping timeout: 272 seconds)
[20:20:11] <gurkenglas> since donald can't leave a merely exponentially large set of lines of code given a linear amount of if conditions
[20:21:16] *** Joins: joe7057 (~joseph@wnpgmb016qw-ds01-2-119.dynamic.bellmts.net)
[20:21:57] <gurkenglas> in other words: Charlie runs a deterministic simulation of a nondeterministic automaton that simulates charlie by guessing what the line of code that he's about to jump to says, if he hasn't visited it before
[20:22:10] <gurkenglas> s/that simulates Charlie/that simulates Donald :(
[20:22:26] <edk> you can bucket them based on what they do in all the time donald is allowed, i'm not sure about the rest of it or that you'll get a useful result
[20:22:37] *** Joins: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net)
[20:22:48] *** Joins: mad_enz (~mad_enz@lnsm4-toronto12-50-101-118-206.internet.virginmobile.ca)
[20:23:26] *** Quits: Church (~aleph@68.161.207.188) (Ping timeout: 272 seconds)
[20:23:39] *** Quits: ioxzev1z (~ioxzev1z@user/ioxzev1z) (Quit: Leaving)
[20:24:36] <cvmn> MacGyver: here is 1 thought:  we use a normal block cipher to generate B many blocks (but without sending them.  rather storing them in memory to accumulate, say, 1 megabits).  those B may blocks are the stacked to form a square (a matrix).  then (an)other block(s) is made to generate enough bits to wrap around the X and Y axis of the matrix (with B blocks in it); let's call this extra block, block
[20:24:38] <cvmn> Z.
[20:24:40] <cvmn> then, think of the X and Y axis as coordinates (from block Z), and wherever such coordinates meet with with (1,0) or (0,1), clip that bit in the B blocks.  this way, half of the bits in the B blocks will flip based on the randomness in block Z.  
[20:24:42] <cvmn> then, send the B blocks bit by bit, and i think this way the adversary will not be able to identify a repeating boundary of 128 bit block size.
[20:25:50] *** Quits: byteskeptical (~amnesia@user/byteskeptical) (Remote host closed the connection)
[20:26:07] <cvmn> imo, assuming the block cipher is secure, this will give us the effect of arbitrarily varying the block size, without actually varying the block size.
[20:27:35] <cvmn> if block Z doesn't have enough bits to wrap around as X and Y coordinates around the B blocks, i think we can simply recursively repeat the process:  to form bigger blocks, and then use multiples of such bigger blocks to create bigger ones.  :D
[20:29:23] <cvmn> i.e. after completion, we can consider those B many blocks (that got their bits flipped by the X and Y axis that were made from block Z), to bet a bigger single block, then it to repeat that process again (except with the larger blocks)
[20:29:47] <gurkenglas> let's try again. Charlie has infinite compute and wants to present bounded Donald with a "random" string of length k given n random bits. Charlie doesn't know what the first line of Donald's program is, so he guesses it from among all the possibilities. He runs each Donald-possibility until the bound and then sees what policies Donald came up with, assuming Donald halted. Charlie does this for all 
[20:29:53] <gurkenglas> (length-n string -> length-k string) functions he could use, then selects the one that minimizes the maximum of average Donald performances. I note that I don't know whether that minimization gets anywhere... but at least I know that *if* there is a solution, this Charlie-strategy finds it :S
[20:34:45] *** Joins: byteskeptical (~amnesia@user/byteskeptical)
[20:38:37] <TimMc> Hmm. I just realized that a machine with finite memory has a limit to how many digits of pi it can compute.
[20:39:14] *** Joins: tuskkk____ (uid18470@id-18470.tinside.irccloud.com)
[20:39:40] <TimMc> Pi is irrational; its expansion never repeats. But a finite system always repeats.
[20:41:19] <halosghost> indeed
[20:42:49] <TimMc> I guess this is just a specific case of uncomputable numbers.
[20:43:33] <river> yes finite memory fundamentally means any sequence the thing produces will repeat
[20:44:10] <river> it's not uncomputable though, pi is computable - you just need more memory to compute more of it
[20:44:13] <TimMc> (Or hmm, is this different? Uncomputable numbers are because there are a finite number of finite *programs*, even if they have unbounded memory...)
[20:44:17] <TimMc> yeah
[20:44:33] <int-e> TimMc: yeah that's it
[20:44:47] <int-e> welll, s/finite/countable/
[20:47:15] <TimMc> Heh. An infinite program could compute an irrational number. :-)
[20:47:24] <TimMc> just hardcode it
[20:47:34] <int-e> TimMc: s/// only affects the first occurrence :P
[20:48:07] * TimMc nods
[20:48:17] <int-e> TimMc: more interestingly there's also a gap between the (countably many) numbers that we can define and those that we can compute. https://en.wikipedia.org/wiki/Chaitin's_constant is an example.
[20:48:25] <halosghost> this reminds me that I want to poke around with the constructive reals again
[20:49:06] <int-e> (well, unless you go the constructivist route, of course)
[20:50:39] *** Quits: powftw (uid448161@id-448161.lymington.irccloud.com) (Quit: Connection closed for inactivity)
[21:04:03] *** Joins: dez (uid92154@user/dez)
[21:09:14] *** Quits: andreasbuhr (~quassel@p549dbec6.dip0.t-ipconnect.de) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
[21:10:01] *** Joins: Gallomimia (~Gallomimi@node-1w7jra2a2gqpzhrjfcgw2b8an.ipv6.telus.net)
[21:15:02] *** Quits: Haohmaru (~Haohmaru@195.24.53.110) ()
[21:19:29] *** Quits: MajorBiscuit (~MajorBisc@c-001-003-047.client.tudelft.eduvpn.nl) (Ping timeout: 248 seconds)
[21:20:11] <TimMc> I kinda do. I don't really trust the reals.
[21:20:36] <halosghost> lol
[21:21:08] <wasamasa> conquest of the irrational
[21:21:55] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Ping timeout: 240 seconds)
[21:22:04] <river> you're wise not to
[21:22:47] *** Quits: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
[21:23:06] <river> although constructive reals never seemed all that much better to me
[21:24:37] *** Joins: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net)
[21:27:02] *** Quits: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net) (Client Quit)
[21:28:40] *** Joins: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net)
[21:29:21] *** Quits: Alina-ma- (~Alina-mal@37.252.83.224) (Quit: !be back soon)
[21:30:14] *** Joins: Alina-malina (~Alina-mal@user/alina-malina)
[21:39:00] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[21:43:58] <nsh> int-e raises [unwittingly] the very good and seldom-appreciated point that while the real number field or continua in general can be well-defined they are not constituted of well-defined elements
[21:44:19] <nsh> which is exactly the crux of many problems in mathematical foundations
[21:45:10] <int-e> it's a feature, not a bug
[21:46:40] *** Joins: chomwitt (~chomwitt@2a02:587:dc19:3600:aabd:edaf:cb83:4282)
[21:46:42] <nsh> the former for the existence of calculus, the latter for didactics :)
[21:47:38] <nsh> we should be unable to formulate the notion of "each" or "next" or "last" wrt to reals
[21:47:45] <nsh> but we still find ourselves prone to
[21:48:02] *** Joins: sobkas (~sobkas@95.175.17.217)
[21:48:14] <nsh> even the guys who proved the most celebrated results pertaining thereto have done
[21:48:33] *** Joins: zer0bitz (~zer0bitz@2001:2003:f750:a200:d52e:866a:6f3a:60a1)
[21:49:13] <nsh> although forgivably as in contradictions - diagonalisation proofs for example
[22:00:46] *** Quits: aleck (~aleck@user/aleck) (Ping timeout: 268 seconds)
[22:11:26] *** Joins: gabriel1 (~gabriel1@user/gabriel1)
[22:19:15] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Ping timeout: 240 seconds)
[22:27:35] *** Joins: caveman (~caveman@gateway/tor-sasl/caveman)
[22:34:01] *** Joins: Tangent-Man (~Tang3nt-M@mutantalien.plus.com)
[22:35:48] *** Quits: Tangent-Man (~Tang3nt-M@mutantalien.plus.com) (Remote host closed the connection)
[22:36:13] *** Joins: Tangent-Man (~Tang3nt-M@mutantalien.plus.com)
[22:52:35] <river> dude
[22:52:41] <river> sha256sum tool can't take a list of files?
[22:52:45] <river> this tool is so fuking annoying!
[22:53:12] <river> im just doing sha256sum $(find .. ) instead but why
[22:53:35] *** Quits: Sofia (~sofia@user/sofia) (Ping timeout: 240 seconds)
[22:53:52] <MacGyver> It can?
[22:53:57] <river> whats the flag?
[22:54:32] <int-e> you can use  xargs
[22:54:54] <MacGyver> river: -c.
[22:55:07] <MacGyver> river: What's the format you're trying to give your list in as?
[22:55:18] <river> oh I guess -c -
[22:55:28] <river> thanks
[22:55:40] <river> I saw that but didn't think hard enough
[22:55:41] <int-e> oh for checking
[22:55:55] <river> format is just the output of find, one path per line
[22:56:13] <MacGyver> Just use a glob for that?
[22:57:18] <river> i cant replace find with a glob
[22:57:40] *** Joins: MajorBiscuit (~MajorBisc@86-88-79-148.fixed.kpn.net)
[22:58:54] <MacGyver> Then `find whatever -exec sha256sum {} \;`
[22:59:06] <MacGyver> Or the expansion of find's output as you're already doing.
[22:59:40] <MacGyver> int-e: I'd assumed for checking, yes, but apparently it's also for initial computation.
[22:59:52] <MacGyver> If the format is the output of find directly.
[23:00:12] *** Joins: gproto23 (~gproto23@user/gproto23)
[23:02:35] <caveman> is, say, aes np-complete?
[23:03:18] <iz> if it were, it would take too long to encrypt anything
[23:03:31] <int-e> MacGyver: hmm, doesn't seem to work for me.  find -name '*.c' -print0 | xargs -0 sha256sum  does.
[23:04:06] <MacGyver> int-e: Find's exec syntax is notoriously hard to get right.
[23:04:31] <MacGyver> int-e: -exec sha256sum {} \; -- the {} is where the filename gets replaced, the \ before the ; is important.
[23:05:08] <MacGyver> int-e: But sure, a pipe into xargs works just the same.
[23:05:44] *** Quits: MajorBiscuit (~MajorBisc@86-88-79-148.fixed.kpn.net) (Ping timeout: 246 seconds)
[23:06:01] <int-e> MacGyver: 1) I can never remember the fine points of -exec. 2) xargs spawns only one subprocess as long as things fit in a single command line
[23:06:43] <MacGyver> int-e: 2) find does that as well if you use \+ instead of \;.
[23:06:45] <int-e> I just look at the manpage of `find` if `xargs` doesn't do the trick.
[23:06:53] <MacGyver> But yes, that is one of the finer points :P
[23:07:12] <iz> xargs.. until the file names have spaces :b
[23:07:26] <MacGyver> iz: That's why you use -print0 and xargs -0.
[23:07:33] <int-e> MacGyver: Thanks, I didn't know that `find` has that ability.
[23:07:35] <iz> oh yeah
[23:07:38] <int-e> (evidently)
[23:07:38] <MacGyver> (I'd argue that's also one of the finer points :P)
[23:07:43] <MacGyver> (All of this is fine points.)
[23:07:50] *** Quits: gurkenglas (~gurkengla@dslb-178-012-018-212.178.012.pools.vodafone-ip.de) (Read error: Connection reset by peer)
[23:07:50] <iz> i just use the -exec
[23:08:01] <iz> with its weird {} syntax
[23:08:07] <int-e> we all have our own habits :)
[23:08:08] *** Joins: gurkenglas (~gurkengla@dslb-178-012-018-212.178.012.pools.vodafone-ip.de)
[23:08:26] *** Joins: Sofia (~sofia@user/sofia)
[23:08:31] <iz> yeah, it's interesting to hear other ppl's variations
[23:08:55] <iz> sometimes i learn a better way to do something myself that way
[23:09:44] <int-e> with \+, `find` is the cleaner option... but the difference is marginal so I'm bound to stick to xargs.
[23:12:11] *** Joins: Klotz (~Klotzoman@gateway/tor-sasl/klotz)
[23:15:00] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[23:15:43] <MacGyver> caveman: re: is AES NP-complete: no.
[23:17:23] <MacGyver> caveman: AES is a finite family of finite-domain functions; even if I were to formulate your question a bit more formally asking "what is the worst-case time complexity of bruteforcing an AES key", that's *constant time* because there's no increase in input size.
[23:18:30] <MacGyver> (And a point symmetric key cryptography makes is to make that constant time infeasibly large)
[23:43:55] *** Quits: caveman (~caveman@gateway/tor-sasl/caveman) (Ping timeout: 240 seconds)
[23:46:50] *** Quits: geeknix (~pi@2001:e68:5432:af1f:781b:3d59:e4b7:2808) (Ping timeout: 268 seconds)
[23:55:11] *** Quits: lord| (~lordpipe@user/lordpipe) (Quit: https://i.imgur.com/xacQ09F.mp4)
[23:55:48] *** Joins: lord| (~lordpipe@user/lordpipe)
[23:55:52] *** Quits: BOKALDO (~BOKALDO@user/bokaldo) (Quit: Leaving)
[23:56:36] *** Joins: BOKALDO (~BOKALDO@user/bokaldo)
