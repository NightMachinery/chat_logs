[00:26:51] *** Quits: RoKenn (~RoKenn@user/rokenn) (Quit: NSA proxy service interrupted)
[00:49:31] *** Quits: ali1234 (~al@user/ali1234) (Remote host closed the connection)
[00:50:45] *** Joins: ali1234 (~al@user/ali1234)
[01:01:55] *** Joins: markong (~kvirc@213.146.188.203)
[01:08:49] *** Joins: bewees (~bewees@user/bewees)
[01:12:18] <bewees> Hi, did I use the std::move function correctly? https://dpaste.com/A4XLP6A94 I added std::move wherever I passed a value to an rvalue reference function to cast the lvalue to an rvalue. Not sure if this code is more efficient (because by passing things by value the compiler optimizes itself maybe better), but my goal was to learn how to use std::move correctly
[01:52:43] *** Quits: lionkor (~lionkor@beammp/staff/lionkor) (Quit: quit)
[02:21:50] <Alipha> bewees: it's pointless to move ints--moving and copying a primitive is the same cost
[02:22:15] <cbreak> bewees: the new on line 86 is nonsense
[02:22:56] <cbreak> the move on 87 is reasonable, if you want to move the value out of the object
[02:23:10] <Alipha> B2(std::string name, int i) : m_name(std::move(name)), m_i(i) {} // missed a move that would actually be useful
[02:23:37] <cbreak> line 43 makes no sense. Why a non-const ref?
[02:23:49] <cbreak> same for 53
[02:24:19] <cbreak> line 33 makes little sense. Why is the string an rvalue ref?
[02:24:57] <cbreak> line 31 makes no sense for the same reason as 53
[02:25:18] <Alipha> bewees: it's probably more important to understand const-correctness at this point than moving, as is somewhat a prerequisite
[02:25:45] <cbreak> yes.
[02:30:43] <Alipha> Line 33: there's no reason to make name be an rvalue ref because you never std::move(name). And there's no reason to std::move name anyway, because set_b_i only needs to observe name, as part of ==. set_b_i doesn't need to steal the contents of name
[02:34:20] <Alipha> And supposing i were a type where it would actually be meaningful to move (eg, a std::string), the std::move on line 38 would be incorrect because that std::move could happen more than once, and it only makes sense to move from an object once. The purpose of moving is to allow a function to steal resources, and so if set_i steals the resources of i, then i would be "empty"
[02:35:23] <Alipha> Unless you intend each object in m_b1 to have a unique name, but you don't enforce that anywhere
[02:37:41] *** Quits: Inline (~Inline@2a02:908:1252:7a80:e007:8711:e7b4:2641) (Ping timeout: 246 seconds)
[02:40:21] *** Quits: magla (~gelignite@55d47dc5.access.ecotel.net) (Quit: Stay safe!)
[02:45:59] *** Quits: PJBoy (~PJBoy@user/pjboy) (Ping timeout: 264 seconds)
[02:49:10] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[02:54:26] *** Joins: NovumDXW (~NovumDXW@113.91.34.220)
[02:54:42] *** Quits: spaceangel (~spaceange@ip-89-176-181-220.net.upcbroadband.cz) (Remote host closed the connection)
[02:59:57] *** Joins: andrea[m]123 (~andreanit@2001:470:69fc:105::1:28a8)
[03:06:22] <bewees> Thanks for the break down. @cbreak Why should I not use `new` in line 86, do you mean I should use simply `B2 b1("foo01", 11);`? If yes, why?
[03:06:45] <bewees> Alipha, As for line 90 `same cost for ints moving std::move(i1))` and line 33 making name rvalue ref I misunderstood a convention which
[03:06:45] <bewees> is used for objects, that says to apply std::move on ints too (even though it's not cost benefit), see: https://youtu.be/St0MNEU5b0o?t=1437
[03:06:45] <bewees> but in my case I don't have an object, but separate/dedicated parameters.
[03:08:05] <bewees> I think I got const refs now. I set line 43, 53 and 31 to a const ref. As long as the value is not changed inside the function const *should* be used. Any non const value the const gets then assigned to I can still modify later on as it copies the const value to a non-const std::string
[03:09:59] <bewees> Line 12 "`B2(std::string name, int i) : m_name(std::move(name)), m_i(i) {}` missed a move that would actually be useful". Didn't know I could use std::move without a rvalue ref, or do you mean I should add a rvalue ref to such as: `B2(std::string && name, int i) : m_name(std::move(name)), m_i(i) {}`. Let me fix the code first
[03:13:57] *** Quits: hsv1 (~weechat@gateway/tor-sasl/hsv-2) (Remote host closed the connection)
[03:14:20] *** Joins: hsv1 (~weechat@gateway/tor-sasl/hsv-2)
[03:14:59] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[03:19:43] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[03:20:36] <cbreak> bewees: yes. the new is worthless because you don't need dynamic storate duration
[03:20:51] <cbreak> allocate it with automatic storage duration as object
[03:21:02] <cbreak> that's more efficient
[03:21:07] <cbreak> and safer
[03:21:39] <bewees> Applied your suggestions https://dpaste.com/5GSQPH3CZ
[03:22:04] <cbreak> line 15, pass by value, not rvalue ref
[03:23:21] <cbreak> there are still several non-const refs
[03:24:31] *** Joins: X-Scale` (~ARM@92.250.98.212)
[03:25:05] <bewees> Line 15, pass by value, because I don't have overloaded functions? hmm
[03:26:14] *** Quits: X-Scale (~ARM@31.22.147.35) (Ping timeout: 260 seconds)
[03:27:03] *** X-Scale` is now known as X-Scale
[03:27:26] <cbreak> it's simpler that way, and more general
[03:27:29] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[03:27:40] <bewees> Hope I didn't miss something: https://dpaste.com/GUR2MXU4Z
[03:27:50] <bewees> Ah gotcha
[03:32:08] <cbreak> const value makes no sense
[03:32:17] <cbreak> when you pass by value, don't make the parameter const
[03:32:27] <cbreak> if you have a non-const value parameter, you can move from it
[03:32:38] <cbreak> if it is const, you can only copy
[03:34:09] <cbreak> there are basically four sane ways to pass parameters in c++: by value (a simple first choice for things that you want to own, or are cheap to copy), by const lvalue-ref for things you only want to observe, by lvalue-ref for things you want to mutate (out parameters)
[03:34:32] <cbreak> and by rvalue refs, for values you want to own, and are efficient to move
[03:34:47] <cbreak> almost always, the rvalue-ref option is combined with an other overload for const ref
[03:37:17] <bewees> " by const lvalue-ref for things you only want to observe" Those would be fine to use for copy too? So this should be fine?     B2(const std::string & name, const int & i) : m_name(std::move(name)), m_i
[03:39:51] <bewees> https://dpaste.com/AA4ST8FEG#line-14
[03:40:46] <bewees> Thanks, that's a pretty good summary when to use what. As for the rvalue refs I think it will take a while for me to get practice for it
[03:43:54] *** Joins: DarkTrick (~DarkTrick@pl-749-047.bunbun.ne.jp)
[03:44:01] <cbreak> you move it...
[03:44:57] <Alipha> bewees: you can't move a const object.
[03:48:00] <Alipha> { std::string s = "abcdefghijklmnopqrs"; std::string t = std::move(t); std::cout << "s=" << s << ", t=" << t; }
[03:48:00] <geordi> s=abcdefghijklmnopqrs, t=
[03:48:07] <Alipha> Oops
[03:48:14] <Alipha> { std::string s = "abcdefghijklmnopqrs"; std::string t = std::move(s); std::cout << "s=" << s << ", t=" << t; }
[03:48:15] <geordi> s=, t=abcdefghijklmnopqrs
[03:49:05] <Alipha> bewees: moving s into t means t is stealing s's data. You can't do that if s is const
[03:49:06] <bewees> Didn't know thanks. The int can stay const ref though? B2(std::string name, const int & i) : m_name(std::move(name)), m_i(i) {}
[03:49:58] <Alipha> bewees: sure, though it's cheaper to pass a simple int by value than by const reference
[03:51:56] <Alipha> << sizeof(int), sizeof(int*)
[03:51:57] <geordi> 4, 8
[03:52:21] <bewees> << sizeof(char), sizeof(char *)
[03:52:21] <geordi> 1, 8
[03:52:31] <bewees> So I do that for characters too 
[03:53:05] <bewees> << sizeof(std::string), sizeof(std::string *)
[03:53:06] <geordi> 32, 8
[03:54:13] <Alipha> I hate conflating references and pointers, but passing a `const int &` to a function is essentially the same as passing a const int* to it, on the machine code level, so passing a const int& is passing 8 bytes whereas passing an int is only passing 4 bytes
[03:57:28] <bewees> Gotcha, I guess this applies also to const char& or const std::string&, both would be in analogy using 8 bytes for their ref like their pointer counterparts
[04:00:02] <Alipha> bewees: though copying a std::string means copying the data it holds, so if the std::string contains a 1 million character string, you're copying 1 million bytes
[04:01:14] <Alipha> But also note that "passing by value" doesn't necessarily mean "passing by copy"--you can also move instead.
[04:01:49] <bewees> Right, how you suggested above in the B2 constructor
[04:02:08] <Alipha> If you have `void foo(std::string str);` and you call it like `foo(std::move(s))`, then s is moved into str, not copied
[04:02:54] <Alipha> (same for constructors)
[04:04:17] <bewees> `B2(std::string name, int i) : m_name(std::move(name)), m_i(i) {}; B2("foo", 10);` Here "foo" is moved from name to m_name, so it's still one copy from the instantiation to the method, and only from there it's moved right?
[04:05:28] <bewees> "foo" copied to lvalue name and name moved to m_name
[04:07:26] *** Quits: DSpider (DSpider@2a02:2f00:1ff:ffff::646c:6a26) (Quit: Leaving)
[04:12:24] <bewees> Got it "call it like `foo(std::move(s))`, then s is moved into str, not copied"
[04:13:10] <bewees> As "foo" is an rvalue it's moved already, but if I have it in a separate string I have to additionall use std::move to cast it to an rvalue and it's then moved to str
[04:16:11] <bewees> The only reason where I see that passing by rvalue ref is useful is when you need an overloaded const ref at the same time. Else you could just pass by value and move stuff to there
[04:16:17] <Alipha> "foo" copied to lvalue name and name moved to m_name--yes, the characters "foo" are copied because the string(const char *) constructor is called, and that's what that constructor does
[04:17:58] <Alipha> Yes, most of the time you should either pass by value or by const ref. You would generally only pass by rvalue ref if you want ownership transfer semantics, eg, std::unique_ptr
[04:19:10] <bewees> So if people work with big strings, there's no way around pointers, to spare the extra copy to the lvalue within the method
[04:20:59] <bewees> Or big objects in general*
[04:21:31] <Alipha> std::string wants to own the character string. So if the constructor accepts a std::string and the caller doesn't have a std::string to give it, then a std::string must be constructed, which will involve copying from the character array
[04:22:37] <Alipha> `B2("foo", 10);` here, "foo" is not a std::string, so a std::string must be created
[04:24:10] <bewees> Ah, so if it's already created, say `std::string s="something"; B2(std::move(s), 10);` then it would just move it to the method's lvalue
[04:24:23] <Alipha> bewees: correct
[04:24:50] <bewees> Thanks! Going to write down my mistakes to not forget it :-)
[04:25:03] <Alipha> s is moved into name and then name is moved into m_name
[04:25:25] *** Quits: shailangsa (~shailangs@host217-39-45-200.range217-39.btcentralplus.com) (Remote host closed the connection)
[04:26:08] <Alipha> If it was absolutely vital to performance, you could reduce that to only one move instead of 2 by having B2 accept a std::string&& instead
[04:26:41] <Alipha> In which case, you would probably want to overload on const std::string& too
[04:27:16] <Alipha> But that involves writing twice as many constructors, so it's just simpler to pass by value unless performance is of utmost importance
[04:29:19] <bewees> That's answered my above question, so now I know when to use rvalue ref, to spare a consecutive moves and make one (if that performance is really needed)
[04:31:13] <bewees> Maybe some people have chained methods that move two 3-4 objects, so if they'd use everywhere rvalue refs and need good performance they could make from 4 move actions 1
[04:31:31] <bewees> s/two/to/
[04:32:51] <bewees> that move an object through 3-4 objects*
[04:42:22] *** Quits: markong (~kvirc@213.146.188.203) (Ping timeout: 260 seconds)
[04:47:29] *** Joins: shailangsa (~shailangs@host217-39-45-200.range217-39.btcentralplus.com)
[05:01:25] *** Joins: night_wulfe_ (~wulfe@cpe-174-103-156-213.cinci.res.rr.com)
[05:05:06] *** Quits: night_wulfe (~wulfe@cpe-174-103-156-213.cinci.res.rr.com) (Ping timeout: 245 seconds)
[05:05:52] *** Quits: NovumDXW (~NovumDXW@113.91.34.220) (Read error: Connection reset by peer)
[05:06:09] *** Quits: shailangsa (~shailangs@host217-39-45-200.range217-39.btcentralplus.com) (Remote host closed the connection)
[05:06:17] *** Joins: NovumDXW (~NovumDXW@113.91.34.220)
[05:13:41] *** Quits: NovumDXW (~NovumDXW@113.91.34.220) (Quit: Leaving)
[05:22:43] *** Quits: bewees (~bewees@user/bewees) (Remote host closed the connection)
[05:57:58] *** Quits: artok (~azo@mobile-access-5672e7-16.dhcp.inet.fi) (Ping timeout: 260 seconds)
[06:17:37] *** Joins: night_wulfe (~wulfe@cpe-174-103-156-213.cinci.res.rr.com)
[06:20:30] *** Joins: The_Jag_ (~The_Jag@host-87-16-87-93.retail.telecomitalia.it)
[06:21:42] *** Quits: night_wulfe_ (~wulfe@cpe-174-103-156-213.cinci.res.rr.com) (Ping timeout: 260 seconds)
[06:23:34] *** Quits: The_Jag (~The_Jag@host-82-56-115-92.retail.telecomitalia.it) (Ping timeout: 260 seconds)
[06:32:32] *** Joins: artok (~azo@mobile-access-5672e7-16.dhcp.inet.fi)
[06:37:38] *** Quits: artok (~azo@mobile-access-5672e7-16.dhcp.inet.fi) (Ping timeout: 260 seconds)
[06:52:04] *** Joins: smallville7123 (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au)
[07:19:27] *** Quits: engest (~engest@50.39.176.86) (Read error: Connection timed out)
[07:19:47] *** Joins: engest (~engest@50.39.176.86)
[07:33:28] *** Joins: artok (~azo@mobile-access-5672e7-16.dhcp.inet.fi)
[08:15:53] *** Quits: smallville7123 (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au) ()
[08:16:16] *** Quits: jeremy_k (~jeremy_k@c-65-50-184-73.hs.gigamonster.net) (Remote host closed the connection)
[08:39:25] *** Joins: smallville7123 (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au)
[08:40:50] *** Quits: engest (~engest@50.39.176.86) (Ping timeout: 260 seconds)
[08:54:26] *** Quits: ferdna (~ferdna@user/ferdna) (Quit: Leaving)
[09:03:16] *** Joins: shailangsa (~shailangs@host217-39-45-200.range217-39.btcentralplus.com)
[09:24:12] *** Quits: Argorok (sid195487@hampstead.irccloud.com) (*.net *.split)
[09:24:12] *** Quits: elichai2 (sid212594@hampstead.irccloud.com) (*.net *.split)
[09:24:12] *** Quits: shenghi (~shenghi@chrysocolla.mutablevoid.org) (*.net *.split)
[09:24:21] *** Joins: Argorok (sid195487@id-195487.hampstead.irccloud.com)
[09:24:40] *** Joins: shenghi (~shenghi@chrysocolla.mutablevoid.org)
[09:25:06] *** Joins: elichai2 (sid212594@id-212594.hampstead.irccloud.com)
[09:32:50] *** Quits: andreyv (~andrey@user/andreyv) (*.net *.split)
[09:32:50] *** Quits: TinoDidriksen (~TinoDidri@tinodidriksen.com) (*.net *.split)
[09:32:50] *** Quits: Hobbyboy (Hobbyboy@hobbyboy.co.uk) (*.net *.split)
[09:32:50] *** Quits: xq (~xq@user/xq) (*.net *.split)
[09:33:04] *** Joins: TinoDidriksen (~TinoDidri@tinodidriksen.com)
[09:33:12] *** Joins: andreyv (~andrey@user/andreyv)
[09:33:17] *** Joins: Hobbyboy (Hobbyboy@hobbyboy.co.uk)
[10:09:21] *** Quits: hsv1 (~weechat@gateway/tor-sasl/hsv-2) (Remote host closed the connection)
[10:09:44] *** Joins: hsv1 (~weechat@gateway/tor-sasl/hsv-2)
[10:13:08] *** Quits: smallville7123 (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au) ()
[10:39:35] *** Joins: riksteri (riksteri@gateway/vpn/airvpn/riksteri)
[10:54:50] *** Joins: Inline (~Inline@2a02:908:1252:7a80:86ce:9852:a68c:aeee)
[11:20:06] *** Joins: magla (~gelignite@55d4d950.access.ecotel.net)
[11:46:30] *** Quits: DarkTrick (~DarkTrick@pl-749-047.bunbun.ne.jp) (Ping timeout: 260 seconds)
[11:56:06] *** Joins: DSpider (~DSpider@82.79.237.29)
[12:00:01] *** Quits: Inline (~Inline@2a02:908:1252:7a80:86ce:9852:a68c:aeee) (Quit: Leaving)
[12:00:59] *** Joins: Inline (~Inline@2a02:908:1252:7a80:86ce:9852:a68c:aeee)
[12:10:57] *** Quits: artok (~azo@mobile-access-5672e7-16.dhcp.inet.fi) (Quit: to work)
[12:12:12] *** Joins: PJBoy (~PJBoy@user/pjboy)
[12:15:06] *** Quits: DSpider (~DSpider@82.79.237.29) (Read error: Connection reset by peer)
[12:15:50] *** Joins: DSpider (DSpider@2a02:2f00:1ff:ffff::646c:68aa)
[12:27:17] *** Joins: Guest396 (~Guest39@eth-west-pareq2-46-193-4-100.wb.wifirst.net)
[12:29:02] *** Joins: spaceangel (~spaceange@ip-89-176-181-220.net.upcbroadband.cz)
[12:29:26] *** Quits: DSpider (DSpider@2a02:2f00:1ff:ffff::646c:68aa) (Ping timeout: 260 seconds)
[12:29:57] *** Joins: DSpider (DSpider@2a02:2f00:1ff:ffff::646c:68aa)
[12:45:16] *** Joins: DarkTrick (~DarkTrick@pl-749-047.bunbun.ne.jp)
[13:39:41] *** Joins: RoKenn (~RoKenn@2001:a61:3505:d101:e368:2fea:b1c9:72d1)
[13:39:41] *** Quits: RoKenn (~RoKenn@2001:a61:3505:d101:e368:2fea:b1c9:72d1) (Changing host)
[13:39:41] *** Joins: RoKenn (~RoKenn@user/rokenn)
[14:05:30] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[14:07:43] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Remote host closed the connection)
[14:08:17] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[14:08:31] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Remote host closed the connection)
[14:09:04] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[14:11:36] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Remote host closed the connection)
[14:14:17] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[14:15:18] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Remote host closed the connection)
[14:15:51] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[14:18:41] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Remote host closed the connection)
[14:19:13] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[14:20:01] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Client Quit)
[14:22:27] *** Joins: xq (~xq@user/xq)
[14:29:21] *** Joins: markong (~kvirc@213.146.188.203)
[14:37:40] *** Quits: Guest396 (~Guest39@eth-west-pareq2-46-193-4-100.wb.wifirst.net) (Quit: Client closed)
[15:25:05] *** Joins: Guest10 (~Guest10@eth-west-pareq2-46-193-4-100.wb.wifirst.net)
[15:41:53] *** Quits: Guest10 (~Guest10@eth-west-pareq2-46-193-4-100.wb.wifirst.net) (Quit: Client closed)
[15:49:50] *** Quits: ali1234 (~al@user/ali1234) (Remote host closed the connection)
[15:50:55] *** Joins: ali1234 (~al@user/ali1234)
[16:21:53] *** Joins: smallville7123 (~smallvill@cpe-172-193-72-46.qld.foxtel.net.au)
[17:06:24] *** Joins: engest (~engest@50.126.100.152)
[17:09:55] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[17:14:34] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Ping timeout: 260 seconds)
[17:16:22] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[17:21:06] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Ping timeout: 260 seconds)
[17:26:16] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[17:31:13] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Ping timeout: 268 seconds)
[17:42:06] *** Quits: DarkTrick (~DarkTrick@pl-749-047.bunbun.ne.jp) (Ping timeout: 260 seconds)
[17:48:55] *** Quits: DSpider (DSpider@2a02:2f00:1ff:ffff::646c:68aa) (Quit: Leaving)
[17:52:03] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[17:56:34] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Ping timeout: 260 seconds)
[18:00:11] *** Joins: DSpider (~DSpider@82.79.237.100)
[18:12:14] *** Joins: lionkor (~lionkor@beammp/staff/lionkor)
[18:19:39] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[18:22:29] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Client Quit)
[18:34:32] *** Joins: markb1 (~markb1@2600:1700:eb40:7ecf:d29:7f9f:ec16:1313)
[18:43:35] *** Joins: bewees (~bewees@user/bewees)
[18:50:08] *** Joins: meator (~meator@user/meator)
[18:53:51] *** Joins: TheHermann (~TheHerman@gateway/tor-sasl/thehermann)
[18:58:59] *** Joins: autoptr (~autoptr@113.120.64.33)
[18:58:59] *** Quits: autoptr (~autoptr@113.120.64.33) (Changing host)
[18:58:59] *** Joins: autoptr (~autoptr@user/autoptr)
[18:59:23] *** Quits: autoptr (~autoptr@user/autoptr) (Client Quit)
[19:08:26] *** Quits: lionkor (~lionkor@beammp/staff/lionkor) (Ping timeout: 260 seconds)
[19:21:46] *** Quits: TheHermann (~TheHerman@gateway/tor-sasl/thehermann) (Remote host closed the connection)
[19:22:25] *** Joins: TheHermann (~TheHerman@gateway/tor-sasl/thehermann)
[19:37:02] *** Joins: lionkor (~lionkor@beammp/staff/lionkor)
[19:48:45] *** Quits: lionkor (~lionkor@beammp/staff/lionkor) (Ping timeout: 268 seconds)
[20:21:30] *** Quits: smallville7123 (~smallvill@cpe-172-193-72-46.qld.foxtel.net.au) ()
[20:23:01] *** Quits: TheHermann (~TheHerman@gateway/tor-sasl/thehermann) (Remote host closed the connection)
[20:23:49] *** Joins: TheHermann (~TheHerman@gateway/tor-sasl/thehermann)
[20:27:20] *** Joins: lionkor (~lionkor@beammp/staff/lionkor)
[20:30:37] *** Quits: TheHermann (~TheHerman@gateway/tor-sasl/thehermann) (Remote host closed the connection)
[20:31:06] *** Joins: TheHermann (~TheHerman@gateway/tor-sasl/thehermann)
[20:31:45] *** Joins: lkor (~lionkor@beammp/staff/lionkor)
[20:32:35] *** Quits: lionkor (~lionkor@beammp/staff/lionkor) (Ping timeout: 260 seconds)
[20:52:55] *** lkor is now known as lionkor
[21:03:43] *** Joins: Guest41 (~Guest41@eth-west-pareq2-46-193-4-100.wb.wifirst.net)
[21:44:04] *** Quits: markong (~kvirc@213.146.188.203) (Ping timeout: 268 seconds)
[22:33:55] *** Joins: smallville7123 (~smallvill@cpe-172-193-72-46.qld.foxtel.net.au)
[22:49:00] *** Joins: eruditehermit_ (~eruditehe@50.226.189.210)
[22:52:06] <eruditehermit_> I have a question about writing a class with getters and setters vs making attributes public and setting them directly. Is there a problem with the latter approach for something simple?
[22:52:21] <eruditehermit_> like a struct
[22:53:22] <Alipha> eruditehermit_: it's rather pointless to add getters and setters if they add no value. So yes, go ahead and make them public
[22:53:43] <Raziel> the whole "encapsulate everything" approach is usually not very popular in C++
[22:54:46] *** Quits: meator (~meator@user/meator) (Quit: Leaving)
[22:55:05] <Alipha> if you want a field readonly, add only a getter. if you want to do bounds checking or manage invariants, then add getters and setters. if none of that applies, then yes, just make them public
[22:58:01] <eruditehermit_> thanks Alipha, Raziel 
[23:11:00] *** Quits: eruditehermit_ (~eruditehe@50.226.189.210) (Ping timeout: 268 seconds)
[23:15:53] *** Joins: greyrat (~greyrat@ip202.ip-51-178-215.eu)
[23:17:07] *** Server sets mode: +nt 
[23:22:29] *** Quits: riksteri (riksteri@gateway/vpn/airvpn/riksteri) (Quit: riksteri)
[23:44:17] *** Quits: TheHermann (~TheHerman@gateway/tor-sasl/thehermann) (Remote host closed the connection)
[23:45:03] *** Joins: TheHermann (~TheHerman@gateway/tor-sasl/thehermann)
