[00:00:25] <shka> i did this once because i was cleaning keyboard
[00:00:32] <shka> and i forgot to unplug the thing
[00:03:05] *** Quits: vats (~vats@103.70.83.249) (Remote host closed the connection)
[00:03:13] <mfiano> Wow, sorry. Guess this keyboard is dead if it's doing things without me
[00:03:14] *** Joins: vats (~vats@103.70.83.249)
[00:14:22] *** Joins: lisp123 (~lisp123@45.130.83.181)
[00:17:48] <edgar-rft> on the contrary: your keyboard is alive - it's taking over your computer now!
[00:18:22] *** Quits: vats (~vats@103.70.83.249) (Remote host closed the connection)
[00:18:31] *** Joins: vats (~vats@103.70.83.249)
[00:27:01] *** Quits: vats (~vats@103.70.83.249) (Remote host closed the connection)
[00:27:21] *** Joins: vats (~vats@103.70.83.249)
[00:36:30] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 244 seconds)
[00:38:47] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[00:51:27] <Josh_2> if I have a list with 100 different elements, each element has a slot whose value is a colour like orange, green, blue, is there a quick way I can sort them into individual lists by that colour?
[00:54:24] <lisp123> Josh_2: So to understand correctly, you have a list, say (A B C D E F G), and you want to split it into (A B) (D F) (E) (G) where each of the sublists are of a certain color?
[00:54:55] <Josh_2> yes, I can do this by looping, was just curious if there is a quick way to do this
[00:54:56] <phoe> oh goodness
[00:55:04] <phoe> that is a really big integer
[00:55:18] <Josh_2> sometimes there are sneaky ways you can do this in CL without realizing, no point reinventing the wheel
[00:55:39] <phoe> Josh_2: I remember that pjb had a utility for that
[00:55:55] <Bike> you're describing a partition
[00:56:04] <lisp123> http://www.lispworks.com/documentation/HyperSpec/Body/f_mem_m.htm - then use a lambda function to test for equality
[00:56:14] <Bike> there's nothing for it in the standard, but some utility libraries have it, i'm sure
[00:56:57] <lisp123> I'm sure you could use a mapping function also
[00:57:01] <Bike> not alexandria though as far as i can tell
[00:57:38] <phoe> serapeum:partition
[00:58:02] <zephyr> i've also seen that called group-by
[00:58:05] <phoe> sorry, serapeum:partitions
[00:58:35] <phoe> (serapeum:partitions (list (lambda (x) (= 0 (mod x 3))) (lambda (x) (= 1 (mod x 3))) (lambda (x) (= 2 (mod x 3)))) '(1 2 3 4 5 6 7 8 9))
[00:58:43] <phoe> ;=> ((3 6 9) (1 4 7) (2 5 8))
[00:58:57] <Josh_2> hmm
[00:59:21] <Bike> hm, well that's slightly more involved
[01:00:41] <phoe> only because the predicates are there
[01:00:47] <phoe> you can generate them on the fly via closing over your colors
[01:01:10] <lisp123> https://stackoverflow.com/questions/36634561/common-lisp-idiom-for-filtering-a-list-and-applying-a-function-to-the-unfiltered
[01:01:14] <phoe> something that can turn '(:green :red :blue) into a list of lambdas that check if the color of an object is :green, :red, :blue
[01:01:47] <pjb> phoe: (com.informatimago.common-lisp.cesarum.list:equivalence-classes '(1 2 3 4 5 6 7 8 9) :key (lambda (n) (mod n 3))) #| --> ((9 6 3) (8 5 2) (7 4 1)) |#
[01:01:59] <Bike> sure, but maybe you don't know the colors to begin with
[01:02:05] <phoe> pjb: exactly this
[01:02:05] <phoe> thanks
[01:02:43] <lisp123> Bike: (which is probably likely) - I guess then the trick would be to CDR through the list and push to a hash table for that color?
[01:03:09] <Josh_2> the colours are unknown in this case
[01:03:34] *** Quits: shka (~herr@109.231.62.239) (Read error: Connection reset by peer)
[01:03:53] *** Joins: shka (~herr@109.231.62.239)
[01:04:04] <lisp123> Josh_2: see above, loop through the items, and push each object onto a hash table with that color as a key (appending to the list for each color as you go on)
[01:04:46] <Bike> https://github.com/informatimago/lisp/blob/master/common-lisp/cesarum/list.lisp#L651-L665 which is more or less how pjb's function works.
[01:04:49] *** Quits: retropikzel (~retropikz@2001:999:202:19ef:ae12:3ff:fe96:9d08) (Quit: Leaving)
[01:04:58] <jcowan> That's when autovivification would be a great thing to have
[01:04:58] <pjb> (defmacro generate-keyword-predicates (&rest keywords) `(progn ,@(mapcar (lambda (keyword) `(defun ,(intern (concatenate 'string (string keyword) "P")) (object) (eql object ',keyword))) keywords)))    (macroexpand-1 '(generate-keyword-predicates :red :green :blue)) #| --> (progn (defun redp (object) (eql object ':red)) (defun greenp (object) (eql object ':green)) (defun bluep (object) (eql object ':blue))) ; t |#
[01:05:20] <Bike> well there's a two dollar word
[01:05:30] <pjb> Josh_2: if the colors are not known at compilation-time, then you don't want to generate functions for each of them.
[01:05:33] <lisp123> Bike: yay, i'm beocmign smarter
[01:05:40] <lisp123> guessed it right :D
[01:05:50] <Bike> "the automatic creation of new arrays and hashes as required every time an undefined value is dereferenced" eck
[01:05:56] <pjb> Josh_2: no code compiled can know what those function names would be if the color keywords are only known at run-time.
[01:06:22] *** Quits: nij- (~jin@2001-48F8-9021-806-0-0-0-954B-dynamic.midco.net) (Quit: Using Circe, the loveliest of all IRC clients)
[01:06:35] *** Quits: selwyn (~selwyn@user/selwyn) (Quit: Leaving)
[01:07:44] <phoe> but you can close over them at runtime
[01:08:09] <phoe> (mapcar (lambda (color) (lambda (x) (eq x color))) colors)
[01:08:20] <phoe> this gives you a list of predicate objects that you can freely funcall
[01:08:50] <Josh_2> got some more complicated answers than I expected
[01:08:53] <Josh_2> heres my bad solution
[01:09:12] <Josh_2> https://plaster.tymoon.eu/view/2585#2585
[01:11:19] <Josh_2> I can easily display this as a table in HTML
[01:11:24] <Josh_2> Thanks for the suggestions :D
[01:13:52] <zephyr> i'll throw in https://plaster.tymoon.eu/view/2586#2586, looks similar to other suggestions
[01:14:59] *** Quits: z3t0 (~z3t0@107-159-10-134.on.dsl.ebox.net) (Read error: Connection reset by peer)
[01:15:21] *** Joins: z3t0 (~z3t0@107-159-10-134.on.dsl.ebox.net)
[01:16:10] <pjb> phoe: this is correct, but more often it will be enough to use (member x colors).
[01:16:19] *** Quits: zos (~zosthegoa@ool-457a8044.dyn.optonline.net) (Quit: WeeChat 2.8)
[01:16:20] <pjb> or (position x color)
[01:16:25] <pjb> or (position x colors)
[01:16:37] <phoe> oh right, sure
[01:16:38] <pjb> (it'd be better to have some specifications).
[01:18:52] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 244 seconds)
[01:19:28] *** Quits: shka (~herr@109.231.62.239) (Ping timeout: 272 seconds)
[01:20:01] *** Quits: scymtym (~user@2001:638:504:20e6:6ac3:87e0:e782:f3fc) (Ping timeout: 250 seconds)
[01:20:15] *** Quits: cage (~cage@dynamic-adsl-78-15-36-212.clienti.tiscali.it) (Quit: rcirc on GNU Emacs 27.1)
[01:21:43] *** Quits: pve (~pve@87-93-198-41.bb.dnainternet.fi) (Quit: leaving)
[01:22:37] *** Quits: z3t0 (~z3t0@107-159-10-134.on.dsl.ebox.net) (Ping timeout: 250 seconds)
[01:30:04] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[01:32:30] *** Quits: brettgilio (~brettgili@45.55.53.68) (Quit: The Lounge - https://thelounge.chat)
[01:33:25] *** Joins: brettgilio (~brettgili@45.55.53.68)
[01:36:39] *** Joins: scymtym (~user@ip-88-153-154-183.hsi04.unitymediagroup.de)
[01:45:57] *** Quits: ecraven (ecraven@user/nex) (Quit: quit)
[01:46:15] *** Joins: ecraven (~ecraven@user/nex)
[02:02:16] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 244 seconds)
[02:02:27] *** Quits: asarch (~asarch@2806:10ae:7:c9a9:507f:f82b:6779:bc32) (Quit: Leaving)
[02:04:04] *** Quits: lisp123 (~lisp123@45.130.83.181) (Remote host closed the connection)
[02:06:23] *** Joins: lisp123_ (~lisp123@45.130.83.181)
[02:07:56] <Bike> sm2n: i just loaded introspect-environment on sbcl 2.1.7 and don't see any errors. there is a compiler note but i am pretty sure it is harmless.
[02:08:34] *** Joins: lisp123 (~lisp123@45.130.83.181)
[02:11:20] *** Quits: lisp123_ (~lisp123@45.130.83.181) (Ping timeout: 256 seconds)
[02:11:51] *** Quits: lisp123 (~lisp123@45.130.83.181) (Read error: Connection reset by peer)
[02:19:42] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[02:20:16] *** Quits: santiagopim (~user@90.166.59.133) (Ping timeout: 272 seconds)
[02:42:24] *** Quits: gaqwas (~john@dynamic-077-004-171-029.77.4.pool.telefonica.de) (Ping timeout: 258 seconds)
[02:46:28] *** Joins: lisp123 (~lisp123@45.130.83.181)
[02:46:42] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 244 seconds)
[02:47:46] *** Joins: pillton (~user@2405:b000:600:b0::36a)
[02:48:00] *** Quits: flip214 (~marek@user/flip214) (Ping timeout: 255 seconds)
[02:53:08] *** Quits: taiju (~taiju@240b:253:ec40:2400:3cf8:2df8:a9c6:9f5a) (Ping timeout: 258 seconds)
[02:57:36] *** Joins: kakuhen (~kakuhen@user/kakuhen)
[02:57:51] *** Joins: taiju (~taiju@240b:253:ec40:2400:3cf8:2df8:a9c6:9f5a)
[02:58:01] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[03:00:04] *** Quits: lisp123 (~lisp123@45.130.83.181) (Ping timeout: 256 seconds)
[03:08:11] *** Joins: akoana (~ah@user/akoana)
[03:13:03] *** Joins: cjb (~cjb@user/cjb)
[03:18:07] *** Quits: frgo (~frgo@p200300deef181d009d5ea094dbc19f3c.dip0.t-ipconnect.de) (Remote host closed the connection)
[03:18:40] *** Joins: frgo (~frgo@p200300deef181d00bd7bf1868c9cad97.dip0.t-ipconnect.de)
[03:21:47] *** Quits: attila_lendvai (~alendvai@1F2E5CC9.dsl.pool.telekom.hu) (Ping timeout: 245 seconds)
[03:25:17] *** Quits: froggey (~froggey@cpc96342-rdng26-2-0-cust314.15-3.cable.virginm.net) (Ping timeout: 252 seconds)
[03:27:02] *** Joins: froggey (~froggey@cpc96342-rdng26-2-0-cust314.15-3.cable.virginm.net)
[03:30:56] *** Joins: dsk (~dsk@user/dsk)
[03:31:08] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 244 seconds)
[03:48:38] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[03:55:57] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Quit: ec)
[04:00:30] *** Joins: kakuhen_ (~kakuhen@user/kakuhen)
[04:03:17] *** Quits: random-nick (~random-ni@87.116.165.220) (Ping timeout: 258 seconds)
[04:04:03] *** Quits: kakuhen (~kakuhen@user/kakuhen) (Ping timeout: 258 seconds)
[04:12:29] *** Quits: dsk (~dsk@user/dsk) (Ping timeout: 258 seconds)
[04:16:42] *** Quits: rgherdt__ (~rgherdt@ip5f5af1d0.dynamic.kabel-deutschland.de) (Ping timeout: 258 seconds)
[04:17:28] *** Quits: robin (~robin@user/terpri) (Ping timeout: 258 seconds)
[04:29:22] *** Joins: Guest29 (~Guest29@122.56.56.215)
[04:32:51] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 250 seconds)
[04:33:46] *** Quits: makomo (~makomo@user/makomo) (Ping timeout: 240 seconds)
[04:38:35] *** Joins: notzmv (~zmv@user/notzmv)
[04:47:54] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 252 seconds)
[04:49:59] *** Quits: cjb (~cjb@user/cjb) (Ping timeout: 260 seconds)
[04:54:03] *** Joins: rt (~robin@user/terpri)
[04:54:21] *** Quits: rt (~robin@user/terpri) (Remote host closed the connection)
[04:55:07] *** Joins: rt (~robin@user/terpri)
[05:08:23] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 250 seconds)
[05:14:41] *** Quits: Guest29 (~Guest29@122.56.56.215) (Quit: Client closed)
[05:42:38] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[05:59:45] *** Joins: flip214 (~marek@h081217094109.dyn.cm.kabsi.at)
[06:02:20] *** Quits: nirnam (~nirnam@1.47.135.162) (Read error: Connection reset by peer)
[06:07:57] *** Joins: notzmv (~zmv@user/notzmv)
[06:14:55] *** Joins: bpanthi977 (~Thunderbi@103.152.144.53)
[06:18:27] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 245 seconds)
[06:25:23] *** rt is now known as robin
[06:27:32] *** Joins: notzmv (~zmv@user/notzmv)
[06:27:44] *** Quits: bpanthi977 (~Thunderbi@103.152.144.53) (Quit: bpanthi977)
[06:33:55] *** Parts: brettgilio (~brettgili@45.55.53.68) (The Lounge - https://thelounge.chat)
[07:00:32] *** Joins: prxq (~quassel@x4db5115a.dyn.telefonica.de)
[07:00:34] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 240 seconds)
[07:04:17] *** Quits: prxq_ (~quassel@x4db34e54.dyn.telefonica.de) (Ping timeout: 245 seconds)
[07:07:08] *** Quits: derelict (~derelict@user/derelict) (Ping timeout: 256 seconds)
[07:17:12] *** Quits: trufas (~trufas@177.240.218.218) (Ping timeout: 245 seconds)
[07:21:59] <sm2n> Bike, this was the error I got: https://plaster.tymoon.eu/view/2587#2587
[07:22:16] <sm2n> I will delete the fasls and see what happens
[07:22:18] <Bike> that's not an error. that's a compiler note that refers to an error.
[07:22:35] <Bike> it's saying that the call to error is unreachable and has been deleted.
[07:23:04] <sm2n> oh whoops, sorry for wasting your time
[07:23:17] <sm2n> I should have read that correctly
[07:23:22] <Bike> it is kind of confusing
[07:23:39] <Bike> and maybe i should go in and figure out the #+ incantations to make the note go away, since it's not really interesting
[07:26:33] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[07:26:54] *** Joins: dsk (~dsk@user/dsk)
[07:31:29] <beach> Good morning everyone!
[07:39:22] *** Parts: akoana (~ah@user/akoana) ()
[07:45:41] *** Quits: igemnace (~ian@user/igemnace) (Quit: WeeChat 3.2)
[07:46:05] *** Joins: igemnace (~ian@user/igemnace)
[07:46:14] *** Quits: srhm (~ascii@user/srhm) (Quit: Konversation terminated!)
[07:46:30] *** Joins: srhm (~ascii@user/srhm)
[07:48:24] <Josh_2> Morning beach
[07:49:16] *** Quits: igemnace (~ian@user/igemnace) (Client Quit)
[07:49:42] *** Joins: igemnace (~ian@user/igemnace)
[08:24:32] <mfiano> That was fun. The new Sussman book was very thought provoking and makes me want to revisit some of my complicated CL projects.
[08:27:41] <beach> Sounds like I must get a copy?  What makes it so good?
[08:29:32] <mfiano> It has a few techniques for what I usually call additive programming - extending designs beyond their initial intentions without modifying existing code. Some of the ideas, while hard to explain briefly on IRC, really hit home for me.
[08:29:54] <Bike> i haven't finished it yet, but unlike most things on programming i've read it emphasizes rewriting programs. a lot of the examples are along the lines of "okay, so we made this thing of perfect crystalline beauty in the last section, but now we need it to do something else. how could we have written it more mutably in the first place to avoid having to completely rewrite it now?"
[08:30:39] *** Joins: nirnam (~nirnam@1.47.135.162)
[08:31:03] <beach> Interesting.
[08:33:09] <Bike> oh huh, and it has the ball of mud quote i like, but says it was made up. how about that
[08:33:47] <moon-child> wikipedia says the alleged originator of the quote claims he called it a hackey sack, not a ball of mud
[08:34:00] <moon-child> err, bean bag
[08:34:01] <Bike> oh well that's fine then.
[08:35:02] <lotuseater> mfiano: What's the title of the new Sussman book?
[08:35:18] <Bike> software design for flexibility
[08:35:24] <mfiano> Software Deisgn for Flexibility - How to Avoid Programming Yourself Into a Corner
[08:35:36] <Bike> oh, and it uses scheme instead of lisp, which shouldn't really be surprising
[08:35:48] <Bike> so it is only somewhat on topic
[08:36:16] <mfiano> I would not recommend it as an introductory book on Lisp nor software design.
[08:36:25] <beach> I ordered it.
[08:38:16] *** Quits: robin (~robin@user/terpri) (Remote host closed the connection)
[08:38:39] <hayley> Hey, with the number of people asking if they can learn Common Lisp from SICP, another Sussman book can't be that off topic.
[08:40:25] *** Joins: robin (~robin@user/terpri)
[08:44:40] <mfiano> beach: Just try not to grumble too much when you don't see any explicit objects or generic functions :)
[08:45:18] <mfiano> It's all closures in the usual scheme spirit
[08:47:11] <lotuseater> Bike: it isn't surprising and I would have bet on it
[08:49:07] <lotuseater> they also reused the lambda sorcerers for the cover :)
[08:50:05] <mfiano> Well it is considered an advanced sequel to SICP
[08:51:30] <lotuseater> do you also know this "Structure and Interpretation of Classical Mechanics"? they do even Hamiltonian and Lagrangian mechanics
[08:52:29] <Bike> huh, and it mentions not only MOP, but AspectL
[08:52:38] <lotuseater> ok that's offtopic. but interesting as a somewhat physicist in spe
[08:52:57] <lotuseater> oh what's AspectL?
[08:53:38] <beach> mfiano: I'll keep that in mind.
[08:54:03] <lotuseater> s/interesting/interesting to me
[08:54:19] <Bike> aspectl (they actually mention aspect-oriented programming, but w/e) was the predecessor to pascal costanza's contextl project https://github.com/pcostanza/contextl
[08:55:12] <Bike> which is an interesting system to dynamically add data and behavior to classes and generic functions and stuff, though i haven't really used it
[08:55:49] <lotuseater> sounds very advanced
[08:56:04] <mfiano> Guile's CLOS port has some nifty features not found in (at least standard) CL, that I'd like to find support for one day when I'm bored enough.
[08:56:28] <Bike> like what?
[08:56:37] <mfiano> 2 examples:
[08:57:29] <mfiano> defining a generic function with the defgeneric equivalent on a builtin function like #'+ will register it as the base case method, allowing you to extend any regular function.
[08:57:57] <mfiano> and, arity overloading...new methods don't have to conform to the required positional parameter protocol.
[08:58:20] <Bike> mm. both things people want sometimes
[08:58:37] <moon-child> former is a nonstarter as such for performance reasons, but you can easily define a '+' method in your own package that uses cl:+ as its base case
[08:59:28] <moon-child> latter is cool though
[09:00:07] <hayley> 1. Either you are doing UB or someone should be in trouble for not making something generic 2. Bye-bye lambda list
[09:00:32] *** Quits: Bike (~Glossina@71.69.170.70) (Quit: sleep)
[09:05:44] *** Quits: taiju (~taiju@240b:253:ec40:2400:3cf8:2df8:a9c6:9f5a) (Ping timeout: 258 seconds)
[09:06:09] *** Parts: pranavats (3fba1d1b34@jabberfr.org) ()
[09:07:30] *** Joins: taiju (~taiju@240b:253:ec40:2400:3cf8:2df8:a9c6:9f5a)
[09:09:58] *** Quits: srhm (~ascii@user/srhm) (Quit: Konversation terminated!)
[09:10:20] *** Joins: srhm (~ascii@user/srhm)
[09:11:43] *** Joins: selwyn (~selwyn@user/selwyn)
[09:22:21] *** Joins: pve (~pve@188-67-129-117.bb.dnainternet.fi)
[09:28:15] *** Joins: karlosz (~karlosz@rrcs-172-254-64-51.nyc.biz.rr.com)
[09:32:55] *** Joins: lisp123_ (~lisp123@5.30.23.247)
[09:34:16] *** Joins: derelict (~derelict@user/derelict)
[09:37:56] *** Quits: dsk (~dsk@user/dsk) (Ping timeout: 258 seconds)
[09:39:25] <beach> mfiano: The first thing is easy in SICL.  Simple functions in SICL are funcallable standard objects.  All that is needed is a CHANGE-CLASS and the definition of the initial method.
[09:45:16] *** Quits: karlosz (~karlosz@rrcs-172-254-64-51.nyc.biz.rr.com) (Quit: karlosz)
[09:50:09] *** Joins: asarch (~asarch@2806:10ae:7:d143:adcb:db79:f72c:94ee)
[09:54:10] *** Joins: silasfox (~sbv@2001-4dd6-62dc-0-6027-7522-36-c7ab.ipv6dyn.netcologne.de)
[09:55:01] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Remote host closed the connection)
[09:55:26] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[10:07:03] *** Joins: notzmv (~zmv@user/notzmv)
[10:09:59] *** Joins: wilfred (uid159@id-159.highgate.irccloud.com)
[10:11:59] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[10:12:36] *** Quits: srhm (~ascii@user/srhm) (Quit: Konversation terminated!)
[10:13:00] *** Joins: srhm (~ascii@user/srhm)
[10:19:37] *** Quits: asarch (~asarch@2806:10ae:7:d143:adcb:db79:f72c:94ee) (Quit: Leaving)
[10:20:06] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Ping timeout: 258 seconds)
[10:20:41] *** Joins: amb007 (~a_bakic@233.104.204.77.rev.sfr.net)
[10:30:18] *** Joins: spr (~des@45.33.93.30)
[10:32:45] *** Quits: vats (~vats@103.70.83.249) (Ping timeout: 252 seconds)
[10:33:26] *** Quits: srhm (~ascii@user/srhm) (Quit: Konversation terminated!)
[10:33:50] *** Joins: srhm (~ascii@user/srhm)
[10:35:46] *** Quits: pve (~pve@188-67-129-117.bb.dnainternet.fi) (Ping timeout: 240 seconds)
[10:37:53] *** Joins: rgherdt__ (~rgherdt@2a02:8109:86c0:d8d:5c93:4b82:e706:c33e)
[10:44:35] *** Joins: rain3 (~rain3___@2a02:2f09:d30b:1300:514:bcc7:8202:1798)
[10:46:09] *** Joins: icer (eric@gateway/vpn/protonvpn/icer)
[10:48:28] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 258 seconds)
[10:49:02] *** Joins: shka (~herr@109.231.62.239)
[10:53:23] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[10:55:04] *** Joins: Lord_of_Life_ (~Lord@user/lord-of-life/x-2819915)
[10:55:35] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 268 seconds)
[10:56:19] *** Lord_of_Life_ is now known as Lord_of_Life
[11:08:43] *** Quits: kakuhen_ (~kakuhen@user/kakuhen) (Quit: Leaving...)
[11:08:56] *** Joins: kakuhen (~kakuhen@user/kakuhen)
[11:10:41] *** Parts: spr (~des@45.33.93.30) ()
[11:20:30] *** Quits: icer (eric@gateway/vpn/protonvpn/icer) (Quit: WeeChat 2.9)
[11:23:09] *** Quits: scymtym (~user@ip-88-153-154-183.hsi04.unitymediagroup.de) (Remote host closed the connection)
[11:26:12] *** Joins: peterhil (~peterhil@mobile-access-5d6aa6-103.dhcp.inet.fi)
[11:29:21] *** Joins: voltron (~voltrin_@ip5f5993ed.dynamic.kabel-deutschland.de)
[11:30:07] *** Quits: amb007 (~a_bakic@233.104.204.77.rev.sfr.net) (Ping timeout: 245 seconds)
[11:30:22] *** Joins: amb007 (~a_bakic@28.104.204.77.rev.sfr.net)
[11:36:04] *** Quits: fengshaun (~fengshaun@68.69.214.210) (Quit: bibi!)
[11:36:21] *** Joins: fengshaun (~fengshaun@68.69.214.210)
[11:36:22] *** Quits: silasfox (~sbv@2001-4dd6-62dc-0-6027-7522-36-c7ab.ipv6dyn.netcologne.de) (Ping timeout: 245 seconds)
[11:36:38] *** Joins: silasfox (~sbv@xdsl-87-79-98-159.nc.de)
[11:38:12] *** Joins: santiagopim (~user@90.166.59.133)
[11:42:03] *** Joins: dsk (~dsk@user/dsk)
[11:42:58] *** Quits: santiagopim (~user@90.166.59.133) (Read error: Connection reset by peer)
[11:42:58] *** Quits: amb007 (~a_bakic@28.104.204.77.rev.sfr.net) (Read error: Connection reset by peer)
[11:43:15] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[11:43:16] *** Joins: santiagopim (~user@90.166.59.133)
[11:45:22] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[11:46:19] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[11:49:13] *** Quits: santiagopim (~user@90.166.59.133) (Ping timeout: 250 seconds)
[11:49:13] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[11:51:02] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[11:51:30] *** Quits: peterhil (~peterhil@mobile-access-5d6aa6-103.dhcp.inet.fi) (Ping timeout: 240 seconds)
[11:52:55] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[11:53:00] *** Joins: santiagopim (~user@90.166.59.133)
[11:53:12] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[11:53:14] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[11:53:58] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[11:54:17] *** Quits: santiagopim (~user@90.166.59.133) (Remote host closed the connection)
[11:56:52] *** Joins: rgherdt_ (~rgherdt@ip5f5af1c6.dynamic.kabel-deutschland.de)
[11:59:48] *** Joins: lisp123 (~lisp123@5.30.23.247)
[12:00:13] *** Joins: gaqwas (~john@dynamic-095-115-078-128.95.115.pool.telefonica.de)
[12:00:55] *** Quits: rgherdt__ (~rgherdt@2a02:8109:86c0:d8d:5c93:4b82:e706:c33e) (Ping timeout: 258 seconds)
[12:00:58] *** Quits: lisp123_ (~lisp123@5.30.23.247) (Ping timeout: 240 seconds)
[12:01:04] <jackdaniel> traffic is low, so I'll share an artifact of a tutorial I'm writing for McCLIM that aims at "gadget" developers: http://turtleware.eu/static/paste/aea793e7-clock.webm
[12:02:28] *** Quits: srhm (~ascii@user/srhm) (Quit: Konversation terminated!)
[12:02:50] *** Joins: srhm (~ascii@user/srhm)
[12:06:57] <rain3> Awesome
[12:07:15] <jackdaniel> thanks
[12:07:45] <jackdaniel> I plan to also discuss an interactive "date picker" gadget (sort of a calendar)
[12:10:21] *** Joins: kakuhen_ (~kakuhen@user/kakuhen)
[12:12:12] *** Quits: kakuhen (~kakuhen@user/kakuhen) (Ping timeout: 245 seconds)
[12:21:56] *** Quits: silasfox (~sbv@xdsl-87-79-98-159.nc.de) (Ping timeout: 272 seconds)
[12:22:57] *** Quits: kakuhen_ (~kakuhen@user/kakuhen) (Quit: Leaving...)
[12:23:07] *** Joins: silasfox (~sbv@2001-4dd6-8e13-0-6f0d-fa0c-ffdd-c563.ipv6dyn.netcologne.de)
[12:23:08] *** Joins: kakuhen (~kakuhen@user/kakuhen)
[12:23:28] *** Quits: srhm (~ascii@user/srhm) (Quit: Konversation terminated!)
[12:23:39] <lisp123> jackdaniel: does McClim require any dependencies outside of the lisp files?
[12:23:50] *** Joins: srhm (~ascii@user/srhm)
[12:23:50] <lisp123> I tried using it once but it errored out on MacOS
[12:24:10] <beach> lisp123: The current main backend needs X11.
[12:24:31] <moon-child> lisp123: try installing xquartz, maybe?
[12:24:45] <lisp123> thanks beach & moon-child, will do
[12:25:02] <lisp123> Can't wait to get rid of this Mac..
[12:25:17] <beach> What's stopping you?
[12:25:38] <lisp123> I bought a 27" 5K screen a few years ago, and it only works with Mac
[12:25:57] <lisp123> So I need to use this for a few more years to make the purchase worthwhile
[12:26:33] <moon-child> sounds like the sunk cost fallacy
[12:26:36] <lisp123> I tried doing Linux via VM, but the fonts are not as sharp (probably because of the screen being HD)
[12:27:12] <lisp123> moon-child: more or less :)
[12:28:37] *** Joins: vats (~vats@103.70.83.249)
[12:30:01] <pjb> moon-child: in a way; but also, the screen is gorgeous. Even if you didn't used macOS, you'd use it on macOS with X11.app to your linux box…
[12:30:29] <pjb> lisp123: tramp is nice for that; you run the local emacsformacosx.com with the nice font, editing remote files.
[12:32:01] *** Joins: jimka (~user@2a01:e0a:26a:f400:78f1:4c5d:36e:1258)
[12:32:37] <lisp123> pjb: I have that Emacs, with tramp does that mean I can remote into a VM but use Apple's screen rendering?
[12:32:59] <lisp123> as in I am using that version (emacsformacosx.com)
[12:33:45] <jimka> hi everyone, I was having lots of trouble connecting.  I was reading https://www.cliki.net/irc, which lead me in the wrong direction.   From that web page I thought the server name was libera.chat, but it is irc.libera.chat.
[12:34:16] <beach> jimka: Hey, welcome [back].
[12:35:24] <jimka> beach. I was about to send you an email asking you how the irc channel works now.  I don't know what gave me the idea to try irc.libera.chat rather than libera.chat.  First I was trying libra.chat (being dislexic and not noticing the infix e)
[12:35:57] <beach> Yes, I see.
[12:36:05] <jimka> Hey can someone help me with something that has bugged me for many years.
[12:36:16] <beach> You were absent when we had all the discussions and made a decision to move.
[12:36:23] *** Joins: hendursa1 (~weechat@user/hendursaga)
[12:36:34] *** Quits: gaqwas (~john@dynamic-095-115-078-128.95.115.pool.telefonica.de) (Ping timeout: 258 seconds)
[12:36:51] <beach> jimka: Try us.
[12:36:56] *** Joins: pve (~pve@87-93-150-30.bb.dnainternet.fi)
[12:37:14] <jimka> Is there a place in the hyperspec (or elsewhere) which documents the format directives.  What I mean is a mapping from directive to meaning.  the spec has many sections you can click though one by one until you find the one you want.  But what if I want to know what ~w means (for example)   how can it find it more easily?
[12:37:42] <jackdaniel> jimka: try typing ~a in l1sp.org
[12:37:58] <jackdaniel> http://l1sp.org/search?q=~w
[12:38:17] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 244 seconds)
[12:38:21] <jackdaniel> it provides a link to the appropriate section in the hyperspec
[12:38:31] <lisp123> If you have slime, believe this works: common-lisp-hyperspec-format, or C-c C-d ~, to lookup format control characters.
[12:38:38] <lisp123> http://snowsyn.net/2020/01/01/local-clhs-access-in-emacs/
[12:39:43] <jimka> so there's no table in the spec that lists all the directives ?
[12:39:55] <jimka> that's a shame.
[12:41:10] <lisp123> jimka: try this (not a table, but still): https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node200.html
[12:42:48] <jimka> The clojure language as a very good implementation of cl-format.  whoever implemented this function did an amazing job.  The documention of the function gives the url of the cl hyperspec page.   I've started using it more and more.  and I've started posing a few cl-format recipies in the open clojure docs.
[12:43:37] <jimka> but it is hard for clojure users to navigate the hyperspec.  I thought a summary table would be a good thing for reverse engineering a given call to cl-format.
[12:44:17] *** Quits: srhm (~ascii@user/srhm) (Quit: Konversation terminated!)
[12:44:39] <jimka> can someone tell me the relation of ~A to pretty printing?
[12:44:40] *** Joins: srhm (~ascii@user/srhm)
[12:45:09] <jimka> is ~A supposed to pretty print its argument or not or is that a choice of the implementation or does it depend on the value of *print-pretty* ?
[12:46:12] <jimka> someone (not expert) told me this was a matter in dispute.
[12:46:22] <lisp123> jimka: looks like it is based on princ, so if you look up the CLHS for that you will get the answer. "It binds *print-escape* to false and *print-readably* to false
[12:46:54] <jackdaniel> ~a means aesthetic print, not pretty print
[12:47:01] <jackdaniel> jimka: please read this issue: http://www.lispworks.com/documentation/HyperSpec/Issues/iss169_w.htm
[12:47:59] <jimka> in sbcl
[12:48:01] <jimka> (format t "~A~%" '(or (and a b) (and c d) (and c d) (and c d) (and c d) (and c d) (and c d) (and c d) (and c d) (and c d) (and c d) (and c d) (and c d) (and x y)))
[12:48:04] <jimka> is printed as
[12:48:09] <jimka> (OR (AND A B) (AND C D) (AND C D) (AND C D) (AND C D) (AND C D) (AND C D)
[12:48:09] <jimka>     (AND C D) (AND C D) (AND C D) (AND C D) (AND C D) (AND C D) (AND X Y))
[12:48:27] <jimka> maybe that is because of line-length or margin or something?  not because of pretty-printing ?
[12:48:58] <hayley> As I see it, *PRINT-PRETTY* defaults to T on SBCL, and so ~A uses pretty printing.
[12:50:50] <hayley> And the margins are only respected when pretty printing.
[12:51:22] <jimka> the issue http://www.lispworks.com/documentation/HyperSpec/Issues/iss169_w.htm talks about whether *pretty-print* should get bound by ~A and ~S.   However, I don't understand whether this *issue* was implemented or left up to implementations.
[12:53:21] <jimka> Motivation for my question/comment:  in the clojure implementation of cl-format, the ~W directive invokes the pretty printer but ~A does not, regardless of the value of *print-pretty*.     however ~A does print aesthetically in the sense that it calls the equivalent of print-object on its argument.
[12:53:40] <jimka> I didn't even know that ~W existsed.
[12:53:42] <jimka> existed
[12:57:11] <jackdaniel> since the specification does not mention that ~a binds *pretty-print* this issue has not been put in the standard
[12:57:14] <jackdaniel> issues are supplemental
[12:57:35] <jackdaniel> as of why it did not end up as part of the standard -it might be that they didn't have time to put it there
[12:58:15] <jimka> hayley, where do you get that the margins are only respected when pretty printing?  Is that something you gather from experience, or have you seen it written somewhere?
[12:59:35] <hayley> I can't remember where, but loosely speaking, the pretty printer is just clever about where to put newlines. When pretty printing is enabled, the margins are used to decide where to break, and no newlines are printed otherwise.
[12:59:41] *** Quits: wilfred (uid159@id-159.highgate.irccloud.com) (Quit: Connection closed for inactivity)
[13:00:27] <hayley> clhs pprint-newline
[13:00:28] <specbot> http://www.lispworks.com/reference/HyperSpec/Body/f_ppr_nl.htm
[13:05:08] *** Quits: srhm (~ascii@user/srhm) (Quit: Konversation terminated!)
[13:05:30] *** Joins: srhm (~ascii@user/srhm)
[13:06:56] <jimka> pprint-newline and pprint-logical-block make my head spin.
[13:07:05] <jimka> hats off to anyone who has implemented this.
[13:07:40] <jimka> beach, who implemented format for clasp?
[13:07:44] <hayley> Yeah, when I was trying to figure out how to use the pretty printer I just grepped through Quicklisp code to find a suitable FORMAT string.
[13:08:18] <hayley> https://github.com/clasp-developers/clasp/blob/main/src/lisp/kernel/lsp/format.lsp says it originated in CMUCL.
[13:08:42] <hayley> Oh, and it then went through ECL, which Clasp was based off to an extent.
[13:09:28] <beach> jimka: Clasp copied the Common Lisp code of ECL, so I am guessing it came from there.
[13:12:04] <jimka> the clojure implementation is only 1950 lines long.  It was authored by Tom Faulhaber in 2009.  The source code is goverened by an Eclipse Public License.  The header says it implements chapter 22 of "Common Lisp the Language, 2nd edition", but it does not give an indication whether it was written from scratch, or based off of (translated from) some other source.
[13:14:12] <beach> SICL FORMAT is almost exactly twice that size.
[13:14:25] <beach> ... and there are still a few directives missing.
[13:14:50] <jimka> beach, are you including the code for pprint?  or is that a seperate section?
[13:15:04] <beach> PPRINT is not included in that count.
[13:15:27] <jimka> beach, if you strip away the comments, how many lines is it?
[13:16:12] <jimka> the clojure version is not heavily commented, but pretty understandable, at least locally.
[13:16:33] <beach> 3300 without comments.
[13:16:41] <jimka> curious.
[13:16:54] <beach> I probably do things very differently.
[13:18:04] <beach> Does clojure have a format-directive compiler?
[13:18:23] <jimka> did anyone know that ~R has support for new-roman and old-roman  I.e, iv vs iiii ?
[13:18:34] <beach> For each directive, I have an interpreter method and a compiler method.
[13:19:07] *** Joins: makomo (~makomo@user/makomo)
[13:19:13] <jimka> It has a function named compile-directive.  So that's probably what you're talking about.  right?
[13:19:24] <beach> I guess.
[13:19:36] <jimka> is that good or bad?
[13:20:41] <beach> Well, if it is a monolithic function, that's probably not great.  SICL format parses directives to instances of standard classes and then it has methods specialized to those classes on the interpreter and the compiler generic functions.
[13:21:44] <beach> This way, FORMAT is both extensible and possible to customize.
[13:22:05] <jimka> the compile-directive function extracts the params and the flags, determines the dispatch function from the directive, emits an error if it cannot do so, and returns a structure that I don't immediately understand if it was successful.
[13:22:42] <beach> How does it determine the dispatch function from the directive?
[13:22:52] <jimka> the function is 20 lines long.
[13:23:46] <beach> I guess I could study it if I wanted to.
[13:25:32] <jimka> there is a data structure defined by a macro called defdirectives.  each directive looks like it contains 5 fields which look to me like the specify things like padding, at and colon, and a lambda function of 3 argument which appently evenutally prints the result.
[13:26:00] <jimka> does anyone know Tom Faulhaber?
[13:26:19] <jimka> he was/is obviously lover of common lisp.
[13:27:10] *** Quits: voltron (~voltrin_@ip5f5993ed.dynamic.kabel-deutschland.de) (Ping timeout: 272 seconds)
[13:34:56] <beach> Maybe Tom is hiding here behind some nick.
[13:37:03] *** Quits: lisp123 (~lisp123@5.30.23.247) (Quit: Leaving...)
[13:37:50] <jimka> https://github.com/tomfaulhaber/cl-format
[13:38:36] *** Joins: lisp123 (~lisp123@5.30.23.247)
[13:41:23] <beach> jimka: Thanks.  I don't think I have the time to study it now.
[13:45:12] *** Joins: kevingal (~quassel@2a02:8084:4140:f300:706d:6457:86cf:4f78)
[13:50:42] <jimka> https://github.com/clojure/clojure/blob/master/src/clj/clojure/pprint/cl_format.clj
[13:51:16] <jimka> that's prehaps a better page.  apparently the code within the clojure code base compiles lots of files togehter from the original project into a single file.
[13:53:20] *** Joins: selwyn (~selwyn@user/selwyn)
[13:57:22] <jimka> I still haven't found any attribution of where the original code came from.   reading the comment the author wrote it from scratch
[14:02:34] *** Joins: santiagopim (~user@90.166.59.133)
[14:08:40] <beach> It could be.  It's a fun project.  SICL FORMAT was the first SICL module I wrote I think.
[14:13:17] *** Quits: srhm (~ascii@user/srhm) (Quit: Konversation terminated!)
[14:13:40] *** Joins: srhm (~ascii@user/srhm)
[14:15:41] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[14:16:14] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[14:46:18] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Ping timeout: 240 seconds)
[14:46:34] *** Joins: amb007 (~a_bakic@44.104.204.77.rev.sfr.net)
[14:47:52] *** Joins: scymtym (~user@ip-88-153-154-183.hsi04.unitymediagroup.de)
[14:51:59] *** Quits: pillton (~user@2405:b000:600:b0::36a) (Ping timeout: 260 seconds)
[14:52:39] *** Quits: jimka (~user@2a01:e0a:26a:f400:78f1:4c5d:36e:1258) (Ping timeout: 258 seconds)
[15:02:15] *** Joins: nij- (~jin@2001-48F8-9021-806-0-0-0-954B-dynamic.midco.net)
[15:02:47] <nij-> It's hard to program in C interactively. Is this going to change if I learn and use cffi?!
[15:03:49] <hayley> It Depends™️. It is nice to be able to interactively prod at alien things, but those alien things can sometimes be written in a way that is hostile to interactive prodding.
[15:04:26] <hayley> And you are out of luck if you need to change anything on the C side, which I am shore probably won't be necessary if you are using someone else's library, but is worth mentioning.
[15:04:49] <nij-> s/shore/sure/ ?
[15:05:11] <hayley> Hm, no, the C side has a shore.
[15:05:12] *** Quits: amb007 (~a_bakic@44.104.204.77.rev.sfr.net) (Read error: Connection reset by peer)
[15:05:18] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[15:07:32] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[15:07:45] <mfiano> oh boy :)
[15:08:25] <nij-> lol ok :)
[15:09:08] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[15:12:42] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[15:13:14] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[15:14:06] <lisp123> Is C a hard language to learn?
[15:14:40] *** Joins: PinealGlandOptic (~PinealGla@37.115.210.35)
[15:17:13] *** Quits: dsk (~dsk@user/dsk) (Ping timeout: 250 seconds)
[15:18:05] *** Quits: frgo (~frgo@p200300deef181d00bd7bf1868c9cad97.dip0.t-ipconnect.de) (Remote host closed the connection)
[15:18:23] <mfiano> No, but it's hard to use effectively.
[15:18:33] *** Joins: jimka (~user@2a01:e0a:26a:f400:78f1:4c5d:36e:1258)
[15:18:33] *** Joins: frgo (~frgo@p200300deef181d00bd7bf1868c9cad97.dip0.t-ipconnect.de)
[15:19:01] <nij-> I'm spoiled by lisp's interactive devel experience.. C seems hard
[15:19:08] <lisp123> mfiano: thanks
[15:19:20] <hayley> It's simple enough, but you don't get much to work with, and what you do get out of the box is quite nice for blowing your feet off.
[15:19:44] <mfiano> Just your feet? You're lucky
[15:19:47] <lisp123> Will C always be around or will "Rust" take over?
[15:20:00] <hayley> Neither.
[15:20:20] <lisp123> Assembly?
[15:20:44] <hayley> mfiano: I'm pretty sure the idea is to merely scare them, not give them nightmares for the rest of their life.
[15:21:19] <hayley> lisp123: If your name is John von Neumann, sure.
[15:21:28] <mfiano> There will always be languages with gimmicks, just like there always has been.
[15:21:36] <mfiano> I wouldn't say any will "take over"
[15:22:49] *** Joins: rogersm (~rogersm@90.166.177.48)
[15:23:06] <lisp123> For example, as I understand now, a Lisp compiler will parts of its code written in C, will there be a future where C is not used as the base language?
[15:23:37] <nij-> I'm overwhelmed.. could someone help come up with a basic usage example for this lib...... https://github.com/tdrhq/cl-unix-sockets/blob/master/unix-sockets.lisp
[15:23:48] <nij-> It's full of CFFI and I don't really know C :(
[15:23:56] <lisp123> And Emacs also has some code written in C
[15:24:01] <mfiano> As long as you are interfacing with traditional operating systems, it is unavoidable.
[15:24:13] *** Joins: random-nick (~random-ni@87.116.181.197)
[15:24:20] <lisp123> mfiano: i see - thanks
[15:25:30] <hayley> nij-: Well, there is a test file which shows off most of the interface: https://github.com/tdrhq/cl-unix-sockets/blob/master/test-unix-sockets.lisp
[15:26:47] *** Quits: srhm (~ascii@user/srhm) (Quit: Konversation terminated!)
[15:27:10] *** Joins: srhm (~ascii@user/srhm)
[15:27:47] <nij-> Oh, it reminds me that tests are actually my friend not foe! Thank you hayley :)
[15:28:11] <hayley> You can barely get by with mere syscalls on Unix, so C is avoidable. But another view is that you don't touch bare C from Emacs or most Common Lisp code.
[15:29:11] <hayley> But none of the big native-code Lisp compilers (SBCL, Clozure, SICL) have C code; the latter two have interface stuff written in C, but that's it.
[15:30:50] <lisp123> hayley: interesting, thanks for the colour
[15:31:26] <pjb> nij-: there are C interpreters.
[15:31:28] <pjb> with repl etc.
[15:31:38] <nij-> Can I expect to find the standard C libs in linux in Windows as well?
[15:31:39] <pjb> nij-: cf. cint, eic,
[15:31:58] <pjb> standard C libraries are found anywhere a standard C compiler runs.
[15:31:59] <nij-> pjb: my impression is that they are not stable enough.. remembered trying some of them
[15:32:21] <nij-> pjb oh that makes sense!
[15:33:09] <pjb> well, that depends on the number of users.  More users => more bug found => more maintenance work => fewer bugs remaining.
[15:33:48] <nij-> Then.. why is cl-unix-sockets not supporting Windows? Both C and common lisp should be able to run on Windows.
[15:34:09] <mfiano> Not enough developer interest more than likely
[15:34:20] <hayley> Are there even Unix sockets on Windows?
[15:34:24] <nij-> Yeah, it's not the nature of C that prevents a good enough C interpretor to be made?
[15:34:53] <hayley> And, also note that C doesn't specify how networking works - that is specified in the standard for your operating system (e.g. POSIX).
[15:34:59] <nij-> hayley: I don't know really. I'm not sure if that's an abstraction of socket that's called by the name "Unix sockets".
[15:35:23] <mfiano> hayley: win10 and later apparently
[15:35:59] <pjb> nij-: no, there are windows sockets on windows, not unix sockets.
[15:36:23] <pjb> nij-: not at all the C language doesn't prevent a good interpreter to be implemented.
[15:36:27] <hayley> You could surely write a C interpreter, but a. I doubt it would make for a productive environment and b. you are asking the wrong question - a compiler would also work, you just have to be able to run it on the fly.
[15:36:32] <mfiano> pjb: there are Unix domain sockets in windows 10 version 1803
[15:36:36] <pjb> nij-: it's the nature of C programmers that prevents them to use interpreters.
[15:37:07] <pjb> mfiano: but does it uses the same API as on unix?
[15:37:45] <hayley> I think Windows snarfed the BSD socket API a long time ago.
[15:38:14] <mfiano> No idea. I haven't used Windows since windows 2000
[15:38:26] <hayley> Random example: https://docs.microsoft.com/en-gb/windows/win32/api/winsock/nf-winsock-recv
[15:38:45] <nij-> Seems that they support bash too...
[15:38:45] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[15:39:20] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[15:39:40] <hayley> Nasty example code though.
[15:42:08] *** Quits: kakuhen (~kakuhen@user/kakuhen) (Quit: Leaving...)
[15:51:41] *** Quits: srhm (~ascii@user/srhm) (Ping timeout: 258 seconds)
[15:57:02] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[15:58:34] *** Quits: jimka (~user@2a01:e0a:26a:f400:78f1:4c5d:36e:1258) (Ping timeout: 240 seconds)
[16:25:04] *** Joins: jimka (~user@2a01:e0a:26a:f400:78f1:4c5d:36e:1258)
[16:31:19] <lotuseater> lisp123: i found a book with a mathematical introduction to C, maybe that will help me. but better learn to use CFFI first
[16:31:51] <lotuseater> hayley: there's a C++ interpreter written by CERN physicists for their ROOT system
[16:31:52] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[16:32:10] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[16:32:47] <lisp123> lotuseater: Hvae you see the recipe for CFFI in Common Lisp Recipes? It was quite good (but maybe its too basic for what you are after)
[16:32:57] <lotuseater> yes i did
[16:33:10] <lisp123> thought so
[16:34:37] <lotuseater> the big difference is, when you write bindings to *.so files or such, you're not enslaved to write that in C but do it in CL
[16:35:28] <lotuseater> lisp123: there's a 2h video by cbaggers about CFFI, very good and one of his longest in the series
[16:36:01] <lotuseater> https://www.youtube.com/watch?v=A5CnYlG7sc8
[16:36:27] <lisp123> lotuseater: Nice, I will watch it one day. For now I'm lucky to avoid having to use anything outside of Lisp
[16:37:24] <lotuseater> but be careful out there, they will tell you it MUST be done in C :)
[16:40:19] <beach> lisp123: Are you saying that there must be some C code in a Common Lisp system?
[16:41:06] <lotuseater> so when you ie do cffi:with-foreign-object in SBCL (and surely the most other similarly) it gets stack-allocated with dynamic-extent. all those (for us) alien objects
[16:41:50] <lisp123> beach: I was saying that some point (I may likely be wrong) that C is required - it can be thrown away later once its compiled?
[16:42:07] <lisp123> is likely to be required* - from what I have read
[16:42:23] <beach> lisp123: You should have told me that a decade ago.  I would never have started SICL if I knew that.
[16:42:47] <beach> lisp123: I am still waiting for that day to happen though.  So far, there is not a single line of C code in SICL.
[16:42:51] <lisp123> beach: Glad I didn't :D
[16:42:54] <lotuseater> beach: I think lisp123 means iff nothing else is there formerly.
[16:43:11] <lisp123> lotuseater: yes, that's what I meant
[16:43:15] <beach> So back in 1957?
[16:43:22] <beach> C didn't exist then.
[16:43:26] <lotuseater> so you can say as with McCLIM "Now featuring 100% less C."
[16:43:40] *** Joins: yitzi (~yitzi@173-27-106-188.client.mchsi.com)
[16:44:35] <lotuseater> I once wanted to tell a C programmer the type "void" can't exist, he got scared and yelled at me.
[16:45:46] <beach> nij-: As hayley said, C can certainly be interpreted, just as Common Lisp can be compiled.  But the definition of C and most static languages is such that there is a compile-link-execute cycle.  These languages don't have defined semantics for (say) modifying a definition at run time.
[16:46:07] <lisp123> beach: in the context of something like this: https://guix.gnu.org/en/blog/2020/guix-further-reduces-bootstrap-seed-to-25/
[16:46:54] <hayley> The void type sorta does exist; we can say that some expression is of type void. And you can return a "void" value of some sort, but it's not really a value. In ML, for example, the equivalent to void would be a tuple of 0 elements, i.e. the type ().
[16:46:59] <beach> lisp123: But that's not in 1957.  That's now.  Now that we have several very good Common Lisp systems, no C is required.
[16:47:29] <lisp123> beach: but at some point those systems required C, no?
[16:47:44] <phoe> at some point they even didn't require C
[16:47:45] <beach> No!  What makes you think that?
[16:47:51] <phoe> ;; because C did not even exist
[16:48:17] <lisp123> I see
[16:48:20] <hayley> For example, given the declaration void foo(); we know the expression foo() is necessarily of type void. It is impossible to use such a value, but the type itself exists.
[16:48:50] <shka> void is not real, it can't hurt you
[16:48:52] <beach> lisp123: I am really curious to understand why you think C is required.
[16:48:52] <phoe> also see mezzano for a completely C-less Lisp implementation
[16:48:53] <jackdaniel> lisp123: computer (as a machine) has certain binary protocols for telling the machine what to do
[16:49:13] <jackdaniel> usually an abstraction layer is put on top of it (a kernel so to speak), but that's not even necessary
[16:49:29] <lisp123> beach: Well I was reading this paragraph "Currently, Mes consists of a mutual self-hosting scheme interpreter and C compiler. It also implements a C library. Mes, the scheme interpreter, is written in about 5,000 lines of code of simple C. MesCC, the C compiler, is written in scheme. Together, Mes and MesCC can compile a lightly patched TinyCC that is self-hosting. Using this TinyCC and the Mes C library, it is possible to bootstrap the enti
[16:49:29] <lisp123> re Guix System for i686-linux and x86_64-linux."
[16:49:36] <jackdaniel> either way, said program is compiled by some means to that binary protocol language
[16:49:52] <hayley> shka: "Who is lotuseater?" "He is afraid of the void type." "foo()!" "Stop it, hayley! You're scaring him!"
[16:50:10] <shka> lisp123:  oh, you can write without C
[16:50:16] <jackdaniel> and there is no need to have the source language to be "C", it may be very well lisp
[16:50:17] <shka> you can even write without glibc
[16:50:25] <beach> lisp123: But the fact that one system requires C doesn't mean that every system requires it.  I am still curious about why you thought so.
[16:50:53] <jackdaniel> omnipotence of C ABI certainly gives that impression ,)
[16:50:58] <lisp123> I thought operating systems were written in C?
[16:50:59] <beach> lisp123: As in, I am interested in the kind of thinking that lead to that conclusion.
[16:51:01] <phoe> omnipotence?
[16:51:03] <phoe> or omnipresence?
[16:51:07] <phoe> lisp123: no?
[16:51:13] <phoe> again, see mezzano for a completely C-less operating system
[16:51:17] <shka> lisp123: usually they are, but they don't have to be
[16:51:17] <hayley> lisp123: Only if your name is Andrew Tanenbaum.
[16:51:22] <beach> Heh.
[16:51:24] <phoe> https://github.com/froggey/Mezzano/
[16:51:45] <lisp123> But was CMUCL written on a platform that was written on C?
[16:52:04] <shka> lisp123: the big thing with C is the libc which allows you to not use system calls directly
[16:52:17] <phoe> lisp123: no idea, some part of it surely was
[16:52:19] <beach> lisp123: You keep bringing up examples.  But I am interested in knowing why you thought that *any* system would require C.
[16:52:31] <jackdaniel> phoe: omnipotence has at least two meanings I'm aware of -- one is (as you probably assumed) being all-powerful; second is adaptivity (as in cellular biology)
[16:52:31] * pl recalls OSes written in Lisp, C#, Pascal, Oberon, Ada, PL/I, PL/M, BLISS... 
[16:52:33] <hayley> It probably was, but -- I'm just going to say what beach said.
[16:52:34] <phoe> but some parts of it might have been written on a lisp machine which was microcode + lisp
[16:52:34] <lotuseater> hayley: I can greatly imagine this scene in a meme! :D
[16:52:48] <pl> CMUCL originated from a system without C
[16:52:52] <lisp123> shka: thanks for that
[16:52:54] <phoe> jackdaniel: oh, I think I understand now
[16:52:54] *** Quits: nirnam (~nirnam@1.47.135.162) (Remote host closed the connection)
[16:53:14] <hayley> But, do note, that going back a few hours in context, you don't need to touch C for most programming exercises anyway.
[16:53:18] <pl> I believe the C runtime portion that SBCL also kinda inherited showed up much later eith Unix port
[16:53:35] <shka> lisp123: btw, it is not just lisp, Golang in the original guise was producing binaries which would not link libc
[16:53:46] <shka> even
[16:53:56] <shka> but this was difficult to maintain
[16:54:00] <hayley> Hm, Macintosh Common Lisp (aka Clozure) would have had Pascal code early on. The FFI uses Pascal terms from memory.
[16:54:14] <lotuseater> shka: it's just saying "hey, I'm a funny procedure doing nasty side-effects. have fun!"
[16:54:19] <lisp123> C's got a good marketing team :)
[16:54:20] <pl> Golang still doesn't link with libc outside of few platforms
[16:54:26] <beach> lisp123: Please!  I am very interested in the way people reason about these things.  So help me out here.
[16:54:41] <pl> I often setup building without libc on purpose
[16:54:42] <shka> pl: well, it does link with libc even on linux now :/
[16:54:47] <hayley> lotuseater: That is still a type though. Oh, in Haskell we might write IO ()
[16:54:50] <pl> shka: not mandatory
[16:54:54] <shka> true
[16:55:08] <pl> shka: and lots of software builds without libc
[16:55:20] *** Quits: jimka (~user@2a01:e0a:26a:f400:78f1:4c5d:36e:1258) (Ping timeout: 256 seconds)
[16:55:29] <lotuseater> hayley: you're right of course :)
[16:55:34] <hayley> But then again, write does an obvious side effect, but returns a ssize_t, which is not void, so it cannot be a funny procedure doing nasty side-effects.
[16:55:40] <shka> lisp123: thing is, C is just another programming language, it's position is because of historical reasons
[16:55:49] <pl> Also, Windows specifically does not require C
[16:56:10] <shka> in the alternate timeline, pascal for instance could occupy the same niche as C
[16:56:26] <lotuseater> and it's more or less special purpose for handling register machines
[16:56:29] <lisp123> shka: or even lisp
[16:56:31] <phoe> lisp123: the thing is that our x8664 or ARM machines don't run C or Lisp or whatever other language, they run assembly
[16:56:32] <pl> shka: it used to, even beating out C++ (I did a lot eith Delphi)
[16:56:33] <beach> lisp123: Even if you meant "a language with the low abstraction level that C has", I am interested in your reasoning.
[16:56:43] <shka> pl: yeah, that's the point!
[16:56:45] <phoe> and assembly can be generated from lots of languages by compilers written in lots of languages
[16:56:55] <shka> turbo pascal was hot stuff at some point
[16:57:01] <phoe> and then fed to the CPU, bam, we have useful programs
[16:57:05] <lisp123> beach: It was because I assumed people didn't program directly in Assembly, so they used something one level up
[16:57:13] <pl> lisp123: btw, it's arguably impossible to write OS in standard-compliant C
[16:57:16] <phoe> lisp123: that's the case most of the time
[16:57:23] <phoe> but that thing one level up does not need to be C
[16:57:29] <shka> lisp123: i mean, you can write lisp in lisp
[16:57:37] <beach> lisp123: So now I am interested in knowing why you think a Common Lisp system must have some assembly code in it.
[16:57:37] <pl> lisp123: at the very least you end up with A LOT of assembly subroutines
[16:57:38] <shka> just like gcc is written in C
[16:57:59] <pl> beach: does LAP/VOPs count as assembly? XD
[16:57:59] <lisp123> shka: but at some point you have to talk in the language of machines
[16:58:15] <lotuseater> starting with the metacircular interpreter :)
[16:58:17] <shka> lisp123: listen, language of machines is just vectors of bytes
[16:58:18] <pl> lisp123: yes, you can do so through the compiler
[16:58:27] <shka> your cpu is not executing C
[16:58:35] <shka> it is executing machine code
[16:58:44] <beach> pl: I am interested in lisp123's reasoning, because I think there are lots of people out there who does the same kind of reasoning, and I think it is fascinating.
[16:58:47] <lisp123> shka: yes but I assume people don't want to write their lisp interpreters in 1s and 0s
[16:58:51] * hayley got dangerously close to writing a LAP for Cleavir today.
[16:58:55] <shka> which is essentially vector of bytes
[16:59:10] <jackdaniel> lisp123: how about writing lisp compilers in lisp?
[16:59:18] <lotuseater> hayley: what does LAP mean in this context?
[16:59:19] <lisp123> beach: I will give you a timeline of this non scientific thinking
[16:59:24] <beach> lisp123: Yes, the code generator of the compiler much generate machine instructions.
[16:59:27] <phoe> lotuseater: Lisp Assembly Program
[16:59:28] <hayley> lotuseater: Lisp Assembler Program
[16:59:34] <pl> beach: I think it's related to memetic "C is close to hw" (very untrue), combined with how bad knowledge transfer is in computing
[16:59:35] <beach> lisp123: Is that what you mean?
[16:59:36] <shka> lisp123: i think that you are confused about the term "interpreter"
[16:59:36] <lotuseater> thx :)
[16:59:41] <phoe> hayley: assembly or assembler?
[17:00:01] <hayley> Good question.
[17:00:07] <shka> perhaps both
[17:00:11] <lisp123> if I have file of lisp commands which I need to execute - one needs to convert this to processor instructions right
[17:00:23] <beach> lisp123: Yes, the compiler does that.
[17:00:33] <lisp123> and what is the compiler written in?
[17:00:37] <beach> Common Lisp.
[17:00:37] <lotuseater> I'm rather the dumbest person in the room and ask annoying questions than just pretending to know it. or I try to
[17:00:58] <lisp123> But how did the computer run the first Common Lisp program
[17:01:05] <lisp123> the compiler
[17:01:12] <jackdaniel> lisp123: you may write a compiler to arch-xxx assembler in common lisp; what's even more interesting, that compiler may be compiling java to assembly (despite being written in common lisp)
[17:01:13] <pl> lisp123: are you bootstrapping from zero?
[17:01:28] <lotuseater> and to be honest, form of Assemblers is more close to some kind of lisp when one removes the parentheses
[17:01:35] <pl> Because remember, if you want to make an apple pie from scratch, you start by creating the universe
[17:01:52] <lisp123> pl: yes, at least from processor instructions to lisp
[17:01:56] <beach> lisp123: You cross compile on a different computer, so that a binary for the new computer is generated.  Then you transport that binary to the new computer.
[17:02:13] <lotuseater> pl: that would be really scratchy :P
[17:02:21] <jackdaniel> (what beach said is also done for C compiler ports to new architectures)
[17:02:34] <phoe> ah yes, the famous cross-compilation technique
[17:02:36] <lotuseater> or with GHC and and and
[17:02:42] <tyson2> At my former company, we created cross-assemblers in Lisp for various microprocessors
[17:02:46] <lisp123> beach: yes, of course, that's obvious. But to go from scratch to lisp was my point
[17:02:57] <jackdaniel> why though?
[17:02:59] <lisp123> And I assumed (likely incorrectly) that C helped there
[17:03:03] <tyson2> I still have a copy of the 8086 assembler, two pages of lisp
[17:03:05] <jackdaniel> do you program C compiler from scratch in 0 and 1?
[17:03:07] <beach> lisp123: So we are back in 1957?
[17:03:17] <pl> lisp123: you need /something/ to start programming with
[17:03:24] <lisp123> jackdaniel: say we have a new super chip from a company called "Orange", M77
[17:03:32] <lotuseater> and then one designs special hardware in FPGA and you can run run lisp natively for real
[17:03:41] <Josh_2> Afternoon
[17:03:41] <lisp123> I was thinking one would write the C compiler first and then the lisp
[17:03:43] <hayley> It is not unlikely that the first Common Lisp system was compiled by another Lisp system.
[17:03:43] <shka> lisp123: yes, you technically can write lisp (or C!) compiler in assembly
[17:03:43] <phoe> I assume that some people are interested in trusting trust and what not, and want to be able to ensure that their software does not have any backdoors compiled in by already existing compiler binaries
[17:03:49] <pl> Wurst Kase scenario, you start by low level switch panel and enter bootstrap code you assembled by hand
[17:03:49] <lisp123> that was the whole basis of the initial thought
[17:03:59] <phoe> so they want to start with 100% source code and no binaries
[17:04:04] <hayley> lotuseater: "Good God no, don't do that!" - Cliff Click
[17:04:07] <jackdaniel> jackdaniel: then C compiler vendor writes a port for their compiler in C; and Lisp compiler vendor writes a port of their compiler in Lisp (both targetting Orange M77)
[17:04:09] <shka> lisp123: are you wondering about the bootstrapping process?
[17:04:18] <jackdaniel> then they cross compiler compilers to that machine and poof, each may run natively
[17:04:20] <beach> lisp123: No, you would generate an executable on a different system, and then transport that executable.
[17:04:31] <jackdaniel> lisp123: ^
[17:04:33] <pl> lisp123: but if you are starting from position where other computer exists, you build a cross compilation system that can generate a binary of your compiler for the new chip plus ways to load it
[17:04:36] * hayley has memorised only the funny parts of watching too many Java implementation presentations.
[17:04:43] <lisp123> beach: but to answer your more general question, its because everyone talks about C - so the conneciton is that C is required at some level. Doesn't mean its the right thinking, but that's what others would be thinking too if I imagine
[17:05:02] <lotuseater> beach: I hope you don't get peevish about such phrases.
[17:05:04] <hayley> Who is "everyone"?
[17:05:22] <jackdaniel> C ABI is present on all major operating systems (Linux, Windows, OSX, even Android)
[17:05:39] <shka> lisp123: C is not required, but it is simply very convenient
[17:05:40] <lisp123> shka: yes you could say that. If its a brand new chip with brand new instructions, how woulod you do it?
[17:05:51] <shka> now, that is interesting question!
[17:06:10] <lotuseater> hayley: if I would be able doing VHDL or Verilog some day ... you can get cheap open hardware boards by OLIMEX with also an open toolchain
[17:06:13] <pl> lisp123: I'd write a compiler backend for SBCL, then follow its cross-compilation mechanism?
[17:06:15] <phoe> lisp123: use an existing compiler, write a new backend for it
[17:06:22] <phoe> then copy the resultant binary to the new machine
[17:06:24] <pl> (not too specific)
[17:06:26] <shka> lisp123: ok, so here is how this works
[17:06:28] <hayley> lisp123: I would modify the backend of a compiler to emit code for that instruction set, and have it compile itself.
[17:06:39] <lisp123> and that would be written in lisp?
[17:06:46] <phoe> that can be written in anything
[17:06:51] <shka> lisp123: ok, let's go back to basics
[17:06:51] <phoe> a compiler is just a program
[17:07:00] <beach> This is fascinating stuff.
[17:07:05] <phoe> it eats source code and spits out some binary blobs
[17:07:12] <shka> so on the cpu, you gonna need a specific vector of bytes to execute
[17:07:15] <hayley> lotuseater: https://youtu.be/5uljtqyBLxI?t=1213
[17:07:27] <shka> it will be different on different instruction sets
[17:07:37] <lotuseater> lisp123: you can if you would like, also imagine lisp macros as little compilers
[17:07:39] <phoe> the interesting stuff is that a compiler can spit out amd64 blobs even if it is not running on an amd64 machine
[17:07:44] <phoe> do you know how this works?
[17:07:52] <shka> however, compilers are usually separated into few parts, and one of those is the code generator
[17:07:53] <phoe> or how that is possible?
[17:08:23] <lisp123> lotuseater: thanks, makes sense
[17:08:24] <shka> and if you wanna support new instruction set, optimistically you need to make a new code generator
[17:08:35] <lisp123> shka: ok that makes sense
[17:08:37] <lotuseater> hayley: oh damn. but I must watch later, about to going out
[17:08:46] <hayley> Rather just make a nice instruction set that is easy to compile to. David Ungar and David Patterson's Smalltalk on a RISC went down the same way, and the LMI K machine would have: http://fare.tunes.org/tmp/emergent/kmachine.htm
[17:08:56] <lisp123> So basically we don't need anything other than Lisp, thats good to know :D
[17:09:05] <_death> https://en.wikipedia.org/wiki/Retargetable_compiler
[17:09:16] <phoe> lisp123: in theory the same goes for any Turing-complete language
[17:09:20] <shka> but you can still use your parser, some optimizers and everything else which is portable across architectures
[17:09:25] <beach> lisp123: And that is what I fully intend to pull off with SICL, which is why I teased you with that in the beginning.
[17:09:27] <phoe> it's just a matter of what is the most convenient to use
[17:09:55] *** Joins: Bike (~Glossina@71.69.170.70)
[17:09:56] *** ChanServ sets mode: +o Bike
[17:10:06] <shka> and obviously, since we are still talking about vectors of bytes, sure, you can generate those vectors let's say on the x86 PC for the ARM linux machine
[17:10:09] <shka> no problem
[17:10:23] <lisp123> yes that makes sense
[17:10:25] <shka> i mean, in theory, sometimes it gets tangled in a technical details
[17:10:51] <lisp123> beach: so will you have something that converts lisp to machine code?
[17:10:59] <shka> lisp123: that is called a compiler
[17:11:06] <lisp123> as in new machine code
[17:11:09] <beach> lisp123: Yes, what shka says.  It's the compiler.
[17:11:30] <beach> lisp123: Yes, the code generator of the compiler spits out native instructions.
[17:11:46] <lisp123> nice
[17:11:53] <beach> lisp123: So hayley is working on the "register allocator", and next is the "code generator".
[17:12:03] <hayley> lotuseater: If I had a FPGA and a lot of time, I'd build a relatively boring RISC, but one I knew how to compile to easily, and with some more subtle tricks like read and write barriers in hardware.
[17:12:49] <beach> lisp123: But that's nothing new.  SBCL does that as well.
[17:12:50] <lisp123> beach: that makes it very cool because its no longer dependent on any other programs or lisp
[17:13:00] <lisp123> I assumed there was some C somewhere
[17:13:19] <beach> There is in SBCL, but very little, and nothing in the compiler I think.
[17:13:22] <lisp123> but I guess when you put it in terms of creating machine instructions directly from lisp (for new processors), it makes sense
[17:13:33] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[17:13:37] <lisp123> existing processors I never had an issue with, because one already had the binaries
[17:13:51] <beach> lisp123: Good that we finally sorted out that issue.
[17:14:06] <shka> (SBCL has C for garbage collection, this could be technically be done in lisp, but it would make it more difficult AFAIK)
[17:14:10] <beach> Again, fascinating stuff.
[17:14:58] <shka> lisp123: remember, CPUs are stupid, they just talk in vectors of bytes
[17:15:01] <lisp123> Wonder why GNU Mes is using C?
[17:15:04] <beach> lisp123: And, as other pointed out, Mezzano is a complete Common Lisp system and an operating system, entirely written in slc.
[17:15:09] <beach> in Common Lisp
[17:15:23] <lisp123> They should've just done it all in Scheme or Guile or whatever
[17:15:30] <phoe> lisp123: it says GNU in the name, tons of gnu utils are written in C since that is what was popular in their circles
[17:15:43] <shka> (CPUs essentially do very simple stuff, very, very, very quickly)
[17:15:49] <beach> lisp123: The thinking that it took half an hour or so for you to accept is pervasive.
[17:15:49] <phoe> but that's just a history tidbit and might not be 100% true
[17:15:55] * hayley wonders what abbrev slc is a typo of. No obvious characters nearby on this keyboard.
[17:16:10] <lisp123> shka: indeed :)
[17:16:33] <lisp123> phoe: Thanks
[17:16:34] <beach> hayley: "cls" is my abbrev for "Common Lisp"
[17:16:38] <phoe> SLC = Simple Lisp Compiler, beach's new project to each compiler basics as well as lisp basics to new people
[17:16:40] <Xach> catastrophic dabbrev failure
[17:16:52] * phoe ducks
[17:16:55] <shka> lisp123: well,  the historic goal of GNU was to replace the unix with open source copy
[17:16:58] <phoe> s/each/teach/
[17:17:29] <shka> and unix is written in C mostly
[17:17:40] <shka> so perhaps this is the explanation
[17:17:41] <lisp123> shka: thanks
[17:17:59] <shka> don't quote me in on that, i am not well versed on the gnu history
[17:18:03] <lisp123> beach: and that's where you will find a lot of us assuming C is omnipresent everywhere (to your earlier question)
[17:18:39] <shka> lisp123: yeah, the omnipresence in the strongest side of C
[17:18:40] <beach> lisp123: Yes, but I am interested in how the thinking goes.
[17:19:05] <shka> but notice that it has little to do with the design of the language
[17:19:33] <shka> and everything with the huge success of unix which spread C all over the computers
[17:20:08] <shka> but, for instance, the OG apple macintosh
[17:20:16] <lisp123> beach: C is systems language -> C is fast -> Other languages slow (C is "closest to the metal" -> Other languages written in C -> OK we understand stuff can get compiled to binary -> some fuzzy autocomplete -> C is required somewhere to write compilers for other languages because its fast
[17:20:35] <shka> IIRC the operating system for this machine was more pascal
[17:20:39] <lisp123> doesn't sound great when writing it down, but I wouldn't be suprised if many thought the same way
[17:21:07] <shka> lisp123: C is not fast, it does not make your computer to execute more intructions per second
[17:21:07] *** Joins: jimka (~user@2a01:e0a:26a:f400:78f1:4c5d:36e:1258)
[17:21:08] <phoe> lisp123: "C is systems language" sounds like "C is THE systems language"
[17:21:12] <phoe> which is, eh
[17:21:25] <nij-> Anyone knows how C deal with UNIX sockets natively? I wonder why CL needs to go through it in order to take control..
[17:21:41] <nij-> Like.. what's preventing me from dealing with UNIX sockets directly using Common lisp?
[17:21:51] <phoe> nij-: you mean network or local ones?
[17:21:51] <lisp123> shka: nice, did you have one?
[17:21:58] <nij-> local ones, file based
[17:22:14] <nij-> We have one here, but it's using CFFI and C https://github.com/tdrhq/cl-unix-sockets/blob/master/unix-sockets.lisp
[17:22:48] <lisp123> shka: some people seem to think one can do special tricks with C
[17:22:49] <shka> nah, i am from poor eastern country, at the time zx spectrum was the high point of computer freak aspirations
[17:23:06] <shka> well, commodore as well
[17:23:19] <Bike> nij-: operating systems have system functions that you can call, such as socket(2)
[17:23:22] <lisp123> which makes it closer to assembly / coding directly in machine language
[17:23:36] <Bike> nij-: the lisp compiler needs to be aware of how to call them, but it's doable, and i think SBCL has direct system calls for some things
[17:23:56] <shka> lisp123: you can't do anything, because it boils down to the fact that the only thing which C is
[17:24:14] <shka> is the description of how to generate machine code
[17:24:36] <shka> it is not like your computer be able to do anything different if you use C
[17:24:56] <Bike> i'm not sure if syscalls are part of the posix standard or what
[17:26:07] *** Quits: lotuseater (~user@p200300e7871b3f0034ed9e810c3724ce.dip0.t-ipconnect.de) (Quit: ERC (IRC client for Emacs 27.2))
[17:26:09] <shka> however some of the C programmers know the compiler really, really well and they KNOW what kind of machine code should be expected from the C code they wrote
[17:26:47] <beach> lisp123: Thanks.  I am interested in how the reasoning goes, because it is responsible for a lot of unnecessary maintenance requirements.
[17:26:51] <Bike> i think the system calls are in general not stable compared to libc, so going through libc is easier maintenancewise
[17:27:20] <shka> this is partially because those programmers put enough of time to get good at it, and partially because C is thin abstraction compared to let's say Common Lisp
[17:27:41] *** Joins: tfeb (tfb@gateway/vpn/protonvpn/tfb)
[17:28:22] <nij-> Bike: Oh, so it's possible? And the reason why C seems to be a better language for this job is that there are many libs to interact with the system functions already?
[17:28:50] <nij-> And also, C has prevailed. So it's actually better for me to call C for maximal portability?
[17:28:51] <Bike> that is basically my understanding
[17:29:01] <hayley> beach: I've seen two people think that C is only worth mentioning because of imagined popularity and influence.
[17:29:02] <Bike> and of course operating systems commonly present a C API
[17:29:03] <beach> The problem with C as a low-level language for writing things like operating systems, though, is that such a system requires code that has undefined behavior according to the C standard, so you have to write for a particular version of a particular compiler.
[17:29:05] <shka> lisp123: regardless, in other world Pascal (for instance!) would be the system language and C would be this obscure language of historical significance
[17:29:09] <nij-> Cool
[17:29:31] <beach> hayley: Here?
[17:29:40] <hayley> Not to say people don't use C, but it's not the damn "backbone of the internet" or "modern" computing or so on.
[17:29:40] <lisp123> shka: is Pascal more of an abstraction than C? Because that would imply it would be a bit harder to get the same performance out of it?
[17:29:57] <hayley> beach: Not here, no, just anywhere on the Internet.
[17:30:03] <beach> I see.
[17:30:04] <shka> i would rather not discuss Pascal here :D
[17:30:49] <shka> lisp123: but my point is, C is not unique as a language, it is the historical background which made it so relevant as it is today
[17:31:04] <hayley> Though amusingly someone at my old university took a look at an uncited programming language popularity list, added up usage of C and C++ (claiming the latter was a superset of the former) and proclaimed it even more popular than Java.
[17:31:59] <shka> lisp123: one should not confuse the technical side of programming with sociological and historical surroundings
[17:32:34] <lisp123> shka: that makes sense
[17:33:00] <shka> to be fair it is easy to get confused because computer history is not accessible subject
[17:33:27] <shka> AFAIK there is no handbook that would explain "How we got here"
[17:34:07] <shka> and trying to figure out when certain language features where invented is sometimes just impossible
[17:34:33] <shka> for instance when were docstrings invented?
[17:34:47] <lisp123> Yup, and everything contributed to each other - its a shared struggle of progress
[17:34:55] <shka> but this is offtopic
[17:35:31] <hayley> Clearly Python invented docstrings. :)
[17:35:41] <shka> clearly
[17:36:14] <hayley> Though I could imagine they invented the shortening of "documentation string" in a more formal setting.
[17:36:29] <shka> lisp123: i hope that you are less confused when you were before
[17:37:15] <lisp123> shka: a little better thanks. I know now lisp is fully free and independent :)
[17:37:36] <shka> well, same goes for other languages
[17:37:52] <shka> like for instance Golang
[17:38:23] <beach> lisp123: That kind of thinking leads to increased maintenance because some people think you need to write a Common Lisp system in layers, starting with CAR/CDR, and then each new module must use only the subset provided by previously defined modules.  Even the SBCL compiler does not use generic functions and standard classes for instance.
[17:42:40] <lisp123> beach: yes, its not a practical thought. I suspect it might be because Lisp programmers like to build their programs up, and hence would like the the underlying compiler to do the same
[17:43:40] *** Quits: vats (~vats@103.70.83.249) (Ping timeout: 272 seconds)
[17:43:47] <hayley> I don't build from mere cons cells though.
[17:44:34] <beach> lisp123: Well, in the case of SBCL, it is that CLOS is added last, because SBCL (or CMUCL) was started before CLOS was part of the standard, so for such systems CLOS is "bolted on" at the end.
[17:44:46] <phoe> build our programs up?
[17:45:03] <phoe> hmmm
[17:45:09] <phoe> I thought it's more like adding more mud to a ball of mud
[17:45:22] <phoe> and then you just split it in half and reshape into two balls of mud
[17:45:37] <tfeb> but the ball of mud was once a mud atom
[17:46:03] <phoe> it was once a ship of theseus but the wood got rotten real bad
[17:46:14] <contrapunctus> lol
[17:46:16] <hayley> But, if you play it right, you can implement Lisp with all of Lisp. However, you cannot build your new program with another implementation of it.
[17:46:26] <shka> we are all slaves to the history :P
[17:46:40] <tfeb> ... or at least some claim so.  Pretty sure there was always just mud
[17:48:00] <hayley> So I believe language implementation is very different to implementing a typical program.
[17:48:27] <beach> I have thoughts about creating an industry talk entitled something like "n psychological forces that decrease your productivity in developing software", and this "bootstrapping" thinking should be part of it.
[17:49:36] <tfeb> hayley: for me as a lisp hacker, language implementation and programming are the same thing
[17:51:57] <hayley> tfeb: If you want to phrase it that way, then with a program, you have no other implementation to borrow while building. But with a metacircular implementation, you can borrow the old implementation while you work your way to completion.
[17:53:11] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[17:53:17] <hayley> There is a lot of handwaving in that phrasing, but either case requires a different strategy to me.
[17:54:09] <tfeb> that's not what I meant: I think of my (nontrivial) programs as languages which extend CL.  There's usually no metacircularity because
[17:54:26] <tfeb> s/because//
[17:54:44] *** Quits: jimka (~user@2a01:e0a:26a:f400:78f1:4c5d:36e:1258) (Ping timeout: 258 seconds)
[17:54:51] *** Joins: selwyn (~selwyn@user/selwyn)
[17:54:57] <contrapunctus> beach: hey ^^ I tried to approach my project in a way that avoids the need for sandboxing, but got frustrated with it. I'd like to see if I can help make CL-implementation-independent sandboxing a reality. What does it involve doing? Can someone with no experience in Lisp implementation do it?
[17:55:31] *** Joins: davep (uid504677@id-504677.tinside.irccloud.com)
[17:56:24] <flip214> contrapunctus: if you only allow functions (and macros) within one package, and that package doesn't include OPEN, RUN-PROGRAM, etc., then no external access is possible.
[17:57:38] <phoe> contrapunctus: CL is a hard language to sandbox in the general case
[17:58:01] <phoe> if someone gains access to the COMMON-LISP package then you are toast
[17:58:09] <contrapunctus> flip214: CL packages? I thought it was possible to override them with package::symbol 🤔️
[17:58:46] <phoe> not only becaue you have unrestricted EVAL, but also because you can destroy memory safety via e.g. RESTART-BIND and other DYNAMIC-EXTENT stuff
[17:58:48] *** Joins: peterhil (~peterhil@mobile-access-5d6aa6-103.dhcp.inet.fi)
[17:59:36] <tfeb> If you wanted a sndboxed lisp I don't think you'd start from CL unless you had to.
[18:00:51] <phoe> see e.g. (flet ((fireworks () (restart-bind ((fireworks (lambda ()))) (compute-restarts)))) (print (fireworks))) on SBCL
[18:01:07] *** Quits: selwyn (~selwyn@user/selwyn) (Remote host closed the connection)
[18:01:31] *** Joins: selwyn (~selwyn@user/selwyn)
[18:02:01] <flip214> contrapunctus: If you read an external file, you can either make #\: an error, or just check the input for the symbols used.
[18:04:35] <hayley> (funcall (intern "RUN-PROGRAM" "SB-EXT") ...)
[18:05:07] <contrapunctus> flip214, phoe, tfeb: to be clear, I was implicitly referring to beach's work on first-class global environments. He has mentioned on many occasions its potential for use in sandboxing.
[18:05:34] *** Quits: hendursa1 (~weechat@user/hendursaga) (Quit: hendursa1)
[18:07:07] *** Joins: hendursaga (~weechat@user/hendursaga)
[18:07:18] *** Joins: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3)
[18:08:08] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[18:08:36] *** Joins: jimka (~user@2a01:e0a:26a:f400:78f1:4c5d:36e:1258)
[18:10:21] <flip214> hayley: well, INTERN must not be allowed, of course. Or FIND-SYMBOL.
[18:12:46] <tfeb> or format, or ...
[18:12:47] *** Joins: lisp123_ (~lisp123@45.130.83.208)
[18:13:36] <beach> contrapunctus: It is already possible with SICL first-class global environments, but I have not written any documentation meant for that purpose.
[18:15:45] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 250 seconds)
[18:17:09] *** Quits: tfeb (tfb@gateway/vpn/protonvpn/tfb) (Quit: died)
[18:17:24] <contrapunctus> beach: you mean, in an implementation-portable way? I was under the impression there was work to be done before that was possible ._.
[18:20:00] <beach> contrapunctus: I do that on a daily basis when I run the bootstrapping script for SICL.  It has to execute code that is totally separate from the host code.  It works in any Common Lisp implementation, provided it also has CLOSER-MOP.
[18:20:10] <hayley> It is possible to mechanically rewrite Common Lisp code to use first-class global environments.
[18:20:25] *** Joins: cage (~cage@dynamic-adsl-78-15-36-212.clienti.tiscali.it)
[18:21:12] <beach> contrapunctus: What hayley says.  The way we do it is we take the Cleavir-based compiler and translate the code to ASTs.  Then we translate the ASTs back to Common Lisp, but with every reference to a function or a special variable replaced, so that it refers to the first-class global environments instead.
[18:22:33] <beach> The Cleavir-based compiler is non-trivial of course, but it exists, and it seems to do the job.  The inverse translator is pretty trivial.
[18:23:10] <beach> This way, you can put in the first-class global environments what you want exposed to the code, and nothing else.
[18:32:43] *** Joins: selwyn (~selwyn@user/selwyn)
[18:34:59] *** Quits: selwyn (~selwyn@user/selwyn) (Remote host closed the connection)
[18:35:23] *** Joins: selwyn (~selwyn@user/selwyn)
[18:39:29] *** Joins: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431)
[18:40:07] <nij-> Hello! #'flexi-streams:string-to-octets transforms string of latin chars to a vector of octets. But my strings could contain other things.. is there nice transformer for general strings?
[18:40:15] <nij-> (I want to later transform it back too.)
[18:40:52] *** Quits: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3) (Read error: Connection reset by peer)
[18:41:19] <hayley> babel:string-to-octets
[18:42:43] <hayley> However, you could specify another encoding by e.g. :external-format :utf-8 for either function. The latter will most likely default to some Unicode though.
[18:43:29] *** Quits: jimka (~user@2a01:e0a:26a:f400:78f1:4c5d:36e:1258) (Ping timeout: 250 seconds)
[18:50:11] *** Joins: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3)
[19:01:23] *** Joins: lisp123 (~lisp123@5.30.23.247)
[19:01:54] *** Joins: nirnam (~nirnam@1.47.135.162)
[19:03:15] *** Quits: lisp123_ (~lisp123@45.130.83.208) (Read error: Connection reset by peer)
[19:05:13] *** Joins: dnaeon (~dnaeon@46.10.222.189)
[19:06:48] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 256 seconds)
[19:07:54] *** Joins: notzmv (~zmv@user/notzmv)
[19:09:28] <dnaeon> Hey Lispers! Is there a way to inspect the condition within a `restart-case' in case I need to provide more details to the user when an error is signalled. A use case would be to inspect the condition instance and change the prompt accordingly? For example `(restart-case (something-that-errors-out) (restart-A () ..) (restart-B (CONDITION) ...))` . How do I make restart-B accept an instance of the respective condition?
[19:10:29] <Josh_2> (restart-b (c) :report "blah blah" (do-something-with-condition))
[19:11:18] <Josh_2> c being the condition
[19:16:57] <pjb> dnaeon: you can pass the condition to the restart case: (restart-case (handler-bind ((error (lambda (condition) (inspect condition) (invoke-restart 'restart-B CONDITION)))) (something-that-errors-out))  (restart-A (arg) ..) (restart-B (CONDITION) ...))
[19:17:29] <pjb> dnaeon: but the idea is to inspect the condition in the handler, and to give the restart only the data it needs to perform the restart.
[19:18:38] <pjb> Of course, it would be silly to unwrap a rich condition into another object just to pass it to the restart. In that case you can just pass the condition to the restart.
[19:20:24] <yitzi> Adding to pjb, by itself restart-case or restart-bind won't do this. The lambda of each restart comes from invoke-restart or the interactive invoke. The condition is not included in the interactive invoke.
[19:21:04] <nij-> hayley:  <3 thanks!
[19:21:40] <dnaeon> pjb: I had the same idea about using `handler-bind' within a `restart-case', but wasn't sure whether this is idiomatic approach or not, so I abandoned that idea quickly.
[19:22:04] <pjb> It is the tool.  Don't think in terms of idioms, think in terms of tools.
[19:22:19] <pjb> If you have conditions, handler-case and handler-bind are the tools.
[19:24:24] <yitzi> dnaeon: You could also bind a dynamic variable to the current condition. This would make invoke-restart-interactively work without the condition in the lambda list.
[19:27:31] <dnaeon> pjb: yitzi: thanks!
[19:40:35] *** Quits: hendursaga (~weechat@user/hendursaga) (Remote host closed the connection)
[19:40:59] *** Joins: hendursaga (~weechat@user/hendursaga)
[19:41:09] *** Joins: vats (~vats@103.70.83.249)
[19:56:06] <nij-> Hmm.. I can't spot why there's a type error in -
[19:56:06] <nij->   (SB-KERNEL:CHECK-TYPE-ERROR VECTOR #(51 50 49) (VECTOR (UNSIGNED-BYTE 8)) NIL)
[19:57:32] <nij-> Here's the code that caused the problem: https://bpa.st/NMBA
[19:57:42] *** Quits: ggoes (~gregf@user/ggoes) (Changing host)
[19:57:42] *** Joins: ggoes (~gregf@fsf/staff/ggoes)
[19:57:46] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[19:57:53] <nij-> Notice that I have (apply #'vector [elided]) to transform the input to a vector of octets.
[19:58:39] *** Joins: lisp123 (~lisp123@5.30.23.247)
[19:58:57] *** Quits: silasfox (~sbv@2001-4dd6-8e13-0-6f0d-fa0c-ffdd-c563.ipv6dyn.netcologne.de) (Ping timeout: 258 seconds)
[20:01:54] <beach> nij-: Specialized vectors are created as such and do not become such as a result of the elements in them.
[20:01:56] <Bike> nij-: babel wants a vector specialized to unsigned-byte 8. the function VECTOR returns a general vector, specialized to type T
[20:01:57] <mfiano> (coerce result '(vector (unsigned-byte 8)) instead
[20:02:17] <mfiano> (of apply)
[20:03:09] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 258 seconds)
[20:03:23] <beach> Bike: So does that mean that it relies on the implementation having such a vector type?
[20:03:42] <beach> ... because those are not required by the standard as I recall.
[20:04:19] <Bike> i assume not, because if the implementation doesn't support that specialization it's impossible to refer to it
[20:04:48] <Bike> yeah it just does (check-type vector (vector (unsigned-byte 8))) and stuff
[20:04:55] <beach> I see.
[20:07:08] *** Quits: yitzi (~yitzi@173-27-106-188.client.mchsi.com) (Quit: Leaving)
[20:11:30] <nij-> mfiano: Works for latin chars, but not for UTF-8 @@
[20:12:05] *** Joins: srhm (~ascii@user/srhm)
[20:12:16] <mfiano> You should read the babel documentation for that function
[20:14:02] <nij-> I mean (babel:octets-to-string (babel:string-to-octets "🐖")) does return the emoji.
[20:14:13] <nij-> So I suppose that's not a problem with babel.
[20:14:53] <jcowan> The idea of Mes is that if you have either a C compiler or a Scheme interpreter that you trust, you can build (forked) tcc, and from that you can build an old version of gcc, and from there to anything you want.  It minimizes the TCB.
[20:15:34] <jcowan> And because both parts of Mes are pretty easy to understand, you can eyeball them without turning green and yellow.
[20:16:41] <nij-> Moreover, (babel:octets-to-string (coerce (babel:string-to-octets "🐖") '(vector (unsigned-byte 8)))) also returns the correct emoji.
[20:17:07] <Bike> string-to-octets probably returns a (vector (unsigned-byte 8)), so the coerce is a no-op
[20:18:06] <nij-> Yeah, but even without that it works fine. Hmmm
[20:18:13] <Bike> yes, that's why i said that
[20:18:33] <Bike> string-to-octets takes an encoding argument. that is probably what mfiano is referring to
[20:18:45] <Bike> (i don't actually see a docstring, tho)
[20:18:48] <Josh_2> By default it its :utf-8
[20:24:39] <mfiano> Well you are reversing the octets before decoding them to a string, but I don't know what you are trying to do
[20:25:10] <nij-> OH!
[20:25:19] <nij-> I see. Lemme fix that.
[20:25:39] <mfiano> It's probably not very efficient to not chunk them anyway
[20:25:49] <mfiano> byte for byte can't be great
[20:27:03] *** Quits: dnaeon (~dnaeon@46.10.222.189) (Quit: EOF)
[20:28:30] <nij-> Oh.. it works :)
[20:30:36] *** Quits: peterhil (~peterhil@mobile-access-5d6aa6-103.dhcp.inet.fi) (Ping timeout: 252 seconds)
[20:32:46] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 272 seconds)
[20:34:54] *** Joins: lisp123 (~lisp123@5.30.23.247)
[20:36:24] *** Joins: icer (eric@gateway/vpn/protonvpn/icer)
[20:39:10] *** Joins: jimka (~user@2a01:e0a:26a:f400:78f1:4c5d:36e:1258)
[20:43:54] *** Quits: jimka (~user@2a01:e0a:26a:f400:78f1:4c5d:36e:1258) (Ping timeout: 240 seconds)
[20:45:03] *** Joins: _dave (~dave_@2600:1700:38a0:3d40::49)
[20:47:40] *** Quits: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3) (Ping timeout: 256 seconds)
[20:57:31] <sterni> are the gcl.tar.gz actually the ANSI standard or just some subset of it?
[20:57:47] <sterni> (the info files)
[20:58:05] <beach> Where is that file?
[20:58:05] *** Joins: jimka (~user@2a01:e0a:26a:f400:78f1:4c5d:36e:1258)
[20:58:12] <beach> Or those files.
[20:58:30] <beach> The "gcl" suggests a particular implementation.
[20:58:44] <sterni> beach: https://ftp.gnu.org/gnu/gcl/gcl.info.tgz
[20:59:30] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 258 seconds)
[20:59:34] <sterni> seems to me that the GCL ppl just converted it similar to how the hyperspec was made, thought maybe somebody here knows the backstory
[21:01:25] <beach> I think it is for GCL, and has nothing to do with the standard.
[21:02:14] <beach> Oh, you may be right.
[21:02:32] <sterni> “The third info file gcl details the Ansi standard for common lisp, to which this subset tries to adhere.”
[21:02:32] <beach> I wonder what they used as source then.
[21:03:02] *** Joins: lisp123 (~lisp123@5.30.23.247)
[21:03:36] <sterni> beach: https://github.com/rebcabin/dpans2texi
[21:03:55] <sterni> ah, likely it's the draft ANSI standard and not the real one
[21:04:04] <sterni> so 1984 I guess?
[21:04:39] <beach> sterni: The dpANS is nearly identical to the standard.
[21:05:59] <beach> sterni: In fact, the standard can only be had as a bad photocopy.  ANSI apparently lost the source files.
[21:06:02] *** Quits: icer (eric@gateway/vpn/protonvpn/icer) (Quit: WeeChat 2.9)
[21:08:23] <sterni> lol
[21:09:14] <mfiano> Why are you interested in GCL?
[21:09:23] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[21:10:06] <shka> jesus
[21:10:14] <shka> ANSI loosing documents
[21:10:25] <shka> are you kindding me?
[21:14:50] <sterni> mfiano: I was mostly interested in the info version of the draft tbh
[21:15:09] <sterni> but now I'm kinda interested in GCL I wasn't aware it existed
[21:15:17] <mfiano> I see. I don't know if GCL will ever be a conforming implementation.
[21:15:35] <sterni> is it even active anymore?
[21:16:02] <mfiano> I think it gets like a small commit per year or something last I checked
[21:17:08] <mfiano> It is quite active lately
[21:17:11] <mfiano> https://git.savannah.gnu.org/cgit/gcl.git/log/
[21:18:54] <sterni> interesting, maybe I should play around with a version from git
[21:23:32] <pjb> mfiano: it could become, with some work.
[21:23:39] <pjb> FSF would be happy.
[21:23:54] <pjb> In the meantime, we use ecl which is similar and conforming.
[21:24:15] <pjb> There's a compiler in ecl that generates C code compiler with gcc.
[21:24:27] *** Joins: makomo_ (~makomo@user/makomo)
[21:27:30] *** Quits: makomo (~makomo@user/makomo) (Ping timeout: 240 seconds)
[21:28:33] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[21:32:28] *** Quits: jimka (~user@2a01:e0a:26a:f400:78f1:4c5d:36e:1258) (Ping timeout: 258 seconds)
[21:33:05] <pl> shka: or they lost build env
[21:35:24] <MichaelRaskin> Losing assumes they have _ever_ cared about the sources
[21:36:35] *** Joins: yitzi (~yitzi@173-27-106-188.client.mchsi.com)
[21:40:24] *** Joins: dnaeon (~dnaeon@46.10.222.189)
[21:40:58] <jcowan> Often enough the "source" is just a paper document produced on a typewriter.
[21:42:58] <MichaelRaskin> Where «enough» is «enough to ANSI to have workflows assuming this is always the case»
[21:43:38] *** Joins: jimka (~user@2a01:e0a:26a:f400:78f1:4c5d:36e:1258)
[21:43:45] <jcowan> Whenever there's an ECMA standard, I always use it (freely available0
[21:43:47] *** Quits: dnaeon (~dnaeon@46.10.222.189) (Changing host)
[21:43:47] *** Joins: dnaeon (~dnaeon@user/dnaeon)
[21:43:47] <jcowan> )
[21:44:05] *** Quits: dnaeon (~dnaeon@user/dnaeon) (Client Quit)
[21:44:27] *** Joins: dnaeon (~dnaeon@46.10.222.189)
[21:44:28] *** Quits: dnaeon (~dnaeon@46.10.222.189) (Changing host)
[21:44:28] *** Joins: dnaeon (~dnaeon@user/dnaeon)
[21:45:30] *** Quits: dnaeon (~dnaeon@user/dnaeon) (Client Quit)
[21:46:14] *** Joins: dnaeon (~dnaeon@user/dnaeon)
[21:47:50] <sterni> how can they even sell it if they don't have the sources
[21:47:55] <sterni> I guess they haven't lost the ps
[21:48:02] <sterni> or the first pressing never sold out
[21:48:25] <jcowan> No, what they've got is paper, and they photocopy that and send you the copy.
[21:48:47] <sterni> is that true
[21:51:30] <shka> pl: still, keeping those things accessible is part of the job description
[21:55:21] <shka> would WSCL be published under CC?
[21:55:22] <lisp123> I have a copy of the ANSI Standard
[21:55:27] <lisp123> Or at least I assume I do
[21:55:31] <lisp123> I bought it off the ANSI website
[21:55:51] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Ping timeout: 258 seconds)
[21:56:32] *** Joins: amb007 (~a_bakic@60.104.204.77.rev.sfr.net)
[21:56:35] <jcowan> I was slightly wrong: your US$60 gets you a PDF of the crappy photocopy
[21:57:22] <lisp123> Yes, its a photocopy
[21:57:30] <lisp123> Someone could probably OCR it
[21:57:52] *** Joins: karlosz (~karlosz@cpe-184-153-37-90.nyc.res.rr.com)
[22:00:43] *** Joins: peterhil (~peterhil@mobile-access-5d6aa6-103.dhcp.inet.fi)
[22:02:24] <lisp123>  This is a reference document, not a tutorial document. Where possible and convenient, the order of presentation has been chosen so that the more primitive topics precede those that build upon them; however, linear readability has not been a priority.
[22:02:42] <lisp123> Not that bad of a copy, can copy/paste pretty easily without errors (example above)
[22:03:10] *** Joins: lotuseater (~user@185.66.193.48)
[22:04:29] <lotuseater> hello there :)
[22:06:10] <Josh_2> Hi hi
[22:06:52] <lotuseater> hope I didn't miss something interesting the last hours when topic was on compilation
[22:09:45] <lotuseater> hayley: what was the time point at the Java on 1000 cores talk you linked me?
[22:17:18] *** Quits: peterhil (~peterhil@mobile-access-5d6aa6-103.dhcp.inet.fi) (Ping timeout: 252 seconds)
[22:17:54] *** Quits: jimka (~user@2a01:e0a:26a:f400:78f1:4c5d:36e:1258) (Ping timeout: 272 seconds)
[22:25:45] *** Parts: PinealGlandOptic (~PinealGla@37.115.210.35) ()
[22:40:31] *** Joins: attila_lendvai (~alendvai@C226779F.nat.pool.telekom.hu)
[22:47:29] *** Joins: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3)
[22:49:07] *** Joins: peterhil (~peterhil@mobile-access-5d6aa6-103.dhcp.inet.fi)
[22:54:09] *** Quits: dnaeon (~dnaeon@user/dnaeon) (Ping timeout: 252 seconds)
[22:54:34] <phoe> dnaeon: still need some restart help?
[22:58:01] *** Quits: lotuseater (~user@185.66.193.48) (Quit: ERC (IRC client for Emacs 27.2))
[22:59:08] *** Quits: davep (uid504677@id-504677.tinside.irccloud.com) (Quit: Connection closed for inactivity)
[23:00:38] *** Quits: peterhil (~peterhil@mobile-access-5d6aa6-103.dhcp.inet.fi) (Ping timeout: 258 seconds)
[23:01:54] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[23:04:36] *** Joins: Catie (~user@c-24-17-253-63.hsd1.wa.comcast.net)
[23:14:03] *** Quits: nij- (~jin@2001-48F8-9021-806-0-0-0-954B-dynamic.midco.net) (Ping timeout: 258 seconds)
[23:15:13] *** Quits: amb007 (~a_bakic@60.104.204.77.rev.sfr.net) (Read error: Connection reset by peer)
[23:16:35] *** Joins: amb007 (~a_bakic@60.104.204.77.rev.sfr.net)
[23:16:36] *** Quits: amb007 (~a_bakic@60.104.204.77.rev.sfr.net) (Read error: Connection reset by peer)
[23:17:33] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[23:23:52] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Ping timeout: 245 seconds)
[23:25:02] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[23:25:09] *** Quits: karlosz (~karlosz@cpe-184-153-37-90.nyc.res.rr.com) (Quit: karlosz)
[23:27:43] <shka> phoe: hey, did you got my email?
[23:28:36] <phoe> shka: yes, thank you
[23:28:45] <phoe> I collected it, just didn't acknowledge it yet
[23:28:54] <shka> ok, great
[23:29:00] <shka> good night!
[23:30:03] <phoe> nini
[23:30:08] *** Joins: gaqwas (~john@dynamic-095-115-078-128.95.115.pool.telefonica.de)
[23:31:00] *** Quits: makomo_ (~makomo@user/makomo) (Ping timeout: 252 seconds)
[23:31:45] *** Quits: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3) (Remote host closed the connection)
[23:31:50] *** Parts: gin (~gin@user/gin) ()
[23:34:15] *** Joins: tfeb (~tfb@88.98.95.237)
[23:36:10] *** Joins: dnaeon (~dnaeon@46.10.222.189)
[23:36:10] *** Quits: dnaeon (~dnaeon@46.10.222.189) (Changing host)
[23:36:10] *** Joins: dnaeon (~dnaeon@user/dnaeon)
[23:38:01] *** tfeb is now known as tfb
[23:38:44] *** Joins: JoshYoshi (~user@154.57.3.82)
[23:38:53] *** Quits: JoshYoshi (~user@154.57.3.82) (Remote host closed the connection)
[23:39:36] *** Quits: Josh_2 (~user@37.25.47.130) (Ping timeout: 272 seconds)
[23:41:34] *** lonjil2 is now known as lonjil
[23:43:37] *** Joins: tyson2 (~user@toroon12-3096782677.sdsl.bell.ca)
[23:52:22] <phoe> minion: memo for rpg: UIOP:DEFINE-PACKAGE docstring does not mention :MIX-REEXPORT or :USE-REEXPORT. Is that expected?
[23:52:22] <minion> Remembered. I'll tell rpg when he/she/it next speaks.
[23:53:06] *** Quits: pve (~pve@87-93-150-30.bb.dnainternet.fi) (Quit: leaving)
[23:54:01] *** Joins: selwyn (~selwyn@user/selwyn)
[23:54:47] *** Joins: dsk (~dsk@user/dsk)
[23:54:52] *** Quits: tfb (~tfb@88.98.95.237) (Quit: died)
