[00:01:32] <tewi> that's good to know
[00:04:25] <White_Flame> but there's a common scheme that lisp implementations use now.  It ties a lot into dynamic bindings being quickly findable, and having the NIL symbol/cons-cell equivalency
[00:04:44] <White_Flame> (the latter being (car nil) and (cdr nil) returning NIL instead of blowing up that it's not a cons cell)
[00:13:09] <tewi> uhh maybe this is a very dumb thing to ask, but do types even exist, or are they just a concept, and what's actually used every time is type specifiers?
[00:15:35] <drakonis> they do, yes?
[00:18:10] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[00:18:17] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[00:19:33] <White_Flame> tewi: a class defines what the nature of a thing is.  a type is a categorization that might overlap many classes, and is not fundamental to the object
[00:20:39] <White_Flame> so INTEGER is a class. while (INTEGER -30 30) is a type
[00:21:07] <White_Flame> and (OR INTEGER MY-CLASS) is a type
[00:26:52] <tewi> hmm, i don't really get it. should (integer -30 30) be accepted by the repl?
[00:27:19] <White_Flame> it's not a function
[00:27:43] <White_Flame> (typep -10 '(integer -30 30)) => T
[00:27:47] <White_Flame> (typep 40 '(integer -30 30)) => NIL
[00:27:57] *** Quits: hashfunc1818 (~user@2601:5c0:c280:7090:8c1e:afa3:b36b:39be) (Ping timeout: 240 seconds)
[00:28:17] <White_Flame> (class-of 40) => #<BUILT-IN-CLASS COMMON-LISP:FIXNUM>  ;; for sbcl
[00:28:52] <White_Flame> so a type is kind of like a predicate that can be tested, while the class is the intrinsic nature of the thing (which does have its parent classes, too)
[00:29:49] <White_Flame> types can be infinitely complex, combined with OR, MEMBER, SATISFIES, etc, while the class will always be singular
[00:31:10] <Bike> you are right that there is no way to refer to types in any direct way. they are only dealt with through specifiers.
[00:32:17] <tewi> so '(integer -30 30) in (typep 40 '(integer -30 30)) is a type specifier?
[00:32:49] <White_Flame> very specifically, the list (integer -30 30) is the type specifier.  The quote is syntax just to have a literal list
[00:32:50] <Bike> (integer -30 30) is a type specifier.
[00:41:31] <Bike> you could also do, like, (typep 40 (list 'integer x y)), kind of thing
[00:51:55] *** Quits: opfez (~opfez@ti0013a400-1060.bb.online.no) (Ping timeout: 256 seconds)
[00:53:20] *** Joins: opfez (~opfez@ti0013a400-0518.bb.online.no)
[00:53:45] <tewi> how are types actually attached to an object? by that i mean, how does it tell what type is it? it has to be stored somewhere, no?
[00:54:01] <White_Flame> they're not attached
[00:54:14] <White_Flame> the tag on an object in memory can tell what class it is
[00:54:27] <Bike> well like, for one thing, any given object is a member of infinitely many types.
[00:54:36] <White_Flame> a type specifier is tested against a memory object
[00:54:36] <Bike> like 0 is an (integer -1 1), an (integer -2 2), etc
[01:02:41] *** Quits: st_iron (uid370243@id-370243.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[01:08:15] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[01:09:19] <tewi> White_Flame: when type specifier is tested against an object in memory, what does it test for?
[01:09:45] <White_Flame> what its class is, what its value is
[01:10:10] <White_Flame> array type specifiers test what its size is, what its storage type is, etc
[01:10:40] <White_Flame> (typep x '(integer -30 30)) would test hat it's an integer, then test the range of it
[01:11:24] <tewi> integer as in class?
[01:11:44] <White_Flame> yes, its fundamental nature as an object
[01:27:24] <tewi> so a class would be found by its tag, and type would be found by what tests it satisfies (so what attributes it has)? and type-of would return whatever the first type is to satisfy all tests on such object?
[01:30:35] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 240 seconds)
[01:32:15] <Bike> type-of is pretty vaguely defined. different implementations of type-of can give different results for similar objects
[01:32:25] *** Joins: Oladon (~olad@98.43.81.226)
[01:32:47] <Bike> it would probably be legal for it to, for example, just return (class-name (class-of object)), but it doesn't have to do that
[01:34:05] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[01:35:09] <tewi> but more or less, is that way of thinking about it correct? at least the first sentence
[01:37:58] <Bike> well, the particular way an object is associated with a class is part of the implementation internals and can vary a lot, but in general it will be a pretty direct association, yeah
[01:38:24] <Bike> i think the problem with what you said is that what type-of does - taking an object and getting a type it satisfies - is not a common operation, and is kidn of backwards from how types are usually used
[01:59:55] <tewi> well i more or less get what you mean, i think
[02:22:52] <tewi> subtype n. a type whose membership is the same as or a proper subset of the membership of another type, called a supertype - doesn't that just make a subset?
[02:26:45] <White_Flame> the membership of the type is a subset
[02:26:57] <White_Flame> the membership of the subtype is a subset of the membership of the supertype
[02:27:17] <White_Flame> the type is the description/categorization that defines membership
[02:28:54] <tewi> membership being objects that are of type?
[02:29:14] <White_Flame> (or (integer 1 100) (integer -1000 -999) (member :foo :bar :baz)) is a single valid type that contains 105 members
[02:29:29] <White_Flame> 102 numbers and 3 symbols
[02:29:37] <tewi> am i missing something? i'm confused why does the definition break it up into being equal and being proper subset
[02:29:50] <White_Flame> the subject of those sentences is "membership", not the type itself
[02:29:57] <tewi> yes
[02:30:44] <tewi> if you want either the same members, or a proper subset, that just makes a subset doesn't it
[02:30:47] <White_Flame> the definition you pasted on subtype only talks about subset; what part used "equal"?
[02:31:06] <tewi> "whose membership is the same"
[02:31:31] <White_Flame> oh, that's just basically the sort of notion as "less than or equal"
[02:31:43] <White_Flame> (1 2 3) is a subset of (1 2 3)
[02:31:50] <tewi> yes exactly
[02:31:58] <tewi> so why not just say subset
[02:32:08] <White_Flame> right, they could have
[02:32:22] <White_Flame> "same or proper subset" = "subset"
[02:32:44] <tewi> yeah i agree. i just wanted to make sure i wasn't reading it wrong or something
[02:32:51] <White_Flame> but they have a proclivity to be super specific, and "subset" might be ambiguous as to whether or not it's proper, is my guess
[02:34:29] <White_Flame> yeah, that does read like a mouthful and could be simplified, but only if "subset" is specifically defined
[02:38:40] <tewi> well, it's already using the mathematical definition of proper subset, but maybe that's more obvious. so i guess subtype and supertype is probably just subset and superset, where set elements are objects
[02:39:14] <White_Flame> yes
[02:39:22] <tewi> the glossary for type literally calls it a set now that i think about it
[02:41:43] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[03:00:33] *** Quits: Bike (~Glossina@71.69.170.70) (Quit: Lost terminal)
[03:14:35] *** Quits: eugercek (~user@user/eugercek) (Remote host closed the connection)
[03:14:52] *** Joins: eugercek (~user@user/eugercek)
[03:15:11] *** Quits: eugercek (~user@user/eugercek) (Read error: Connection reset by peer)
[03:17:48] *** Quits: shka (~herr@109.231.3.55) (Ping timeout: 272 seconds)
[03:38:36] *** Quits: tewi (~tewi@apn-95-40-197-118.dynamic.gprs.plus.pl) (Ping timeout: 240 seconds)
[03:49:58] *** Joins: Oladon (~olad@98.43.81.226)
[04:49:45] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[04:54:12] *** Quits: random-nick (~random-ni@87.116.179.129) (Ping timeout: 240 seconds)
[07:19:08] *** Joins: Jamba17 (~Jamba17@cpe-74-137-85-1.kya.res.rr.com)
[07:22:38] *** Quits: Jamba17 (~Jamba17@cpe-74-137-85-1.kya.res.rr.com) (Remote host closed the connection)
[07:38:50] *** Joins: Oladon (~olad@98.43.81.226)
[07:39:11] <beach> Good morning everyone! 
[07:45:51] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Remote host closed the connection)
[08:04:28] *** Joins: ilmu2 (~ilmu@176.76.242.59)
[08:06:25] <beach> White_Flame: Aside from the CONS/NIL "equivalence", what is the "common scheme that lisp implementations use now" that you were referring to?
[08:07:06] <White_Flame> I guess mostly that equivalence, where the same accessors for car/cdr map onto the symbol-value and another field
[08:07:29] <White_Flame> the dynamic bindings really don't end up affecting the shape of the underlying symbol object too much
[08:07:38] <beach> I see.
[08:07:52] *** Quits: ilmu1 (~ilmu@176.76.242.159) (Ping timeout: 272 seconds)
[08:08:58] <beach> Just to make things clear, there is nothing in the standard that says that the function or global/current value associated with a symbol has to be stored in a slot in the symbol object.
[08:09:05] <White_Flame> right
[08:09:15] <White_Flame> <White_Flame> tewi: it's left up to the implementation where the function/value/etc are physically stored
[08:09:21] <beach> Right.
[08:09:58] <beach> Also, I personally think it is an unnecessary complication to make CAR/CDR work on NIL.  And I recall working out that it would make the tests in a typical loop over the elements of a list more expensive.
[08:12:39] <White_Flame> and in fact, it's not that the standard says nothing about it, it's actually explicit ;)
[08:12:41] <White_Flame> "Symbols have the following attributes. For historical reasons, these are sometimes referred to as cells, although the actual internal representation of symbols and their attributes is implementation-dependent."
[08:13:29] <beach> Yes, I think that passage should be removed, or clarified so that it is clear that it refers to historical stuff.
[08:13:45] <White_Flame> beach: I wonder about that.  It eliminates NIL checking from car/cdr, not sure where it would add cost
[08:14:23] <beach> Let's see how you implement a loop over a proper list, like (loop for element in list ...).
[08:14:28] <White_Flame> however, I guess the decision of where to use consp vs listp would differ
[08:14:34] <beach> What tests do you do in each iteration?
[08:15:39] <beach> I mean, you would do CONSP or ATOM, but how are those implemented?
[08:15:53] <beach> ... in a system that uses this scheme.
[08:15:53] <White_Flame> there's also a CDR accessor per iteration
[08:16:18] <beach> To get to the next element, sure.
[08:16:20] <White_Flame> and yeah, check for consp, nil, and otherwise dotted/error
[08:16:37] <beach> How many tests does that involve?
[08:17:29] <White_Flame> and if CONSP requires a NIL check and LISTP doesn't, that adds 1 test.
[08:17:49] <White_Flame> but CDR does elide a NIL test
[08:18:04] <beach> That test has already been made.
[08:18:04] <White_Flame> so at first glance it seems like a wash there
[08:18:20] <beach> So you an elide it anyway.
[08:18:21] <White_Flame> yeah, depends on how aggressive the compiler is
[08:18:42] <White_Flame> since in the loop body, it's known that the current cell actually is a cons
[08:19:02] <White_Flame> but if a general CDR is called, that would need to check for NIL vs CONSP as wel
[08:19:16] <White_Flame> (without the equivalence)
[08:19:20] <beach> But if you consider NIL an ordinary symbol, as SICL does, you just test for the CONS tag.  Only when the test fails, i.e., at the end of the list, do you have to test for NIL.
[08:19:58] <White_Flame> sure, so NIL check in CDR, no NIL check in CONSP
[08:20:06] <White_Flame> with the equivalence, no NIL check in CDR, NIL check in CONSP
[08:20:08] <beach> Sure, but I think it was important a long time ago to optimize single calls to CAR/CDR because lists were used as data structures then.
[08:20:23] <beach> Now I think it just complicates the implementation.
[08:20:24] <White_Flame> right
[08:20:30] <White_Flame> and for naive things like (caaar NIL)
[08:20:44] <beach> Sure.
[08:20:56] <White_Flame> Yes, I'd agree in complicating the implementation, not necessarily sure I"d agree it actually makes things slower
[08:21:14] <White_Flame> though certainly some individual cases would be
[08:21:30] <beach> Possibly.  But I am betting not faster either. 
[08:21:50] <White_Flame> I just still don't like (symbolp '()) => T :-)
[08:22:06] <beach> That's different.
[08:22:16] <White_Flame> right, that's _not_ an implementation artifact
[08:22:16] <beach> ... I mean what you like or don't like.
[08:22:52] <beach> It would be fun to see in how many places in the code of an implementation this scheme becomes visible.
[08:22:57] <White_Flame> and I don't think modern code does much naive car/cdr accesses of NIL
[08:23:06] <beach> Indeed.
[08:31:42] <beach> I would much rather that the standard had a section called "Global environment" in which functions like FDEFINITION, SYMBOL-FUNCTION, FIND-CLASS, etc. were defined.  But it looks to me like the distinction between environments (run-time environment, compilation environment, evaluation environment) must have come into the standard pretty late, because this distinction is not used systematically.
[08:34:04] <beach> It is unappealing to me that SYMBOL-FUNCTION is in the "Symbols" chapter and FDEFINITION is in the "Data and Control Flow" chapter.
[08:39:07] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[08:41:28] <White_Flame> well, at least the compilation environment stuff existed in CLtL2, I'm under the impression it was more of a time constraint that things like that & the MOP didn't get the attentioned they needed inthe spec
[08:42:10] <White_Flame> the global environment is kinda hand-wavey and probably was assumed to be statically, singularly global as far as any lisp code is concerned
[08:47:15] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 240 seconds)
[08:49:26] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[08:54:24] <beach> I agree that it must have been time constraints.
[08:55:12] <beach> And yes, the section on compilation both distinguishes the three kinds of global environments and explicitly allows for an implementation to make them all the same.
[08:55:35] <beach> I mean, they had to, given how most implementations are written. 
[09:00:21] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 245 seconds)
[10:43:15] *** Joins: lisp123 (~lisp123@120.154.103.52)
[10:52:37] *** Joins: v88m (~Xiro@109-252-170-8.dynamic.spd-mgts.ru)
[10:54:16] *** Quits: lisp123 (~lisp123@120.154.103.52) (Remote host closed the connection)
[10:58:02] *** Joins: lisp123 (~lisp123@120.154.103.52)
[11:06:22] *** Joins: shka (~herr@109.231.3.55)
[11:23:45] *** Quits: lisp123 (~lisp123@120.154.103.52) (Remote host closed the connection)
[11:47:30] *** Joins: lisp123 (~lisp123@120.154.103.52)
[11:52:06] *** Joins: tewi (~tewi@apn-95-41-56-40.dynamic.gprs.plus.pl)
[12:09:48] *** Quits: v88m (~Xiro@109-252-170-8.dynamic.spd-mgts.ru) (Ping timeout: 240 seconds)
[12:33:46] *** Quits: lisp123 (~lisp123@120.154.103.52) (Remote host closed the connection)
[12:45:08] *** Joins: lisp123 (~lisp123@120.154.103.52)
[13:06:52] *** Joins: eugercek (~user@user/eugercek)
[13:07:38] *** Joins: v88m (~Xiro@109-252-170-8.dynamic.spd-mgts.ru)
[13:55:28] *** Quits: lisp123 (~lisp123@120.154.103.52) (Remote host closed the connection)
[14:28:34] *** Quits: eugercek (~user@user/eugercek) (Read error: Connection reset by peer)
[14:28:50] *** Joins: eugercek (~user@user/eugercek)
[14:36:34] *** Joins: lisp123 (~lisp123@120.154.103.52)
[14:41:31] *** Quits: lisp123 (~lisp123@120.154.103.52) (Ping timeout: 256 seconds)
[14:43:12] *** Quits: v88m (~Xiro@109-252-170-8.dynamic.spd-mgts.ru) (Remote host closed the connection)
[14:44:00] *** Joins: v88m (~Xiro@213.87.161.249)
[14:46:17] *** Quits: v88m (~Xiro@213.87.161.249) (Read error: Connection reset by peer)
[14:47:10] *** Joins: v88m (~Xiro@109-252-170-8.dynamic.spd-mgts.ru)
[14:47:43] *** Joins: random-nick (~random-ni@87.116.176.196)
[15:13:14] *** Quits: shka (~herr@109.231.3.55) (Quit: Konversation terminated!)
[15:43:52] *** ilmu2 is now known as ilmu
[15:46:35] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 240 seconds)
[15:48:53] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[15:59:48] *** Quits: ilmu (~ilmu@176.76.242.59) (Ping timeout: 240 seconds)
[16:29:37] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[16:31:44] *** Joins: ilmu (~ilmu@176.76.242.59)
[16:52:56] *** Joins: treflip (~user@user/treflip)
[16:55:50] *** Quits: |3b| (bbb@user/3b/x-2324788) (Remote host closed the connection)
[16:56:35] *** Joins: |3b| (bbb@user/3b/x-2324788)
[18:32:01] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[18:45:14] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Remote host closed the connection)
[19:24:15] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[20:04:30] *** Joins: ilmu1 (~ilmu@176.76.242.92)
[20:07:39] *** Quits: ilmu (~ilmu@176.76.242.59) (Ping timeout: 256 seconds)
[20:13:32] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Remote host closed the connection)
[20:20:34] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[21:43:53] *** Quits: pjb (~pjb@user/pjb) (Read error: Connection reset by peer)
[22:05:53] *** Quits: eugercek (~user@user/eugercek) (Read error: Connection reset by peer)
[22:06:18] *** Joins: eugercek (~user@user/eugercek)
[22:10:12] *** Quits: v88m (~Xiro@109-252-170-8.dynamic.spd-mgts.ru) (Ping timeout: 240 seconds)
[22:11:03] *** Joins: v88m (~Xiro@213.87.154.131)
[22:13:15] *** Quits: mns (~mns@c-73-119-178-157.hsd1.ma.comcast.net) (Quit: Quit)
[22:24:34] *** Quits: v88m (~Xiro@213.87.154.131) (Read error: Connection reset by peer)
[22:59:39] *** Quits: minion (~minion@common-lisp.net) (Read error: Connection reset by peer)
[23:00:55] *** Joins: minion (~minion@common-lisp.net)
[23:32:24] *** Quits: treflip (~user@user/treflip) (Quit: good night)
