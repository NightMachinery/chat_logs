[00:42:17] *** Quits: PTNapivoski (~PTNapivos@2804:60:1c2:9b00:283d:c55f:359b:1ac0) (Quit: Leaving)
[00:42:24] *** Quits: autodev (~autodev@67-198-118-247.dyn.grandenetworks.net) (Remote host closed the connection)
[00:54:20] <pie_> Aha. <Naktibalda> it seams that the issue was the team id wasn't a primary key https://dbfiddle.uk/?rdbms=mysql_8.0&fiddle=c13219cdba5b86f6e23d922a435e4ce3
[00:55:32] <pie_> Isotopp: why did you add an order by?
[00:55:53] <Isotopp> That was part of the original query in 9
[00:56:04] <pie_> oh
[00:56:10] <pie_> ok
[00:56:15] <Isotopp> I was just taking the original query and modified it minimally to reach a valid solution
[00:56:29] <Isotopp> So what you see there is the minimal change to the original given query
[00:56:33] <Isotopp> to make it pass
[00:58:36] <pie_> Oh interesting. The way you did it, in a way, you use aggregation to put stuff in the select that isnt covered by the group by, and you use the group by for the other stuff
[00:58:40] <pie_> so like, theyre kind of orthogonal
[00:59:14] <pie_> though...that might be exactly what youre supposed to do, I'm just being weird
[00:59:28] <pie_> IDK I don't find SQL very intuitive a lot of the time.
[01:00:17] <pie_> i guess that point you can just use COUNT(*) though; SELECT teamname, COUNT(*) FROM eteam JOIN goal ON teamid=id GROUP BY teamname; though
[01:01:09] <pie_> re: equivalence class stuff - aha. right.
[01:03:56] <Isotopp> pie_: that is kind of the point
[01:04:01] <pie_> To prove I have understood nothing; I'm having trouble with 11.
[01:04:13] <Isotopp> group by x puts data into piles with equal x
[01:04:20] <pie_> yeah
[01:04:24] <pie_> https://sqlzoo.net/wiki/The_JOIN_operation `SELECT matchid, mdate, COUNT(*) FROM goal FULL JOIN game ON id = matchid WHERE team1 = 'POL' OR team2 = 'POL' GROUP BY matchid`
[01:04:26] <Isotopp> so you have one pile of x=1, one pile of x=2, one pile of x=3 and so on
[01:04:33] <pie_> is what I have so far. I'll stare at it for a few more minutes.
[01:04:52] <Isotopp> and all columns that are NOT in the order by you can only refer to by using an aggregate function
[01:05:14] <Isotopp> so select x, sum(y) from t group by x
[01:05:25] <Isotopp> makes x-piles, and then sums up all y that are not NULL
[01:05:35] <Isotopp> select x, sum(y), count(y) from t group by x
[01:05:42] <Isotopp> the same, and you sum and count all non-null y
[01:06:05] <Isotopp> (incidentally that happens to be the def of an average: sum(y)/count(y))
[01:11:00] <pie_> This is very clearly wrong in that it's a hack but "it works"; SELECT matchid, max(mdate), COUNT(*) goals FROM goal JOIN game ON id = matchid WHERE team1 = 'POL' OR team2 = 'POL' GROUP BY matchi
[01:11:11] <pie_> the hack being the max(mdate)  cheat to get mdate in scope
[01:14:55] <pie_> ok the answer actually does "GROUP BY matchid,mdate"
[01:15:05] <pie_> I guess that works if the first thing youre grouping by is a primary key anyway
[01:22:21] *** Quits: David-- (~none@host81-149-15-132.in-addr.btopenworld.com) (Ping timeout: 256 seconds)
[01:24:00] *** Joins: autodev (~autodev@67-198-118-247.dyn.grandenetworks.net)
[01:25:06] <Isotopp> I count goal.gtime instead of *
[01:25:21] <Isotopp> Do you know what is the difference between count(*) and count(somecolumn)?
[01:25:29] <Isotopp> SELECT matchid,mdate, count(goal.gtime) FROM game JOIN goal ON matchid = id
[01:25:29] <Isotopp> WHERE (team1 = 'POL' OR team2 = 'POL')
[01:25:30] <Isotopp> group by matchid, mdate
[01:25:46] <thumbs> Isotopp: unless you select another functionally dependent column
[01:26:18] <thumbs> SELECT col1, col2, COUNT(*) FROM tbl GROUP BY col1; that is correct, if col2 is functionally dependent on col1
[01:26:43] <thumbs> but perhaps it's too early to cover that with pie_
[01:26:53] *** Joins: David- (~none@host81-149-15-132.in-addr.btopenworld.com)
[01:27:16] <Isotopp> yes, i was going for count(*) counts all rows in the group by 'pile', whereas count(somecolumn) only counts non-null rows
[01:27:33] <thumbs> oh, that is another good lesson for pie_
[01:27:43] <Isotopp> in this example it should not make a difference, but in left join, or in scenarios where the counted column can be null it matters
[01:28:04] <thumbs> yes, those are much better examples than the pile of crap he linked here yesterday
[01:28:31] *** Quits: autodev (~autodev@67-198-118-247.dyn.grandenetworks.net) (Ping timeout: 260 seconds)
[01:45:41] *** Quits: nickel715 (~nickel715@user/nickel715) (Quit: Ping timeout (120 seconds))
[01:46:05] *** Joins: nickel715 (~nickel715@user/nickel715)
[01:48:58] <pie_> are there cases where I need something other than a full join, other than if im joining against a table in a anything-(possibly 0) relationship?
[01:49:10] <pie_> Though even posing the question seems kind of tautological
[01:49:30] <pie_> basically, I'm going to screw up my test by not noticing small (but important) stuff
[01:50:00] <pie_> I manage to solve 13 but I did a full join instead of a left join, and I couldn't figure out the problem until I checked the answer
[01:50:14] *** Quits: rvalue (~rvalue@user/rvalue) (Read error: Connection reset by peer)
[01:50:30] *** Joins: rvalue (~rvalue@user/rvalue)
[01:54:08] *** Quits: DrowningElysium (uid190788@user/drowningelysium) (Quit: Connection closed for inactivity)
[01:59:10] *** Quits: rvalue (~rvalue@user/rvalue) (Excess Flood)
[01:59:24] *** Joins: rvalue (~rvalue@user/rvalue)
[02:17:35] *** Joins: Guest54 (~Guest54@2620:10d:c092:400::4:a871)
[02:32:14] *** Joins: autodev (~autodev@67-198-118-247.dyn.grandenetworks.net)
[02:38:28] <znf> quick reminder -- can I restore a backup from 5.7 to mysql 8.0 that was done with percona's xtrabackup?
[02:39:47] <thumbs> should be able to
[02:41:03] <znf> thanks
[02:49:50] *** Quits: autodev (~autodev@67-198-118-247.dyn.grandenetworks.net) (Remote host closed the connection)
[03:08:51] *** Joins: KnowledgeShark (~Knowledge@50.34.222.212)
[03:24:13] *** Joins: travisghansen (~travisgha@192.74.130.86)
[03:39:56] <thumbs> pie_: read about CROSS JOINs
[03:51:06] <pie_> ok
[04:18:34] <pie_> thumbs: what am I looking for? This is just a simple cartesian product of rows?
[04:42:00] *** Quits: Guest54 (~Guest54@2620:10d:c092:400::4:a871) (Ping timeout: 250 seconds)
[04:51:15] <znf> It is possible that the backup was created by Percona XtraBackup 2.4 or earlier version. Please use the same XtraBackup version to restore.
[04:51:23] <znf> damn it.
[05:16:11] <pie_> are correlated subqueries ever necessary?
[05:17:25] <thumbs> pie_: there is always a better approach
[05:17:40] <pie_> ok, do I need to learn anything other than joins?
[05:17:49] <thumbs> pie_: CTEs.
[05:21:41] *** Quits: DaNeenjah (~jake@adsl-74-230-4-23.hsv.bellsouth.net) (Quit: WeeChat 3.5)
[05:42:26] <pie_> coincidentally I think I ran into that right when I asked
[05:56:12] *** Joins: prabha_friend (~prabha_fr@122.178.250.93)
[05:57:00] *** Joins: finsternis (~X@23.226.237.192)
[06:08:57] <pie_> Im surely missing something real dumb here
[06:09:07] <pie_> Why can't I get JOIN and USING to work?:
[06:09:14] <pie_> SELECT * FROM (SELECT 1 a ) a JOIN (SELECT 1 a ) b USING a;
[06:10:01] <pie_> this works: SELECT * FROM (SELECT 1 a ) a JOIN (SELECT 1 a ) b ON a.a=b.a;
[06:12:12] <thumbs> pie_: you don't want USING.
[06:12:42] <pie_> why not / ok but still
[06:12:56] <thumbs> pie_: because you should always be explicit with an ON clause
[06:13:13] <thumbs> pie_: if this is yet another one of the course "requirements", then the course is misleading you
[06:13:14] <pie_> isnt using the same as what I did in the ON?
[06:13:17] <pie_> no its not
[06:13:19] <thumbs> pie_: no.
[06:13:20] <pie_> im just fiddling with stuff
[06:13:43] <thumbs> pie_: USING(colname) is a non-standard approach only available with MySQL
[06:13:47] <pie_> and probably writing a bad solution to 12 of https://sqlzoo.net/wiki/More_JOIN_operations
[06:14:00] <pie_> thumbs: OH.
[06:14:09] <pie_> geez.
[06:14:22] <pie_> damn vendors :p
[06:15:05] <pie_> I need to learn to indent my sql soon.
[06:33:40] <pie_> this is my two solutions for problem 12 https://bpa.st/LKJA
[06:33:52] <pie_> I worked more on the first one and the second is my first janky solution that worked
[06:33:57] <pie_> is any of this any good?
[06:35:01] <pie_> We're gonna have 8 minutes per problem. I hope I get better at this because getting something that isn't trash takes too long ;_;
[06:46:26] <thumbs> pie_: you don't need CTEs here - you can use a self-join
[06:47:05] <thumbs> pie_: SELECT ... FROM tbl AS a JOIN tbl AS b ON ... WHERE a.col = 'foo' AND b.col = 'bar'
[06:47:20] <pie_> I did do that earlier for the last part of it
[06:47:29] <pie_> and then i confused myself about why it even worked :I
[06:47:35] <pie_> I guess I need to think over that agin
[06:48:50] <pie_> but dont I want at least the actor_in cte? I need the movie-actor connection, and then I need to self join on that
[06:49:21] <thumbs> pie_: if you don't need any aggregation, then you have little to gain from CTEs here.
[06:49:29] <pie_> readability?
[06:49:36] <thumbs> pie_: you can self-join on any criteria
[06:49:53] <thumbs> pie_: a self-join properly formatted is very readable, as well.
[06:50:59] <pie_> oh also i keep scerwing myself up with self joins causing name conflicts
[06:51:47] <pie_> cant I prefix the names during the join or somthing
[06:51:53] <thumbs> yes.
[06:54:16] *** Quits: Vacuity (~Vacuity@user/vovo) (Ping timeout: 272 seconds)
[06:54:55] <pie_> ok...how
[06:55:09] <thumbs> aliasname.columnname
[06:55:20] *** Joins: Vacuity (~Vacuity@user/vovo)
[06:56:18] <pie_> No, I mean, `Ambiguous column name 'title'.`, I think its complaining about the result table columns being the same
[06:56:46] <thumbs> pie_: qualify it, yes. aliasname.columnname
[06:56:48] <pie_> sorry PEBCAK
[06:57:05] <pie_> I missed a spot
[06:57:33] *** Quits: codebam_ (~codebam@user/codebam) (Quit: WeeChat 3.4)
[06:58:38] <pie_> I also confused it with the case when I was trying to SELECT * earlier
[06:58:50] <thumbs> don't select * either.
[06:59:41] <pie_> I um...use it to incrementally build stuff up and check it...
[06:59:55] <pie_> This is what I have now https://bpa.st/KVCA
[07:02:37] <thumbs> pie_: really poorly formatted. Try this: https://bpa.st/BWZQ
[07:02:59] <thumbs> also, the CTE is completely unnecessary here.
[07:03:43] <pie_> What should I do
[07:03:57] <thumbs> pie_: use simple joins.
[07:04:46] <pie_> I guess I'm not using most of that self-join
[07:05:33] <thumbs> pie_: also, why a self-join on that CTE? Why do you think you need it?
[07:06:02] <thumbs> pie_: what do you gain from using a self-join on the CTE you defined?
[07:06:06] <pie_> Well, I need a link betwen movie IDs and Julie Andrews, and I need a link between Movie IDs and ord1 actors
[07:06:09] <pie_> and then I need to link those
[07:06:49] <pie_> both of the first two things are subsets of the movie-casting-actor chain
[07:07:17] <thumbs> pie_: you should really fully qualify your columns. It's hard to tell what table holds what information.
[07:07:26] <pie_> so im taking a subset of a cross product
[07:07:32] <pie_> but im actually not using a cross join
[07:07:45] <pie_> which I'm a bit confused about
[07:07:56] <thumbs> no, the previous cross-join was another suggestion.
[07:08:04] <thumbs> a cross join has no ON clause.
[07:08:45] <pie_> I know
[07:08:51] <thumbs> what you should do is build a test case on dbfiddle.uk so we can decipher your columns and their source
[07:09:11] <thumbs> as well as describing in plain English the results expected.
[07:09:26] *** Joins: codebam (~codebam@user/codebam)
[07:11:24] <pie_> I dont suppose they have the sqlzoo databases on there
[07:12:41] <pie_> The problem specification is `List the film title and the leading actor for all of the films 'Julie Andrews' played in. ` and the schema is at the top of the page at https://sqlzoo.net/wiki/File:Movie-er.png
[07:14:14] <thumbs> pie_: build a dbfiddle. You can do it.
[07:14:49] <pie_> What am I supposed to show you? Do I copy two rows out of the database?
[07:16:18] <pie_> by fully qualifying, do you mean when I didn't do this?:     SELECT m.movieid,a.actorid,m.title,a.name,casting.ord
[07:16:27] <thumbs> pie_: create the schema, insert test rows, show the expected results
[07:16:34] <thumbs> pie_: yes
[07:16:50] <pie_> except even I screwed it up because I cant remember the damn schema
[07:17:36] <pie_> ( https://bpa.st/XEHA )
[07:17:36] <thumbs> pie_: why can't you remember the schema?
[07:17:42] <pie_> brain smol
[07:17:49] *** Quits: codebam (~codebam@user/codebam) (Quit: WeeChat 3.4)
[07:18:00] <thumbs> your formatting skills are still poor.
[07:18:09] <pie_> I totally forgot to redo that
[07:18:12] <pie_> its the same formatting.
[07:18:25] <pie_> I just added the qualifications to that one line.
[07:20:46] <pie_> formatting sql is an entire ascii art project sheesh
[07:22:42] <thumbs> not if you adopt a discipline.
[07:24:21] <thumbs> practice will help too. Look at how I did it.
[07:24:25] <pie_> https://bpa.st/HSUQ
[07:24:54] <pie_> That is indeed what I did. I didn't otherwise have the faintest idea
[07:30:34] <pie_> wait
[07:30:56] <pie_> what happens if I do an inner join on a non-unique key?
[07:31:28] <thumbs> you may introduce duplication in your tuples
[07:31:33] <pie_> in:    ON a.movieid=b.movieid movieid certainly has many redundancies because each movieid should have many actors
[07:31:54] *** Joins: codebam (~codebam@user/codebam)
[07:32:17] <pie_> and each row corresponds to an actor who was cast in a given movie
[07:32:35] <thumbs> pie_: this is where you can use CTEs effectively by grouping data in the CTE itself.
[07:33:43] <pie_> ok but what actually happens if I do this? does it do a cross join on the condition? undefined behavior? does it just pick the first thing it finds each time?
[07:34:32] <thumbs> pie_: a cross join will also produce duplicate tuples.
[07:34:48] <pie_> i dont know how to phrase this, let me try again
[07:35:15] <thumbs> pie_: a db fiddle would really help.
[07:35:25] <pie_> if I do a join on a column that has redundant elements, but the actual tuples are unique, what does the join do?
[07:36:15] <thumbs> if the left portion of the join has n matches for each value of the right table, then you have n duplicate tuples.
[07:36:44] <thumbs> build a simple db fiddle, you will see.
[07:36:52] <pie_> I'm currently trying to figure out how to do that
[07:37:14] <thumbs> pie_: you add the DDL first, then the INSERT into another block, then the SELECT in the third.
[07:37:27] <pie_> so now I have to figure out ddl too :P
[07:37:43] <thumbs> pie_: in this case, you only need CREATE TABLE statements.
[07:38:19] * boubou slaps thumbs around a bit with a large trout
[07:38:23] <boubou> :D
[07:38:30] <boubou> long time no see
[07:38:35] <thumbs> bou!
[07:38:42] <thumbs> (wait, that was not scary at all)
[07:39:05] <boubou> check ur pv :D
[07:39:10] <thumbs> wait, I botched that, it should have been boo
[07:40:03] <pie_> looks like someone has a bou boo
[07:40:20] <boubou> no, its a registered nick
[07:40:21] <boubou> :P
[07:40:29] <boubou> bou maybe not boubou
[07:40:52] <boubou> im the only specimen
[07:41:02] <boubou> thumbs, we talked on hhtps
[07:41:05] <boubou> httpd
[07:46:24] <pie_> thumbs: https://dbfiddle.uk/?rdbms=oracle_21&fiddle=c25bd149c23ad693a41fe2311077b50f
[07:47:13] <pie_> the only element of the column b is 1, twice
[07:47:50] <pie_> however joining on it looks like a cross product
[07:48:03] <pie_> I don't see any redundant tuples
[07:48:25] <thumbs> because you didn't insert any duplicate data in your source table.
[07:48:41] <thumbs> insert the value 1 twice into the column b.
[07:49:00] <pie_> maybe we're talking past eachother somehow, one sec
[07:49:32] <pie_> here, same db just a select * of the original table https://dbfiddle.uk/?rdbms=oracle_21&fiddle=91012e150b21184d354545318419660b
[07:49:41] <pie_> b has 1 twice in it
[07:49:55] <pie_> so maybe you mean something other than what I think you mean
[07:50:08] <thumbs> pie_: wrong again.
[07:50:11] <thumbs> pie_: wrong again.
[07:50:14] <thumbs> pie_: wrong again.
[07:50:18] <thumbs> oops
[07:51:15] <thumbs> pie_: https://dbfiddle.uk/?rdbms=oracle_21&fiddle=6603e4068e5e2cd73ff4bf32b9144280
[07:51:38] <pie_> ok sure but thats not surprising at all?
[07:51:53] <pie_> I dont think I said I had redundant rows in the original data
[07:51:57] <thumbs> pie_: this outlines the situation you described before. Your test case did not.
[07:52:01] <thumbs> pie_: you did.
[07:52:07] <pie_> ok I may have but I didnt think I did
[07:52:32] *** Quits: jlc (~jlc@cpe-107-15-173-212.nc.res.rr.com) (Ping timeout: 272 seconds)
[07:52:57] <pie_> Have you noted I said column with redundant elements, not table with redundant rows?<pie_> if I do a join on a column that has redundant elements, but the actual tuples are unique, what does the join do?
[07:53:15] <pie_> or was it before I tried rephrasing it
[07:53:47] <pie_> in any case, ok, but so it _does_ a cross join on repeated column elements?
[07:53:56] <pie_> *_does_ do
[07:55:01] <thumbs> your ability to express your requirements clearly isn't so great, so I am not sure what problem you really want to solve here.
[07:55:14] <pie_> Im just asking how it works
[07:55:24] <pie_> but yes I'm lacking in that department
[07:55:44] <pie_> I'd just show you but...I have to write it out longform.
[07:56:36] <thumbs> try to write the expected grid output, perhaps that will be easier than using English
[08:04:34] *** Quits: prabha_friend (~prabha_fr@122.178.250.93) (Quit: Client closed)
[08:12:51] <pie_> " an inner join is always a cartesian join _filtered by the condition_   "
[08:12:56] <pie_> ok so basically, yes
[08:13:11] * pie_ waits for the inevitable qualification
[08:15:12] <pie_> this may be where I went wrong, I probably shouldn't have said key<pie_> what happens if I do an inner join on a non-unique key?
[08:17:20] <thumbs> pie_: yes. That implies duplicate values.
[08:17:40] <thumbs> or the possibility of it, anyway
[08:20:52] <pie_> they solved it with a nested select https://sqlzoo.net/wiki/More_JOIN_operations?answer=1 i feel like thats _some_ justification for me using a CTE
[08:20:52] <pie_> i also totally forgot about implicit joins
[08:21:03] *** Quits: bodiccea (~bodiccea@user/bodiccea) (Ping timeout: 260 seconds)
[08:21:36] <pie_> that makes it a bit less verbose
[08:22:03] <thumbs> you don't want to use implicit joins.
[08:22:16] <thumbs> also, the correlated behaviour is undesireable.
[08:25:54] <pie_> Why not? Is it just an "explicit is better" thing or is there something else wrong with it?
[08:26:35] <thumbs> pie_: it reduces the readability, for one.
[08:26:47] <thumbs> pie_: especially for more complex queries.
[08:34:11] <pie_> another go with this variant https://bpa.st/KLIA
[08:34:45] <thumbs> and you went with the implicit join form? Why?
[08:35:00] <pie_> to see what it's like
[08:37:40] <pie_> At this point it somehow feels less irritating than explicit join.
[08:38:19] <pie_> I still dont see / forgot how to get rid of the CTE
[08:38:25] <pie_> you said I don't need it (?)
[08:38:50] <thumbs> you don't need it, indeed. Just chain your explicit joins correctly.
[08:39:13] <pie_> so...I need to join two more tables?
[08:39:24] <pie_> basically tack on the stuff in the cte again?
[08:39:34] <thumbs> if you had built the fiddle, you would have progressed far more.
[08:39:48] <thumbs> that is a rough start, I suppose.
[08:40:09] <pie_> I promise I'll do It tomorrow when I'm less tired (not that that means I'll be particularly more lucid)
[08:40:23] <pie_> inb4: this is exactly why I should be doing it now
[08:40:31] <pie_> (Im slow anyway FWIW)
[08:42:09] <pie_> ok its a mess but I got it
[08:42:12] <pie_> yay
[08:42:37] <pie_> https://bpa.st/BJMA
[08:43:05] <pie_> the lines may be readable but good luck deriving meaning from this?
[08:43:17] <pie_> how would you actually make this make any sense
[08:47:25] <pie_> (so when do I actually need CTE?)
[08:53:35] <pie_> is it possible to give something in a having clause an alias?
[08:53:51] <pie_> or something so that I dont have to repeat the thing in both the having and the select?
[08:54:12] <pie_> SELECT COUNT(*) ... HAVING COUNT(*) > 5 ...
[08:58:46] <thumbs> !t pie_ alias
[08:58:46] <ubiquity_bot> pie_: aliases established in the SELECT clause are not available until the resultset is returned (can be used in GROUP BY, ORDER BY and HAVING clauses). Aliases established in the FROM clause are available earlier (can be used in the WHERE clause).
[09:00:10] <pie_> this complains about invalid column name cc https://bpa.st/BOPQ (in the having)
[09:00:19] <pie_> that snippet says I should be allowed to do that?
[09:00:54] <thumbs> pie_: what rdbms?
[09:00:57] <pie_> oracle
[09:01:01] <pie_> blehj
[09:01:05] <thumbs> pie_: then you're in the wrong channel.
[09:01:15] <pie_> I dont know what sqlzoo uses but I think it's mysql
[09:01:19] <pie_> I just reflexively wrote that
[09:01:31] <thumbs> pie_: that SQL will work with MySQL.
[09:01:48] <thumbs> pie_: if you want help with Oracle, ask the Oracle folks.
[09:01:55] <pie_> (well in fact, you pointed me to sqlzoo with a snipper IIRC)
[09:02:26] <thumbs> I am not sure what your justification is here.
[09:03:16] <pie_> SELECT @@version gives:
[09:03:17] <pie_> Microsoft SQL Azure (RTM) - 12.0.2000.8 Feb 23 2022 11:32:53 Copyright (C) 2021 Microsoft Corporation
[09:03:29] <pie_> So. I have no idea if that implies T-SQL
[09:03:29] <thumbs> pie_: that's not MySQL.
[10:31:28] *** Quits: rvalue (~rvalue@user/rvalue) (Remote host closed the connection)
[10:33:23] *** Joins: rvalue (~rvalue@user/rvalue)
[10:53:40] *** Quits: defn (~n0b0dy@user/defn) (Ping timeout: 272 seconds)
[10:54:38] *** Joins: defn (~n0b0dy@user/defn)
[10:56:49] <Isotopp> thumbs: USING is totally in the SQL Standard, I am afraid
[10:57:25] <Isotopp> https://docs.actian.com/vector/4.2/index.html#page/SQLLang/ANSI_2fISO_Join_Syntax.htm
[10:57:42] <Isotopp> thumbs: also I believe that NATURAL JOIN is ANSI, but I can't prove that right now
[10:58:23] <Isotopp> pie_: USING and NATURAL JOIN are SQL shorthand syntax exploit the fact that the column names on the left and right hand side coincidentally have the same name
[10:58:47] <Isotopp> pie_: with USING (col1, col2, ...) you name the columns that are to be joined on, but they need to have the same name on both sides
[10:59:13] <Isotopp> pie_: and NATURAL JOIN completely implies the column set -- all columns on the LHS and the RHS that happen to have the same name are being used
[10:59:37] <Isotopp> pie_: why is that bad? because if you put this into code and compile and somebody else later changes the schema, it will break in interesting and hard to debug ways.
[10:59:58] <Isotopp> where I work, if you use either -- USING or NATURAL -- we will find you and make an example of you to deter the others
[11:00:23] <Isotopp> pie_: so what thumbs says, for production SQL, use an ON clause and be explicit in what makes up the join
[11:00:26] <Isotopp>  
[11:01:09] <Isotopp> pie_: when to use a LEFT JOIN? there is only JOIN and LEFT JOIN. there are other syntaxes, that are only convenience -- RIGHT JOIN for example is a LEFT JOIN with tables swapped
[11:01:27] *** Quits: tercaL (~tercaL@user/tercal) (Quit: enter the Tekken!)
[11:01:54] <Isotopp> pie_: a LEFT JOIN b ON a.aid = b.aid takes all rows of a and will list them. for each a listed, it will produce at least one row, taking the values of b that match
[11:02:18] <Isotopp> so if a.aid has no counterpart (there is no matching b.aid), it will produce NULL values for all b columns
[11:02:53] <Isotopp> if a.aid has exactly one counterpart (there is exactly one b.aid that matches the current a.aid), it will produce one row (and the b.* columns won't be NULL)
[11:03:28] <Isotopp> if a.aid has more than one counterpart (there are two or more b.aid that match the current a.aid), the a.* values will be repeated and the b.* values will be filled in, once for each matching b.aid
[11:04:32] <Isotopp> in a     a LEFT JOIN b ON a.aid = b.aid     we sometimes call a the driving table (it drives the join) or spanning table (it spans the value space of a.aid)
[11:06:09] <Isotopp> you will often find LEFT JOINS to decode values. You want to list the driving table, in full, but the values in the driving table are encoded. there are no colors (red, green, blue, orange, rose, ...), but color ids. You LEFT JOIN the color table, and all colorids will be replace by color names from the color table.
[11:06:34] <Isotopp> The left join makes sure you always have all values from the driving table, even if there happens to be a color that cannot be decoded.
[11:07:38] <Isotopp> so      SELECT a.article_id, c.colorname from articles as a LEFT JOIN colors as c ON a.colorid = c.colorid WHERE a.zipcode BETWEEN 10000 AND 20000
[11:08:17] <Isotopp> "list me the entire article table for the zipcodes starting with 1, but translate colorids to colornames" (and if a colorid cannot be resolved, emit a NULL)
[11:08:55] <Isotopp> better     SELECT a.article_id, coalesce(c.colorname, a.colorid) from articles as a LEFT JOIN colors as c ON a.colorid = c.colorid WHERE a.zipcode ....
[11:09:35] <Isotopp> the coalesce() function takes a list of values, and will return the first value that is not a NULL. so if c.colorname is null, because the a.colorid cannot be resolved, we return the unresolvable raw value
[11:09:39] <Isotopp>  
[11:35:00] <pie_> This is what I had understood originally. I *thought* I'd seen it somewhere. <Isotopp> pie_: with USING (col1, col2, ...) you name the columns that are to be joined on, but they need to have the same name on both sides
[12:58:26] *** Joins: Aussie_Matt_ (~quassel@180.150.112.148)
[13:06:28] *** Joins: bodiccea (~bodiccea@user/bodiccea)
[13:24:57] <Isotopp> pie_: good. It is also how it is explained ie in https://docs.actian.com/vector/4.2/index.html#page/SQLLang/ANSI_2fISO_Join_Syntax.htm
[13:25:45] <Isotopp>  
[13:35:22] *** Joins: Naktibalda (~Naktibald@88.135.22.17)
[14:10:37] <thumbs> Isotopp: hrm, right
[14:10:53] <thumbs> Isotopp: I have a deep hatred for them.
[14:11:43] *** Quits: Vacuity (~Vacuity@user/vovo) (Ping timeout: 260 seconds)
[14:13:18] *** Joins: Vacuity (~Vacuity@user/vovo)
[14:18:43] *** Quits: codebam (~codebam@user/codebam) (Ping timeout: 260 seconds)
[15:33:45] *** Joins: Guest54 (~Guest54@2620:10d:c092:400::4:a80e)
[16:22:16] *** Quits: shokohsc (~shokohsc@lfbn-idf2-1-974-194.w86-238.abo.wanadoo.fr) (Quit: Ping timeout (120 seconds))
[16:23:35] *** Joins: shokohsc (~shokohsc@lfbn-idf2-1-974-194.w86-238.abo.wanadoo.fr)
[16:29:11] *** Quits: ikwyl6 (~ikwyl6@195.206.105.22) (Ping timeout: 260 seconds)
[16:31:00] *** Joins: ikwyl6 (~ikwyl6@195.206.105.22)
[16:49:25] *** Quits: kevr` (~kevr@user/kevr) (Remote host closed the connection)
[16:49:46] *** Joins: kevr (~kevr@user/kevr)
[17:09:04] *** Quits: Guest54 (~Guest54@2620:10d:c092:400::4:a80e) (Ping timeout: 250 seconds)
[17:37:19] *** Joins: Guest54 (~Guest54@2620:10d:c092:400::4:a80e)
[18:04:26] *** Joins: Bushcat (~Goondog@host-92-28-79-240.as13285.net)
[18:06:01] *** Quits: Bushcat (~Goondog@host-92-28-79-240.as13285.net) (Quit: Leaving)
[18:23:15] *** Joins: Bushmaster (~Goondog@user/bushmaster)
[18:23:57] <Bushmaster>  Howdy Folks, just inquiring, does anyone good at table normalizing following Codd's normal form 1NF, 2NF and 3NF
[18:28:18] *** Joins: ssh073 (~thelounge@79.164.47.232)
[18:32:41] <Xgc> Isotopp: NATURAL JOIN is standard too.
[18:33:53] <Xgc> <natural join> ::= { <table reference> | <partitioned join table> } NATURAL [ <join type> ] JOIN { <table factor> | <partitioned join table> }
[18:34:54] <Xgc> Found in: 7.7 <joined table>  ... or the equivalent section in the version of interest.
[18:42:30] *** Quits: Aussie_Matt_ (~quassel@180.150.112.148) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
[18:46:34] *** Quits: Guest54 (~Guest54@2620:10d:c092:400::4:a80e) (Ping timeout: 250 seconds)
[18:58:37] *** Quits: ssh073 (~thelounge@79.164.47.232) (Quit: The Lounge - https://thelounge.chat)
[19:04:24] *** Joins: ssh073 (~serg073@79.164.47.232)
[19:12:18] *** Quits: ssh073 (~serg073@79.164.47.232) (Quit: The Lounge - https://thelounge.chat)
[19:21:34] *** Joins: ssh073 (~serg073@79.164.47.232)
[19:39:58] *** Quits: Vacuity (~Vacuity@user/vovo) (Ping timeout: 272 seconds)
[19:40:31] *** Quits: nickodd (~nickodd@user/nickodd) (Ping timeout: 260 seconds)
[19:41:32] *** Joins: Vacuity (~Vacuity@user/vovo)
[19:43:43] *** Quits: David- (~none@host81-149-15-132.in-addr.btopenworld.com) (Quit: /)
[19:47:43] *** Joins: David- (~none@host81-149-15-132.in-addr.btopenworld.com)
[20:04:43] *** Joins: csm3105 (~csm3105@47.61.127.217)
[20:33:48] *** Quits: David- (~none@host81-149-15-132.in-addr.btopenworld.com) (Ping timeout: 260 seconds)
[20:47:36] *** Joins: David- (~none@host81-149-15-132.in-addr.btopenworld.com)
[20:51:16] *** Joins: David-- (~none@host81-149-15-132.in-addr.btopenworld.com)
[20:51:57] *** Quits: David- (~none@host81-149-15-132.in-addr.btopenworld.com) (Ping timeout: 256 seconds)
[20:55:44] *** Joins: David- (~none@host81-149-15-132.in-addr.btopenworld.com)
[20:56:29] *** Quits: David-- (~none@host81-149-15-132.in-addr.btopenworld.com) (Ping timeout: 256 seconds)
[21:01:35] *** Quits: David- (~none@host81-149-15-132.in-addr.btopenworld.com) (Ping timeout: 256 seconds)
[21:02:05] *** Joins: David- (~none@host81-149-15-132.in-addr.btopenworld.com)
[21:03:04] *** Joins: nickodd (~nickodd@user/nickodd)
[21:07:32] *** Quits: David- (~none@host81-149-15-132.in-addr.btopenworld.com) (Ping timeout: 252 seconds)
[21:13:17] *** Joins: jwash (~jwash@c-73-254-46-148.hsd1.wa.comcast.net)
[21:13:45] <jwash> hi guys i am trying to install mariadb but i can't find the mysql_secure_installation script after installing from the repo
[21:13:48] <jwash> any ideas
[21:13:51] *** Joins: David- (~none@host81-149-15-132.in-addr.btopenworld.com)
[21:15:18] <lopid> mariadb-secure-installation
[21:15:41] *** Quits: nickodd (~nickodd@user/nickodd) (Ping timeout: 246 seconds)
[21:16:25] <jwash> ty
[21:28:47] *** Quits: David- (~none@host81-149-15-132.in-addr.btopenworld.com) (Ping timeout: 256 seconds)
[21:33:17] *** Joins: pulseaudio (~pulseaudi@223.223.137.136)
[21:53:48] *** Joins: codebam (~codebam@user/codebam)
[21:55:04] *** Joins: David- (~none@host81-149-15-132.in-addr.btopenworld.com)
[21:57:08] *** Joins: nickodd (~nickodd@user/nickodd)
[22:04:36] *** Joins: David-- (~none@host81-149-15-132.in-addr.btopenworld.com)
[22:05:17] *** Quits: David- (~none@host81-149-15-132.in-addr.btopenworld.com) (Ping timeout: 252 seconds)
[22:08:57] *** Joins: David- (~none@host81-149-15-132.in-addr.btopenworld.com)
[22:09:24] *** Quits: David-- (~none@host81-149-15-132.in-addr.btopenworld.com) (Ping timeout: 240 seconds)
[22:37:15] *** Quits: ssh073 (~serg073@79.164.47.232) (Quit: The Lounge - https://thelounge.chat)
[22:39:43] *** Joins: ssh073 (~serg073@79.164.47.232)
[22:40:21] *** Quits: ssh073 (~serg073@79.164.47.232) (Client Quit)
[22:58:58] *** Quits: [sr]|2 (~kvirc@pal-213-228-163-73.netvisao.pt) (Quit: KVIrc 5.0.0 Aria http://www.kvirc.net/)
[23:10:46] *** Quits: David- (~none@host81-149-15-132.in-addr.btopenworld.com) (Ping timeout: 245 seconds)
[23:11:53] *** Joins: David- (~none@host81-149-15-132.in-addr.btopenworld.com)
[23:26:17] *** Joins: zumba_addict (~zumba_add@c-71-194-58-34.hsd1.il.comcast.net)
[23:31:11] *** Quits: David- (~none@host81-149-15-132.in-addr.btopenworld.com) (Ping timeout: 256 seconds)
[23:31:16] *** Joins: David-- (~none@host81-149-15-132.in-addr.btopenworld.com)
[23:42:32] *** Quits: pulseaudio (~pulseaudi@223.223.137.136) (Ping timeout: 250 seconds)
