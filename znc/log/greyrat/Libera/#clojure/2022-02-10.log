[00:07:49] *** Joins: seabass (~seabass@user/seabass)
[00:17:14] *** Joins: seebs (~seebs@24.196.59.174)
[00:18:40] <seebs> hi! i keep planning to actually learn a functional programming language, after comparing notes and having a bunch of people enthusiastically tell me which one they liked best, i decided to try clojure. have lots of background in imperative languages, poked at racket a bit and sorta bounced off it, spent like 4 hours playing with emacs lisp once in the 80s.
[00:19:55] <seebs> any suggestions for good starting points or likely pitfalls to watch out for?
[00:20:13] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[00:33:44] *** Quits: mwnaylor (~user@2601:5ce:4300:5560::68b3) (Read error: Connection reset by peer)
[00:34:06] *** Joins: mwnaylor (~user@2601:5ce:4300:5560::68b3)
[00:51:02] *** Joins: blei (~blei@209.201.38.106)
[00:52:17] *** Quits: blei (~blei@209.201.38.106) (Client Quit)
[01:08:34] *** Quits: DasBrain (~DasBrain@user/dasbrain) (Killed (NickServ (GHOST command used by DasBrain_)))
[01:08:40] *** Joins: DasBrain_ (~DasBrain@user/dasbrain)
[01:13:26] *** Joins: Harlin (~DonQixote@75-163-202-34.clsp.qwest.net)
[01:21:16] <seabass> seebs, have you ever used the React framework in web development? For me, it was very valuable to realise that React's paradigm is model function programming, and basically everywhere in Clojure 
[01:21:50] <seabass> Never mutate state; always take a state hash-map as the first parameter and return a new state hash-map
[01:21:52] <technomancy> seebs: the hardest part is finding a good learning project IMO
[01:22:02] <seabass> technomancy: lol, no shortage of ideas for me
[01:22:11] <seabass> 'good' is the operative word :D
[01:22:26] <technomancy> right, like ... finding something that's not too contrived but also not too difficult
[01:24:52] <Para> My very first Clojure project was a small tool which would scan a given AWS environment and remove all resources which were older than x days. That alone took surprisingly long to make when I was starting.
[01:25:44] <seabass> yes, everything takes surprisingly long... death to deadlines...
[01:26:55] <seebs> haven't touched react, no, i fear javascript greatly
[01:27:15] <seebs> i get along pretty well with C, Go, Ruby, and Lua. i found a thing of koans which i usually get along with and i'm having fun with it.
[01:28:12] <seebs> i would be absolutely terrrified to try to point a learning project at AWS, i'd be worried about somehow ending up destroying someone else's stuff, acquiring access to stuff i wasn't supposed to have, and ending up having technically committed a war crime, *without* successfully administering my own stuff at all
[01:28:21] <seebs> i might be the tiniest bit low on confidence in AWS
[01:28:39] <Para> seebs: in my case that was the point, we had an AWS sandbox and despite being told so people wouldn't delete their crap :)
[01:28:45] <Para> So we went LOIC.
[01:28:52] <seebs> LOIC?
[01:29:06] <seabass> seebs: ah, but that's where functional programming is great! There are no side effects; you can test the functions to your hearts content before actually sending the IO
[01:29:09] <seebs> i mean, that seems reasonable, i just... i have a *talent* for programming, but not in, like, a good way
[01:29:15] <Para> Low Orbit Ion Cannon
[01:29:33] <seebs> so i would be pretty nervous about sending delete commands to AWS even if i could absolutely prove on paper that the commands could not possibly do any harm to anything outside the sandbox
[01:30:35] <seebs> i haven't got any specific project ideas in mind yet, and i should probably pick something. for starters, i think mostly i just have to get used to things like "sometimes there's an apostrophe, and that matters"
[01:30:43] <Para> And if you're not familiar with LOIC, it's the full name of a superweapon from the Command&Conquer series, and also a DDoS tool made by 4chan. I'm old enough to only care about CnC, though.
[01:30:57] <seebs> for instance, the koan for strings started out with:
[01:31:00] <seebs> (ns koans.02-strings
[01:31:00] <seebs>   (:require [koan-engine.core :refer :all]
[01:31:00] <seebs>             [clojure.string :as string]))
[01:31:06] <seebs> so i thought "oh hey, i see how require works"
[01:31:32] <seebs> user=> (:require [clojure.string :as string])
[01:31:56] <seebs> well it turns out that doesn't work. i don't want the :, but i want a '[ instead of a [, and... i actually don't understand the second part
[01:32:03] <seabass> seebs: I have the perfect online free ebook for you!
[01:32:05] <seebs> the first part makes sense, require is a function, :require is a symbol
[01:32:14] <seebs> ooh
[01:32:16] <ToxicFrog> :require is a keyword. Different thing.
[01:32:34] <ToxicFrog> So, the trick there is that (ns ...) is itself a macro that looks for stuff like (:require ...) and (:import ...) and turns it into calls to (require ...) and (import ...)
[01:32:44] <seabass> seebs: Chapter 6 of Clojure for the Brave and True explains everything about namespaces: https://www.braveclojure.com/organization/
[01:32:59] <seabass> like literally everything
[01:33:04] <seebs> er, yes, keyword, not symbol. ... i now realize i don't know that distinction either.
[01:34:02] <ggb> Symbols are names for values. When the reader encounters a symbol it attempts to look up the value the symbol points to.
[01:34:07] <seebs> anyway, thanks, i will look at that book, it looks friendly.
[01:34:13] <ggb> Keywords are special things that always evaluate to themselves.
[01:34:37] <ToxicFrog> (require) on its own needs the ' to prevent the argument from being evaluated
[01:34:39] <ToxicFrog> So (require '[clojure.string :as string]) passes it, as an argument, a list containing the symbol "clojure.string", the keyword ":as", and the symbol "string".
[01:34:41] <ToxicFrog> If you don't use the ', it tries to evalute the list, but clojure.string and string aren't bound to anything yet because you haven't required them! So it fails.
[01:35:23] <technomancy> step 1: accept that the ns macro doesn't make a lick of sense
[01:35:40] <seebs> ahh, yes. i've been told that the purpose of macros is to make Paul Graham smug
[01:35:55] <seebs> honestly i have rarely seen a language feature so successful
[01:35:59] <technomancy> it's one of the stupidest frustrations you will encounter as a newcomer building up your intuition of how clojure works
[01:36:05] <ggb> Since you mentioned C earlier, this might be a worthwhile pair of talks: https://www.youtube.com/watch?v=P76Vbsk_3J0&t=14s (# 2 is just the same title with s/1/2/)
[01:36:17] <ggb> Java being a c-style language.
[01:36:31] <seebs> ... i feel like either java programmers or c programmers will take offense at that :P
[01:36:42] <ggb> (;
[01:37:06] <ggb> It's a worthwhile introduction to the language fundamentals targeted at non-functional programming background.
[01:37:08] <seebs> i tend to struggle with talks and need to read words to get much out of things
[01:37:18] <ggb> Fair enough.
[01:37:57] <seebs> i feel like i've seen No Starch somewhere... oh! they're the people who published the PoC||GTFO collections i have
[01:39:10] <ggb> Java is certainly a C descendant, though.
[01:40:32] <ToxicFrog> Yeah, as someone who's used both professionally that seems like a completely non-controversial statement.
[01:41:13] <seebs> huh. java feels wildly different from C to me.
[01:41:34] <technomancy> semantically it's wildly different but syntactically it's very close
[01:41:39] <seebs> ahh, that's fair.
[01:41:49] <ggb> Java is obnoxiously object oriented, and C is procedural. But Java definitely falls in the C family tree.
[01:41:57] <seebs> it's sort of amazing, they managed to preserve the things i liked least, while wrecking everything i liked.
[01:42:31] <ggb> If it feels better: C and Java are both curly-brace languages.
[01:43:43] <seebs> and yet, only one of them makes me break out in hives. very mysterious. :P
[01:44:03] <seebs> honestly, when i was soliciting suggestions on a functional language to play with, the strongest argument anyone had against clojure was "JVM".
[01:44:05] <ggb> I guess that doesn't feel better (:
[01:44:23] <ggb> Ah, well then just jump on the Clojurescript train. Same language, different VM.
[01:44:33] <ggb> Or Clojure CLR. Same language, but on the CLR!
[01:44:37] <seebs> eh, jvm's fine for now. i can worry about it later.
[01:44:50] <seebs> i have to have a JVM anyway because minecraft.
[01:44:55] <ToxicFrog> Honestly the JVM, as a VM, is a pretty cool piece of tech that IMO has been unfairly tainted by long association with Java
[01:44:58] <seebs> yeah
[01:45:35] <seebs> anyway, i had one friend who was very big on racket, and another who likes racket except for some missing stair problems in the community, and i've seen some people be pretty happy with clojure, so. seemed like a good thing to try out.
[01:45:37] <ToxicFrog> I do not actually enjoy using Java and I'm glad that my writing-java-for-money days are long behind me, but I'm quite happy that there's now a whole ecosystem of JVM-based languages that aren't Java
[01:45:43] <ggb> It is worthwhile seeking out some of Rich Hickey's stuff on creating the language. Being hosted on a VM such as the JVM is a fundamental design decision.
[01:47:08] <seebs> i used to do a lot of interviewing, and i saw someone once attempt a coding thing in clojure, which he *absolutely loved* and had been doing for i think two days
[01:47:34] <technomancy> racket has a lot better materials for learning than clojure tbh
[01:47:47] <seabass> seebs: wow that's a great story
[01:47:48] <seebs> by far the largest gap i ever saw between "objective performance" (got virtually nothing done) and "subjective performance" (absolutely amazing).
[01:48:00] <seabass> welcome to the Clojure community, in any case :)
[01:48:28] <seebs> like, it was really obvious that this was an excellent programmer, and also that he couldn't remember how to do mutable list-like-things and was fuzzy on syntax details.
[01:48:41] <technomancy> probably because the core team consists of (I think) 100% professors
[01:49:16] <ToxicFrog> Wow, top marks for enthusiasm but questionable judgement there~
[01:49:22] <seebs> i've read racket docs some, because of a friend who uses it a lot, and i dunno. it seemed okay but it felt Messy to me in a way that clojure doesn't.
[01:49:41] <seebs> yeah, it was definitely not the best productivity answer, and he knew that, but he was just *so hyped* about this COOL NEW TOY.
[01:49:52] <technomancy> seebs: the docs are great reference but not great learning material; I was thinking more of the books
[01:50:23] <technomancy> (but even so they're still better than clojure's docs)
[01:51:29] <technomancy> try reading the docstring for doseq or reduce
[01:51:30] <seebs> so one of the possible long-term goals of this is eventually producing documents that people might be learning stuff from, and one of the factors i was sort of weighing is "if i encourage people to go program this and be in this community, how does that work out"
[01:51:41] <technomancy> it's very much "yes this makes perfect sense if you already know what it does and zero sense if you don't"
[01:52:21] <seebs> and someone linked me to a thing from a former racket contributor on their concerns about the community, and i looked at it a bit and just did not think i wanted to encourage hopeful novices to find out whether it was that bad for them
[01:57:39] <ToxicFrog> tbh the main reason I am hesitant about recommending clojure, as much as I love it, is that its error reporting, especially it's compile-time error reporting, is unmitigated garbage
[01:58:08] <technomancy> rule 1: never recommend a language whose IRC channel is full of people who don't have anything bad to say about it
[01:59:06] <seebs> Pretty much, yeah.
[02:00:10] <technomancy> in the Emacs channel, the bot has a "salespitch" command that says "We aren't gonna lie. Emacs sucks. Some of us tolerate it, but we can't tell you if YOU'LL be able to. Try it and make up your own mind."
[02:00:11] <ggb> So, never recommend a language with an empty IRC channel?
[02:00:19] <technomancy> ggb: well yeah, that goes without saying
[02:00:57] <ggb> In my experience, programmers can be a cantankerous bunch. I've never used any language or tool which doesn't elicit complaints even from passionate users.
[02:01:27] <ggb> So an IRC channel with nothing bad to say is, tautologically, empty.
[02:02:09] <technomancy> I remember when I had to debug a problem in python twisted (not knowing python) and I joined the channel and it was full of people trying to convince themselves that it was worth the pain because async is the only way to be webscale; that was eye-opening
[02:02:30] <ggb> Interesting.
[02:02:37] <ggb> Yeah, that sounds unhealthy.
[02:03:45] <technomancy> if I find a project and the readme explains under what circumstances you should not use the project, that is an instant way to earn my trust
[02:04:18] <ggb> Agreed on that. I also like anti-goals.
[02:04:42] <technomancy> ah yeah for sure
[02:13:03] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 276 seconds)
[02:19:37] *** Quits: cmiles74 (~miles@068-184-030-013.res.spectrum.com) (Ping timeout: 240 seconds)
[02:20:37] <seebs> ahh, yes. webscale.
[02:20:50] <seebs> https://www.youtube.com/watch?v=b2F-DItXtZs
[02:21:53] <seebs> at one point i was working on a thing which was an LD_PRELOAD library which intercepted libc calls to emulate root without requiring actual root privileges (it's called pseudo, it was a ton of fun), and someone was lecturing me on how I should have written this thing that intercepts syscalls and patches them in Python so I wouldn't have to do string manipulation.
[02:22:05] *** Joins: AlaskanEmily (~AlaskanEm@user/alaskanemily)
[02:22:20] <seebs> definitely did not give me high confidence that their recommendations were based on nuanced study of the requirements of a particular project.
[02:23:10] *** Joins: libertyprime (~libertypr@118-92-72-229.dsl.dyn.ihug.co.nz)
[02:23:20] *** Quits: libertyprime (~libertypr@118-92-72-229.dsl.dyn.ihug.co.nz) (Client Quit)
[02:23:55] *** Joins: libertyprime (~libertypr@118-92-72-229.dsl.dyn.ihug.co.nz)
[02:25:38] <ToxicFrog> Oh dear
[02:25:40] <ToxicFrog> I mean, I've done stuff like that in the past -- write a thin layer of glue in C and then do all the actual logic in Lua, say -- but I was also well aware that I was basically doing the programming equivalent of shitposting
[02:26:19] <ToxicFrog> (although I do maintain that for my compilers course, using C for the flex/bison interface layer and Lua for the code analysis and generation layer was the correct choice)
[02:29:21] <seebs> once the glue is done there's not enough left to really justify the work, and also, the overhead of trying to have a garbage-collected runtime *inserted in another process's address space* struck me as concerning.
[02:29:30] <technomancy> god yeah I can't imagine writing an actual parser in a language without strings; why would you do that to yourself
[02:32:27] <seebs> well, one reason would be it's like 1975 and you don't have enough memory to support one of the Big Fancy Languages :P
[02:35:44] <ToxicFrog> technomancy: I mean, in the case of the compilers course, the whole point of flex+bison is to generate the lexer and parser for you so you don't have to do it by hand
[02:36:27] <technomancy> ah yeah, I misread that.
[02:36:38] <ToxicFrog> I wired it up so that "shift" pushed a token onto the lua stack and "reduce" combined the top N tokens into an AST node, so by the time parsing was complete there was a single value on the stack representing the root of the AST and then it just transfers control to lua, which does all the hard parts and blorfs out asm
[02:36:39] <seebs> huh. (keyword map) and (map keyword) are apparently equivalent?
[02:37:04] <seebs> like "({:a 1 :b 2} :a)" and "(:a {:a 1 :b 2})"
[02:37:07] <technomancy> but isn't the entire existence of flex/bison just a workaround for using a shitty language that doesn't have strings? why not ... write the actual code, but use a language that is well-suited for it?
[02:37:21] *** Quits: seschwar (~seschwar@user/seschwar) (Quit: :wq)
[02:38:35] <ToxicFrog> technomancy: at the time I was taking the course, lex/flex, yacc/bison, and antlr were all very widely used and stuff like PEGs were mostly unknown
[02:38:37] <ToxicFrog> so part of the project was "pick one of these industry-standard compiler frontend libraries and familiarize yourself with it"
[02:38:39] <ToxicFrog> and the rest of the project was "write a functioning compiler backend using any tech you want as long as it can interoperate with the frontend you chose"
[02:39:01] <technomancy> I guess there's only so much you can fit into a semester
[02:40:37] <goodger> > Today's Unix/Posix-like operating systems, even including IBM's z/OS mainframe version, as seen with 1980 eyes are identical; yet the 31,085 lines of configure for libtool still check if <sys/stat.h> and <stdlib.h> exist, even though the Unixen, which lacked them, had neither sufficient memory to execute libtool nor disks big enough for its 16-MB source code.
[02:40:46] <seebs> I wouldn't be surprised if stuff like flex would, in some cases, significantly outperform the behavior you'd get trying to do it by hand at a string-processing level. State machines are pretty good at their thing.
[02:40:52] <seebs> yeah
[02:41:06] <seebs> configure has a flag to check for sizeof(char)
[02:41:41] <ToxicFrog> using flex+bison also gets you a whole lot of error detection and reporting you don't need to write yourself, which is pretty nice
[02:41:52] <technomancy> it's a university course; you're not going for the fastest possible parser
[02:42:06] <ToxicFrog> technomancy: yeah, in this case there was a prerequisite course where you learned about language theory and wrote your own lexers and parsers using various techniques and whatnot
[02:42:58] <technomancy> configure's like "Hang on a sec while I check to see whether this computer knows about the sine function." / "OK, we got sine. but what about cosine. that might be missing. gonna check... ok, it's there. whew."
[02:42:59] <ToxicFrog> So this course starts out from the assumption that you know how the frontend works and can write one yourself if you need to, but rather than making you do that again you'll just use an off-the-shelf industry standard implementation that is probably what you'll be using anyways if you find yourself needing to write a compiler in the real world anyways
[02:43:01] <ToxicFrog> now let's talk register allocation algorithms
[02:43:03] <AlaskanEmily> The sizeof(char) thing is concerning, even in ansi/C89 C that is required to equal 1 no matter what...
[02:45:37] <seebs> yes
[02:45:41] <seebs> it's the *unit*
[02:45:47] <seebs> you don't need to measure the length of the unit, in units
[02:45:49] <seebs> we know that one
[02:45:54] <seebs> with some exceptions
[02:45:57] <seebs> unit circle: r=1
[02:46:04] <seebs> absolute unit circle: r=1.2 a chonky boi
[02:46:06] <AlaskanEmily> I would be really interested to know what systems didn't have that property, where the unit wasn't in chars.
[02:46:19] <seebs> none that i've ever heard of, and that includes systems where CHAR_BIT was 64
[02:46:22] <ToxicFrog> Maybe the logic is that if sizeof(char)!=1 it panics?
[02:46:34] <AlaskanEmily> But I would only expect purpose-built stuff to work with it.
[02:46:37] <seebs> no, it just writes a value that you can use to make things conditional on it and multiply things by it
[02:46:40] <technomancy> ToxicFrog: trick quostion
[02:46:53] <seebs> i don't know of an actual use for this that isn't "being very confused"
[02:48:57] <goodger> it was apparently useful for programming on cheap minicomputers when it was designed
[02:49:23] <ToxicFrog> > i don't know of an actual use for this that isn't "being very confused"
[02:49:25] <ToxicFrog> I need to immortalize this in a channel topic somewhere or something
[02:49:35] <technomancy> obligatory https://leftoversalad.com/c/014_javavsjavascript/
[02:50:58] <seebs> this question may be nonsensical, but: given the existence of namespaced symbols and namespaced keywords, are the namespaces there the same type of thing? like, if i had a namespace foo and a symbol bar, foo/bar is the symbol bar in the namespace foo... is :foo/bar then the keyword :bar in the samespace foo?
[02:51:07] <seebs> er namespace, not samespace
[02:51:17] <technomancy> "it appeared to be a coffee but it was actually a medium coffee!" is gonna be my go-to example error message when writing documentation from here on out
[02:51:36] <technomancy> seebs: they're totally not, and this is really confusing
[02:52:14] <technomancy> well, wait... between symbols and keywords, they're basically the same thing
[02:52:18] <seebs> okay
[02:52:27] <technomancy> but between keywords and the ns macro, they're only very tenuously related
[02:52:53] <seebs> okay
[02:53:43] <seebs> i'm mostly just trying to figure out whether :foo/bar is more like something that could also have been spelled foo/:bar with different design choices, in that it's picking the namespace foo, then looking for a keyword bar in it, or whether the entire thing is a keyword and the / is less-magic, or ???
[02:53:57] <seebs> i am probably not actually prepared to understand an answer to the question but i'm a very curious person
[02:54:47] <technomancy> for both symbols and keywords, the namespace is just a string prefix
[02:55:04] *** Joins: paddymahoney (~paddymaho@cpe9050ca207f83-cm9050ca207f80.cpe.net.cable.rogers.com)
[02:55:23] <technomancy> (= (namespace :foo/bar) (namespace 'foo/bar)) ; -> true
[02:55:26] <technomancy> if that helps
[02:55:39] <technomancy> but a namespace from the ns macro is a storage location where vars exist and bind names to functions, but a namespace on a keyword/symbol is just a label that lives on the keyword and tells you where to classify it.
[02:56:04] <technomancy> foo/:bar could in a parallel world be a perfectly reasonable alternate notation to mean the same thing as :foo/bar
[02:56:32] <seebs> *thinking* oh. keywords don't have any meaning other than that they are that keyword, so there's no *meaning* to the idea of a given namespace "exporting" a keyword or defining it.
[02:56:56] <technomancy> yep. keywords are just names, basically.
[02:57:09] <seebs> so it may make sense as a convention to use namespaces on them, but the keyword :foo/bar does not, in any way, translate into the same thing that :bar would mean inside the namespace foo.
[02:57:43] <seebs> but 'foo/bar does mean the same thing that 'bar would mean within the thing that foo refers to, i think.
[02:57:54] <seebs> this is gonna take some getting used to
[02:57:55] <technomancy> for keywords, no, never. for symbols, you can use the symbol to look up a value in a ns-namespace
[02:58:11] <technomancy> basically it's making names and their dereferencing into a first-class concept
[02:58:31] <technomancy> in most languages this is embedded into the language and you can't grab a name and pass it to a function
[02:58:46] <seebs> yeah, this is... pretty similar to how ruby handles things like :foo, except i don't think ruby lets you have slashes in them
[02:59:03] <seebs> but you can do to-sym/to-string to swap them around.
[02:59:24] <technomancy> similar in that :foo is an independent thing you can pass around which can then be used to look up a method thru dereferencing, yeah
[02:59:55] <technomancy> the difference is that every clojure program is composed primarily of symbols, and in ruby that's not true at all. (this is very nearly what it means to be a lisp)
[03:00:11] <technomancy> https://blog.janestreet.com/whats-in-a-name/ <- more about names and namespaces and dereferencing
[03:00:51] <seebs> yeah, and there's no meaning to "defining" a ruby-symbol, it doesn't need to be declared, and so on, it's just that anything that refers to a given symbol will be the same as anything else referring to the same symbol, making them good choices for some identifier-like functionality.
[03:01:06] <seebs> er, "magic cookie to identify a thing", not like, identifier in the BNF sense
[03:01:39] <seebs> man this looks like it's gonna be fun
[03:01:56] <seebs> the best thing about programming is always finding something new enough that it's hard to make sense of it at first
[03:02:31] <technomancy> especially when it's a concept you've always used and taken for granted, but you then see it framed in a new light where you can do new things with it
[03:03:12] <seebs> yeah
[03:03:35] *** Parts: seabass (~seabass@user/seabass) ()
[03:03:42] <seebs> it's great if i find a language useful, but a big part of the benefit of learning any language is that it makes me better at all the other languages
[03:08:51] <seebs> i have seen that janestreet post about names before, and oh man do i feel them on make_foo/bar_create/NewBaz.
[03:18:26] <goodger> I just got to that bit myself
[03:18:34] <goodger> it's pretty painful
[03:21:16] <goodger> maybe I'll understand lisp one day…
[03:34:26] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[04:04:23] *** Joins: kipper (~kipz@home.kipz.org)
[04:06:19] *** Joins: blei (~blei@209.201.38.106)
[04:06:37] *** Quits: kipz (~kipz@home.kipz.org) (Ping timeout: 240 seconds)
[04:11:49] *** Joins: kipz (~kipz@home.kipz.org)
[04:13:25] *** Quits: kipper (~kipz@home.kipz.org) (Ping timeout: 250 seconds)
[04:29:13] *** Joins: kipper (~kipz@home.kipz.org)
[04:31:17] *** Quits: kipz (~kipz@home.kipz.org) (Ping timeout: 240 seconds)
[04:34:48] *** Joins: kipz (~kipz@home.kipz.org)
[04:36:47] *** Quits: kipper (~kipz@home.kipz.org) (Ping timeout: 256 seconds)
[04:43:52] *** Joins: kipper (~kipz@home.kipz.org)
[04:46:22] *** Quits: kipz (~kipz@home.kipz.org) (Ping timeout: 250 seconds)
[04:47:01] *** Quits: nivekuil (~nivekuilc@2001:470:69fc:105::d57e) (Ping timeout: 240 seconds)
[04:48:14] *** Joins: nivekuil (~nivekuilc@2001:470:69fc:105::d57e)
[04:49:15] *** Quits: dadinn (~dadinn@host86-134-44-43.range86-134.btcentralplus.com) (Ping timeout: 256 seconds)
[04:56:37] *** Quits: nullm0dem (~nullm0dem@rs232.0x2f8.io) (Ping timeout: 240 seconds)
[04:56:44] *** Joins: nullm0dem (~nullm0dem@rs232.0x2f8.io)
[04:57:52] *** Joins: IPmonger (~IPmonger@c-69-242-83-226.hsd1.pa.comcast.net)
[04:58:11] *** Quits: IPmonger (~IPmonger@c-69-242-83-226.hsd1.pa.comcast.net) (Remote host closed the connection)
[05:07:15] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 276 seconds)
[05:09:56] <sobel> for my part, learning async flow control has been a rewarding new challenge
[05:10:14] <sobel> i'm trying to convince myself i can build a "reactive" system
[05:10:52] *** Quits: blei (~blei@209.201.38.106) (Quit: Client closed)
[05:12:33] <ToxicFrog> My experiences with async flow control have mostly convinced me that it's a bad solution to a problem coroutines already solve better :/
[05:19:59] <jaawerth> technomancy: well also python's async/event-based stuff feels very haphazarlybolted on in an attempt to get with the times. at least that was my impression at the time
[05:20:12] <jaawerth> ike "oh hey we have two kindsof Future now I guess oh well
[05:51:09] *** Quits: lunik1 (~lunik1@37.205.14.203) (Quit: :x)
[05:57:44] *** Joins: IPmonger (~IPmonger@c-69-242-83-226.hsd1.pa.comcast.net)
[05:57:59] *** Quits: IPmonger (~IPmonger@c-69-242-83-226.hsd1.pa.comcast.net) (Remote host closed the connection)
[06:20:32] *** Joins: shiranaihito (~textual@123-192-192-149.dynamic.kbronet.com.tw)
[06:28:19] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[06:33:30] <seebs> one of my friends is Very Lisp, and he was talking about how at some job, as an entry-level programmer, he was supposed to do a "parser", by which we mean "something that reads an input file" (no actual nested structure).
[06:33:54] <seebs> so he did the only thing that made sense in Python, which was spend two days building something that allowed him to duplicate the effects of tail call optimizations so he could write it recursively and not have it explode
[06:34:50] <seebs> so far as i can tell, there simply isn't a category in his world for "things that might make more sense to think about as iteration than as recursion".
[06:36:24] *** Quits: puchka (~marius@165.73.242.83) (Quit: leaving)
[06:36:27] <seebs> learning to think outside the box is very hard, but i think there's benefit to at least learning to think in several different boxes
[06:37:57] *** Quits: mwnaylor (~user@2601:5ce:4300:5560::68b3) (Ping timeout: 240 seconds)
[06:39:09] <TimMc> haha
[06:40:13] <seebs> i think i tend to think of recursion as a good fit when things are logically nested, like, i have to finish a subtask before i can actually finish a parent task, so if tail calls being free makes a big difference, i'm probably going to be doing something more loop/iteration shaped.
[06:41:56] <TimMc> This sounds like a [parse(line) for line in f.readlines()] or whatever.
[06:42:31] <TimMc> or (map parse (split-lines (slurp f))) in Clojure
[06:44:26] <seebs> roughly, yeah. i've been poking him about his intuitions here because they're very surprising to me, and actually i think he's articulated the rule
[06:44:41] <TimMc> Not sure how you'd shoehorn explicit recursion in there even in a Lisp.
[06:44:45] <seebs> which is roughly that he thinks iteration feels natural for doing side-effects for each item in a list, and recursion feels natural for computing a value based on a list.
[06:45:17] <TimMc> ...is this because of cons cells?
[06:45:25] <seebs> i don't know
[06:45:30] <seebs> he said "(define f (begin (x) (f))"
[06:45:45] <seebs> i saw someone do this in C once, and at the time I could not figure out what on earth they were doing
[06:46:06] <seebs> but it was basically `void process_file(FILE *f) { blah blah fgets; process_file(f); }}`
[06:46:13] <seebs> only with fewer extra }
[06:46:17] <seebs> i need to reflash this keyboard
[06:46:36] <TimMc> I'm so used to Clojure's seq abstraction that I forget they're recursive under the covers.
[06:46:37] <seebs> but now that i think about it, i bet they just came from a scheme background, where that optimization is explicitly required-by-spec
[06:47:43] <seebs> but i'm pretty sure that "computing value" vs "doing side-effects" is a pretty arbitrary line without much relationship to the shape of the problem
[06:47:43] <TimMc> Yeah, this brings me back to HtDP and DrScheme.
[06:48:12] <seebs> (define (even? n) (if (zero? n) #t (odd? (sub1 n))))
[06:48:12] <seebs> (define (odd? n) (if (zero? n) #f (even? (sub1 n))))
[06:48:38] <seebs> in the absence of, say, other math operators, this seems natural to him, and looping/iteration seems weird and unnatural
[06:48:48] <seebs> and that just seems very alien to me
[06:51:37] <seebs> i mean, admittedly, anything where you don't have the other operations available is gonna feel clunky to me no matter what
[06:56:43] *** Joins: mbuf (~Shakthi@110.225.224.158)
[07:37:20] *** Joins: DasBrain (DasBrain@user/dasbrain)
[07:41:01] *** Quits: DasBrain_ (~DasBrain@user/dasbrain) (Ping timeout: 240 seconds)
[07:42:56] *** Joins: Jing (~hedgehog@240e:390:7c53:a7e1:e8ea:b48d:a0c7:7ddc)
[08:28:06] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 276 seconds)
[08:34:47] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[08:34:49] *** Quits: Harlin (~DonQixote@75-163-202-34.clsp.qwest.net) (Quit: Leaving)
[09:00:56] *** Joins: Harlin (~DonQixote@75-163-202-34.clsp.qwest.net)
[09:20:22] *** Joins: puchka (~marius@165.73.241.19)
[09:37:27] *** Quits: Jing (~hedgehog@240e:390:7c53:a7e1:e8ea:b48d:a0c7:7ddc) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[10:01:01] *** Quits: shiranaihito (~textual@123-192-192-149.dynamic.kbronet.com.tw) (Quit: My MacBook Air has gone to sleep. ZZZzzz…)
[10:30:09] *** Joins: SR-71 (~user@user/SR-71)
[10:40:40] *** Joins: struchu (~struchu@staticline-31-183-182-64.toya.net.pl)
[10:59:38] <SR-71> I wonder what's it  like to work at a clojure startup.
[11:13:35] *** Quits: DasBrain (DasBrain@user/dasbrain) (Killed (NickServ (GHOST command used by DasBrain_)))
[11:13:43] *** Joins: DasBrain_ (DasBrain@user/dasbrain)
[11:20:08] <seebs> well whatever it's like, it'll be like that forever because it defaults to being immutable
[11:30:22] *** Quits: zak (~zak@144.172.69.61) (Quit: ZNC 1.8.2 - https://znc.in)
[11:49:08] *** Joins: szkl (uid110435@id-110435.uxbridge.irccloud.com)
[12:05:49] *** Joins: silasfox (~sbv@p200300cec71adb000b1561d576288968.dip0.t-ipconnect.de)
[12:07:07] *** Joins: zak (~zak@144.172.69.61)
[12:07:11] *** Joins: HDurer (~hdurer@104.134.21.20)
[12:17:01] *** Joins: schmudde (~schmudde@net-93-70-71-143.cust.vodafonedsl.it)
[12:21:38] *** Joins: tatsumaru (~tatsumaru@82.147.131.155)
[12:21:54] <tatsumaru> hey guys, is there any benefit of using emacs for clojure other than cider?
[12:22:24] *** Quits: AlaskanEmily (~AlaskanEm@user/alaskanemily) (Remote host closed the connection)
[12:22:33] <tatsumaru> i know emacs is endlessly customizable but does anyone actually customize it?
[12:23:08] *** Joins: lunik1 (~lunik1@37.205.14.203)
[12:29:04] <ridcully_> according to the last polls on the community emacs is the dominant editor
[12:29:16] *** Joins: MajorBiscuit (~MajorBisc@wlan-145-94-218-48.wlan.tudelft.nl)
[12:29:29] <ridcully_> whether it's the best for you, you have to decide yourself
[12:29:47] <ridcully_> it's not mandatory.  other editors/ides come next in the polls
[12:38:33] <v3ga> tatsumaru: all day long...
[12:39:32] <v3ga> its literally lisp...you even have a repl to make edits/changes on the fly. I'll never leave emacs lol
[12:41:41] <faxmodem> usually it's vi people never leave... because they don't know how to exit
[12:42:24] <v3ga> faxmodem: lol. if they would have ran vi in emacs like they were supposed to it would be simple
[12:45:03] *** Joins: dadinn (~dadinn@host86-134-44-43.range86-134.btcentralplus.com)
[12:45:47] <tatsumaru> faxmodem: I only recently figured out that you have to turn off your computer if you want to exit vim.
[12:50:48] <andreyorst> tatsumaru: I have a writeup about various text editors, maybe you'll find it interesting: https://andreyorst.gitlab.io/posts/2020-04-29-text-editors
[12:51:13] <tatsumaru> andreyorst: thanks I will check it out now
[12:51:14] *** Joins: shiranaihito (~textual@219.85.41.219)
[12:54:43] *** Quits: xsperry (~xs@user/xsperry) (Ping timeout: 250 seconds)
[12:55:37] <andreyorst> in short though, Emacs is the editor that wants you to make it your own thing, so you benefit if you take advantage of that. Its true to say that emacs of one person will not be the same as the Emacs of another. I'm using it mostly because I can bend it how I see fit, but that's not for everyone
[12:58:04] <andreyorst> e.g. I went from literate config that was mimicking Atom to almost barebones emacs config with no extra features, and then to something inbetween
[12:59:15] <tatsumaru> did you end up using vim keybindings or something like that
[12:59:17] <v3ga> same... funny enough i'd used emacs for several years but it wasn't until I truly started paying attention to clojure and common lisp that I realized I really can go to town with my emacs setup
[13:16:58] <andreyorst> tatsumaru: no, I use mostly stock Emacs keymap with some additional keys I've set for myself
[13:17:14] <andreyorst> I don't like Vim editing model all that much
[13:18:00] <andreyorst> of all things I'd prefer Kakoune editing model, but it's hard to replicate in Emacs correctly
[13:23:07] *** Quits: tatsumaru (~tatsumaru@82.147.131.155) (Quit: Leaving.)
[13:27:35] *** Quits: shiranaihito (~textual@219.85.41.219) (Quit: My MacBook Air has gone to sleep. ZZZzzz…)
[13:28:53] *** Joins: kipz (~kipz@home.kipz.org)
[13:30:55] *** Quits: kipper (~kipz@home.kipz.org) (Ping timeout: 256 seconds)
[13:34:32] *** Quits: Tolstoy (~textual@97-120-45-156.ptld.qwest.net) (Ping timeout: 240 seconds)
[13:34:53] *** Quits: schmudde (~schmudde@net-93-70-71-143.cust.vodafonedsl.it) (Quit: WeeChat 3.2)
[13:37:24] *** Joins: shiranaihito (~textual@2001-b011-4000-1d51-e860-e5ab-2b85-66cc.dynamic-ip6.hinet.net)
[13:41:31] *** Joins: Tolstoy (~textual@71-36-117-11.ptld.qwest.net)
[13:43:40] <v3ga> speaking of emacs how did I not know about vterm?!
[13:56:25] *** Quits: m5zs7k (aquares@web10.mydevil.net) (Ping timeout: 256 seconds)
[13:56:43] *** Joins: pingpongball (~pingpongb@43.228.192.104)
[13:56:49] <pingpongball> should i learn clojure?
[13:56:58] <pingpongball> instead of java
[13:57:28] *** Joins: m5zs7k (aquares@web10.mydevil.net)
[13:58:02] <pingpongball> like javafx, swing , does clojure have those?
[13:58:24] <pingpongball> tell me , why clojure was made in first case?
[13:59:27] <yeik-the-spik[m]> clojure has access to javafx and swing directly
[13:59:42] <yeik-the-spik[m]> you can call any java libraries directly
[13:59:57] <yeik-the-spik[m]> some people would claim something along the lines of painless interop
[14:00:21] *** Joins: dalek-caan (~Thunderbi@109.252.124.86)
[14:00:40] <yeik-the-spik[m]> not knowing java and having interop'ed on all my clojure projects, interop has been everything but painless to me
[14:01:13] <v3ga> if you have interest in lisp and a better angle for using javas infrastructure then sure
[14:02:01] <pingpongball> i dont know interest, interest comes when someone master it
[14:02:11] <pingpongball> i'm learning common lisp for now
[14:02:12] <v3ga> o_O
[14:03:37] *** Joins: samuelb (~samuelber@nata01.lip.pt)
[14:03:37] *** Joins: mgxm (~mgxm@user/mgxm)
[14:03:43] *** Joins: seabre_ (~seabre@user/seabre)
[14:03:52] <v3ga> CL is fine. I don't have a lot of experience in it but I've toyed with it a bit.  You can go in any direction. If you feel you need to be on the JVM then clojure. If not then CL is perfectly fine.  I found it easier to grasp clojure ...and had no prior java experience.
[14:04:30] <pingpongball> whoah, we dont need exprience on java any :)
[14:04:49] <pingpongball> does clojure use oop?
[14:04:54] <pingpongball> or any ?
[14:05:04] *** Joins: turlando_ (~turlando@93-42-250-112.ip89.fastwebnet.it)
[14:05:09] <yeik-the-spik[m]> you can do oop using java
[14:05:14] <yeik-the-spik[m]> its a bad idea tho
[14:05:16] <v3ga> its geared more towards functional but you can
[14:05:33] <v3ga> lol are you trolling? from =P 
[14:05:57] <pingpongball> where is best resource to learn clojure from?
[14:06:02] <pingpongball> book/....
[14:06:28] *** Joins: nuorzi_ (nuorzi@hilla.kapsi.fi)
[14:06:44] *** Joins: sudden (~cat@h-98-128-128-173.A351.priv.bahnhof.se)
[14:06:46] <yeik-the-spik[m]> https://iloveponies.github.io/120-hour-epic-sax-marathon/index.html
[14:07:02] <yeik-the-spik[m]> I liked that one, because I like exercises over books
[14:07:08] *** sudden is now known as Guest3567
[14:08:07] <v3ga> I really like The Clojure Workship for new people.  It didn't get as popular as many of the other books but they did a really good job to me.  Also Getting Clojure.  Then joy of clojure afterwards
[14:08:38] <pingpongball> if i learnt clojure, whats next?
[14:08:54] <yeik-the-spik[m]> hack the world
[14:09:15] <pingpongball> means
[14:09:19] <yeik-the-spik[m]> or develop a webpage for your neighbor
[14:09:32] <yeik-the-spik[m]> the posibilities are endless
[14:09:59] <v3ga> lol
[14:10:20] <pingpongball> whats so interesting in prefix based , rather than common ones like c,c++?
[14:10:37] <v3ga> you can create The Gibson... and someone else will try to hack that =P 
[14:10:38] <yeik-the-spik[m]> metaprogramming is easier
[14:10:40] *** Joins: TheCoffeMaker_ (~TheCoffeM@200.126.129.149)
[14:10:48] <yeik-the-spik[m]> you should not metaprogram tho
[14:11:02] *** Quits: Ingvix (~Ingvix@user/ingvix) (*.net *.split)
[14:11:02] *** Quits: turlando (~turlando@user/turlando) (*.net *.split)
[14:11:03] *** Quits: aphyr (~kyle@aphyr.com) (*.net *.split)
[14:11:03] *** Quits: Guest6340 (~cat@h-98-128-128-173.A351.priv.bahnhof.se) (*.net *.split)
[14:11:03] *** Quits: nuorzi (~nuorzi@hilla.kapsi.fi) (*.net *.split)
[14:11:03] *** Quits: TheCoffeMaker (~TheCoffeM@user/thecoffemaker) (*.net *.split)
[14:11:03] *** Quits: seabre (~seabre@user/seabre) (*.net *.split)
[14:11:03] *** Quits: samuelbernardo (~samuelber@nata01.lip.pt) (*.net *.split)
[14:11:03] *** Quits: mgxm_ (~mgxm@user/mgxm) (*.net *.split)
[14:11:03] *** Quits: justGhost (~justache@user/justache) (*.net *.split)
[14:11:03] *** Quits: cross_ (~cross@spitfire.i.gajendra.net) (*.net *.split)
[14:11:03] *** Quits: dustinm (~dustinm@static.38.6.217.95.clients.your-server.de) (*.net *.split)
[14:11:03] *** Quits: Para (~Para@95.216.176.167) (*.net *.split)
[14:11:03] *** Quits: TMA (~tma@twin.jikos.cz) (*.net *.split)
[14:11:03] *** Quits: materialfuture (~materialf@149.248.8.187) (*.net *.split)
[14:11:03] *** Quits: lobotomy (~lobotomy@static.213.19.216.95.clients.your-server.de) (*.net *.split)
[14:11:03] *** Quits: kawpuh (~kawpuh@66.42.81.80) (*.net *.split)
[14:11:03] *** Quits: flynn (~mcbloch@user/flynn) (*.net *.split)
[14:11:33] <yeik-the-spik[m]> dont dwell to much on prefix notation, its just notation
[14:12:14] <pingpongball> i heard most on lisp/elisp/commonlisp  and even in that book
[14:12:34] <pingpongball> Practical common lisp that i'm learning
[14:13:11] <yeik-the-spik[m]> v3ga: the gibson is a guitar, right?
[14:14:25] <pingpongball> told "oh i was using java for years and years, yet feels more productive and job done in common lisp rather than any other"(not same sentence, but saying like this) .
[14:14:47] <pingpongball> he told, oh i finished a project in a 29 days, where in java same project would take 5 6 months
[14:14:59] <pingpongball> how is that kind of sentences true?
[14:15:46] <yeik-the-spik[m]> when you write java, you have to write more code. so it takes longer.
[14:16:05] <yeik-the-spik[m]> Then some people are quite good at making claims bigger
[14:16:13] *** Joins: Ingvix (~Ingvix@user/ingvix)
[14:16:13] *** Joins: aphyr (~kyle@aphyr.com)
[14:16:13] *** Joins: justGhost (~justache@user/justache)
[14:16:13] *** Joins: cross_ (~cross@spitfire.i.gajendra.net)
[14:16:13] *** Joins: dustinm (~dustinm@static.38.6.217.95.clients.your-server.de)
[14:16:13] *** Joins: Para (~Para@95.216.176.167)
[14:16:13] *** Joins: TMA (~tma@twin.jikos.cz)
[14:16:13] *** Joins: materialfuture (~materialf@149.248.8.187)
[14:16:13] *** Joins: lobotomy (~lobotomy@static.213.19.216.95.clients.your-server.de)
[14:16:13] *** Joins: kawpuh (~kawpuh@66.42.81.80)
[14:16:13] *** Joins: flynn (~mcbloch@user/flynn)
[14:16:24] <pingpongball> like clojure is of java, is there similar kind to c++ alternative lisp dialect
[14:17:24] <yeik-the-spik[m]> I have made java codebases go to 1/3 lines of code when porting to clojure
[14:19:18] <yeik-the-spik[m]> pingpongball: Well, I do not know anything about compilers or how computers work. But Clojure is hosted on the JVM, so you can directly call any JVM code. As far as I've seen, you can call C from common lisp, but you need to use a FFI library to call. You do not call directly
[14:19:41] <yeik-the-spik[m]> But again, take my word with a grain of salt
[14:19:59] <pingpongball> ok
[14:21:27] <pingpongball> what is reason of spiking up or adopting professionally like (perl,ruby....) but while if lisp based are good ?
[14:24:08] <pingpongball> why most people didnt used lisp based langauges?
[14:24:48] <SR-71> They can't handle parenthesis.
[14:24:50] <SR-71> I guess.
[14:25:12] <yeik-the-spik[m]> Cause lisp languages are for "academic wankers." Or so I've been told by a senior architect I highly respect
[14:25:32] <SR-71> Reddit was written in lisp.
[14:26:00] <SR-71> Lisp lost popularity
[14:26:09] <SR-71> like a lot of other languages.
[14:26:14] <pingpongball> right `Lisp lost popularity` why?
[14:26:43] <SR-71> Err..lispmachines failed i guess.
[14:27:24] <pingpongball> do you think will it be back?
[14:27:38] <SR-71> I hope they make a comeback.
[14:27:46] <SR-71> It's really hard thou.
[14:28:04] <pingpongball> oh reincarnation?
[14:28:06] <sobel> another day, another datum
[14:28:45] <SR-71> Considering it's been decades, Intel and Arm has dominated the market.  
[14:28:47] <yeik-the-spik[m]> pingpongball: it's too far gone. And with stuff like microsoft copilot, most programming languages will die, specially these most obscure ones.
[14:28:55] <SR-71> It's hard for Symbolics to make a comeback
[14:29:52] <sobel> i had stronger opinions about what "should" be in hardware before i was more tuned in to the social aspect of hardware design
[14:30:21] <SR-71> VM's dominate the market...soooo
[14:30:29] <SR-71> IDK, what's the future.
[14:30:30] <pingpongball> you guys must know that nyxt browser
[14:30:35] <SR-71> yup
[14:30:41] <sobel> case in point: i was convinced that network gear makers were nuts not to adopt a bump-in-the-wire SSL proxy.
[14:31:21] <pingpongball> i heard , from its founder, while in interview, that he told,
[14:31:22] <pingpongball> "we'll use lisp from ground up, from all the way hardware level  to software like completely  in lisp based "
[14:31:30] <sobel> it could terminate a datacenter's worth of SSL in one box
[14:31:44] <SR-71> sobel: Then there is CUDA
[14:32:54] <sobel> things i forgot to factor into my evaluation: moore's law, the need to distribute SSL (e.g. border proxy was not the killer app), layer-crossing protocol changes such as SNI
[14:34:35] <sobel> all of which made the network gear vendors right to wait out better general-purpose performance and keep the security stack in software
[14:35:09] <sobel> even though i had spreadsheets documenting all the cash they were leaving on the table while they waited it out
[14:36:11] <sobel> SR-71: they convinced everyone they needed CUDA before the ubiquitous apps started popping up all over the place. wise of them.
[14:36:41] <SR-71> sobel: I hope OpenCl picks some pace.
[14:37:34] <sobel> i wish it were generally accepted that a NIC needs to incorporate a platform for packet manipulation just upstream of the network chip
[14:38:13] <sobel> SR-71: yeah, i'd like to see more portability in that area to
[14:38:14] <sobel> o
[14:38:47] <SR-71> sobel: Did you hear of ARM gpus?
[14:40:11] <SR-71>  /join #crypto
[14:40:19] <SR-71> what
[14:40:28] <SR-71> lol
[14:52:29] <sobel> i'm not that interested in crypto currency if that's what you mean
[14:52:51] <sobel> i'm aware of other GPUs but i'm so far from expert on any of them i just call them graphics cards :P
[14:54:16] <sobel> when it comes to GPUs, Steam is a platform i know
[15:01:11] *** Joins: Jing (~hedgehog@240e:390:7c53:a7e1:3c97:bf3a:3e4c:7eb2)
[15:07:34] *** Quits: struchu (~struchu@staticline-31-183-182-64.toya.net.pl) (Remote host closed the connection)
[15:07:53] *** Joins: struchu (~struchu@staticline-31-183-182-64.toya.net.pl)
[15:27:40] *** Joins: yauhsien (~Yau-Hsien@61-231-45-223.dynamic-ip.hinet.net)
[15:45:01] *** Quits: libertyprime (~libertypr@118-92-72-229.dsl.dyn.ihug.co.nz) (Ping timeout: 250 seconds)
[15:58:49] *** Quits: pingpongball (~pingpongb@43.228.192.104) (Quit: "bye :* ")
[16:23:50] *** Joins: mwnaylor (~user@2601:5ce:4300:5560::68b3)
[16:30:44] *** Quits: silasfox (~sbv@p200300cec71adb000b1561d576288968.dip0.t-ipconnect.de) (Quit: WeeChat 3.4)
[16:40:33] *** Joins: cmiles74 (~miles@068-184-030-013.res.spectrum.com)
[16:43:10] *** Quits: henry40408 (~henry4040@175.181.155.165) (Read error: Connection reset by peer)
[16:44:54] *** Joins: henry40408 (~henry4040@123-204-141-191.adsl.dynamic.seed.net.tw)
[17:40:58] *** Joins: xsperry (~xs@user/xsperry)
[18:11:59] *** Joins: silasfox (~sbv@p200300cec71adb000b1561d576288968.dip0.t-ipconnect.de)
[18:36:37] *** cross_ is now known as cross
[18:39:44] *** Joins: shiranaihito_ (~textual@123-192-192-149.dynamic.kbronet.com.tw)
[18:42:42] *** Quits: shiranaihito (~textual@2001-b011-4000-1d51-e860-e5ab-2b85-66cc.dynamic-ip6.hinet.net) (Ping timeout: 250 seconds)
[18:46:58] *** Quits: silasfox (~sbv@p200300cec71adb000b1561d576288968.dip0.t-ipconnect.de) (Quit: WeeChat 3.4)
[18:49:59] *** Quits: struchu (~struchu@staticline-31-183-182-64.toya.net.pl) (Quit: WeeChat 3.3)
[19:26:24] *** Quits: amk (~amk@109.255.169.126) (Remote host closed the connection)
[19:27:32] *** Joins: amk (~amk@109.255.169.126)
[19:46:50] *** Quits: uncleyear (~ian@pppoe.178-66-158-61.dynamic.avangarddsl.ru) (Remote host closed the connection)
[19:48:00] *** Joins: uncleyear (~ian@pppoe.178-66-158-61.dynamic.avangarddsl.ru)
[19:59:18] *** Joins: pingpongball (~pingpongb@43.228.192.121)
[20:00:57] <cyberbanjo> pingpongball: i used eric normands clojure videos and the clojurians slack to learn clojure
[20:09:34] <pingpongball> tutorial hell
[20:21:42] <cyberbanjo> worked fine for me, but i also met 1-on-1 who offered guidance.
[20:22:26] <cyberbanjo> imo the way out of tutorial hell is just more projects
[20:44:05] <seebs> my rough intuition is that anything linked-list-based is gonna be painful on modern architectures, just because it's not cache-friendly. on the other hand, a lot of code probably doesn't care.
[20:45:25] <technomancy> seebs: this is roughly true; most of the time it doesn't matter but when it does you use vectors which have a very intentionally cache-locality-friendly design. we also have chunked seqs to deal with that.
[20:46:25] <seebs> ooh, interesting. i gotta say, after years of having lispy people tell me that it's stupid to think about performance, a factor of ten doesn't matter, it's really refreshing to see someone say "that could matter and if it does here's the workaround"
[20:47:04] <technomancy> I mean, it has never mattered to me personally working in clojure since 2009, but I know one or two people who have cared about it. =)
[20:47:21] <technomancy> three if you count Rich
[20:47:51] *** Quits: SR-71 (~user@user/SR-71) (Remote host closed the connection)
[20:48:48] <seebs> idle curiousity, when people say macros can do things to a syntax tree, what's the scope of this? like... presumably the existing parser/tokenizer/something has to be able to read to the end of the macro to figure out what the macro *is*?
[20:49:01] <logiz> seebs: a lot of people don't care about python performance, and a lot of scheme/lisps are faster than python :P
[20:49:29] <seebs> so i'd expect you couldn't, say, make a macro which accepts whitespace-indented code instead of using close-parens. probably.
[20:49:38] *** Quits: pingpongball (~pingpongb@43.228.192.121) (Quit: Client closed)
[20:49:45] <technomancy> seebs: a macro is just a function that takes one form and returns another form. macros operate after the reader has turned text into lists.
[20:49:47] <seebs> i once did a performance comparison between python3 and go, and discovered that python3 was faster as long as you included the compile time for the go binary
[20:50:02] <seebs> hmm
[20:50:21] *** Joins: seschwar (~seschwar@user/seschwar)
[20:50:29] <ggb> seebs: re: macros Lisps separate reading and evaluation. The reader turns a stream of tokens (e.g. from a file or typed into the REPL) into Clojure data structures (e.g., lists, vectors, maps, sets, atomics)
[20:50:58] <ggb> The evaluator receives Clojure data structures and applies a set of evaluation rules to those data structures to do computation.
[20:51:52] <seebs> okay. so... hmm. could a macro do something like, say, take blocks of C-style braces code, like `if (condition) { do_things; }` and make that work, or would that break in the reader before it got that far?
[20:52:11] <ggb> One evaluation rule is "if the thing in the callable position is a macro, feed the rest of the expression to that macro to do anything it wants. Then, take the return value of that macro, and continue with evaluation rules."
[20:52:22] <technomancy> other lisps will let you access the underlying raw text but Clojure requires that everything be syntax-compliant first (which IMO is a great thing)
[20:52:26] <ridcully_> seebs: you can try that out.  wrap in `'()`
[20:53:12] <ridcully_> seebs: but the problem here is the `;` - its used for comments and it comes first
[20:53:49] <ggb> As mentioned ^^, Clojure requires data structures in Clojure syntax. That said, a string is a valid input, so your macro could include lexing, parsing, and compiling a string containing code in some other format and emitting Clojure forms.
[20:53:50] <seebs> hmm. and i assume newlines are invisible, so it'd be impossible to handle multi-line blocks of something C-like.
[20:53:51] <ridcully_> seebs: next problem after that is `{}` which is used as map literal
[20:53:54] <ggb> I don't know why you'd want to do that.
[20:53:55] <technomancy> if you want to get weird with macros you probably want racket, not clojure
[20:54:22] <seebs> i mean, the "why" would be mostly "pure spite" which has been a great motivation for me in doing things with compilers
[20:54:28] <ggb> Fair.
[20:54:44] <seebs> and yeah, racket is clearly much more aggressive about letting you rewrite the world
[20:54:46] <ggb> But yeah, macros allow arbitrary computation so long as their inputs are valid Clojure forms.
[20:55:32] *** Quits: mbuf (~Shakthi@110.225.224.158) (Quit: Leaving)
[20:55:45] <ggb> A macro *could* call out to a database or do other IO as part of its expansion.
[20:55:51] <technomancy> personally I appreciate it when I can look at the code and have a good guess at what it does based on my intuition of how the rest of the language works. clojure macros can break that, but racket macros can *really* break that.
[20:57:07] <ggb> For an example of significant whitespace in a Lisp, you could take a look at wisp in Scheme: https://srfi.schemers.org/srfi-119/
[20:57:29] <technomancy> you could certainly write a compiler that does that which emits clojure. it just wouldn't be a macro.
[20:57:29] <ridcully_> and that is not even totally uncommon in cljs - you can inline resources into your js code
[21:01:02] *** Quits: Jing (~hedgehog@240e:390:7c53:a7e1:3c97:bf3a:3e4c:7eb2) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[21:07:05] *** Quits: cmiles74 (~miles@068-184-030-013.res.spectrum.com) (Ping timeout: 252 seconds)
[21:24:19] *** Quits: MajorBiscuit (~MajorBisc@wlan-145-94-218-48.wlan.tudelft.nl) (Ping timeout: 256 seconds)
[21:25:09] *** Joins: piotrts (~piotrts@188.146.233.58.nat.umts.dynamic.t-mobile.pl)
[21:29:50] *** Joins: cmiles74 (~miles@068-184-030-013.res.spectrum.com)
[21:35:52] *** Quits: unyu (~pyon@user/pyon) (Quit: brb)
[21:37:25] *** Quits: piotrts (~piotrts@188.146.233.58.nat.umts.dynamic.t-mobile.pl) (Ping timeout: 240 seconds)
[21:37:41] *** Joins: unyu (~pyon@user/pyon)
[21:38:48] *** Quits: Harlin (~DonQixote@75-163-202-34.clsp.qwest.net) (Quit: Leaving)
[22:10:13] *** Quits: cmiles74 (~miles@068-184-030-013.res.spectrum.com) (Ping timeout: 256 seconds)
[22:25:37] *** Quits: puchka (~marius@165.73.241.19) (Quit: leaving)
[22:27:45] <hiredman> the core.async go macro is a macro that is a compiler that emits clojure
[22:29:57] <TimMc> Aren't all Clojure macros just compiler extensions that emit Clojure?
[22:32:08] <TimMc> Also, I think aphyr wrote a macro that takes (a subset of) "braces-style code" so it can be run.
[22:33:00] <ridcully_> well you could write a macro, that parses a string into code
[22:34:18] <TimMc> No, this was embedded in Clojure syntax.
[22:34:58] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Remote host closed the connection)
[22:35:14] <seebs> i feel like "aphyr did it" is not a compelling argument that it's possible
[22:35:17] *** Quits: unyu (~pyon@user/pyon) (Quit: WeeChat 3.4)
[22:35:19] <ridcully_> well if you keep pairs in your {} ;)
[22:35:22] <TimMc> https://aphyr.com/posts/353-rewriting-the-technical-interview
[22:35:23] <seebs> i have read those interview posts
[22:35:59] <seebs> oh interesting. that's clever; it's cheating, it doesn't actually use or need the semicolons at all, they just seem familiar
[22:37:16] <seebs> okay i stand by my position; "aphyr did it" is not really evidence that it's possible
[22:38:16] <TimMc> :-D
[22:38:57] <yauhsien> great interview note.
[22:42:00] <TimMc> It's so damn tempting to pull something like that during a real interview.
[22:42:02] <seebs> so, basically, as long as the C-like syntax happens to form things that are syntactically-valid clojure, it's possible to do it with a macroo
[22:42:05] <seebs> macro, even
[22:42:14] <seebs> but things like semicolons can't *really* work
[22:42:35] <seebs> but you can *pretend* they work if it happens that every semicolon always comes at the end of a line and doesn't actually need to be there for you to figure out what it meant
[22:43:22] <TimMc> It's a great example of the gulf between the set of programs that are possible and the set of programs that are a good idea.
[22:43:56] <seebs> if for some reason i ended up having to apply for jobs again, i think my pitch would start with "the go community slack server has a seebs-no emoji"
[22:44:13] <seebs> i figure anyone i will enjoy working with will regard this as a plus
[22:44:36] *** Quits: dalek-caan (~Thunderbi@109.252.124.86) (Quit: dalek-caan)
[22:44:58] <technomancy> like putting "blocked by paul graham on twitter" on your resume
[22:45:04] <technomancy> (a feat I have sadly yet to achieve)
[22:45:36] <ridcully_> and i bet you, there is some homoglpyh for a semicolon to cheat the erst
[22:45:40] <ridcully_> s/erst/rest/
[22:46:51] <sobel> that reminds me, i haven't trolled HN for months
[22:47:26] <seebs> my opinion of paul graham declined noticably when someone told me a story about him doing a thing when doing VC of putting candy and nuts on a table for meetings, and never investing in anyone who took candy, because that meant "low self-control"
[22:47:45] <sobel> on the one hand, it's sorta beneath me, but on the other hand, externalities are pretty good on this one
[22:48:19] <seebs> i have actually spent a lot of time thinking about his famous-ish argument that anything that you do in macros in lisp is impossible in other languages, but the more i think about it, the more i think some things people use macros for would be things that were *easy* in other languages but just happened to be hard in lisp.
[22:48:27] <sobel> oh geeze, that tired old discredited test? figures a VC would seize on it.
[22:48:44] <seebs> it's like ruby monkeypatching. you're encouraged to avoid it, but sometimes it's a great tool, and if you use it, presumably you couldn't do what you wanted without it... in ruby.
[22:49:05] <Para> I'm a hangry person and slightly allergic to nuts. I guess no VC billionz for me :(
[22:49:41] <sobel> i have my bit already calculated, for the first time anyone tries to tell me the nuts & candy story seriously
[22:49:49] <seebs> i'm hyperactive. it took me *years* to get my weight *up* to a reasonable level, although admittedly i've overshot
[22:50:11] <seebs> i just... what if they're diabetic and just realized that they were being significantly more active today than they expected when they calculated their insulin in the morning?
[22:50:12] <sobel> i can weave a short tale about deez nutz that they will *eventually* be disappointed about
[22:50:19] <seebs> ooh that is also good
[22:50:20] <technomancy> sobel: blavo
[22:50:22] <technomancy> *bravo
[22:50:36] <seebs> if it's a sysadmin role you can even talk about the whole BOFH/BOFA distinction
[22:50:38] <ridcully_> there you have your troll: bring some too and throw it in the candy jar
[22:51:00] <ridcully_> a banana or some lug nuts
[22:51:01] <technomancy> seebs: the story where 25% of his codebase was macros and he's like ... bragging about it or something, experienced lispers hear that number and are goddamn terrified
[22:51:08] <sobel> bring *better* nuts. offer the VC some roasted brazil and chestnuts.
[22:51:11] <sobel> macadamias
[22:51:47] <TimMc> There are so many things wrong with that test, oh jeez.
[22:51:59] <Para> And if you get accused, you can jump on the table and yell "Gotcha! Macadamias aren't actually nuts!"
[22:52:01] <TimMc> Starting with "hey, maybe it's polite to take some food your host offers".
[22:52:17] <sobel> Para: god i'd be so busted but i would take that risk with glee
[22:52:22] <ridcully_> Para: "but i am! MUAHAHA"
[22:52:30] <technomancy> TimMc: VCs don't really acknowledge the existence of other cultures afaict
[22:52:38] <seebs> so when i read that i didn't know what macros were, and now i sort of know what they are and i'm significantly more afraid of that
[22:52:58] <sobel> "legYUUUME," you shout, as you draw your saber
[22:53:27] <Para> I want to be in this VC pitch. Just as an audience.
[22:53:44] <Para> Performed in front of live audience.
[22:53:48] <sobel> i have you cast as the stoic VC
[22:55:54] <seebs> speaking of "i want to be in this situation it would be hilarious", i am super bummed, because a ton of my coworkers got stupid phishing attempts pretending to be our boss
[22:55:56] <seebs> and *i* didn't
[22:55:59] <TimMc> I don't understand. Would not the strongest candidate simply take the entire contents of the bowl for later consumption?
[22:56:16] <sobel> ...by force
[22:56:28] <seebs> if it's a marketing role, you want someone who offers *you* the bowl and somehow makes you feel like they're being very generous to do so
[22:56:41] <TimMc> hahaha
[22:56:50] <sobel> wold*star move
[22:56:55] <TimMc> Now *that* would show chutzpah.
[22:57:01] <Para> Sell me this pen^H^H^Hbowl of nuts.
[22:57:05] <ridcully_> seebs: s/offers/sells/  ftfy
[22:57:13] <sobel> i went to high school with that guy
[22:57:53] <sobel> i figured he was going into sales when we were first friends, but on the way out i changed my estimate to disorganized crime / petty fraud
[22:58:40] <sobel> what a difference patience makes
[22:59:14] *** Joins: unyu (~pyon@user/pyon)
[23:08:10] <seebs> > The Church. The lambda calculus. The gay agenda. It has known a thousand names, a thousand forms.
[23:28:53] *** Joins: cmiles74 (~miles@068-184-030-013.res.spectrum.com)
[23:32:23] *** Quits: wht (~wht@havoc.proulx.com) (Ping timeout: 256 seconds)
[23:33:42] *** Joins: Ilyu (~quassel@166.215.82.79.rev.sfr.net)
[23:43:53] *** Joins: blei (~blei@209.201.38.106)
[23:48:37] *** Quits: Tolstoy (~textual@71-36-117-11.ptld.qwest.net) (Quit: Textual IRC Client: www.textualapp.com)
[23:49:21] *** Joins: wht (~wht@havoc.proulx.com)
[23:52:33] *** Quits: kipz (~kipz@home.kipz.org) (Ping timeout: 256 seconds)
[23:53:11] *** Joins: kipz (~kipz@home.kipz.org)
[23:57:12] *** Joins: kipper (~kipz@home.kipz.org)
[23:58:37] *** Quits: kipz (~kipz@home.kipz.org) (Ping timeout: 240 seconds)
