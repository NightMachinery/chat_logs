[00:17:17] *** Joins: rawley (~rawley@142.99.241.242)
[00:30:11] *** Quits: austb (~austb@c-73-240-245-80.hsd1.or.comcast.net) (Ping timeout: 252 seconds)
[00:57:13] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[01:01:51] *** Joins: AlaskanEmily (~AlaskanEm@user/alaskanemily)
[01:32:22] *** Quits: shiranaihito_ (~textual@123.192.192.149) (Quit: My MacBook Air has gone to sleep. ZZZzzz…)
[01:39:48] *** Quits: ahungry (~user@c-68-51-134-46.hsd1.mi.comcast.net) (Ping timeout: 240 seconds)
[01:44:50] *** Quits: rawley (~rawley@142.99.241.242) (Remote host closed the connection)
[01:48:31] *** Quits: Techcable (~Techcable@user/Techcable) (Remote host closed the connection)
[01:48:39] *** Joins: Techcable (~Techcable@user/Techcable)
[01:59:57] *** Quits: kreved (~user@user/kreved) (Ping timeout: 240 seconds)
[02:05:33] *** Quits: schmudde (~schmudde@75-172-40-164.tukw.qwest.net) (Ping timeout: 256 seconds)
[02:12:35] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 240 seconds)
[02:19:46] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[02:25:20] *** Quits: uncleyear (~ian@178.176.79.141) (Remote host closed the connection)
[02:26:28] *** Joins: uncleyear (~ian@178.176.79.141)
[02:39:45] *** Joins: seabass (~seabass@user/seabass)
[02:39:50] *** Quits: seabass (~seabass@user/seabass) (Client Quit)
[03:06:18] *** Joins: austb (~austb@c-73-240-245-80.hsd1.or.comcast.net)
[03:17:32] *** Quits: uncleyear (~ian@178.176.79.141) (Ping timeout: 272 seconds)
[03:27:31] *** Quits: seschwar (~seschwar@user/seschwar) (Quit: :wq)
[03:40:36] *** Quits: yason (yason@kapsi.fi) (Ping timeout: 240 seconds)
[03:42:42] *** Joins: yason (yason@kapsi.fi)
[04:24:02] *** Quits: austb (~austb@c-73-240-245-80.hsd1.or.comcast.net) (Ping timeout: 272 seconds)
[04:41:58] *** Joins: szkl (uid110435@id-110435.uxbridge.irccloud.com)
[04:59:27] *** Joins: austb (~austb@94.140.8.4)
[05:22:50] *** Joins: Intelo (~Intelo@user/Intelo)
[05:26:03] <Intelo> Am I heard a lot about macros, meta programing etc of clojure/lsip. Is that the real power by which one person can do a lot more as compare to teams/groups doing the same in other languages? or is there anything else about clojure that makes it do so more in so less liines?
[05:28:25] *** Quits: pflanze (~pflanze@61-41-178-139.dyn.fiber.qlnet.ch) (Quit: Leaving)
[05:30:43] <technomancy[m]> macros don't contribute very much towards concision compared to just being data-oriented
[05:34:33] <seebs> i currently strongly suspect that most of the stuff about how incredibly powerful and central macros are consists largely of Paul Graham being sort of a twit
[05:44:11] <Intelo> technomancy[m] seebs ok so what is/are the clojure's super powers the people praise so much?
[05:48:25] <technomancy[m]> Intelo: must just be that mainstream languages tend to be pretty bad overall I guess 
[05:50:14] <technomancy[m]> more seriously: using immutable data structures directly instead of classes and methods everywhere, higher order functions, destructuring, and the ability to call maps and keywords like functions
[05:50:43] <technomancy[m]> also concision and power are only loosely related 
[05:51:11] <Intelo> ok.. that makes sense
[05:57:19] <seebs> i am the wrong person to ask i've been using it very lightly for a couple of weeks
[05:57:41] <seebs> speaking of not knowing clojure, is there an idiomatic way to check whether a string is empty that doesn't also return true for strings of all whitespace?
[06:00:56] <technomancy> seebs: `empty?` should do it
[06:01:04] <technomancy> Intelo: also it depends on what you're comparing it against
[06:01:22] <technomancy> Intelo: the reasons for clojure being more concise than lua are very different from why it's more concise than java or racket
[06:08:30] <seebs> okay i'm not happy with this approach but i'm not miserable about it
[06:08:47] <seebs> what i'm trying to do: trivial state machine parser to handle possibly-quoted text and break it into words
[06:09:06] <seebs> > (loop [input input current nil words [] quoting false backslash false]
[06:09:35] <seebs> and the rest sort of follows from that (there's an "(if backslash..." and an "(if quoting..." coming up).
[06:09:44] <seebs> and this works fine but i'm not super pleased with the complexity.
[06:10:15] <seebs> in a language with more mutable things i'd just have a straightforward loop-on-characters and local variables or states or something.
[06:12:18] <seebs> https://gist.github.com/seebs/ecfe63f5ea7e66ed3ec174998ce00a91
[06:12:38] <seebs> i don't like how much this has to repeat parameters to recur when i actually don't want to change them.
[06:13:13] <Intelo> seebs technomancy[m] what should be the learning source? i am more of a video guy who learns from videos more. So which learning platforms you suggest?
[06:13:54] <seebs> i have no idea, i can't understand videos at all
[06:14:15] <seebs> historically, the best way for me to learn a language has been to get a large hunk of code in it and try to debug it, or just start writing something and hope for the best
[06:17:33] <seebs> (this parser actually has a moderately glaring bug, which is that it doesn't notice or care about unfinished quotes. yet.)
[06:19:03] <seebs> the thing with \space, \tab, and \newline rather than just having \ work normally on whitespace really feels like cowardice to me. :)
[06:23:11] *** Joins: pflanze (~pflanze@61-41-178-139.dyn.fiber.qlnet.ch)
[06:25:03] <Intelo> ok
[06:26:12] <technomancy[m]> I wrote the first Clojure video course ever but by now it's pretty out of date (the pluralsight one)
[06:26:38] <technomancy[m]> I don't really keep up enough to have good recommendations that are up to date
[06:26:39] <Intelo> technomancy can you link?
[06:27:53] <technomancy[m]> sure https://www.pluralsight.com/courses/functional-programming-clojure
[06:29:07] <Intelo> technomancy[m] you are the author of this course?
[06:29:22] <technomancy[m]> yeah
[06:29:26] <technomancy[m]> it's from 2009
[06:29:49] <Intelo> You are Rich Hickey?
[06:30:09] <technomancy[m]> no
[06:30:29] <technomancy[m]> he helped with the script 
[06:31:28] <Intelo> technomancy[m] so you are Phill?
[06:31:57] <technomancy[m]> ye
[06:32:06] <technomancy[m]> s
[06:32:20] <Intelo> Oh.. its an honor!
[06:34:05] <seebs> i was going to guess you were the "and"
[06:34:42] <Intelo> technomancy[m] so which source do you suggest to learn clojure?
[06:34:47] <seebs> woot, my NBT editor is now far enough that i can start it in interactive mode, enter "ls", and get a list of the top level.
[06:48:15] <technomancy[m]> Intelo: Chas Emerick's book on Clojure is good
[06:49:21] <Intelo> thanks
[06:56:49] *** Quits: Intelo (~Intelo@user/Intelo) (Ping timeout: 256 seconds)
[07:27:14] *** Joins: xulfer (uid452788@id-452788.ilkley.irccloud.com)
[07:34:37] *** Quits: silasfox (~sbv@p200300cec717230004f2e58485b580c9.dip0.t-ipconnect.de) (Ping timeout: 240 seconds)
[07:36:30] *** Joins: silasfox (~sbv@p200300cec74817009bc16da18a2343ec.dip0.t-ipconnect.de)
[08:12:02] *** Quits: austb (~austb@94.140.8.4) (Ping timeout: 272 seconds)
[08:18:17] *** Joins: schmudde (~schmudde@75-172-40-164.tukw.qwest.net)
[08:37:51] *** Joins: ltriant_ (~ltriant@194-223-10-27.tpgi.com.au)
[08:39:06] *** Joins: austb (~austb@212.102.46.27)
[08:39:24] *** Quits: ltriant (~ltriant@ec2-13-211-134-196.ap-southeast-2.compute.amazonaws.com) (Ping timeout: 240 seconds)
[09:49:19] <Para> seebs: clojure.string/blank?
[09:49:42] <seebs> i wanted not-that, in that i wanted to check for "is empty" rather than "is empty or blank". empty? seems to work, i guess?
[09:50:23] <seebs> and now i have a thing which successfully splits things up on spaces, but allows quoted strings and backslashes.
[09:50:35] <seebs> haven't properly tested it on a broad variety of inputs but it seems to work for easy cases
[09:50:56] <seebs> feels sorta messy though.
[09:51:22] <Para> Isolate the messiness behind a function.
[09:51:42] <Para> And then for bonus points if its on github, create an issue about it to your own repo and tag it as "good for beginners" :D
[09:51:58] <Para> or whatever that tag was
[09:52:42] *** Quits: zmt00 (~zmt00@user/zmt00) (Quit: Leaving)
[09:53:59] <seebs> it's sort of already behind a function, and it's a loop, so if i try to split out sub-functions, i have worse problems, i think. hmm.
[09:54:24] <seebs> maybe not, though, i might be able to push the "handle quoted strings" part out, because the behavior upon finding a quoted string is consistent.
[09:55:17] *** Joins: zmt00 (~zmt00@user/zmt00)
[09:58:16] *** Joins: mbuf (~Shakthi@171.61.236.231)
[10:10:14] *** Quits: schmudde (~schmudde@75-172-40-164.tukw.qwest.net) (Quit: WeeChat 3.2)
[11:08:25] *** Quits: ltriant_ (~ltriant@194-223-10-27.tpgi.com.au) (Ping timeout: 256 seconds)
[11:31:21] *** Joins: uncleyear (~ian@178.176.79.141)
[11:41:17] *** Quits: Tolstoy (~textual@75-164-154-61.ptld.qwest.net) (Quit: My iMac has gone to sleep. ZZZzzz…)
[11:49:41] *** Joins: ltriant (~ltriant@194-223-10-27.tpgi.com.au)
[11:54:42] *** Joins: shiranaihito (~textual@219.85.1.85)
[12:26:45] *** Quits: szkl (uid110435@id-110435.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[12:35:20] *** Quits: shiranaihito (~textual@219.85.1.85) (Quit: My MacBook Air has gone to sleep. ZZZzzz…)
[12:53:29] *** Joins: shiranaihito (~textual@219.85.41.174)
[13:12:44] *** Quits: AlaskanEmily (~AlaskanEm@user/alaskanemily) (Remote host closed the connection)
[13:30:06] *** Quits: ifs[m] (~ifsmatrix@2001:470:69fc:105::1:7342) (Quit: You have been kicked for being idle)
[13:30:06] *** Quits: aesth[m] (~aesthmatr@2001:470:69fc:105::1:57c1) (Quit: You have been kicked for being idle)
[14:02:18] *** Joins: seschwar (~seschwar@user/seschwar)
[14:04:39] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4.1)
[14:08:18] *** Quits: seschwar (~seschwar@user/seschwar) (Quit: :wq)
[14:08:39] *** Joins: seschwar (~seschwar@user/seschwar)
[14:12:13] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[14:25:11] *** Quits: seschwar (~seschwar@user/seschwar) (Quit: :wq)
[14:25:29] *** Joins: seschwar (~seschwar@user/seschwar)
[14:27:39] *** Quits: seschwar (~seschwar@user/seschwar) (Client Quit)
[14:30:31] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Remote host closed the connection)
[14:30:50] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[14:49:28] *** Joins: seschwar (~seschwar@user/seschwar)
[14:54:45] *** Quits: seschwar (~seschwar@user/seschwar) (Quit: :wq)
[14:55:02] *** Quits: shiranaihito (~textual@219.85.41.174) (Quit: My MacBook Air has gone to sleep. ZZZzzz…)
[14:55:04] *** Joins: seschwar (~seschwar@user/seschwar)
[14:57:43] *** Quits: ltriant (~ltriant@194-223-10-27.tpgi.com.au) (Ping timeout: 260 seconds)
[15:18:22] *** Quits: seschwar (~seschwar@user/seschwar) (Quit: :wq)
[15:20:08] *** Joins: seschwar (~seschwar@user/seschwar)
[15:22:55] *** Joins: ProfSimm (~ProfSimm@87.227.196.109)
[15:23:23] <ProfSimm> does Clojure use s-expr internally or something more pragmatic like arrays of arbitrary length (not 2)
[15:24:34] *** Quits: seschwar (~seschwar@user/seschwar) (Client Quit)
[15:24:55] *** Joins: seschwar (~seschwar@user/seschwar)
[15:27:33] <opqdonut> the clojure vector and map data structures are nicely optimized, but I don't actually know what the lists are at runtime. they might just be linked lists.
[15:30:31] <opqdonut> yeah looks like reading a list gives you a clojure.lang.PersistentList, which is just a singly-linked list
[15:30:35] <opqdonut> https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/PersistentList.java
[15:30:48] <opqdonut> private final Object _first; private final IPersistentList _rest;
[15:31:52] <opqdonut> of course many things that look like lists when you print them are actually some other type that implements ISeq
[15:32:11] <opqdonut> (seq (into-array [1 2 3 4])) prints out as (1 2 3 4)
[15:32:31] <opqdonut> but it's actually a clojure.lang.ArraySeq that just wraps the array
[15:33:20] <opqdonut> it's pretty easy to explore these yourself by just defining clojure values, calling (class ...) on them, and then looking up the (java) source code on github
[15:34:40] <opqdonut> one thing worth exploring is the fact that small maps, like {:a 1 :b 2 :c 3}, are clojure.lang.PersistentArrayMap, whereas larger maps are clojure.lang.PersistentHashMap
[15:35:50] <opqdonut> vectors are even more subtle, I looked into their memory use at some point: https://gist.github.com/opqdonut/b74b7483bd7304f0d0648561efdcb253
[15:35:53] *** Quits: mbuf (~Shakthi@171.61.236.231) (Ping timeout: 256 seconds)
[15:37:15] *** Quits: seschwar (~seschwar@user/seschwar) (Remote host closed the connection)
[15:38:02] *** Joins: seschwar (~seschwar@user/seschwar)
[15:38:27] *** Quits: seschwar (~seschwar@user/seschwar) (Client Quit)
[15:40:20] *** Joins: ltriant (~ltriant@194-223-10-27.tpgi.com.au)
[15:44:01] *** Joins: seschwar (~seschwar@user/seschwar)
[16:11:52] *** Joins: kreved (~user@user/kreved)
[16:20:12] *** Joins: mbuf (~Shakthi@110.225.247.221)
[16:22:25] *** Quits: mbuf (~Shakthi@110.225.247.221) (Remote host closed the connection)
[17:05:07] *** Quits: kreved (~user@user/kreved) (Ping timeout: 260 seconds)
[17:38:18] *** Joins: shiranaihito (~textual@125-228-188-231.hinet-ip.hinet.net)
[17:47:52] *** Joins: shiranaihito_ (~textual@123-192-192-149.dynamic.kbronet.com.tw)
[17:49:17] *** Quits: shiranaihito (~textual@125-228-188-231.hinet-ip.hinet.net) (Ping timeout: 240 seconds)
[18:02:40] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Remote host closed the connection)
[18:02:55] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[18:11:31] *** Joins: mwnaylor (~user@2601:5ce:4300:5560::68b3)
[18:29:46] *** Joins: seabass_ (~seabassfo@2001:470:69fc:105::187)
[19:13:59] *** Joins: zmt01 (~zmt00@user/zmt00)
[19:14:36] *** Quits: zmt00 (~zmt00@user/zmt00) (Ping timeout: 240 seconds)
[19:21:24] *** Quits: silasfox (~sbv@p200300cec74817009bc16da18a2343ec.dip0.t-ipconnect.de) (Ping timeout: 240 seconds)
[19:22:14] *** Joins: Yaser_Amiri (~yaser@5.208.190.100)
[19:24:49] <Yaser_Amiri> Hi, I have a question about swapping atoms. I have atom which contains a hash map, I want to have this constraint on it: when the first thread managed to set a key, other threads must not be able to set another value.
[19:25:01] <Yaser_Amiri> for this purpus is this code correct?
[19:25:07] <Yaser_Amiri> https://paste.opensuse.org/9762788
[19:26:19] <Yaser_Amiri> I have some doubts about "change" function, I'm not sure that if it runs atomic or not.
[19:26:19] <Para> That's not an atom, really, I'd recommend `promise` instead https://clojuredocs.org/clojure.core/promise
[19:26:44] <Para> Promises can be delivered only once.
[19:27:13] <opqdonut> Yaser_Amiri: any time you do something like @atom ... logic ... swap! you have a potential race condition
[19:27:33] <opqdonut> Yaser_Amiri: try to design your thing so that you can just call (swap! atom f arg1 arg2)
[19:28:18] <opqdonut> Yaser_Amiri: oh right it looks like your change function is the right thing, I guess the when inside transact is just an optimisation?
[19:28:41] <Yaser_Amiri> Para: Yes, but then I have to create a promise per key, because I don't have list of all keys.
[19:28:44] <opqdonut> after all, (defn transact [key value] (swap! state change key value)) would have the same behaviour
[19:29:28] <Para> Yaser_Amiri: That doesn't sound like an issue to me :) Create a two-line helper function for value (un)wrapping.
[19:29:57] <opqdonut> they're different designs
[19:30:03] <Yaser_Amiri> @opqdonut: yes, it's just an optimization.
[19:30:08] <opqdonut> the promise thing works for e.g. memoizing a function over a fixed set of keys
[19:30:32] <opqdonut> this atom thing works for something like a url shortener, where you want every key to be settable exactly once
[19:30:53] <Yaser_Amiri> opqdonut: exactly!
[19:30:58] <opqdonut> but you don't know the full key set (it's infinite or too large), and you don't compute the value, so it can't be a promise
[19:31:54] <opqdonut> Yaser_Amiri: one thing to note is that your change function allows overriding a nil value. you need to use contains? to avoid that
[19:31:57] <opqdonut> but it might not be a problem for you
[19:32:39] <Yaser_Amiri> no it's not a problem for my case. Thanks by the way!
[19:33:02] <opqdonut> also note that swap! returns the new value, so you could make transact return the value of the key, or a boolean that tells the caller whether the assoc happened
[19:33:24] <opqdonut> now transact incidentally returns the whole map
[19:35:46] <Yaser_Amiri> opqdonut: yes he return value of transact is creepy. I haven't thought about that, I was tring to make sure about the atomic thing.
[19:36:10] *** Joins: Xylon (~joseph@mail.xylon.me.uk)
[19:43:00] *** Quits: lunik1 (~lunik1@37.205.14.203) (Ping timeout: 240 seconds)
[19:44:11] <ridcully_> random nitpick: contains? will check if the key is there - nil? check there makes nil values impossible
[19:47:50] *** Joins: lunik1 (~lunik1@37.205.14.203)
[20:01:09] *** Joins: rawley (~rawley@216-197-141-102.nbfr.hsdb.sasknet.sk.ca)
[20:01:57] *** Joins: matts_ (uid548166@id-548166.helmsley.irccloud.com)
[20:02:15] <rawley> Relatively new to clojure, how can I map a list of lists to a new list of lists, keeping only the first 4 values of each original list? If that makes sense.
[20:02:47] <rawley> I tried (map (take 4) old_list))
[20:02:51] *** Quits: mwnaylor (~user@2601:5ce:4300:5560::68b3) (Read error: Connection reset by peer)
[20:04:18] <Para> It should be #(take 4 %), if I understood correctly.
[20:04:29] *** Joins: mwnaylor (~user@2601:5ce:4300:5560::68b3)
[20:04:53] <rawley> perfect, thank you! Can you explain the #?
[20:04:56] <Para> `(take 4)` returns a transducer which hs a whole another thing.
[20:05:01] <Para> #() is anonymous function
[20:05:10] <rawley> Excellent, thanks!
[20:05:28] <Para> So `#(take 4 %)` same as `(fn [x] (take 4 x))`
[20:05:44] <rawley> Yeah, like a lambda almost right?
[20:06:45] <Para> Hm, I guess so :)
[20:07:11] <Para> Although it's not maybe completely accurate.
[20:08:07] <rawley> I will keep that #() in mind though, seems like it will come in handy often
[20:09:03] <Para> In Clojure there's about a dozen special forms, all starting with #. https://clojure.org/reference/reader#_dispatch
[20:09:49] <rawley> I was aware of sets, and regex but the others ill read up on. Thanks again.
[20:11:17] *** Quits: ToxicFrog (~ToxicFrog@198-200-100-178.cpe.distributel.net) (Ping timeout: 256 seconds)
[20:31:35] <lunik1> be aware there are some cases where you need (fn [] (...)) over #(), for example #() cannot be nested
[20:34:36] <ridcully_> if you want to have more of the curry flair, you can use (partial take 4)
[20:54:57] *** Joins: ToxicFrog (~ToxicFrog@198-200-100-178.cpe.distributel.net)
[20:57:52] <rawley> Is there a nice way to convert the types of every value in a 2d array?
[20:58:13] <rawley> Currently I have a 2d array of strings, that needs to be numerics
[20:58:34] *** Joins: austb_ (~austb@c-73-240-245-80.hsd1.or.comcast.net)
[20:58:53] *** Quits: austb (~austb@212.102.46.27) (Ping timeout: 256 seconds)
[21:00:55] <rawley> I know I can do (bigdec value) to convert to a numeric value, just not exactly sure how to apply that to a list within a list
[21:02:07] <ridcully_> map/mapv is what you want.  or specter if you are willing to add a library
[21:10:44] <Para> So, what's the neatest trick to flip argument order in the middle of threading for just one step?
[21:15:02] <leah2> (#(foo %2 %1))
[21:15:28] <leah2> or (->> foo) i think?
[21:18:18] <leah2> works for ->> in -> but not reverse, hrm
[21:18:19] <Para> Ah, I mean imagine having a ->> where all functions work as expected but because of eg. interop one function call in the middle wants the threaded value as first arg
[21:18:59] <leah2> yeah then my %2 %1...
[21:19:13] <leah2> obviously we need to define a <- :)
[21:20:05] <Para> The "nudge" operator.
[21:20:50] <ridcully_> write a flip function.  or use as-> ?
[21:21:02] <leah2> i think as-> is best
[21:22:20] <leah2> (->> 2 (#(/ % 3)))
[21:38:30] *** Joins: AlaskanEmily (~AlaskanEm@user/alaskanemily)
[22:07:14] *** Quits: rawley (~rawley@216-197-141-102.nbfr.hsdb.sasknet.sk.ca) (Remote host closed the connection)
[22:07:36] *** Joins: rawley (~rawley@216-197-141-102.nbfr.hsdb.sasknet.sk.ca)
[22:13:07] *** Quits: austb_ (~austb@c-73-240-245-80.hsd1.or.comcast.net) (Ping timeout: 260 seconds)
[22:34:57] *** Quits: rawley (~rawley@216-197-141-102.nbfr.hsdb.sasknet.sk.ca) (Ping timeout: 240 seconds)
[23:11:52] *** Quits: ProfSimm (~ProfSimm@87.227.196.109) (Remote host closed the connection)
[23:12:12] *** Joins: ProfSimm (~ProfSimm@87.227.196.109)
[23:12:27] *** Joins: kreved (~user@user/kreved)
[23:12:47] *** Joins: rawley (~rawley@216-197-141-102.nbfr.hsdb.sasknet.sk.ca)
[23:19:24] *** Quits: rawley (~rawley@216-197-141-102.nbfr.hsdb.sasknet.sk.ca) (Ping timeout: 260 seconds)
[23:22:55] *** Quits: justOkay (~justache@user/justache) (Read error: Connection reset by peer)
[23:24:33] *** Joins: justOkay (~justache@user/justache)
[23:29:46] *** Quits: Yaser_Amiri (~yaser@5.208.190.100) (Remote host closed the connection)
[23:35:10] *** Quits: euandreh (~euandreh@2804:14c:33:9fe5:4042:4584:26e0:bc36) (Quit: WeeChat 3.4.1)
[23:37:35] *** Quits: kreved (~user@user/kreved) (Ping timeout: 260 seconds)
[23:37:48] *** Joins: Yaser_Amiri (~Thunderbi@5.208.190.100)
[23:39:02] *** Joins: euandreh (~euandreh@2804:14c:33:9fe5:a3d9:5253:a1a8:660f)
[23:41:01] *** Quits: Yaser_Amiri (~Thunderbi@5.208.190.100) (Client Quit)
[23:41:23] *** Joins: Yaser_Amiri (~Thunderbi@5.208.190.100)
[23:42:18] *** Quits: Yaser_Amiri (~Thunderbi@5.208.190.100) (Client Quit)
[23:42:59] *** Joins: Yaser_Amiri (~Thunderbi@5.208.190.100)
[23:45:02] *** Quits: jespada (~jespada@cpc121022-nmal24-2-0-cust171.19-2.cable.virginm.net) (Ping timeout: 240 seconds)
[23:46:23] *** Quits: Yaser_Amiri (~Thunderbi@5.208.190.100) (Client Quit)
[23:47:51] *** Joins: jespada (~jespada@cpc121022-nmal24-2-0-cust171.19-2.cable.virginm.net)
