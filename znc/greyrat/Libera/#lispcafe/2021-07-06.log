[00:02:54] <selwyn> what is ncurses like
[00:06:35] <gilberth> CLISP?
[00:14:18] <shka> selwyn: ncurses? it is pretty good for what is worth
[00:15:08] <shka> i found the go programming music https://www.youtube.com/watch?v=iulBHRi99HA
[00:15:09] -ixelp- Alex Gopher - Est-Ce Une Gopher Party, Baby? - YouTube
[00:17:04] * shka just create keyboard macro for launching eshell
[00:17:16] <shka> escape space a t s e
[00:17:28] <shka> what the fuck spacemacs?
[00:19:20] <gilberth> You don't find just-one-space useful?
[00:21:55] <gilberth> Has anyone experience in removing keycaps of an Macbook keyboard?
[00:22:00] <selwyn> shka: vibes
[00:22:57] <shka> gilberth: one with the butterfly switches?
[00:24:42] <shka> they really tried to make it more dirt resistant, but in the end it just made it more annoying to service
[00:29:14] <gilberth> I don't know if that are butterfly switches, it's a late 2015 Macbook Pro. And they may be dirt resistant, but certainly not beverages-resistant.
[00:29:56] <gilberth> I hestitate a bit to give it a try as this is the only machine, I have here.
[00:31:17] <shka> gilberth: 12 inch model?
[00:31:33] <gilberth> 15"
[00:32:16] <shka> i think that this may have old fashion scissor switches
[00:32:19] <gilberth> The meta key feels a bit aehm numb.
[00:33:22] <gilberth> It has tactile feedback anymore, this drives me crazy. However I am lucky, that the coffee didn't fry the whole machine, as I once managed with red wine, on vacation.
[00:33:38] <gilberth> * It has NO feedback
[00:34:41] <gilberth> Hence I guess, I would need to clean the tiny tight gap around the key towards the case.
[00:42:07] <shka> i actually like linear modifier keys
[00:47:03] <gilberth> I cannot type with linear keys at all. But as me living here seems to be pretty permanent, I should get a real desk and move one of my Mac Minis and one of the 27" screens here. This laptop does start to feel a bit tiny anyway. And I need some of my books.
[00:48:51] <shka> yeah, typing is a problem
[00:48:58] <shka> but you don't type with the meta key
[00:49:21] <shka> anyway, good night
[00:49:47] <selwyn> goodnight
[00:49:52] <gilberth> Take care!
[00:53:46] *** Quits: shka (~herr@109.231.62.239) (Ping timeout: 240 seconds)
[00:57:41] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[01:11:02] *** Joins: dave0 (~davezero@069.d.003.ncl.iprimus.net.au)
[01:11:25] <dave0> maw
[01:11:42] *** Joins: cons (~example@user/aeth/bot/cond)
[01:11:59] <aeth> cons is cond experimenting with a change that last time didn't work out well and made it ping out
[01:14:06] <aeth> When there's not that much activity, every 30 seconds it blocking reads inside of a 0.1 second timeout to potentially get the EOF from a byte stream since there's no read-byte-no-hang. This is, of course, dangerous and will fail with just the right race condition that makes read-byte for a legitimate byte take 0.100001 seconds or whatever.
[01:14:26] <aeth> But there's no good way to do it with usocket since all you're given is LISTEN and LISTEN returns NIL on EOF (TCP stream ended) as well as on no current input
[01:16:17] *** Quits: cons (~example@user/aeth/bot/cond) (Ping timeout: 252 seconds)
[01:16:28] <aeth> aaaaaaaand it still ate a ping eventually.
[01:18:09] *** Joins: cons (~example@user/aeth/bot/cond)
[01:18:37] <aeth> oh, that's because I didn't return the message
[01:26:40] <gilberth> Is FRESH-LINE supposed to work on a pretty printing stream?
[01:29:23] <gilberth> aeth: Yes, this is the very silly thing about LISTEN. What I also miss is SHORT-READ-SEQUENCE or what ever it should be called. It would work like read(2) and return as much as is available without blocking for more. Overall the whole stream API is CL is not that great.
[01:29:31] *** Joins: selwyn (~selwyn@user/selwyn)
[01:30:07] <aeth> gilberth: in theory, the way to do it would be to fix it at the level of the socket library, but afaik usocket is too minimalist for that
[01:30:07] <gilberth> BTW READ-SEQUENCE in CMUCL once behaved that way, which was non-conforming.
[01:30:32] <gilberth> aeth: What has the socket library to do with it?
[01:30:39] <aeth> read-byte-eof-p-no-hang would be another way to do it or something
[01:30:50] <gilberth> Not in CL.
[01:31:15] <aeth> gilberth: if I can't query the byte stream to see if it is an EOF without hanging, then I should be able to query the TCP connection to see if it is dead without hanging
[01:31:19] <aeth> but usocket doesn't have that
[01:31:52] <aeth> So the only conclusion I can come up with is that nobody used usocket for anything robust (they probably did toy implementations of character streams which can't really portably conform to standards without manually doing the encoding/decoding from bytes)
[01:32:04] <aeth> s/of character streams/using character streams/
[01:32:23] <gilberth> And there would be no point in just usocket having that. I mean, when you depend on usocket, you could as get hold of the file descriptor and issue a select(2) syscall.
[01:33:21] <aeth> Afaik, most of the time, you get the encoding after having established the connection and IRC is no exception here, with UTF8ONLY in the RPL_ISUPPORT if that is the case (and it isn't the case on any ircd in the wild that I've connected to, including Libera!)
[01:33:22] <gilberth> * as well
[01:35:00] <gilberth> aeth: Yes, this is why I implemented by own stream API in Closure, which was before universal adoption of Gray streams and characters wider than 7 bit. All octets. And we HTML you must be faced to get hold of the encoding while you parse.
[01:35:27] * gilberth types garbage.
[01:36:15] <aeth> gilberth: I mean, I always knew that this would end with me implementing TCP/UDP myself
[01:36:22] <aeth> Nothing is robust
[01:36:25] <aeth> Unless I write it myself
[01:36:36] <gilberth> aeth: Anyhow the stream API of CL is lacking. I'd also really would like to have a macro for direct buffer access and/or the option to unread any amount of octets or characters.
[01:37:09] <gilberth> aeth: Talking to the tun/tap device?
[01:37:15] <aeth> well, unreading any amount is going too far most of the time. There are good reasons to only allow one unread (although there is no way to unread/peek bytes, either!)
[01:37:21] <gilberth> aeth: And why do you want to poll anyway?
[01:37:46] <selwyn> i remember xml deals with encoding since every file must begin with <?xml
[01:37:53] <selwyn> but then, what is the use of the encoding attribute
[01:38:54] <gilberth> aeth: Yes? Like what? To make things slow? Therefore I would prefer direct buffer access, because otherwise I would be stuck with one funcion invokation per octet/character. Which hurts, when you scan at 7\tau per char directly from a buffer.
[01:40:05] <gilberth> Can't do a method dispatch in 7\tau. And the compiler would need to spill registers, that alone would take the cycles.
[01:40:12] <aeth> selwyn: most things will begin with <?xml the same way though, since most things are compatible with 7-bit ASCII for the <?xml part
[01:40:28] <aeth> unless you're just detecting for 16-bit or 32-bit Unicode rather than UTF-8
[01:41:08] <selwyn> yeah
[01:41:14] * gilberth was refering to the <META CHARSET=...> tag in HTML, which could be just somewhere in the HEAD element.
[01:41:17] <selwyn> the xml standard seems to have the corner cases worked out
[01:42:06] <aeth> afaik, in general, most things will begin with ASCII until they tell you otherwise, and if they never tell you, just assume UTF-8
[01:42:09] <aeth> not perfect, of course
[01:42:10] <gilberth> And BTW someone broke Closure HTML for me, as its default now is UTF-8, which is wrong, HTML's default still is ISO-8859-1.
[01:42:33] <aeth> yes, nobody pays attention to details
[01:42:48] <gilberth> I do. And I read specs.
[01:43:31] <aeth> we need new unicode/TCP/UDP libraries
[01:43:39] <aeth> built into the implementations for efficiency, probably
[01:44:29] <gilberth> And I pretty much hate broken encodings. It sill is a challange to get umlauts unharmed. In 2021! When generating documents I stick to US-ASCII to be safe and escape chars beyond DEL.
[01:45:12] <gilberth> aeth: TCP is just a stream. Or do you really need to handle urgend packets?
[01:47:28] <gilberth> BTW the possibility to unread any amount of octets would provide the API needed to portably implement any decoding stream you could put onto any existing octet stream.
[01:48:57] <gilberth> In theory I would want to build chains of decoders, Like octets -> uncompression -> character decoding. But: Each phase really wants to read faster than one element at a time.
[01:49:34] <gilberth> Throw in chunked encoding, mime/multi-part or sth similar.
[01:50:32] <gilberth> This ought to be possible without unecessary copying.
[01:51:49] <gilberth> In a perfect world the last stage dealing with raw octets would see the DMA buffer.
[01:52:17] <gilberth> Everything else is the all too copy-happy UNIX design.
[01:53:30] <gilberth> I like I/O timeouts and dead lines too. Makes network stuff more robust.
[01:54:06] <gilberth> </vent>
[01:57:47] <aeth> gilberth: I need to be able to eventually detect a connection timeout so I can eventually support autoreconnecting since most IRC connections aren't particularly reliable in the long run
[01:58:32] <aeth> this seems to work even if it's not the cleanest right now: https://gitlab.com/zombie-raptor/zr-irc/-/blob/a431b6203ca33f41d4196f7aa66fcd1588863f92/irc.lisp#L1089
[01:58:33] -ixelp- irc.lisp · a431b6203ca33f41d4196f7aa66fcd1588863f92 · zombie-raptor / ZR IRC · GitLab
[01:58:42] <gilberth> Yes, this is why I like I/O timeouts. But can't you PING yourself?
[01:58:53] <aeth> gilberth: that would add more time
[01:59:11] <aeth> I've gotten 60+ second delays in some edge cases in self-pinging on IRC, without losing the connection
[01:59:59] <gilberth> 60+ seconds? Why that much?
[02:00:26] <SAL9000> most irc clients set some cap on the acceptable ping delay after which they assume that the connection is lost & reconnect
[02:00:39] <gilberth> Anyhow, what I would have to deal with is the DSL link going down, this is not an EOF from the perspective of the host.
[02:00:51] <aeth> This is (1) if LISTEN then read into an octets vector and turn that into a string, (1a) if it works then return it, (1b) if EOF in that process then the connection is gone; (2) if not LISTEN then if it hasn't checked in approximately 30 seconds then READ-BYTE inside of a 0.1 second timeout for a possible EOF
[02:01:13] <aeth> (2a) if EOF then again the connection is lost, (2b) if not an EOF, then read-irc-message* but start at 1 (because 0 is the non-EOF character that was read)
[02:01:19] <aeth> (3) otherwise, no-op
[02:02:10] <gilberth> Sounds overly complicated.
[02:02:14] <aeth> yes
[02:02:18] <aeth> that's what robust software is
[02:02:24] <aeth> this just detects the connection lost
[02:03:20] <gilberth> I have not implemented that yet, but I plan to rely on just PINGs coming back within a dead line. This does not take any bets.
[02:03:31] <aeth> reconnecting will require (1) attempting to connect to the server every 5 minutes, including handling the cases where the connection still won't work (currently, I don't handle it); and, (2) having an alternate nick and/or appending _'s at the end in the event that the old nick is still alive, waiting to ping out (and possibly adding a way to reclaim it automatically)
[02:03:50] <gilberth> I'll use a second thread for that, which sends the PINGs.
[02:04:47] <gilberth> And on reconnect attempts I would use exponential back off.
[02:07:13] <gilberth> I have no idea, what usocket provides in terms of timeouts.
[02:08:35] <gilberth> aeth: Anyhow, what stops you from using an ISO-8859-1 encoded character stream. This is essentially octets and you get READ-CHAR-NO-HANG. Though I still don't see how that is needed, when using multiple threads.
[02:11:00] <aeth> gilberth: I'd rather write my own TCP library than build the probable UTF-8 characters out of an incorrect 8-byte encoding
[02:11:45] <aeth> in particular because raw octets will be stored compactly, while an incorrect encoding will still be stored as internal UTF-32 until converted to a different form of UTF-32 when applying the correct encoding (probable UTF-8)
[02:12:07] <gilberth> I'd like to design a robust implementation. I need a way to test it. But I could do that here, this flaky DSL line fails every so often and is unavailable for a brief period of time, coming back with a new IP address. My IRC clients runs on my machine at the evil house with a damn stable DSL-link, which gets a new IP address every 180 days only.
[02:12:33] <Alfr> gilberth, aeth simply considers the case that the other end is about 1/2 light minute away. (wrt 60+s)
[02:13:33] <gilberth> aeth: Well then just use what the CL implementation provides. I am happy with CCL, as it has bivalent streams and proper I/O timeouts.
[02:14:58] <gilberth> Alfr: Thus my idea to take no bets at all. Either the PINGs come back or they don't come back. Doesn't matter why. And when the other host is on Mars, set the timeout to, what, 40min minimum.
[02:15:09] <aeth> bivalent streams would probably be the way to go (octet until it's safe to utf-8?)
[02:15:13] <aeth> but usocket doesn't do that
[02:16:17] <aeth> Alfr: no activity in 30 seconds is actually very probable if you're only in a few channels because server PINGs will only happen every 180-300 seconds and often the ircd only sends it if you haven't sent anything in that time period.
[02:17:01] <aeth> in which case, checking for EOF can determine a disconnection that usocket detected, but that there's no way to actually know in a non-hanging way
[02:17:17] <gilberth> Yep, this is why I just use what CCL provides. I don't care about it being portable. But in case of IRC it wouldn't hurt to just decode one message at a time. In fact there is no guarantee that messages come in some particular encoding, so you better be prepared for random encoding errors and fall back to perhaps ISO-8859-1 as a good guess.
[02:18:03] <gilberth> aeth: When the DSL router reconnects, even the kernel does not know that the TCP link is away.
[02:18:04] <aeth> Alfr: While self-CTCP-PINGing can plausibly return a result over 60 seconds in cases of extreme lag (it has happened to me before) without actually pinging out from the server (failing to return a PONG to the server's PING within the specified timeout period)
[02:18:30] <aeth> (and, I mean, I could have never seen an extreme CTCP PING response if I had PINGed out from the server, since the connection would have dropped)
[02:18:45] <aeth> IRC having two pings, after all
[02:19:13] <aeth> I do need to actually implement sending CTCP PINGs (sending a timestamp that is echoed verbatim) in my library, btw.
[02:19:32] <gilberth> Yes. But is lag a lost connection? Somewhere you have to set a dead line.
[02:20:15] <aeth> gilberth: detecting an EOF implies that the connection was lost, but not detecting an EOF does not imply that the connection is still alive.
[02:20:18] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 244 seconds)
[02:20:25] <aeth> So my two ways to detect a lost connection are not the only two ways to do so
[02:20:31] <gilberth> aeth: As I said.
[02:21:05] <aeth> fwiw, irssi seems to time out about as long as it takes to ping out... so 250-300 seconds or so.
[02:21:16] <gilberth> I have seen an EOF when I myself miss to answer PINGs with PONGs only.
[02:21:18] <aeth> so it does some other lag detection
[02:22:56] <gilberth> aeth: How fast would you want to pace your PINGs?
[02:23:29] <aeth> gilberth: are you talking about self-CTCP PINGs or PONG to a server's PING because those are two separate concepts?
[02:24:28] <gilberth> aeth: CTCP pings. I am not confident that may non-CTCP PING the server, the RFC is not clear to me here. But it works, too.
[02:24:28] <aeth> personally, I have PONGs skip the command queue that all other IRC commands go through and the library immediately responds with a PONG as soon as a PING is parsed, to reduce the probability of an internal delay in the program (a very unfortunate GC?) giving a false positive ping timeout
[02:24:47] <aeth> I don't think you're supposed to PING a server unless you are a server
[02:24:57] <aeth> but there are so many (potentially conflicting) documents
[02:25:04] <gilberth> This is what I have read.
[02:25:13] <aeth> and the horse docs don't even have PING yet
[02:25:22] <aeth> https://modern.ircdocs.horse/
[02:25:22] -ixelp- IRC Client Protocol Specification
[02:25:25] <Alfr> gilberth, but you still have to decide on some value for the timeout.
[02:25:30] <gilberth> I mean: I read the you're not supposed to do that unless you're a server part.
[02:25:44] <aeth> the horse docs aren't an RFC, but they're a very incomplete attempt to document actual client/server behavior, which is more useful
[02:25:58] <aeth> I noticed that their RPL_BANLIST is outdated, though
[02:26:18] <aeth> in practice RPL_BANLIST is <client> <channel> <mask> <op-who-banned> <timestamp>
[02:27:24] <aeth> s/timestamp/unix timestamp/
[02:28:03] <aeth> you must be able to parse a unix timestamp, and parse ISO 8601, since all dates are ad hoc additions
[02:28:58] <aeth> in particular, https://ircv3.net/specs/extensions/server-time is ISO 8601 time instead.
[02:28:59] -ixelp- `server-time` Extension - IRCv3
[02:30:49] <gilberth> aeth: Actually you could send any message to yourself. Doesn't need to be CTCP PING. And there does need to be a time stamp in it, as long as you remember the one single outstanding PING. The timestamp is just usually used to be state-less here. Which in case of a ping to probe the connection I am not in any case.
[02:31:22] <gilberth> aeth: What would the server time give you?
[02:32:19] <gilberth> * does not need to be a time stamp ;oh well, why do I always forget the "not"?
[02:32:20] <aeth> gilberth: you can PRIVMSG yourself and respond to yourself with a NOTICE
[02:32:38] <aeth> gilberth: however, that's just the same as CTCP PINGing yourself
[02:32:48] <aeth> you just drop the ^APING ...^A part
[02:32:56] *** Joins: lucf117 (~lucf117@user/lucf117)
[02:32:59] <gilberth> aeth: You don't even need to respond. The initial PRIVMSG comes back to you.
[02:33:14] <aeth> yes
[02:33:20] <aeth> I special case my logging, actually
[02:33:33] <gilberth> The repsonse is for someone else pinging you.
[02:33:37] <aeth> if you message or notice yourself, I ignore it and only include the response
[02:34:17] <aeth> gilberth: server time, btw, gives you precisely the time that the server received the message, instead of when you locally received it. This could be useful to see when your messages arrive to everyone else (although that would require echoing your messages, which I guess is probably another extension)
[02:34:22] <aeth> gilberth: but it's mostly for bouncers
[02:34:40] <aeth> since a bouncer is just a fake IRC network that plays back messages that you've missed
[02:34:53] <aeth> they would all show up as 18:04:40 though if I used it, unless they had the server time extension
[02:35:05] <gilberth> ok
[02:35:07] <aeth> if you use an IRC bouncer and it shows the correct timestamp, then that means that both the bouncer and your client support that extension
[02:35:28] <aeth> it also means that you can precisely request based on the last message that you've seen, which helps if you pinged out
[02:35:39] <aeth> down to the millisecond
[02:35:54] <aeth> that and message tags
[02:37:21] <aeth> server-time + message-tags means that you could get, say, 2021-07-05T22:06:22.525Z bncmsg234234235 <aeth> This is a message.
[02:37:34] <aeth> So now you know exactly what to request
[02:38:14] <aeth> I'm going to have to implement a bouncer once I move to a graphical client from in-terminal IRC that I can just shove in tmux
[02:39:17] <aeth> afaik, a bouncer basically relays everything except QUIT, PING, and PONG (since it maintains its own PING<->PONG relationship to the ircd vs its separate one to you)
[02:39:37] <gilberth> Yep. I use HTTP/HTML/JS. Could connet to my IRC client running from here, I locally edit and when the local link goes down, nothing happens.
[02:39:42] <aeth> So a bnc is easy except when you disconnect, then reconnect, and need to catch up with the history played back
[02:41:02] <gilberth> Anyhow, I will stick to CTCP PINGs, just to be polite.
[02:41:20] <aeth> I suppose you can just give it the last message you received (in raw form), and then it can replay from there, assuming it caches every message in order (or at least some order) with timestamps added if the server doesn't timestamp
[02:41:55] <aeth> so instead of having to parse, log by channel, etc., it can just have a big appending buffer of messages that it will eventually play back to you
[02:42:56] <aeth> gilberth: the only complication is that you need to distinguish between automatic CTCP PINGs (don't log or display) and user-sent CTCP PINGs (log and display) since one might want to ping oneself
[02:42:59] <gilberth> aeth: BTW I will probably ditch CL-IRC with time.
[02:44:34] <gilberth> I could fix all the issues, but I never quite liked the API to begin with. So I don't see a point.
[02:49:05] <aeth> ime, most libraries seem to be built around working 90% of the time and providing a DEFMETHOD API to override behavior in ways that don't really make sense
[02:49:30] <aeth> cons: are you still there?
[02:49:30] <cons> aeth: Alright!
[02:49:59] <aeth> I must resist the urge to create an infinite loop between cons and cond by using manual messaging functionality to have one start it
[02:51:16] <gilberth> For decoding characters, I plan to do that on a message by message basis, because encoding errors could not set up the network in any way by doing so. And I could implement some fall back. Initially for debugging purposes I keep a log of the exact octet traffic. Timestamped and logging my messages too. I perhaps keep it that way, because it doesn't lose any information.
[02:51:58] <aeth> https://modern.ircdocs.horse/#character-encodings
[02:51:58] <gilberth> aeth: Heh, ixelp is safe in that regard. :-p
[02:51:58] -ixelp- IRC Client Protocol Specification
[02:53:03] <gilberth> aeth: Yes, as I said, try UTF-8 fall back to ISO-8859-1.
[02:53:45] <aeth> a bivalent stream could work, if an alternative to usocket does that, since the happy path would remain, well, happy
[02:53:48] <gilberth> I would guess most servers threat messages just as octets.
[02:54:00] <aeth> most ircd are written in C or C++
[02:54:11] <aeth> so they don't have a distinction between characters and numbers
[02:54:40] <aeth> What I'm probably going to do, though, is I'm probably going to manually do octet into utf-8
[02:54:42] <gilberth> aeth: You can't rewind still. I will threat each message having potentially a different encoding or being broken in any way.
[02:54:58] <aeth> gilberth: depends on what you want
[02:55:13] <aeth> in the long run, everything might be https://ircv3.net/specs/extensions/utf8-only
[02:55:14] -ixelp- UTF8ONLY ISUPPORT token - IRCv3
[02:55:16] <gilberth> Well, this is the design I have in mind.
[02:56:21] <gilberth> And I don't want to take any bets. Like funny people encoding surrogates as UTF-8 or heck even a LF character.
[02:57:12] <aeth> gilberth: you could try using my zr-irc once I remove the sole known dependency on SBCL (utf-8 encoding/decoding... I can just use babel as a fallback, as I've done that before, but I should probably just manually handle the translation so I can use string buffers instead of encoding new strings)
[02:57:23] <aeth> s/encoding new strings/consing new stings when encoded/
[02:58:03] <aeth> unlike my game engine, I'm not attempting nonconsing and networking might even make that impossible (timeouts surely do, unless I write my own timeout system and recycle them in a pool)
[02:58:14] <gilberth> WHat happened to good old flexi-streams?
[02:58:20] <aeth> I am trying to minimize consing up little strings, though, which I'm currently failing to do
[03:00:47] <gilberth> Hmm, usually I want pretty high speed, non-consing, no-copy parsers. But for IRC I won't care too much, as I handle a very low data rate.
[03:01:29] <gilberth> And in my case the rest of the client conses way more. Like constructing DOM fragments, etc.
[03:05:37] <gilberth> But: In the end of he day I want to cons message objects anyway, so that I could method dispatch to implement handlers. That aspect of cl-irc isn't too bad.
[03:07:04] <gilberth> Though I won't work with hooks, but with a single HANDLE-MESSAGE connection message GF and let the API user subclass the CONNECTION object to stick in new handlers in :AFTER methods. That would be the CLOS way.
[03:07:46] <gilberth> Logging for instance could be a mixin. CLOSy.
[03:10:19] <gilberth> As well as SASL, which I have not yet implemented.
[03:12:51] <gilberth> And I would send messages by crafting new message objects and give it some SEND-MESSAGE GF. I do this in my client already, since CL-IRC doesn't do it this way. After all I want to render my own messages by the same infrastructure than any other.
[03:14:24] <gilberth> aeth: It recently occurred to me, that a SLIME REPL which just formats and prints incoming messages and reads messages and commands could be suffice for a simple IRC client.
[03:15:20] <aeth> I do that
[03:15:34] <gilberth> Nice.
[03:15:45] <cons> e.g. 18:44:24 <gilberth:#lispcafe> aeth: It recently occurred to me, that a SLIME REPL which just formats and prints incoming messages and reads messages and commands could be suffice for a simple IRC client.
[03:16:23] <gilberth> And what you type will be send as messages?
[03:16:25] <cons> It gets confusing if you're in more than one channel if more than one is active at the same time, though, since you have to always include the destination (unless you wanted to build a buffer and require some form of channel switching that plays back the backlog if you switch channels)
[03:17:08] <cons> (msg "#lispcafe" ...)
[03:17:16] <gilberth> I have not yet implemented being on more than one channel at once.
[03:17:17] <aeth> or in that case, zr-irc/irc> (msg "#lispcafe" "(msg \"#lispcafe\" ...)")
[03:17:27] <aeth> it's easy to be in more than one channel at once
[03:17:40] <aeth> it's hard to tell them apart unless you code in an explicit destination
[03:17:50] <gilberth> Ah, so you don't have a custom command parser?
[03:18:14] <aeth> and you have to state-track for NICK and QUIT if you want to separate output (since you only want to display NICK and QUIT in channels where the user is present but they only send one NICK or QUIT message)
[03:18:19] <gilberth> A pity that SLIME could handle only one REPL.
[03:19:21] <aeth> gilberth: you don't need a custom command parser since IRC commands (except CTCPs) are human readable (but emacs will display the CTCP character as ^A so even that is technically readable)
[03:20:02] <gilberth> I would hate to prefix each regular message by anything.
[03:20:30] <aeth> <gilberth:#lispcafe> isn't too bad
[03:20:50] <aeth> if channels are low-traffic
[03:20:55] <gilberth> So there should at least be a default for me, which sends messages to the current target. When you're lazy "(" could be the prefix for a lisp form to eval.
[03:21:01] <aeth> cond is in multiple channels, though
[03:21:30] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[03:21:58] <aeth> Since this is way noisier than the other channels, if I wanted to actually follow a conversation in another channel, it wouldn't really work out
[03:22:17] <gilberth> Actually with my HTTP based client "(" is a prefix to talk to the Lisp. Values and *standard-output* would be send back to the browser.
[03:23:02] <gilberth> aeth: Can't Emacs somehow be taught to hide lines based on a regular expression or something?
[03:23:07] <aeth> I'd probably want to (1) filter by channel and then hide the destination in those cases (but then QUIT and NICK need state tracking to show only where the user is present), (2) combine NETSPLITs into one line (most clients do it this way... you lose history but you gain readability in large channels)
[03:23:30] <aeth> (3) optionally show/hide joins/parts/quits/etc. (often long stretches of channels like #commonlisp are just that)
[03:23:41] <aeth> (but you'd want to turn it back on if it's relevant)
[03:24:08] <aeth> technically all except #3 can be done through SLIME If you're willing to give up a strict chronological order and just play back the unseen history of a channel when you switch to it, via a command
[03:24:35] <aeth> probably best at that point just to switch to a bouncer and graphical client pair, though
[03:25:55] <gilberth> You have seen <http://bauhh.dyndns.org:8000/mcclim/beirc/b1.png and http://bauhh.dyndns.org:8000/mcclim/beirc/b2.png -- look carefully what happens.
[03:27:18] <gilberth> Sorry, Tipsy2_.
[03:27:49] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[03:29:18] <White_Flame> is that on freenode or something?
[03:30:39] <gilberth> Sure, look at the file date.
[03:31:40] *** Quits: makomo (~makomo@user/makomo) (Ping timeout: 246 seconds)
[03:31:47] <gilberth> Just delete the b1.png from the url.
[03:32:03] <White_Flame> oh, I was tryign to figure out how to do a 'view info' or something on it ;)
[03:32:19] <White_Flame> ah, quite a ways ago then
[03:32:43] <gilberth> Yep, I feel old as you state that.
[03:33:52] <White_Flame> I don't remember when I first got onto #lisp.  I went through a few handles in the meantime, and I think my current client's log goes back to 2010 or so
[03:34:45] <aeth> you definitely changed handles a bunch because your current freenode account before the purge was fairly new... maybe 2016-2018 or so. Surprisingly new.
[03:34:56] <aeth> I did nickserv info on quite a few people near the end. Not enough, unfortunately
[03:36:08] <aeth> Lisp was kind of the worst thing that happened to my programming because now I expect perfect, even if it's not ever completed, while before I expected completed, even if it just hastily glues together existing libraries (whereas the existing CL libraries aren't mature enough to even get that far)
[03:36:09] <White_Flame> I was unregistered for a long time, then it went +r during some spam problems of a few years back
[03:36:17] <aeth> yeah
[03:36:43] <White_Flame> so yeah, my freenode account specifically was fairly new
[03:36:50] <aeth> Amazing how one spammer or a handful of spammers completely changed IRC culture to +r channels and +R users
[03:37:20] <aeth> before you mostly needed accounts to (1) kill old versions of your nick if your connection was/is bad, (2) get ops/voice in channels
[03:37:33] <aeth> and many networks don't have an easy GROUP like in old freenode and libera
[03:37:45] <aeth> so in many networks you'd just... not bother registering aeth_
[03:38:10] <aeth> I mean, my aeth_ was probably registered a year later than aeth and I don't think I registered the alt nicks for the other nicks I used to use
[03:39:03] <gilberth> The earlies proof of me being in #lisp I could find is 2002-02-03.
[03:40:00] <aeth> I like to believe that the earliest time I was in #lisp was 2012 or so because that's the most amusing. At least, speaking. I was briefly in it not speaking earlier, and maybe I was in it even earlier than that
[03:40:36] <aeth> Jan 2012
[03:40:43] <gilberth> I was silent quite a long time, though.
[03:41:18] <aeth> looks like it's not quite true
[03:41:46] <aeth> The amusing exchange where I start permanently being in #lisp starting in Jan 2012 wasn't the first time I was there. Where I'm like "I want Lisp to prove itself to me" because I was reading too much pg and someone's like "It won't"
[03:42:09] <aeth> Looks like in Oct 2011 I asked about formal proofs in Lisp as Aeth (upper case at the time)
[03:42:18] <aeth> 21:17:28 < Aeth> What's the thing that makes some languages (e.g. lisp?) better than others in this respect?
[03:42:26] <aeth> bad question
[03:42:39] <aeth> didn't really show up in my greps because it's part of my compressed Amazon logs from when I was on EC2
[03:42:43] <gilberth> Nicks are case-insensitive to Scandavian-ASCII.
[03:44:12] <aeth> right
[03:44:25] <aeth> however, back then I was Aeth and on Freenode the nick was registered as Aeth, not aeth
[03:44:34] <aeth> even though obviously owning Aeth lets you use aeth
[03:44:52] <aeth> on some older ircd you couldn't even nick from Aeth to aeth without first using another intermediate nick, which is weird
[03:47:28] *** Joins: {gilberth} (~gilbert@p54bfef57.dip0.t-ipconnect.de)
[03:47:28] *** ChanServ sets mode: +o {gilberth}
[03:47:56] <{gilberth}> You could /msg [gilberth] as this is still me.
[04:20:25] <edgar-rft> Scandavian-ASCII, as introduced by Leif Erikson?
[04:21:52] <hayley> https://www.youtube.com/watch?v=VBaC30wHQXo
[04:21:52] -ixelp- Pink Floyd - Atom Heart Mother (The Amsterdam Rock Circus) - YouTube
[04:25:00] <gilberth> edgar-rft: Here is the missing piece: "in"
[04:26:25] <dave0> up and atom!
[04:26:29] <dave0> up and at them!
[04:26:31] <gilberth> Like DIN-66303, where they reused [ \ ] { | } and ~ for accented chars. Thus { uppercase is [.
[04:28:02] <hayley> gilberth: Rust regex uses an NFA for submatching with Rob Pike's VM. Thus I would say it is not efficient.
[04:28:03] <gilberth> My CP/M-80 had a keyboard short cut to switch character ROMs to make Ä into [ and back.
[04:28:16] <edgar-rft> gilberth, what I meant was: how many scandinavians were involved in defining american standards?
[04:28:34] <waleee> ä and ö is used by germans too
[04:28:52] <gilberth> hayley: Is it even correct? I should run the test suite on it. I have not yet seen any POSIX RE matcher besides mine, which passes it.
[04:29:25] <hayley> gilberth: Don't count on it.
[04:29:26] <waleee> edgar-rft: Å/å is where true Scandinavianism lies
[04:29:29] <gilberth> waleee: We have a code point for the ß ligature. :-p
[04:29:45] <gilberth> It's on "~"
[04:30:10] <waleee> on a standard german keyboar? :|
[04:30:12] <waleee> why
[04:30:35] <waleee> +d
[04:30:38] <gilberth> No in the 7-bit charset.
[04:31:29] <gilberth> I have to take a look to find it on the keyboard. Found it: When I press it, I get: "/". Hmm, borken keyboard.
[04:32:38] <gilberth> This machine used to be my wife's machine and thus unfortunately has German keycap.
[04:33:06] <waleee> quaking qwertz 
[04:33:15] <gilberth> I just don't look, so I am fine.
[04:33:33] * gilberth uses US layout.
[04:34:41] * edgar-rft never looks while typing: zrxkzmfkrwrscnmvswktdgpjrbcltr
[04:35:19] <gilberth> What would looking be of use when the keycaps don't say what you type?
[04:35:29] <waleee> Had I started out typing with a US-layout I'd use it. Now muscle memory makes stuff weird when trying out other layouts
[04:36:18] <waleee> tried dvorak for a full 5 minutes in my teens and it felt incredibly wrong 
[04:36:53] <gilberth> In fact, on occasions I need to type with German layout, I HAVE to look and fall back to hunt and peck.
[04:37:27] <gilberth> waleee: It takes 21 days.
[04:37:43] <hayley> https://www.youtube.com/watch?v=S7WJSm6UHlU
[04:37:43] -ixelp- Talking Heads - The Book I Read (CBS Demo 1975) - YouTube
[04:38:25] <waleee> gilberth: not worth all the spelling corrections needed during that time 
[04:38:50] <gilberth> But I have a custom layout and swapped [ ] with ( ) and - with /. Better for Lisp hacking.
[04:39:07] <dave0> time for a walk! bbl
[04:39:11] *** Quits: dave0 (~davezero@069.d.003.ncl.iprimus.net.au) (Quit: dave's not here)
[04:39:46] <gilberth> I always wanted Backspace on CapsLock, never got used to that.
[04:41:52] <waleee> yeah, switching a key from the right to left hand seems unoptimal 
[04:43:41] <hayley> Hm, seems the library has not found the GC Handbook yet. 
[04:44:17] <gilberth> Leaving my typing position for each error to correct seems inefficient to me. With Backspace on CapsLock (which I dont use as Control), would just need a little tap with left pinky.
[04:44:55] <gilberth> hayley: Have you forgotten to return the copy last time?
[04:45:05] <waleee> unoptimal as in re-training your muscle memory
[04:45:13] <hayley> I haven't borrowed it before.
[04:45:19] <gilberth> waleee: Sure.
[04:45:37] <gilberth> hayley: Are you sure? So where is that book then?
[04:45:49] <hayley> https://www.reddit.com/r/TalkingHeadCircleJerk/comments/oe9frp/david_byrne_in_just_dance_2_for_da_wii/
[04:45:54] <hayley> gilberth: Yes, somewhere in the library.
[04:46:03] <gilberth> I own a copy 100km away :-/
[04:46:32] <gilberth> hayley: Yes, your library.
[04:46:39] <waleee> isn't hayley in the land down under?
[04:46:48] <hayley> waleee: Yes.
[04:47:10] <waleee> ah, 100km away from gilberth's current position
[04:48:22] <hayley> https://www.youtube.com/watch?v=SYQZq2VJaoc
[04:48:22] -ixelp- Gary Numan - The Aircrash Bureau - YouTube
[04:48:26] <gilberth> Yes, still too far away for me. It's high up on my reading list.
[04:49:37] <gilberth> I have a stack of books-to-read. It sits right on the top. I hope, I was not at my house since December.
[05:01:47] *** Quits: random-nick (~random-ni@87.116.179.129) (Ping timeout: 252 seconds)
[05:52:08] <aeth> cons: are you still alive?
[05:52:09] <cons> aeth: Yeah!
[05:52:17] <aeth> so it might have lost messages, but it has not lost a PING
[05:54:34] <hayley> https://www.youtube.com/watch?v=9tSj1xaB17I
[05:54:35] -ixelp- The Secret World of Chip Art - CPU under the Microscope - Birds, Godzilla & CO - YouTube
[05:58:20] <aeth> The Secret World of Clip Art - Microsoft Office 97 under the Microscope - Bill, Microsoft & CO - Bing Videos
[05:59:01] <aeth> damn, maybe I should have said "- Windows Media Player" instead
[06:00:27] *** Quits: cammie (~cammie@pa49-180-26-29.pa.nsw.optusnet.com.au) (Read error: Connection reset by peer)
[06:00:45] *** Joins: cammie (~cammie@pa49-180-26-29.pa.nsw.optusnet.com.au)
[06:00:51] *** Quits: cammie (~cammie@pa49-180-26-29.pa.nsw.optusnet.com.au) (Read error: Connection reset by peer)
[06:01:10] *** Joins: cammie (~cammie@159.196.170.213)
[06:04:51] * hayley has a bad idea
[06:05:22] *** Quits: cammie (~cammie@159.196.170.213) (Ping timeout: 240 seconds)
[06:05:53] <hayley> Rather than loading every page header to see if we need to move references to it, could we hash page numbers in some way s.t. we have a 64-bit word with 0s for hashes that certainly don't have to move and 1s for hashes that might have to move? 
[06:09:01] <hayley> For it to work we have to move very few pages though. It is basically a Bloom filter come to think of it.
[06:12:06] <hayley> We still have locality of reference, I guess. It might be likely that when we scan over one page, all the references only go to a few pages.
[06:16:15] *** Joins: cammie (~cammie@159.196.170.213)
[06:16:26] *** Quits: cammie (~cammie@159.196.170.213) (Client Quit)
[06:23:52] <gilberth> aeth: I played with one of Libera's servers, it seems to transmit messages as they are octet-by-octet.
[06:28:28] <waleee> was there a hypothesis that they don't?
[06:28:53] <White_Flame> yeah, I presume it's basically the redis model, where it's just slamming around byte buffers
[06:29:03] <White_Flame> (obv ircd precedes it)
[06:35:53] <gilberth> waleee: Yes.
[06:39:10] <gilberth> aeth: Upon reconnect, why not just choose a random [and I mean random] nick. In the very rare case of a collision, just pick another. Then identify with NickServ. And then ghost the old nick?
[06:41:26] <gilberth> waleee: The link aeth posted <https://modern.ircdocs.horse/#character-encodings> says that servers might decode and encode again. Though I really doubt that. So I will better be prepared for just any sequence of octets modulo LF.
[06:41:27] -ixelp- IRC Client Protocol Specification
[06:42:54] <gilberth> aeth: However that will be a nice (not) little state machine.
[06:43:25] <aeth> gilberth: generally, clients just keep trying to add _s
[06:43:26] <gilberth> Dunno how SASL would change that.
[06:43:31] <aeth> (at least if it remains within the length limit)
[06:43:50] <aeth> gilberth: at least on Libera, account identification and nick identification are independent
[06:43:50] <gilberth> aeth: Nicknames may only be up to nine characters. :-)
[06:44:05] <aeth> I remain identified as aeth even if I nick to an unregistered nick and then nick back
[06:44:22] <aeth> that is, in fact, by design so that you can claim one with /msg nickserv group
[06:44:28] <gilberth> Yep. This is what I just tried.
[06:44:44] <aeth> old services tend to have independent nicks tied to NickServ so if you nicked away and back then you'd have to reidentify, and you'd have to register each nick
[06:45:03] <gilberth> Well, you have a short nick. Mine would have just one _ to add. In theory.
[06:45:17] <aeth> well, no
[06:45:38] <aeth> 16:41:24 -!- [005] KNOCK SAFELIST ELIST=CTU MONITOR=100 CALLERID=g FNC WHOX ETRACE CHANTYPES=# EXCEPTS INVEX CHANMODES=eIbq,k,flj,CFLMPQScgimnprstuz are supported by this server
[06:45:41] <aeth> 16:41:24 -!- [005] CHANLIMIT=#:250 PREFIX=(ov)@+ MAXLIST=bqeI:100 MODES=4 NETWORK=Libera.Chat STATUSMSG=@+ CASEMAPPING=rfc1459 NICKLEN=16 MAXNICKLEN=16 CHANNELLEN=50 TOPICLEN=390 DEAF=D are supported by this server
[06:45:58] <aeth> of course, unless cached, you don't know this until you pick your initial nick
[06:46:17] <aeth> when I used a longer nick, irssi would substitute the penultimate letter with "1" (and then I guess probably 2, 3, etc.)
[06:46:38] <gilberth> Yes, but I believe my scheme would work.
[06:46:41] <aeth> so assuming you're at the right length for that, it would use gilber1h or, I know for sure, it would be White_Fla1e for White_Flame
[06:46:44] <aeth> I think, anyway
[06:47:18] <gilberth> White_F1ame would make more sense. :)
[06:47:18] <aeth> anyway, if it knew that Libera's MAXNICKLEN=16 then it would append _s to the end until 16
[06:47:28] <aeth> it would have to guess on first connect that it hasn't changed, from a cached value, though
[06:47:49] <aeth> gilberth: I wonder if it's that smart and just the penultimate happened to make the most sense based on its algo
[06:47:51] <gilberth> Yes, sure, but why the hassle?
[06:48:56] <gilberth> no-defun-allowed would then have no _ to add at all.
[06:50:06] <aeth> right, no-defun-allowed was afaik constructed to perfectly fit and not have any extra space. Or it was a coincidence. Idk
[06:50:21] <aeth> no-defun-allowed didn't follow us here to libera, unfortunately
[06:53:23] <gilberth> Yes, no node fun anymore, a pity.
[06:53:30] <hayley> aeth: No, it was accidental.
[06:53:59] <gilberth> aeth: We summoned her.
[06:54:59] <gilberth> Do all NickServ's take IDENTIFY <nick> <passwd>? Or just this one?
[06:55:14] <hayley> The real Freenode did IIRC.
[06:55:28] <hayley> Still no sign of the Handbook. sigh
[06:55:54] <gilberth> hayley: Have you looked under your pillow?
[06:56:07] <hayley> gilberth: Very funny. I don't have a copy.
[06:56:54] <gilberth> hayley: You just forgot that you forgot to return it, it's still somewhere in your room unless your brother has it.
[06:57:03] * hayley sighs again
[06:57:26] <aeth> "No, it was accidental." -- hayley on no-defun-allowed's disappearance, even though nobody said that it was a death yet
[06:57:36] <aeth> that's kind of sus
[06:57:51] <hayley> I saw gilberth vent actually
[06:57:51] <gilberth> hayley: I believe they call it Alzheimer decease. Comes with age.
[06:58:00] * hayley uploaded an image: (13KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/nUoxefBwsizspOnJppahqUyl/Screenshot%20from%202021-07-06%2012-27-42.png >
[06:58:05] <hayley> gilberth: Come on, I am only 20.
[06:58:32] <aeth> gilberth: no, I think it was just IDENTIFY <passwd> since you'd identify to the current account
[06:58:33] <gilberth> See, you forgot a digit. Alzheimer in final stage.
[06:59:57] <gilberth> aeth: Dammit. My olde logs show that as the hint, yes. But GHOST also takes a password.
[07:00:16] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 246 seconds)
[07:01:06] *** Quits: derelict (~derelict@user/derelict) (Ping timeout: 240 seconds)
[07:02:10] <gilberth> Anyhow, I want to go with SASL in the long run.
[07:02:19] <hayley> Right, I am 200.
[07:02:49] <gilberth> hayley: No you're 120, forgot?
[07:02:53] <aeth> gilberth: yes, I plan to support SASL because NickServ feels wrong
[07:02:58] <aeth> and TLS, too
[07:03:01] <hayley> gilberth: Clearly yes.
[07:03:42] <aeth> I guess ironclad can do TLS if you ignore the warnings that mean that it's potentially insecure. https://github.com/sharplispers/ironclad#warnings
[07:03:43] -ixelp- GitHub - sharplispers/ironclad: A cryptographic toolkit written in Common Lisp
[07:03:44] <gilberth> aeth: Indeed. Passwords in clear text is wrong. No TLS for me, no SASL.
[07:04:24] <aeth> gilberth: it also helps because messages to NickServ are generally logged (and you generally do want everything else logged, e.g. looking things up), so the password is now in a million little places
[07:04:25] <gilberth> aeth: Oh, didn't know that ironclad also does TLS.
[07:05:09] <hayley> In hindsight, I don't think my current GC plan actually would benefit from user-mode MMU keys or whatever. I guess if I use hardware traps to handle the write barrier, there would be a reason, but it's too damn slow that I'd rather do it in software.
[07:05:13] <gilberth> aeth: Yep.
[07:05:14] <aeth> TLS means that the password is in one place: the configuration (or you could remember it and type it every time, but I think it's better just to have a throwaway secure password from `openssl rand -base64 LENGTH` or something like that)
[07:05:38] <aeth> (I suppose you could do both and have the memorable password decrypt the disposable, secure one)
[07:06:11] <hayley> At least the only hardware barrier is a read barrier for which we unprotect the page for the whole cycle. Oh, I forgot that the servicing code has to update the page while it is still protected for the rest of the process. So there is one.
[07:06:17] <hayley> aeth: https://github.com/shrdlu68/cl-tls uses Ironclad to implement TLS
[07:06:18] -ixelp- GitHub - shrdlu68/cl-tls: An implementation of TLS and related specifications in Common Lisp
[07:06:31] <aeth> gilberth: Ironclad appears to do the TLS algorithms
[07:06:46] <gilberth> Good news. Sounds great.
[07:06:53] <hayley> FWIW C (as well as some CPUs even) also suck at constant-time, and the only reason OpenSSL works is because someone looks at all the disassembly.
[07:07:20] <hayley> But on x86-64, is it slower to execute MOV RAX, [RBX + RCX] than MOV RAX, [RBX]?
[07:07:21] <aeth> (I'm not sure which TLS, though, since 1.3 is different)
[07:07:37] <aeth> hayley: wow, that's more code than I would have expected to implement TLS from ironclad, which is unfortunate
[07:08:01] <hayley> Agner's tables only mention one latency for MOV seemingly. 
[07:08:07] <hayley> aeth: You have all the handshaking stuff, no?
[07:09:00] <aeth> well, I didn't look into what ironclad included or not (the encryption but not the handshaking apparently)
[07:09:15] <hayley> Right, Ironclad is just crypto.
[07:09:55] <gilberth> But shouldn't openssl s_client -conect host:port work too?
[07:10:03] <gilberth> n
[07:11:36] <aeth> I guess I won't begin to attempt TLS yet
[07:14:22] <hayley> How would I go about testing the two without getting cache to interfere? I suppose in the end the idea is to use RCX as a swizzle so I keep that constant, then have RBX iterate over some array.
[07:15:03] <gilberth> Works. Good enough for me.
[07:15:33] *** Joins: gilberth_ (~gilberth_@p54bfef57.dip0.t-ipconnect.de)
[07:15:33] *** ChanServ sets mode: +o gilberth_
[07:15:59] <gilberth_> This is me over openssl s_connect
[07:17:06] <gilberth_> No client though, so I have to type IRC commands manually. And I'd better be quick with PONGs.
[07:17:18] <cons> Looks like this works. Or at lesat, it hasn't crashed yet. No need to keep this test up anymore.
[07:17:21] <hayley> What the fuck, blah[j] is slower than blah[j + swizzle]? Though I forgot to provide -O3 again.
[07:17:31] *** Quits: cons (~example@user/aeth/bot/cond) (Quit: Bot)
[07:17:52] <aeth> oooooooooops
[07:17:54] <hayley> Right, blah[j] with gcc -O3 takes 1.7 seconds but blah[j + swizzle] takes 2.5 seconds.
[07:18:16] <hayley> Off to godbolt.org again.
[07:18:22] <aeth> I meant to say "Bot test passed"
[07:18:26] <hayley> "Support diversity in C++ with #include <C++>" how bout no
[07:18:46] *** Quits: gilberth_ (~gilberth_@p54bfef57.dip0.t-ipconnect.de) (Remote host closed the connection)
[07:19:53] *** Joins: dave0 (~davezero@069.d.003.ncl.iprimus.net.au)
[07:20:07] *** Joins: cons (~example@user/aeth/bot/cond)
[07:20:25] *** Quits: cons (~example@user/aeth/bot/cond) (Client Quit)
[07:20:33] <aeth> GOD DAMN IT
[07:20:41] <gilberth> Yes, this is easy, I'll just use openssl then.
[07:21:03] <gilberth> aeth: What happened?
[07:21:12] <hayley> Seems for my loop GCC would rather emit a loop bumping RAX rather than relative addressing.
[07:21:41] <dave0> maw
[07:21:56] <hayley> Of course, that is when I convince it not to generate SSE instructions because I currently just do a sum.
[07:21:57] <hayley> Hey dave0
[07:22:23] <dave0> hi hayley 
[07:22:56] <dave0> indexing is as fast as auto-increment these days
[07:23:23] <hayley> But I add something else to the index, i.e. blah[i + j]
[07:23:52] <hayley> Guess the compiler can't do MOV RAX, [RBX+RCX+RDX] so it has to add something for blah[i + j]. 
[07:23:55] <gilberth> dave0: Which auto-increment?
[07:23:55] <aeth> gilberth: my guess, and I don't print the raw messages, is that the first (quit "Bot test passed.") became "QUIT Bot test passed." and without the : in front, only "Bot" was accepted because it only cares about the first parameter (the : makes it no longer space separated, but can only be used once for obvious reasons)
[07:24:04] <aeth> gilberth: so the first quit was "Quit: Bot"
[07:24:15] <aeth> I apparently only use one-word quit messages
[07:24:24] <hayley> So having page keys rather than swizzling would be faster.
[07:24:25] <dave0> gilberth: well not on x86 i guess
[07:24:53] <gilberth> dave0: One addition per loop is faster than too. Yes.
[07:24:58] <aeth> gilberth: I then attempted to fix it with a simple (format nil ":~A" message) for now even though not consing up an additional string is the long-term way to do it
[07:25:11] <aeth> and it quit with "Client Quit" instead of with the message "Bot test passed?"
[07:25:26] <hayley> blah[0] is barely faster than blah[i] but I would wonder if my 4096 character array is always in cache.
[07:26:05] <gilberth> aeth: I would say (send-message *connection* :quit "Bot test passed") with my initial attempt at a new irc lib. I cannot even send messages with spaces in non-trailing arguments.
[07:26:29] <gilberth> It's &rest
[07:26:31] <aeth> gilberth: similar thinking, I did this
[07:26:35] <aeth> (defun quit (message) (command-list-enqueue *queue* `(:quit ,(format nil ":~A" message))))
[07:27:01] <gilberth> Yes and the : in there is the mistake.
[07:27:07] <aeth> how
[07:27:28] <dave0> hayley: sometimes if blah is a constant, the assembly is   mov rax,[blah+rbx+rcx]
[07:27:36] <aeth> gilberth: without the : it treats it as an unrecognized extension to QUIT and ignores everything from the first space onward
[07:27:43] <aeth> But with the : it doesn't accept the message for whatever reason
[07:27:45] <gilberth> Because you send a number of parameters. It happens that the last one may contain spaces, when prefixed by #\:
[07:28:18] <gilberth> aeth: Then the server is not listening to the RFC.
[07:28:43] <aeth> maybe it was some kind of flood control, to not always accept quit messages if done too soon after each other
[07:29:09] <aeth> I don't really want to test that outside of my localhost ircd because that's how you wind up being a spammer false positive
[07:29:17] <aeth> so I will refrain from doing further tests for now
[07:29:19] <gilberth> I have never seen QUIT messages actually transporting the message. Try PART.
[07:29:48] <aeth> I don't actually have a part message in my part function atm
[07:29:56] <hayley> dave0: You can't add three in one instruction though.
[07:30:00] <aeth> it's way easier to write commands than to handle messages because you only have to support a certain part of the standard.
[07:30:10] <dave0> hayley: yes that's right :-/
[07:30:18] <aeth> For instance, "QUIT :Foo" is perfectly OK... to always have the :, even if you don't need it.
[07:30:21] <hayley> NASM complains "error: invalid effective address: impossible register" and IIRC the general form is base + scale * offset + displacement
[07:30:44] <hayley> Where base and offset are registers, scale and displacement are constant.
[07:30:45] <gilberth> aeth: Well, I chose to have a generic printer, which just would allow for spaces in but the last parameter.
[07:31:11] <dave0> hayley: on x86 the LEA instruction is very powerful
[07:32:08] <gilberth> aeth: This is sth I don't like with CL-IRC, it doesn't get this right.
[07:32:16] <aeth> gilberth: right, but the last parameter should always have a : when you send a message because then you don't have to worry about special cases, like when they send a one-word last parameter but the one word is :
[07:32:28] <aeth> (the correct answer would be to ::)
[07:33:29] <gilberth> aeth: Right, I always send the last param prefixed by #\:, but I validate the but last parameter to not have spaces.
[07:33:52] <gilberth> So, that my lib cannot send malformed messages.
[07:34:20] <aeth> but where do you draw the line in validation?
[07:34:34] <aeth> because if you are going to send to a target, the target might be "#foo" or it might be "#foo,#bar" etc.
[07:34:43] <aeth> so you could do more validation than just a find #\Space
[07:35:34] <gilberth> I'll do that with CTCP too. CL-IRC responded to CTCP PING with basically ^APING ^APING cookie^A^A --- bad. Because messages were constructed with FORMAT.
[07:35:50] <hayley> https://www.youtube.com/watch?v=fBBDMJ_-IBc
[07:35:50] -ixelp- Tribute to Pink Floyd - Saucerful of Secrets Finale on Pipe Organ - YouTube
[07:35:55] <aeth> yeah, CL-IRC is bad
[07:36:09] <aeth> unfortunately, everything is bad when you press on the edge cases, with few exceptions :-/
[07:36:17] <gilberth> aeth: That is above messages. It is the format of e.g. a PRIVMSG.
[07:36:23] <aeth> so e.g. doing TLS means implementing TLS on top of ironclad and hoping ironclad doesn't have an issue
[07:36:50] <gilberth> Or more precise: The first parameter of a PRIVMSG. One transport layer up.
[07:38:30] <gilberth> I would have a privmsg class, it would have a send-message method, which would construct command + params list and pass it one level down to IRC.
[07:40:31] <gilberth> So the knowledge about what the target of a privmsg is, is at one spot only.
[07:42:56] <gilberth> And you better make sure, that params contain no CR, no LF either.
[07:57:46] <aeth> I don't have classes/methods for that sort of thing because it is extremely unlikely for IRC to be extended
[07:57:50] <aeth> in that sense, anyway
[07:58:46] <aeth> Extensions for e.g. supported CTCP responses make sense within the IRC context. Extending PRIVMSG does not.
[07:59:20] <aeth> There are some niche cases where it would make sense (e.g. debugging), but that's not worth slowing down the main type of IRC message imo
[07:59:53] <aeth> I'd probably extend CTCP responses with an EQUALP hash table
[08:00:56] <aeth> Manually writing a CHAR-EQUAL trie would probably be the right approach, but probably too much effort, at least for now.
[08:02:22] <aeth> (and CTCP commands are possibly not long enough for the optimized specific search data structure to beat a hash table and its built-in performance advantage for being built-in)
[08:04:09] <aeth> gilberth: What I do do is split the IRC messages by expected parameter count
[08:04:48] <aeth> irc-message-type-1 through irc-message-type-4 (beyond 4 parameters, it's probably best just to parse up to 4 and then use another abstraction, such as repeated iteration of parsing four parameters... if even parsing up to 4 makes sense)
[08:05:06] <aeth> there isn't even any irc-message-type-4 outside of numeric replies
[08:05:55] <aeth> gilberth: https://gitlab.com/zombie-raptor/zr-irc/-/blob/a431b6203ca33f41d4196f7aa66fcd1588863f92/irc.lisp#L32
[08:05:56] -ixelp- irc.lisp · a431b6203ca33f41d4196f7aa66fcd1588863f92 · zombie-raptor / ZR IRC · GitLab
[08:06:24] <aeth> structs instead of defclass so the type information can be preserved, which is not uncommon when parsing bytes/strings/etc. intended for C/C++ programs.
[08:07:25] <aeth> I should use some form of array, but then I have to switch indices from (maybe uint16) to int16 and turn (when index ...)s into (unless (minusp index) ...)s
[08:08:16] <aeth> because if you give Common Lisp (or null 42) it stores it in a T array and all of that work to specify type information is for nothing
[08:08:59] <aeth> Of course, you can in theory dispatch on an irc-message-type-2 and check for command-symbol :PRIVMSG
[08:09:11] *** Quits: Alfr (~Alfr@user/alfr) (Quit: Leaving)
[08:10:11] <aeth> (Note that the last expected parameter isn't the last parameter that a client/server can send you.)
[08:10:31] <aeth> Looks like a mess right now, but it'll all be hidden by macros once the design is final
[08:17:39] <gilberth> aeth: How many MB/s do you want to parse?
[08:18:03] <aeth> gilberth: as many as the bouncer is required to
[08:18:33] <gilberth> And when you want to get real fast use a scanner generator :-p
[08:18:46] <aeth> the client/bot don't have to be fast
[08:18:47] <gilberth> aeth: Saturate your network link?
[08:18:59] <aeth> persisting the client, or persisting the bot without having to run SLIME, does have to be fast.
[08:19:31] <aeth> although I think a bouncer mostly just has to parse for PING (to PONG) so that could probably be special cased in the bouncer, with the rest just stored for forwarding
[08:19:46] <gilberth> Still? How fast? 10MB/s, 100MB/s, 1GB/s?
[08:20:48] <aeth> worst case would be being in hundreds of channels for multiple users while syncing the messages to out of date clients so idk what that is. Probably less than you think because it's just text
[08:21:05] <gilberth> I am after sth like a lib and it should be robust on both sides. I believe you could trick ixelp to ACTION. Bad.
[08:21:44] <aeth> I'm guessing you'd have a lot of duplicates as soon as you put multiple users/bots into one bouncer, which I would pretty much want to do right away
[08:22:09] <aeth> both cond and I would be in here, via separate connections, receiving the same messages
[08:22:21] <aeth> (possibly in a different order!)
[08:23:03] <aeth> right now I just use very different clients, without sending it through a common bouncer server
[08:23:32] <gilberth> aeth, I care about correctness and robustness first. Should there be a performance issue, I could always optimize.
[08:23:43] <aeth> right, initially everything would just duplicate
[08:23:49] <aeth> scaling it to dozens of users would require being smart
[08:24:04] <aeth> if you optimize, some state tracking is required, too, since if you kick cond from here and I stay in here, then I should keep getting the messages but cond shouldn't
[08:28:02] <aeth> but a bouncer only needs to handle a few things like PING, and if it optimizes like I described it only needs to pay attention to changing state, like KICK, PART, QUIT (you can be forced to QUIT with a K-line), JOIN, etc.
[08:28:20] <gilberth> Anyhow, I need to crash.
[08:31:44] <aeth> good night
[08:33:10] <aeth> and, yeah, I have a lot of intentionally bad performance parts, like SUBSEQs and other random small allocations that are unnecessary, as well as the whole command queue thing which is just enqueuing (:TYPE "foo bar baz")
[08:34:10] <aeth> I already have more than 70 unit tests. If something needs to be made faster, then I'll just make a change that passes the many, many tests I'll be writing.
[08:44:33] <hayley> https://www.youtube.com/watch?v=8FA9TGM2Mfs
[08:44:34] -ixelp- I Dream of Wires - YouTube
[09:28:35] *** Joins: easye (~user@2a01:4f8:200:8261::b0)
[09:30:35] *** Joins: shka (~herr@109.231.62.239)
[09:47:23] *** Joins: pjb (~pjb@user/pjb)
[09:52:45] <shka> good morning
[09:58:53] <hayley> Hey shka
[10:01:18] <hayley> Someone should register luserbenchmark.com and put either Lisp micro-benchmarks or mainframe benchmarks on it.
[10:33:49] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[10:37:17] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 252 seconds)
[10:43:51] <hayley> https://www.youtube.com/watch?v=IMHULTgtQ3A
[10:43:51] -ixelp- COME BACK WETTON - YouTube
[10:45:51] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[10:47:35] *** Quits: lucf117 (~lucf117@user/lucf117) (Quit: Leaving)
[10:48:58] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 240 seconds)
[10:49:28] <dave0> hayley: oh you're an aussie!
[10:49:38] <dave0> hayley: have you heard of a band named "tism" ?
[10:49:38] <hayley> dave0: Yes?
[10:49:45] <hayley> Yes.
[10:49:51] <shka> i think kiwi is the more accurate 
[10:49:55] <shka> term
[10:50:03] <hayley> Wrong island.
[10:50:15] <dave0> hayley: https://youtu.be/Al5mIPVA0dk
[10:50:15] -ixelp- TISM - Jung Talent Time (Unofficial Music Video) - YouTube
[10:50:24] <dave0> it made me laugh :-)
[10:52:35] * shka is trying to use less memory with lisp
[10:52:46] <shka> my initial approach was to attempt to use ECL
[10:53:03] <shka> but it complains about the uiop launch program
[10:55:14] <hayley> Reduce the heap size?
[10:55:41] <shka> yeah, this works, but ideally i want to squeeze into 128 megabytes
[10:55:56] <shka> and at this point i can't load my image
[10:56:15] <shka> i am trying to build 32 bit version of sbcl
[10:56:47] <hayley> SBCL is usually like 15MB image, 35MB minimum heap, so a fair bit is on you IMO.
[10:56:55] <shka> yeah
[10:57:01] <shka> i am equally surprised
[10:57:06] <hayley> 30MB heap with Quicklisp.
[10:57:20] <shka> my image is like 100mb
[10:57:23] <shka> i wonder why honestly
[10:57:39] <hayley> (room t) and see if any classes look suspect?
[10:58:00] <shka> i mean, it used to be 150, but that's because i am any idiot who loads mcclim in the .sbclrc :P
[11:00:24] <hayley> https://www.youtube.com/watch?v=5_ZlhmOiRwQ
[11:00:24] -ixelp- Richard Wright gets revenge on Roger Waters for kicking him out of Pink Floyd - YouTube
[11:00:27] <shka> i will start with empty cache, just in case
[11:01:56] <shka> perhaps my problem is that i need postgres
[11:02:00] <shka> and ssl
[11:02:04] <shka> which means ironcla
[11:02:06] <shka> d
[11:02:19] <shka> but it shouldn't be using this much memory, right?
[11:02:42] <hayley> I thought e.g. cl+ssl just went through OpenSSL and no cryptography was done in Lisp.
[11:03:30] <shka> well, it loads ironclad
[11:03:36] <shka> i can tell you this much
[11:04:52] <shka> anyway, after loading everything i need (and serapeum which i don't need but i have already figured out that it is not memory hog) https://gist.github.com/sirherrbatka/d38cf547a459cfddd991c26d900c02f9
[11:04:52] -ixelp- gist:d38cf547a459cfddd991c26d900c02f9 · GitHub
[11:05:16] <shka> uh, this is huge heap actually, let me reduce it
[11:05:24] <shka> i mean, dynamic space size
[11:08:40] <shka> hayley: yeah, when trying to use even just 128mb heap, i can quickload my system, but first GC will land me in the ldb
[11:08:48] <shka> because of not enough of space
[11:09:30] <shka> i really think that i should blame postmodern
[11:10:01] <shka> it is the only thing that looks like could cause it
[11:12:22] <shka> hmmm, yeah, it looks like postmodern needs 50 megabytes... for some reason
[11:17:27] <shka> hayley: As of version 1.3 it also depends on ironclad, base64 and uax-15 because of the requirement to support scram-sha-256 authentication.
[11:17:36] <shka> so yeah, it needs ironclad
[11:17:52] <hayley> ):<
[11:18:56] <shka> i wonder what i should do
[11:19:11] <shka> i normally don't care about the memory that much
[11:19:36] <shka> because typically, i use lisp to hurl huge chunks of data around
[11:19:39] <shka> essentially
[11:19:57] <shka> and 100mb less or more does not make a difference
[11:20:45] <shka> perhaps i should simply accept this
[11:21:16] <shka> but silly azure function wants me to pay for the average memory usage
[11:21:19] <shka> which is not ideal
[11:24:01] *** Joins: derelict (~derelict@user/derelict)
[11:25:07] <hayley> What is the application?
[11:25:09] <shka> https://www.youtube.com/watch?v=tKB5E6dm0is
[11:25:10] -ixelp- North West - YouTube
[11:26:08] <shka> hayley: read fifos, populate PG database, handle conditions, expose web API (hunchentoot most likely)
[11:26:17] <hayley> Right.
[11:26:21] <shka> nothing really complicated
[11:26:31] <hayley> https://www.youtube.com/watch?v=8TEAMHgrxi0
[11:26:32] -ixelp- JJ Burnel - Crabs - YouTube
[11:29:05] <shka> anyway, it is tied to another program written in golang
[11:29:20] <shka> and this one needs above 200 mb as well
[11:29:38] <shka> so i guess sorry boss, but we gonna need 512mb for this 
[11:30:08] <shka> should be still much cheaper then the old system
[11:31:12] <hayley> "What do you need the memory for?" "...caching?"
[11:31:50] <shka> library uses it, did not dig in to figure out for what
[11:32:51] <hayley> At some point I need to find a host that provides sufficiently new Intel machines so that I can test protection keys to imitate e.g. Azul's "GC" mode, which can be accessed by userspace but has different memory protection bits.
[11:34:34] <hayley> But it seems that the only effect of making the GC swizzle pointers is a few more additions and perhaps more TLB pressure. So I am not sure if it would help, but someone better investigate this crap, no?
[11:37:09] <shka> on another topic
[11:37:19] <shka> anybody here using gatreon green key switches?
[11:45:14] <shka> they remind me why i don't like cherry mx blues
[11:49:35] <Lulu> Too clicky?
[11:51:17] <shka> scratchy 
[11:51:29] <shka> and the noise is not pleasant
[11:52:20] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Remote host closed the connection)
[11:52:53] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[11:53:16] <shka> i actually like clicky switches
[11:54:00] *** Joins: treflip (~user@95.79.32.99)
[11:57:03] <shka> oh, and cherry switches wobble a lot when fully pressed
[11:57:10] <shka> but this is not just blues
[11:57:47] <shka> i think that shape of the slider causes this
[12:06:08] *** Joins: makomo (~makomo@user/makomo)
[12:06:26] <hayley> Hm, that said, we don't have to swizzle pages to copy from, as we are sure that the mutator will never load from those pages. But I guess we might still protect target pages, would we do a Cheney scan and only shallow copy, then fix up later.
[12:07:46] <hayley> https://www.youtube.com/watch?v=-bBPVSf3L_g gilberth's Raspberry Pi -2
[12:07:47] -ixelp- 486 SBC, Benchmark & Dos Gaming on a Vintage Single Board Computer - YouTube
[12:13:53] <hayley> https://www.youtube.com/watch?v=Bd1H-I-i-68
[12:13:54] -ixelp- AMD Walloped Intel on Top500 Supercomputer List - YouTube
[12:30:52] * hayley runs a DOS benchmark in dosbox and watches the graph go up and down as she changes the speed.
[12:37:44] *** Quits: pjb (~pjb@user/pjb) (Ping timeout: 252 seconds)
[12:38:14] <dave0> hayley: turning knobs is fun!
[12:38:49] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[12:39:00] <hayley> You know what would be funny for a dynamic-language-on-microcontroller demo? Emulating another microcontroller.
[12:41:26] <hayley> For example, it'd be hilarious to see an emulated ATmega328/Arduino Uno program running on a Pi Pico.
[12:41:46] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 240 seconds)
[12:48:58] <hayley> Can't seem to find a list of other languages I can program a Pico on. C obviously, MicroPython was ported by the Pi team, and I heard of uLisp and Lua ports. What about JS? Scheme? idk
[12:50:16] *** Quits: derelict (~derelict@user/derelict) (Ping timeout: 246 seconds)
[12:55:59] *** Joins: selwyn (~selwyn@user/selwyn)
[13:37:01] *** Joins: derelict (~derelict@user/derelict)
[13:48:06] *** Joins: pjb (~pjb@user/pjb)
[14:07:53] <dave0> nite all
[14:08:16] *** Quits: dave0 (~davezero@069.d.003.ncl.iprimus.net.au) (Quit: dave's not here)
[14:18:43] <shka> hayley: interestingly enough, on the 32 bit SBCL strings require less memory
[14:18:55] <shka> memory padding perhaps?
[14:19:00] <selwyn> why are you using 32 bit
[14:19:03] <hayley> That and the length would be a 32-bit value.
[14:19:22] <shka> selwyn: trying to save memory
[14:19:43] <shka> but it is just 18mb
[14:19:55] <shka> perhaps more during the actual operation
[14:20:10] <shka> i wonder if go supports 32 bit builds
[14:21:53] <selwyn> i had hopes of running common lisp on a bbc micro with 128 kb memory
[14:21:56] <selwyn> but simply not possible
[14:22:13] <selwyn> i would like to make a ulisp implementation one day
[14:29:16] <hayley> Port ulisp.com?
[14:32:37] <shka> well, 32 bit core image is smaller though 
[14:32:57] <shka> just 74mb
[14:33:03] <hayley> Right, every pointer is going to be smaller.
[14:33:37] <hayley> .oO( Java has compressed OOPs [ordinary object pointers] which achieve that, but of course there is no such thing as a Java image. )
[14:33:46] <shka> 75 mb if executable 
[14:37:33] <shka> i wonder why i have so many strings in the image honestly
[14:42:34] <selwyn> symbol names
[14:49:11] <shka> aaah, shit
[14:49:27] <shka> selwyn: you are obviously right
[14:50:05] <selwyn> well, we worked out a while back that this is why you can´t have common lisp on a microprocessor
[14:50:19] <selwyn> straightaway puts you in megabyte territory
[14:50:42] <shka> right
[14:50:47] <shka> i don't mind usually
[14:50:49] <selwyn> iirc gives you a surprisingly large lower bound for the size of an image
[14:50:56] <shka> but this time around i pay for the memory usage
[14:51:06] <selwyn> oh dear
[14:51:31] <shka> ecl can do poors man tree shaking
[14:51:43] <shka> but ecl is giving me problems
[14:51:53] <shka> i wonder if CCL would be smaller
[14:55:30] <pjb> ecl can generate elf executables using the libecl.so shared library, so smaller executable than a lisp image.
[14:55:37] <selwyn> hayley: yes we would port ulisp to the mos 6502
[14:56:38] <hayley> cl65 ulisp.c -o ulisp
[14:56:40] <selwyn> hm, you can target a lot of retro systems with that
[14:57:14] <selwyn> hayley: oh
[14:58:00] <hayley> http://www.ulisp.com/list?3K3O
[14:58:31] <hayley> IIRC cc65 is picky and only wants variable definitions at the start of functions, but it's doable.
[14:58:42] <selwyn> i see
[14:58:43] <selwyn> thanks a lot
[14:58:48] <shka> CCL ships with the QL, nice
[14:59:54] <selwyn> yeah, so i had the idea of cross compiling ecl with cc65
[15:00:01] <selwyn> which wouldn´t have been feasible
[15:00:22] <selwyn> though i had forgotten that i could simply cross compile ulisp.c
[15:02:06] <selwyn> apparently the hobbyists like to put the c standard library in rom because it is too big
[15:03:44] <selwyn> anyway, they also used to build modems for the bbc micro, which provided a kind of internet over teletext
[15:04:12] <selwyn> next project would be to do dial-up internet access with one of the modems
[15:07:37] <selwyn> there is now a ´lambda variant´ of covid
[15:07:41] <selwyn> worrying black mesa vibes
[15:08:03] *** Joins: random-nick (~random-ni@87.116.165.220)
[15:27:04] *** Quits: selwyn (~selwyn@user/selwyn) (Ping timeout: 246 seconds)
[15:28:08] <shka> the right bat in the wrong place
[15:40:49] *** Joins: selwyn (~selwyn@user/selwyn)
[15:46:04] <hayley> gilberth: What kind of information would a good auto-router/placer need?
[16:15:39] <shka> hmmm, can i somehow wrap SBCL executable image with other executable without docker?
[16:17:51] *** Joins: brainfunnel (~quassel@176.128.208.46.dyn.plus.net)
[16:21:01] <gilberth> Good morning #lispcafe!
[16:22:03] <gilberth> hayley: At least some information about the kind of signals it is supposed to route.
[16:22:32] <ck_> what do you mean lambda variant, they aren't named in order anymore? or are we at 11 already
[16:22:54] <gilberth> And whether you want impedance matching and whether some signals should have the same propagation delay.
[16:24:59] <gilberth> Or: For say switching power converters: What signals carry the current and should better not form loops. etc etc.
[16:26:23] <treflip> Hi gilberth!
[16:36:08] <selwyn> i have no idea how they are named
[16:36:38] <selwyn> the lambda one is considered harmful
[16:40:34] <shka> selwyn: HL3 confirmed?
[16:42:16] <selwyn> lol
[16:42:25] <selwyn> covid was in fact a valve marketing campaign
[16:44:02] <shka> yeah, but then the HL3 got delayed
[16:46:13] <gilberth> Sigh. My machine is falling apart. The meta^Wcmd^apple key feels numb and the fan is making noise :-(
[16:50:25] *** Quits: aeth (~aeth@user/aeth) (Read error: Connection reset by peer)
[16:50:25] *** Quits: cond (~example@user/aeth/bot/cond) (Read error: Connection reset by peer)
[16:51:08] *** Joins: aeth (~aeth@user/aeth)
[17:00:33] <hayley> gilberth: What information?
[17:01:04] <gilberth> hayley: What what?
[17:01:15] <hayley> Right now, I figure humans like buses to stick close, and support components near ICs. Thus we have some idea of what to minimize to make a neat layout.
[17:01:39] <hayley> Okay, you said some, never mind.
[17:02:33] <gilberth> hayley: Neat is no category. It should work. But in general you need to care about loops.
[17:03:02] <gilberth> hayley: Well, see, a clock is different from a bus or some GPIO signal were not much is happening.
[17:03:31] <hayley> Right.
[17:04:12] <gilberth> And when you want that a set of signals arrive at the same time, there is extra considerations. This is why you sometimes see meanders in signals to delay them.
[17:05:10] <hayley> Sure, more stuff to keep "tight".
[17:05:11] <gilberth> Or to make sure that e.g. the clock does not outpace the data to be clocked.
[17:06:11] <hayley> But I think there are quasi-aesthetic features that make people think autorouted routes are bad, and I guess they tie to functional problems too.
[17:06:36] <gilberth> And you don't want to pierce the ground layer too much, as a signal not only runs in the wire, the current has to flow back on the ground layer. That's your loop. Best is, if the return path takes the same way as the signal => tight loop.
[17:07:40] <gilberth> hayley: Most often they do. But wire wrap usually beats PCBs. There also is cross-talk e.g.
[17:09:22] <gilberth> But as long as you stick to a few MHz, you could route as you wish. At least if you don't care about radio interference. :-)
[17:10:32] *** Quits: derelict (~derelict@user/derelict) (Ping timeout: 252 seconds)
[17:11:38] *** Joins: derelict (~derelict@user/derelict)
[17:23:49] <gilberth> hayley: Why you'd ask? Do you want to turn DFAs into circuit and finally a PCB for it?
[17:24:14] <hayley> lukego did another demo with simulated annealing and autoloading.
[17:24:28] <hayley> *autoplacing
[17:24:41] <hayley> https://twitter.com/lukego/status/1412307957971361793
[17:26:02] <gilberth> Where is the video?
[17:26:23] <hayley> No video sadly.
[17:27:33] <hayley> Though I think autorouting would work best with placing with some vague idea of how it should look, as the computer can also shift around components if it just looks bad.
[17:27:52] <gilberth> A pity. Heh, my approach was special purpose and ad hoc. Didn't do pin swapping e.g.
[17:29:48] <gilberth> hayley: As in manual routing, placement is key. For routing a chip, I read that they often cluster in blocks and have kind of channels for wires between them. Like a city with blocks and roads between.
[17:32:07] <gilberth> But in my case it was moderatly nest of gates and what my poor algorithm gave me wasn't too bad and made final routing quite easy.
[17:32:42] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[17:34:59] *** Quits: whosit (~username@user/whosit) (Ping timeout: 258 seconds)
[17:38:18] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 252 seconds)
[17:41:20] *** Joins: selwyn (~selwyn@user/selwyn)
[17:48:54] *** Joins: MetaYan (~MetaYan@c-7b5d235c.07-84-7462671.bbcust.telenor.se)
[18:05:27] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Quit: ec)
[18:06:47] *** Joins: trn (jhj@sourcehut/user/trn)
[18:07:47] *** Joins: phantomics (~phantomic@71-218-246-207.hlrn.qwest.net)
[18:21:50] *** Quits: OlCe (~user@lfbn-nic-1-123-149.w2-15.abo.wanadoo.fr) (Remote host closed the connection)
[18:23:00] *** Joins: OlCe (~user@lfbn-nic-1-123-149.w2-15.abo.wanadoo.fr)
[18:26:54] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[18:31:31] <gilberth> I still don't get why the fan is (a) not temperature controlled and (b) runs at all.
[18:32:32] <hayley> You have a temperature sensor and a way to make a feedback loop?
[18:32:54] * hayley wouldn't mind making a PWM control driven by temperature for the fan for the Pi as it apparently is noisy sometimes.
[18:34:15] <gilberth> My fan runs all the time and its bearing is bad. When I close the lid, the fan stops => not temperature controlled.
[18:34:35] <gilberth> I should get it replaced. But this is the only machine I have here.
[18:35:14] <gilberth> hayley: My Pi doesn't have a fan to begin with :-)
[18:35:22] <hayley> Still, a heatsink would also help.
[18:35:44] <gilberth> Heat sinks, I have.
[18:36:15] <gilberth> Real ones, not just a glued coin. :-p
[18:37:26] <hayley> So I'd use a PWM output driven by a script which outputs some value based on the temperature measured, and the output would be fed to a MOSFET which passes the power of course. And I suppose to be serious, before the script starts I could pull the output high (assuming it is left floating).
[18:37:37] *** Quits: OlCe (~user@lfbn-nic-1-123-149.w2-15.abo.wanadoo.fr) (Remote host closed the connection)
[18:38:52] <gilberth> hayley: Doesn't the pi do that already? Mine came with a fan supposed to be plugged into some pwm header. Never installed it as I don't use the case.
[18:38:52] <hayley> Hey, I never glued the coin. I am still a broke student :)
[18:39:02] <gilberth> hayley: lol
[18:39:23] <hayley> gilberth: Nope, my fan just taps 5V output and is always on.
[18:39:33] <gilberth> Bad.
[18:39:50] *** Joins: OlCe (~user@lfbn-nic-1-123-149.w2-15.abo.wanadoo.fr)
[18:40:09] <gilberth> Can you read the CPU temperature somewhere from /proc ?
[18:40:26] <hayley> There's a command for that somewhere, it's not an issue.
[18:40:33] <shka> sensors
[18:41:07] <shka> coins... some are better then other
[18:41:18] <shka> Yen coins are made of solid copper
[18:41:28] <shka> very good thermal conductivity
[18:41:32] <hayley> Gold coins here are of course copper with a thin layer of gold.
[18:41:42] <gilberth> Coins aren't flat, so no good contact.
[18:42:05] <shka> gilberth: soft enough to grind down
[18:42:13] <hayley> Though the temperature difference was like 3 degrees IIRC, whereas a fan without heatsink is a 20 degree difference (when idle!)
[18:42:56] <gilberth> Anyhow, I am surprised how hot a Pi can run.
[18:43:14] *** Joins: [deleted] (~livoreno@user/notzmv)
[18:43:40] <gilberth> hayley: Here is an idea for you: Submerge it in oil.
[18:43:55] <hayley> I was also considering using a larger fan at a lower RPM, but those tend to want higher voltages (unless I run them slow, which I do I guess) and wouldn't fit the case.
[18:45:03] <hayley> gilberth: I always wanted a deep fryer.
[18:45:23] <hayley> My digestive system, perhaps not...
[18:45:39] <shka> secretly an American
[18:45:50] <gilberth> heh
[18:46:42] * selwyn cues up rammstein
[18:47:06] * hayley uploaded an image: (104KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/OIScjRsTfInqafiicIHEXybv/i'm-afraid-of-rustaceans.jpeg >
[18:47:31] <hayley> selwyn: Still no luck with hotdogs?
[18:49:44] <selwyn> hayley: i am hoping to become an official supplier to these guys https://twitter.com/SportsCenter/status/1411732721974530051
[18:50:24] <selwyn> seriously, how is that possible
[18:50:55] <hayley> Wow. Just remember to pull out before someone dies.
[18:51:05] <gilberth> hayley: We still haven't figured out how to smuggle sausages.
[18:51:16] <shka> selwyn: stomach can stretch 
[18:51:43] <shka> like vagina if you will 
[18:51:49] * selwyn takes notes
[18:52:17] <hayley> Days without shka discussing sex on #lispcafe: 0
[18:52:52] <selwyn> i can eat a 18 inch pizza but i could maybe eat 10 hot dogs
[18:52:57] <hayley> gilberth: Deliver them free with an order for Symbolics 2 hardware?
[18:53:03] <shka> hayley: well, i was going to mention act of giving birth
[18:53:29] <shka> but yeah, i am pervy old man, what can i do? 
[18:53:32] <shka> :P
[18:54:16] <hayley> God dammit, Simple Minds and OMD cancelled their December 2021 tour here. Not that I had a ticket, but I was considering it.
[18:57:38] <shka> selwyn: anyway, back to the stomach 
[18:58:11] <shka> empty stomach is more or less same size as the fist
[18:58:35] <shka> and it really does not take much to fill it
[19:00:44] <shka> i would use comparison, but hayley can interpret it in a sexual way for some reason :P
[19:01:35] * hayley avoids thinking about the "deserves a blowjob" incident
[19:02:09] <shka> ... me does not want to know
[19:02:30] <hayley> Hey, you said it.
[19:02:40] <shka> i said it?
[19:02:49] <hayley> Yes.
[19:02:54] <shka> it does not sound like me :(
[19:04:38] <shka> i am not this pervy
[19:05:42] <shka> anyway, have a good day
[19:06:21] <hayley> gilberth: btw when is Symbolics 2 coming
[19:06:29] <Gnuxie> twitch chat remembers 
[19:07:00] <hayley> I forgot what was said on Twitch
[19:07:36] <shka> w00t? i don't have a twitch account
[19:08:07] <shka> somebody was impersonating me?
[19:09:24] <Gnuxie> i think it was bridged to the els IRC
[19:09:56] <Gnuxie> sorry i'm happy to forget it happened too 
[19:10:02] <shka> i was not on the ELS irc either
[19:10:42] <shka> hayley: some details perhaps?
[19:10:42] <Gnuxie> weird 
[19:11:00] <shka> because this smells fishy
[19:11:03] <Gnuxie> someone said one of the ELS organisers people deserved a blowy 
[19:11:55] <shka> well, it wasn't me
[19:12:10] <shka> but if this was under my nick, i want to know
[19:12:55] <shka> or did I misunderstood?
[19:12:58] <selwyn> i don´t think it was under your nick, iirc i checked to see if you were there because i wanted to chat about something
[19:13:03] <selwyn> but i cannot remember
[19:13:36] <shka> ok
[19:13:45] <shka> that's relief
[19:16:41] *** Quits: OlCe (~user@lfbn-nic-1-123-149.w2-15.abo.wanadoo.fr) (Remote host closed the connection)
[19:24:54] * gilberth reads "smells fishy" and thinks of something non-appropriate.
[19:26:11] <gilberth> hayley: Anyhow, how about having some operator for REs, which accumulates iterations into perhaps a list? IIRC I mentioned that in my draft already.
[19:27:14] <hayley> Probably not hard, sure.
[19:27:22] <gilberth> Essentially an assignment could as well be not just another register, but a function applied to it.
[19:27:52] *** Quits: derelict (~derelict@user/derelict) (Ping timeout: 246 seconds)
[19:28:05] <gilberth> hayley: As long as that is free of side effects, yes.
[19:28:19] *** Joins: derelict (~derelict@user/derelict)
[19:37:50] <edgar-rft> beware, above-effects might fall upon your head
[19:39:56] <shka> you know what? you guys are pervy, not me! :P
[19:41:44] <selwyn> perhaps #lispcafe requires horny police
[19:42:21] * hayley bonks
[19:42:45] <edgar-rft> why should the police be horny?
[19:43:53] <selwyn> who is horny for the horny police?
[19:45:12] * edgar-rft watches naked conses
[19:45:35] <shka> "The naked cons: lisp thriller"
[19:46:49] <shka> features cold war, AI, and source code espionage
[19:47:13] <shka> could happen in either 1960s or 2020s!
[19:49:25] *** Quits: derelict (~derelict@user/derelict) (Quit: WeeChat 3.2)
[19:52:29] <gilberth> Spoiler: They only managed to get hold of the last page of the source code. It is full of ")"s, nothing else.
[19:53:08] <shka> "Sergey... You idiot!"
[19:55:32] <gilberth> Reminds me of the story of selling free software as espionage to the Russians.
[19:58:17] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 252 seconds)
[20:07:10] *** Joins: OlCe (~user@lfbn-nic-1-123-149.w2-15.abo.wanadoo.fr)
[20:18:13] *** Joins: kevingal (~quassel@2a02:8084:4140:f300:394a:1349:1bf0:ba2f)
[20:42:17] <shka> kailh sells keyboard switches in 10, 30, and 70 packages
[20:42:20] <shka> and i need 15
[20:42:24] <shka> eeeh
[20:46:19] <pjb> 2 x 10
[20:48:39] <selwyn> buy ten thousand and set up a dealership
[20:51:46] *** Quits: kevingal (~quassel@2a02:8084:4140:f300:394a:1349:1bf0:ba2f) (Remote host closed the connection)
[20:52:40] <shka> given the inflation rate, selwyn idea is honestly not terrible
[20:52:44] <shka> INVEST
[20:53:14] <shka> seriously though, i will stick with those gatreon greens for now
[20:53:21] <selwyn> anime waifu keycaps are a strong hold 
[20:53:46] <shka> anime waifu keycaps are getting more popular
[20:53:56] <shka> now multiple companies make those
[20:54:05] <Gnuxie> a waifu on each key??
[20:54:25] <selwyn> ´a waifu on every key´ great government pledge
[20:54:41] <selwyn> keyboards fit for heroes
[20:54:43] <shka> Gnuxie: yeah
[20:55:58] <shka> oh, i found the perfect keycap for rust usert
[20:56:05] <shka> http://pl.aliexpress.com/item/1005002016930809.html?spm=a2g0o.productlist.0.0.46bf765cQg5qb4&algo_pvid=c0f4c2b6-0108-4f10-ab85-72b299366a94&algo_exp_id=c0f4c2b6-0108-4f10-ab85-72b299366a94-7
[20:56:05] -ixelp- 1Pc niestandardowe kreskówki Anime krab Keycap dolne podświetlane klawisze prezent dla Cherry klawiatura mechaniczna MX  [...]
[20:56:14] <shka> sorry for the pl
[20:57:07] <selwyn> what inflation rate
[20:57:16] <shka> selwyn: hih
[20:57:19] <shka> *high
[20:58:25] <shka> selwyn: https://www.statista.com/statistics/1086390/poland-monthly-inflation-rate/ it goes way up lately 
[20:58:25] -ixelp- • Poland: monthly inflation rate 2021 | Statista
[20:59:16] <selwyn> the currency is stable though
[20:59:30] <selwyn> i just checked gbp/zl it´s just as i remember from like 7 years ago
[20:59:35] <selwyn> interesting
[20:59:51] <shka> i would not count on the pln stability
[21:02:08] *** Joins: notzmv (~zmv@user/notzmv)
[21:08:26] <selwyn> perhaps gbp has similar stability?
[21:10:23] <shka> selwyn: hmmmm, you consider gbp to be stable?
[21:10:31] <selwyn> well, not that much
[21:10:33] <selwyn> which is my point
[21:11:22] <shka> well, Soros is a historic fact in the history
[21:11:41] <selwyn> indeed
[21:11:44] <shka> and you better bet that this could happen again
[21:12:32] <selwyn> a friend of mine became a quant
[21:13:11] <selwyn> and one of his new colleagues is hopeful that there could be some massive deflationary cycle here that the government can´t stop
[21:13:28] <selwyn> which would bring down asset prices and be good in the long run
[21:13:48] <selwyn> i don´t know what else that would do for the economy though. i suppose exports become more competitive?
[21:14:26] <shka> there would be no export at all
[21:14:59] <shka> and no investment
[21:15:37] <selwyn> well
[21:15:37] <shka> problem with massive deflation is that it makes more sense to hold your own cache 
[21:15:41] <selwyn> something to look forward to then
[21:15:42] <shka> *cash
[21:15:47] <shka> to much programming :D
[21:15:51] <selwyn> haha
[21:16:34] <shka> so anyway, if you currency is gaining value, you want this currency in the wallet, not the foreign currency
[21:16:58] <shka> so exporting does not make sense
[21:17:10] <shka> if anything, inflation increases export
[21:17:22] <shka> that's how Italy operated prior the Euro 
[21:17:31] <selwyn> right
[21:17:35] <shka> and it worked kinda well
[21:18:33] <selwyn> one thing that surprises me about italy, is how genuinely pro-european they are
[21:18:34] <selwyn> considering how badly their economy did after joining the euro
[21:18:56] <shka> don't ask me, i guess historical imperative 
[21:20:23] <selwyn> yeah
[21:23:03] <pjb> A lot of brain washing by the media foremost.
[21:24:19] <shka> it is not like the Italy has strong historical ties to Austria and Germany
[21:25:47] <selwyn> well, north italy sort of does
[21:25:49] <selwyn> burgundy
[21:38:29] <aeth> damn, I never detected the disconnect on cond... I guess I didn't update it to the branch that checked
[21:44:24] *** Joins: cond (~example@user/aeth/bot/cond)
[21:57:40] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 246 seconds)
[22:00:03] *** Joins: notzmv (~zmv@user/notzmv)
[22:07:42] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[22:11:46] *** Joins: derelict (~derelict@user/derelict)
[22:41:18] *** Quits: emacsomancer (~emacsoman@c-174-52-88-123.hsd1.ut.comcast.net) (Read error: Connection reset by peer)
[22:42:55] *** Joins: emacsomancer (~emacsoman@c-174-52-88-123.hsd1.ut.comcast.net)
[22:43:09] *** Joins: selwyn (~selwyn@user/selwyn)
[22:46:41] *** Joins: gilberth_ (~beirc@dynamic-077-003-054-094.77.3.pool.telefonica.de)
[22:46:41] *** ChanServ sets mode: +o gilberth_
[22:49:40] *** Quits: [deleted] (~livoreno@user/notzmv) (Read error: Connection reset by peer)
[22:49:59] *** Joins: livoreno (~livoreno@user/notzmv)
[22:51:47] *** Quits: gilberth_ (~beirc@dynamic-077-003-054-094.77.3.pool.telefonica.de) (Quit: Good bye!)
[22:52:33] <gilberth> Ah, QUIT messages come through, perhaps CL-IRC was doing sth silly here.
[23:00:50] *** Quits: treflip (~user@95.79.32.99) (Remote host closed the connection)
[23:20:07] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[23:25:38] *** Quits: pjb (~pjb@user/pjb) (Ping timeout: 252 seconds)
[23:30:16] *** Quits: brainfunnel (~quassel@176.128.208.46.dyn.plus.net) (Quit: No Ping reply in 180 seconds.)
[23:31:38] *** Joins: brainfunnel (~quassel@176.128.208.46.dyn.plus.net)
[23:53:52] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 246 seconds)
[23:54:45] *** Joins: notzmv (~zmv@user/notzmv)
[23:58:05] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
