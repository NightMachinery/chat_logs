[01:04:12] *** Joins: badone (~badone@209.132.189.152)
[01:12:41] <CarloWood> { cout << e2; } enum E { e1 = 42, e2 };
[01:12:42] <geordi> 43
[01:14:26] <CarloWood> { Foo<e2> foo; cout << TYPE(foo); } enum E { e1 = 42, e2 }; template<E e> class Foo { };
[01:14:27] <geordi> lvalue Foo<e2>
[01:15:30] <CarloWood> { Foo<e2> foo; cout << TYPE(foo); } enum E { e1 = 42, e2 }; struct A { uint32_t m = {}; }; template<E e, A a = {}> class Foo { };
[01:15:31] <geordi> lvalue Foo<e2>
[01:15:50] <CarloWood> { Foo<e2> foo; cout << TYPE(foo); } enum E { e1 = 42, e2 }; struct A { uint32_t m = {}; }; template<E e, A a = { 13 }> class Foo { };
[01:15:50] <geordi> lvalue Foo<e2>
[01:16:15] <CarloWood> { Foo<e2, {14}> foo; cout << TYPE(foo); } enum E { e1 = 42, e2 }; struct A { uint32_t m = {}; }; template<E e, A a = { 13 }> class Foo { };
[01:16:15] <geordi> lvalue Foo<e2, A{14}>
[01:27:22] <CarloWood> { Foo<e2, {14}> foo; cout << TYPE(foo); } enum E { e1 = 42, e2 }; struct A { uint32_t m = {}; }; template<E e, A a = { 13 }> class Foo { };
[01:27:23] <geordi> Same output.
[01:29:33] <CarloWood> { Foo<e2, {14}> foo; cout << TYPE(foo); } enum E { e1 = 42, e2 }; struct A { uint32_t m = {}; }; template<E e, A a = { 13 }> class Foo { }; template<E e, A a> Foo<e, a> create(E e1, A a1) { return Foo<e1, a1>{}; } struct B { auto x = create(e2, A{14}); }; 
[01:29:33] <geordi> error: 'e1' is not a constant expression
[01:29:48] <CarloWood> { Foo<e2, {14}> foo; cout << TYPE(foo); } enum E { e1 = 42, e2 }; struct A { uint32_t m = {}; }; template<E e, A a = { 13 }> class Foo { }; template<E e, A a> Foo<e, a> constexpr create(E e1, A a1) { return Foo<e1, a1>{}; } struct B { auto x = create(e2, A{14}); }; 
[01:29:48] <geordi> Same error.
[01:30:07] <CarloWood> { Foo<e2, {14}> foo; cout << TYPE(foo); } enum E { e1 = 42, e2 }; struct A { uint32_t m = {}; }; template<E e, A a = { 13 }> class Foo { }; template<E e, A a> Foo<e, a> constexpr create(constexpr E e1, constexpr A a1) { return Foo<e1, a1>{}; } struct B { auto x = create(e2, A{14}); }; 
[01:30:07] <geordi> error: a parameter cannot be declared 'constexpr'
[01:30:27] <CarloWood> { Foo<e2, {14}> foo; cout << TYPE(foo); } enum E { e1 = 42, e2 }; struct A { uint32_t m = {}; }; template<E e, A a = { 13 }> class Foo { }; template<E e, A a> Foo<e, a> constexpr create(E e1, A a1) { return Foo<e1, a1>{}; } struct B { auto x = create(e2, A{14}); }; 
[01:30:27] <geordi> error: 'e1' is not a constant expression
[01:30:52] <CarloWood> { Foo<e2, {14}> foo; cout << TYPE(foo); } enum E { e1 = 42, e2 }; struct A { uint32_t m = {}; }; template<E e, A a = { 13 }> class Foo { }; template<E e, A a> Foo<e, a> constexpr create(E _e, A _a) { return Foo<_e, _a>{}; } struct B { auto x = create(e2, A{14}); }; 
[01:30:52] <geordi> error: '_e' is not a constant expression
[01:31:28] <CarloWood> { Foo<e2, {14}> foo; cout << TYPE(foo); } enum E { e1 = 42, e2 }; struct A { uint32_t m = {}; }; template<E e, A a = { 13 }> class Foo { }; template<E e, A a> constexpr Foo<e, a> create(E _e, A _a) { return Foo<_e, _a>{}; } struct B { auto x = create(e2, A{14}); }; 
[01:31:28] <geordi> Same error.
[03:39:53] <CarloWood> {} template<int n = 42> struct A { float m_pi = 3.14; }; template<> class A<13> : A<13> { std::string s; };
[03:39:53] <geordi> error: invalid use of incomplete type 'class A<13>'
[03:40:16] <CarloWood> {} template<int n = 42> struct A { float m_pi = 3.14; }; template<> class A<13> : A<14> { std::string s; };
[03:40:17] <geordi>  
[03:40:46] <CarloWood> {} template<int n = 42> struct A { float m_pi = 3.14; }; template<> class A<13> : A { std::string s; };
[03:40:46] <geordi> error: expected class-name before '{' token
[03:40:54] <CarloWood> {} template<int n = 42> struct A { float m_pi = 3.14; }; template<> class A<13> : A<> { std::string s; };
[03:40:55] <geordi>  
[04:58:47] <CarloWood> { A a{ .y = 42 }; } struct A { private: int x = {}; public int y; };
[04:58:47] <geordi> error: expected ':' before 'int' (fix known)
[04:59:01] <CarloWood> { A a{ .y = 42 }; } struct A { private: int x = {}; public: int y; };
[04:59:01] <geordi> error: designated initializers cannot be used with a non-aggregate type 'A'
[04:59:57] <CarloWood> { A a{ .y = 42 }; } struct A { public: int y; private: int x = {}; };
[04:59:57] <geordi> Same error.
[08:19:17] *** Quits: CarloWood (~LdK13@212-127-230-18.cable.dynamic.v4.ziggo.nl) (Ping timeout: 256 seconds)
[08:49:57] *** Quits: great_taste (~great_tas@user/great-taste/x-5798414) (Quit: Client closed)
[08:56:31] *** Quits: GyrosGeier (~geier@185.27.255.155) (*.net *.split)
[08:56:32] *** Quits: graphitemaster (~graphitem@user/graphitemaster) (*.net *.split)
[08:56:32] *** Quits: blo (~blo@user/blo) (*.net *.split)
[08:56:32] *** Quits: greenbagels (~gb@user/greenbagels) (*.net *.split)
[08:56:32] *** Quits: enrico_ (~enrico@debian/enrico) (*.net *.split)
[08:56:35] *** Quits: nolyc (~nolyc@tinodidriksen.com) (*.net *.split)
[08:56:36] *** Quits: Griwes (~griwes@znc.reaver-project.org) (*.net *.split)
[08:56:37] *** Quits: geordi (~geordi@tinodidriksen.com) (*.net *.split)
[08:56:37] *** Quits: ERROH (~mama@user/mama) (*.net *.split)
[08:56:38] *** Quits: computerquip (sid423484@user/computerquip) (*.net *.split)
[08:56:38] *** Quits: andreyv (~andrey@user/andreyv) (*.net *.split)
[08:58:12] *** Joins: GyrosGeier (~geier@185.27.255.155)
[08:58:12] *** Joins: nolyc (~nolyc@tinodidriksen.com)
[08:58:12] *** Joins: graphitemaster (~graphitem@user/graphitemaster)
[08:58:12] *** Joins: blo (~blo@user/blo)
[08:58:12] *** Joins: computerquip (sid423484@user/computerquip)
[08:58:12] *** Joins: greenbagels (~gb@user/greenbagels)
[08:58:12] *** Joins: enrico_ (~enrico@debian/enrico)
[08:58:12] *** Joins: Griwes (~griwes@znc.reaver-project.org)
[08:58:12] *** Joins: geordi (~geordi@tinodidriksen.com)
[08:58:12] *** Joins: andreyv (~andrey@user/andreyv)
[08:58:12] *** Joins: ERROH (~mama@user/mama)
[08:58:12] *** strontium.libera.chat sets mode: +vv nolyc geordi
[10:27:44] *** Joins: CarloWood (~LdK13@212-127-230-18.cable.dynamic.v4.ziggo.nl)
[13:41:52] *** Quits: badone (~badone@209.132.189.152) (Quit: ZNC 1.7.5 - https://znc.in)
[19:30:46] *** Joins: great_taste (~great_tas@user/great-taste/x-5798414)
[20:43:14] <CarloWood> { B b; } struct A { int n; }; using Ac = A const; struct B : Ac { int x; };
[20:43:14] <geordi>  
[20:43:19] <CarloWood> wuuuuut
[20:43:50] <CarloWood> { B b{ .x = 42 }; cout << b.x; } struct A { int n; }; using Ac = A const; struct B : Ac { int x; };
[20:43:51] <geordi> 42
[20:44:01] <CarloWood> { B b{ .x = 42 }; cout << b.n << ", " << b.x; } struct A { int n; }; using Ac = A const; struct B : Ac { int x; };
[20:44:02] <geordi> 0, 42
[20:44:12] <CarloWood> { B b{ .n = 13, .x = 42 }; cout << b.n << ", " << b.x; } struct A { int n; }; using Ac = A const; struct B : Ac { int x; };
[20:44:12] <geordi> error: 'B' has no non-static data member named 'n'
[20:44:24] <CarloWood> { B b{ {.n = 13}, .x = 42 }; cout << b.n << ", " << b.x; } struct A { int n; }; using Ac = A const; struct B : Ac { int x; };
[20:44:24] <geordi> error: either all initializer clauses should be designated or none of them should be
[20:45:29] <CarloWood> { B b{ {13}, 42 }; cout << b.n << ", " << b.x; } struct A { int n; }; using Ac = A const; struct B : Ac { int x; };
[20:45:30] <geordi> 13, 42
[20:45:45] <CarloWood> { B b{ {13}, 42 }; b.n = 14; cout << b.n << ", " << b.x; } struct A { int n; }; using Ac = A const; struct B : Ac { int x; };
[20:45:46] <geordi> 14, 42
[20:45:52] <CarloWood> { B b{ {13}, 42 }; b.x = 14; cout << b.n << ", " << b.x; } struct A { int n; }; using Ac = A const; struct B : Ac { int x; };
[20:45:52] <geordi> 13, 14
[20:45:55] <CarloWood> grr
[20:46:16] <CarloWood> { B b{ {13}, 42 }; b.n = 14; cout << b.n << ", " << b.x; } struct A { int n; }; using Ac = A const; struct B : Ac { int x; };
[20:46:17] <geordi> 14, 42
[20:54:13] <CarloWood> { B b{A{42}}; cout << b.n; } struct A { int n; };  struct B : protected A { int const& n = A::n; };
[20:54:13] <geordi> error: no matching function for call to 'B::B(<brace-enclosed initializer list>)'
[20:54:41] <CarloWood> { B b{A{42}}; cout << b.n; } struct A { int n; };  struct B : protected A { int const& n = A::n; B(A a) : A(a) { } };
[20:54:42] <geordi> 42
[20:54:46] <CarloWood> { B b{{42}}; cout << b.n; } struct A { int n; };  struct B : protected A { int const& n = A::n; B(A a) : A(a) { } };
[20:54:46] <geordi> 42
[20:54:51] <CarloWood> { B b{42}; cout << b.n; } struct A { int n; };  struct B : protected A { int const& n = A::n; B(A a) : A(a) { } };
[20:54:52] <geordi> error: no matching function for call to 'B::B(<brace-enclosed initializer list>)'
[20:54:55] <CarloWood> { B b{{42}}; cout << b.n; } struct A { int n; };  struct B : protected A { int const& n = A::n; B(A a) : A(a) { } };
[20:54:55] <geordi> 42
[20:55:03] <CarloWood> { B b{{42}}; b.n = 13; cout << b.n; } struct A { int n; };  struct B : protected A { int const& n = A::n; B(A a) : A(a) { } };
[20:55:06] <geordi> error: assignment of read-only location 'b.B::n'
[23:41:04] *** Joins: badone (~badone@209.132.189.136)
