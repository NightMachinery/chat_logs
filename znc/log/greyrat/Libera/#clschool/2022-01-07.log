[00:14:20] *** Quits: artchad (~user@public-gprs233180.centertel.pl) (Read error: Connection reset by peer)
[00:31:08] *** Quits: rotateq (~user@185.66.193.48) (Quit: ERC (IRC client for Emacs 27.2))
[00:34:37] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 240 seconds)
[00:36:04] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[00:38:37] *** Quits: nexeq (~nexeq@user/nexeq) (Read error: Connection reset by peer)
[00:38:46] *** Joins: nexeq (~nexeq@user/nexeq)
[00:52:53] *** Joins: lisp123 (~lisp123@5.30.23.247)
[00:57:37] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[01:17:43] *** Joins: nij- (~jin@2001-48F8-9021-806-0-0-0-619B-dynamic.midco.net)
[01:18:13] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[01:18:41] <nij-> How to make a backup plan when a form returns an error? Something like (if (error-from-p FORM-BODY) (do-this-instead) "GOOD JOB!") .. how to implement #'error-from-p?
[01:34:35] <aeth> handler-
[01:34:43] <aeth> handler-bind and handler-case iirc
[01:35:00] <aeth> https://gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html
[01:35:06] <aeth> http://l1sp.org/search?q=handler
[01:36:34] *** Quits: nexeq (~nexeq@user/nexeq) (Remote host closed the connection)
[01:37:15] *** Joins: nexeq (~nexeq@user/nexeq)
[01:37:34] *** Quits: nexeq (~nexeq@user/nexeq) (Remote host closed the connection)
[01:39:33] *** Joins: nexeq (~nexeq@user/nexeq)
[01:41:00] *** Joins: winning-luser (~winning-l@2601:8c1:80:70d0::4b06)
[01:45:22] *** Quits: nexeq (~nexeq@user/nexeq) (Remote host closed the connection)
[01:45:53] *** Joins: nexeq (~nexeq@user/nexeq)
[01:51:54] *** Quits: winning-luser (~winning-l@2601:8c1:80:70d0::4b06) (Remote host closed the connection)
[02:10:29] <nij-> aeth: Oh! Ok it's time to read this again and really learn it.. I thought this is kinda advance, but it seems to be the right timing. Thanks for the reminder!
[02:16:45] <aeth> you just needed the right magic word
[02:16:48] <aeth> in this case "handler"
[02:18:07] <nij-> Yeah ;)
[02:18:54] <nij-> How to extract strings from an async process? Something like (with-output-to-string (s) (uiop:launch-program (list "echo" "3") :output s)) doesn't do the job :(
[02:23:17] *** Quits: nexeq (~nexeq@user/nexeq) (Remote host closed the connection)
[02:24:18] *** Joins: nexeq (~nexeq@user/nexeq)
[02:26:50] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[02:33:39] *** Quits: Partmedia (~kevinz@097-086-181-165.res.spectrum.com) (Quit: reboot)
[02:34:57] *** Quits: random-nick (~random-ni@87.116.167.125) (Ping timeout: 256 seconds)
[02:47:20] <nij-> Hmm.. I've also tried this: https://bpa.st/2VOQ  Still getting an empty string.
[02:48:15] *** Quits: jeffrey (~jeffrey@2001:1c00:b1c:4100::80c0) (Quit: Client quit)
[02:54:25] *** Joins: lisp123 (~lisp123@5.30.23.247)
[02:58:18] *** Quits: nitrowheels (~nitrowhee@151.95.83.100) (Quit: Leaving)
[02:58:37] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 240 seconds)
[02:59:00] *** Joins: Partmedia (~kevinz@2600:6c40:6400:2f:221:ccff:fe66:4105)
[03:09:23] <White_Flame> nij-: works for me if I do uiop:wait-process before extracting the string
[03:10:36] <White_Flame> https://plaster.tymoon.eu/view/2836#2836
[03:13:35] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[03:13:54] <White_Flame> same as on the repl; even though the process is likely long done, the output string is empty until I wait-process it
[03:14:29] <White_Flame> from the docs "Any asynchronously spawned process requires this function to be run before it is garbage-collected in order to free up resources that might otherwise be irrevocably lost."
[03:14:46] <White_Flame> which likely includes actually closing the streams
[03:31:42] <nij-> White_Flame: Ah thanks! Though #'wait-process makes the whole thing synchronous.. something like `sleep 3; echo 3` will hang say stumpwm if it's evaluated from stumpwm.
[03:32:05] <White_Flame> it's not synchronous
[03:32:35] <White_Flame> if the process output a lot of text, I'm sure it would start flowing even before the process completed, but then that's not the usecase for a string stream
[03:32:54] <White_Flame> you do need to have the stream closed properly
[03:33:25] <White_Flame> you can also poll to see if the program is done yet, and wait-process should return immediately if that's the case
[03:34:03] <White_Flame> in any case, the protocol requires a call to wait-process no matter what
[03:34:50] <White_Flame> you can also spawn a thread that blocks on wait-process if you need it to basically "signal" you when it completes
[03:37:02] <nij-> Hmm. Can I trap #'wait-process in some form, that automatically kills it after a given amount of time?
[03:37:17] <nij-> (trap (wait-process [..]) :timeout 10) 
[03:37:21] <nij-> Things like this @@
[03:40:15] <White_Flame> killing is always a race condition
[03:40:56] <White_Flame> but I would set a timer to do the kill, then block on wait
[03:41:11] <White_Flame> the kill is probably ignored if it already exited
[03:41:15] <nij-> Hmm.. lets not kill it then. I can afford to just abandon it.
[03:41:36] <White_Flame> welcome to distributed programming :-P
[03:42:00] <nij-> I want to wait for it for 10 seconds, and see if it returns any string. If after 10 seconds no string is coming, then abandon the process and move on.
[03:44:01] <White_Flame> that's leaky
[03:44:32] <nij-> better to kill it, you mean?
[03:44:42] <White_Flame> yes
[03:45:03] <White_Flame> wait-process explicitly says you leak resources if you don't call it, presumably that means that it really should return
[03:50:58] <nij-> timeout is what I want: https://common-lisp.net/project/trivial-timeout/
[04:52:50] <White_Flame> ah, I just used teh SBCL ones directly
[04:55:56] *** Joins: lisp123 (~lisp123@5.30.23.247)
[05:00:35] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[05:33:34] *** Quits: Lanny (~Lanny@2600:1700:5f60:d2f:8468:ff44:88cf:d0da) (Quit: Leaving)
[05:52:34] *** Joins: Oladon (~olad@98.43.81.226)
[06:02:37] *** Quits: nij- (~jin@2001-48F8-9021-806-0-0-0-619B-dynamic.midco.net) (Ping timeout: 240 seconds)
[06:38:12] *** Quits: sts-q (~sts-q@212.53.219.230) (Ping timeout: 256 seconds)
[06:47:30] *** Joins: lisp123 (~lisp123@5.30.23.247)
[06:48:55] *** Joins: sts-q (~sts-q@212.53.219.254)
[07:13:16] <lisp123> Morning #CLSCHOOL
[07:13:57] <lisp123> I have a bit of a conuldrum. As I understand, its not possible to specialise on a slot. However say I have 5 classes, and 3 different 'types' of slots, that will create 15 possible combinations
[07:16:46] <lisp123> Any suggestions how to handle CLOS where there can be many classes? Should I mix method specialisation with standard COND tables in that case?
[07:18:57] <CodeBitCookie[m]> Hello Everyone!
[07:20:48] <CodeBitCookie[m]> What would be the best alternative for `stb_image.h`? Asking because I am making an application with CL-OPENGL.
[07:21:10] <CodeBitCookie[m]> ... And want to load a texture.
[07:25:27] <lisp123> CodeBitCookie[m]: You may also wish to try #commonlisp in case you don't get an answer here
[07:25:47] <CodeBitCookie[m]> lisp123: good advice.
[07:26:00] <CodeBitCookie[m]> Although, I already did ask.
[07:26:02] <lisp123> (as its more an 'application' question and I know a lot of them use OPENGL based on the chatlogs)
[07:26:18] <lisp123> ah sorry, perhaps just ping them again, sometimes it gets lost :-)
[07:26:56] <CodeBitCookie[m]> Did that work?
[07:27:23] <lisp123> Yeah, I saw it. Now just wait :-)
[07:27:35] <CodeBitCookie[m]> Are there 2 copies of the message or just one?
[07:27:40] <CodeBitCookie[m]> * lisp123: Are there
[07:28:37] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 240 seconds)
[07:30:25] <beach> Good morning everyone! 
[07:30:44] <CodeBitCookie[m]> gm beach 
[07:36:40] <lisp123> For my earlier question, I think I am going to use EQL specialisation as an alternative. Maybe do some funky stuff with an around methods...lets see how it goes
[08:06:52] *** Quits: lisp123 (~lisp123@5.30.23.247) (Quit: Leaving...)
[08:18:33] *** Joins: seok (~Seok@n114-73-75-18.bla3.nsw.optusnet.com.au)
[08:19:45] *** Quits: seok (~Seok@n114-73-75-18.bla3.nsw.optusnet.com.au) (Client Quit)
[08:47:12] <White_Flame> you can probably do what you want through the MOP
[08:47:34] <White_Flame> but  it does sound like you want your own custom dispatcher, whether your own or mop based
[09:02:50] *** Joins: Jing (~hedgehog@2604:a840:3::103c)
[09:17:03] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[09:54:37] *** Quits: Partmedia (~kevinz@2600:6c40:6400:2f:221:ccff:fe66:4105) (Ping timeout: 240 seconds)
[10:00:31] *** Joins: Partmedia (~kevinz@2600:6c40:6400:2f:221:ccff:fe66:4105)
[10:09:21] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[11:55:53] *** Joins: st_iron (uid370243@id-370243.uxbridge.irccloud.com)
[12:01:20] *** Joins: nij- (~jin@2001-48F8-9021-806-0-0-0-619B-dynamic.midco.net)
[12:21:44] *** Joins: rotateq (~user@p200300e787097300818cd04b4ea1a4f3.dip0.t-ipconnect.de)
[12:34:37] *** Quits: beach (~user@2a01:cb19:150:3400:928b:3395:fe81:c0b2) (Read error: Connection reset by peer)
[12:36:58] *** Joins: beach (~user@2a01:cb19:150:3400:e578:7149:acf:a4d9)
[12:56:17] *** Joins: artchad (~user@public-gprs224306.centertel.pl)
[13:18:17] *** Joins: lisp123 (~lisp123@5.30.23.247)
[13:44:55] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[13:45:58] *** Joins: lisp123 (~lisp123@5.30.23.247)
[13:47:06] *** Quits: nexeq (~nexeq@user/nexeq) (Remote host closed the connection)
[13:48:15] *** Joins: nexeq (~nexeq@user/nexeq)
[14:33:15] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[14:34:15] *** Joins: random-nick (~random-ni@87.116.167.125)
[14:42:50] *** Joins: lisp123 (~lisp123@5.30.23.247)
[16:33:59] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[16:57:30] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[16:59:16] *** Quits: nexeq (~nexeq@user/nexeq) (Remote host closed the connection)
[16:59:32] *** Joins: nexeq (~nexeq@user/nexeq)
[17:00:25] *** Joins: cranium (~cranium@user/cranium)
[17:10:37] *** Quits: nexeq (~nexeq@user/nexeq) (Ping timeout: 240 seconds)
[17:11:46] *** Joins: rain3 (~rain3___@2a02:2f09:d405:a600:7f3e:4e48:ca3c:8857)
[17:17:33] *** Parts: nij- (~jin@2001-48F8-9021-806-0-0-0-619B-dynamic.midco.net) (Using Circe, the loveliest of all IRC clients)
[18:17:39] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[18:46:21] *** Joins: nexeq (~nexeq@user/nexeq)
[18:47:58] *** Quits: nexeq (~nexeq@user/nexeq) (Remote host closed the connection)
[18:48:40] <lisp123> Can anybody send me the chatlog for yesterday? I forgot to save the discussion on lists
[18:48:54] <lisp123> It was a goldmine of tips
[18:50:22] *** Joins: nexeq (~nexeq@user/nexeq)
[18:56:10] <rotateq> you could look for the log
[18:56:26] <lisp123> this channel is not logged :(
[18:56:40] <rotateq> oh noez yes i see now, sry
[19:00:32] <rotateq> so as always, what do i know ..
[19:01:42] <lisp123>  a lot :-)
[19:02:01] <rotateq> :(
[19:02:16] <lisp123> My brain hurts from learning too much today, time to go eat a burger. We have a new place here that's really good
[19:02:38] <rotateq> yes take a step back and eat, i should eat too
[19:02:47] <lisp123> Enjoy :-) Cya later
[19:02:53] <rotateq> okay but surely out of my financial range ^^
[19:03:32] <lisp123> Some burgers ARE getting very expensive
[19:04:00] <lisp123> But IMO they are all hype. THis one is just an Australian fast food company that recently opened up here..first international store, so the quality is good so far
[19:04:06] <lisp123> Enjoy your eve!
[19:04:53] <rotateq> yes one store here has patties based on insects and next time i go there want to try those
[19:05:11] <lisp123> interesting
[19:05:36] *** Quits: lisp123 (~lisp123@5.30.23.247) (Quit: Leaving...)
[19:26:57] *** Quits: Jing (~hedgehog@2604:a840:3::103c) (Remote host closed the connection)
[19:27:25] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[19:27:38] *** Joins: Jing (~hedgehog@2604:a840:3::103c)
[20:30:01] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 268 seconds)
[20:30:48] <pjb> Have you seen the look of insectivores???  https://www.youtube.com/watch?v=Ykv8CYSs0uU
[20:31:03] <pjb> https://youtu.be/Ykv8CYSs0uU?t=60
[20:38:46] <rotateq> video unavailable
[20:39:57] *** Joins: Oladon (~olad@98.43.81.226)
[20:43:51] <artchad> same
[20:44:12] <artchad> great firewall of europe
[20:44:26] <rotateq> yay :D
[20:45:07] <rotateq> and where are you from artchad?
[20:46:37] *** Joins: nij- (~jin@2001-48F8-9021-806-0-0-0-619B-dynamic.midco.net)
[20:46:58] <nij-> What is the plist of a symbol used for usually? I fail to get the point why it was introduced.
[20:47:13] <beach> nij-: Nothing.  
[20:47:26] <beach> nij-: It is there for hysterical raisins. 
[20:47:26] <White_Flame> before hashtables existed, they were very handy for fast key/value lookup
[20:47:37] <White_Flame> but yeah nowadays they're just legacy
[20:47:50] <nij-> hysterical / historical ;)?
[20:48:06] <nij-> I see. Nice to have them around then.
[20:48:07] <White_Flame> Let's say you had a table of 10,000 data items, keyed by symbol
[20:48:13] *** Quits: nexeq (~nexeq@user/nexeq) (Read error: Connection reset by peer)
[20:48:16] <White_Flame> that'd be really slow in a plain a-list
[20:48:29] *** Joins: nexeq (~nexeq@user/nexeq)
[20:49:12] <White_Flame> so, you'd do something like (get 'foo 'my-table) to get the table entry for FOO, and there's generally way fewer than 10,000 uages of FOO as a key
[20:49:25] <White_Flame> so the plist is small
[20:49:45] <nij-> gotcha
[20:50:19] <White_Flame> it's still rarely used for annotations on things that are named by symbol.  if you have the interned symbol object, then you don't need to go searching using it as a key
[20:50:46] *** Quits: Jing (~hedgehog@2604:a840:3::103c) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[20:51:08] <White_Flame> but an issue is that it's impossible to clean up, compared to having those annotations in a hashtable keyed by symbol
[20:51:16] <beach> In the past, it was used to store things like function or macro definitions.
[20:51:26] <White_Flame> (well, I guess you could iterate all the symbols in the image, but that's pretty brute force)
[20:51:42] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[20:51:49] <White_Flame> beach: cool, I wasn't certain of that
[20:52:33] <beach> I forget whether that was the case in Maclisp, but I have definitely seen it.
[20:52:39] <beach> Maybe in Franz Lisp?
[20:52:47] <beach> *sigh* memory!
[20:52:47] <nij-> Next question - what does the word "construct" mean in "loop construct", "do construct"..?
[20:53:12] <beach> Is there such a LOOP keyword?
[20:53:18] <beach> Doesn't ring a bell.
[20:53:38] <rotateq> Me neither.
[20:53:39] <beach> Oh, as terminology...
[20:53:57] <beach> nij-: It's used as its ordinary English meaning there.
[20:54:01] <White_Flame> usually a syntactic construction/pattern
[20:54:06] <bremner>  construct == thingy
[20:54:19] <artchad> rotateq: I'm from central Europe. Germany/Poland
[20:54:23] <White_Flame> since they're macros with their own placement of things & sub-language terms as in LOOP
[20:54:38] <beach> Yes, "pattern", "edifice".
[20:54:39] <nij-> Gotcha. Can I call it a "loop form" to make it more formal?
[20:54:45] <White_Flame> sure
[20:54:47] <nij-> Or "a form that starts with LOOP"
[20:55:07] <rotateq> artchad: So we're not far away from each other. :) But I'm more from western Germany.
[20:55:44] <artchad> Well, the plist os the symbol is still there. Is there any good reason why anyone would consider it bad practice to use that field to have associate more data with the symbol?
[20:55:45] <beach> nij-: "LOOP form is fine".  
[20:55:58] <White_Flame> artchad: cleanup, collision
[20:56:16] <White_Flame> (although collision is quite well mitigated by the key as a symbol in a package)
[20:56:26] <artchad> that's a new concept for me. Could you elaborate?
[20:56:42] <White_Flame> how do you wipe information that's spread across arbitrary symbols?
[20:56:53] <artchad> I know of symbol collision when importing a package that contains an already used symbol.
[20:57:21] <artchad> > how do you wipe information that's spread across arbitrary symbols? You setf it to NIL?
[20:57:22] <White_Flame> if the plist keys are :keywords, then collision is much easier
[20:57:33] <White_Flame> artchad: but you don't know which symbols have been annotatee
[20:57:35] <White_Flame> *annotated
[20:58:26] <artchad> Honestly, I think I would need an example to understand that. 
[20:59:02] <White_Flame> let's say that you have an index of names, and you store info on symbols based on the last name
[20:59:10] <White_Flame> so for "White Flame", the symbol FLAME would hold my entry
[20:59:17] <artchad> sure
[20:59:19] <White_Flame> and you have a ton of names stored
[20:59:39] <White_Flame> now you want to deal with another database of names, and thus clear the old (since symbols & their plists are fully global)
[21:00:03] <White_Flame> unless you specifically tracked those, the symbols who hold the data are simply dispersed around the image
[21:00:20] <White_Flame> and only referenced when you have a last name to look up
[21:01:07] <artchad> I'll come back to that if I ever find a good usecase for that plist.
[21:01:29] <White_Flame> as I mentioned, hash tables obsoleted that storage style of keyed info
[21:02:09] <White_Flame> so it's just an anachronism anyway
[21:02:27] <artchad> Yeah, it's not per se bad to store data inside a symbol I'd say. But the real question is why would anyone want to do that.
[21:02:29] <White_Flame> but I've gone through a fair amount of ancient AI code to have seen a lot of that style of usage
[21:02:38] *** Joins: Josh_2 (~user@37.25.47.130)
[21:02:43] <White_Flame> because it's fast, if you have no hashtable
[21:02:49] <artchad> lol
[21:02:55] <White_Flame> and machines were slooooooow
[21:02:56] <artchad> but we have those in common lisp :D
[21:03:25] <White_Flame> right, and common lisp brought together a bunch of lisp diaspora into a single language, including a lot of compatibility & legacy
[21:03:42] <aeth> that's also why the argument order in GETHASH is backwards (unless this was already mentioned in the backlog)
[21:03:59] <White_Flame> 'twasn't
[21:04:06] <aeth> (gethash key object) when normally it's (foo object whatever) e.g. AREF (although NTH does use the "wrong" order, too)
[21:04:18] <aeth> because the fake-hash-table uses the same order
[21:04:43] <White_Flame> right, (get symbol table-name) for this style of plist usage
[21:04:53] <White_Flame> (gethash symbol hashtable-object)
[21:04:56] <aeth> ofc there it makes sense because you're getting from the symbol
[21:22:32] *** Quits: emacsomancer (~emacsoman@136.60.128.68) (Ping timeout: 240 seconds)
[21:24:01] *** Joins: emacsomancer (~emacsoman@136.60.128.68)
[21:31:41] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 268 seconds)
[21:33:28] *** Joins: waleee (~waleee@h-98-128-229-110.na.cust.bahnhof.se)
[21:40:46] *** Quits: nij- (~jin@2001-48F8-9021-806-0-0-0-619B-dynamic.midco.net) (Quit: Using Circe, the loveliest of all IRC clients)
[21:55:05] *** Quits: nexeq (~nexeq@user/nexeq) (Remote host closed the connection)
[21:55:42] *** Joins: nexeq (~nexeq@user/nexeq)
[22:52:32] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[23:05:49] *** Quits: rain3 (~rain3___@2a02:2f09:d405:a600:7f3e:4e48:ca3c:8857) (Ping timeout: 240 seconds)
