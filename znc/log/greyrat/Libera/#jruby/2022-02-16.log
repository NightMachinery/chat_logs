[00:11:06] *** Joins: dangerousdave (~dangerous@host-92-16-220-133.as13285.net)
[02:16:16] <byteit101[m]> enebo: won't have time to fully respond for another few hours, but quick points: "unless our convert itself has special logic" <- that is one place I wasn't sure, and the other reason for specifying the class that I know of is numerics. 2) " it will definitely not be easier to remember that + verb" That's the point, see one of my earlier comments in the PR on why that was one of my goals. I'm curious if you disagree with the reasoning
[02:16:57] <enebo[m]> byteit101: I did read it which was why I mentioned verb being more difficult to remember
[02:18:20] <enebo[m]> but think about a specific convert using numeric because I am not sure I understand how that would work in practice
[02:18:32] <enebo[m]> we can talk about both of those more when you have the time
[02:51:28] *** Quits: siasmj (sid6106@2a03:5180:f:2::17da) (*.net *.split)
[02:53:32] *** Joins: siasmj (sid6106@2a03:5180:f:2::17da)
[03:14:41] *** Quits: dangerousdave (~dangerous@host-92-16-220-133.as13285.net) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[06:16:00] <byteit101[m]> Yay, free time! Ok, so you disagree with my reasoning and prefer just "instance_variable"? (sorry, having a hard time following the conversation from earlier)
[06:17:01] <byteit101[m]> > headius: there may be a better example as part of jrubyfx
[06:17:01] <byteit101[m]> Nope, jrubyfx (will) use this as part of the fxmlloader, which is write-only, and happens once. so it currently says `                java_field "@javafx.fxml.FXML java.lang.Object #{value}", bind_variable: true` (old syntax)
[06:17:26] <byteit101[m]> and if users want to reassign their ivars, it will save the wrapped IRO instead of unwrapipng and re-wrapping
[06:17:31] <byteit101[m]> so no conversion necessary
[06:17:50] <byteit101[m]> If javafx needed to read those variables again, then I would need to convert there
[06:17:58] <byteit101[m]> but this way keeps the most ruby semantics
[06:34:18] <byteit101[m]> I should be free to discuss this more  all afternoon tomorrow
[11:25:43] *** Joins: dangerousdave (~dangerous@host-92-16-220-133.as13285.net)
[11:25:48] *** Quits: dangerousdave (~dangerous@host-92-16-220-133.as13285.net) (Client Quit)
[11:52:08] *** Joins: dangerousdave (~dangerous@host-92-16-220-133.as13285.net)
[12:02:19] *** Quits: dangerousdave (~dangerous@host-92-16-220-133.as13285.net) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[12:32:50] *** Joins: dangerousdave (~dangerous@host-92-16-220-133.as13285.net)
[12:44:40] *** Quits: dangerousdave (~dangerous@host-92-16-220-133.as13285.net) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[12:53:09] *** Joins: dangerousdave (~dangerous@host-92-16-220-133.as13285.net)
[15:14:21] *** Quits: dangerousdave (~dangerous@host-92-16-220-133.as13285.net) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[15:36:20] *** Joins: dangerousdave (~dangerous@host-92-16-220-133.as13285.net)
[16:00:08] *** Quits: dangerousdave (~dangerous@host-92-16-220-133.as13285.net) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[16:04:10] *** Joins: dangerousdave (~dangerous@host-92-16-220-133.as13285.net)
[16:30:53] *** Quits: dangerousdave (~dangerous@host-92-16-220-133.as13285.net) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[16:32:30] *** Joins: dangerousdave (~dangerous@host-92-16-220-133.as13285.net)
[17:53:18] <enebo[m]> byteit101: I added a comment to the issue which I hope will make this discussion easier
[18:04:06] *** Quits: dangerousdave (~dangerous@host-92-16-220-133.as13285.net) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[18:12:27] *** Joins: dangerousdave (~dangerous@host-92-16-220-133.as13285.net)
[19:28:53] <headius> I do prefer just instance_variable for naming the binding bar. No strong opinion on convert: because it's doing a couple things
[19:29:05] <headius> s/bar/var/
[19:31:29] *** Quits: dangerousdave (~dangerous@host-92-16-220-133.as13285.net) (Quit: Textual IRC Client: www.textualapp.com)
[20:03:40] <headius> looks like I managed to rewrite a define_method block to super the name that was defined but a break_spec spec broke
[20:03:55] <headius> how many specs would a break spec break if a break spec broke break specs
[20:04:18] <headius> wondering if this is something that broke due to the cloning
[20:05:02] <enebo[m]> headius: are you putting it into a method at that point like the original optimization?
[20:05:42] <headius> no, I am always cloning the IRClosure and putting it into a new MixedModeIRBlockBody with a new Block object around it but the same binding
[20:05:56] <headius> if that proceeds on to the method conversion so be it
[20:06:16] <headius> so if it is not methodizable it will still be cloned and rewritten but stay a block
[20:06:25] <enebo[m]> hmm I wonder if it lost any state during the clone for flags
[20:06:32] <headius> yeah something like that I'm thinking
[20:06:46] <enebo[m]> It is possible I did not copy that state in clone not realizing I should
[20:07:08] * headius sent a code block: https://libera.ems.host/_matrix/media/r0/download/libera.chat/c0b3398cf80147b80a333c97ddf0307f4e3997d2
[20:07:15] <headius> that's the one that fails
[20:07:23] <headius> it actually kills the whole spec run so the break is losing its target
[20:07:44] <enebo[m]> Probably not cloning hasBreakInstructions
[20:08:08] <enebo[m]> I am guessing none of this state is preserved in clone constructors and it was an oversight
[20:08:18] <headius> hmmm ok
[20:08:41] <enebo[m]> The IRScope constructor saying it is for cloning does not seem to do anything
[20:08:41] <headius> I can probably get this to a small example that I can manually diff the IR
[20:09:01] <headius> oh wait
[20:09:08] <headius> there's no define_method here so I am not cloning
[20:09:28] <enebo[m]> hah yeah
[20:09:49] <enebo[m]> So you may want to make these are even running before your changes
[20:09:56] <headius> I made some changes to how supers are built so more of them would resolve
[20:10:11] <headius> yeah I will look into the other changes I have locally
[20:10:12] <enebo[m]> Maybe we have some test walk off the edge of some source and now you caused it to start working or something like that
[20:10:42] <headius> this might be due to the way I changed builder to detect if a super happens in a method within a class or module
[20:11:15] <enebo[m]> anyways...we are not cloning all those booleans
[20:11:43] <enebo[m]> I think that should happen since they are largely only setup during IRBuild at this point and are intended to always be true about the scope
[20:11:57] <enebo[m]> as it stands the clone will contain them and everything will be false
[20:12:35] <headius> I do force a full build before I clone
[20:13:03] <enebo[m]> This does make me wonder though.  If you are removing super then usesSuper may become false (this flag also examines the contained lexical closures so it is not trivial)
[20:13:08] <headius> not sure if that bypasses some of the logic that needs the flags but it is at least full structure and protocol
[20:13:11] <enebo[m]> full build will probably not affect there booleans at all
[20:13:16] <enebo[m]> or not many of them
[20:13:46] <headius> ok I see
[20:14:09] <headius> I converted this super into a ModuleSuper from UnresolvedSuper, but UnresolvedSuper has additional logic for when it receives a literal block
[20:14:11] <headius> I need to restore that
[20:14:39] <enebo[m]> If you build full before you clone we may not care about the flags at that point and it might just work but if that new code JITs it may try to run more passes and then it will not have access to those flags
[20:15:20] <headius> yeah unsure
[20:15:45] <enebo[m]> prepareFull does less than prepareForCompilation so I think there is a good chance things will go south
[20:16:12] <enebo[m]> but in any case if we clone something we should make sure we update those flags
[20:16:20] <headius> ok duh this was an easy fix
[20:16:38] <headius> if the super has a literal block it needs to call through the "iter" logic that marks the block as escaped after the super returns
[20:16:46] <enebo[m]> The only second thing on top of that is that we maybe can untoggle something like usesZSuper if we make sure nothing is doing zsuper any more
[20:17:20] <enebo[m]> but I would guess we clone all flag fields and the modify that state off right after we construct
[20:17:35] <headius> I got confused about the literal block and thought it referred to the container of the super, not the block passed to the super
[20:17:44] <enebo[m]> ah
[21:20:23] <headius> enebo: I pushed current experiments here: https://github.com/jruby/jruby/pull/7098
[21:21:10] <headius> I have one failure due to not using "class super" logic for a define_method in a singleton, and another that appears to be using the wrong name and not getting rewritten properly
[21:21:46] <headius> oh I see the problem there... I'm not recursing through all nested closures
[21:21:53] <headius> so those are straightforward fixes
[21:22:19] <headius> this should mean that all supers are now using a static name, except for ones that would not be valid anyway (super in a block at toplevel or in a class body, etc)
[21:22:41] <headius> I don't feel great about how I'm doing the rewriting
[21:23:06] <headius> it is obviously heavy but also feels like I'm poking around the guts of IR/BB too much
[21:53:48] <enebo[m]> When you get things working we can examine what we can do to make it simpler
[22:33:44] *** Joins: subbu (~subbu@user/subbu)
