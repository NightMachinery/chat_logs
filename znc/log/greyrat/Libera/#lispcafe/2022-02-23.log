[00:01:36] <masinter> it's like a statue of Robert E Lee
[00:05:00] <selwyn> why did poland participate in the 1905 russian revolution but not the revolutions of 1917
[00:05:17] <shka> ... what?
[00:05:42] <shka> selwyn: poland did not exist at the time
[00:05:59] <selwyn> well, polish people, whatever
[00:06:03] <shka> right
[00:06:40] <shka> well, the point is that at the time the most awesome thing happens
[00:06:43] <shka> namely
[00:06:59] <shka> both Imperial Germany and Imperial Russia die
[00:07:10] <shka> so there is space to reform the Poland
[00:07:25] <selwyn> and poland lived happily ever after
[00:07:35] <shka> well, there was that WW2 thing
[00:07:45] <shka> but yeah, communism was the best thing ever for Poland
[00:07:52] <shka> it killed the Empire 
[00:08:12] <shka> and then USSR collapsed because it can't into economy
[00:08:32] <shka> meanwhile super-murdering nazis, which was a good thing obviously 
[00:09:05] <shka> so in summary, if not for the communism, Poland as an independent country would not exist today
[00:09:59] <shka> selwyn: you must realize that Poles were never pro-Russian or pro-German
[00:10:12] <shka> they were either more anti-Russian or anti-German :P
[00:10:23] <selwyn> i see
[00:10:44] <shka> nobody at the time was expecting that both great powers would collapse at the same time
[00:19:13] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Remote host closed the connection)
[00:28:25] *** Quits: mgl (~mgl@cpc87455-finc19-2-0-cust234.4-2.cable.virginm.net) (Ping timeout: 256 seconds)
[00:45:02] *** Quits: scymtym (~user@2001:638:504:20e6:6ac3:87e0:e782:f3fc) (Ping timeout: 260 seconds)
[00:48:22] *** Quits: shka (~herr@109.231.3.55) (Ping timeout: 272 seconds)
[00:59:35] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[01:10:46] *** Joins: scymtym (~user@ip-094-114-248-079.um31.pools.vodafone-ip.de)
[01:21:32] *** Joins: vms14 (~user@29.red-79-153-202.dynamicip.rima-tde.net)
[01:22:05] <vms14> I've changed a bit the bookmark to turn a "night mode" in the current website
[01:22:18] <vms14> javascript:(function(){Array.prototype.forEach.call(document.getElementsByTagName("*"),function(element){element.style.fontSize="24px";element.style.padding="3px";element.style.fontFamily="Quicksand";element.style.color="white";element.style.background = "black";if(element.tagName == "A"){element.style.color="orange"}})})()
[01:22:20] <vms14> xd
[01:22:35] <vms14> kind of works, at least a bit better than before
[01:22:57] <vms14> but if you plan to copypaste it, change the element.style.fontFamily="Quicksand"
[01:23:22] <vms14> quicksand is a gay font I've found https://www.fontsquirrel.com/fonts/quicksand
[01:23:24] -ixelp- Font Squirrel | Quicksand Font Free by Andrew Paglinawan
[01:25:42] <vms14> https://i.imgur.com/sUmu0ah.png this is stackoverflow
[01:27:37] <vms14> it'ss mostly for the webpages that are very simple with a killing black background
[01:27:45] <vms14> white*
[01:31:16] <vms14> what do you think abou prolog?
[01:31:21] *** Joins: dec0d3r (~dec0d3r@2001:8003:480a:e00:e07:e7c3:7efc:ed0f)
[01:31:25] <vms14> did you at least tried it?
[01:33:27] <vms14> I know a guy who likes it and he some day told me prolog has nothing to envy from lisp
[01:34:09] <vms14> also a quick search seems to say prolog has some kind of reflection and homoiconity
[01:34:31] <vms14> and there is a mix of haskell and prolog that seems to be a very nice debugger
[01:34:40] <vms14> have*
[01:35:26] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[01:37:36] *** Joins: Brucio-61 (~Brucio-15@ip-094-114-248-079.um31.pools.vodafone-ip.de)
[01:44:27] *** Quits: vms14 (~user@29.red-79-153-202.dynamicip.rima-tde.net) (Remote host closed the connection)
[02:00:28] <epony> what collapsed? where?
[02:01:40] <epony> you know why you're using latin instead of cyrillic script?
[02:06:02] <epony> https://en.wikipedia.org/wiki/Cyrillization_of_Polish
[02:13:11] <epony> https://en.wikipedia.org/wiki/Category:Slavic_language_histories
[02:13:33] <epony> https://en.wikipedia.org/wiki/Old_Polish#History "latinization"
[02:17:18] <epony> https://en.wikipedia.org/wiki/Early_Slavs#Homeland
[02:21:07] <epony> https://en.wikipedia.org/wiki/History_of_Poland#Formation_of_modern_Polish_society_under_foreign_rule_(1864%E2%80%931914)
[02:21:48] <epony> keep telling yourself that, at home dinners on Sundays.. and see what happens  Feb22 2239<shka> selwyn: you must realize that Poles were never pro-Russian or pro-German
[02:25:27] <epony> double heil, to both invaders  https://upload.wikimedia.org/wikipedia/en/4/42/Wyszy%C5%84ski.jpg
[02:26:53] *** Quits: kevingal (~quassel@2a02:8084:4140:f300:1d8d:6d27:28bf:5b00) (Remote host closed the connection)
[02:28:02] <epony> the biggest successes of the roman latinization: Poland under WW2 and Yugoslavia cancellation after the cold war
[02:28:34] <epony> do Ukrainians want the latin script or the roman pope?
[02:28:45] <epony> did you want it?
[02:29:09] <White_Flame> Putin should invade canada, purely for the opportunity to create Putin Poutine
[02:29:51] <moon-child> :<
[02:30:15] <hayley> vms14: no
[02:30:15] <epony> Russia invades only its own lands after they were captured by romans latins and arabs and turks
[02:30:18] <moon-child> I came came here because the sociopolitical situation was supposed to be _better_ than down south
[02:30:50] * selwyn has writers block
[02:30:54] <selwyn> or maybe fatigue
[02:31:15] <epony> you should stop invading Russian lands if you want your ass to not be slapped red and stamped USSR
[02:32:03] <epony> try your luck with India, I heard they like British royal cake
[02:34:28] <epony> muahahaha sahib I am calling you from teh microsoft tech support bangalore you have a why-russ?
[02:34:38] * hayley has writers dead
[02:37:05] * White_Flame has writer's foot
[02:38:06] *** Quits: pjb (~pjb@user/pjb) (Ping timeout: 252 seconds)
[02:38:23] <epony> unfuck your creativity with a quick dictionary random article  https://en.wiktionary.org/wiki/random
[02:38:24] -ixelp- random - Wiktionary
[02:39:56] <hayley> https://www.youtube.com/watch?v=e1X3RBFVgjo
[02:39:57] -ixelp- Random - YouTube
[02:41:18] <masinter> I use a random utility to decide what github Interlisp issue to work on
[02:42:25] <masinter> https://github.com/Interlisp/medley/blob/promote-internal/scripts/pick-issue
[02:42:26] -ixelp- medley/pick-issue at promote-internal · Interlisp/medley · GitHub
[02:43:29] <masinter> shell is a kind of lisp
[02:44:25] <moon-child> I did lambda calculus in shell
[02:44:33] <moon-child> no mutation, but it wouldn't've been hard to add
[02:44:37] <moon-child> I have no idea how you gc, though
[02:44:49] <hayley> I just wait to see which one I get bitten by first.
[02:45:40] <masinter> csh is more lispy than sh
[02:48:56] <hayley> moon-child: Copy out live data to a new script, exec sh data.sh
[02:49:53] <moon-child> hayley: can do a normal allocator; the question is, how do you know what your roots are?
[02:50:36] * hayley shrugs
[02:50:59] <hayley> Just go full on Cheney on the MTA?
[02:52:18] <moon-child> in shell?
[02:52:36] <moon-child> also: I want to use the shell conventions for passing and returning values
[02:55:40] <selwyn> halp
[02:57:31] <selwyn> https://pbs.twimg.com/media/FMO6LvkX0AssmcO.png
[02:58:26] * Gnuxie uploaded an image: image.png
[02:59:35] * moon-child uploaded a chirping bird in a meadow
[03:07:25] <hayley> https://www.reddit.com/r/programmingcirclejerk/comments/sytnjh/a_good_programmer_should_wake_up_at_6_am_in_the/ beach_irl
[03:07:27] -ixelp- A good programmer should wake up at 6 am in the morning get a solid 2.5hrs of coding done by 8:30 am (it goes without sa [...]
[03:11:01] *** Joins: vms14 (~user@29.red-79-153-202.dynamicip.rima-tde.net)
[03:11:22] <vms14> gilberth: I try to fight against the reverse polish notation
[03:11:29] <vms14> I think I win
[03:14:41] <vms14> https://termbin.com/u4oo
[03:14:46] <vms14> it's in lisp
[03:15:07] <vms14> the words force the execution of the next word if they need arguments
[03:15:35] <vms14> if there is no more words to execute words are taken from input
[03:16:13] <vms14> now I just need to specify the number of arguments a word needs and execute this number of words
[03:16:53] <vms14> but something is broken with this method I think 
[03:17:59] <epony> the reversed statement is also valid, lisp is a kind of shell scripting  Feb23 0113<masinter> shell is a kind of lisp
[03:19:20] *** Quits: cosimone (~user@93-34-132-33.ip49.fastwebnet.it) (Quit: ERC (IRC client for Emacs 27.1))
[03:19:37] <vms14> actually you can have a mix of reverse notation words and "normal" ones
[03:19:54] <epony> https://en.wikipedia.org/wiki/Scripting_language#Notable_examples
[03:20:05] <vms14> the reverse ones just take items from the stack and the others force execution of next words
[03:20:29] <vms14> this is why i think something is broken there
[03:20:47] <epony> https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Scripting_languages
[03:21:32] <masinter> especially the kinds of things people develop for "dev ops"
[03:21:58] <vms14> the repl can be (loop (exec-next-word)) xd
[03:22:05] <epony> also polish notation is from stack machines and reverse is from calculators
[03:22:29] <epony> nothing to fight about that, it's just in decline when it comes to computing
[03:22:32] <epony> :-D
[03:23:45] <masinter> compiling lisp to bytecodes puts the function call afteer pushing the arguments
[03:24:09] <epony> https://en.wikipedia.org/wiki/Polish_notation#Implementations
[03:24:17] <epony> https://en.wikipedia.org/wiki/Reverse_Polish_notation#Practical_implications
[03:24:17] <masinter> (cons a b) => [push a] [push b] [call cons]
[03:24:31] <epony> of course
[03:24:35] <epony> that's how assembler works
[03:25:01] <epony> loads operands in registers then the instruction
[03:25:31] <epony> (on a deeper level how most microprossors and their decoding units process these)
[03:26:02] <masinter> webasm is a stack machine?
[03:26:59] <masinter> no registers
[03:27:45] <hayley> There are local variables in wasm. 
[03:27:58] <epony> https://en.wikipedia.org/wiki/Hungarian_notation#Systems_Hungarian_vs._Apps_Hungarian
[03:28:03] <hayley> You can execute WASM programs on a stack machine, but WASM is more restrictive than your typical stack machine.
[03:28:22] <epony> https://en.wikipedia.org/wiki/PascalCase#Computer_programming
[03:28:32] <hayley> https://github.com/no-defun-allowed/wasm2ps/blob/master/Code/convert.lisp
[03:28:33] -ixelp- wasm2ps/convert.lisp at master · no-defun-allowed/wasm2ps · GitHub
[03:29:36] <moon-child> masinter: you can do either way.  push a; push b; push cons; call, or: push cons; push a; push b; call
[03:29:52] <moon-child> and the overhead of an indirect call is not bad given interpretive overhead
[03:30:29] <epony> https://en.wikipedia.org/wiki/Charles_Simonyi#Career
[03:32:01] <epony> "Simonyi introduced the concept of metaprogramming at Microsoft, turning it into what people sometimes referred to as a software factory, but the metaprogramming concept "did not work out in practice."
[03:32:36] <epony> "Simonyi introduced to Microsoft the techniques of object-oriented programming that he had learned at Xerox. He developed the Hungarian notation convention for naming variables. These standards were originally part of his doctoral thesis. The Hungarian notation has been widely used inside Microsoft."
[03:33:11] <masinter> yeah it was just variable names, not an algorithmic notation
[03:33:44] <masinter> as a way of being obvious about types
[03:33:59] <masinter> not so useful in Lisp
[03:37:13] <epony> see the note about "meta" not working ;-)
[03:37:17] <epony> sting
[03:41:38] <masinter> before CLOS there was 3-Lisp
[03:42:21] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Remote host closed the connection)
[03:42:28] <masinter> I hope to revive Gregor's implementation
[03:42:45] <epony> sounds like we should know which Gregor that is
[03:42:56] <epony> or that a name dropped from "alien space" rings bells
[03:43:14] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Remote host closed the connection)
[03:43:37] <masinter> Kizalis; simonyi's bio mentions him
[03:43:40] <epony> it's not your fault, just people talk like it's supposed to be some luminary professor or pioneer of computing.. and nobody knows who is that
[03:44:16] <epony> well, have to first learn of the "simony" value..
[03:44:37] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[03:45:06] <masinter> 4:00 PM epony: https://en.wikipedia.org/wiki/Charles_Simonyi#Career
[03:45:22] <epony> ya ya
[03:48:07] <epony> the person is 73 ;-) looks younger on the photo
[03:49:47] <epony> https://en.wikipedia.org/wiki/Intentional_programming#Similar_works
[03:51:54] <masinter> https://cdr.common-lisp.dev/document/1/
[03:51:55] -ixelp- CDR 1: The CLOS Metaobject Protocol
[04:07:42] *** Quits: vms14 (~user@29.red-79-153-202.dynamicip.rima-tde.net) (Remote host closed the connection)
[04:10:36] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[04:15:28] <epony> next year, CDRW ;-)
[04:15:47] <epony> imagine if you could change directory to the left..
[04:16:20] <epony> car cad cdr
[04:16:26] <epony> cdrom
[04:17:23] <hayley> "In this course, you will be assessed through a team project assignment with three milestones and individual assessments. For the project, you are expected to work in teams of 3-4." Shit.
[04:17:30] <hayley> Who wants to be in my software engineering class team?
[04:27:58] <epony> your classmates ;-) sign me up
[04:29:21] <epony> just joking.. I just need Perl modules in "shell"
[04:37:03] <hayley> https://www.youtube.com/watch?v=K1h8ayp6SA8
[04:37:03] -ixelp- The Queen tests positive for COVID-19 | Coronavirus | 9 News Australia - YouTube
[04:37:23] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Remote host closed the connection)
[04:37:42] *** Parts: masinter (~masinter@c-73-158-116-21.hsd1.ca.comcast.net) ()
[04:38:59] <White_Flame> This was her chance to outlive charles, but I think he got over his covid
[04:39:57] <hayley> Hopefully I'll get to play The Smiths very loud pretty soon.
[04:42:00] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[04:47:10] *** Joins: humasect (~humasect@2001:1970:57e0:4100::1ae0)
[04:47:24] *** Quits: humasect (~humasect@2001:1970:57e0:4100::1ae0) (Read error: Connection reset by peer)
[04:55:14] *** Quits: eugercek (~user@user/eugercek) (Remote host closed the connection)
[04:55:25] *** Joins: christophergray (~christoph@186.151.17.62)
[04:55:31] *** Joins: eugercek (~user@user/eugercek)
[04:57:28] *** Quits: eugercek (~user@user/eugercek) (Remote host closed the connection)
[04:57:44] *** Joins: eugercek (~user@user/eugercek)
[04:59:29] *** Quits: eugercek (~user@user/eugercek) (Read error: Connection reset by peer)
[05:03:56] *** Quits: christophergray (~christoph@186.151.17.62) (Quit: WeeChat 3.4)
[05:05:16] <aeth> It's still 2022-02-22 where I am. Less than 2 hours to 2022-02-22T22:22-05:00
[05:28:36] *** Joins: dave0 (~davezero@069.d.003.ncl.iprimus.net.au)
[05:43:14] <hayley> I've asked on Garry's Mod, so I'll ask here too.
[05:43:14] <hayley> Anyone hiring?
[05:44:08] *** Quits: random-nick (~random-ni@87.116.179.129) (Ping timeout: 272 seconds)
[05:50:57] *** Quits: derelict (derelict@user/derelict) (Quit: bye)
[05:51:59] *** Joins: derelict (derelict@user/derelict)
[06:15:02] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 240 seconds)
[06:30:58] *** Joins: pjb (~pjb@user/pjb)
[06:35:22] <epony> imagine +02:22 or -20:22
[06:36:39] <epony> also, what about the last :22(seconds)
[06:36:58] <epony> https://en.wikipedia.org/wiki/ISO_8601
[06:37:18] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 250 seconds)
[06:39:38] *** Joins: notzmv (~zmv@user/notzmv)
[07:23:42] *** Quits: jeosol (~jeosol@user/jeosol) (Quit: Client closed)
[07:29:53] *** Joins: jeosol (~jeosol@user/jeosol)
[07:33:16] <edgar-rft> timezones are plain bogus anyway, let's compute everything on earth in sideral time
[07:37:29] *** Quits: dec0d3r (~dec0d3r@2001:8003:480a:e00:e07:e7c3:7efc:ed0f) (Quit: Leaving)
[07:51:40] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Remote host closed the connection)
[08:02:39] *** Joins: semz_ (~semz@user/semz)
[08:04:56] *** Quits: semz (~semz@user/semz) (Ping timeout: 245 seconds)
[08:05:04] <White_Flame> or fractions of orbit around the galactic center
[08:05:57] <moon-child> tai!
[09:02:42] * contrapunctus tries reading the Hopscotch paper, and almost, but not quite, entirely fails to understand it.
[09:23:23] <hayley> https://www.skynews.com.au/world-news/global-affairs/fullscale-invasion-of-ukraine-likely-in-24-hours-australia-begins-russia-sanctions/video/82c97329e1aac14a20f06f9df6474d56
[09:24:00] *** Joins: masinter (~masinter@c-73-158-116-21.hsd1.ca.comcast.net)
[09:53:38] <gilberth> I wonder, if I could write a kind of decompiler. I have this mulisp 8080 binary. I already identified what is code and what is data especially wrt to indirect jumps. I can compile it is fine to a large switch statement on the pc. However, I'd like to identify subroutines, so that the host language's control stack could be used. I wonder what that would take.
[09:54:59] <gilberth> One problem I face is that one subroutine often happily jumps into a tail of another, which could be regarded as tail calls, if it weren't for the stack.
[09:59:04] <gilberth> Perhaps I pretend the 8080 would have two stacks, a control stack and a data stack and see what I get. Hmm.
[10:02:09] <gilberth> I only have seen two spots where that is violated and that is where an indirect jmp is forged. For some reason that is done by pushing the jump target and then doing RET.
[10:02:53] <gilberth> Perhaps the PCHL instruction was missed? idk. All in all there is no self-modifying code, which is good news.
[10:04:23] <moon-child> not hard to bail when you do get serious abuse, and peephole when the stack is 'unbalanced' for ret-jmp forgery
[10:05:47] <gilberth> Yep. I am not concerned about that, it is two spots that I can manually identify. And I have to look at THROW.
[10:07:01] <gilberth> Oops, there is no THROW? Curious.
[10:09:12] <gilberth> Anyhow, I need to keep the data stack and the registers global because of the GC. Otherwise I could also do some data flow analysis to identify what would be lexicals. Also for things like PUSH D ; CALL BLAH ; POP D -- But can't.
[10:11:42] * gilberth prepares another coffee.
[10:14:35] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Ping timeout: 240 seconds)
[10:14:43] <moon-child> you would need control flow, too, not just data flow, no?
[10:14:50] <moon-child> I guess it depends on how it uses the stack
[10:15:58] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[10:17:43] <gilberth> What you mean by "how it uses the stack"? There is no SP-relative addressing (the 8080 has no instruction for that), all there is is PUSH x, POP x, CALL, RET, and XTHL which is (rotatef HL [SP]).
[10:18:22] <moon-child> I see
[10:19:15] <gilberth> With one exception: The GC traverses linearly over the stack and it's compacting.
[10:20:59] *** Quits: GreaseMonkey (greaser@user/greasemonkey) (Read error: Connection reset by peer)
[10:23:03] *** Joins: shka (~herr@109.231.3.55)
[10:23:53] <hayley> "How many people will have COVID in class?" "Can we all agree to lick the tables on the first day"
[10:25:06] <gilberth> I am at a loss. I could perhaps for each instruction tell what is on the stack, that is if the top of stack is a return address or not. But what would I gain by that?
[10:27:57] <moon-child> you know if a RET is 'real' or 'fake
[10:27:59] <moon-child> '
[10:28:17] <gilberth> Right.
[10:32:45] <gilberth> I could regard all jumps as tail calls and go from there. To get a nice result, I could then turn a tai-called subroutine only used within one other subroutine into a host language goto by essentially inlining. *scratcheshead*
[10:33:13] <gilberth> I mean, I want something readable to humans.
[10:34:38] <moon-child> maybe I am missing something.  Why can you not represent jumps as jumps?
[10:35:16] <gilberth> Because different subroutines at times share tails.
[10:36:13] <gilberth> Like FOO: blah blah JMP L1 ; BAR: blah blah L1: blah blah RET
[10:36:30] <moon-child> I would duplicate such tails
[10:36:57] <moon-child> probably.  Or make tail calls only for things which are shared
[10:37:25] <gilberth> If they are short. At times they are long and more real tail calls.
[10:38:07] <gilberth> moon-child: Yep, that's my problem: I want to tell "real" jumps within a subroutine from "real" tail calls.
[10:38:17] <hayley> Here's a thought. Is it harder to, say, turn some code for a made-up RISC machine into nice code for your favourite processor, rather than a higher level language?
[10:39:22] <moon-child> _nice_ code is a difficult proposition
[10:39:29] <moon-child> in either case
[10:39:40] <hayley> And said machine is quite poor with register sizes, with 16-bit registers and data. One thing that comes to mind is, rather than knowing when we can perform fixnum addition, we have to do the opposite, and figure if we can replace multiple 16-bit adds and carries with a 64-bit addition.
[10:40:01] <gilberth> moon-child: There are things, I want to duplicate though. E.g. for returning NIL, I see a JMP RET_NIL, and RET_NIL: LXI H, NIL ; RET. That's so short, that I want to inline that. But I could live with manually telling so.
[10:40:04] <moon-child> (esp. as, in the latter case, niceness is not strictly defined)
[10:41:06] <moon-child> gilberth: there was one decompiler I saw that would take assembly like this:  if (foo) { bar; goto R; } baz; R: return;  and turn it into:  if (foo) { bar; return; } baz; return
[10:41:12] <hayley> It'll be a minor point in something, but I suspect having a made-up compilation target machine, which tries to look like actual hardware but falls short hugely, is worse than directly compiling to the actual hardware.
[10:41:15] <moon-child> which I was rather impressed by, as other decompielrs were not able to do that
[10:41:44] <moon-child> hayley: falls short in what respect?
[10:42:04] <hayley> I do not have a definition of "niceness", sure. But I also know that they want to run things on crap^Wold hardware, so runtime performance requires actual effort to not be total shit.
[10:42:36] <hayley> moon-child: The first thing that comes to mind is having 16-bit addresses and words.
[10:42:40] <gilberth> moon-child: Yep, that is a niceness that I would care later about. You could perhaps also identify while and do/while loops.
[10:43:17] <hayley> It's also a stack machine, but given every implementation (apparently) just interprets, who cares?
[10:43:40] <moon-child> hayley: yeah, makes sense.  It still seems easier to generate machine code, though, as in a nice high-level language you can not forge pointers
[10:43:47] <moon-child> so you would need to have a global 'memory' array or some such
[10:43:49] <moon-child> which is not so nice
[10:45:40] <gilberth> moon-child: I also already have a heap of ideoms, like mov a, m ; inx h ; mov l, m ; mov h, a => mova hl, [hl]
[10:46:28] <moon-child> oh my, that's horrible
[10:48:26] <hayley> moon-child: I mean, either fictive machine -> machine code, or high level language -> machine code. The former doesn't go through a HLL step, so no memory array. I strongly suspect that the former is "optimised" for hardware that doesn't exist.
[10:49:54] <hayley> But it is a minor point, in the grand scheme of things. I already have a pain point to exploit, wherein people interpret on old or underpowered hardware. Not unlike gilberth's favourite programming language^Wimplementation for microcontrollers.
[10:51:03] <moon-child> hayley: oh--I see
[10:51:05] <dave0> "old" pfffft you're just young :-p
[10:51:22] <moon-child> hayley: in general, the more constraints you have on your source, the nicer output you can produce for your target
[10:51:47] <moon-child> (e.g. to use the same example, I may assume pointers are not forged, and so do alias analysis)
[10:52:23] <hayley> dave0: One implementation is targeted for the "IBM PC". I don't know if they mean the 8088 original, or just some x86 with MS-DOS or whatever else. But good luck running anything interesting!
[10:52:40] <hayley> moon-child: Right, sure. Compilation loses information that re-compiling could make use of.
[10:54:08] <hayley> .oO( It would be funny to compile that language to my VM, and then get a half-assed JIT compiler as a result. Same with compiling Arduino/AVR code to e.g. this VM/ARM as I suggested before. )
[10:55:23] <contrapunctus> hayley: https://youtube.com/watch?v=TIoBrob3bjI
[10:55:24] -ixelp- Tom Lehrer - We Will All Go Together When We Go - with intro - YouTube
[10:56:05] <hayley> https://www.youtube.com/watch?v=JlGZN74iaZ4
[10:56:05] -ixelp- La Dolce Vita - YouTube
[11:03:00] <hayley> .oO( Well, it has the same sort of humour involved when compiling Smalltalk to Self gave you the fastest Smalltalk implementation. And Self was supposed to be harder to implement fast. )
[11:08:18] *** Joins: lisp123 (~lisp123@120.154.103.52)
[11:10:30] * moon-child is reminded of when he argued (with moderate success) that java is lower-level than c because the latter has value structures
[11:17:29] *** Quits: lisp123 (~lisp123@120.154.103.52) (Remote host closed the connection)
[11:20:29] * contrapunctus 's CLIM question was not responded to in #clim...to repost or not to repost... 🤔️
[11:21:19] *** Quits: minion (~minion@common-lisp.net) (Read error: Connection reset by peer)
[11:22:31] <gilberth> Ok. I am lazy. I have an 8080 emulator in Lisp with the few CP/M BDOS calls I would need which runs mulisp fine. I could see what happens, if I add a tag to words pushed and poped saying if it is from a call and see. RET should warn me, if it doesn't see sth pushed by a CALL.
[11:22:40] *** Joins: minion (~minion@common-lisp.net)
[11:29:00] <gilberth> Hmm, this I wrote in 2016 and I already have my stack outside the addressable 64kB.
[11:38:22] <gilberth> Oh, I see violations, but in my own BDOS. :-(
[12:03:54] *** Joins: cosimone (~user@93-34-132-33.ip49.fastwebnet.it)
[12:04:01] * hayley takes a trip down memory lane
[12:04:28] <hayley> When I did C++ classes, they had a final exam. One of the questions asked "what's this program print/return/something like that" but there was UB.
[12:04:46] <hayley> Specifically, they wrote "int blah;" without initialising before using. And one of the first things they taught us was to not do that. Hmm.
[12:04:47] * gilberth is debugging his 8080 emulator.
[12:05:23] <hayley> I also remember the lecturer said that not initialising was faster, but I retorted saying that initialising with a bogus value (like 0) is no slower, because a compiler can easily kill off the redundant assignment.
[12:06:50] <gilberth> A valid argument for non initializing would have been that a good compiler could tell you when you read that uninitialized value.
[12:06:51] <hayley> "We do Java for one class, C++ for another, and C# for another, we did Python already, that's all the OO languages" "Damn, which class uses Smalltalk?"
[12:08:43] <gilberth> It's about intentions. saying "int sum = 0;" is different from "int tmp;". That is when I see the former, I expect that that value is used. But a matter of taste really.
[12:08:51] * hayley nods
[12:09:00] *** Quits: Catie (~user@user/catie) (Ping timeout: 240 seconds)
[12:09:29] <hayley> But they seem to have assumed initialising to zero in a C++ program, based on what I recall of that program in the exam. And one of the first lessons in C++ was "don't do that!!!"
[12:10:13] <gilberth> Imagine a summation loop after the former. And yes, my sum of no summands is zero and not undefined :-)
[12:10:23] <moon-child> gilberth: compiler gets it wrong sometimes, though.  Somebody once sent a patch to a project to initialise a value 'to shut the compiler up', even though it was never actually read before being written to
[12:10:37] <moon-child> so it is a violation of intent to initialise in that case
[12:10:40] * hayley stares in +/
[12:10:56] <moon-child> I would much rather the compiler initialise when you say 'int x;' anyway.  (As cl does, when you say (let (x) ...))
[12:11:02] *** Joins: mgl (~mgl@cpc87455-finc19-2-0-cust234.4-2.cable.virginm.net)
[12:13:00] <gilberth> moon-child: In my experience compilers report false positives but don't miss an uninitialized read, that is telling that a variable not initialized, when indeed it is, because the compiler didn't figure it out that the variable in question is always defined at that point. Which is fair as that would entail to solve the halting problem.
[12:13:42] <gilberth> moon-child: Actually I would prefer with CL, that (LET (X) ...) would give you an unbound X.
[12:13:50] <moon-child> yes, that would be good
[12:14:01] <moon-child> (actually, I was about to mention that: it should behave like an unbound slot :P)
[12:14:12] <pjb> gilberth: but for lexical variables, it's difficult to have an unbound state.
[12:14:18] <gilberth> And (LET (X) (DECLARE (TYPE FIXNUM X)) (SETQ X 1)) should be fine, too. Which it isn't with CL.
[12:14:56] <gilberth> pjb: Doesn't the unbound marker fit into a register or onto the stack?
[12:16:26] <pjb> That's not the point.  The problems come from run-time testing for the unbound lexical variable.  boundp takes a symbol.  We'd need a variable-boundp taking the variable name (the symbol), and we'd have to keep those names around at run-time.
[12:16:27] <gilberth> That marker should completely go away in the resulting machine code, as reading it would be an error.
[12:16:58] <gilberth> pjb: And? What's the problem?
[12:16:59] <pjb> In the meantime:  (LET (X) (DECLARE (TYPE (or NULL FIXNUM) X)) (SETQ X 1)) ; which clearly indicates that X can be unbound (NIL) or a fixnum.
[12:17:09] <pjb> gilberth: more complex compiler and run-time.
[12:17:25] <gilberth> Nope, it does indicate that X could be NIL, which is not the same as unbound.
[12:17:43] <pjb> You can even write: (defconstant $unbound '$unbound)   (LET ((X $unbound)) (DECLARE (TYPE (or (eql $unbound) FIXNUM) X)) (SETQ X 1))
[12:17:48] <gilberth> pjb: Since when do we care for lazy compiler writers?
[12:19:18] <gilberth> I bet CMUCL^WSBCL would do fine with sth like (defstruct unbound) (defvar +unbound+ (make-unbound)) (let ((x +unbound+)) (declare (type (or unbound fixnum)) ... (setq x 1) (foo (the fixnum x))) Which is what I envision this would essentially turn to.
[12:20:09] <gilberth> pjb: You were faster.
[12:20:17] * hayley spots a classmate has a funny base64 message in their profile for some chatroom, but they forgot the padding == on the end.
[12:21:35] <gilberth> The only thing that is missing is that when I do that manually to catch the unbound value, I would need to wrap (the fixnum x) around every use.
[12:22:09] <hayley> I would not hold my breath on it, because SBCL is not too good with type inference and SETQs.
[12:22:42] <hayley> No SSA or value numbering, so it takes the union of all values and still ends up with (or unbound fixnum).
[12:22:53] <gilberth> hayley: But you agree that a proper compiler could infer that with easy. *sigh* I bet we could generate way better code with a modern CL compiler.
[12:23:12] <hayley> gilberth: You are talking to the person who implemented global value numbering for SICL and/or Cleavir.
[12:24:44] <gilberth> I am aware. I wonder, if I could craft a CL->CL compiler doing that. What I also want is to turn (let ((q (cons a b)) .. (foo (car q) (cdr q))) into just (foo a b); No need to write the actual backend for that, this kind of transformations could be done within CL.
[12:25:23] <hayley> SICL used to be bootstrapped by converting CL code to IR, then converting IR back to CL code.
[12:25:48] <moon-child> gilberth: you would still be counting on certain optimizations to be implemented by the host.  So I don't know how interesting that is
[12:26:01] <hayley> Trouble is, that the generated code is larger and the SBCL compiler is slow, and wants quite some memory. Thus, unless you could run with a 10GB heap, and would wait a while, you could not bootstrap SICL.
[12:26:14] <hayley> Not fun when I only had 8GB of RAM and had to watch it swap.
[12:26:35] <gilberth> Then ditch Python. There are other compilers.
[12:26:46] <moon-child> hayley: I note sicl is also specced to have a slow compiler
[12:26:57] <hayley> "Why should I add the padding, it's bloat" "It makes base64 -d sad ):"
[12:27:00] <hayley> moon-child: Yeah, but we have global value numbering.
[12:27:19] *** Joins: treflip (~user@user/treflip)
[12:27:51] <gilberth> I used to open-code the state machine for an LALR parser and this was impractical with CMUCL. There must be something O(n^2) or so in there.
[12:28:08] <hayley> That's the theory that beach had too.
[12:28:35] <gilberth> Yeah, so then don't use it. You want your own backend in the long run anyway, don't you?
[12:29:06] <hayley> Reminds me that I still haven't tried to feed one-more-re-nightmare output to the SICL compiler, to see if its GVN can help at all.
[12:31:30] <hayley> gilberth: Yeah, but we need to run code in the host still.
[12:31:52] <pjb> gilberth:  or factorize the with locally: (if (eq '$unbound x) (do-unbound-stuff) (locally (declare (fixnum x)) …))
[12:39:07] <gilberth> pjb: That would buy me nothing. When I as a programmer already figure out the do-unbound and do-bound parts, I have done the work that the compiler should do for me. That is when I do that, there would be no reason to have an unbound marker there in the first place.
[12:39:56] <gilberth> Anyhow, when I put the stack back to where it belongs, or mulisp thinks it belongs, all hell breaks loose.
[12:40:41] <gilberth> So I have to see if mulisp guesses a sane place for the stack. And CP/M this really is some kind of guesswork.
[12:42:35] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 240 seconds)
[13:02:55] <gilberth> Ouch. There is this silly convention to put a string argument right after the return address. Like CALL PUTS ; DB "Hello, there!$" But that's there only for the herald and error messages.
[13:04:28] <moon-child> ook
[13:04:54] <moon-child> that would be slow on modern hardware.  But I guess they did not have cache back then
[13:05:13] <gilberth> But I am bitten by /me not having a BIOS entry point.
[13:05:53] <gilberth> moon-child: Cache? On the 8080? It wasn't slowed down by memory at all.
[13:06:07] <moon-child> sure sounds nice...
[13:07:11] <gilberth> Well, the [not mine] CP/M emulator I have emulates a Z80 roaming at like 8GHz ...
[13:07:38] <moon-child> even l1 has something like 4-5 cycles of latency today
[13:08:03] <moon-child> vs asking for anything (no page faults, please) and getting it straightaway next cycle
[13:08:20] <gilberth> Yep, and in general memory latency hasn't improved much over time.
[13:09:17] <Alfr> Tweak c?
[13:09:40] <gilberth> c isn't the issue yet.
[13:12:29] <gilberth> I mean, what is DRAM latency? A dozen ns or something? My DRAM isn't in 12ft distance from the CPU.
[13:13:13] * hayley wonders if telling someone that their base64'ed strings are broken is the best way to ask them out. Oh well
[13:13:24] <moon-child> more like 100ns
[13:13:38] <gilberth> 100ns? Oh my!
[13:14:20] <gilberth> That's 300ft. Ok. 150ft considering the round-trip.
[13:15:10] <dave0> hayley: the traditional encoding is rot13 :-)
[13:15:14] <moon-child> disc is a lot slower, and it's no further
[13:15:44] <hayley> dave0: Eh, welcome to 2022.
[13:16:09] <hayley> And I must say that rot13 is not good enough, even when used for a joke.
[13:16:30] <gilberth> I always wanted to compare latency with a picture, like your short-term memory being the registers, L1 would be your desk, L2 your book-shelf, L3 the book-shelf down at the other floor. DRAM the libarary across the campus. And disk the libaray at the other city. Or so.
[13:17:05] <dave0> does usenet even exist now?
[13:17:22] <gilberth> Of course it exists.
[13:17:24] <moon-child> gilberth: https://fgiesen.wordpress.com/2016/08/07/why-do-cpus-have-multiple-cache-levels/ makes that sort of analogy
[13:17:24] -ixelp- Why do CPUs have multiple cache levels? | The ryg blog
[13:17:28] <moon-child> dave0: more or less...
[13:17:51] <dave0> hayley: you're on irc.. welcome to 1989 :-p
[13:19:05] <dave0> last time i used usenet it had alt.binaries and alt.humor.funny
[13:19:59] <gilberth> Some 30 years ago I used to be a regular on comp.lang.lisp. I accessed Usenet by UUCP.
[13:23:39] <hayley> "Go on, make the joke about the reading list for algorithms class." "If they don't mention the infamous book Algorithms + Data Structures = Programs it will be a Wirth-less course"
[13:24:48] <dave0> haaa
[13:32:13] <Alfr> gilberth, hm ... around 0.1m/cycle at 3GHz?
[13:33:20] <gilberth> Alfr: I don't get you. What kind of figure is that?
[13:33:22] <Alfr> gilberth, we're at hundreds of cycles for an l1 miss?
[13:34:08] <pl> hayley: honestly, I think that book is so fucking overrated
[13:34:11] <Alfr> gilberth, distance light travels in vacuum in that time.
[13:34:46] <pl> hayley: the only book worse at an algorithms class is Cormen as the only textbook with shitty prof doing unengaging lectures
[13:34:58] <gilberth> Alfr: Yep. Light travels at 1 foot/ns.
[13:35:16] <Alfr> gilberth, just tying to figure out how far away we need to place memory for that to make a difference.
[13:35:26] <gilberth> So 3GHz is a wave length of 10cm.
[13:36:43] <Alfr> gilberth, only took that because that cancels out nicely with 3*10^8m/s.
[13:37:34] <gilberth> Indeed, that's the reason with assuming 1ft=30cm I memorized the 1ft/ns figure.
[13:41:22] <gilberth> Ok. When I don't use the CALL PUTS ; DB "Hello!" trick and instead do LXI H, MSG ; CALL PUTS .. MSG DB "Hello!", I would need a whooping 12 extra bytes. Could I spare those?
[13:42:25] <moon-child> I thought you are decompiling?  You want also to target the 8080?
[13:43:12] <gilberth> Alfr: A year has pi * 10^7 seconds. Another round figure one can remember easily.
[13:44:29] <gilberth> moon-child: I am fine with modifying the assembly I generated manually. It should still assemble and run fine. But, yes, decompiling is my target.
[13:45:15] <moon-child> so why do you care how many bytes of 8080 machine code you would need?
[13:45:34] <hayley> pl: The lecturer wants us to imagine how cool it would be to discuss algorithms with classmates, without writing any code.
[13:45:48] <hayley> Times were very odd when he studied algorithms, I guess.
[13:46:10] <gilberth> I wasn't serious. I don't care. There are some fixed assumption about the layout of the resulting code, but I have room for those 12 bytes.
[13:46:38] <hayley> Particularly, discussing running times of algorithms. Good luck doing that on a superscalar branch predicting machine, but sure why not.
[13:47:14] <moon-child> draw a dependency graph, hope really hard your working set fits in cache and your branches are predictable?
[13:47:14] <gilberth> Like everything below 01F00h being a SUBR. Up to 02600h is an FSUBR.
[13:47:25] <moon-child> https://grsecurity.net/amd_branch_mispredictor_just_set_it_and_forget_it    urk
[13:47:57] <gilberth> Symbols start at 02600h and 02600h itself is NIL. This sort of things.
[13:50:59] * hayley is looking forward to some very odd optimisations this semester.
[13:54:27] * hayley also needs to think of better dating strategies.
[13:55:55] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Ping timeout: 256 seconds)
[13:58:08] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[14:09:43] <neominimum> I don't know a lot about simd. Is it possible to do something like `(or (eq (aref array 0) obj) (eq (aref array 1) obj) ... )` and make it vectorised(?)?
[14:10:27] <hayley> Yes.
[14:10:57] <neominimum> excellent!
[14:11:08] <hayley> On x86-64 I would do a load, then compare-equal, then move-mask to get a bitmap mask. If it is non-zero, then there is a match.
[14:11:31] <hayley> Then you can use count leading/trailing zeroed to find the first or last match if you like.
[14:11:36] <hayley> *zeroes
[14:11:37] <moon-child> can just [V]PTEST
[14:12:16] <hayley> VPTEST does bitwise AND, not equal.
[14:12:35] <moon-child> yes.  Compare equal and then VPTEST the result of the comparison with itself
[14:12:47] <moon-child> don't need to put the mask in a gpr
[14:13:01] <hayley> Ah, right.
[14:13:45] <hayley> I usually find myself needing to know which element matched, so move mask comes up still. And AIUI VPTEST before move mask wasn't faster, but these things are worth re-testing when I can.
[14:14:10] <moon-child> still reduces register pressure
[14:15:05] <hayley> Sure.
[14:16:27] <neominimum> Yes, I see. I know some of these words. You're talking assembly right? Does sbcl have any lispy way to write assembly instructions?
[14:17:55] <hayley> Yes, DEFINE-VOP
[14:18:21] <hayley> https://github.com/telekons/one-more-re-nightmare/blob/master/Code/SIMD/sbcl-x86-64.lisp
[14:18:21] -ixelp- one-more-re-nightmare/sbcl-x86-64.lisp at master · telekons/one-more-re-nightmare · GitHub
[14:22:30] <neominimum> Okay cool, I know what I'm doing tomorrow. Thanks.
[14:27:39] <neominimum> Out of curiosity, is it possible to write an entire program in assembly using that? I have been wanting to learn assembly or rather any sort of low level method of programming, and I wouldn't mind staying within my development environment to do so.
[14:28:25] <neominimum> or would it just lead to weirdness
[14:30:29] <hayley> It's possible, but annoying.
[14:31:34] <moon-child> as I recall, some parts of mezzano are done like that
[14:37:32] <neominimum> Oh nice, I may take a look. Although I think I really should just take the common route and use an assembler/assembly
[14:38:15] <neominimum> no need to make things harder than they need to be
[14:39:34] <neominimum> night
[14:43:11] <hayley> CCL also has a Lisp assembler (LAP). Had to fix it using a CAS loop rather than LOCK XADD.
[14:49:38] <gilberth> Actually it's only six bytes saved by that silly calling convention as the routine takes up space too.
[14:59:32] *** Joins: lisp123 (~lisp123@120.154.103.52)
[15:00:07] * hayley reads a post by Mr Felleisen on organizing code.
[15:00:42] <hayley> "You could use fancy tools to extract structure, but source code is the only thing that is consistently displayed." And it's my problem /how/ if people use poor tools?
[15:01:28] <hayley> I especially liked the part where you are supposed to do figlet-esque big headers for sections, so that the miniature version some editors show has "sections".
[15:02:49] <moon-child> felleisen?
[15:03:08] <hayley> Seems like that is a hack based on what some editors do. My Emacs doesn't.
[15:03:14] <hayley> The Racket guy.
[15:03:34] <moon-child> ahhh
[15:04:20] <hayley> (Though, since us CLers have a package system that is orthogonal to files, we end up reaping some of the benefits by just making more files. Some weird people even number the files, to suggest you read or build in some order.)
[15:04:29] *** Quits: lisp123 (~lisp123@120.154.103.52) (Ping timeout: 256 seconds)
[15:05:28] <hayley> But designing based on "plain text is the least common denominator, and all tools only speak plain text" is a self fulfilling disappointment.
[15:09:50] <hayley> Still, I do not think it is worth my time to make anything more usable if someone deliberately chooses bad tooling.
[15:20:15] <gilberth> Oh, for data (control?) flow analysis I now have an hen and egg problem. Without knowing what is on the stack, I can't tell where RET leads me to.
[15:22:08] <gilberth> And it's that RET I am after as they are used to forge indirect jumps. If there would have been a PCHL (= mov pc, hl) instruction instead that would be easier and that is what I want. *sigh*
[15:23:13] <gilberth> However I am pretty confident I already know the two places where indirect jumps are actually made.
[15:24:09] <hayley> I was going to do data flow analysis to figure this out in my LC-3 JIT, so I could inline function calls.
[15:27:00] <hayley> But, still, /me thinks that if there really is an IDE that is much better, it is not her problem if someone does not want to use it.
[15:28:06] <hayley> (Assuming no other obstructions, of course. They probably do exist, so you have to be more careful in practice. But I would not be interested if someone couldn't use ed(1) easily to read my code.)
[15:28:58] <hayley> Hm, should my LC-3 in CL be 3-CL? Too similar to 3-Lisp I think. Or maybe LC-3-CL
[15:34:21] <gilberth> hayley: Have fun: <http://termbin.com/lixf>
[15:39:02] <gilberth> And this curious. The code is clean and clever at the same time, very well written. But still the PCHL instruction, which is there for indirect jumps isn't used. I wonder why.
[15:40:16] <moon-child> perhaps it was not documented at the time?  I am spitballing
[15:41:50] <gilberth> PCHL was always documented.
[15:43:04] <gilberth> And the undocumented very useful 8085 were never used. Hey would have provided painless SP relative addressing. But that was at a time the Z80 already was popular.
[15:43:52] *** Joins: random-nick (~random-ni@87.116.179.129)
[15:44:03] <gilberth> Actually I always wonder why Intel would upgrade the 8080 instruction set with such useful instructions and not document them? I mean, they aren't there by accident.
[15:44:37] * gilberth takes a break.
[15:49:39] <gilberth> I know why! The calling convention is to pass the first argument in HL, the second in DE. You can't do that with PCHL.
[15:50:14] *** Joins: eugercek (~user@user/eugercek)
[15:51:29] <moon-child> 'We've previously made a case why four tiers in V8 make sense'
[16:02:32] <gilberth> Sigh. It could be so easy, as no stack relative addressing is used and no frame pointers taken, but all there is is PUSH and POP for the most part, this shouldn't be too hard. In theory.
[16:03:50] <moon-child> eh, if hotspot does it, you can too
[16:03:52] <moon-child> :)
[16:15:28] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[17:08:59] *** Joins: jackdaniel (~jack@user/jackdaniel)
[17:28:03] *** Joins: kevingal (~quassel@2a02:8084:4140:f300:b960:8330:724b:bd23)
[17:51:27] *** Quits: cosimone (~user@93-34-132-33.ip49.fastwebnet.it) (Remote host closed the connection)
[17:51:52] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[18:20:04] *** Quits: dave0 (~davezero@069.d.003.ncl.iprimus.net.au) (Quit: dave's not here)
[18:27:44] *** Quits: treflip (~user@user/treflip) (Quit: rebooting...)
[18:30:31] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[18:33:52] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Remote host closed the connection)
[18:35:35] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 240 seconds)
[18:37:35] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[18:50:16] <gilberth> Heh, there seems to be dead code, a whole spare 12 bytes!
[18:57:57] <gilberth> And one string is "\r\n", it could share with e.g. "No Disk Space\r\n". So I need only 3 bytes more for a sane PUTS calling convention. :-)
[19:00:13] <moon-child> Get rid of the 'Disk ' in 'Disk Space'
[19:00:17] <moon-child> who needs descriptive error messages?
[19:01:09] <gilberth> There also is "Space exhausted" --- the GC giving up.
[19:01:16] <moon-child> 'No space'
[19:01:38] <gilberth> So "Space" is disk space and "space" is RAM?
[19:02:03] <jackdaniel> it should be "No1" for RAM and "No2" for disk
[19:02:09] <gilberth> I could go with error numbers, look them up in the manual.
[19:02:44] <gilberth> Curious is that '}' is used as an interrupt character. But have been a funny keyboard.
[19:02:56] <gilberth> * Must
[19:04:46] <gilberth> Anyhow, dead code makes me nervous. Either it's real dead code, or my routine to find all reachable code is missing something. Before I don't have that, I can't begin with any program analysis.
[19:05:13] <jackdaniel> what are you working on?
[19:05:27] <epony> https://en.wikipedia.org/wiki/Self-modifying_code#Use_as_camouflage
[19:05:35] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 240 seconds)
[19:05:40] <epony> viruses, of course
[19:05:44] <gilberth> I am disassembling/reverse-engineering ancient mulisp for CP/M-80.
[19:05:52] *** Joins: lisp123 (~lisp123@120.154.103.52)
[19:06:21] <jackdaniel> sounds esoteric :)
[19:06:37] <gilberth> It's like a puzzle. I needed a break.
[19:07:26] <gilberth> This is an on-off project. I already have meaningful label names and comments for about 1/4 of it. And a working .asm file.
[19:08:12] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[19:08:30] <epony> https://en.wikipedia.org/wiki/Orders_of_magnitude_(time)#More_than_one_second "31.5576 Ms (365.25 d): length of the Julian year, also called the annum, symbol a. | 31.55815 Ms (365 d 6 h 9 min 10 s): length of the true year, the orbital period of the Earth"  --not Pi
[19:09:20] <gilberth> Anyhow, it's a clever implementation, I used it back in those days, and it's surprising you could fit a Lisp in 64kB address space.
[19:10:26] *** Quits: lisp123 (~lisp123@120.154.103.52) (Ping timeout: 250 seconds)
[19:10:58] <gilberth> That's only 16k cons cells. And the interpreter takes room too.
[19:12:10] <epony> https://en.wikipedia.org/wiki/RAM_limit#Operating_system_RAM_limits
[19:18:24] <epony> prediction of the roundabouts: no later than 20 years after 2038 someone will be working on fitting 64 GB RAM on a 32-bit processor emulation just for fun
[19:18:46] <epony> "proper addressing must be had"
[19:23:35] *** semz_ is now known as semz
[19:24:45] *** Joins: treflip (~user@user/treflip)
[19:33:44] <epony> https://en.wikipedia.org/wiki/Special:WhatLinksHere/Self-modifying_code
[19:49:50] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[20:07:03] *** Quits: mgl (~mgl@cpc87455-finc19-2-0-cust234.4-2.cable.virginm.net) (Quit: Client closed)
[20:17:39] <White_Flame> yeah, just the common lisp symbol instances with their names would take up a huge part of the 64k :)
[20:18:55] <moon-child> there are, what, 1k symbols?  At an average length of, say, 10-20 chars
[20:19:01] <moon-child> not quite, but close!
[20:23:58] <jackdaniel> the system is little sluggish because 30% of ram is occupied by names :)
[20:33:01] <gilberth> So, what do I need to do? A forward analysis? For each instruction keep the known top of stack? Or rather look at a stack use and go backwards to tell if I could tell if there is a return address or some data? Or ditch the analysis and tweak things manually?
[20:36:41] <gilberth> The sum of the length of the symbol name of all 978 symbols in CL is 11,271.
[20:40:18] <moon-child> hmm, perhaps we can use a packed 7 bits per char, in symbol names at least
[20:40:39] <moon-child> and there may be an even more compact representation (considering there are only 96 standard characters), but that is pushing it
[20:41:05] <moon-child> how big is zlib again?  That might be worthwhile
[20:42:45] <jackdaniel> who needs names at runtime? just number them
[20:42:48] <moon-child> 'eventually consistent?  What am I, a shitty boyfriend?'
[20:43:12] <gilberth> There are only 37 distinct characters in the names. So 5.2 bits should do. Otherwise: <http://bauhh.dyndns.org:8000/cruft/lzw-2.lisp>
[20:43:36] <moon-child> well, you also have to handle user-defined names with arbitrary characters
[20:44:02] <moon-child> I would do just 5 bits.  I bet most of those characters are alphabetics, -, and *
[20:44:13] <moon-child> (and then have a flag for symbols with more chars)
[20:48:47] <gilberth> &*+-/12<=>ABCDEFGHIJKLMNOPQRSTUVWXYZ
[20:49:21] <jackdaniel> no multiple-value-prog3 extension? ,)
[20:49:22] <moon-child> I count 10 characters aside from alphabetics
[20:49:33] <moon-child> so should be 36, not 37, no?
[20:50:31] <moon-child> anyway I would definitely ditch <=>.  Those symbols are quite short anyway, so they probably would not benefit from being squished
[20:50:54] <gilberth> Here is the frequency: ((#\E 1126) (#\T 951) (#\A 918) (#\- 875) (#\R 774) (#\O 715) (#\I 707) (#\N 697) (#\S 632) (#\L 533) (#\P 435) (#\C 429) (#\D 379) (#\M 367) (#\U 244) (#\H 228) (#\G 222) (#\F 221) (#\B 187) (#\Y 121) (#\V 104) (#\* 98) (#\K 69) (#\W 62) (#\X 44) (#\Q 27) (#\Z 22) (#\1 15) (#\J 12) (#\= 12) (#\2 9) (#\/ 9) (#\& 8) (#\+ 7) (#\> 6) (#\< 6))
[20:51:28] <moon-child> frequency is fine, but actual cost savings will be harder to determine
[20:51:35] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Quit: ec)
[20:51:52] <gilberth> I am too lazy to compute a simple Huffman table.
[20:52:00] <moon-child> e.g. < will be 7 bits vs 5 bits, still 1 byte.  <= is 10 vs 14 bits, still 2 bytes
[20:52:24] <gilberth> Byte? What is a byte?
[20:52:44] <moon-child> an addressible unit
[20:53:21] <gilberth> 37, I missed ">" with cut and paste. Sorry.
[20:53:34] *** Parts: jackdaniel (~jack@user/jackdaniel) ()
[20:53:56] <gilberth> moon-child: (make-array 42 :element-type 'bit)
[20:54:10] <gilberth> I can address a bit just fine.
[20:54:29] *** Joins: lisp123 (~lisp123@120.154.103.52)
[20:54:58] <gilberth> No, I did not. 36 it is.
[20:55:07] <moon-child> sure
[20:55:36] <gilberth> But you would also need some kind of end-marker.
[20:55:47] <moon-child> rather than a length?
[20:55:52] <moon-child> I bet there is some structure to be shared
[20:56:10] <moon-child> which you are less likely to get with a terminator
[20:57:09] <gilberth> It's the other way around. With an end marker I have "STRING-EQUAL" and have "EQUAL" point right into the former.
[20:57:54] <moon-child> You can do that with a length, too
[20:58:02] <gilberth> But for catching this structure, don't we have compression?
[20:58:20] <moon-child> but you can not also make STRING point to the beginning of STRING-EQUAL with a terminator
[20:58:32] *** Quits: lisp123 (~lisp123@120.154.103.52) (Ping timeout: 240 seconds)
[20:58:40] <moon-child> I don't know, do we? :P
[20:59:45] <gilberth> Yes, say 37 = STRING-, and 38 = MULTIPLE-, and so on.
[21:01:44] <gilberth> Hmm. gzip could compress the 11,271 plus 978 NLs to 4,104 octets.
[21:02:04] <moon-child> how big is gunzip, though?
[21:04:24] <gilberth> 11,271 + 978 = 12,249
[21:04:42] <gilberth> Ah you mean the binary?
[21:05:01] <gilberth> Hard to tell, it's dynamically linked.
[21:05:09] <Alfr> How do you represent symbols?
[21:05:29] <gilberth> ?
[21:06:10] <Alfr> Not textually, but how should that implementation handle them?
[21:06:39] <moon-child> A unique pointer to a pair of package + instructions for extracting name
[21:06:57] <gilberth> What do you need? "cells" for the package, the value, the function, the plist, and the name.
[21:07:34] <gilberth> But you don't need to keep values, functions and plists at the symbol. And who uses plists anyway?
[21:07:56] <moon-child> you did, recently
[21:08:21] <gilberth> Yes, for APVAL, EXPR, SUBR, and PNAME :-)
[21:09:17] <gilberth> And +INTERNAL-STRING-MARKER
[21:11:04] <gilberth> But in general plists are underrated. And GET should take an environment argument.
[21:11:42] <gilberth> For user-defined name spaces.
[21:12:58] <Alfr> gilberth, how about symbols are leafs in a trie encoding their names.
[21:14:20] <gilberth> Would that really use less memory? I mean, you would need pointers in there.
[21:14:29] <Alfr> gilberth, every time you want a symbol's name you'll have to walk the trie until you find that node.
[21:14:42] <Alfr> gilberth, depends on how many common prefixes you have.
[21:15:39] <gilberth> Yeah, CL has a host of common prefixes like STRING-, CHAR-, MULTIPLE-VALUE-, PACKAGE-, PATHNAME-, etc.
[21:46:50] <clothespin> good morning
[21:50:30] *** Quits: jeosol (~jeosol@user/jeosol) (Quit: Client closed)
[21:57:09] *** Joins: jeosol (~jeosol@user/jeosol)
[22:06:15] *** Quits: eugercek (~user@user/eugercek) (Remote host closed the connection)
[22:12:16] *** Joins: nwoob (~apple@49.36.239.167)
[22:12:26] <nwoob> how do hackers learn optimized ways to program
[22:14:51] <gilberth> This is like asking how do hackers learn to hack.
[22:17:05] *** Quits: treflip (~user@user/treflip) (Quit: good night!)
[22:17:29] <masinter> hash tables are good for user-defined name spaces
[22:17:59] <masinter> it's a performance issue
[22:18:48] <nwoob> gilberth: are hacker geniuses
[22:27:31] <ck_> nah, not in general. hacking is very easily done and doesn't require next level intellect -- you just need to know which surface to attack first
[22:27:45] <ck_> for example, many laptop computers are vulnerable through the keyboard
[22:27:51] <ck_> https://thumbs.dreamstime.com/z/rage-against-computers-8830783.jpg
[22:38:18] <White_Flame> nwoob: do something, make mistakes, learn from mistakes, know how to avoid mistakes preemptively.  Iterate many times.  That is the path of experience/expertise
[22:38:21] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[22:39:22] <White_Flame> learning from others really helps, too, but it's the mistakes you make yourself (or others' make in your presence) that stick in mind the most
[22:49:46] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Remote host closed the connection)
[22:58:32] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[23:03:29] <gilberth> masinter: (1) I don't care about lookup performance at compile time (2) I like that just compiling a file does not define the entities (3) lexical scope would also be nice. Hash tables can't do that.
[23:05:45] <gilberth> nwoob: If you ask me. Hackers are no geniuses per se. It takes curiosity and a lot of persistence to get a good hacker IMHO.
[23:19:15] <masinter> gilberth I might be missing some context. What did you mean by "GET"?
[23:22:57] <masinter> "9:41 AM @gilberth: But in general plists are underrated. And GET should take an environment argument."
[23:23:30] <White_Flame> this GET: http://www.lispworks.com/documentation/HyperSpec/Body/f_get.htm
[23:23:31] -ixelp- CLHS: Accessor GET
[23:24:11] <White_Flame> the symbol-plist element accessor
[23:24:47] <masinter> i don't understand where the environment fits in at all then
[23:25:43] <masinter> the association of symbols in source code to lexical environment is at compile time
[23:25:49] <White_Flame> diffrent namespaces the symbol might be in
[23:26:04] <White_Flame> but yeah, the package of the symbol, and the package of the keys in the plist already scop eit
[23:26:11] <masinter> what do you mean by "namespace"?
[23:26:33] <shka> good night all https://www.youtube.com/watch?v=-o-6ftmw8CE
[23:26:33] -ixelp- Sisters of Mercy, Dominion / Mother Russia - YouTube
[23:27:09] <White_Flame> could mean a lot of things, up to and including first-class global environments a la Beach's stuff
[23:34:51] <gilberth> masinter: CL:GET would be the perfect device to stick a definition of some symbol in a user defined name space at, if CL:GET would have an &environment argument or would magically be in another compile-time environment to get the same bahaviour as with macros. DEFMACRO makes a macro only available at compile time.
[23:35:46] <gilberth> A good example for a name space would be CLIM's presentation types. The usual hack to craft symbols like named |(PRESENTATION-TYPE FOO)| is awful and does not survive renaming a package.
[23:35:49] <masinter> macrolet
[23:36:01] <gilberth> macrolet?
[23:36:20] <masinter> defining macros at compile time only
[23:36:31] <gilberth> DEFMACRO does that too.
[23:36:58] <gilberth> I mean, DEFUN doesn't define the function before its loaded, does it?
[23:38:18] <gilberth> I should be able to do the same with new name spaces. Like e.g. presentation types. Or as in my Pascal compiler, which works by emitting an s-expr form of pascal subject to the CL compiler. There Pascal types etc are defined in a new name space.
[23:38:26] *** Joins: Catie (~user@user/catie)
[23:38:36] <gilberth> Anyhow, I'll be back in a bit.
[23:58:17] *** Joins: eugercek (~user@user/eugercek)
