[00:00:24] *** Joins: Bike (~Bike@71.69.170.70)
[00:12:21] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Remote host closed the connection)
[00:16:30] *** Joins: cosimone (~user@93-34-132-251.ip49.fastwebnet.it)
[00:17:04] *** Quits: phantomics (~phantomic@71-218-243-149.hlrn.qwest.net) (Read error: Connection reset by peer)
[00:26:13] *** Quits: vats (~vats@180.149.226.25) (Ping timeout: 256 seconds)
[00:31:22] <AeroNotix> disk space is cheap tho
[00:33:46] <AeroNotix> Xach: is this a feature you'd consider?
[00:33:57] <AeroNotix> tracking the reason something was installed
[00:34:30] *** Joins: phantomics (~phantomic@71-218-126-185.hlrn.qwest.net)
[00:35:24] *** Joins: aartaka (aartaka@gateway/vpn/protonvpn/aartaka)
[00:35:29] <nij-> Does ASDF support customizable fetcher? Something like (:depends-on (nyxt :host github :repo "atlas-engineer/nyxt" :hash "0a9sd0a9sd"))
[00:36:59] <nij-> That CL is frozen in time provides the community a chance to make use of code written 30 years ago. However the liquidity of dependencies may break this.. thus the question.
[00:38:06] <AeroNotix> you can use a snapshot of a quicklisp tree though
[00:38:34] *** Joins: klimnbrk (~barakvoid@2.55.3.120)
[00:38:38] <AeroNotix> you can even make your own
[00:38:53] <AeroNotix> which contains versions of whatever dependencies, at whatever versions
[00:44:22] <semz> nij-: ASDF doesn't fetch at all.
[00:44:54] <nij-> Is it one of the development goal for asdf to do this?
[00:45:24] <nij-> I really hope any code in CL could still easily work in the far future (assuming the code and all its dependencies still exist).
[00:46:56] <semz> https://asdf.common-lisp.dev/ suggests that it's considered out of scope (which makes sense to me)
[00:48:53] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 256 seconds)
[00:52:26] <qhong> I do see a problem here. Seems that asdf specifies dependencies only with name, but with no version information? (at least I don‚Äôt see people writing such in asd) Then in the far future, systems might break because of accumulation of tiny incompatible changes in their dependencies
[00:52:54] *** Quits: aartaka (aartaka@gateway/vpn/protonvpn/aartaka) (Ping timeout: 250 seconds)
[00:53:34] *** Joins: voidbrkd (~barakvoid@2.55.134.52)
[00:55:41] <nij-> qhong: As suggested by semz, it seems that asdf dev team doesn't think it's an issue (at least for asdf to solve).
[00:55:53] *** Quits: klimnbrk (~barakvoid@2.55.3.120) (Ping timeout: 256 seconds)
[00:56:12] <nij-> But indeed, that does break the dream of having codes that work *forever* (assuming existence, again).
[00:56:16] <qhong> nij-: fetching is out of scope, but I‚Äôm unsure about versioning
[00:57:13] <nij-> Got it, yeah.
[00:57:17] *** Quits: shka (~herr@109.231.0.226) (Ping timeout: 240 seconds)
[00:57:36] <qhong> ah, asdf3 actually support versioning
[00:58:09] <qhong> I hardly see it in use though, and seems that it only ensure newer version (so not exactly solving the bit rotting problem)
[00:58:26] <nij-> Does it support hash-specific versioning?
[00:59:46] <EdLangley[m]> The solution is to not make breaking changes
[00:59:51] <EdLangley[m]> I consider this a feature
[01:00:07] <dre> you pay more for features
[01:00:25] <nij-> EdLangley[m]: The solution is to make everyone to not make breaking changes?
[01:00:42] <qhong> EdLangley[m]: hyrum‚Äôs law
[01:00:55] <qhong> it‚Äôs pretty much impossible
[01:01:52] <nij-> qhong: Hmm...... I only see version-specifier - https://asdf.common-lisp.dev/asdf.html
[01:02:00] <EdLangley[m]> Package versioning makes it easy to make breaking changes
[01:02:00] <nij-> But hash-specifier should be much more reliable.
[01:02:27] <EdLangley[m]> Which results in things like pip and npm where people just go around breaking things
[01:02:39] <nij-> It's ok. With hash-specifier I can just stick with the older version, which works.
[01:03:01] <EdLangley[m]> Anyways, as far as hyrum‚Äôs law goes
[01:03:16] <EdLangley[m]> If you‚Äôre using :: things breaking are your fault
[01:03:26] <EdLangley[m]> If you‚Äôre using :, it‚Äôs on the dependency
[01:03:47] <moon-child> that's for symbols
[01:03:49] <moon-child> what about behaviour?
[01:04:04] <EdLangley[m]> What about it?
[01:04:28] <EdLangley[m]> External symbols that name functions should only change behavior in strictly additive ways
[01:04:31] *** Quits: artchad (~user@public-gprs225103.centertel.pl) (Read error: Connection reset by peer)
[01:04:42] <EdLangley[m]> If you want to break all your users, fork your package and rename it
[01:04:44] <nij-> You're imposing other people to all do that, which is fine.
[01:04:50] <nij-> But in reality, not everyone will do that.
[01:05:01] <EdLangley[m]> semver-major changes are rude
[01:05:05] <nij-> But as a community, we need to have a reliable way to use libraries.
[01:05:21] *** Quits: Dynom (~niels@80-114-12-206.cable.dynamic.v4.ziggo.nl) (Quit: WeeChat 3.4)
[01:05:22] <nij-> I don't see a problem in hash-specifiers in this.
[01:05:23] <moon-child> supposing I did not specify some behaviour in one version of my protocol?
[01:05:32] <moon-child> specifying it is a strictly additive change
[01:05:40] <EdLangley[m]> Yeah, and my point is, as a community, if we expect libraries never to push breaking changes, then we set up incentives to keep it that way.
[01:05:54] <moon-child> but the unspecified way I behaved was relied upon by some user of my library
[01:06:05] <qhong> EdLangley[m]: There‚Äôs no such thing as strictly additive. E.g. I might rely on a specific function to produce an error, and a later version that does not produce error breaks my code
[01:06:06] <nij-> EdLangley[m]: that's too ideal.
[01:06:28] <EdLangley[m]> No it‚Äôs not
[01:07:24] <EdLangley[m]> I‚Äôve never missed version bounds in CL
[01:07:37] <nij-> That doesn't mean you won't in the later 50 years.
[01:07:38] <EdLangley[m]> Over the last six years of using quicklisp
[01:07:43] <nij-> CL needs to survive *forever*!
[01:08:00] <EdLangley[m]> I can run forty year old code just fine
[01:08:12] <nij-> All of them?
[01:08:13] <moon-child> fwiw I don't think semver is the solution either
[01:08:18] <EdLangley[m]> So, I assume things will mostly work as expected in fifty years
[01:08:23] <moon-child> I agree if you break compat you make a new package name
[01:08:29] <nij-> moon-child: what do you think about hash-specifier?
[01:08:30] <moon-child> I just don't think it's reasonable to dismiss hyrum's law so
[01:08:47] <moon-child> nij-: I hope common lisp will outlive git
[01:08:51] *** Joins: shka (~herr@109.231.0.226)
[01:09:05] <nij-> moon-child: ? It has nothing to do with git.
[01:09:06] <EdLangley[m]> Well, my view is that if you‚Äôre depending on unspecified behavior, breakage is your fault
[01:09:32] <moon-child> nij-: what does the hash identify then?
[01:09:51] <nij-> Compute a hash of the whole system with a fixed algorithm, say md5sum.
[01:10:04] <nij-> And when loading the system, first check if the hash agrees.
[01:10:07] <qhong> EdLangley[m]: I also run 40 years code from say CMU AI repo just fine, but that‚Äôs because there were no ASDF, and they are self containing tarballs using `load`
[01:10:13] <moon-child> so content-addressibility.  Ok
[01:10:37] <nij-> Yeah, things like this is very secure, and will ensure the code to keep working 50 years later. How sexy is that?
[01:10:43] <moon-child> there is an interesting mailing list post by joe armstrong about that
[01:10:48] <EdLangley[m]> Anyways, the problem with this scheme is it breaks the best feature of lisp
[01:10:55] <moon-child> https://erlang.org/pipermail/erlang-questions/2011-May/058768.html
[01:11:10] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[01:11:39] <EdLangley[m]> It is fundamentally at odds with lisp‚Äôs interactive development
[01:11:54] <nij-> EdLangley[m]: You cannot expect every major libraries to behave as you wish in your ideal for 50 years, can you?
[01:12:02] <nij-> in your ideal way*
[01:12:04] <EdLangley[m]> Why not?
[01:12:11] <EdLangley[m]> This isn‚Äôt JavaScript
[01:12:20] <EdLangley[m]> We don‚Äôt break things because we‚Äôre bored of them
[01:12:23] <qhong> moon-child: ha, like ‚Äúwiki-based development‚Äù which got brought up over and over again on LtU?
[01:12:41] <nij-> EdLangley[m]: I see the merit in it.
[01:12:56] <nij-> However, that also limits the numbers of usable libraries.
[01:13:06] <phoe> how?
[01:13:07] <nij-> Sure, the most important libraries will always be like that.
[01:13:32] <nij-> But currently there are lots of libraries written that only acquired little popularity.
[01:13:54] <nij-> If you want those to grow incrementally, the better way is to come up with a way that encourages people to use and extend it.
[01:13:59] *** Quits: pve (~pve@37-33-78-221.bb.dnainternet.fi) (Quit: leaving)
[01:14:02] <phoe> will breaking backwards compatibility increase their popularity in any way though?
[01:14:08] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 250 seconds)
[01:14:10] <phoe> if by "usable libraries" you mean "not broken by the developers" then I think it's actually the reverse
[01:14:16] <nij-> If the main building system in CL doesn't encourage that, those will be harder to be used.
[01:14:47] <nij-> phoe:  what do you mean?
[01:14:57] <nij-> (and what do you think about hash-specifier, btw?)
[01:15:49] <AeroNotix> you seem super hung up on using a hash-specifier like it's unique
[01:15:53] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[01:16:04] <AeroNotix> content-addressable stores are fine, I guess?
[01:16:11] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[01:16:14] <AeroNotix> _how_ you specify a version isn't really the interesting thing
[01:16:34] <AeroNotix> you can require that versions take the form `banana-:digit:-apple`
[01:16:37] <AeroNotix> same difference?
[01:16:41] <nij->   AeroNotix: Yeah, in the end I just want content-addressability. This is how the functional package managers work.
[01:16:49] <AeroNotix> nij-: so build it
[01:17:16] <nij-> AeroNotix: I want to first understand why this isn't what's wanted in the major build system (asdf).
[01:17:17] <AeroNotix> summing up the answers so far: ASDF doesn't have this functionality and it appears it does not intend to grow the functionality.
[01:17:51] <nij-> AeroNotix: Well, in asdf3 they introduced version-specifier.. maybe hash-specifier or other type of content addressing tools are to come.
[01:18:20] <AeroNotix> yeah again, not sure if you understood what I mentioned - the string format the version takes really isn't the important part
[01:18:43] <AeroNotix> just 'does this string thing point to the same code over time'
[01:19:16] <AeroNotix> things being content-addressable make it seem super duper megawow important, but ehh... ? Not really.
[01:19:17] <nij-> yeah, that's why I think hash-specifier is the answer
[01:19:22] <sveit> is there a way to get the "~G" format directive to not output trailing spaces? it seems in the spec that there is some "ee" parameter which gets used as "~ee@T" and "ee" is always set to at least 2.
[01:19:44] <etimmons> nij-: :version has been around longer than ASDF 3
[01:19:50] <nij-> Why not? consider 100 years later
[01:20:06] <nij-> etimmons:  Errrgh sorry my bad.
[01:20:09] <etimmons> And there are no plans I'm aware of to add hash-specifier or similar
[01:20:11] <AeroNotix> nij-: alright, I considered it
[01:20:39] <AeroNotix> my main concern isn't around what the version string is, but rather, does the store that hold the code even still exist
[01:20:41] <nij-> etimmons: Good to know. Do you know why they don't plan such tool?
[01:20:53] <etimmons> My personal opinion is that such a thing belongs outside the ASDF system definition
[01:20:58] <nij-> AeroNotix: That's another problem, which will never be solved.
[01:21:10] *** Quits: voidbrkd (~barakvoid@2.55.134.52) (Remote host closed the connection)
[01:21:35] <nij-> etimmons: Got it. I respect that. I'm just curious why they also don't think it's a nice idea to use hash-specifiers.
[01:22:06] <etimmons> A sufficient reason to not include it is how do you reconcile two systems that depend on the same system but at different versions/hashes
[01:22:34] <etimmons> we can't simultaneously load two different versions of the same system
[01:23:45] <qhong> FYI: I just tried loading hunchentoot 1.2.0 (from ~10 years ago). Loads fine, I run (asdf:test-system "hunchentoot"), test fails
[01:25:34] <qhong> I'm afraid contemporary projects based on ASDF will not work after a dozen of years, totally unlike the projects 40 years ago
[01:26:17] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 256 seconds)
[01:28:08] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[01:29:53] <qhong> etimmons: it can be done, at least for systems that don‚Äôt do wacky stuff like introspecting symbol-package. `rename-package` hack
[01:30:45] <masinter> 2022-40 = 1982 but there wasn't CLtL1 until 1984
[01:30:51] *** Joins: Algernon69 (~Algernon6@2a01:e0a:511:6ce0:d9fd:fa02:c3dd:fc1c)
[01:31:07] <_death> qhong: does the test fail because of asdf?
[01:32:24] <mgl> Is there a way to get the default values of &optional and &key arguments of a function on CCL?
[01:32:24] <mgl> (ccl:arglist (lambda (&optional (o 1)))) => (&OPTIONAL O)
[01:33:42] <qhong> _death: no. It seems like changed behavior in `drakma`
[01:33:53] <qhong> hyrum's law in action, probably
[01:35:59] <_death> qhong: so why do you say "based on ASDF"?.. besides, saying they're "based" on asdf is a bit of a stretch.. sure, they have an .asd file and old projects may have had a different defsystem file, but that doesn't mean they're "based" on it.. the actual difference between hunchentoot and the older projects is the number of dependencies
[01:36:59] *** Quits: mgxm (~mgxm@user/mgxm) (Quit: ....)
[01:37:06] <qhong> _death: you are correct.
[01:37:14] <_death> qhong: many old projects are self-contained.. some however depend on mcclim or genera code or whatever, so those are less likely to work without changes
[01:37:15] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 256 seconds)
[01:37:27] <_death> *depend on clim
[01:37:59] *** Joins: mgxm (~mgxm@user/mgxm)
[01:38:17] <qhong> I still think this should and can be fixed, say, if projects document the exact version of their dependencies, so that a working system in the past can always be reproduced in the future
[01:38:21] <_death> mgl: why not use alexandria's function? it gets you the init forms
[01:39:15] <mgl> _death: which function?
[01:39:23] <_death> parse-ordinary-lambda-list
[01:39:43] <mgl> I don't have a lambda list. I have a function object.
[01:40:28] <_death> function-lambda-expression?
[01:41:05] <qhong> _death: ccl seems to typically yeet nil,nil,nil for anything
[01:42:26] <_death> I see
[01:44:34] <mgl> _death: nice. f-l-e seems to do the trick
[01:45:27] <mgl> argh, it was on allegro. ccl indeeds returns nil
[01:47:15] <random-nick> I agree it would be nice if CL library releases would include a file which lists versions of their dependencies at the time of release/testing
[01:47:59] <random-nick> however I don't think it should be respected by default because of the version conflict issue
[01:48:30] <random-nick> but nowadays it seems many libraries don't do releases/versioning at all
[01:48:55] <phoe> ...or they try to be fully backwards compatible, which limits the amount of damage that non-versioning can do
[01:49:31] <EdLangley[m]> I sort of think the best thing to happen to a CL package is for it to be basically done and then become unmaintained
[01:53:13] <phoe> or, in other words, "complete"
[01:53:21] <EdLangley[m]> Yeah
[01:53:24] *** Joins: Inline (~Inline@ip-037-201-240-204.um10.pools.vodafone-ip.de)
[01:53:44] <EdLangley[m]> Code doesn't rot
[01:54:22] <_death> well, I'd say that even if the interface is not perfect, there are usually many improvements that can be made on the implementation side.. and exposing a new interface without breaking the old one is often possible too.. these things take more effort and imagination and require an anti-churn attitude that respects users.. and outside CL all kinds of pressures lead to the opposite attitude
[01:54:35] <EdLangley[m]> Yeah, I don't mind improvements
[01:54:49] <EdLangley[m]> And I'm a bit biased by writing JS professionally
[01:54:54] *** Quits: mgxm (~mgxm@user/mgxm) (Quit: ....)
[01:55:10] <EdLangley[m]> But, it seems to me like maintainers often get sort of bored with something that works and then start breaking it
[01:55:12] *** Joins: mgxm (~mgxm@user/mgxm)
[01:55:23] <EdLangley[m]> Python 2 -> 3, Perl 5 -> 6, Scala 2 -> 3, etc.
[01:55:25] <AeroNotix> EdLangley[m]: code does rot
[01:55:33] <EdLangley[m]> It doesn't
[01:55:40] <AeroNotix> EdLangley[m]: it's just the reasons for the rot are irrelevant to CL because CL itself is unchanging
[01:55:42] <EdLangley[m]> Unless your dependencies change under you
[01:55:58] <AeroNotix> and that's not necessarily a good thing, but it is a benefit of basing your project on CL
[01:55:59] <EdLangley[m]> Which means you picked the wrong dependencies, IMO
[01:56:27] <qhong> _death: hyrum‚Äôs law again
[01:57:21] <AeroNotix> I've said it previously when this channel was on freenode but imho CL is in need of a modernized standard
[01:57:43] <EdLangley[m]> Why?
[01:57:56] <EdLangley[m]> We have good-enough portability libraries for the gaps in the standard
[01:58:02] <AeroNotix> on the face of it CL being so set in stone itself seems like a good thing but you end up with balkanization of useful features when they are implemented in poor libraries
[01:58:20] <moon-child> EdLangley[m]: it would be better if those portability libraries were standardised
[01:58:31] <EdLangley[m]> So, I've seen python people say things like "the standard library is where libraries go to die"
[01:58:45] <AeroNotix> Modern concurrent programming is, imho, a large feature which CL lacks. Libraries are all over the place and maintained by the few, pushed to the limits by no-one
[01:58:47] <phoe> if we had a standardization committee member every time this topic was mentioned then we would have multiple X3J13 by now :D
[01:58:49] <EdLangley[m]> It's better for things not to be standardized so we can swap them out
[01:59:07] <AeroNotix> and if they are reasonably halfway decent, they're supported by only a couple of implementations
[01:59:14] <moon-child> EdLangley[m]: how can you swap out named readtables?  package local nicknames?
[01:59:25] <moon-child> and regarding threads, see boehm 'threads cannot be implemented as a library'
[01:59:28] <EdLangley[m]> Named readtables is just a hash table of readtables
[01:59:30] <AeroNotix> imho the fact CL is so stagnant is a big part of why its popularity stays so niche
[01:59:52] <semz> phoe: and we probably still wouldn't have a new standard :-)
[02:00:03] <EdLangley[m]> As far as threads goes, the implementations implement threads and the portability library standardizes the interface
[02:00:07] <_death> what may be good is more specifications (extensions to the standard) that are agreed upon and implemented by lisp implementation vendors.. but it requires $$$.. if only there were some rich Lisp people who were interested in pursuing this ;)
[02:00:08] <EdLangley[m]> Which works pretty well
[02:00:12] <moon-child> AeroNotix: do not mistake stability for stagnation
[02:00:14] <EdLangley[m]> bordeaux-threads is pretty good
[02:00:30] <AeroNotix> threads are literally the most basic and error-prone concurrency mechanism
[02:00:32] <EdLangley[m]> IMHO, people are used to churn in JS, Ruby, Python and similar
[02:00:35] <EdLangley[m]> And miss it in CL
[02:00:42] <AeroNotix> the industry has moved on, we're literally decades ahead of simple threads
[02:00:42] <moon-child> EdLangley[m]: the interface is not standardised to the level of quality I would like
[02:00:47] <EdLangley[m]> AeroNotix: Sure, and you can build your CSP library on top of them
[02:00:56] <AeroNotix> EdLangley[m]: have you USED the popular CSP libraries?
[02:00:59] <AeroNotix> guessing you have not
[02:01:02] <AeroNotix> because they are rubbish
[02:01:02] <EdLangley[m]> moon-child: So, make a PR to B-T or come up with a new portability library
[02:01:14] <AeroNotix> they spin the CPU on the most basic of operations, for example
[02:01:40] <EdLangley[m]> But, again, we don't need a standard here
[02:02:00] <moon-child> we don't need any standard in the first place, again
[02:02:04] <moon-child> but I think it provides a lot of value
[02:02:05] <EdLangley[m]> We just need someone to write a good library and/or improve bordeaux-threads
[02:02:15] <AeroNotix> my suggestion is that no standard in a platform and community such as CL's leads to terrible balkanization where no-one is the winner
[02:02:32] <EdLangley[m]> It's a bit strange to complain about the standard causing stagnation and then suggest standardizing more things would help
[02:02:40] <EdLangley[m]> Things that are standardized can't change, by definition
[02:02:58] <moon-child> isn't this what you suggested?  Append-only?
[02:03:03] <EdLangley[m]> So, if we come up with better interfaces and/or techniques, they can only be implemented as libraries on top of the standard
[02:03:05] <AeroNotix> EdLangley[m]: I think standardization is good, and CL in particular lends itself well to that model
[02:03:28] <EdLangley[m]> Which, to me, suggests we make the standard as minimal as possible to support a healthy library ecosystem
[02:03:34] <EdLangley[m]> And then let vendors add on things like sockets and threads
[02:03:35] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[02:03:53] <EdLangley[m]> And have libraries to sort out the vendor extensions into things that are portable between implementaitons
[02:03:53] <moon-child> sure.  For many things that works.  But, again, _threads cannot be implemented as a library_
[02:03:54] <AeroNotix> my opinion is that because the standard is coming up on quite literally 30 years old, it's missing out on a lot of progress
[02:03:55] * moon-child shuts up
[02:04:14] <semz> They aren't implemented as a library!
[02:04:25] <EdLangley[m]> Yeah, they're vendor extensions
[02:05:16] *** Joins: kevingal (~quassel@2a02:8084:4140:f300:389d:624:1174:4b42)
[02:05:28] <AeroNotix> EdLangley[m]: we have the situation you mention, 'standard as minimal as possible'
[02:05:34] <AeroNotix> since the standard is unchanging
[02:05:37] <moon-child> sure.  Where is my memory model?  Can I be sure that abcl, ccl, and sbcl all implement the same semantics?
[02:05:41] <EdLangley[m]> Exactly
[02:05:46] <EdLangley[m]> And that's why I like CL
[02:05:46] <AeroNotix> and we quite literally do not see a healthy library ecosystem
[02:05:59] <EdLangley[m]> It's like #1 on the list of reasons why I like CL
[02:06:02] *** Quits: shka (~herr@109.231.0.226) (Ping timeout: 240 seconds)
[02:06:03] <phoe> I think this problem is always answered best by "who's supposed to do this and who's supposed to pay them"
[02:06:11] <EdLangley[m]> And the library ecosystem is pretty great
[02:06:16] <EdLangley[m]> There are lots of gaps
[02:06:17] <contrapunctus> .o(Wasn't there some talk of restarting the CDR process?)
[02:06:30] <phoe> until this is answered there's little point reliving the same debates over and over
[02:06:33] <AeroNotix> EdLangley[m]: those two statements are in conflict
[02:06:57] <EdLangley[m]> Not really
[02:06:58] <phoe> and CDR is kinda meant to be append-only
[02:07:15] <EdLangley[m]> "healthy" and "complete" are different
[02:08:37] <phoe> "it would be nice if CL had a revised specification" is a truism; the real meat of that issue is who are the people and whence comes the money, everything else has already been said probably hundreds of times before
[02:09:11] <phoe> and until this meat has an appropriately meaty answer we are bound to repeat history, except as farce
[02:09:31] <EdLangley[m]> The reason I stopped using Python is that they revised the "specification"
[02:09:51] <EdLangley[m]> I don't think it's obvious that updating the spec will improve things
[02:10:03] <EdLangley[m]> It's more likely to cause a second-system effect that kills everything
[02:10:37] *** Quits: lispy (~lispy4@84.69.59.93) (Quit: Leaving)
[02:10:45] <qhong> EdLangley[m]: what‚Äôs your opinion on SRFI?
[02:10:51] <phoe> EdLangley[m]: true
[02:10:57] <contrapunctus> Maybe it's time to start something akin to XEPs and SRFIs? Sounds like that way the existing standard remains untouched, but there's a library standardization process...
[02:11:04] <contrapunctus> qhong: aha ;)
[02:11:07] <EdLangley[m]> I like SRFI because they're layered on top of the standard
[02:11:19] <EdLangley[m]> But, I'd prefer them to be implementations rather than just docs
[02:11:23] <phoe> contrapunctus: that's CDR, which are, again, meant to be append-only
[02:11:45] <contrapunctus> phoe: I'm saying "something not append-only, then"
[02:11:58] <EdLangley[m]> https://cdr.common-lisp.dev
[02:12:04] <qhong> EdLangley[m]: SRFIs are usually doc+a reference impl+real impls by vendors
[02:12:40] <EdLangley[m]> Cool, that's the sort of process I'd prefer
[02:12:44] *** Quits: szkl (uid110435@id-110435.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[02:12:53] <EdLangley[m]> e.g. turning bordeaux-threads into a spec
[02:12:57] *** Quits: morganw (~user@80.225.24.132) (Remote host closed the connection)
[02:12:58] <EdLangley[m]> And usocket
[02:13:04] <moon-child> that's what I was suggesting
[02:13:10] <qhong> Also MOP
[02:13:16] <EdLangley[m]> MOP already is a spec
[02:13:34] <EdLangley[m]> although, the effective spec is probable closer-mop
[02:13:59] <EdLangley[m]> The second half or so of AMOP was intended to be a spec
[02:14:00] <_death> EdLangley[m]: the updates could constitute clarifications etc. like WSCL.. but there's a lot of room for new specs, some of which don't actually require participation of lisp implementation vendors, but may require participation of lisp library writers in particular fields
[02:14:43] <AeroNotix> I personally wouldn't care which form it takes... the above sounds reasonable to me
[02:15:46] <AeroNotix> my point is more that people are off in the weeds implementing modern tooling on 30 year old software
[02:16:10] <AeroNotix> and we have pockets of brilliance which are tarnished by the fact there's no cohesion between any thing
[02:16:22] <contrapunctus> phoe: even append-only is fine, I guess, since newer ones can supercede older ones. cf. XEPs - each one gets a new number, it's just that the older ones are rarely changed and the current set of relevent XEPs changes; the older, deprecated XEPs don't go anywhere.
[02:16:40] <AeroNotix> libraries fester, are incomplete or lack the performance or usability required because implementations are well, 30 years old and are unchanging to their needs
[02:16:44] <_death> again, this requires time and will, and the fuel is $$$.. PG went back to roots with Arc and Bel.. maybe someone should point out that the next language starts with the letter "C" :).. there are potential patrons for such a process who were (or even are) part the Lisp world.. I dunno why, but I've not seen any of them talk about that, though they usually do show some interest in Lisp
[02:17:09] <fe[nl]ix> I'm not sure what you mean by turning Bordeaux-threads into a spec
[02:17:23] <fe[nl]ix> without buy-in from the implementors it won't go anywhere
[02:17:53] <fe[nl]ix> and that's the main problem with the CDR process
[02:18:16] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 268 seconds)
[02:18:19] <fe[nl]ix> if you look at past documents, they were introduced and marked as "final" within a month
[02:18:42] <fe[nl]ix> just to be ignored by almost everybody
[02:20:33] <EdLangley[m]> I just mean specifying the semantics of its exported symbols sufficiently
[02:20:40] <_death> fe[nl]ix: maybe the problem there is that they were written by individuals
[02:20:56] <contrapunctus> fe[nl]ix: hm...did implementation maintainers not participate in the CDR process? And did nobody request or aid CDR implementation? ü§îÔ∏è
[02:20:59] <EdLangley[m]> If we have the library and it's implementable on top of what existing implementations provide, it's mostly fine
[02:22:06] <_death> there was no pressure to standardize from some entity with resources
[02:26:55] *** Joins: pillton (~user@202.168.60.161)
[02:26:58] *** Quits: pillton (~user@202.168.60.161) (Remote host closed the connection)
[02:27:18] *** Joins: pillton (~user@202.168.60.161)
[02:28:04] <fe[nl]ix> the only implementors I see there are Xof and Sam Steingold, so SBCL and Clisp
[02:28:16] <fe[nl]ix> I would be surprised if the others even heard about it
[02:28:22] <_death> the "hyrum's law" stuff can be mitigated by things like section 1.6
[02:28:49] *** Quits: occ (~occ@user/occ) (Ping timeout: 256 seconds)
[02:29:13] *** mon_aaraj is now known as mon
[02:29:29] <_death> fe[nl]ix: what's interesting though is that something like PLN, which has no real specification, was implemented by several Lisp vendors..
[02:29:44] *** mon is now known as mon_aaraj
[02:29:50] <fe[nl]ix> what's PLN ?
[02:29:56] <_death> package-local nicknames
[02:30:18] <fe[nl]ix> that's not even a CDR :D
[02:30:24] <_death> exactly
[02:30:39] <fe[nl]ix> and yes, there was enough demand that mostly similar functionality was implemented
[02:30:46] <White_Flame> that's how "Common" lisp formed, after all
[02:31:03] <_death> so maybe a CDR for that is in order
[02:31:04] <_death> ;)
[02:31:33] <fe[nl]ix> if you take a look at https://github.com/phoe/trivial-package-local-nicknames/blob/master/trivial-package-local-nicknames.lisp
[02:31:43] <fe[nl]ix> you'll see what I mean by "mostly similar"
[02:31:50] *** Quits: Algernon69 (~Algernon6@2a01:e0a:511:6ce0:d9fd:fa02:c3dd:fc1c) (Ping timeout: 268 seconds)
[02:32:10] <fe[nl]ix> if you're interested in precise semantics, the compatibility is crappy
[02:32:56] <moon-child> I was told sbcl docs were canon
[02:32:58] <moon-child> read them
[02:33:01] <moon-child> they had holes
[02:33:05] <moon-child> so I'm not surprised
[02:33:49] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[02:33:54] <fe[nl]ix> EdLangley[m]: most of the things that are important require changes to the implementations
[02:34:01] <fe[nl]ix> MOP, threads, etc...
[02:34:50] <_death> right, so this could be a first target.. the variants are not too different, and it's recent enough, and could improve via pressure of standardization
[02:34:58] <fe[nl]ix> I'm working on making Bordeaux-threads APIv2 as good as possible, with lots of tests but there are limits
[02:35:04] <moon-child> fe[nl]ix: hm, I think you can do completely portable clos/mop
[02:35:06] <moon-child> no?
[02:35:25] <fe[nl]ix> and I very much doubt that implementors are willing to change incompatibly
[02:35:28] <moon-child> (well.  I guess technically you can also do completely portable reader, and your own PLN.  SO maybe it does not signify much)
[02:35:44] <_death> (btw personally I don't use PLNs.. I just give it as an example of something not too complicated that's ready for standardization)
[02:36:59] <_death> fe[nl]ix: right, the bigger the surface, the more funding would be required
[02:40:30] <_death> fe[nl]ix: this all reminds me of what I wrote a while ago https://old.reddit.com/r/Common_Lisp/comments/j7vd25/a_curated_standard_library_for_common_lisp/g89544v/ .. if anyone's interested
[02:44:29] <pillton> _death: Nicely written. People seem to confuse standards, libraries and language.
[02:47:15] <nij-> >> etimmons> A sufficient reason to not include it is how do you reconcile two systems that depend on the same system but at different versions/hashes
[02:48:57] <tyson2> join #wls
[02:50:33] <nij-> Hmm I think you are right, etimmons, unless the system with two different hash-specifiers (versions) can be loaded simultaneously without name clashings..
[02:51:55] <nij-> A hack of this seems to require a hack of how package works now. E.g. instead of 'nyxt:start, we need 'nyxt-0sa98d:nyxt:start. (where 0sa98d is the hash)
[02:52:10] <mfiano> _death: Well said
[02:52:28] <nij-> But then this couples the notion of systems and the notion of packages..
[02:52:37] <nij-> qhong: what do you think about this?
[02:55:02] <mfiano> We'll just have to wait for FCGE's to be a defacto standard
[02:55:16] *** Quits: myrrh (~markus@172.58.196.49) (Ping timeout: 268 seconds)
[02:56:52] *** Joins: shozo (~user@178.74.52.55)
[02:58:30] *** Joins: lispy (~lispy4@84.69.59.93)
[03:00:42] <nij-> qhong: The usual strategy used by nix or guix doesn't work immediately here. By loading two different versions of the same system, the packages will be collided.
[03:00:55] *** Quits: attila_lendvai (~alendvai@catv-89-132-245-188.catv.broadband.hu) (Ping timeout: 256 seconds)
[03:01:40] *** Joins: dra (~dra@2a04:4540:640a:de00:9170:fb96:16c3:a081)
[03:02:04] <qhong> nji-: It's good enough for retrofitting into CL.
[03:02:37] <qhong> it actually sounds pretty cool to implement sth like nix/guix, but totally within a lisp process (like how make compare to asdf)
[03:03:37] <nij-> qhong: Or maybe guix itself is the solution to this..
[03:04:14] <EdLangley[m]> What you need is something like linux containers, but inside lisp
[03:04:26] <qhong> nij-: one lisp image spawning lisp processes through UNIX shell? eww
[03:04:31] *** Quits: cosimone (~user@93-34-132-251.ip49.fastwebnet.it) (Ping timeout: 256 seconds)
[03:04:47] <EdLangley[m]> A way to have some sort of sub-lisp system where you can load all a system's dependencies and then only expose a specified set of packages to the "global" lisp
[03:04:56] <mfiano> FCGEs
[03:04:58] <EdLangley[m]> i.e. first-class global environments, or something like that
[03:05:07] <qhong> or drop the global, just FCEs
[03:05:31] <mfiano> No, FCGEs are a thing. Let's refer to them as their inventor intended
[03:05:42] *** Quits: masinter (~masinter@c-73-158-116-21.hsd1.ca.comcast.net) (Quit: ~ Trillian - www.trillian.im ~)
[03:05:52] <qhong> it's restricted FCE? FCEs are also a thing
[03:06:02] <mfiano> No relation
[03:06:04] <nij-> qhong: Well I mean to install the packages through guix in the first place.
[03:06:51] <nij-> Hmm but that's also kinda off.
[03:07:04] <nij-> I don't know what FCGEs have anything to do with this..could someone explain?
[03:07:33] <EdLangley[m]> It would let you load multiple versions of a single system into one lisp image
[03:07:36] <qhong> mfiano: I'm pretty sure FCGE is a special case of general FCE
[03:07:37] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 240 seconds)
[03:07:41] <EdLangley[m]> Because you could sandbox them from each other
[03:09:05] <nij-> EdLangley[m]: :O !! What's the current status of FCGE in CL?
[03:09:57] <fe[nl]ix> nij-: not happening
[03:11:01] <nij-> :'( why not.. not even in SICL?
[03:11:03] <EdLangley[m]> I think sicl can be loaded in sbcl and is somewhat usable? It's been a while since I've heard much about it
[03:11:14] <EdLangley[m]> (because I've been off IRC for a while)
[03:12:08] <nij-> It's not complete yet, at least.
[03:12:24] *** Quits: gamaliel (~gamaliel@24.171.221.75) (Quit: Client closed)
[03:13:04] <fe[nl]ix> first-class environments means implementors have to rewrite their compilers, and requires new APIs
[03:13:25] <Catie> "not happening" as in "not going to be a part of the standard"?
[03:13:29] <fe[nl]ix> it will be a miracle if just one of the major implementations gets this feature in the next 5 years
[03:13:33] *** Quits: varjag (~user@ti0040a400-5479.bb.online.no) (Quit: ERC 5.4.1 (IRC client for GNU Emacs 29.0.50))
[03:15:00] <qhong> better just revive kernel instead if we have the effort ;D
[03:15:21] <mfiano> qhong: That depends on which FCE you are referring to. There are several, each very different from each other.
[03:17:12] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[03:17:34] <nij-> fe[nl]ix: I see.. Hopefully SICL will be done soon.
[03:17:35] <qhong> mfiano: I rather view it as very unambiguous. Like concretely different language may have very different semantics of lambda, but we in general agree that lambda is that one thing in lambda calculus, approximated to different extent by each language
[03:18:04] <qhong> mfiano: FCE on the other hand is simply "the reification of the \rho in lambda calculus' standard denotational semantics"
[03:18:08] <mfiano> Oh, you aren't familiar with the implementations.
[03:18:22] <qhong> just like first class continuation is "the reification of the \kappa in lambda calculus' standard denotational semantics"
[03:18:29] <nij-> Naive question: What ever FCGE is, it should be contained in itself, right? How does that work? Self pointing object?
[03:20:54] <jasom> nij-: don't know how it works, but I would assume that it would make a tree (that is the root global-environment could contain pointers to other global environments and so on)
[03:24:15] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 268 seconds)
[03:24:39] <jasom> It seems like it's optional for any given FCGE to contain a reference to itself.  Imagine that you have a working FCGE, if you remove the pointer to itself, you only lose the ability to directly query and manipulate the environment, which you didn't have in a CL without the FCGE
[03:26:42] *** Joins: myrrh (~markus@172.58.196.197)
[03:28:20] <nij-> jasom: gotcha
[03:29:23] <nij->  fe[nl]ix: I'm a bit confused. Suppose SBCL wants to introduce FCGE. What would be the hard work? Well, the global environment is stored in some format already. They just need to write some API to expose that global env, right?
[03:29:56] <jasom> nij-: instead of "some format already" think "spread out all over the image, without any thought to making clones"
[03:30:04] <mfiano> No work has gone into that research yet.
[03:30:13] <nij-> sb-cltl2 module provides compiler-let and environment access functionality described in Common Lisp The Language, 2nd Edition which were removed from the language during the ANSI standardization process. http://www.sbcl.org/manual/
[03:30:15] <mfiano> FCGE's are an implementation technique
[03:30:55] <nij-> Here we do have env access.. what's making it not first-class given sb-cltl2?
[03:32:32] *** Quits: myrrh (~markus@172.58.196.197) (Changing host)
[03:32:32] *** Joins: myrrh (~markus@user/poet)
[03:32:40] *** Quits: kevingal (~quassel@2a02:8084:4140:f300:389d:624:1174:4b42) (Remote host closed the connection)
[03:32:50] <mfiano> I would just read the paper.
[03:33:06] <nij-> mfiano: which paper? Beach's paper?
[03:33:06] <moon-child> mfiano: first-class global environments are a language feature that happens to be useful for bootstrapping one implementation
[03:33:18] <mfiano> Right
[03:34:03] <mfiano> THe paper explicitly mentions it did not research their use for application developers, and defers to problems in doing so in related works.
[03:34:53] <fe[nl]ix> which paper ?
[03:35:03] <nij-> http://metamodular.com/SICL/environments.pdf
[03:35:16] *** Quits: lispy (~lispy4@84.69.59.93) (Quit: Leaving)
[03:35:19] <nij-> How about sb-cltl2, quoted above?
[03:36:12] <EdLangley[m]> Trucler is probably better designed, IMO
[03:37:03] <EdLangley[m]> Anyways, sicl already uses them to bootstrap itself.  So, someone could probably figure out how to write an ASDF component that uses a similar technique.
[03:38:47] <jasom> Hmm, reading the environments paper, the package system is not affected; does that mean you couldn't have two environments in which the set packages would have conflicting imports?
[03:38:54] <jasom> s/reading/skimming quickly/
[03:42:21] *** Joins: dra_ (~dra@2a04:4540:6422:2c00:9170:fb96:16c3:a081)
[03:42:29] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[03:43:49] <EdLangley[m]> Yeah, ideally you'd also use a separate reader like Eclector to virtualize the package system too
[03:44:37] *** Quits: dra (~dra@2a04:4540:640a:de00:9170:fb96:16c3:a081) (Ping timeout: 240 seconds)
[03:45:37] <jasom> well I wasn't sure because it says "For a given package P and symbol name N, there is at most one symbol with the name N in P" but does not clarify what "in" means; I could potentially see that not applying to imports, though the surrounding text implies it does.
[03:46:42] *** Joins: occ (~occ@user/occ)
[03:47:57] *** Quits: mgl (~mgl@cpc87455-finc19-2-0-cust234.4-2.cable.virginm.net) (Ping timeout: 256 seconds)
[03:48:13] *** Quits: AeroNotix (~xeno@185.107.67.252) (Quit: WeeChat 3.4)
[03:48:56] *** Joins: AeroNotix (~xeno@185.107.67.252)
[04:00:03] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 256 seconds)
[04:11:25] *** Quits: dra_ (~dra@2a04:4540:6422:2c00:9170:fb96:16c3:a081) (Remote host closed the connection)
[04:11:43] <dbotton> Does IN-PACKAGE work with in an EVAL? in a PROGN? I get strange results one time no, one time yes
[04:11:45] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[04:14:56] <White_Flame> what do you mean by "work"?  affect  *package* for the calling environment, or for peer forms within PROGN?
[04:15:02] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 240 seconds)
[04:15:19] <dbotton> yes
[04:16:54] <dbotton> I evel a (progn (in-package :xyz) (something)) where something = xyz:something
[04:17:13] <dbotton> sorry eval not evel
[04:17:25] <Catie> Would (let ((*package* :the-package-you-want)) ...) do the same thing?
[04:17:27] <White_Flame> what's the current package? and is 'something already ayx:something?
[04:17:34] <White_Flame> *xyz
[04:17:38] <dbotton> no some other package
[04:17:57] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 240 seconds)
[04:18:14] <dbotton> it is valid code, ie xyz:something exists
[04:18:26] <White_Flame> the literal symol whose symbol-name is "SOMETHING" in that expression; that's an extant symbol in a sexpr list that is xyz:something, or that is a string on the REPL that is being read?
[04:18:58] <dbotton> a function
[04:19:10] <White_Flame> are you typing this at the repl?
[04:19:20] <White_Flame> or is this literal source code in a file?
[04:19:31] <White_Flame> or this is a sexpr that's built up programmatically that you're EVALing?
[04:19:59] <dbotton> #3
[04:20:03] *** Parts: nij- (~jin@2001:48f8:9021:806::6f8b) (#commonlisp)
[04:20:26] <White_Flame> ok, so while (something) is executing, *PACKAGE* should be XYZ, as well as when it returns
[04:20:45] <EdLangley[m]> IN-PACKAGE would affect package, but by the time you call EVAL, it's too late to adjust the package read symbols belong to
[04:20:59] <White_Flame> right, if it's a constructed sexpr, though, I don't think the reader is involved
[04:21:29] <White_Flame> hence asking if the symbol xyz:something is already constructed before that EVAL form is reached
[04:21:41] <dbotton> So I am generated code as text, let the user modify it, the submit it to be eval'd
[04:21:43] <White_Flame> in terms of the literal symbol in the s-expression
[04:21:49] <White_Flame> (whee all sorts of overparticular words :-P)
[04:21:54] <White_Flame> ah
[04:21:57] <EdLangley[m]> You have to also bind PACKAGE around READ
[04:21:59] <White_Flame> so you are going through the reader
[04:22:15] <EdLangley[m]> Although, hmm, does READ-FROM-STRING handle IN-PACKAGE?
[04:22:18] <EdLangley[m]> It should have to
[04:22:33] <White_Flame> so, when you read "(eval '(progn (in-package ....)...))", the value of *PACKAGE* will be used to construct the symbols well before EVAL or the inner IN-PACKAGE is evaluated
[04:22:52] <White_Flame> no, the reader doesn't handle in-package.  The compiler/evaluator does
[04:23:16] <EdLangley[m]> It has to, though because it has to know where to intern read symbols
[04:23:25] <White_Flame> so when running a file, the reader needs to be called per toplevel form and then executedevaluated before the next toplevel form is read
[04:23:34] <White_Flame> *executed/evaluated
[04:23:43] <EdLangley[m]> Hmm, that makes sense
[04:24:01] <EdLangley[m]> So, you, you'll have to do (let ((package ...)) (read ...))
[04:24:05] <White_Flame> that's why toiplevel (progn (in-package ..) ..) breaks fro common usage
[04:24:09] <White_Flame> righit
[04:24:21] <White_Flame> (man, this other keyboard sucks)
[04:24:41] *** Quits: amk (~amk@109.255.169.126) (Ping timeout: 268 seconds)
[04:24:46] <Alfr> EdLangley[m], in-package sets cl:*package*, and the compiler has to treat top-level in-package specially to have the same effect, that's about it.
[04:25:19] <White_Flame> loading a .lisp file has to do the same per-form handling
[04:25:26] <EdLangley[m]> Theproblem is READ has to intern symbols
[04:25:35] *** Joins: amk (~amk@109.255.169.126)
[04:25:36] *** Quits: AeroNotix (~xeno@185.107.67.252) (Quit: WeeChat 3.4)
[04:25:44] <EdLangley[m]> So, you have to basically run top-level forms sequentially
[04:25:53] <EdLangley[m]> (at least ones with load/compile-time effects)
[04:25:55] *** Quits: jeosol (~jeosol@user/jeosol) (Ping timeout: 256 seconds)
[04:26:00] <Alfr> White_Flame, forms within a top-level progn are also considered top-level forms.
[04:26:15] <White_Flame> EdLangley[m]: yes, lisp source code forms are mutators against the running image
[04:26:21] <EdLangley[m]> Interestingly, you could use eval-when for mischievous tricks here
[04:26:30] <EdLangley[m]> e.g. pick different packages for load and compile time
[04:26:47] <moon-child> see masinter comments in #lisp
[04:26:47] <White_Flame> there's also the notion of compilation-unit, which i'm not too up on
[04:26:48] <EdLangley[m]> White_Flame: Although, arbitrary toplevel forms don't necessarily run, right
[04:27:00] <EdLangley[m]> e.g. (setf package (find-package :foo))
[04:27:14] <EdLangley[m]> I don't think that necessarily does anything at load or compile time
[04:27:22] <White_Flame> at compile-time?  correct.  I'm not sure that behavior is defined for that
[04:27:28] <White_Flame> load time is probably sequential
[04:27:34] <EdLangley[m]> And DEFUN doesn't necessarily create a function that can be used at load time
[04:27:48] <EdLangley[m]> which is why you have to EVAL-WHEN DEFUNs you use in macros
[04:27:52] <White_Flame> the compilation unit aggregates peer DEFUNs
[04:28:13] <White_Flame> no, macro use of functions are compile-time, not load time.  so eval-when boosts it earlier
[04:28:55] <EdLangley[m]> Yeah
[04:28:56] <EdLangley[m]> sorry
[04:29:01] <White_Flame> dbotton: more confused or less now? ;)
[04:30:04] <Bike> if (setf package (find-package :foo)) is a toplevel form with no eval-when etcs around it, it will run at load time
[04:30:06] <dbotton> sometimes you are so confused you don't know you are
[04:30:18] <Bike> you can kind of think as :load-toplevel :execute as being the default state before any eval-whens come in
[04:30:48] <White_Flame> dbotton: heh.  Well, when you _read_ the string in to a list, that's where the packages are assigned to the symbols
[04:31:17] <White_Flame> and that happens before eval.  So you need to (let ((*package* (find-package :xyz))) (read-from-string "(progn ...)"))
[04:31:36] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 276 seconds)
[04:31:43] <White_Flame> and then those default symbols in there will be from XYZ package
[04:31:51] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[04:31:54] <White_Flame> then you can EVAL that list
[04:32:45] <White_Flame> so yeah, if you have a variety of packages you might want to read inside of, then that'll generally have to be sideband information outside the string
[04:33:05] <White_Flame> "(progn #.(in-package :xyz) ...)" is also a terrible hack that will work, but also leave the caller's package changed
[04:33:29] <dbotton> did a let *package* (find-package :foo) around the eval and works
[04:33:37] <White_Flame> cool
[04:33:43] <White_Flame> that's the proper way
[04:34:06] <White_Flame> specifically, that it's around the read-from-string (or whatever READ-based thing) that makes it work
[04:34:11] <dbotton> It means that I can't allow the user to play with packages
[04:34:18] <dbotton> but is ok in this case
[04:34:54] <White_Flame> yep, just like toplevel .lisp (in-package ..), the compiler has to stop and swap packages before continuing the next read
[04:36:01] <Alfr> dbotton, you could use read and consume what you get form by form and check for an in-package form.
[04:36:04] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 250 seconds)
[04:37:03] <dbotton> I'll keep that in mind Alfr
[04:37:12] <dbotton> Thank you all
[04:37:34] <Alfr> dbotton, if you have a string, you may want to use with-input-from-string, so that READ will like it.
[04:38:15] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[04:38:52] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 268 seconds)
[04:39:06] <EdLangley[m]> I've been trying to figure how much of this is important
[04:39:17] <EdLangley[m]> Because I'd like to implement a system for loading code from non-file inputs
[04:39:25] <EdLangley[m]> e.g. a database or a zipfile
[04:39:50] <EdLangley[m]> (without unpacking the zipfile to disk)
[04:40:19] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[04:41:18] <dbotton> EdLangley[m] take a look at - https://github.com/rabbibotton/clog/blob/main/demos/03-demo.lisp
[04:41:50] <dbotton> line 29 the capture-eval function
[04:42:26] <EdLangley[m]> Cool, looks interesting
[04:43:29] <White_Flame> (loop for line = (read-from-string ...) while line eval line) would support things like (in-package) moreso than "(progn ~a)"
[04:43:44] <White_Flame> sorry, not read-from-string, but reading from a string stream set up
[04:49:00] <EdLangley[m]> Or, you could treat PROGN as a special form
[04:49:10] <White_Flame> no, it's too late
[04:49:12] <EdLangley[m]> Although, that doesn't work... ignore me
[04:49:20] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[04:49:25] <White_Flame> once you have teh symbol CL:PROGN... yeah, all the other symbols are already read, too
[04:50:01] *** Joins: s-liao (~s-liao@101.86.96.21)
[04:50:13] <EdLangley[m]> jscl could probably be used here
[04:50:37] <EdLangley[m]> to pre-process the source code with its reader and turn all the symbols into PACKAGE::FOO
[04:51:20] <EdLangley[m]> I've done stuff like this occasionally when I want to print the code in a way that makes symbol packages unambiguous
[04:51:41] <dbotton> what is strange is that the code the second time through the eval works
[04:51:42] <EdLangley[m]> (let ((*package* (make-package "tmp" :use ()))) (prin1 form))
[04:52:04] <EdLangley[m]> Yeah, because the first eval changes the package and then the second one evaluates in the right package
[04:53:45] <dbotton> that should not affected code already running correct? (ie it has already been read)
[04:53:53] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 256 seconds)
[04:54:21] <EdLangley[m]> hmm, must be something else
[04:54:32] <White_Flame> you probably should :use :cl
[04:55:00] <White_Flame> it is pretty roundabout, though to go string->read->print->read
[04:55:57] <EdLangley[m]> I was doing this when I was serializing the code to a db and wanted it to be as unambiguous as possible
[04:56:04] <White_Flame> if there is #. or #=  it won't round-trip and might mess with the timing & identity of objects
[04:57:23] <EdLangley[m]> :use :cl has the downside of making the code a bit ambiguous, because you have to assume it's always going to be read in a package that doesn't shadow symbols from :CL
[04:58:58] *** Joins: notzmv (~zmv@user/notzmv)
[05:01:26] *** Quits: Catie (~user@user/catie) (Remote host closed the connection)
[05:02:15] *** Joins: Catie (~user@user/catie)
[05:02:46] *** Quits: Catie (~user@user/catie) (Remote host closed the connection)
[05:03:54] <White_Flame> yeah, hence the "probably"
[05:13:53] *** Joins: Catie (~user@user/catie)
[05:14:49] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[05:19:57] *** Quits: random-nick (~random-ni@87.116.181.150) (Ping timeout: 256 seconds)
[05:23:11] *** Quits: xsperry (~xs@user/xsperry) (Killed (NickServ (GHOST command used by asdfasf!~xs@cpe-188-129-71-242.dynamic.amis.hr)))
[05:23:21] *** Joins: lispy (~lispy4@84.69.59.93)
[05:23:50] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[05:26:58] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 268 seconds)
[05:27:35] *** Quits: pieguy128 (~pieguy128@bras-base-mtrlpq5031w-grc-37-70-24-250-33.dsl.bell.ca) (Ping timeout: 268 seconds)
[05:28:20] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[05:31:06] *** Joins: xsperry (~xs@user/xsperry)
[05:34:02] *** Joins: pieguy128 (~pieguy128@bras-base-mtrlpq5031w-grc-35-70-24-248-139.dsl.bell.ca)
[05:37:20] *** Joins: pieguy128_ (~pieguy128@bras-base-mtrlpq5031w-grc-35-70-24-248-188.dsl.bell.ca)
[05:38:28] *** Quits: pieguy128 (~pieguy128@bras-base-mtrlpq5031w-grc-35-70-24-248-139.dsl.bell.ca) (Ping timeout: 250 seconds)
[05:38:39] *** Quits: EsoAlgo (~EsoAlgo@152.70.142.52) (Ping timeout: 256 seconds)
[05:43:48] *** Joins: jeosol (~jeosol@user/jeosol)
[05:44:47] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[05:47:02] *** Quits: Inline (~Inline@ip-037-201-240-204.um10.pools.vodafone-ip.de) (Ping timeout: 240 seconds)
[05:47:35] <EdLangley[m]> If I ever really return to this, I'm going to try to figure out how to use eclector to make a reversible reader
[05:48:07] <EdLangley[m]> Adding a sort of IR that represents the side-effecting reader macros
[05:49:59] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Remote host closed the connection)
[05:50:11] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[05:50:59] <EdLangley[m]> I've sort of prototyped this for #+ and #-: https://github.com/fiddlerwoaroof/lisp-sandbox/blob/master/eclector-test.lisp
[05:53:17] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 240 seconds)
[05:54:25] <White_Flame> a reversible reader, assuming things don't mutate in the meantime, and just store the original string it read and print that as its representation :-P
[05:54:51] <White_Flame> a reversible printer is the hard part ;)
[05:56:39] <EdLangley[m]> By "reversible" I mean there's a bijection between input and output
[05:56:46] <EdLangley[m]> So, it has an inverse operation
[05:57:46] <White_Flame> just to be specific/pedantic, the brunt of the work goes in the printer, not necessarily extending the existing reader
[06:01:19] <moon-child> EdLangley[m]: that's not different
[06:02:02] <moon-child> (defun reversible-read-from-string (s) (cons s (read-from-string s)))
[06:02:09] <moon-child> (defun unread-from-string (c) (car c))
[06:08:20] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[06:08:31] <Bike> it wouldn't include side effects by the reader, i guess
[06:08:40] <Bike> though undoing those is kind of impossible generally
[06:09:22] <EdLangley[m]> Yeah
[06:09:36] <White_Flame> how far do you want to take "transactional"?
[06:10:00] <EdLangley[m]> The idea would just be to have a s-expression format that doesn't lose things like #+feature or #.(...)
[06:10:51] <EdLangley[m]> And then implement the final bit of READ in terms of that format
[06:10:58] <White_Flame> yeah, that would be read side
[06:10:59] <Alfr> White_Flame, just snapshot the universe for rollback and don't forget to destroy the one you abandon.
[06:12:20] <EdLangley[m]> So, I'd also like a CL implementation that lets you snapshot and rollback :)
[06:12:39] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 256 seconds)
[06:14:07] <Bike> pretty sure eclector is already being used to keep stuff like comments
[06:14:21] <Bike> i dunno the details though. something scymtym is doing for climacs if i'm not mistaken
[06:14:50] <EdLangley[m]> Yeah
[06:18:26] *** Joins: IPmonger (~IPmonger@c-69-242-83-226.hsd1.pa.comcast.net)
[06:18:42] *** Quits: IPmonger (~IPmonger@c-69-242-83-226.hsd1.pa.comcast.net) (Remote host closed the connection)
[06:23:31] *** Joins: Jing (~hedgehog@240e:390:7c53:a7e1:b4c3:bc35:ccb7:fa58)
[06:23:43] *** Parts: pranavats (3fba1d1b34@2a00:c70:1:178:170:40:189:1) (Error from remote client)
[06:24:25] *** Joins: pranavats (3fba1d1b34@2a00:c70:1:178:170:40:189:1)
[06:25:03] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[06:29:36] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 250 seconds)
[06:29:57] *** Quits: myrrh (~markus@user/poet) (Ping timeout: 240 seconds)
[06:31:20] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 250 seconds)
[06:33:35] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[06:40:38] *** Joins: pmwals09 (~pmwals09@c-73-218-223-243.hsd1.ma.comcast.net)
[06:45:38] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[06:50:21] *** Quits: pmwals09 (~pmwals09@c-73-218-223-243.hsd1.ma.comcast.net) (Quit: Leaving...)
[06:52:11] *** Joins: myrrh (~markus@172.58.197.224)
[06:56:32] *** Quits: dre (~dre@2001:8003:c932:c301:d3ad:30f8:46d3:c284) (Ping timeout: 240 seconds)
[07:04:28] *** Joins: pmwals09 (~pmwals09@c-73-218-223-243.hsd1.ma.comcast.net)
[07:08:06] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 268 seconds)
[07:08:18] *** Quits: pmwals09 (~pmwals09@c-73-218-223-243.hsd1.ma.comcast.net) (Remote host closed the connection)
[07:09:58] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[07:14:25] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 256 seconds)
[07:15:35] <moon-child> drmeister, Bike: are you using llvm's built-in support for gc in clasp?  If so, how have you found it?
[07:16:56] <Bike> Nope
[07:17:38] <moon-child> ok
[07:17:44] <Bike> We do use stack maps, but not for precise stack scanning
[07:17:45] <moon-child> is that by chance, or were there problems with it?
[07:17:59] *** Quits: occ (~occ@user/occ) (Read error: Connection reset by peer)
[07:18:25] <Bike> We just haven't needed it
[07:28:03] <moon-child> ok
[07:30:17] <beach> Good morning everyone!
[07:30:24] *** Quits: xsperry (~xs@user/xsperry) ()
[07:35:57] <lispy> Morning!
[07:38:47] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 256 seconds)
[07:40:43] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[07:42:52] <mzan> Hi, I'm learning CL. Up so far this is the most complex code I wrote https://aoc-benchmarks.dokmelody.org/linux/program.php?test=aoc2021_day03b&lang=lisp&id=3
[07:43:05] <mzan> I didn't liked one thing...
[07:43:14] <mzan> I were writing optimized code (it was for a benchmark).
[07:44:10] <mzan> I like the (iter ...) macro a lot. But the (iter ...) macro initialize some variables to "nil" sometime, and the SBCL compiler refuse to apply some type optimizations because it sees an initial nil value and sometime it is not smart enough to figure out that the "nil" value will never be used.
[07:44:31] <mzan> But usually, I liked a lot programming in CL. A very fun language.
[07:45:13] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[07:46:22] <mzan> My impression is that the majority of macros works well together but sometime there is some leak. It is acceptable, but it is rather frustrating if one coded in more rigid languages like Haskell.
[07:47:48] <mzan> In this case specific, the leak was only related to optimizations, but not real semantic. Probably there are no many leaks on the side of the semantic.
[07:49:08] <beach> mzan: You are learning Common Lisp, and the first thing you do is with CFFI?  Wow!
[07:49:12] <moon-child> mzan: in such 'rigid' languages, you would probably not be allowed to write such code in the first place
[07:49:17] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 240 seconds)
[07:49:36] <mzan> moon-child: yes fair. In fact using CL is exhilarating :-)
[07:51:02] <moon-child> re iter/optimization: there was some loop/iter-like macro that purported to generate good code for pipelines of transformations.  I can not now remember what it's called, but someone else may...
[07:51:03] <beach> mzan: There are several irritating style problems with your code, like mysterious blank lines, wrong number of semicolons in comments, incorrect indentation.
[07:52:07] <sm2n> mzan: have you read the section of the iterate manual on type declarations?
[07:52:10] <sm2n> moon-child: SERIES?
[07:52:16] <moon-child> yeah, I think that was it
[07:52:38] <moon-child> mzan: http://series.sourceforge.net/  potentially of interest
[07:53:31] <mzan> moon-child: yes, I tried SERIES. In the end I prefer the "iterate" macro.
[07:53:43] <mzan> SERIES by default do not compile to optimized code (IIRC).
[07:53:48] *** Quits: Jing (~hedgehog@240e:390:7c53:a7e1:b4c3:bc35:ccb7:fa58) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[07:54:00] <beach> mzan: What is your reason for showing your code?
[07:54:11] <mzan> nothing in particular
[07:54:25] <beach> mzan: Ah, so you don't want remarks on it?
[07:54:31] <mzan> I have problems to go to bed/sleep tonight (I'm not kidding)
[07:55:14] <mzan> beach: If you want remark something, it is very good. My I'm mainly here for chatting.
[07:55:52] *** Joins: aartaka (aartaka@gateway/vpn/protonvpn/aartaka)
[07:55:58] <beach> I see.
[07:56:35] <mzan> sm2n: I read something about type declarations in "iterate", but I will study it better. Thanks!
[07:57:34] <mzan> BTW, in case of doubts I can expand the code generated by the "iterate" macro, so for sure the problem was not obfuscated by the environment.
[07:57:57] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 240 seconds)
[07:58:45] <mzan> Probably in future I will try to micro-optimize the code, removing left notes signaled by SBCL, and benchmark the difference.
[07:59:03] <mzan> Now it is good enough, and better than I were expecting.
[08:00:36] <mzan> moon-child: I tried SERIES. In theory they should be superior to "iterate", because you can reuse chunks of code transforming data in different places. SERIES support this.
[08:01:19] <mzan> In practice, up to date, rarely I feel to write more code in "iterate" than in SERIES. And "iterate" is more flexible and more in line with the imperative semantic of some parts of CL.
[08:02:20] <sm2n> I agree with this
[08:03:50] *** Joins: xsperry (~xs@user/xsperry)
[08:04:02] *** Joins: occ (~occ@user/occ)
[08:04:06] * moon-child just uses loop
[08:04:16] <EdLangley[m]> I think the sort of implicit stream-fusion SERIES does ends up being pretty limited in CL
[08:04:24] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[08:05:14] <EdLangley[m]> I've been experimented with transducers (from Clojure) that work more explicitly by passing a continuation around, and I think they're a better fit for lisps
[08:05:30] <EdLangley[m]> If you want to use MAP and friends
[08:05:55] <mzan> Are there transducers also for CL?
[08:09:20] <EdLangley[m]> I've been working on a port, but it's not really ready to shar
[08:09:23] <EdLangley[m]> *share
[08:09:37] <mzan> nice
[08:10:14] <mzan> Another thing I didn't liked to CL, it is that there is some lack of basic data-structures. In Haskell there is a rather efficient IntMap for example, and other data structures. C++ has plenty of them.
[08:10:34] *** Quits: Bike (~Bike@71.69.170.70) (Quit: Connection closed)
[08:10:36] <EdLangley[m]> The trick behind them is pretty simple: https://twitter.com/fwoaroof/status/1337667255727886337
[08:10:43] *** Joins: dre (~dre@2001:8004:4410:f280:3c1f:c841:18ca:3236)
[08:12:23] <EdLangley[m]> mzan: various libraries implement datastructures
[08:13:07] <EdLangley[m]> I think FSET is one of the older ones
[08:14:00] <EdLangley[m]> Also, Sycamore, which I've never used
[08:16:45] *** Joins: semz_ (~semz@user/semz)
[08:17:16] <mzan> ahhh "(1+ ...)". I din't know there were this function, but I suspected there were something of similar! :-)
[08:19:14] *** Quits: semz (~semz@user/semz) (Ping timeout: 250 seconds)
[08:19:45] *** Quits: dre (~dre@2001:8004:4410:f280:3c1f:c841:18ca:3236) (Read error: Connection reset by peer)
[08:20:41] <mzan> EdLangley[m]: I don't know TRANDUCERS, but you example seems anti-intuitive to me. You are usinng a "reduce", but you pass a function that creates a stream (a vector in this case).
[08:20:55] <mzan> In SERIES you work with streams, and there is fusion.
[08:21:26] <mzan> In your example, "compose" apparently do not work on streams using fusion, but only on the entire result.
[08:21:57] <mzan> I'm not able to grasp the paradigm.
[08:22:37] *** Quits: lispy (~lispy4@84.69.59.93) (Quit: Leaving)
[08:23:47] <mzan> In my ideal world, I would like stream transformers with an optional internal state, that can be fused. Then some final reducers.
[08:23:59] <EdLangley[m]> So, functions like MAPPING return a function that takes a continuation as an argument
[08:24:11] <EdLangley[m]> Conventionally, this is called RF, for "reducing function"
[08:24:54] <EdLangley[m]> This returns a function with the signature you'd pass to REDUCE: (ACC NEXT) -> whatever
[08:25:46] <EdLangley[m]> This function, instead of building up a result with an explicit constructor, calls RF and passes an appropriate value of ACC and NEXT to it
[08:26:09] <EdLangley[m]> So, for MAPPING, this means something like (funcall rf acc (funcall transform next))
[08:26:21] <EdLangley[m]> Where transform is the argument passed to MAPPING
[08:27:49] *** Joins: s-liao (~s-liao@101.86.96.21)
[08:31:06] *** Joins: Jing (~hedgehog@240e:390:7c53:a7e1:54a1:8815:7a95:cd26)
[08:31:06] <mzan> I don't know CL enough for understanding all your code. But it is usefull reading it for me.
[08:32:01] <mzan> This seems rather readable, BTW
[08:32:02] <mzan>  (reduce (funcall (compose (mapping #'parse-integer)
[08:32:02] <mzan>                                       (mapping #'2*)
[08:32:02] <mzan>                                       (mapping #'1+))
[08:32:02] <mzan>                              'add-to-snoc)
[08:32:13] <beach> mzan: Don't do that please.
[08:32:23] <beach> mzan: Use a paste service for more than one line of code.
[08:32:45] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[08:32:59] <moon-child> (mapping f) ‚Üê‚Üí (lambda (&rest x) (apply #'mapcar f x))?
[08:33:46] <EdLangley[m]> It's equivalent to that
[08:33:57] <moon-child> ok
[08:34:08] <EdLangley[m]> But (compose (mapping f) (mapping g)) doesn't build up an intermediate collection
[08:34:16] <moon-child> then it seems to me that compose distributes over mapping
[08:34:35] <moon-child> i.e. instead of (compose (mapping f) (mapping g)), you can say (mapping (compose f g))
[08:34:39] <moon-child> so it does not matter so much anyway
[08:34:50] <EdLangley[m]> Yeah, that's just an example
[08:34:53] <moon-child> err, mapping distributes over compose
[08:35:24] <EdLangley[m]> With a full library, you can do like: (compose (mapping #'1+) (filtering #'evenp) . . .)
[08:35:49] <moon-child> (loop for x in xs if (evenp x) collect (1+ x))
[08:35:51] <moon-child> :^)
[08:35:58] <EdLangley[m]> Basically, any operation that can be expressed through the lambda you pass to REDUCE, you can do this way
[08:36:38] <EdLangley[m]> Yeah, but the point is to preserve the (mapcar (lambda (b) ...) (mapcar (lambda (a) ...))) style
[08:36:44] <EdLangley[m]> without the extra garbage
[08:37:06] <moon-child> I worry more about indirect calls than garbage
[08:37:19] <EdLangley[m]> If you don't care or like that style, it matters less :)
[08:37:58] <EdLangley[m]> This also abstracts from the concrete result type and from limitations like "the input sequence must be finite"
[08:38:39] <EdLangley[m]> You can express an operation once and pick whether it builds a list, a vector or puts results on a channel of some sort at the use-site
[08:38:52] <moon-child> my primary exposure to this sort of style is apl (not clojure), which is very strongly oriented _away_ from streams
[08:38:54] <mzan> EdLangley[m]: SERIES are composable, in the sense you can reuse a complex SERIES definition as starting point of another SERIES. Is your paradigm composable?
[08:39:14] <EdLangley[m]> Yeah, that's the point
[08:40:17] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 240 seconds)
[08:40:28] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Remote host closed the connection)
[08:40:45] <mzan> so something like (defun even1+ () (compose (mapping #'1+) (filtering #'evenp)) can be reused, while a "loop" no.
[08:43:29] *** semz_ is now known as semz
[08:44:22] *** Joins: hineios1 (~hineios@a95-93-142-124.cpe.netcabo.pt)
[08:45:27] *** Quits: hineios (~hineios@a95-93-142-124.cpe.netcabo.pt) (Ping timeout: 256 seconds)
[08:45:27] *** hineios1 is now known as hineios
[08:53:29] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[08:57:48] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 250 seconds)
[09:02:19] *** Joins: lispy (~lispy4@84.69.59.93)
[09:04:05] *** Joins: dre (~dre@2001:8003:c932:c301:7948:9e4c:da1f:659b)
[09:05:27] *** Quits: lispy (~lispy4@84.69.59.93) (Client Quit)
[09:06:18] *** Joins: karlosz (~karlosz@47.151.136.69)
[09:12:52] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[09:18:33] *** Joins: Inline (~Inline@ip-037-201-240-204.um10.pools.vodafone-ip.de)
[09:21:21] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 256 seconds)
[09:27:29] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[09:32:02] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 250 seconds)
[09:35:46] *** Quits: myrrh (~markus@172.58.197.224) (Quit: leaving)
[09:39:34] *** Quits: occ (~occ@user/occ) (Remote host closed the connection)
[09:39:55] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[09:42:40] *** Joins: occ (~occ@user/occ)
[09:44:10] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[09:44:30] *** Quits: occ (~occ@user/occ) (Remote host closed the connection)
[09:48:17] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 240 seconds)
[10:10:36] *** Parts: pranavats (3fba1d1b34@2a00:c70:1:178:170:40:189:1) (Error from remote client)
[10:20:57] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 240 seconds)
[10:23:15] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[10:30:11] *** Joins: ahc (~ahc@121.98.229.241)
[10:35:00] *** Joins: shka (~herr@109.231.0.226)
[10:40:17] *** Joins: s-liao (~s-liao@101.86.96.21)
[10:41:17] *** Quits: Inline (~Inline@ip-037-201-240-204.um10.pools.vodafone-ip.de) (Ping timeout: 240 seconds)
[10:47:32] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[10:51:37] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 240 seconds)
[11:01:27] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[11:09:17] *** Joins: MajorBiscuit (~MajorBisc@86-88-79-148.fixed.kpn.net)
[11:09:26] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[11:16:57] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 256 seconds)
[11:22:04] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[11:23:00] *** Joins: pranavats (3fba1d1b34@2a00:c70:1:178:170:40:189:1)
[11:26:32] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 240 seconds)
[11:27:25] *** Joins: Cymew (~ante@host-95-193-5-164.mobileonline.telia.com)
[11:36:30] *** Joins: mgl (~mgl@cpc87455-finc19-2-0-cust234.4-2.cable.virginm.net)
[11:41:06] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[11:44:05] *** Joins: s-liao (~s-liao@101.86.96.21)
[11:45:30] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 250 seconds)
[11:46:57] *** Joins: Major_Biscuit (~MajorBisc@c-001-017-008.client.tudelft.eduvpn.nl)
[11:49:32] *** Quits: luna-is-here (~quassel@2a02:908:f761:2a3c::a) (Ping timeout: 240 seconds)
[11:49:37] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[11:50:16] *** Quits: MajorBiscuit (~MajorBisc@86-88-79-148.fixed.kpn.net) (Ping timeout: 250 seconds)
[11:53:24] *** Joins: attila_lendvai (~alendvai@catv-89-132-245-188.catv.broadband.hu)
[11:54:21] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 256 seconds)
[12:02:05] *** Quits: ahc (~ahc@121.98.229.241) (Ping timeout: 256 seconds)
[12:05:52] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[12:06:47] *** Joins: Dynom (~niels@80-114-12-206.cable.dynamic.v4.ziggo.nl)
[12:08:01] *** Joins: pve (~pve@176-93-73-71.bb.dnainternet.fi)
[12:10:53] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 268 seconds)
[12:11:03] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Quit: Lost terminal)
[12:12:19] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[12:14:45] *** Quits: xantoz (~tewi_inab@c-c0bae255.013-124-73746f25.bbcust.telenor.se) (Ping timeout: 256 seconds)
[12:23:38] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 250 seconds)
[12:24:29] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[12:24:35] *** Joins: rogersm (~rogersm@90.166.180.250)
[12:26:18] *** Joins: lisp123 (~lisp123@5.30.23.247)
[12:28:37] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 240 seconds)
[12:41:03] *** Quits: Jing (~hedgehog@240e:390:7c53:a7e1:54a1:8815:7a95:cd26) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[12:41:33] *** Quits: attila_lendvai (~alendvai@catv-89-132-245-188.catv.broadband.hu) (Read error: Connection reset by peer)
[12:41:56] *** Joins: attila_lendvai (~alendvai@catv-89-132-245-188.catv.broadband.hu)
[12:43:46] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[12:47:09] *** Joins: Algernon69 (~Algernon6@2a04:cec0:10b2:4cc6:9099:c899:e6dc:2839)
[12:48:38] *** Joins: Jing (~hedgehog@240e:390:7c53:a7e1:e5fb:7a43:8199:8861)
[12:50:02] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 240 seconds)
[12:50:27] *** Quits: karlosz (~karlosz@47.151.136.69) (Ping timeout: 256 seconds)
[13:00:50] <shka> i need example of building with roswell
[13:03:41] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[13:12:36] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 250 seconds)
[13:15:47] *** Joins: szkl (uid110435@id-110435.uxbridge.irccloud.com)
[13:17:01] *** Quits: rogersm (~rogersm@90.166.180.250) (Ping timeout: 240 seconds)
[13:18:09] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[13:22:34] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 250 seconds)
[13:27:31] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[13:28:14] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[13:31:49] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 256 seconds)
[13:34:28] *** Joins: lisp123 (~lisp123@5.30.23.247)
[13:34:40] *** Joins: karlosz (~karlosz@47.151.136.69)
[13:38:13] *** Joins: Equill (~Equill@154.red-80-39-174.dynamicip.rima-tde.net)
[13:38:57] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 240 seconds)
[13:44:32] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[13:49:37] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 240 seconds)
[13:52:01] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[13:54:29] *** Quits: Cymew (~ante@host-95-193-5-164.mobileonline.telia.com) (Ping timeout: 256 seconds)
[14:02:37] *** Quits: Catie (~user@user/catie) (Ping timeout: 240 seconds)
[14:06:04] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[14:06:33] *** Joins: s-liao (~s-liao@101.86.96.21)
[14:09:17] *** Quits: Algernon69 (~Algernon6@2a04:cec0:10b2:4cc6:9099:c899:e6dc:2839) (Ping timeout: 268 seconds)
[14:10:42] *** Joins: Cymew (~ante@c-0c87225c.023-1144-7570702.bbcust.telenor.se)
[14:17:09] *** Joins: Lord_of_Life_ (~Lord@user/lord-of-life/x-2819915)
[14:18:17] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 256 seconds)
[14:18:27] *** Lord_of_Life_ is now known as Lord_of_Life
[14:20:55] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[14:28:17] *** Quits: jeosol (~jeosol@user/jeosol) (Ping timeout: 256 seconds)
[14:51:58] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[15:04:47] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 268 seconds)
[15:05:34] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[15:06:01] *** Quits: shozo (~user@178.74.52.55) (Ping timeout: 268 seconds)
[15:10:54] *** Joins: kevingal (~quassel@2a02:8084:4140:f300:f9d3:ce75:b234:b0dc)
[15:12:13] *** Quits: pillton (~user@202.168.60.161) (Remote host closed the connection)
[15:14:23] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[15:15:45] *** Joins: shozo (~user@178.74.52.55)
[15:18:42] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 250 seconds)
[15:21:39] *** Joins: rogersm (~rogersm@90.166.180.250)
[15:21:56] *** Joins: rain3 (~rain3___@2a02:2f09:d113:6d00:6f23:fba2:d834:1a7)
[15:23:01] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[15:23:37] *** Quits: scymtym (~user@ip-94-114-248-79.unity-media.net) (Ping timeout: 240 seconds)
[15:26:54] *** Joins: random-nick (~random-ni@87.116.167.125)
[15:27:22] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 250 seconds)
[15:28:05] *** Joins: gamaliel (~gamaliel@24.171.221.75)
[15:30:22] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[15:34:04] <gamaliel> Hi, does anyone have experience with the vgplot system? I don't know how to return a plot as a tk widget. When I run (vgplot:plot) it returns an empty string.
[15:34:47] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 256 seconds)
[15:36:31] *** Joins: lisp123 (~lisp123@5.30.23.247)
[15:36:39] *** Joins: gamaliel44 (~gamaliel@67.224.128.71)
[15:36:59] *** Quits: gamaliel44 (~gamaliel@67.224.128.71) (Client Quit)
[15:37:19] *** Joins: gamaliel78 (~gamaliel@67.224.128.71)
[15:38:29] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[15:39:41] *** Quits: gamaliel (~gamaliel@24.171.221.75) (Ping timeout: 256 seconds)
[15:40:30] *** Joins: vats (~vats@180.149.226.242)
[15:41:01] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[15:44:16] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 250 seconds)
[15:46:17] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[15:51:39] *** Joins: s-liao (~s-liao@101.86.96.21)
[15:54:20] *** Quits: karlosz (~karlosz@47.151.136.69) (Quit: karlosz)
[16:03:02] *** Quits: Cymew (~ante@c-0c87225c.023-1144-7570702.bbcust.telenor.se) (Ping timeout: 240 seconds)
[16:06:37] *** Joins: scymtym (~user@2001:638:504:20e6:6ac3:87e0:e782:f3fc)
[16:12:01] *** Joins: Algernon69 (~Algernon6@2a04:cec0:10b2:4cc6:64f3:cef2:5b2f:1a09)
[16:15:47] *** Quits: gamaliel78 (~gamaliel@67.224.128.71) (Quit: Client closed)
[16:18:15] *** Joins: Cymew (~ante@host-95-193-4-126.mobileonline.telia.com)
[16:23:19] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[16:27:07] *** Joins: s-liao (~s-liao@101.86.96.21)
[16:30:30] *** Quits: frodef (~frode@46.212.93.4) (Ping timeout: 268 seconds)
[16:31:20] *** Joins: frodef (~frode@46.212.93.4)
[16:38:15] *** Quits: vats (~vats@180.149.226.242) (Ping timeout: 256 seconds)
[16:39:17] *** Joins: varjag (~user@188.95.247.247)
[16:40:22] *** Quits: Algernon69 (~Algernon6@2a04:cec0:10b2:4cc6:64f3:cef2:5b2f:1a09) (Ping timeout: 268 seconds)
[16:42:37] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 240 seconds)
[16:44:43] <qhong> gamaliel: why you want to get a widget object? vgplot (or gnuplot) seems to rely extensively on global state and I think there‚Äôs no way to do that
[16:45:50] <qhong> gamaliel: iirc vgplot doesn‚Äôt manage its own GUI, it just sends command to a separate gnuplot process. I could be wrong. I was using it a lot for scientific computing but I had no need to hack it
[16:48:49] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[16:52:01] <ns12> qhong: That user is no longer online ...
[17:00:58] *** Joins: Algernon69 (~Algernon6@2a04:cec0:10b2:4cc6:64f3:cef2:5b2f:1a09)
[17:02:53] *** Quits: gjvc (~gjvc@user/gjvc) (Ping timeout: 250 seconds)
[17:05:44] *** Joins: lisp123 (~lisp123@5.30.23.247)
[17:08:43] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[17:10:13] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 240 seconds)
[17:10:22] *** Joins: Bike (~Bike@71.69.170.70)
[17:15:25] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 240 seconds)
[17:20:51] *** Joins: nij- (~jin@2001-48F8-9021-806-0-0-0-6F8B-dynamic.midco.net)
[17:21:57] <nij-> I just watched beach's talk again on FCGE. A main issue it addressed is that it's not easy to implement FCGE without sacrificing run-time performance. But I fail to understand how his implementation resolves this issue.. any idea?
[17:22:40] *** Joins: s-liao (~s-liao@101.86.96.21)
[17:23:08] *** Joins: VincentVega (~user@212.97.4.163)
[17:24:22] <Bike> FCGE?
[17:24:51] <contrapunctus> Bike: First Class Global Environments
[17:25:36] *** Quits: s-liao (~s-liao@101.86.96.21) (Client Quit)
[17:26:08] <Bike> oh. well, beach's implementation uses cells, so that at runtime to look up a definition you just grab it from a cell that was compiled in, which is pretty quick. that's not in the presentation?
[17:26:26] *** Joins: VincentV` (~user@212.97.4.163)
[17:27:37] *** Quits: VincentVega (~user@212.97.4.163) (Ping timeout: 240 seconds)
[17:31:57] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 240 seconds)
[17:34:09] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[17:46:23] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[17:46:50] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Remote host closed the connection)
[17:47:25] <nij->  I did stop and re-watch many parts of it, but still failed to see the reason. Hmm.. I also need to think more about what you said.
[17:47:27] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[17:47:50] <nij-> If not using this "cell method", what else did people try?
[17:49:21] <Bike> well the obvious way is like a hash table lookup
[17:51:55] *** Quits: OlCe (~user@lfbn-nic-1-109-134.w2-15.abo.wanadoo.fr) (Ping timeout: 256 seconds)
[17:55:38] *** Quits: Algernon69 (~Algernon6@2a04:cec0:10b2:4cc6:64f3:cef2:5b2f:1a09) (Read error: Connection reset by peer)
[17:55:53] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 256 seconds)
[17:56:03] *** Joins: Algernon69 (~Algernon6@2a04:cec0:10b2:4cc6:64f3:cef2:5b2f:1a09)
[17:56:54] <beach> nij-: An indirection through as CONS cell has the same cost as an indirection through a symbol, which is what most implementations do.
[17:57:22] <beach> nij-: And as Bike said, previous work used a hash-table lookup for each function call.
[17:57:25] <nij->  And by grabbing it from a cell, do you mean the same thing as (slot-value ..) in CLOS? I'm not sure how CLOS is implemented.. but whenever (slot-value ..) is evaluated, under the hood isn't it doing a hash table lookup?
[17:57:40] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Remote host closed the connection)
[17:58:13] <Bike> no, it's like a cons cell
[17:58:27] <Bike> like you compile #'foo as (car cell). cheap
[17:58:30] <beach> nij-: More like (funcall (internal-car (load-time-value (find-function-cell <name>))) arg...)
[17:58:46] <beach> nij-: Where INTERNAL-CAR is one instruction.
[17:59:13] *** Joins: Inline (~Inline@ip-037-201-240-204.um10.pools.vodafone-ip.de)
[18:00:20] <nij-> How does it perform #'find-function-cell ?
[18:00:49] <nij-> I suppose there should still be a mechanism for it to look over a collection of cells, right? That doesn't make it as inefficient as a hash table lookup?
[18:01:17] <phoe> you are skipping the LOAD-TIME-VALUE
[18:01:54] <phoe> by the time INTERNAL-CAR is called at all, LOAD-TIME-VALUE has already called FIND-FUNCTION-CELL and installed the reference to the concrete Lisp object in its stead
[18:06:26] <nij-> Tbh not fully understood yet. But notes taken. Thanks :)
[18:06:50] <phoe> the real work here is done by LOAD-TIME-VALUE
[18:07:00] <phoe> do you know how  the #. syntax works?
[18:07:08] <phoe> being able to evaluate stuff at read-time?
[18:07:58] <nij-> Yeah. Read that in cltl2.
[18:08:39] <nij-> Hmm.. so the goal is to make it efficient in run-time. And the heavy work has been done before run-time..?
[18:08:47] <phoe> then L-T-V is very similar, except evaluation happens at load-time
[18:09:02] <phoe> so when you get to runtime, the heavy work has already been done, yes
[18:09:19] <nij-> Oh great :)
[18:09:40] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[18:10:36] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[18:10:54] <beach> nij-: A typical Common Lisp implementation has an indirection through a symbol.  The work to find that symbol at load time is the same as that of FIND-FUNCTION-CELL.
[18:11:06] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[18:16:45] <nij-> Got it. I look forward to SICL. Thanks :)
[18:17:09] <beach> Pleasure.
[18:20:13] *** Joins: OlCe` (~user@lfbn-nic-1-117-92.w2-15.abo.wanadoo.fr)
[18:20:31] *** Joins: lisp123 (~lisp123@5.30.23.247)
[18:21:19] <phoe> it's fun to be a bystander to this, because I'm working on an article documenting a library utility that directly depends on LOAD-TIME-VALUE
[18:30:27] <beach> It is also fun to see how it is not widely known what a typical Common Lisp implementation has to do at load time in order to find the symbol corresponding to a function call in source code.  Nor is it widely known how a typical Common Lisp implementation represents the global (null-lexical) environment, as opposed to the lexical compile-time environments of CLtL2.
[18:31:14] <phoe> I think it's generally not widely known what a typical CL implementation has to do in order to achieve X, unless you're something of an implementer yourself
[18:31:30] <lisp123> TIL one of the inventors of Lisp Machines (Tom Knight) has founded a company worth $17bn as last year
[18:31:52] <lisp123> But their IT page has only mention of JavaScript and other crap
[18:32:18] <lisp123> I do wonder if there is some secret LISP code in there that they are keeping a trade secret
[18:33:25] <nij-> Sigh. I start wondering if JS is really that bad. Is there any formal argument that shows JS is inferior to Lisp?
[18:33:46] <phoe> I think #lispcafe will be happy to tell you that it is the former
[18:33:57] <beach> nij-: Programming languages can't be compared on a linear scale like that.
[18:34:07] <beach> And yes, off topic.
[18:41:01] *** Quits: Cymew (~ante@host-95-193-4-126.mobileonline.telia.com) (Ping timeout: 240 seconds)
[18:44:42] *** Quits: lisp123 (~lisp123@5.30.23.247) (Quit: Leaving...)
[18:45:17] *** Quits: attila_lendvai (~alendvai@catv-89-132-245-188.catv.broadband.hu) (Ping timeout: 240 seconds)
[18:51:30] *** Quits: pjb (~pjb@user/pjb) (Remote host closed the connection)
[19:00:26] *** shozo is now known as szos
[19:00:27] *** Quits: Algernon69 (~Algernon6@2a04:cec0:10b2:4cc6:64f3:cef2:5b2f:1a09) (Read error: No route to host)
[19:01:15] <qhong> beach: ‚ÄúOn the expressive power of programming languages‚Äù
[19:02:54] <nij-> qhong: In that paper, the author created a framework.
[19:03:07] <nij-> I failed to get how the framework is judged..
[19:03:16] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[19:04:12] <qhong> nij-: it‚Äôs just formalizing the well known notion of macro-expressibility actually
[19:04:36] *** Joins: Algernon69 (~Algernon6@2a04:cec0:10b2:4cc6:64f3:cef2:5b2f:1a09)
[19:05:27] <qhong> and it can yield bunch of sensible result, like mutation is real power, call/cc is real power, and delim/cc = call/cc + mutation > call/cc
[19:06:43] *** Joins: lisp123 (~lisp123@5.30.23.247)
[19:07:08] <lisp123> Not that I plan on doing it, but is it possible to call generic functions in a eval-when form (you know the ones that run code at load time)
[19:10:50] *** Quits: kevingal (~quassel@2a02:8084:4140:f300:f9d3:ce75:b234:b0dc) (Ping timeout: 268 seconds)
[19:11:44] *** Joins: pjb (~pjb@user/pjb)
[19:13:39] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[19:14:37] <Alfr> lisp123, the default behavior is for forms only to be evaluated when a compiled file is loaded, not when they are compiled.
[19:15:59] *** Quits: zbrown[m] (~zbrownsys@2001:470:69fc:105::1:4e81) (Quit: Client limit exceeded: 20000)
[19:16:10] <lisp123> Alfr: I mean this one (eval-when   (:compile-toplevel  :load-toplevel   :execute)  ‚Ä¶ )
[19:16:23] *** Joins: zbrown[m] (~zbrownsys@2001:470:69fc:105::1:4e81)
[19:17:28] *** Quits: pjb (~pjb@user/pjb) (Ping timeout: 250 seconds)
[19:18:08] <lisp123> Seems to work
[19:18:28] <lisp123> (eval-when   (:compile-toplevel  :load-toplevel   :execute) (defgeneric test (a)) (defmethod test ((a list))  (print "test"))  (test '(1 2 3)))
[19:18:35] <White_Flame> all functionality works at all run/load/compile-times.  the question is whether or not that functionality is loaded/present at that time
[19:18:37] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 256 seconds)
[19:18:48] <lisp123> White_Flame: Thanks
[19:18:55] <White_Flame> in terms of specific defun/defmacro/defvar/etc being completed at that point
[19:18:57] <White_Flame> it's all the same language runtime
[19:19:01] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[19:19:04] *** Joins: pjb (~pjb@user/pjb)
[19:19:10] <lisp123> Makes sense
[19:19:28] *** Parts: nij- (~jin@2001-48F8-9021-806-0-0-0-6F8B-dynamic.midco.net) (commonlisp)
[19:19:30] <lisp123> So as soon as the basic "CL" image is loaded, everything is kinda already in runtime?
[19:19:48] <lisp123> And then one loads into / compiles with against that live image?
[19:20:07] <White_Flame> everything standard for the implementation exists when the base image starts
[19:20:20] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[19:20:26] <phoe> if your question is "is CL loaded after CL is loaded", then the answer is "yes"
[19:20:31] <White_Flame> it's a snapshot of the constructed system and has very little initialization per runtime
[19:20:47] <lisp123> Got it
[19:21:08] <lisp123> White_Flame: But now I am curious, what do you mean by "very little initalization per runtime"
[19:21:11] <White_Flame> (relatively speaking.  it initializes the heap and whatever, but all the code is extant)
[19:21:29] <White_Flame> lisp123: I mean it doesn't do any loading at that point.  everything was already loaded before the image was made
[19:21:49] <lisp123> I see
[19:21:51] <White_Flame> now, further REQUIRE forms might pull in more stuff from the implementation, but generally speaking it's all already there
[19:21:51] <lisp123> Thanks!
[19:22:23] *** Joins: Cymew (~ante@host-95-193-4-126.mobileonline.telia.com)
[19:22:35] <Alfr> lisp123, for the interaction and about what may or may nor be available/done to your running image when you compile a form or file, see
[19:22:43] <Alfr> clhs 3.2.1
[19:22:43] <specbot> Compiler Terminology: http://www.lispworks.com/reference/HyperSpec/Body/03_ba.htm
[19:22:58] <lisp123> Alfr: Thanks for the link
[19:23:13] <Alfr> lisp123, especially those parts regarding environment.
[19:25:10] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[19:25:32] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 240 seconds)
[19:26:52] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 268 seconds)
[19:27:38] *** Joins: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se)
[19:32:13] *** Quits: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se) (Ping timeout: 256 seconds)
[19:35:18] *** Quits: szkl (uid110435@id-110435.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[19:38:15] *** Joins: lispy (~lispy4@84.69.59.93)
[19:39:19] *** Joins: ahammer (~ahammer@120.230.113.41)
[19:43:57] *** Quits: ahammer (~ahammer@120.230.113.41) (Ping timeout: 240 seconds)
[19:44:23] *** Joins: didi (~user@user/didi)
[19:45:02] *** Joins: gioyik (~gioyik@gateway/tor-sasl/gioyik)
[19:45:37] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[19:46:41] <didi> The last version (2.2) of SBCL eliminated my problems with ENOMEM errors. Thank you, SBCL developers. <3
[19:47:03] <phoe> didi: #sbcl might want to know about it too!
[19:47:12] <didi> Right on.
[19:47:20] *** Joins: jeosol (~jeosol@user/jeosol)
[19:47:48] *** Joins: ahammer (~ahammer@120.230.113.41)
[19:50:21] *** Quits: Cymew (~ante@host-95-193-4-126.mobileonline.telia.com) (Ping timeout: 256 seconds)
[19:51:06] *** Joins: lisp123_ (~lisp123@45.86.201.13)
[19:53:52] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 250 seconds)
[19:55:15] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[19:55:37] *** Quits: ahammer (~ahammer@120.230.113.41) (Ping timeout: 240 seconds)
[19:55:49] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 240 seconds)
[19:59:06] *** Joins: lisp123 (~lisp123@5.30.23.247)
[20:02:13] *** Quits: lisp123_ (~lisp123@45.86.201.13) (Ping timeout: 240 seconds)
[20:04:43] *** Joins: Algernon91 (~Algernon6@2a04:cec0:10b2:4cc6:1587:3049:52bb:efee)
[20:05:03] *** Quits: Algernon69 (~Algernon6@2a04:cec0:10b2:4cc6:64f3:cef2:5b2f:1a09) (Read error: No route to host)
[20:09:22] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[20:09:51] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[20:14:43] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 256 seconds)
[20:17:01] *** Joins: kevingal (~quassel@2001:770:c0:401:c8f5:e6ef:3f0f:f4d8)
[20:17:42] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 250 seconds)
[20:19:00] *** Quits: Inline (~Inline@ip-037-201-240-204.um10.pools.vodafone-ip.de) (Ping timeout: 250 seconds)
[20:23:53] *** Joins: frgo (~frgo@p548a30d7.dip0.t-ipconnect.de)
[20:24:47] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[20:25:10] *** Joins: Josh_2 (~user@37.25.47.130)
[20:25:30] <Josh_2> 'ello
[20:25:40] <phoe> hey hi
[20:26:55] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[20:27:27] <beach> qhong: Why are you telling me that?
[20:29:32] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 240 seconds)
[20:30:23] <drakonis> phoe: congrats on becoming a cdr editor
[20:31:10] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[20:31:13] <drakonis> may lots of CDRs be written :V
[20:31:42] <phoe> drakonis: we'll see where this goes - CDRs need implementations much more than they need authors
[20:31:59] <phoe> (or editors, truth be told)
[20:32:12] <drakonis> that is true, yes.
[20:32:17] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 256 seconds)
[20:32:45] <didi> Do CDRs come with implementations?
[20:32:51] *** Joins: occ (~occ@user/occ)
[20:32:53] <drakonis> SRFIs typically do.
[20:32:57] <didi> Indeed. ^
[20:33:10] <phoe> some sometimes do, but some ideas are hard or impossible to implement in portable CL
[20:33:37] <drakonis> portable CL is not the same as portable scheme, sadly.
[20:34:00] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[20:35:12] <drakonis> some of the existing CDRs are related to runtime functionality rather than language functionality
[20:36:56] *** Quits: Algernon91 (~Algernon6@2a04:cec0:10b2:4cc6:1587:3049:52bb:efee) (Read error: Connection reset by peer)
[20:37:59] <drakonis> they also leave the actual implementation up to the implementors
[20:39:06] *** Joins: artchad (~user@public-gprs225103.centertel.pl)
[20:39:20] <beach> Maybe I am wrong here, but if something could be implemented as portable Common Lisp code, wouldn't it just be a library rather than a CDR?
[20:39:27] *** Joins: attila_lendvai (~alendvai@2a02:ab88:3710:7c80:9130:5abf:96b3:dc0c)
[20:39:31] <drakonis> it probably could i guess?
[20:39:42] <beach> It seems to me that the CDR exists specifically because it can't be just a library.
[20:39:49] <drakonis> unless you want to roll that into the implementation to enhance it?
[20:40:07] <didi> Really? So it's different than SRFIs.
[20:40:16] <beach> I am just guessing.
[20:40:38] <EdLangley[m]> Some of them could
[20:40:43] <phoe> it seems to me that the CL ecosystem depends on de-facto libraries much more than Scheme depends on SRFIs
[20:40:44] <beach> drakonis: What do you mean by that?
[20:40:53] <EdLangley[m]> Like the one that specifies an interface for custom hash table tests
[20:41:03] <EdLangley[m]> Sorry, a protocol
[20:41:08] <sm2n> Yes, SRFIs are kind of scheme's standard library mostly; which is not an issue in CL
[20:41:17] *** Joins: Inline (~Inline@ip-037-201-240-204.um10.pools.vodafone-ip.de)
[20:41:19] <phoe> and e.g. Ironclad has customized code that is compiled only on SBCL for performance reasons
[20:41:22] <etimmons> It seems CDRs are not focused on things that require implementation support.
[20:41:28] <etimmons> > For example, a CDR document can contain specifications of libraries, language extensions, example implementations, test suites, articles, etc.
[20:41:35] <etimmons> ^ from the CDR home page
[20:41:58] <drakonis> you can either write it as a generic library that's pure scheme/CL or write an implementation that takes advantage of features provided by the implementation
[20:42:06] <beach> etimmons: I can believe what the home page says, but it still seems to me that the main point would be as I guessed.
[20:42:18] <phoe> if Ironclad was a SRFI, which it could, then it would provide some API for accessing crypto functions, and then either SBCL would ship ironclad-performance-specific code with itself as a contrib or ironclad would carry SBCL-specific code with itself
[20:42:25] <phoe> ...and the latter is exactly what happens now!
[20:42:35] <drakonis> that's how it works with srfis
[20:42:36] <etimmons> beach: Agreed! And I thought that was the point as well until only recently
[20:42:40] <phoe> drakonis: so, uh
[20:42:43] <drakonis> i guess
[20:42:44] <random-nick> there was that one CDR about generic EQUALS
[20:42:45] <beach> etimmons: I see.
[20:42:48] <phoe> CL already has SRFIs, except they're named differently
[20:42:52] <drakonis> yes i know
[20:42:57] *** Joins: morganw (~user@80.225.24.132)
[20:43:01] <random-nick> that would I guess be a CDR for library writers and not for implementation writers
[20:43:10] <phoe> random-nick: oh yes, and I dislike it, specifically because it has no way of conveying intent (see kmp's writeup on the topic)
[20:43:12] <drakonis> CDRs, the suite of portability libraries called trivial-*
[20:43:23] <phoe> http://www.nhplace.com/kent/PS/EQUAL.html
[20:43:57] <pve> Hi, is there a Zork-like game (text-based adventure) written in CL that I could study? Zork itself was written in some other dialect of lisp.
[20:44:26] <drakonis> hmm
[20:44:29] <drakonis> hold on
[20:44:32] <EdLangley[m]> One of the things about generic equality is that it's usually possible to right a :key function that lets you use the standardized equality predicates
[20:44:49] <EdLangley[m]> can't spell: s/right/write/
[20:44:49] <drakonis> i think there's a zil interpreter someone wrote years ago
[20:45:01] *** Joins: Oladon (~olad@98.43.81.226)
[20:45:03] *** Joins: lisp123 (~lisp123@5.30.23.247)
[20:45:11] <phoe> drakonis: https://github.com/LispEngineer/Pretzil ?
[20:45:13] *** Quits: lisp123 (~lisp123@5.30.23.247) (Read error: Connection reset by peer)
[20:45:24] <pve> Alternatively a MUD could work too.
[20:45:31] <drakonis> that's one
[20:45:33] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[20:45:50] <drakonis> it wasnt the one i was thinking of
[20:46:31] <drakonis> i thought about gargoyle but it does not do zil
[20:46:46] <drakonis> anyways, i think i might have misunderstood the question
[20:46:48] <drakonis> hold on
[20:47:11] <drakonis> https://medium.com/the-software-firehose/architecting-a-text-adventure-game-2e0dc4d49812
[20:47:16] <drakonis> this is in clisp
[20:47:28] <drakonis> targets the clisp cl implementation
[20:47:49] <drakonis> https://github.com/shaaza/text-adventure-game
[20:47:54] <drakonis> cannot attest to its quality though
[20:49:03] <phoe> the code at https://github.com/shaaza/text-adventure-game would need untabification before it's readable to me
[20:49:06] <random-nick> phoe: right, but it makes me wonder if presentation types could be generalised a little to allow for things such as equality, hashing, serialisation, etc.
[20:49:18] <pve> drakonis: Thanks for the links, I'll check those out. It doesn't necessarily have to CL code, architecture is interesting too.
[20:49:32] <phoe> random-nick: presentation types, you mean CLIM ones?
[20:49:43] <drakonis> https://github.com/scheme-requests-for-implementation
[20:49:44] <phoe> if yes, then I'm not wise in the ways of CLIM so I cannot really answer that
[20:49:50] <random-nick> yeah, the equality essay has a section at the end
[20:50:28] <drakonis> its impressive imo
[20:51:12] <random-nick> basically, commands are defined to accept arguments of specific presentation types and all presentations have a presentation type attached
[20:51:19] <drakonis> the real question here is, what can be turned into a CDR that isn't already a library everyone uses?
[20:52:12] <random-nick> and presentation types also have defined a way of getting accepted (other than clicking on a presentation of the given type)
[20:53:12] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 268 seconds)
[20:53:32] <phoe> drakonis: the real real question here is, what CDRs can be turned into a library everyone uses
[20:53:48] <drakonis> that's a reversal, but good point/question.
[20:54:23] <phoe> in particular, how to make something that's useful, as in, actually usable and used by people to solve real-world problems
[20:55:02] <phoe> I kinda guess that "notarizing" already de-facto standards into CDRs is the easy part and also the part that brings little overall benefit
[20:55:13] <phoe> the hard part is making stuff that works
[20:55:35] <pve> drakonis: The reason I asked (or one reason, anyway) is I'd like to find out if there are "standard" solutions to how to make creatures etc react to certain events. Say I'm in a room and drop a piece of gold. Then the greedy gnome in the same room should notice this and immediately try to grab the gold. Stuff like that.
[20:55:41] <random-nick> also, it would be nice if the compatibility libraries decoupled their implementation support from their main systems
[20:56:06] <phoe> random-nick: decoupled, as in? e.g. swank already does this
[20:56:25] <mfiano> pve: Dijkstra maps. That's all you need to research :)
[20:56:26] <phoe> it doesn't mean that you can use swank without an implementation-dependent piece of code, but the API is separated from the backend
[20:56:33] <drakonis> there are large features that could be lifted from the schemes
[20:56:35] <random-nick> mezzano has to use a bunch of patched compatibility libraries because its internal interfaces aren't stable enough to upstream the patches
[20:56:51] <drakonis> a cdr for something like the suite of hygienic macros?
[20:56:54] *** Joins: cage (~cage@dynamic-adsl-84-221-50-16.clienti.tiscali.it)
[20:57:24] <drakonis> but its not something widely loved by the CL community because they all prefer regular macros
[20:57:30] <phoe> drakonis: that sounds mostly implementable as a standalone library on top of CL
[20:57:41] <pve> mfiano: thank you
[20:57:47] <phoe> is there anything that would require strict implementation support for that?
[20:58:15] <EdLangley[m]> I think you'd need enviroment information of some sort
[20:58:35] <EdLangley[m]> To reliably get bindings in a bit of code?
[20:58:44] <EdLangley[m]> Or a good code-walker
[20:58:51] <phoe> we have good code walkers now
[20:59:00] <mfiano> It's called symbol-macrolet
[20:59:05] <phoe> :D
[20:59:31] <random-nick> drakonis: well I think a lot of the use for hygienic macros isn't there in CL because of CL's package system
[20:59:51] <EdLangley[m]> Also, hygienic macros are harder to read, IMO
[20:59:58] <mfiano> Much harder
[21:00:03] <random-nick> where packages contain symbols instead of the scheme way of having a global symbol table and modules mapping symbols to values
[21:00:16] <EdLangley[m]> Especially racket's syntax-parse macros which always involve some complicated parser DSL
[21:00:24] <qhong> beach: so there‚Äôs a partial order at least
[21:00:27] <didi> You know what we need? A TAB format directive.
[21:00:33] <qhong> And maybe even a lattice
[21:00:54] <didi> Or even a TAB string literal.
[21:01:16] <phoe> FORMAT Tilde Backspace, the quantum format directive that erases itself the moment somebody looks
[21:01:36] * didi erases phoe
[21:01:59] <mfiano> ~üêà
[21:02:19] <random-nick> mit-scheme has a hygienic macros system where you write macros like with defmacro but symbols which you want to be exposed to user code (like the anaphoric IT or anything similar) you include as a "syntactic closure" instead of just as the symbol object itself
[21:02:51] <drakonis> to be fair, racket is vaguely a scheme now
[21:03:13] <random-nick> such a style would be nicer imo, but still not that useful considering the package system
[21:03:22] <phoe> drakonis: that might already be a bit over the offtopic line
[21:03:28] <drakonis> yes
[21:03:37] <drakonis> but back to the topic at hand
[21:05:09] <drakonis> it is certainly hard to find something to crib from elsewhere
[21:05:17] <didi> Come to think about it, I would welcome a implementation extension that implemented string literals.
[21:05:43] <phoe> ...
[21:05:46] <phoe> you mean like "foo"?
[21:06:00] <drakonis> make continuations a cdr
[21:06:02] *** Quits: mgl (~mgl@cpc87455-finc19-2-0-cust234.4-2.cable.virginm.net) (Quit: Client closed)
[21:06:02] <didi> Not, like "foo\tbar" meaning "fooTABbar".
[21:06:12] <phoe> didi: (ql:quickload :cl-interpol)
[21:06:19] <didi> phoe: Thanks.
[21:06:21] <drakonis> that one had a library written eons ago
[21:06:28] <random-nick> drakonis: UNWIND-PROTECT doesn't support reentrancy
[21:06:37] <didi> I want batteries, not libraries!
[21:06:37] <drakonis> i see
[21:06:38] <mfiano> I would welcome an extension for extended number literal syntax
[21:06:46] <phoe> then (cl-interpol:enable-interpol-syntax) #?"foo\tbar"
[21:06:49] <moon-child> didi: you can just write tabs literally in your source code
[21:07:01] <didi> moon-child: I do. They are not ideal.
[21:07:08] <moon-child> mfiano: how would you extend the number syntax?
[21:07:16] <phoe> moon-child: 1_000_000_000_000_000
[21:07:21] <phoe> instead of 1000000000000000
[21:07:22] <mfiano> 1_000_000 or 1000_1010_0001_1011
[21:07:24] <moon-child> ah yeah that would be good
[21:07:33] <mfiano> err #b for the last
[21:07:42] <phoe> that's actually one idea that sounds really suitable as a CDR
[21:07:56] <phoe> because of the "possible number syntax" part of the spec that could kinda allow it
[21:08:24] <random-nick> maybe lambda macros could be a CDR?
[21:08:24] <phoe> clhs 2.3.1.1
[21:08:25] <specbot> Potential Numbers as Tokens: http://www.lispworks.com/reference/HyperSpec/Body/02_caa.htm
[21:08:30] <phoe> random-nick: lambda macros?
[21:09:14] <phoe> continuations could be a CDR, too - I've seen a few discussions about how to solve the U-P reentrancy problem
[21:09:23] <random-nick> it was a feature on some old lisp I remember reading about, basically defining a lambda macro FOO would get called when you do something like ((FOO BAR) BAZ)
[21:09:40] <random-nick> s/defining //
[21:09:52] <phoe> oh, so extra syntax for when an operator call argument is a list - like ((lambda ...) ...) is supported in standard CL
[21:10:14] <drakonis> lexical macros?
[21:10:20] <phoe> drakonis: you mean MACROLET?
[21:10:20] <didi> phoe: If I recall correctly, schemers don't like continuations no more. Apparently "delimited continuations" are the way to go. I understand neither.
[21:10:32] <mfiano> lexical generic functions
[21:10:39] <EdLangley[m]> Yeah, continuations aren't really as useful
[21:10:55] <phoe> mfiano: https://www.reddit.com/r/Common_Lisp/comments/s98u12/portable_implementations_of_genericlabels_and/
[21:11:08] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[21:11:08] <EdLangley[m]> Delimited continuations have better properties because they exist within a scope
[21:11:22] <random-nick> delimited continuations are also reentrant, which is a no-go if there's a UNWIND-PROTECT in the delimited area of the stack
[21:11:23] <drakonis> delimited continuations are nice too
[21:11:25] <phoe> EdLangley[m]: err, yes, I meant that
[21:11:35] <EdLangley[m]> I tried implementing this once and came up with something that sort of worked.
[21:11:49] <random-nick> but better than global continuations on that front
[21:12:04] <mfiano> phoe: translation needed
[21:12:06] <EdLangley[m]> random-nick: Yeah, I think there's some sort of continuation-barrier concept that helps with that
[21:12:15] <random-nick> I think mezzano has delimited continuations, not sure what are they used for
[21:12:31] <phoe> mfiano: read Lisp rather than Japanese, you can figure it out
[21:12:37] <EdLangley[m]> I tried implementing generic lambdas once, capturing the correct lexical environment is really tricky
[21:12:45] *** Joins: mgl (~mgl@cpc87455-finc19-2-0-cust234.4-2.cable.virginm.net)
[21:12:47] <random-nick> https://github.com/froggey/Mezzano/blob/master/system/delimited-continuations.lisp
[21:12:52] <phoe> in particular, DEFMACRO GENERIC-FLET and DEFMACRO GENERIC-LABELS
[21:12:55] <random-nick> it mentions continuation barriers too
[21:13:08] <EdLangley[m]> That implementation is weird
[21:14:07] <phoe> the DEFGENERIC with a gensym is a big shortcut, but I guess it works
[21:14:10] <EdLangley[m]> I think that (load-time-value (defgeneric ...)) will have the same problem
[21:14:27] <phoe> EdLangley[m]: oh! I see what you mean
[21:14:47] <EdLangley[m]> I eventually gave up because of this
[21:14:47] <EdLangley[m]> And (load-time-value ... (defmethod ...))
[21:15:31] <EdLangley[m]> But, if you don't care about the lexical environment of the lambda, this works: https://github.com/fiddlerwoaroof/fwoar.lisputils/blob/master/glambda.lisp
[21:15:55] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 256 seconds)
[21:17:10] <mfiano> phoe: I read the code and the use of LOAD-TIME-VALUE makes me question its usefulness
[21:17:11] *** Quits: lispy (~lispy4@84.69.59.93) (Quit: Leaving)
[21:19:06] <phoe> hmmmm
[21:19:14] <phoe> I think I have an idea
[21:19:49] <phoe> make the GF itself a load-time-value, but initialize the GF by adding methods to it the moment control first reaches it
[21:20:09] <phoe> this will allow the method functions to freely capture lexical environment
[21:20:20] <phoe> kinda sorta just like the thing I'm doing with Serapeum's STATIC-LET right now
[21:21:13] <EdLangley[m]> Yeah, I think that works
[21:21:28] * phoe adds to his TODO list
[21:21:30] <EdLangley[m]> Although, the problem you might run into is a memory leak
[21:21:41] <phoe> where exactly?
[21:21:46] <EdLangley[m]> If the methods aren't cleaned up
[21:21:58] <phoe> they don't need to be cleaned up though
[21:22:11] <phoe> just like a "normal" GF's methods aren't cleaned up
[21:22:12] <EdLangley[m]> Every time you add a method to the L-T-V generic function, the size of the generic function increases in memory
[21:22:19] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[21:22:22] <phoe> this is why I only want to do this once
[21:22:35] <phoe> and the moment I reevaluate a form containing L-T-V, a new GF will get created
[21:22:36] <EdLangley[m]> If the method has an EQL specializer on a lexically-created object, the generic function will pin the method and the method will pin the object
[21:23:02] <phoe> and the old GF will eventually get collected
[21:23:04] <EdLangley[m]> At the very least, the generic function will pin the method
[21:23:20] <EdLangley[m]> > the moment I reevaluate a form containing L-T-V
[21:23:26] <phoe> yes, but this isn't a problem if the GF becomes unreachable, right?
[21:23:30] *** Quits: Jing (~hedgehog@240e:390:7c53:a7e1:e5fb:7a43:8199:8861) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[21:23:38] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[21:23:45] <EdLangley[m]> Yeah, but (loop repeat 1000 do (something-with-anonymous-gf)) will leak
[21:24:12] <EdLangley[m]> reevaluating the definition of SOMETHING-WITH-ANONYMOUS-GF only really happens during development
[21:24:12] <phoe> that's why I only want to initialize the GF once
[21:24:22] <phoe> that is, add the methods once, and then never do it again
[21:24:26] <phoe> and I know how to do that
[21:24:27] <EdLangley[m]> In production, the generic function will last forever
[21:24:46] <EdLangley[m]> I think I need a pastebin to explain the problem :)
[21:24:54] <phoe> please do :D
[21:26:12] <EdLangley[m]> https://fwoar.co/pastebin/ac3053d94f8dcd36990a2abdebb08ae74d0db626.lisp.html
[21:26:40] <EdLangley[m]> If the generic function is created by generic-flet is created once, at load time
[21:27:10] <EdLangley[m]> Then it's possible to implement the (:method ...) part in a way that that EQL specializer adds a new method every time the function runs
[21:28:12] <EdLangley[m]> So, first of all, you'll have an indefinitely growing collection of methods attached to the l-t-v generic function
[21:28:44] <EdLangley[m]> And the EQL specializer of each method will keep an instance of BIG-OBJECT alive as well
[21:29:00] <EdLangley[m]> So, basically, you need an UNWIND-PROTECT to cleanup the methods
[21:31:10] <phoe> yes, I see
[21:32:13] *** Joins: lisp123 (~lisp123@5.30.23.247)
[21:32:20] <phoe> still, sounds doable
[21:32:39] <lisp123> For some reason, every time I restart my Lisp image, I need to reset the ASDF configuration to load a recently defined pacakge
[21:32:56] <lisp123> Sounds like an error on my side?
[21:33:32] *** Joins: vats (~vats@180.149.226.242)
[21:33:53] <lisp123> Fixed it - Ignore me!
[21:33:54] <Bike> if nothing else, you could probably reset or whatever in your rc
[21:33:58] <Bike> too late!
[21:34:06] <Bike> so: are we bringing back generic-flet
[21:34:13] <lisp123> :D
[21:34:17] <phoe> Bike: kinda sounds like it!?
[21:34:41] <Bike> i've never quite understood what it would be good for, so i'd be interested in seeing usage
[21:35:16] <EdLangley[m]> I find generic-lambda more interesting
[21:35:40] <phoe> generic-lambda would simply return an instance of GENERIC-FUNCTION, right?
[21:35:46] <phoe> an anonymous one
[21:35:51] <EdLangley[m]> For me, at least, it's more a nicer syntax for a typecase inside a lambda, when you're mapping over a bunch of objects of different types
[21:35:52] <phoe> the main issue is closing over stuff
[21:35:59] <EdLangley[m]> Yeah
[21:36:17] <EdLangley[m]> The main difference with a typecase is you can use :around and stuff
[21:36:30] <EdLangley[m]> I have a sample somewhere...
[21:36:30] <phoe> sounds doable then - the main issue is avoiding multiple compilations I guess
[21:36:47] <phoe> so, like, try to compile the method functions once, and then just close over the arguments that the GF needs to close over
[21:37:06] <phoe> that's the main performance hurdle I see
[21:37:19] <EdLangley[m]> the issue I ran into was figuring out how to capture the lexical environment correctly
[21:37:20] <phoe> this, and EQL specializers
[21:38:28] <EdLangley[m]> but, I was trying to do it through the MOP rather than using DEFGENERIC and friends
[21:38:45] <phoe> doing it through the MOP should also be viable I think
[21:39:00] <phoe> the main hurdle I see is COMPILE being a butt in presence of lexical bindings, if we want to be strictly compliant
[21:39:12] <phoe> which is an issue me and Bike talked about some time ago here
[21:39:25] <phoe> s/the main hurdle/a minor hurdle/
[21:40:22] <phoe> but, yeah, even if we go through the MOP, that should be doable
[21:40:40] <phoe> I mean, if DEFGENERIC can properly capture the lexical environment, then the MOP must be able to as well
[21:40:58] <EdLangley[m]> Yeah, I couldn't figure out how to make the stuff inside COMPILE able to access the lexical enviroment
[21:41:05] <EdLangley[m]> But, I was probably doing something wrong
[21:41:09] <phoe> that's the neat thing, you don't
[21:41:43] <phoe> special opeartor FUNCTION itself must access the lexical environment; if anything, you just COMPILE whatever is the result of it
[21:41:56] <phoe> in particular, (FUNCTION (LAMBDA ...)) must access it
[21:42:17] <phoe> and you need to compile the function object that pops out when you evaluate a call to FUNCTION
[21:42:39] <EdLangley[m]> Hmm, maybe that works
[21:42:40] <mfiano> Can I change the displaced-index-offset of an existing displaced array object to be able to updated the displaced-to array at different locations without constructing multiple displaced arrays?
[21:42:51] <mfiano> I don't work with displaced arrays much at all. Thanks
[21:42:53] <phoe> this, and there's the interaction with MAKE-METHOD-LAMBDA that needs to be taken into account
[21:42:59] <EdLangley[m]> I remember I spent a long time looking at the macroexpansion and definition of DEFMETHOD trying to figure this out
[21:43:33] <phoe> mfiano: doesn't seem possible, ARRAY-DISPLACEMENT is a reader and not a writer
[21:43:46] <mfiano> That makes me sad
[21:44:02] <phoe> EdLangley[m]: I think the macroexpander needs to call MAKE-METHOD-LAMBDA and splice the result of calling it into the macroexpansion
[21:44:14] <phoe> then the compiler will be capable of making lexical closures
[21:44:29] *** Joins: Catie (~user@user/catie)
[21:44:37] <phoe> hmmmmm, this actually seems doable
[21:44:48] <EdLangley[m]> I think ADJUST-ARRAY can change the displacement
[21:44:53] <EdLangley[m]> clhs ADJUST-ARRAY
[21:44:53] <specbot> http://www.lispworks.com/reference/HyperSpec/Body/f_adjust.htm
[21:45:05] <phoe> !
[21:45:06] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[21:45:13] <Bike> yes, adjust-array can change the displacement, mfiano.
[21:45:17] <phoe> nice, TIL! thanks
[21:45:18] *** Joins: lispy (~lispy4@84.69.59.93)
[21:45:21] <mfiano> Nice!
[21:45:23] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 256 seconds)
[21:45:26] <EdLangley[m]> (adjust-array array (array-dimensions array) :displaced-to whatev :displaced-index-offest 4)
[21:45:30] *** Quits: pjb (~pjb@user/pjb) (Remote host closed the connection)
[21:45:30] <Bike> the rules for this are a large part of the definition, even, since it's kind of complicated
[21:45:47] <EdLangley[m]> I used this a couple times to slide a window over a string
[21:45:50] <mfiano> Does asjust-array specify if a new array object is created or if the index pointer is moved?
[21:46:01] <Bike> also, yes, for generic-flet you'd want to go through the make-mmethod-lambda rigamarole and avoid actually calling COMPILE.
[21:46:32] *** Quits: Major_Biscuit (~MajorBisc@c-001-017-008.client.tudelft.eduvpn.nl) (Ping timeout: 250 seconds)
[21:46:36] <Bike> mfiano: a new object is only created if the array isn't "actually adjustable". you can assure an array is actually adjustable by specifying :adjustable t in make-array.
[21:47:09] <mfiano> Ok, and I can make the displaced array adjustable without affecting the displaced-to simple-array?
[21:47:26] <Bike> Yes. You're not actually altering the underlying array in any way.
[21:47:34] <mfiano> This is excellent. I just found a really good use for displaced arrays for once.
[21:47:38] <mfiano> Thank you!
[21:47:45] <Bike> No problem
[21:53:17] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[21:57:20] *** Quits: rain3 (~rain3___@2a02:2f09:d113:6d00:6f23:fba2:d834:1a7) (Ping timeout: 268 seconds)
[21:58:32] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 240 seconds)
[21:58:57] *** Joins: Algernon91 (~Algernon6@2a01:e0a:511:6ce0:f190:fe95:722d:f13c)
[21:59:26] *** Joins: szkl (uid110435@id-110435.uxbridge.irccloud.com)
[22:01:03] *** Joins: AeroNotix (~xeno@185.107.67.252)
[22:04:25] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[22:06:45] *** Joins: azimut_ (~azimut@gateway/tor-sasl/azimut)
[22:07:51] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Ping timeout: 276 seconds)
[22:11:14] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 250 seconds)
[22:14:52] *** Joins: dra (~dra@2a04:4540:6422:2c00:1c1a:dda9:f862:c077)
[22:15:13] *** Quits: Algernon91 (~Algernon6@2a01:e0a:511:6ce0:f190:fe95:722d:f13c) (Ping timeout: 268 seconds)
[22:16:19] *** Joins: mmk2410 (~mmk2410@user/mmk2410)
[22:16:21] *** Quits: mmk2410_ (~mmk2410@mmk2410.org) (Ping timeout: 256 seconds)
[22:20:03] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[22:22:07] *** Joins: Algernon91 (~Algernon6@2a01:e0a:511:6ce0:f190:fe95:722d:f13c)
[22:23:01] *** Quits: kevingal (~quassel@2001:770:c0:401:c8f5:e6ef:3f0f:f4d8) (Remote host closed the connection)
[22:27:47] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[22:29:01] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 256 seconds)
[22:29:17] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[22:33:06] *** Quits: Algernon91 (~Algernon6@2a01:e0a:511:6ce0:f190:fe95:722d:f13c) (Ping timeout: 268 seconds)
[22:33:20] *** Quits: attila_lendvai (~alendvai@2a02:ab88:3710:7c80:9130:5abf:96b3:dc0c) (Ping timeout: 250 seconds)
[22:41:57] *** Quits: didi (~user@user/didi) (Ping timeout: 240 seconds)
[22:45:26] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 268 seconds)
[22:45:34] *** Joins: lisp123 (~lisp123@5.30.23.247)
[22:50:13] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 240 seconds)
[22:56:17] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 240 seconds)
[22:58:31] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[23:00:54] *** Quits: varjag (~user@188.95.247.247) (Quit: ERC 5.4.1 (IRC client for GNU Emacs 29.0.50))
[23:02:52] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[23:06:57] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 240 seconds)
[23:11:39] *** Quits: raeda (~raeda@72.49.252.109) (Read error: Connection reset by peer)
[23:11:43] *** Joins: raeda_ (~raeda@72.49.252.109)
[23:14:04] *** Quits: amb007 (~a_bakic@102.215.76.86.rev.sfr.net) (Ping timeout: 250 seconds)
[23:14:39] *** Joins: amb007 (~a_bakic@106.38.22.93.rev.sfr.net)
[23:16:09] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[23:21:17] *** Quits: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net) (Ping timeout: 240 seconds)
[23:29:17] *** Quits: pieguy128_ (~pieguy128@bras-base-mtrlpq5031w-grc-35-70-24-248-188.dsl.bell.ca) (Ping timeout: 240 seconds)
[23:30:13] *** Quits: amb007 (~a_bakic@106.38.22.93.rev.sfr.net) (Ping timeout: 256 seconds)
[23:30:33] *** Joins: amb007 (~a_bakic@213.12.23.93.rev.sfr.net)
[23:32:52] *** Joins: xantoz (~tewi_inab@c-c0bae255.013-124-73746f25.bbcust.telenor.se)
[23:37:20] *** Joins: pieguy128 (~pieguy128@bras-base-mtrlpq5031w-grc-52-65-93-194-105.dsl.bell.ca)
[23:38:37] *** Joins: varjag (~user@ti0040a400-5479.bb.online.no)
[23:40:45] *** Joins: karmichammer (~patrick@ip68-9-95-224.ri.ri.cox.net)
[23:46:40] *** Quits: lispy (~lispy4@84.69.59.93) (Quit: Leaving)
[23:52:02] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 268 seconds)
[23:53:56] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[23:58:18] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
