[00:00:29] <Zipheir> I think that eq? remains common in Scheme programs because (a) tradition, (b) use in textbooks like SICP and Little Schemer, (c) the absence of a good modern Scheme intro book.
[00:01:31] <Zipheir> I think the standards do not make it clear to a newcomer what the three equivalence procedures are about, hence we need a good Scheme intro to explain them to newcomers.  But, anyway.
[00:06:10] *** Joins: Darkcoal (~user@2001:16a2:7a75:f800:7ae2:9bb1:6de0:1674)
[00:12:29] *** Quits: Darkcoal (~user@2001:16a2:7a75:f800:7ae2:9bb1:6de0:1674) (Quit: Darkcoal)
[00:13:26] *** Joins: Guest70 (~Guest70@89.151.178.153)
[00:13:59] *** Parts: Guest70 (~Guest70@89.151.178.153) ()
[00:16:17] *** Quits: gproto23 (~gproto23@user/gproto23) (Ping timeout: 240 seconds)
[00:17:58] *** Joins: cjb (~cjb@user/cjb)
[00:25:00] *** Joins: poselyqualityles (~poselyqua@user/poselyqualityles)
[00:28:31] *** Quits: seninha (~seninha@user/seninha) (Remote host closed the connection)
[00:30:19] *** Joins: grettke (~grettke@184.62.226.206)
[00:40:39] *** Quits: grettke (~grettke@184.62.226.206) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[00:43:01] *** Joins: seninha (~seninha@user/seninha)
[00:45:14] <sham1> I like having a strict pointer equivalence predicate
[00:45:37] <sham1> Makes detecting stuff like cycles easier, even if it can also be done by eqv? technically
[00:46:44] <Zipheir> You can usually use eqv? for that.
[00:49:14] <Zipheir> It's worth looking at the standards; there really aren't any structures in Scheme that you could cycle-check with eq? that you couldn't check with eqv?.
[00:50:05] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 252 seconds)
[00:50:21] <Zipheir> R7 says: "On symbols, booleans, the empty list, pairs, and records, and also on non-empty strings, vectors, and bytevectors, eq? and eqv? are guaranteed to have the same behavior."
[00:51:48] *** Joins: aeth (~aeth@user/aeth)
[00:55:37] <Zipheir> Of course, you might want the (probably) efficiency of eq?.
[00:55:37] *** Quits: poselyqualityles (~poselyqua@user/poselyqualityles) (Ping timeout: 240 seconds)
[00:57:09] <sham1> Yeah. The thing with eq? is that one doesn't need to check stuff like the tagged pointer's bits or anything. You just do a CMP a, b JZ return-true /* return false */ (ofc with more optimization and jump threading and what have you)
[01:00:26] <sham1> Indeed. R7 spec at least says "obj1 and obj2 are both inexact numbers such that they are numerically equal (in the sense of =)" so now you have to check whether your stuff is inexact reals and such, and if you do something like box floating point numbers then that becomes a (slightly) more expensive check to make
[01:02:31] <sham1> And indeed-ing my indeed, the rational for eq? even states as much. "It will usually be possible to implement eq? much more efficiently than eqv?, for example, as a simple pointer compasiron instead of as some more complicated operation. One reason is that it is not always possible to compute eqv? of two numbers in constant time, whereas eq? implemented as pointer comparison will always finish in
[01:02:33] <sham1> constant time."
[01:02:37] *** Quits: klovett (~klovett@107.127.24.145) (Ping timeout: 240 seconds)
[01:04:52] <sham1> And, well, usually I end up using equal? instead of eqv? or eq?, unless I'm doing weird stuff like cycle detection or whatnot
[01:15:30] <Zipheir> And then there are the many type-specific equality procedures.  In a sense, the eq- family are sort of pre-Scheme fossils.  None of the SRFIs that define new types say anything about their equivalence/equality under the traditional equality predicates.
[01:16:18] <Zipheir> Since new types are usually records in Scheme, that makes the family mostly useless on new types.
[01:17:14] <nytpu> in a usual scheme implementation would equals? (and eqv? depending on the type) dispatch comparisons to the respective type's equality procedure for built-in types?
[01:18:09] <nytpu> *equal?
[01:18:10] <Zipheir> That's a possibility.  e.g. eqv? on characters might become char=?.
[01:19:24] <sham1> Well you have to do some type dispatch because equality according to eqv? and so on requires that things have the same type and that then they have some value property
[01:20:16] *** Quits: sonny (~sonny@8.6.144.252) (Ping timeout: 256 seconds)
[01:20:19] <Zipheir> There would be absolutely no reason *not* to call = when comparing numbers with eqv?, given its semantics.  So I'd say that's probably the intention.
[01:21:54] <sham1> Yeah. The spec for example says that for when the arguments are exact numbers, eqv? has to act like =, and same for inexact. For chars it has to act like char=?
[01:21:57] <sham1> And so on
[01:22:06] <Zipheir> What's semantically bad, I think, is that eqv? gives a totally different notion of list, vector, etc. comparison than the typed comparisons.
[01:22:27] <sham1> Yeah, that's annoying
[01:23:22] <Zipheir> It says "these are the same thing".  And then you get into an argument about the nature of identity.
[01:23:59] <sham1> And RE: eq?, eqv? and equal? being pre-Scheme fossils, this is always a relevant funny thing: https://arcanesentiment.blogspot.com/2015/01/if-scheme-were-like-scheme.html
[01:24:29] <Zipheir> That's a funny one. :)
[01:25:18] <Zipheir> Comparators help with that, but again, there's a totally different system of equality than the eq- family.
[01:25:31] <Zipheir> But they get the semantics right!
[01:27:07] <sham1> If there ever would be an R8RS, there are certainly many a place where at least I'd just take some garden scissors and try to take away some of the weirder things
[01:28:49] <Zipheir> Yes.
[01:29:34] <Zipheir> It's a little surprising that R6, with all its changes, didn't change much about the eq family.
[01:30:30] <sham1> Although, to torture the analogy even further, I'd also hot-glue on some stuff in this hypothetical "Am a dictator of Scheme for a day", like at least some kind of Unicode support
[01:32:43] *** Quits: m455 (~m455@user/m455) (Quit: WeeChat 3.0)
[01:33:42] *** Quits: kjak (~kjak@pool-108-45-56-21.washdc.fios.verizon.net) (Ping timeout: 268 seconds)
[01:35:05] <Zipheir> I think typeclass-style equality (via comparators) is the best way forward; eq?/eqv? could stick around as speed tricks, preferably prefixed with dirty- :)
[01:35:39] <sham1> Yeah, I'd also prefer comparators being made the "main" equality/comparison thing
[01:35:54] <sham1> They might become more idiomatic once R7-large hits
[01:38:24] <Zipheir> Hopefully so.
[01:38:55] <amazigh> gwatt: I merged ruse-exe (chez-exe fork) in racket's chez fork :D
[01:40:11] <amazigh> gwatt: I am wondering if instead of two temporary files, we can get away with none, and use directly Sbuild_heap
[01:40:35] <amazigh> I also plan to get rid of libuuid dependency
[01:40:55] <amazigh> but those are low hanging possibly useless
[01:41:14] <amazigh> I am not sure what I am doing, but it was fun to go through the Chez makefile labyrinth
[01:42:38] <Zipheir> I really don't understand how make labyrinths come to be.
[01:42:52] <Zipheir> It's actually a very expressive language.
[01:43:18] <amazigh> well, it is a labyrinth to me, I am noob makefile coder, also I hated make for a long time
[01:43:45] <amazigh> the configure, which does not really on autoconf, will sed makefile.in and generate actual makefile
[01:44:09] <Zipheir> That's always the first step in obfuscating makefiles. :)
[01:44:19] <amazigh> what is the first step?
[01:44:31] <Zipheir> Autogenerate stuff.
[01:44:36] <amazigh> yeah.
[01:44:41] <amazigh> but then it is not finished!
[01:45:12] <amazigh> several files, can be generated using different paths dependengin on whether you want to build part of of it, or all of it or even cross compile 
[01:45:18] <amazigh> x)
[01:47:13] <amazigh> I do not say it evil, I just say, it does not feel straightforward, and could be made simpler
[01:47:44] *** Joins: livoreno (~livoreno@user/notzmv)
[01:48:01] <amazigh> e.g. I added a rule to compile a .sls library into a bootfile, that should work across targets (arch and os) but not tested
[01:48:43] <amazigh> but once you did the full bootstrap via plain `make`, if you change a file from the .sls, it does not recompile it
[01:48:45] <amazigh> (:
[01:49:09] <amazigh> makefile for the win
[01:49:51] <amazigh> along the years, I figured, my "hate" of makefile and sql, came from the fact that I was clueless about those, but I am still a great proponent of single language systems
[01:50:24] <Zipheir> Single language systems?
[01:50:41] <amazigh> yes, e.g. full-stack scheme, or lisp machine
[01:50:43] *** Quits: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net) (Read error: Connection reset by peer)
[01:51:32] <amazigh> on a somewhat unrelated not, do you know this kind of C signature: static ptr boot_call(tc, p, n) ptr tc; ptr p; INT n; { ... }
[01:51:40] <sham1> Unikernels
[01:51:58] <sham1> amazigh: k&r code
[01:52:09] <Zipheir> *Old* C.
[01:52:14] <amazigh> I am not a unikernels expert, but from a knowledge economy, single language stack surely have a lot of pros
[01:52:18] <Zipheir> Back when it was more or less untyped...
[01:52:18] <sham1> Yeah. Pre ANSI
[01:52:21] <amazigh> what standard is that?
[01:52:23] <amazigh> oh
[01:52:41] <amazigh> funny ^^
[01:53:21] <sham1> Support for those was finally removed in C23 IIRC
[01:54:16] <amazigh> gwatt: since the bootfile, and the scheme program are both in the c program, maybe it is possible to feed chez with those without going through a temporary file, hence speed up startup time?
[01:54:48] <amazigh> that's fun, C is evolving toward PL/I prolly :p
[01:55:44] *** Joins: klovett (~klovett@107.127.24.145)
[01:56:21] *** Quits: ZombieChicken (~weechat@user/zombiechicken) (Quit: WeeChat 3.3)
[01:57:20] *** Quits: cjb (~cjb@user/cjb) (Quit: rcirc on GNU Emacs 29.0.50)
[01:58:47] *** Joins: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net)
[01:59:10] *** Joins: cjb (~cjb@user/cjb)
[02:01:32] *** Joins: notzmv (~zmv@user/notzmv)
[02:16:20] *** Joins: sonny (~sonny@2a09:bac0:14::806:90fc)
[02:16:56] *** Quits: yewscion (~yewscion@52.94.133.129) (Ping timeout: 256 seconds)
[02:20:22] <amazigh> tonight is the night, I will fix the tests for the json test suite for all twelve scheme
[02:20:28] <amazigh> cyclone passed another subset
[02:21:25] <amazigh> I will rework the test suite somehow
[02:21:29] <amazigh> to have a better coverage
[02:21:47] <amazigh> possibly skipping test for only the scheme that do not pass some tests
[02:22:02] *** Quits: madagest (~madage@user/madage) (Remote host closed the connection)
[02:22:15] *** Joins: madage (~madage@user/madage)
[02:22:45] <amazigh> the funny thing is an optimization that I had done for the other scheme that worked well (I did not check for eof), failed completly with cyclone which lead to a memory leak =|
[02:25:59] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[02:26:30] *** Joins: badkins (~badkins@136.56.92.199)
[02:26:36] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[02:26:46] *** Joins: badkins (~badkins@136.56.92.199)
[02:46:37] *** Quits: python476 (~user@88.160.31.174) (Ping timeout: 240 seconds)
[03:07:47] *** Joins: poselyqualityles (~poselyqua@user/poselyqualityles)
[03:14:35] *** Joins: s-liao (~s-liao@101.86.96.21)
[03:27:08] *** Quits: klovett (~klovett@107.127.24.145) (Quit: ZZZzzz…)
[03:31:02] *** Quits: civodul (~user@guix/contributor/civodul) (Ping timeout: 240 seconds)
[03:40:43] *** Quits: poselyqualityles (~poselyqua@user/poselyqualityles) (Ping timeout: 268 seconds)
[03:48:43] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[03:52:06] *** Joins: badkins (~badkins@136.56.92.199)
[03:53:08] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[03:56:45] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 268 seconds)
[04:05:43] *** Joins: s-liao (~s-liao@101.86.96.21)
[04:08:33] *** Joins: badkins (~badkins@136.56.92.199)
[04:14:15] *** Joins: kjak (~kjak@pool-108-45-56-21.washdc.fios.verizon.net)
[04:25:00] *** Quits: aeka (~aeka@pool-100-4-208-71.albyny.fios.verizon.net) (Ping timeout: 256 seconds)
[04:27:10] *** Joins: aeka (~aeka@pool-100-4-208-71.albyny.fios.verizon.net)
[04:34:09] *** Quits: seninha (~seninha@user/seninha) (Remote host closed the connection)
[04:44:14] *** Quits: sonny (~sonny@2a09:bac0:14::806:90fc) (Ping timeout: 268 seconds)
[04:52:37] *** Quits: aeka (~aeka@pool-100-4-208-71.albyny.fios.verizon.net) (Ping timeout: 240 seconds)
[05:01:38] *** Joins: aeka (~aeka@pool-100-4-208-71.albyny.fios.verizon.net)
[05:08:48] *** Joins: klovett (~klovett@107.127.24.145)
[05:11:22] *** Quits: aeka (~aeka@pool-100-4-208-71.albyny.fios.verizon.net) (Ping timeout: 268 seconds)
[05:11:39] *** Joins: aeka (~aeka@2606:6080:1001:d:c59c:6e9a:3115:6f2f)
[05:14:31] *** Joins: grettke (~grettke@184.62.226.206)
[05:16:01] *** Quits: grettke (~grettke@184.62.226.206) (Client Quit)
[05:17:18] *** Joins: grettke (~grettke@184.62.226.206)
[05:18:15] *** Joins: sonny (~sonny@2a09:bac0:14::806:90fc)
[05:18:23] *** Quits: sonny (~sonny@2a09:bac0:14::806:90fc) (Client Quit)
[05:29:15] *** Joins: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net)
[05:31:43] *** Quits: lockywolf (~lockywolf@vultr-seoul-openbsd.lockywolf.net) (Excess Flood)
[05:33:42] *** Joins: lockywolf (~lockywolf@vultr-seoul-openbsd.lockywolf.net)
[05:33:53] *** Joins: mdhughes_ (~mdhughes@user/mdhughes)
[05:34:12] *** Quits: mdhughes (~mdhughes@user/mdhughes) (Read error: Connection reset by peer)
[05:39:22] *** Joins: m455 (~m455@user/m455)
[05:53:22] *** Quits: tripfandango (~tripfanda@5.29.63.24) (Ping timeout: 260 seconds)
[05:53:49] *** Quits: schulze (~schulze@dynamic-077-001-119-182.77.1.pool.telefonica.de) (Ping timeout: 240 seconds)
[06:09:09] *** Joins: genieliu (~genieliu@103.37.140.38)
[06:16:55] *** Quits: grettke (~grettke@184.62.226.206) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[06:21:17] *** Quits: genieliu (~genieliu@103.37.140.38) (Ping timeout: 240 seconds)
[06:32:07] *** Joins: genieliu (~genieliu@103.37.140.38)
[06:36:05] *** Joins: grettke (~grettke@184.62.226.206)
[06:44:01] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[06:47:42] *** Quits: skapata (~Skapata@user/skapata) (Remote host closed the connection)
[07:06:40] *** Joins: s-liao (~s-liao@101.86.96.21)
[07:10:26] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[07:10:38] *** Joins: badkins (~badkins@136.56.92.199)
[07:16:10] *** Parts: pranavats (3fba1d1b34@jabberfr.org) ()
[07:16:51] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[07:17:37] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[07:19:32] *** Joins: badkins (~badkins@136.56.92.199)
[07:21:07] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[07:26:54] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 256 seconds)
[07:28:37] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 240 seconds)
[07:45:02] *** Quits: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net) (Ping timeout: 256 seconds)
[07:45:40] *** Quits: cjb (~cjb@user/cjb) (Ping timeout: 260 seconds)
[07:50:25] <amazigh> morning :)
[07:58:29] *** Parts: pranavats (3fba1d1b34@jabberfr.org) ()
[08:00:07] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[08:00:37] *** Quits: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net) (Ping timeout: 240 seconds)
[08:08:21] *** Quits: genieliu (~genieliu@103.37.140.38) (Ping timeout: 268 seconds)
[08:16:57] *** Joins: genieliu (~genieliu@103.37.140.24)
[08:17:06] *** Quits: xgqt (~xgqt@gentoo/developer/xgqt) (Ping timeout: 260 seconds)
[08:18:00] *** Joins: xgqt (~xgqt@gentoo/developer/xgqt)
[08:29:53] *** Quits: klovett (~klovett@107.127.24.145) (Quit: ZZZzzz…)
[08:35:28] *** Quits: genieliu (~genieliu@103.37.140.24) (Ping timeout: 256 seconds)
[08:45:12] *** Joins: badkins (~badkins@136.56.92.199)
[08:50:17] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 268 seconds)
[09:24:39] *** Joins: notzmv (~zmv@user/notzmv)
[09:25:02] *** Joins: yewscion (~yewscion@c-24-131-220-23.hsd1.wv.comcast.net)
[09:25:40] *** Joins: genieliu (~genieliu@103.37.140.38)
[09:26:13] *** Joins: s-liao (~s-liao@101.86.96.21)
[10:17:04] *** Quits: livoreno (~livoreno@user/notzmv) (Read error: Connection reset by peer)
[10:17:26] *** Joins: livoreno (~livoreno@user/notzmv)
[10:17:48] *** Quits: grettke (~grettke@184.62.226.206) (Quit: Textual IRC Client: www.textualapp.com)
[10:22:30] <ns12> Hi, I have a question: I read somewhere that Scheme was invented to experiment with "actors" (this reminds me of Erlang). Why do I not see anything special in Scheme for concurrent programming, given that Scheme's original purpose was to explore "actors"?
[10:27:45] *** Quits: Perryman (~perryman@user/perryman) (Remote host closed the connection)
[10:28:11] *** Joins: Perryman (~perryman@216.97.249.113)
[10:28:41] <sham1> I mean, we have call/cc, although it turns out that call/cc isn't as good for a lot of the stuff we wished
[10:29:14] <sham1> Although now I wonder when it was first introduced
[10:46:23] *** Joins: karlosz (~karlosz@47.151.136.69)
[10:48:11] <Zipheir> ns12: Concurrency and parallelism are two different things.  You can explore concurrent programs in a single process, which was probably the only option for Steele & Sussman in the 70s.
[10:49:10] <Zipheir> IIRC the main discovery was that "actors" were fully described by lambdas.
[10:49:41] <karlosz> how do you write case expressions where the cases are constants? i.e. how would i accomplish the equivalent of (case foo (#.constant ...) (#.constant2 ...))
[10:50:00] <karlosz> (where #. is read eval as in CL)
[10:50:44] <Zipheir> What does that mean in Scheme?
[10:51:04] <Zipheir> (If there's nothing equivalent, then the answer is, of course, "you don't".)
[10:51:24] <karlosz> like, say i do (define character-tag 0) (define integer-tag 1)
[10:51:55] <karlosz> instead of writing: (case tag (0 (load-character)) (1 (load-integer)) ...
[10:52:02] <amazigh> you need a cond
[10:52:08] <amazigh> case only acccept literals
[10:52:16] <karlosz> there's no reader eval mechanism in scheme?
[10:52:19] <Zipheir> No.
[10:52:22] <karlosz> i don't see one specified in r7rs
[10:52:35] <karlosz> bummer
[10:52:42] <karlosz> even C can switch on constants
[10:53:01] <amazigh> that's called cond :)
[10:53:05] <karlosz> so (cond ((eqv? character-tag tag)) ... ) it is
[10:53:06] <Zipheir> Because C constants aren't C constants but preprocessor macros!
[10:53:39] <amazigh> or write a switch macro
[10:53:46] <karlosz> yep. i suppose reader evaluation is not a very schemey feature
[10:54:08] <amazigh> afair only guile has reader macros, maybe chicken
[10:54:35] <Zipheir> CHICKEN does.  I just spent some time with them providing SRFI 207 notation.  They are very slippery.
[10:54:59] <Zipheir> "When does the reader start reading with a reader macro?"  Who knows.  The semantics are funky.
[10:56:55] <ns12> Zipheir: "concurrent programs in a single process" - Aren't these things called "threads"?
[10:57:00] <karlosz> the common lisp specification has a well specified answer to that question
[10:57:23] <karlosz> for common lisp; it probably works well enough for scheme too, since the reader syntax is fairly isomorphic
[10:57:29] <Zipheir> ns12: And threads are traditionally implemented by call/cc.
[10:57:42] <amazigh> karlosz: otherwise you can use match also known as matchable
[10:57:46] <Zipheir> ns12: Which was one of the innovations of the original RABBIT compiler.
[10:58:25] <karlosz> oh yeah, match might be what i want
[10:59:34] <Zipheir> ns12: CHICKEN is a current example of a Scheme that uses call/cc threads.
[11:00:23] <ns12> Zipheir: Okay. I didn't realize that there was some relationship between concurrency and call/cc.
[11:01:11] <karlosz> also, this is kind of a weird asymmetry, but it seems like r7rs only has call-with-binary-{input,output}-file, and no with-binary-input-file
[11:02:07] <amazigh> ns12: that is how coroutines are implemented with scheme
[11:02:12] <karlosz> am i missing something... or is the standard library functions just assymetric for character and binary prots?
[11:02:20] <sjamaan> ns12: With CPS, you basically get a suspendable thread state for free in the continuation; you just stash it at the end of a queue and take the first one from the queue and call it when a timer expires
[11:02:22] <amazigh> karlosz: indeed
[11:03:34] <Zipheir> ns12: Dybvig has an extended example of this: https://scheme.com/tspl4/examples.html#./examples:h11
[11:05:17] <Zipheir> I suspect the idea is that the with-{input, output}-from-file forms are sort of inessential.
[11:05:49] <Zipheir> With parameterize, it's easy to roll your own from the call-with-*-file forms.
[11:06:31] <ns12> sham1: Zipheir: amazigh: sjamaan: Thank you for the explanations.
[11:06:55] <karlosz> hm... don't yet really understand what gets included in the standard yet
[11:07:19] <karlosz> i guess parameterize is sort of the new kid on the block
[11:07:31] <Zipheir> Pre-R7RS, current-input-port etc. weren't parameters.
[11:07:56] <Zipheir> So you'd need a with-input-from-file form to rebind current-input-port.  Not so with R7.
[11:08:25] <Zipheir> But it seems reasonable to just pass ports around.
[11:10:50] <amazigh> re what gets included in the standard is whatever is voted ;)
[11:10:53] <amazigh> see topic
[11:11:15] <Zipheir> N.B. that's r7rs-large.  The small standard had its own process.
[11:13:22] <amazigh> karlosz: you can use (call-with-port (open-binary-input-port "/dev/stdin") my-proc)
[11:13:34] *** mdhughes_ is now known as mdhughes
[11:14:04] <karlosz> got it.
[11:14:29] <Zipheir> amazigh: /dev/fd0
[11:15:03] <Zipheir> I don't think /dev/stdin is portable, although I know a lot of Linux distros provide that link.
[11:15:23] <sjamaan> amazigh, karlosz: That's not exactly the same, as that won't close the port on normal return
[11:16:00] <karlosz> bah, i had a hard time understanding how any of the dynamic extent forms get cleaned up
[11:16:07] <karlosz> or when, rather
[11:16:08] <Zipheir> sjamaan: Sure it will.
[11:16:38] <Zipheir> "If proc returns, then the port is closed automatically and the values yielded by the proc are returned."
[11:17:03] <sjamaan> Zipheir: Ah, I stand corrected
[11:20:43] <Zipheir> Sorry, I didn't mean to go correcting everyone sequentially. :)
[11:23:15] <sjamaan> No worries
[11:26:24] <karlosz> so another "gotcha" coming from lisp: its true that the order of evaluation of arguments isn't well specified, right? so instead of doing (foo (read-u8) (read-u8) (read-u8) ...), how should i sequence that?
[11:26:28] <karlosz> with LET?
[11:26:42] <karlosz> but LET bindings could get evaluated in parallel...
[11:26:46] <karlosz> so LET*?
[11:26:53] <sjamaan> yeah, let* is the ticket
[11:27:25] <dpk> hmm, a funcall* macro which did guarantee the order of argument evaluation would be handy in some cases
[11:27:30] <karlosz> that will take getting used to
[11:27:54] <sham1> Having some way of calling a function with a guaranteed left-to-right order would be convenient
[11:28:11] <sham1> Like yeah, let* is nice, but a bit verbose
[11:28:21] <karlosz> to be honest i don't really see the point of not doing left-to-right order when the language has eager evaluation semantics already
[11:28:44] <sham1> Well, it means you can sometimes reorder operations
[11:29:17] <sham1> Because if the stuff doesn't have data dependencies between each other, then you should be allowed to reorder evaluation
[11:29:31] <sham1> It's just that for stuff that does, it's annoying
[11:30:19] *** Quits: casaca (~casaca@user/casaca) (Remote host closed the connection)
[11:31:20] *** Quits: curium (~curium@mail.clouded.monster) (Remote host closed the connection)
[11:37:43] <karlosz> yeah, so for stuff like file io i guess let* is the way
[11:41:39] *** Joins: gproto23 (~gproto23@user/gproto23)
[11:50:21] *** Quits: genieliu (~genieliu@103.37.140.38) (Ping timeout: 268 seconds)
[11:51:20] *** Joins: casaca (~casaca@user/casaca)
[11:52:50] *** Joins: Darkcoal (~user@2001:16a2:7a75:f800:7ae2:9bb1:6de0:1674)
[12:01:31] *** Joins: genieliu (~genieliu@103.37.140.38)
[12:03:54] *** Joins: tripfandango (~tripfanda@2a00:a040:19e:72a1:10df:5a06:d5ff:2f9b)
[12:03:57] *** Joins: curium (~curium@mail.clouded.monster)
[12:04:33] *** Quits: Darkcoal (~user@2001:16a2:7a75:f800:7ae2:9bb1:6de0:1674) (Ping timeout: 268 seconds)
[12:05:35] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[12:06:01] *** Joins: Darkcoal (~user@2001:16a2:7a75:f800:7ae2:9bb1:6de0:1674)
[12:10:19] *** Joins: civodul (~user@guix/contributor/civodul)
[12:31:56] *** Quits: akarle (~akarle@user/akarle) (Remote host closed the connection)
[12:41:33] *** Quits: livoreno (~livoreno@user/notzmv) (Ping timeout: 268 seconds)
[12:44:17] *** Quits: genieliu (~genieliu@103.37.140.38) (Ping timeout: 240 seconds)
[12:46:50] *** Joins: badkins (~badkins@136.56.92.199)
[12:51:02] *** Quits: Darkcoal (~user@2001:16a2:7a75:f800:7ae2:9bb1:6de0:1674) (Ping timeout: 260 seconds)
[12:51:36] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 256 seconds)
[12:52:44] *** Joins: Darkcoal (~user@167.86.149.23)
[12:53:50] *** Joins: genieliu (~genieliu@103.37.140.24)
[12:59:01] <sham1> Yeah. Could probably macroize it though. So it'd be somewhat like (begin ...) But which calls a function instead
[12:59:17] *** Joins: schulze (~schulze@dynamic-077-008-025-234.77.8.pool.telefonica.de)
[13:00:20] <sham1> I know it'd be possible with syntax-case. Not sure about syntax-rules
[13:01:36] *** Joins: akarle (~akarle@user/akarle)
[13:01:50] <dpk> what would the expansion look like?
[13:09:36] <sham1> Something with let* and generated identifiers
[13:11:36] <dpk> oh right. yeah, it can be done in syntax-rules, but you need to recursively expand n times to generate n identifiers
[13:14:35] <dpk> actually quite a simple macro to demonstrate that syntax-rules technique, hang on …
[13:20:59] <dpk> https://gitlab.com/dpk/presrfis/-/blob/master/call.scm
[13:25:19] <dpk> generally, anything you can do with just lists and identifiers in syntax-case, you can also do in syntax-rules with more faffing about
[13:30:12] *** Joins: s-liao (~s-liao@101.86.96.21)
[13:31:32] *** Quits: genieliu (~genieliu@103.37.140.24) (Ping timeout: 240 seconds)
[13:34:14] *** Quits: gproto23 (~gproto23@user/gproto23) (Read error: Connection reset by peer)
[13:35:54] *** Joins: gproto23 (~gproto23@user/gproto23)
[13:42:43] *** Quits: karlosz (~karlosz@47.151.136.69) (Quit: karlosz)
[13:49:40] <sham1> Neat
[14:01:50] *** Joins: genieliu (~genieliu@103.37.140.38)
[14:38:29] *** Quits: tripfandango (~tripfanda@2a00:a040:19e:72a1:10df:5a06:d5ff:2f9b) (Read error: Connection reset by peer)
[14:39:49] *** Joins: tripfandango (~tripfanda@5.29.19.182)
[15:06:30] *** Joins: seninha (~seninha@user/seninha)
[15:29:37] *** Quits: yewscion (~yewscion@c-24-131-220-23.hsd1.wv.comcast.net) (Ping timeout: 240 seconds)
[15:30:18] <mdhughes> You can just collect data and then apply it or write your function to use a list passed in:
[15:30:48] <mdhughes> (apply foo (let data-loop ((i 0) (data '()))  (if (>= i 3) (reverse data)  (data-loop (add1 i) (cons (read) data)) )) )
[15:32:33] <dpk> a Scheme implementation should be able to do let* without consing, though
[15:33:26] <mdhughes> Sure, but if you're doing multiple values where order matters, you're *probably* building a data set. And that's better to put in a list or other structure.
[15:34:54] *** Joins: skapata (~Skapata@user/skapata)
[15:36:19] <amazigh> mdhughes: I am hacking on Chez codebase ahah ^^
[15:36:30] *** Quits: kjak (~kjak@pool-108-45-56-21.washdc.fios.verizon.net) (Ping timeout: 256 seconds)
[15:36:32] <amazigh> I added a library :p
[15:36:41] <mdhughes> Nice, for what?
[15:36:45] *** Joins: kjak (~kjak@pool-108-45-56-21.washdc.fios.verizon.net)
[15:37:13] *** Quits: kjak (~kjak@pool-108-45-56-21.washdc.fios.verizon.net) (Client Quit)
[15:37:30] <amazigh> so far the plan is to add chez-exe / ruse-exe features, and gather the R7RS libraries, and then I will try to figure define-library
[15:37:40] <amazigh> I use racket's fork
[15:38:11] <amazigh> it is fun, even if mostly makefile stuff.
[15:38:17] <amazigh> ^^'
[15:39:10] <amazigh> Well, before than I will setup CI, to check that racket forks runs on as many platform as advertised.
[15:39:32] <amazigh> I think it support apple m1
[15:43:33] *** Joins: ManDay (~manday@user/manday)
[15:45:56] *** Quits: seninha (~seninha@user/seninha) (Ping timeout: 268 seconds)
[15:46:21] *** Parts: pranavats (3fba1d1b34@jabberfr.org) ()
[15:53:51] *** Joins: seninha (~seninha@user/seninha)
[16:00:52] <gwatt> amazigh: RE: chez-exe temporary files. AFAICT, chez's c interface requires specifying paths for both bootfiles and programs. It's possible those can be combined, so there's just one file, but I don't think you can get away with no files, without modifying chez scheme. I don't want to maintain my own fork just for that. The goal of chez-exe is to be compatible with standard ChezScheme
[16:11:11] *** Quits: ManDay (~manday@user/manday) (Quit: TURBOquit (tm) - the fastest way to get out of an awkward situation)
[16:15:59] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[16:17:34] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[16:32:14] *** Joins: kjak (~kjak@pool-108-45-56-21.washdc.fios.verizon.net)
[16:33:17] *** Quits: genieliu (~genieliu@103.37.140.38) (Ping timeout: 240 seconds)
[16:38:45] <sham1> mdhughes: while that's true, I've encountered this kind of "order matters" kind of stuff with for example implementing a reader, wherein I've peeked a character and now I need to peek the next character to see what I need to do next. The natural way of writing that would be the following if we're inside a named let which accumulates the characters
[16:38:47] *** Joins: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net)
[16:39:17] <sham1> (loop (cons (read-char port) acc) (peek-char port))
[16:40:07] <sham1> But of course, I can't be sure whether the consing is done first or second, so I need to contort the code in order to ensure that the read is done before the peeking. Usually by way of set!-ing the accumulator list
[16:41:51] <sham1> And yes, this is technically building a data set, since I'm creating a list of read characters, but thankfully one can indeed macroize it
[16:48:43] *** Joins: badkins (~badkins@136.56.92.199)
[16:52:22] <mdhughes> And that's a case where I would use let* and (cons a b) to return the sequence, since they're different operations. The above example with multiple read or read-u8 looks more like filling a buffer.
[16:53:45] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 268 seconds)
[16:56:13] *** Quits: m1dnight (~christoph@christophe.dev) (Ping timeout: 268 seconds)
[16:58:55] <sham1> That's exactly what it is
[17:03:37] *** Quits: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net) (Ping timeout: 268 seconds)
[17:06:21] *** Joins: s-liao (~s-liao@101.86.96.21)
[17:07:10] *** Quits: tripfandango (~tripfanda@5.29.19.182) (Ping timeout: 256 seconds)
[17:07:29] *** Joins: m1dnight (~christoph@christophe.dev)
[17:12:25] *** Joins: Avichi (~Avichi@2001:980:1b5c:1:ca32:8d4b:8764:a6dc)
[17:14:02] *** Joins: tripfandango (~tripfanda@2a00:a040:19e:72a1:ecee:b719:c29a:ba38)
[17:24:55] *** Quits: Darkcoal (~user@167.86.149.23) (Quit: Darkcoal)
[17:26:53] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[17:29:01] *** Quits: webshinra (~shinra@2a01cb080779fc003f6926a195b6d607.ipv6.abo.wanadoo.fr) (Remote host closed the connection)
[17:30:53] *** Joins: webshinra (~shinra@2a01cb080779fc003f6926a195b6d607.ipv6.abo.wanadoo.fr)
[17:46:17] *** Quits: tripfandango (~tripfanda@2a00:a040:19e:72a1:ecee:b719:c29a:ba38) (Ping timeout: 240 seconds)
[17:48:16] *** Joins: tripfandango (~tripfanda@77.137.162.21)
[17:50:11] *** Joins: klovett (~klovett@107.127.24.145)
[17:57:41] *** Quits: kjak (~kjak@pool-108-45-56-21.washdc.fios.verizon.net) (Quit: leaving)
[18:01:03] *** Joins: badkins (~badkins@136.56.92.199)
[18:03:17] *** Joins: s-liao (~s-liao@101.86.96.21)
[18:03:23] *** Quits: s-liao (~s-liao@101.86.96.21) (Client Quit)
[18:03:33] *** Joins: yewscion (~yewscion@52.94.133.129)
[18:05:37] *** Quits: weinholt (weinholt@h-37-123-132-162.A785.priv.bahnhof.se) (Read error: Connection reset by peer)
[18:05:39] *** Quits: gproto23 (~gproto23@user/gproto23) (Read error: Connection reset by peer)
[18:05:57] *** Quits: webshinra (~shinra@2a01cb080779fc003f6926a195b6d607.ipv6.abo.wanadoo.fr) (Remote host closed the connection)
[18:07:54] *** Joins: webshinra (~shinra@2a01cb080779fc003f6926a195b6d607.ipv6.abo.wanadoo.fr)
[18:31:04] *** Joins: cybersyn (~user@42.113.203.128)
[18:42:50] *** Joins: livoreno (~livoreno@user/notzmv)
[18:47:59] *** Quits: cybersyn (~user@42.113.203.128) (Remote host closed the connection)
[18:49:16] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[18:51:09] *** Joins: badkins (~badkins@136.56.92.199)
[18:52:34] *** Quits: light (~light@user/light) (Ping timeout: 256 seconds)
[18:55:51] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 268 seconds)
[19:01:38] *** Joins: light (~light@user/light)
[19:12:37] *** Joins: sonny (~sonny@8.6.144.252)
[19:13:30] <sonny> Zipheir day 4 has me in total disarray, what data structure did you use to solve it?
[19:28:04] *** Joins: badkins (~badkins@136.56.92.199)
[19:51:02] *** Quits: civodul (~user@guix/contributor/civodul) (Ping timeout: 240 seconds)
[19:51:45] *** Joins: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net)
[20:04:19] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Remote host closed the connection)
[20:04:35] *** Joins: taiju (~taiju@240b:253:ec40:2400:bd6b:dfac:c8bb:c6d4)
[20:06:05] <taylan> sonny: out of curiosity, day 4 of what?
[20:07:04] <sonny> advent of code
[20:08:12] *** Joins: nitrowheels (~nitrowhee@151.95.83.100)
[20:48:45] *** Joins: Guest67 (~Guest67@94.177.118.127)
[20:57:27] *** Quits: Avichi (~Avichi@2001:980:1b5c:1:ca32:8d4b:8764:a6dc) (Quit: Client closed)
[21:01:36] <wasamasa> lol
[21:02:30] <wasamasa> sonny: vectors
[21:03:05] *** Quits: casaca (~casaca@user/casaca) (Remote host closed the connection)
[21:03:45] <sonny> you know what, for some reason I did not think racket had immutable vectors cause it makes you jump through hoops to get the immutable lists
[21:04:49] <sonny> and doing it with lists otherwise was an increasinly complex series of transformations
[21:06:17] <wasamasa> oh right, racket
[21:06:39] <wasamasa> I solved that one in elisp
[21:06:47] <sonny> oh, neat
[21:06:54] <wasamasa> but even racket has both mutable and immutable vectors
[21:06:57] <sonny> elisp is a real language?
[21:07:18] <wasamasa> yeah, emacs lisp
[21:07:26] <sonny> huh
[21:07:31] <sonny> nice
[21:07:42] <wasamasa> I cannot recommend it for general-purpose programming
[21:07:55] <wasamasa> that's why I eventually gave up this year's attempt
[21:08:00] <sonny> I see
[21:08:16] <sonny> I am picturing you formatting data with ease in emacs
[21:08:38] <sonny> four days left, I probably won't make it
[21:09:04] <Zipheir> sonny: My discussion of day 4 http://www.sigwinch.xyz/aoc/2021/day_04.html
[21:09:07] <wasamasa> amazigh: this popped up in my feed: https://www.zkdocs.com/
[21:09:21] <sonny> Zipheir ty
[21:10:07] <Zipheir> sonny: Actually, the data structure is a good question.  90% of that post is about what you need to be able to do with Boards, *not* what they are.
[21:10:17] <sonny> interesting, I did follow a thought process like this
[21:10:22] *** Quits: Guest67 (~Guest67@94.177.118.127) (Quit: Client closed)
[21:11:35] <sonny> it didn't help that I didn't know how to play bingo or get the explanation
[21:11:48] <Zipheir> In practice, I found that a list of lists was fine, performance-wise.  O(k) = O(1) for small k.
[21:12:05] <Zipheir> sonny: Yeah, they assume you know bingo!
[21:12:21] <Zipheir> Part two is far more difficult to approach functionally.
[21:12:22] <sonny> I thought every time a number is drawn you place a mark if it is present on a board?
[21:12:55] <Zipheir> Indeed so.
[21:14:02] <sonny> ok, just rereading how you handled bingo with recursion
[21:15:41] <sonny> Zipheir: curious, do you think this is complex? or it's just a normal functional solution?
[21:15:49] *** Joins: kjak (~kjak@pool-108-45-56-21.washdc.fios.verizon.net)
[21:17:55] <sonny> Zipheir I'm thinking in the end the best representation will just be one vector
[21:18:17] <Zipheir> sonny: From my perspective, eating and breathing FP for 4 years, it's not particularly complex.
[21:18:40] <sonny> ok, fair point
[21:18:59] <Zipheir> Scheme vectors immediately tie you into a mutative approach.
[21:19:20] <sonny> some mutation is required
[21:19:47] <sonny> I can also think of it without mutation, the benefit being the indexing is better vs lists
[21:20:51] <Zipheir> Not really.
[21:21:09] <Zipheir> What is O(5)?
[21:21:52] <sonny> idk, it's just a constant
[21:21:55] <Zipheir> If you're really worried about that O(n) complexity, this is why I implemented fxmappings for Scheme.
[21:22:12] <Zipheir> Then you can do O(log 5) update! xD
[21:22:29] <Zipheir> The point is that 5 is a constant, so it's all O(1).
[21:23:15] <sonny> good point, I am just optimizing before doing anything
[21:23:32] <Zipheir> Premature optimization, hmm...
[21:24:40] <sonny> I like your notes, it's a good style
[21:24:57] *** Quits: light (~light@user/light) (Ping timeout: 240 seconds)
[21:25:48] *** Joins: civodul (~user@guix/contributor/civodul)
[21:25:58] *** Joins: light (~light@user/light)
[21:25:59] <Zipheir> sonny: Thanks.  Sorry about the Haskell-esque notation.
[21:26:25] <sonny> brackets here don't look right? "marked b k = any (λ (x, mk) → k == x ∧ mk) b"
[21:27:24] <sonny> no, probably just the arrow throwing me off
[21:29:17] <Zipheir> Looks fine to me.  It's equivalent to Scheme (define (marked b k) (any (lambda (p) (and (= k (car p)) (cadr p))) b))
[21:30:06] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[21:30:38] *** Joins: badkins (~badkins@136.56.92.199)
[21:30:54] <sonny> ok, crisis averted
[21:30:59] <sonny> thanks guys
[21:32:16] <Zipheir> yw.  Let us know what you come up with.
[21:32:59] <Zipheir> Especially for part 2.
[21:35:18] <sonny> well I was skipping part 2 to save time but I may as well do them now
[21:35:22] <Zipheir> I've been trying to figure out how to miniKanrenize Day 8, part 2.  It seems like the perfect application of relational programming.
[21:35:34] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 268 seconds)
[21:36:24] <Zipheir> sonny: Yeah, it's a ridiculous crunch for many people at this point.
[21:36:54] <Zipheir> Reddit is full of brute-force solutions by wired-out hackers trying to keep up.
[21:37:26] <Zipheir> I am happily ignoring the time frame.
[21:38:08] <sonny> as in performance or just the christmas deadline?
[21:40:00] <Zipheir> The deadline.
[21:41:27] <Zipheir> This year has seemed to favor fast-and-dirty solutions.  As wasamasa has said, a lot of AoC seems to be designed for someone with Perl and a few minutes of hacking time.
[21:41:57] <sonny> haha
[21:42:13] <Zipheir> Especially the parsing.  Ugh.
[21:42:59] <sonny> I've just been taking advantage of racket's file->list
[21:44:31] <wasamasa> I'll be honest, the majority of these exercises are a lot more fun to solve in perl or ruby
[21:45:41] <wasamasa> the author is a perl person, too
[21:47:18] <Zipheir> I'm not surprised to hear that.
[21:47:25] *** Quits: yewscion (~yewscion@52.94.133.129) (Ping timeout: 240 seconds)
[21:47:28] <Zipheir> It does say something about how the tool shapes its user...
[21:47:42] <wasamasa> python sits somewhere between, it might make more sense to use thanks to its libraries
[21:48:16] <Zipheir> Maybe we should start Functional AoC.
[21:48:25] <wasamasa> I remember such a website
[21:48:47] <wasamasa> it has like 100 tiny lisp exercises
[21:49:08] *** Joins: karlosz (~karlosz@47.151.136.69)
[21:49:18] <Zipheir> Sounds like fun.
[21:49:36] <wasamasa> mostly list/tree processing stuff
[21:49:51] <wasamasa> maybe someone on #lisp can help me find it again
[21:50:10] <Zipheir> It would be cool to have a month of good puzzles to work on in, say, July.
[21:51:37] *** Quits: light (~light@user/light) (Ping timeout: 240 seconds)
[21:51:39] *** Joins: casaca (~casaca@user/casaca)
[21:53:08] *** Quits: casaca (~casaca@user/casaca) (Remote host closed the connection)
[21:53:27] *** Joins: light (~light@user/light)
[21:57:10] <wasamasa> I found it: https://www.ic.unicamp.br/~meidanis/courses/mc336/2006s2/funcional/L-99_Ninety-Nine_Lisp_Problems.html
[21:59:59] *** Joins: badkins (~badkins@136.56.92.199)
[22:01:34] <Zipheir> wasamasa: Thanks!
[22:08:14] <Zipheir> These are a bit bare.  I appreciate the Advent of Code style of wrapping the puzzles in a novella of sorts.
[22:10:01] <wasamasa> some people do that as a job
[22:11:08] <Zipheir> It is akin to game design.  Take this puzzle and give it a theme.
[22:12:24] <dpk> hmm, Guile appears not to support R7RS let-values
[22:13:46] <dpk> too bad Guile's bug tracker is GNU's practically-unusable email-based shite, or i'd be tempted to formally report this
[22:17:18] *** Joins: X-Scale` (~ARM@206.46.158.5.rev.vodafone.pt)
[22:17:44] <wasamasa> Zipheir: true, I've considered to make a game for tempting people into learning elisp, but it's way too much design work
[22:18:06] <dpk> oh. you need to import (scheme base) at the REPL to use it even if you started in --r7rs mode
[22:18:40] <Zipheir> wasamasa: Interesting idea.
[22:19:26] <Zipheir> Most learn-to-program games I've seen seem to teach a totally imperative view.  More like learn-to-manipulate-a-register-machine...
[22:19:53] <Zipheir> Understandable, since many games are state machines.
[22:20:25] *** Quits: X-Scale (~ARM@83.223.243.175) (Ping timeout: 256 seconds)
[22:20:25] *** X-Scale` is now known as X-Scale
[22:20:48] <wasamasa> yeah and my idea was an intentionally unfinished emacs package
[22:20:54] <wasamasa> which points you towards the holes
[22:21:12] <wasamasa> the problem with this approach is that it's hard to tell what's a bug and what isn't :D
[22:24:53] <wasamasa> not sure what the equivalent would be for scheme
[22:25:05] <wasamasa> other than solving SICP exercises I guess, lol
[22:26:48] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[22:27:15] *** Joins: badkins (~badkins@136.56.92.199)
[22:28:01] <jcowan> Mandatory Unicode will be on one of the Scheme ballots for sure, I don't know which one yet
[22:28:27] <Zipheir> Programming puzzle challenges should be language-independent, IMHO.
[22:28:55] <leah2> so far aoc is even md5-free this year
[22:29:07] <sonny> what does that mean?
[22:29:20] <leah2> previous years had some task where you needed a md5 hash function
[22:29:26] <Zipheir> If it's identifiably a Scheme thing as opposed to an Elisp thing, then the language is clearly railroading the ideas.
[22:29:39] <leah2> which limited the set of obscure languages to use slightly
[22:30:10] <Zipheir> Hmm, I guess I didn't get to that in previous years.
[22:30:48] <leah2> i didn't finish last year, but it happened in the years before i think
[22:31:22] <leah2> hm, 2015 day 4, 2016 day 5 and day 14
[22:31:26] <leah2> ok, been some time
[22:31:58] <leah2> i like that the tasks are very language indepedent
[22:32:16] <Zipheir> Yes, despite the aforementioned Perl flavor to some things.
[22:32:36] <leah2> it's also ok for functional programming this year, more so than the vm-heavy years imo
[22:34:13] <sonny> every problem so far seems to be recursive
[22:34:21] <sonny> but I'm just on day 4 lol
[22:34:29] <Zipheir> leah2: Oh yeah, absolutely.
[22:34:34] <leah2> no. iteration is used a lot ofc
[22:34:40] <leah2> but real recursion isnt needed so much
[22:35:36] <Zipheir> Iteration is just optimized recursion.
[22:36:25] *** Quits: badkins (~badkins@136.56.92.199) (Quit: Leaving...)
[22:36:38] *** Joins: xyh (~xyh@113.92.73.207)
[22:36:40] <xyh> i share a tool i write for sharing docs: https://readonly.link
[22:37:00] *** Quits: livoreno (~livoreno@user/notzmv) (Read error: Connection reset by peer)
[22:37:35] <Zipheir> xyh: Please don't spam the channel.
[22:43:09] <xyh> Zipheir:  how am i spamming?
[22:45:24] <Zipheir> xyh: Joining the channel and immediately posting a link to your tool seems spammish to me.
[22:49:40] <Zipheir> xyh: Just please make sure you're posting links that make sense to the channel context and avoid self-promotion.
[22:49:43] <wasamasa> I bet it's unrelated to scheme, too
[22:56:46] <wasamasa> of course, it's typescript
[22:58:43] <sham1> Well Javascript is just a C-syntax Scheme and Typescript is just a superset of JavaScript, ergo TypeScript is Scheme and ergo it's relevant here /s
[23:01:21] <Zipheir> Haha.
[23:03:17] <sham1> The somewhat sad thing is that there are people out there that unironically say that. Well, mostly the first part
[23:04:55] <Zipheir> You can do a lot of functional programming in JS, but I've never seen much in "real world" code.
[23:13:19] <Zipheir> Which is a shame.  It's like the language took some good ideas from Scheme but failed to make them idiomatic.
[23:18:37] <sham1> While also doing some weird decisions. Like not having any kind of an actual integer type until recently. While one could force a Number to be a signed 32-bit integer by using a bitwise operator, it was still irritating. And of course the bigint type isn't as nice in JS because it requires suffixing the letter "n" onto number literals. All of them. Otherwise you might be forced back to IEEE
[23:18:39] <sham1> double-precision floats.
[23:19:30] <sham1> They could have also had an actual numeric tower, but no
[23:21:28] <Zipheir> Yeah, the type system is not one I want to deal with.
[23:24:24] *** Quits: karlosz (~karlosz@47.151.136.69) (Quit: karlosz)
[23:28:36] *** Quits: nitrowheels (~nitrowhee@151.95.83.100) (Quit: Leaving)
[23:30:08] *** Quits: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net) (Remote host closed the connection)
[23:30:17] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 240 seconds)
[23:30:30] *** Quits: klovett (~klovett@107.127.24.145) (Quit: ZZZzzz…)
[23:33:35] *** Joins: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net)
[23:35:14] *** Joins: yewscion (~yewscion@52.94.133.129)
[23:38:00] *** Joins: karlosz (~karlosz@47.151.136.69)
[23:41:16] *** Quits: sonny (~sonny@8.6.144.252) (Quit: Going offline, see ya! (www.adiirc.com))
[23:57:28] *** Quits: amk (~amk@109.255.169.126) (Remote host closed the connection)
[23:58:06] *** Joins: amk (~amk@109.255.169.126)
