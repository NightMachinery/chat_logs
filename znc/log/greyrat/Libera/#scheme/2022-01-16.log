[00:01:21] *** Quits: karlosz (~karlosz@47.151.136.69) (Quit: karlosz)
[00:03:26] *** Joins: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[00:05:39] *** Joins: evdubs__ (~evdubs@user/evdubs)
[00:08:01] *** Quits: evdubs_ (~evdubs@user/evdubs) (Ping timeout: 256 seconds)
[00:15:12] *** Joins: ouestbillie (~gallup@bl4-157-38.dsl.telepac.pt)
[00:29:40] <aeth> what about emacs vs drracket wars?
[00:30:33] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Remote host closed the connection)
[00:30:49] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[00:32:50] *** Quits: ouestbillie (~gallup@bl4-157-38.dsl.telepac.pt) (Ping timeout: 250 seconds)
[00:33:21] <Franciman> Zipheir: how do zipper based piece tables work?
[00:33:25] <Franciman> what does the zipper do?
[00:35:20] <edgar-rft> it keeps your pants together so that nobody must see your noodle
[00:42:40] *** Joins: skapata (~Skapata@191.177.185.183)
[00:42:40] *** Quits: skapata (~Skapata@191.177.185.183) (Changing host)
[00:42:40] *** Joins: skapata (~Skapata@user/skapata)
[00:44:16] <Franciman> :P
[00:51:32] *** Joins: LeoNerd (~leo@2a03:b0c0:1:d0::feb:5001)
[00:54:08] <Zipheir> Franciman: Traditional piece-tables use pointer assignment to suture in new pieces of text.  Using a zipper, you don't have to do any mutation; the new pieces are just "zipped up".
[00:54:22] <Zipheir> Not the most helpful explanation ever, I know.
[00:57:02] <Zipheir> I worked out a short prototype a while back http://chiselapp.com/user/Zipheir/repository/ztable/file?name=ztable.scm
[00:57:11] <Franciman> i think i understand, don't worry
[00:57:20] <Franciman> i was trying something similar in my scheme implementation of the piece table
[00:57:35] <Zipheir> Oof, why did I use SRFI 116?
[00:57:48] <Franciman> Zipheir: what implementation do you use for r7rs small?
[00:57:54] <Franciman> i see you use records
[00:58:02] <dpk> why *wouldn't* you use SRFI 116?
[00:58:40] <Franciman> aren't builtin lists good enough?
[00:58:44] <Franciman> :P
[00:59:10] <Zipheir> Franciman: I use CHICKEN+r7rs, or possibly chibi (mostly just for testing, though).
[00:59:28] <Franciman> i see, thanks
[00:59:28] <Zipheir> Franciman: Until ilists are builtin, yes.
[00:59:29] <dpk> ideally what SRFI 116 makes *are* built-in lists, but with whatever the implementation's internal immutability flag is set
[00:59:57] <Zipheir> At the moment there's no advantage to using the 116 sample impl..
[01:00:08] <Franciman> i see
[01:00:18] <dpk> i.e. the same kind of lists you can otherwise only get by quoting, assuming your implementation enforces the immutability of literals (insert clown face emoji here)
[01:00:25] <Franciman> btw Zipheir i tried something PRETTY similar to your code, but i fail to be able to implement deletion T.T
[01:00:34] <Franciman> thanks for the link, i'll study your code :D
[01:01:22] <Zipheir> Franciman: Cool, don't take it too seriously :)
[01:02:15] <Zipheir> dpk: Yes, that would be nice.
[01:02:37] <Zipheir> dpk: We'd also want the performance benefits from that enforced immutability.
[01:02:54] <Zipheir> i.e. as much structure-sharing as possible.
[01:04:14] <dpk> according to the post-finalization note to SRFI 116 (side note: another complaint of mine about the R7RS Large process is that the lack of a better way to resolve minor, but nonetheless potentially compatibility-breaking issues with libraries has led to a proliferation of post-finalization notes making changes post facto without), that is indeed how SRFI 116 should be implemented
[01:05:13] <dpk> in fact, i think in implementations that don't enforce the immutability of literals, then all the procedures in SRFI 116 should just be aliased to their SRFI 1 counterparts. but even the PFN-amended version of SRFI 116 doesn't appear to allow that
[01:06:44] <dpk> *without votes
[01:07:41] <Zipheir> The best of all possible worlds IMHO would be only immutable lists in R8RS.
[01:08:08] <Zipheir> set-car! and set-cdr! make everything harder.
[01:12:03] <sham1> Having only immutable pairs sounds like a plan, although it'd make things like (read)ing cyclic lists and such harder when the reader is in Scheme, since currently it's relatively easy to do something like #1=(a . #1#) and implement the reading of that by mutably patching the cdr of that afterwards
[01:12:33] <Zipheir> dpk: IIUC you don't like the addition of unballotted PFNs, because they can introduce arbitrary changes?  I think I agree.  Those really should stay with the SRFIs.
[01:12:43] <dpk> not having cyclic lists would be a major advantage of immutable pairs!
[01:12:49] <Zipheir> Indeed.
[01:12:50] <sham1> And sure, one could also make it so that one would have both mutable pairs and immutable pairs (a la Racket) but then one might also want some way of turning the mcons into regular cons
[01:13:09] <dpk> we could have immutable cycles as a distinct data type, as Emmanuel Medernach has proposed
[01:13:29] <sham1> Sure, but what would we do with datum references then
[01:13:32] <Zipheir> That's a good idea.
[01:13:37] <sham1> Just not have them?
[01:13:55] <Zipheir> It's an error to build a cyclic list?
[01:14:19] *** Quits: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 256 seconds)
[01:14:52] <Zipheir> No self-reference seems like a completely reasonable rule for datum-syntax stuff.
[01:15:24] <Zipheir> "Syntax error: Someone has to shave the barber."
[01:16:00] *** Joins: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[01:16:53] *** Joins: gnomon (~gnomon@cpe1c872c7063d0-cm00fc8d8fbe70.cpe.net.cable.rogers.com)
[01:18:19] * dpk adds ‘Interchangeability of mutable and immutable pairs’ as an issue in her list … up to 41 now
[01:21:57] * dpk also adds ‘Procedural: To what extent do post-finalization notes to SRFIs affect R7RS Large?’ to make 42
[01:37:32] *** Quits: rgherdt (~rgherdt@ip5f5af1b0.dynamic.kabel-deutschland.de) (Ping timeout: 240 seconds)
[01:43:01] *** Joins: karlosz (~karlosz@47.151.136.69)
[01:54:41] *** Joins: rgherdt (~rgherdt@2a02:8109:86c0:d8d:c53f:d83a:dd8d:27ab)
[02:03:57] *** Quits: klovett_ (~klovett@166.205.90.163) (Ping timeout: 240 seconds)
[02:04:42] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 250 seconds)
[02:10:02] *** Quits: rgherdt (~rgherdt@2a02:8109:86c0:d8d:c53f:d83a:dd8d:27ab) (Ping timeout: 240 seconds)
[03:04:32] *** Quits: epony (epony@user/epony) (Ping timeout: 240 seconds)
[03:12:47] *** Quits: karlosz (~karlosz@47.151.136.69) (Quit: karlosz)
[03:18:42] <Spawns> do you guys think it would be possible to create a scheme with purely immutable lists?
[03:18:48] *** Joins: karlosz (~karlosz@47.151.136.69)
[03:18:57] <Spawns> i am curious how badly that would effect macros
[03:26:04] <aeth> at that point, it's no longer a (PLT) Scheme, it's a Racket.
[03:26:16] <aeth> (in other words, someone already did that)
[03:32:29] <Spawns> i am doing it more out of need rather than want
[03:33:00] <Spawns> trying to support mutable linked lists in rust is fairly difficult, even with RefCell
[03:38:05] *** Quits: karlosz (~karlosz@47.151.136.69) (Ping timeout: 256 seconds)
[03:42:38] *** Quits: civodul (~user@guix/contributor/civodul) (Ping timeout: 250 seconds)
[03:56:30] *** Quits: gproto23 (~gproto23@user/gproto23) (Ping timeout: 250 seconds)
[04:20:45] <gwatt> Are mutable pairs different than trying to support other mutable structures in rust?
[04:26:53] *** Joins: livoreno (~livoreno@user/notzmv)
[04:39:27] *** Joins: notzmv (~zmv@user/notzmv)
[04:43:32] *** Quits: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 240 seconds)
[04:45:24] <tokie> Spawns: see refcell
[04:45:32] *** Joins: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[04:50:20] <tokie> Spawns: why a linked list? you could represent pairs as an enum variant
[04:50:36] <tokie> something like: enum Cell { Pair(Box<Cell>, Box<Cell>) }
[04:57:35] *** Joins: klovett (~klovett@166.205.90.163)
[05:04:21] *** Joins: s-liao (~s-liao@101.86.96.21)
[05:08:51] *** Quits: grettke (~grettke@cpe-65-29-228-30.wi.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[05:48:32] *** Quits: biog (~user1@static.39.160.132.142.clients.your-server.de) (Quit: ZZZzzz…)
[05:50:40] *** Quits: klovett (~klovett@166.205.90.163) (Quit: ZZZzzz…)
[05:58:48] *** Joins: biog (~user1@static.39.160.132.142.clients.your-server.de)
[06:00:02] *** Quits: kjak (~kjak@pool-108-45-56-21.washdc.fios.verizon.net) (Ping timeout: 240 seconds)
[06:09:11] *** Quits: seninha (~seninha@user/seninha) (Quit: Leaving)
[06:19:59] *** Joins: grettke (~grettke@cpe-65-29-228-30.wi.res.rr.com)
[06:33:47] <gwatt> but that is a linked list
[06:52:41] *** Quits: biog (~user1@static.39.160.132.142.clients.your-server.de) (Quit: ZZZzzz…)
[06:59:56] *** Quits: zwr (~zwr@2804:d45:b966:fb00:1d:7713:457:353) (Ping timeout: 245 seconds)
[07:00:53] *** Joins: zwr (~zwr@2804:d45:b966:fb00:a05f:6b33:f679:bb49)
[07:04:47] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Ping timeout (120 seconds))
[07:13:41] *** Quits: terrorjack (~terrorjac@2a01:4f8:1c1e:509a::1) (Quit: The Lounge - https://thelounge.chat)
[07:15:53] *** Joins: terrorjack (~terrorjac@2a01:4f8:1c1e:509a::1)
[07:21:51] *** Joins: s-liao (~s-liao@101.86.96.21)
[07:48:00] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[08:15:37] *** Quits: skapata (~Skapata@user/skapata) (Remote host closed the connection)
[08:41:02] *** Quits: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 240 seconds)
[08:43:03] *** Joins: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[08:43:34] *** Joins: s-liao (~s-liao@101.86.96.21)
[08:51:46] *** Joins: ZombieChicken (~weechat@user/zombiechicken)
[08:56:46] <Spawns> thats pretty close to what I do tokie 
[08:57:57] *** Quits: taiju (~taiju@240b:253:ec40:2400:5cec:b035:3bed:59cc) (Ping timeout: 240 seconds)
[08:57:59] <Spawns> also gwatt, very much so. since you need to store references when "walking" down the cons chain, it makes it extremely tricky 
[08:58:02] *** Quits: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 240 seconds)
[08:59:41] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[09:00:25] *** Joins: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[09:12:03] *** Quits: ZombieChicken (~weechat@user/zombiechicken) (Ping timeout: 276 seconds)
[09:19:58] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[09:25:07] *** Joins: ad_absurdum (~ad-absurd@23-126-79-16.lightspeed.spfdmo.sbcglobal.net)
[09:27:08] *** Quits: ad-absurdum (~ad-absurd@23-126-79-16.lightspeed.spfdmo.sbcglobal.net) (Ping timeout: 250 seconds)
[09:34:11] <mdhughes> You can't easily build a tree without mutable pairs, so that might be a problem for a lot of programs. I don't object to immutable pair as default; racket got that right.
[09:35:07] <mdhughes> A pair of mutable boxes = mutable pair with extra reference & cons for every single item.
[09:35:28] <mdhughes> s/A pair/An immutable pair/
[09:53:45] <Spawns> i have figured out a workaround to allow for mutable conses I think, I just have to totally avoid the Iterator trait and sadly lose out on a lot of auto generated stuff that you get when you implement Iterator
[09:54:28] <Spawns> Iterator has to store a reference to the current cell, and the goal is to return a reference to the next cell, which is impossible to do in safe rust if the reference is mutable
[09:54:50] <Spawns> not even refcell allows for that
[10:06:24] *** Quits: ad_absurdum (~ad-absurd@23-126-79-16.lightspeed.spfdmo.sbcglobal.net) (Quit: Leaving)
[10:07:32] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 240 seconds)
[10:33:00] *** Joins: rgherdt (~rgherdt@2a02:8109:86c0:d8d:c53f:d83a:dd8d:27ab)
[10:34:44] *** Quits: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net) (Ping timeout: 250 seconds)
[11:00:37] *** Quits: xgqt (~xgqt@gentoo/developer/xgqt) (Ping timeout: 240 seconds)
[11:01:28] *** Joins: xgqt (~xgqt@gentoo/developer/xgqt)
[11:01:49] *** Joins: epony (epony@user/epony)
[11:11:12] *** Joins: kjak (~kjak@pool-108-45-56-21.washdc.fios.verizon.net)
[11:22:32] *** Quits: kjak (~kjak@pool-108-45-56-21.washdc.fios.verizon.net) (Ping timeout: 240 seconds)
[11:27:14] *** Joins: karlosz (~karlosz@47.151.136.69)
[11:47:33] *** Joins: s-liao (~s-liao@101.86.96.21)
[12:10:04] *** Quits: grettke (~grettke@cpe-65-29-228-30.wi.res.rr.com) (Ping timeout: 250 seconds)
[12:13:24] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 276 seconds)
[12:14:17] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[12:31:32] *** Joins: notzmv (~zmv@user/notzmv)
[12:33:54] *** Joins: grettke (~grettke@cpe-65-29-228-30.wi.res.rr.com)
[12:49:30] *** Quits: rgherdt (~rgherdt@2a02:8109:86c0:d8d:c53f:d83a:dd8d:27ab) (Ping timeout: 250 seconds)
[13:05:17] *** Joins: seninha (~seninha@user/seninha)
[13:18:05] *** Quits: szkl (uid110435@id-110435.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[13:54:35] *** Quits: karlosz (~karlosz@47.151.136.69) (Quit: karlosz)
[13:58:02] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[14:03:41] *** Quits: dnm (sid401311@lymington.irccloud.com) (Ping timeout: 256 seconds)
[14:03:51] *** Joins: dnm (sid401311@id-401311.lymington.irccloud.com)
[14:17:49] *** Joins: gproto23 (~gproto23@user/gproto23)
[14:41:53] <amazigh> universal greetings :)
[14:43:31] *** Quits: gproto23 (~gproto23@user/gproto23) (Ping timeout: 256 seconds)
[14:45:36] *** Joins: gproto23 (~gproto23@user/gproto23)
[14:46:36] <sham1> Spawns: and that's why you'd need unsafe rust
[14:52:32] *** Quits: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 240 seconds)
[15:05:21] *** Joins: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[15:17:45] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Quit: Quit)
[15:22:26] *** Joins: s-liao (~s-liao@101.86.96.21)
[15:32:32] *** Quits: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 240 seconds)
[15:34:39] *** Joins: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[15:48:03] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[15:50:47] *** Quits: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 256 seconds)
[15:58:09] *** Quits: gproto23 (~gproto23@user/gproto23) (Ping timeout: 256 seconds)
[16:19:49] *** Joins: skapata (~Skapata@2804:14c:87b0:a6f9:5d0c:5cd6:41ba:a0fc)
[16:19:49] *** Quits: skapata (~Skapata@2804:14c:87b0:a6f9:5d0c:5cd6:41ba:a0fc) (Changing host)
[16:19:49] *** Joins: skapata (~Skapata@user/skapata)
[16:24:13] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[16:25:30] *** Joins: s-liao (~s-liao@101.86.96.21)
[16:35:14] *** Joins: biog (~user1@static.39.160.132.142.clients.your-server.de)
[16:53:11] *** Joins: klovett (~klovett@166.205.90.163)
[16:54:14] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[16:54:25] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 256 seconds)
[16:56:26] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[17:08:32] *** Joins: gproto23 (~gproto23@user/gproto23)
[17:10:07] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 256 seconds)
[17:11:57] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[17:15:43] *** Joins: skeemer (~skeemer@h-158-174-23-219.NA.cust.bahnhof.se)
[17:18:02] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 240 seconds)
[17:20:17] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[17:33:32] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 240 seconds)
[17:35:38] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[17:54:32] *** Joins: NeoCron (~NeoCron@p200300c4cf4baa00766f97a7a0c56948.dip0.t-ipconnect.de)
[18:06:57] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 256 seconds)
[18:08:47] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[18:21:49] *** Quits: psf (~pi@206.55.172.18) (Ping timeout: 240 seconds)
[18:23:40] *** Joins: psf (~pi@206.55.172.18)
[18:24:31] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 256 seconds)
[18:26:09] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[18:38:03] *** Joins: civodul (~user@guix/contributor/civodul)
[18:52:40] *** Joins: Everything (~Everythin@37.115.210.35)
[18:54:50] *** Joins: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net)
[18:55:50] *** Joins: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net)
[18:57:38] *** Quits: alMalsamo (~alMalsamo@gateway/tor-sasl/almalsamo) (Remote host closed the connection)
[18:57:57] *** Joins: alMalsamo (~alMalsamo@gateway/tor-sasl/almalsamo)
[18:59:49] <tokie> Spawns: all of this is definitely easier if you just write a VM
[19:00:44] <tokie> which is funny, because it draws parallels to this rust keynote about how the common ECS pattern for games makes borrow checkers a lot happier: https://www.youtube.com/watch?v=aKLntZcp27M
[19:28:53] *** Joins: yewscion (~yewscion@52.94.133.128)
[19:30:53] <elly> what is the ECS pattern?
[19:31:20] <sham1> Entity Component System, I think
[19:35:42] <edgar-rft> Electro-Convulsive Shock, what else?
[19:36:59] <leah2> elastic container service :(
[19:38:36] <edgar-rft> Elastrator Castration Service :-)
[19:44:18] <amazigh> Extra-ordinar Concentration of Schemers
[19:44:32] *** Quits: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net) (Ping timeout: 240 seconds)
[19:44:53] <amazigh> I hope to have hands knowledge of ECS one day ;)
[19:45:19] <amazigh> I keep stumbling upon the concept, but never really had exposure to it in my daily work
[19:46:38] <amazigh> On an unrelated note, I changed back to ubuntu, but starting from minimal server install, current RAM usage, with firefox running 1.5GiB
[19:47:12] <amazigh> Also I ditched the rpi400 for the time being.
[19:55:10] <amazigh> an another subject, I think I will keep arew repository a minimal fork of racket's chez scheme, and move the libraries stuff to scheme-live.
[19:59:35] *** Joins: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net)
[20:04:44] <amazigh> I made progress on the search engine, using python at this time. Re Scheme implementation, I am wondering whether I will not just drop the ambiant red library I started, and go callback hell instead!
[20:04:48] *** Quits: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net) (Quit: jrincayc)
[20:05:37] <amazigh> ambiand red incur an overhead, and ime callbacks are not evil.
[20:12:01] *** Quits: yewscion (~yewscion@52.94.133.128) (Ping timeout: 256 seconds)
[20:12:35] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 256 seconds)
[20:13:49] *** Quits: biog (~user1@static.39.160.132.142.clients.your-server.de) (Quit: ZZZzzz…)
[20:14:26] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[20:14:28] *** Quits: gproto23 (~gproto23@user/gproto23) (Read error: Connection reset by peer)
[20:32:02] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 240 seconds)
[20:34:03] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[20:40:02] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 240 seconds)
[20:42:25] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[20:46:49] *** Joins: tristero (~nobody@user/tristero)
[20:48:11] *** Joins: [deleted] (~livoreno@user/notzmv)
[20:50:32] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 240 seconds)
[20:51:51] *** Quits: livoreno (~livoreno@user/notzmv) (Ping timeout: 256 seconds)
[20:52:45] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[20:57:02] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 240 seconds)
[20:57:39] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[21:00:21] *** Quits: [deleted] (~livoreno@user/notzmv) (Ping timeout: 256 seconds)
[21:01:27] *** Joins: biog (~user1@static.39.160.132.142.clients.your-server.de)
[21:12:15] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 276 seconds)
[21:13:02] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[21:56:14] <Spawns> can we print functions back into sexprs?
[21:56:39] <ecraven> depends on your implementation
[21:56:56] <Spawns> so some implementations don't support that?
[21:57:19] <Spawns> seems like it would be tricky to support for schemes that compile to C or something like chicken
[21:58:01] <wasamasa> ding-ding-ding
[21:58:29] <wasamasa> if it's not in the standard, you cannot do it everywhere
[21:58:48] <Spawns> so I am assuming its not in the standard
[21:58:54] <Spawns> i haven't saw anything about it
[21:59:22] <wasamasa> it isn't, no
[21:59:57] <Zipheir> It's tricky for Schemes that compile expressions, period.
[22:00:32] <Spawns> thats why I was asking, I compile my exprs to bytecode, and there is really no way to get the sexpr back from the bytecode
[22:01:19] <wasamasa> no, you'd need to do something like storing what the reader produced as debug info associated with the procedure
[22:01:51] <Spawns> yeah I thought about that too, that wouldn't be super hard but if it's not a super common feature I just won't bother with it :)
[22:02:31] <Zipheir> Spawns: I think it's a very interesting path to try.
[22:04:54] *** Quits: biog (~user1@static.39.160.132.142.clients.your-server.de) (Quit: ZZZzzz…)
[22:06:56] <Zipheir> We already have many Schemes with the 'super common feature' (by def.), so if you're writing a new one you might as well explore new ideas, I say.
[22:07:01] <Zipheir> *features
[22:08:19] <Spawns> thats a good point
[22:11:38] <Spawns> right now it certainly can't be considered a scheme, but most of the implementation is generic enough to support turning it into one 
[22:11:53] <Spawns> the main thing i've ran into so far is supporting libraries 
[22:12:07] *** Quits: seninha (~seninha@user/seninha) (Quit: Leaving)
[22:12:39] <dpk> it's tricky in lexically-scoped Lisps in general
[22:13:07] *** Joins: seninha (~seninha@user/seninha)
[22:13:08] <dpk> how do you print the result of (let ((x 1)) (lambda (y) (+ x y))) ?
[22:14:28] <dpk> (and what if x is mutable?)
[22:19:46] *** Joins: biog (~user1@static.39.160.132.142.clients.your-server.de)
[22:24:25] <sham1> #<closure>
[22:24:25] <Oxyd> #<closure (x) (lambda (y) (+ x y))>, for example.
[22:24:32] <sham1> Same idea
[22:24:39] <Oxyd> The nice thing about writing your own Scheme is that you can do whatever you want.
[22:26:06] <sham1> One thing I've been thinking about is why don't we have an SRFI that allows one to define an external representation (at least for the purposes of write) for record types
[22:26:25] <Oxyd> In any case, it's probably more common and more useful to instead just print the source location. So you'd print it as #<closure lambda at foo.scm:27:5> or something.
[22:30:20] <Spawns> the original reason I was wondering about this, is I was curious how to handle macros that have functions in whatever they expand to, but i think that is not really a thing
[22:30:53] <Spawns> unless it expands to a quoted function, which is just a regular list and symbols and whatever
[22:31:13] <Oxyd> How does writing come into the equation when thinking about macros?
[22:31:33] <sham1> Well there is no such thing as a "quoted function", just a list where the first element is a symbol `lambda`
[22:31:34] <Spawns> what do you mean by writing?
[22:31:44] <Spawns> right exactly sham1 
[22:32:14] <Oxyd> Passing to the procedure called “write”. What you called “printing”.
[22:32:16] <Spawns> and a function call will just expand to whatever the output is. but with if we have a function that returns a function?
[22:32:36] <sham1> You get a procedure object
[22:33:10] <Spawns> a macro can't expand to a "procedure object" though can it? what would the text representation be?
[22:33:21] <sham1> A syntax object
[22:33:41] <Oxyd> Macros expand into expressions.
[22:33:56] <dpk> what a macro returns doesn't have to have a text representation. you can have a macro expand into a record-type instance, for example
[22:34:29] <sham1> Well a macro shouldn't return something that isn't a syntax object, unless one supports something weird like a defmacro-like system
[22:34:36] <dpk> expanding into an actual procedure value is bad style and afaik some Schemes don’t support it — you should expand into a lambda expression instead
[22:34:44] *** Joins: karlosz (~karlosz@47.151.136.69)
[22:34:48] <sham1> But yeah, it can expand to something that doesn't have  an external representation defined, like a record
[22:34:50] *** Joins: kjak (~kjak@pool-108-45-56-21.washdc.fios.verizon.net)
[22:35:10] <dpk> (bearing in mind also the compiler will probably get rid of the lambda expression in most cases, after macro expansion)
[22:36:48] <Oxyd> What Schemes allow macros that expand into anything other than expressions?
[22:37:01] <dpk> what *isn't* an expression? ;-)
[22:37:09] <Oxyd> A record instance, for example.
[22:37:51] <sham1> An instance of a record is clearly an expression, just not one with an external repr
[22:38:03] <Oxyd> No, it clearly isn't.
[22:38:16] <dpk> syntax-rules can't expand into a record instance. i'm not sure exactly what R6RS says about syntax-case macros expanding into records
[22:38:39] <Oxyd> I bet that syntax-case is required to return a syntax object.
[22:38:43] *** Quits: biog (~user1@static.39.160.132.142.clients.your-server.de) (Quit: ZZZzzz…)
[22:38:50] <sham1> Yeah it is
[22:38:59] <Oxyd> So, again, not a record instance.
[22:39:03] <dpk> yes, but a syntax object can include "a nonpair, nonvector, nonsymbol value"
[22:39:06] <dpk> according to R6RS
[22:39:10] <dpk> including a record
[22:40:36] <Oxyd> Do these make sense in any context other than inside a quote expression?
[22:40:54] <sham1> 3
[22:40:56] * dpk tries writing a macro expanding into a procedure in Chez just to see what happens
[22:41:27] <dpk> > (define-syntax foo
[22:41:27] <dpk>     (lambda (stx)
[22:41:27] <dpk>       (lambda (x) (+ x 1))))
[22:41:27] <dpk> > (foo)
[22:41:28] <dpk> Exception in +: #<procedure rho> is not a number
[22:41:37] <dpk> i don't know what i expected to happen, but that wasn't it
[22:42:52] <dpk> ah, but (define-syntax foo (lambda (stx) #`(quote #,(lambda (x) (+ x 1))))) does return the procedure when foo is invoked
[22:43:36] <dpk> Guile doesn't like that, though (While compiling expression: unhandled constant #<procedure 7f8e8100c0f0 at <unknown port>:3:17 (x)>)
[22:44:33] <Oxyd> Yes, because Scheme syntax is made out of pairs and symbols, not of procedures.
[22:44:45] <Oxyd> (And numbers, and vectors, and other literals.)
[22:45:20] <sham1> That's just what the (read) gives you
[22:45:52] <Spawns> in my impl, I have two different structs, both represent scheme objects, but one is consumed by the compiler and the other is for the VMs internals. For the VM I have a couple of extra slots like Object::Lambda or Object::NativeFn, but no clear way to turn those back into the compiler friendly struct.
[22:46:39] <Spawns> so, I was going to implement macros by converting between the two formats, and sending the compiler friendly version into a function that changes it, and then convert it back again
[22:47:55] <Spawns> i know that's not nearly enough information to be very useful
[22:50:15] <dpk> hmmz, Guile doesn't like records in syntax expansions, either
[22:50:18] <tokie> Spawns: i use the printer for that
[22:50:21] <tokie> print -> tokenize again
[22:50:22] <dpk> i'm fairly sure that's an R6RS violation
[22:50:43] <Spawns> oh thats a good idea tokie, i didn't consider just reading it back in
[22:50:45] <tokie> Spawns: i'm also writing a rust compiler/vm for scheme!
[22:50:52] <tokie> i'm just further along
[22:50:55] <Spawns> really! that's sweet
[22:51:08] <Spawns> is yours open source tokie ?
[22:51:10] <tokie> https://github.com/strtok/marwood
[22:51:13] <tokie> yep
[22:52:17] <tokie> i'm working on tail call right now
[22:52:36] * dpk adds R7RS issue 43: ‘What values are allowed to be returned from syntax transformers and what are their semantics?’
[22:53:46] <sham1> Writing the compiler in Scheme might make more sense, although doing the actual VM/runner stuff in Rust or whatever might be better
[22:53:47] <Oxyd> I'd say the obvious answer is “whatever values conform to the syntax defined in the standard”.
[22:53:49] <tokie> Spawns: you could let your lambdas save a pointer to the AST so you could use that for debugging, but that won't help with situations like eval() where you need to feed arbitrary structure back to the compiler
[22:53:55] <sham1> Sidesteps a lot of issues of bootstrapping
[22:55:32] *** Joins: biog (~user1@static.39.160.132.142.clients.your-server.de)
[22:55:45] <Spawns> tokie: your Cell enum is what my sexpr::Value and interpreter::Object are pretty much
[22:55:56] <tokie> sham1: yeah, it depends what one means by "compiler" - in my implementation the compiler mutates the VM because it might need to intern symbols on the VM heap for example
[22:56:08] <tokie> Spawns: yeah, i have a VCell that's the VM version 
[22:59:53] <tokie> then i have things like impl Heap { fn put_as_cell(&mut self, cell: &Cell) -> VCell }
[23:00:18] <Spawns> this is a very nice project tokie :)
[23:00:23] <tokie> thanks!
[23:01:36] <amazigh> anyone has ideas on how to implement pattern maching with procedures, unlike pattern matching with macros? I looking for something like (match exp (list (list (quote pattern) proc) ...)), apparantly it is not possible to use quasiquote. I can't come up with a terser dsl.
[23:02:01] <tokie> Spawns: is yours opensource?
[23:02:30] <amazigh> inside PATTERN, I was planning to use unquote to capture variables, and pass them to PROC
[23:02:51] <Spawns> i haven't uploaded mine yet
[23:02:56] <Spawns> it will be though!
[23:06:57] <tokie> Spawns: careful not to rm -rf :)
[23:09:59] <Spawns> mine is definitely a lot more primitive than yours. i have been implementing a lot of the basic procedures by calling into rust functions that I call "native functions"
[23:10:22] <Spawns> like add, sub, mul, div, equal
[23:10:39] *** Quits: karlosz (~karlosz@47.151.136.69) (Quit: karlosz)
[23:11:39] <tokie> it's all iterative
[23:11:56] <tokie> my first parser was a parser combinator: https://github.com/strtok/parcom
[23:12:22] <tokie> but i abandoned it because it is a project of its own :)
[23:12:52] <sham1> You also don't need parser combinators for lisp
[23:13:49] <Spawns> may not need one but you can use one for sure
[23:13:51] <tokie> absolutely not, yeah
[23:14:03] <Spawns> i don't think they use it for the scheme right?
[23:14:27] <tokie> are you using something like nom?
[23:14:48] <tokie> using an existing parser combinator for rust would work fine since there's a lot of work put into them and they have great error reporting
[23:14:49] <Spawns> i just wrote a little parser by hand 
[23:15:03] <Spawns> it doesn't support dotted lists though (yet)
[23:15:36] <Spawns> its actually extracted to its own "sexpr" crate
[23:15:39] <tokie> yeah, improper lists are a pain 
[23:16:14] <tokie> it took me some fiddling to get that and quote working correctly
[23:16:24] *** Quits: x88x88x (~x88x88x@149.28.53.172) (Quit: ZNC - https://znc.in)
[23:17:13] <Spawns> does yours support macros yet tokie ?
[23:17:17] <tokie> no
[23:17:50] <tokie> nor continuations
[23:18:28] <tokie> i just did the lambda special forms for varargs
[23:21:57] *** Joins: x88x88x (~x88x88x@149.28.53.172)
[23:27:33] *** Joins: karlosz (~karlosz@47.151.136.69)
[23:36:48] *** Joins: livoreno (~livoreno@user/notzmv)
[23:39:56] *** Quits: karlosz (~karlosz@47.151.136.69) (Ping timeout: 250 seconds)
[23:39:58] *** Joins: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net)
[23:44:31] *** Quits: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net) (Read error: Connection reset by peer)
[23:44:47] *** Joins: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net)
[23:49:08] <amazigh> tokie: Spawns: do you really on an existing test suite?
[23:53:20] <amazigh> rely*
[23:56:37] *** Quits: skapata (~Skapata@user/skapata) (Ping timeout: 240 seconds)
[23:57:32] *** Quits: xgqt (~xgqt@gentoo/developer/xgqt) (Ping timeout: 240 seconds)
[23:58:21] *** Joins: skapata (~Skapata@user/skapata)
[23:58:52] *** Joins: xgqt (~xgqt@gentoo/developer/xgqt)
