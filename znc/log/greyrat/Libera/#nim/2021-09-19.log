[00:00:32] *** Joins: ozzz (~oz@46.49.41.80)
[00:00:46] <FromDiscord> <Yardanico> ah yeah https://nim-lang.org/docs/nimc.html#nim-for-embedded-systems also has some info about it
[00:02:47] <FromDiscord> <auxym> yeah I had seen that. By any chance, are you aware of a example getting nim to build for ARM MCUs with arm-none-eabi-gcc? It seems to be emitting `_exit` syscall which fails to link (`exit.c:(.text.exit+0x18): undefined reference to _exit`)
[00:03:26] <FromDiscord> <Yardanico> maybe https://stackoverflow.com/questions/19419782/exit-c-text0x18-undefined-reference-to-exit-when-using-arm-none-eabi-gcc can help you?
[00:03:31] <FromDiscord> <Yardanico> the second answer
[00:03:36] <FromDiscord> <Yardanico> or the third
[00:06:54] *** Quits: neurocyte01 (~neurocyte@user/neurocyte) (Quit: The Lounge - https://thelounge.chat)
[00:08:59] *** Joins: neurocyte01 (~neurocyte@45.93.111.147)
[00:08:59] *** Quits: neurocyte01 (~neurocyte@45.93.111.147) (Changing host)
[00:08:59] *** Joins: neurocyte01 (~neurocyte@user/neurocyte)
[00:13:38] <FromDiscord> <auxym> yeah `--passC:--specs=nosys.specs` seems to work. I don't understand though because I thought arm-none-eabi-gcc linked against Newlib by default, which defines _exit
[00:40:41] <FromDiscord> <auxym> after doing some more reading, it seems that nosys actually is used to enable linking against Newlib's syscalls. duh.
[01:18:26] *** Quits: mst (~matthewt@vps-6c71e929.vps.ovh.net) (Changing host)
[01:18:26] *** Joins: mst (~matthewt@perl/shadowcat-mst/chainsaw-wielder)
[01:29:33] <FromDiscord> <Varriount> Is there a way to ensure a case statement explicitly covers a subset of an enumeration?
[01:31:10] <FromDiscord> <Elegantbeef> Short of `else: assert x in yourSubSet` dont think so
[01:31:21] <FromDiscord> <Elegantbeef> `notin` of course
[01:32:10] <FromDiscord> <Elegantbeef> Is it a range of values or a set of them?
[01:33:23] <FromDiscord> <Elegantbeef> sent a code paste, see https://paste.rs/MZ6
[01:42:41] <FromDiscord> <Varriount> @ElegantBeef I assume `range[0u8..3u8](2u8)` would throw a conversion error if `2u8` were substituted with a variable containing an `int8` value not between `0u8..3u8`?
[01:44:04] <FromDiscord> <Elegantbeef> I mean it's a range defect if you convert a value outside the range into the range
[01:44:10] <FromDiscord> <Elegantbeef> It's like `256.uint8`
[01:44:41] <FromDiscord> <Elegantbeef> You of course should check the range before hand to prevent a raised defect
[01:46:27] <FromDiscord> <leorize> https://github.com/nim-lang/Nim/pull/15212
[01:46:34] <FromDiscord> <leorize> another plug for my pr \:p
[01:46:43] <FromDiscord> <Elegantbeef> Indeed
[01:47:15] <FromDiscord> <Elegantbeef> Such a addition delayed for not very good reason \:D
[01:49:38] *** Quits: luis_ (~luis@50-242-35-142-static.hfc.comcastbusiness.net) (Quit: luis_)
[01:50:07] *** Joins: luis_ (~luis@50-242-35-142-static.hfc.comcastbusiness.net)
[01:50:24] <FromDiscord> <Elegantbeef> Maybe we need to make a `subrangeutils` package leorize üòõ
[01:50:51] <FromDiscord> <leorize> we need `realtypetraits`
[01:56:06] <FromDiscord> <auxym> it seems that `-d:release` (or danger) automatically implies `--opt:speed`, overriding any `--opt` that is passed by the user. Is this expected behavior?
[01:58:18] *** Quits: luis_ (~luis@50-242-35-142-static.hfc.comcastbusiness.net) (Ping timeout: 260 seconds)
[01:58:34] <FromDiscord> <Yardanico> In reply to @auxym "it seems that `-d:release`": yes, it is
[01:58:42] <FromDiscord> <Yardanico> you can always just do -d:release --opt:size to set opt to something else
[01:58:53] <FromDiscord> <Yardanico> just make sure it's placed after -d:release in the cmdline
[01:59:10] *** Quits: max22- (~maxime@2a01cb08833598007ff170d7dad3fd31.ipv6.abo.wanadoo.fr) (Quit: Leaving)
[01:59:33] <FromDiscord> <auxym> oh yeah, that works. doesn't work in nim.cfg though
[01:59:40] <FromDiscord> <Yardanico> wdym?
[01:59:56] <FromDiscord> <leorize> yea, -d\:release is special
[02:00:03] <FromDiscord> <Yardanico> -d:release didn't work in nim configs until nim 1.4.8
[02:01:43] <FromDiscord> <auxym> hm wait. it seems something else might be triggering it
[02:02:32] <FromDiscord> <Yardanico> oh wow, I didn't know new {.all.} pragma for importing all symbols actually worked with [] import syntax
[02:02:36] <FromDiscord> <Yardanico> `import std/[db_sqlite {.all.}, sqlite3 {.all.}]` this works just fine
[02:03:38] <FromDiscord> <Yardanico> (talking in the context of https://forum.nim-lang.org/t/8433 )
[02:04:17] <FromDiscord> <auxym> actually I think it's good. couldn't reproduce. putting `define="release"` before `--opt:size` does seem to work as expected
[02:08:35] <FromDiscord> <Yardanico> @auxym what did you mean in https://forum.nim-lang.org/t/6844#54452 bwt?
[02:08:36] <FromDiscord> <Yardanico> (edit) "bwt?" => "btw?"
[02:08:52] <FromDiscord> <Yardanico> You can define some options conditionally, e.g. depending on a custom symbol
[02:09:06] <FromDiscord> <Yardanico> e.g. see https://github.com/Yardanico/adbscan/blob/master/src/adbscan.nims
[02:12:28] <FromDiscord> <auxym> Thanks for the example. Is there a way then to get the value of `--cpu` and `--os` in order to set `gcc.exe` conditionally?
[02:12:29] <FromDiscord> <Varriount> leorize: Commented on your PR. Personally, I would rather it be in `system`, since it seems like something that should be "built-in", as it were.
[02:12:56] <FromDiscord> <Varriount> @auxym In nim.conf?
[02:12:58] <FromDiscord> <Yardanico> In reply to @auxym "Thanks for the example.": yep
[02:13:06] <FromDiscord> <Yardanico> you can access buildOS and buildCPU  from nimscript files
[02:13:07] <FromDiscord> <Elegantbeef> I'd argue it should just be `slice` but that's bikeshedding üòÄ
[02:13:19] <FromDiscord> <auxym> much thanls
[02:13:25] <FromDiscord> <Yardanico> https://nim-lang.org/docs/nimscript.html#buildOS https://nim-lang.org/docs/nimscript.html#buildCPU
[02:14:22] <FromDiscord> <Varriount> In reply to @Elegantbeef "I'd argue it should": Meh, IMO, `slice` is just a run-time representation of `range`.
[02:15:06] *** Joins: luis_ (~luis@50-242-35-142-static.hfc.comcastbusiness.net)
[02:15:36] <FromDiscord> <Elegantbeef> Oh i agree but given some dont like the `x in T`
[02:17:20] *** Joins: max22- (~maxime@2a01cb0883359800b763d25c3c1fa8b3.ipv6.abo.wanadoo.fr)
[02:18:35] <FromDiscord> <leorize> I can make it `of` \:p
[02:19:04] <FromDiscord> <Elegantbeef> lol i like the `in`
[02:19:30] *** Quits: max22- (~maxime@2a01cb0883359800b763d25c3c1fa8b3.ipv6.abo.wanadoo.fr) (Client Quit)
[02:20:49] <FromDiscord> <leorize> worst case I would just make an `inspector` package for nim types
[02:21:09] <FromDiscord> <Elegantbeef> Indeed then you have contributions from a numpty üòõ
[02:22:19] <FromDiscord> <leorize> or you can make it \:p I have more than enough packages to tend to atm
[02:22:25] <FromDiscord> <Elegantbeef> Like i dont üòõ
[02:22:55] <FromDiscord> <Elegantbeef> Hey one of you lurkers get on it, i know you're reading this message
[02:24:07] <FromDiscord> <Elegantbeef> Fucking lurkers, pretending they dont read messages, shame!
[02:26:41] <FromDiscord> <Yardanico> Hey, be more polite to them!
[02:26:54] <FromDiscord> <Elegantbeef> Ah sorry, sodding lurkers\
[02:27:16] <FromDiscord> <Yardanico> Otherwise they might start silently hating you ·Éö(‡≤†Áõä‡≤†·Éö)
[02:27:27] <FromDiscord> <Yardanico> sorry I meant (‚ï¨ ‡≤†Áõä‡≤†)
[02:27:27] <FromDiscord> <leorize> I think it might be a bad idea to promote doing this for modules you don't own‚Üµ(@Yardanico)
[02:27:31] <FromDiscord> <Elegantbeef> Eh rika vocally hates me what's new
[02:27:40] <FromDiscord> <Yardanico> @leorize well, but it's better than having to edit stdlib modules
[02:28:09] <FromDiscord> <Yardanico> of course you might argue that patchFile is better since then you control the whole file, but {.all.} is simpler
[02:28:15] <FromDiscord> <leorize> then the next update shuffles the names around and their software stops compiling
[02:28:43] <FromDiscord> <Yardanico> sure, you can post that warning on the forum post :)
[02:28:53] <FromDiscord> <Yardanico> i kind of forgot about that, but generally stdlib modules like db_sqlite are pretty stable :P
[02:29:15] <FromDiscord> <leorize> you mean no one works on them \:p
[02:29:22] <FromDiscord> <Yardanico> shhh
[03:08:17] <NimEventer> New Nimble package! surfing - Surfing is a highly functional CLI for Base64., see https://github.com/momeemt/surfing
[03:13:31] *** Quits: luis_ (~luis@50-242-35-142-static.hfc.comcastbusiness.net) (Ping timeout: 252 seconds)
[03:16:04] <FromDiscord> <dom96> what is this {.all.} thing?
[03:17:43] <FromDiscord> <Elegantbeef> It overrides export markers and pulls all main symbols
[03:18:05] <FromDiscord> <Elegantbeef> Useful for texting APIs
[03:18:29] <FromDiscord> <Yardanico> In reply to @dom96 "what is this {.all.}": imports all modules from a module
[03:18:33] <FromDiscord> <Yardanico> (edit) "modules" => "symbols"
[03:18:41] <FromDiscord> <Yardanico> both private and public ones
[03:19:02] <FromDiscord> <Yardanico> there's also a new stdlib module for accessing private fields of an object without importing the whole module with {.all.}
[03:19:16] <FromDiscord> <Yardanico> https://nim-lang.github.io/Nim/importutils.html
[03:21:33] <FromDiscord> <Varriount> This might sound like a stupid question, but do boolean expressions run in the compiler VM perform short-circuiting? And if so, is it only in `if` statements, or is it in `var` statements too?
[04:03:29] *** Joins: Gustavo6046_ (~Gustavo60@user/gustavo6046)
[04:03:40] *** Quits: Gustavo6046 (~Gustavo60@user/gustavo6046) (Ping timeout: 240 seconds)
[04:06:12] *** Gustavo6046_ is now known as Gustavo6046
[04:41:49] <FromDiscord> <Yardanico> https://github.com/nim-lang/Nim/issues/18863 fun stuff
[05:08:24] *** Joins: vicfred (~vicfred@user/vicfred)
[05:26:22] *** Quits: vicfred (~vicfred@user/vicfred) (Quit: Leaving)
[05:32:55] <FromDiscord> <@bracketmaster-5a708063d73408ce4> I'm trying to do some basic graph traversal in nim, and `c` is clearly a child of `b`, but nim doesn't think so...
[05:32:57] <FromDiscord> <@bracketmaster-5a708063d73408ce4> oops
[05:33:00] <FromDiscord> <@bracketmaster-5a708063d73408ce4> https://play.nim-lang.org/#ix=3zil
[05:33:02] <FromDiscord> <@bracketmaster-5a708063d73408ce4> there
[05:33:07] <FromDiscord> <@bracketmaster-5a708063d73408ce4> sent a long message, see https://paste.rs/3dO
[05:33:38] <FromDiscord> <Elegantbeef> you're not using a ref object
[05:33:44] <FromDiscord> <Yardanico> `object` is a value
[05:34:14] <FromDiscord> <Yardanico> "object"s are passed by-value and not references
[05:34:45] <FromDiscord> <Yardanico> maybe https://forum.nim-lang.org/t/8426 can help you understand the differences a bit
[05:35:17] <FromDiscord> <@bracketmaster-5a708063d73408ce4> heh - I knew that
[05:35:29] <FromDiscord> <@bracketmaster-5a708063d73408ce4> thx
[05:38:33] <nrds> <06Prestige99> @Elegantbeef I don't suppose you have a written guide on concepts, do you? The experimental features page isn't super clear to me
[05:38:48] <FromDiscord> <Elegantbeef> I can write one if need be \:D
[05:38:50] *** Quits: arkurious (~arkurious@user/arkurious) (Quit: Leaving)
[05:39:16] <FromDiscord> <Elegantbeef> Basically old concepts are just a case of for each statement inside of it it needs to return true to pass
[05:39:39] <nrds> <06Prestige99> I'm trying to use them like interfaces, saying my type will have a proc foo(f: float)
[05:40:14] <FromDiscord> <Elegantbeef> Ok so to reference my concept from last night
[05:40:25] <nrds> <06Prestige99> or rather type T has proc foo(t: T, f: float)
[05:40:34] <FromDiscord> <Yardanico> you can't really use them like interfaces because interfaces can be used at runtime (e.g. you can create seq[MyInterface]) but you can't do that with concepts
[05:40:43] <FromDiscord> <Yardanico> but if you only need compile-time matching, then concepts will work
[05:40:54] <FromDiscord> <Elegantbeef> `concept f` is the same as a variable `var a: Frameable`
[05:40:59] <nrds> <06Prestige99> Yeah I think compile time would be fine in my case
[05:41:05] <FromDiscord> <Elegantbeef> `type F` is the same as `typeof(a)`
[05:41:18] <FromDiscord> <Yardanico> btw, if you specifically need something similar to interfaces, you can use https://github.com/yglukhov/iface
[05:41:24] <FromDiscord> <Elegantbeef> i guess `var f: Frameable` is more accurate
[05:41:31] <FromDiscord> <Elegantbeef> Yardanico shush for a bit please
[05:41:48] <FromDiscord> <Yardanico> sure, but I'm trying to help too :P
[05:42:22] <FromDiscord> <Elegantbeef> Flooding with unneeded information presently, he's just trying to understand how the concept was used/expand in my example code from last night
[05:43:11] <nrds> <06Prestige99> Is there any way to enforce a type to implement a concept at compile time?
[05:43:16] <FromDiscord> <Elegantbeef> so prestige it's now just a case of `foo(f, 1.0)`
[05:43:24] <FromDiscord> <Elegantbeef> I mean you write a procedure for it
[05:43:40] <FromDiscord> <Elegantbeef> You cannot enforce a concept match without it matching procedures you defined as "needed"
[05:44:02] <FromDiscord> <Elegantbeef> It doesnt make sense to force a match given you're laying out a case of "What i need for this to work"
[05:44:45] <FromDiscord> <Elegantbeef> The nice thing is prestige you can handle most math logic with just a generic
[05:45:04] <nrds> <06Prestige99> Hmm okay
[05:45:22] <FromDiscord> <Elegantbeef> Well give you a modifcation that has a generic lerp
[05:46:46] <nrds> <06Prestige99> iface looks neat too, think it reads better at least
[05:46:58] <FromDiscord> <Elegantbeef> It's also not for the same thing though
[05:46:59] <FromDiscord> <Yardanico> well new-style concepts are also like that
[05:47:18] <FromDiscord> <Elegantbeef> Yea new style concepts also exist which are just proc definitions
[05:47:46] <FromDiscord> <Elegantbeef> `proc foo(t: Self, f: float)` would be what you do in a new style concept
[05:47:56] <FromDiscord> <Elegantbeef> But they're also more limited...
[05:48:05] <FromDiscord> <QueenFuckingAdrielle> does anyone have a parquet reader for nim?
[05:48:33] <FromDiscord> <QueenFuckingAdrielle> I'm not really sure how to begin coding that...
[05:48:54] <FromDiscord> <Yardanico> there seems to be a C wrapper, not sure how well it works though
[05:48:55] <FromDiscord> <Yardanico> https://github.com/emef/nimarrow_glib
[05:49:36] <FromDiscord> <QueenFuckingAdrielle> gotcha, what sort of rabbit hole would it be to implement a reader/writer in pure nim?
[05:50:03] <FromDiscord> <Yardanico> it's hard to tell, but it's just like implementing any other protocol
[05:50:10] <FromDiscord> <QueenFuckingAdrielle> just for parquet, not the entirety of arrow
[05:50:31] <FromDiscord> <Yardanico> doesn't look to be too complex
[05:50:43] <FromDiscord> <Elegantbeef> Prestige here is an exampl(relies on vmath) for a generic lerp https://play.nim-lang.org/#ix=3zir
[05:51:04] <FromDiscord> <QueenFuckingAdrielle> its a decent format, ive been mainly using msgpack,json,csv
[05:51:15] <nrds> <06Prestige99> Thanks beef :)
[05:51:15] <FromDiscord> <Elegantbeef> Aslong as you can do `+`, `-`, `` the lerp will be usable
[05:51:16] <FromDiscord> <QueenFuckingAdrielle> but parquet is becoming standard now
[05:51:20] <FromDiscord> <Yardanico> you can probably recreate it pretty well from https://github.com/apache/parquet-format/blob/master/src/main/thrift/parquet.thrift
[05:51:24] <FromDiscord> <Yardanico> seems to be pretty readable
[05:51:29] <FromDiscord> <Gustavo6046> is a floating-point math operator that is immediately used to store an integer variable replaced by an equivalent integer one?
[05:51:36] <FromDiscord> <Gustavo6046> for example, `/` is floating point div but `div` is integer
[05:52:12] <FromDiscord> <Yardanico> sorry, didn't quite understand the question :P
[05:52:26] <FromDiscord> <Gustavo6046> sent a code paste, see https://play.nim-lang.org/#ix=3zis
[05:52:27] <FromDiscord> <Elegantbeef> That seems like an optimization that doesnt make sense to do
[05:52:36] <FromDiscord> <Elegantbeef> No it shouldnt since `/` returns float
[05:52:44] <FromDiscord> <Yardanico> no, that won't work @Gustavo6046
[05:52:50] <FromDiscord> <Gustavo6046> but it's only used to set an integer
[05:52:54] <FromDiscord> <Gustavo6046> oh
[05:53:03] <FromDiscord> <Gustavo6046> implicit cast can differ from the equivalent integer result?
[05:53:05] <FromDiscord> <Elegantbeef> but `/` returns float explictly
[05:53:07] <FromDiscord> <Elegantbeef> if you want integer  division use `div`
[05:53:13] <FromDiscord> <Yardanico> In reply to @Gustavo6046 "implicit cast can differ": there are no implicit casts
[05:53:17] <FromDiscord> <QueenFuckingAdrielle> yea thats not the most confusing protocol. Do you think my performance would crap out if i subprocessed supported lang script and piped the data over to nim>
[05:53:22] <FromDiscord> <Gustavo6046> then what is mynumber set to?
[05:53:23] <FromDiscord> <QueenFuckingAdrielle> (edit) "nim>" => "nim?"
[05:53:25] <FromDiscord> <Elegantbeef> There is no provided implict type conversion in nim
[05:53:32] <FromDiscord> <Gustavo6046> oh
[05:53:33] <FromDiscord> <Yardanico> In reply to @Gustavo6046 "then what is mynumber": that code won't
[05:53:33] <FromDiscord> <Gustavo6046> compiler error
[05:53:33] <FromDiscord> <Elegantbeef> nothing it errors
[05:53:37] <FromDiscord> <Yardanico> exactly
[05:53:42] <FromDiscord> <Gustavo6046> I figured
[05:53:44] <FromDiscord> <Gustavo6046> if it doesn't cast
[05:53:46] <FromDiscord> <Gustavo6046> then that is error
[05:53:49] <FromDiscord> <Yardanico> in this case you're using `/` proc that takes two integers and returns a float
[05:53:49] <FromDiscord> <Gustavo6046> ooooh
[05:53:50] <FromDiscord> <Gustavo6046> that explains a lot
[05:53:54] <FromDiscord> <Elegantbeef> `std/leniantops `
[05:54:00] <FromDiscord> <Yardanico> std/lenientops 
[05:54:01] <FromDiscord> <Gustavo6046> \:) thanks!
[05:54:22] <FromDiscord> <Elegantbeef> Yardanico taking over for rika on being my spell check
[05:54:33] <FromDiscord> <Elegantbeef> Hopefully you werent to offended by me telling you to shush \:D
[05:54:33] <FromDiscord> <Yardanico> In reply to @QueenFuckingAdrielle "yea thats not the": if there's a python module you can use https://github.com/yglukhov/nimpy which might be faster than doing subprocessing
[05:54:49] <FromDiscord> <Yardanico> nah, it's fine :)
[05:55:22] <FromDiscord> <QueenFuckingAdrielle> ah okay, thats a good point, I haven't touched nimpy yet. I'll look at that. thnx!
[05:56:42] *** Joins: neurocyte013 (~neurocyte@94.46.67.47)
[05:56:43] *** Quits: neurocyte013 (~neurocyte@94.46.67.47) (Changing host)
[05:56:43] *** Joins: neurocyte013 (~neurocyte@user/neurocyte)
[05:59:05] *** Quits: neurocyte01 (~neurocyte@user/neurocyte) (Ping timeout: 268 seconds)
[05:59:05] *** neurocyte013 is now known as neurocyte01
[05:59:12] <FromDiscord> <Elegantbeef> Hopefully that's an ok api prestige i imagine you'd want to manually handle enums and any other values such as strings or objects
[05:59:51] <FromDiscord> <Elegantbeef> Cause for enums you'd probably only want to change to the b value in the lerp when the time is \>= 1
[06:18:52] <FromDiscord> <QueenFuckingAdrielle> how is the health of the nim community going? been a bit outta touch
[06:19:15] <FromDiscord> <Yardanico> "health" as in what?
[06:19:35] <FromDiscord> <Yardanico> there haven't been any major events in the nim community lately, everything's going as usual
[06:20:10] <FromDiscord> <Elegantbeef> So there are 10 people surrounding a barrel fire
[06:24:15] <FromDiscord> <QueenFuckingAdrielle> gotcha, nim is still my favorite language lol just wondernig
[06:24:54] <FromDiscord> <QueenFuckingAdrielle> I'm frustrated with the direction of a lot of languages
[06:48:16] <FromDiscord> <Anuke> Is it possible to have a template/macro that accepts optional parameters, but with a mandatory untyped block at the end? https://play.nim-lang.org/#ix=3ziG
[06:50:47] <FromDiscord> <@bracketmaster-5a708063d73408ce4> ok - why on earth is append sting in nim `&` and not `+`
[06:51:46] <FromDiscord> <leorize> because `+` is for math \:p
[06:52:52] <FromDiscord> <amadan> In reply to @Anuke "Is it possible to": it works in devel for me‚ÜµThis PR added the feature https://github.com/nim-lang/Nim/pull/18631
[06:53:32] <FromDiscord> <Anuke> nice, I recalled seeing that PR earlier but couldn't find it
[06:55:50] <FromDiscord> <Anuke> I'd rather not switch to devel if at all possible (not easy to use on CI), is there some sort of workaround available?
[06:57:41] <FromDiscord> <Elegantbeef> Simples it s https://play.nim-lang.org/#ix=3ziM
[07:01:03] <FromDiscord> <Elegantbeef> The silence means "anuke didnt like that" üòõ
[07:02:54] <FromDiscord> <pietroppeter> In reply to @@bracketmaster-5a708063d73408ce4 "ok - why on": One good reason is that + usually denotes a commutative operation and append is not commutative: ‚Äúa‚Äù & ‚Äúb‚Äù != ‚Äúb‚Äù & ‚Äúa‚Äù
[07:05:07] <FromDiscord> <Elegantbeef> One could also argue it shows allocations üòõ
[07:51:49] <FromDiscord> <jakefromstatefarm> Nim is so cool, the fact that it compiles to basically every system is really useful and super neat.
[08:05:58] <FromDiscord> <Rika> + can mean non-commutative addition depending on mathematical context
[08:06:04] <FromDiscord> <Rika> Still it‚Äôs used for math
[08:28:56] <FromDiscord> <amadan> In reply to @Anuke "I'd rather not switch": Workaround I've used before is to take in `varargs[untyped` as the only parameter then parse the other parameters from that
[08:29:05] <FromDiscord> <amadan> (edit) "`varargs[untyped`" => "`varargs[untyped]`"
[08:29:44] <FromDiscord> <amadan> not the cleanest of methods (and someone probably knows a better way) but gets the job done
[08:36:02] *** Quits: supakeen (~user@python/site-packages/supakeen) (Quit: WeeChat 3.2.1)
[08:36:31] *** Joins: supakeen (~user@python/site-packages/supakeen)
[09:06:33] <FromDiscord> <pietroppeter> sent a long message, see http://ix.io/3zja
[09:21:35] <nisstyre> For some reason trying to access a slice of a sequence like xs[1..^1] causes my programs to crash with a call depth limit reached error...
[09:21:40] <nisstyre> even though I'm not doing any recursion
[09:22:37] <FromDiscord> <Elegantbeef> Code example?
[09:23:01] <nisstyre> I think it might be because it's a custom type
[09:23:07] <nisstyre> and I defined the $ function
[09:23:13] <nisstyre> but not sure
[09:23:34] <nisstyre> I don't have a minimal example that's runnable
[09:24:04] <FromDiscord> <Elegantbeef> are you echoing a slice of a cyclical reference type?
[09:24:52] <nisstyre> let me try and make it run outside of this
[09:24:55] <nisstyre> it is a ref object
[09:25:01] <nisstyre> but it happens even without echo
[09:25:20] <FromDiscord> <Elegantbeef> It being a ref doesnt matter as much as being cyclical
[09:26:26] <nisstyre> this crashes https://play.nim-lang.org/#ix=3zjc
[09:26:53] <nisstyre> oh is it the "discard"
[09:26:55] <nisstyre> my bad
[09:27:12] <nisstyre> I bet that's it
[09:27:22] <FromDiscord> <Elegantbeef> What discard?
[09:27:27] <FromDiscord> <Elegantbeef> The ones in the typedef?
[09:27:28] <nisstyre> in the type
[09:27:30] <nisstyre> yeah
[09:27:36] <nisstyre> could that be causing it?
[09:27:42] <FromDiscord> <Elegantbeef> No
[09:27:50] <nisstyre> any ideas?
[09:27:52] <FromDiscord> <Elegantbeef> It's recursively calling `$`
[09:28:02] <nisstyre> ok so what I thought then
[09:28:13] <FromDiscord> <Elegantbeef> You're recursively calling `$fracProgram`
[09:28:20] <nisstyre> that makes sense
[09:28:22] <nisstyre> ah
[09:28:28] <FromDiscord> <Elegantbeef> Remove that proc it works
[09:28:30] <nisstyre> yep
[09:28:37] <FromDiscord> <Elegantbeef> sequences have a `$` operator built in üòÄ
[09:28:56] <nisstyre> yeah I don't know why I defined that originally
[09:29:09] <FromDiscord> <Elegantbeef> you can also call the specific system one by doing `system.`$`(yourSeq)`
[09:29:32] <FromDiscord> <Elegantbeef> But yea no point redeclaring it since it's a type alias and not a distinct
[09:36:03] *** Quits: pch (~pch@66.49.131.33) (Read error: Connection reset by peer)
[09:36:21] *** Joins: pch (~pch@66.49.131.33)
[09:45:18] *** Joins: max22- (~maxime@2a01cb0883359800da5887c8e8eac50d.ipv6.abo.wanadoo.fr)
[10:54:17] <FromDiscord> <cabboose> Hey y'all check out our package
[10:54:23] <FromDiscord> <cabboose> https://github.com/shayanhabibi/loony
[10:54:47] <FromDiscord> <cabboose> Good luck with it; don't burn your CPUs
[11:00:35] <FromDiscord> <Rika> Does CPS async work under ARC?
[11:01:36] <FromDiscord> <cabboose> CPS is lower level than async/await; but this queue does work under ARC
[11:01:42] <FromDiscord> <cabboose> Works with any ref object
[11:02:23] <FromDiscord> <cabboose> Really this queue means theres no limitations with sync/async operations on multi threaded code
[11:02:46] <FromDiscord> <cabboose> Disruptek ran 500 million continuations over 24,000 queues successfully
[11:02:59] <FromDiscord> <Rika> I know it is
[11:03:40] <FromDiscord> <Rika> I ask because such package does not work under ORC and regular async has cyclic objects
[11:03:57] <FromDiscord> <Rika> Which is why I ask if async using CPS works without ORC
[11:04:17] <FromDiscord> <cabboose> oh nah cps and async gel well together
[11:04:18] <FromDiscord> <cabboose> under orc/arc
[11:04:29] <FromDiscord> <cabboose> but that queue does not work with any ref object under ORC for some reason
[11:04:56] <FromDiscord> <cabboose> for whatever reason the last `=destroy` we would call on an object would just cause a crash
[11:05:06] <FromDiscord> <cabboose> whether it was a string or continuation
[11:05:22] <FromDiscord> <cabboose> ORC is strange ü§∑üèΩ‚Äç‚ôÇÔ∏è
[11:06:04] <FromDiscord> <Rika> I know they gel well together but does async still generate cyclic objects using CPS
[11:06:59] <FromDiscord> <cabboose> if it does in the std lib it will with cps
[11:09:34] <NimEventer> New question by SlightlyKosumi: How to instantiate an app with ProcessStartInfo in this winim library, see https://stackoverflow.com/questions/69240927/how-to-instantiate-an-app-with-processstartinfo-in-this-winim-library
[12:25:34] <FromDiscord> <dain> at 41:43 in this video: https://youtu.be/QM1iUe6IofM?t=2503‚Üµhe proposes a language construct that works like a new scope, but you have to explicitly pass in all of the names you want to be visible. inside the block it doesn't see anything else from the enclosing scope. is it possible to implement this in nim as a macro?
[12:29:33] <FromDiscord> <dain> i was thinking something that would walk the AST and replace every name with a gen-symmed version of it except for the ones that get passed in. but maybe there's a cleaner way? also is there a way to distinguish between names that are available at top level vs inner levels? it would suck to have to pass in all of the imported functions you wanted to use as well
[12:29:49] <FromDiscord> <dain> (edit) "it" => "itself"
[12:29:50] <FromDiscord> <Elegantbeef> That's way  to fucking mess
[12:32:21] <FromDiscord> <Elegantbeef> https://play.nim-lang.org/#ix=3zjL
[12:32:22] <FromDiscord> <Elegantbeef> Here we go did it
[12:33:29] <FromDiscord> <Elegantbeef> If you want to ensure you dont use other symbols you can iterate over the entire scope checking if the symbol comes from a var stmt and not equal to the passed symbols
[12:33:37] <FromDiscord> <Elegantbeef> Can show that aswell
[12:36:08] <FromDiscord> <dain> yeah thats the idea
[12:37:40] <FromDiscord> <dain> how do you inspect the current scope?
[12:38:02] <FromDiscord> <Elegantbeef> I mean you dont need to you iterate the body
[12:38:13] <FromDiscord> <dain> oh
[12:38:40] <FromDiscord> <Elegantbeef> Commas i should use
[12:38:57] <FromDiscord> <dain> is it possible to check whether a symbol comes from the module level scope?
[12:38:57] <FromDiscord> <Elegantbeef> You dont need to inspect the current scope, you just iterate the body looking for any symbol that is a var that wasnt passed in
[12:39:10] <FromDiscord> <Elegantbeef> ehhhh maybe?
[12:39:20] <FromDiscord> <Elegantbeef> Probably not
[12:49:43] <FromDiscord> <Elegantbeef> It's atleast a start https://play.nim-lang.org/#ix=3zjM
[12:54:05] <FromDiscord> <Elegantbeef> Ooh can actually solve that case of "does this sym come from inside here" üòÄ
[13:03:01] <FromDiscord> <Elegantbeef> Getting even fancier https://play.nim-lang.org/#ix=3zjR
[13:04:41] <FromDiscord> <Elegantbeef> @dain\: i now leave it to you to continue my legacy! üòõ
[13:07:36] <FromDiscord> <saem> For the most part you can use the owner and walk up the AST in a loop until you hit an sk module, just check for nil and repeats. The latter meaning generic instantiation
[13:08:01] <FromDiscord> <dain> In reply to @Elegantbeef "<@225449938258100225>\: i now leave": thanks :)
[13:08:33] <FromDiscord> <Elegantbeef> You can get the owner in a macro?
[13:08:48] <FromDiscord> <Elegantbeef> Never knew that
[13:11:28] <FromDiscord> <impbox [ftsf]> what does ownership mean in nim?
[13:11:54] <FromDiscord> <Elegantbeef> In macros?
[13:12:29] <FromDiscord> <Elegantbeef> Assuming yes, it tells you what scope owns the symbol i believe be it a procedure, a block stmt, or a module
[13:12:51] <FromDiscord> <dain> that's cool
[13:13:10] <FromDiscord> <dain> so the macro can look "outside" of itself into where it is being used?
[13:13:39] <FromDiscord> <Elegantbeef> Well typed parameters are semantically checked so you have a ton of information
[13:13:44] <FromDiscord> <impbox [ftsf]> big if true! nice
[13:14:08] <FromDiscord> <Elegantbeef> So if you have a symbol you can check what it's type is as a nimnode and look that up as well
[13:14:33] <FromDiscord> <Elegantbeef> So you can go from a variable to at type declaration doing what you will, tons of introspective capabillities
[13:14:45] <FromDiscord> <Elegantbeef> As much as saem doesnt like macros they do their job well üòõ
[13:16:04] <FromDiscord> <Elegantbeef> The macro cache is also pretty powerful for cross module stuffs, or even cross macro invocation stuff
[13:16:14] <FromDiscord> <saem> They're bad, mmmmkay.
[13:16:48] <FromDiscord> <Elegantbeef> An example of that cross macro invocation stuff https://play.nim-lang.org/#ix=3zdG
[13:17:03] <FromDiscord> <Elegantbeef> Scroll to bottom to see the actual use case
[13:17:33] <FromDiscord> <Elegantbeef> Basically you can set key frames for a specific field then when you call animate with a float it will handle the "animations"
[13:56:49] <FromDiscord> <surajvb> is there a sample snippet to learn about iterating through something equivalent of zipped iterables?
[14:33:06] *** Joins: PersonMcGuy (~PersonMcG@2603-8080-700a-3700-7a17-79e4-1ce4-851e.res6.spectrum.com)
[14:34:19] <PersonMcGuy> Hello, does anyone know the internal structure of a seq? I found a resource showing it once, but I can't seem to find it again. Is it a pointer and a few int fields?
[14:35:44] <PersonMcGuy> Oh, nevermind. I think I just found what I was searching for.
[14:35:47] *** Quits: PersonMcGuy (~PersonMcG@2603-8080-700a-3700-7a17-79e4-1ce4-851e.res6.spectrum.com) (Client Quit)
[14:49:29] *** Joins: Vladar (~Vladar@46.162.2.53)
[14:59:44] <arfy> hi. I just want to check my understanding is correct about the way modules with import and include work. If I have, file A, and I import this into File B, which is, in turn, imported into file C, the public symbols only show up in the scope of file B directly? or do the public symbols go global.
[15:00:14] <arfy> if i used include on the other hand, it would be as if i just copy 'n asted the files together.
[15:08:25] <FromDiscord> <cabboose> Essentially‚Üµ(<@709044657232936960_arfy=5b=49=52=43=5d>)
[15:08:52] <FromDiscord> <cabboose> not unless File B exports the symbols of File C by doing `export c`‚Üµ(<@709044657232936960_arfy=5b=49=52=43=5d>)
[15:09:35] <FromDiscord> <cabboose> often nimble packages top level files are just a list of imports and then exports
[15:10:00] <arfy> nice. 
[15:19:00] *** Quits: max22- (~maxime@2a01cb0883359800da5887c8e8eac50d.ipv6.abo.wanadoo.fr) (Ping timeout: 260 seconds)
[15:21:41] *** Joins: max22- (~maxime@2a01cb08833598008de6b9bad07273d0.ipv6.abo.wanadoo.fr)
[15:48:57] <FromDiscord> <dom96> cabboose: can CPS beat Httpbeast yet? üôÇ
[15:50:10] <FromDiscord> <cabboose> Hahaha looking into combining the queue with continuations and io but I don't have a choice since I have windows ;\_;
[15:52:01] <FromDiscord> <cabboose> I don't think we have anything to compare the queue to in nim though; i don't think it can be as fast as MPSCs but will be an interesting comparison
[15:52:24] <FromDiscord> <dom96> hm, not sure what queues have to do with this
[15:52:53] <FromDiscord> <cabboose> Just in general
[15:53:01] <FromDiscord> <cabboose> I am excited that it's working is all
[15:53:50] <FromDiscord> <cabboose> But as for httpbeast that is yet to be taken to arms! ;)
[15:54:05] <FromDiscord> <cabboose> I assume you had seen the loony queue though
[15:54:16] <FromDiscord> <dom96> what's the blocker?
[15:56:09] <FromDiscord> <cabboose> In reference to challenging you and httpbeast? Because I know nothing about networking and no one else seems to care about making it good for windows but me \:')
[15:56:20] *** Quits: max22- (~maxime@2a01cb08833598008de6b9bad07273d0.ipv6.abo.wanadoo.fr) (Ping timeout: 260 seconds)
[15:56:37] <FromDiscord> <dom96> in terms of making a performant http server
[15:57:08] <FromDiscord> <dom96> I don't think of it as a challenge to me, rather a challenge to other http servers out there. I want to see Nim at the top
[15:59:16] <FromDiscord> <cabboose> Well
[15:59:18] <FromDiscord> <cabboose> the short answer is
[15:59:22] <FromDiscord> <cabboose> I'm learning as I'm going
[15:59:26] <FromDiscord> <cabboose> and I'm a knob at networking things
[15:59:56] <FromDiscord> <cabboose> AFAIK multithreading and async IO is quite a PITA everywhere
[16:01:49] <FromDiscord> <cabboose> Don't ask me too many smart things; I drank a lot last night and my eyes still bleed looking at words on the screen
[16:16:11] <FromDiscord> <Gumber> bleh
[16:16:19] <FromDiscord> <Gumber> last sentence made me glad I barely touch the stuff anymore
[16:16:32] <FromDiscord> <Gumber> and grateful to wake up not hung over üôÇ
[16:17:14] <FromDiscord> <Gumber> sorry - not trying to rub it in lol
[16:17:15] <FromDiscord> <cabboose> It was a 30th and 10 year high school reunion afterwards; I am in pain
[16:17:21] <FromDiscord> <Gumber> ooph
[16:17:42] <FromDiscord> <Gumber> I skipped my ten year but I guess my 20th is coming up in 2?
[16:17:56] <FromDiscord> <Gumber> probs will skip that too - fuck HS lol
[16:18:15] <FromDiscord> <Gumber> In reply to @cabboose "AFAIK multithreading and async": also this is true
[16:18:38] <FromDiscord> <Gumber> well maybe not universally - like async IO is quite not the PITA if you're using green threads with a good scheduler
[16:18:52] <FromDiscord> <Gumber> like it's not a bad situation with Erlang or Golang or Pony, etc...
[16:19:11] <FromDiscord> <Gumber> sharing memory between them becomes triivial
[16:19:15] <FromDiscord> <Gumber> because it doesn't happen
[16:19:43] <FromDiscord> <Gumber> but in the world of concurrency and Nim where you rely on traditional concurrency primitives
[16:19:50] <FromDiscord> <Gumber> the situation is the same as in C or C++ or wherever and it used to be worse
[16:20:16] <FromDiscord> <cabboose> Yeah; they have their own overheads though, golang for instance has a bunch of IO threads waiting to do work
[16:20:19] <FromDiscord> <Gumber> when you had no option BUT to have a separate runtime with its own GC in every shared library you built with nim
[16:20:25] <FromDiscord> <Gumber> oh I'm not saying it's not without cost
[16:20:32] <FromDiscord> <Gumber> or complexity
[16:20:35] <FromDiscord> <cabboose> mmm
[16:20:59] <FromDiscord> <Gumber> but like - typically in those languages you just throw work at a scheduler and don't have to worry about much
[16:21:09] <FromDiscord> <Gumber> I think CPS is making things much better for Nim
[16:21:22] <FromDiscord> <Gumber> but like they're probably worthless for me for a while
[16:21:25] <FromDiscord> <Gumber> because I use the cpp backend
[16:21:34] <FromDiscord> <Gumber> last I checked work hadn't started on that yet
[16:21:40] <FromDiscord> <Gumber> or at least not in earnest
[16:22:09] <FromDiscord> <cabboose> try the MPMC queue; works with any ref object and i'd love to hear how it works on other backends
[16:22:13] <FromDiscord> <Gumber> tis okay though - I'm pretty good at multithreaded programming and fibers
[16:22:19] <FromDiscord> <Gumber> I'll check it out
[16:22:46] <FromDiscord> <Gumber> anyway, back to working on this vulkan renderer
[16:23:14] <FromDiscord> <Gumber> got my render graph library all set up, just need to keep writing this C interface and writing glue code and in maybe another day or two I'll have something drawing to the screen xD
[16:23:44] <FromDiscord> <cabboose> pain
[16:23:48] <FromDiscord> <cabboose> draw pain
[16:23:49] <FromDiscord> <Gumber> oh yeah and I went to bed with this error I couldn't figure out damnit... hopefully it was just because I was falling asleep at the keyboard
[16:23:59] <FromDiscord> <Gumber> yeah - but I've done a lot of 3d work so it's just Vulkan
[16:24:03] <FromDiscord> <Gumber> and all the boilerplate
[16:24:11] <FromDiscord> <Gumber> even with vk-bootstrap it's a pain
[16:24:34] <FromDiscord> <Gumber> but to make matters worse on myself I picked a rendergraph library written in C++ that uses C++20
[16:24:40] <FromDiscord> <Gumber> so I get to wrap it with my own C interface
[16:24:48] <FromDiscord> <Gumber> since Nim can't handle C++20/latest
[16:25:03] <FromDiscord> <cabboose> shit
[16:25:07] <FromDiscord> <cabboose> why even
[16:25:13] <FromDiscord> <Gumber> it's better than writing it myself
[16:25:24] <FromDiscord> <Gumber> it has like eight dependencies, depends on shit like spir-v cross etc
[16:25:32] <FromDiscord> <Gumber> would probably take a couple of months to port
[16:25:47] <FromDiscord> <Gumber> just not worth the time and I'd probably end up having to do the same thing elsewhere eventually
[16:26:11] <FromDiscord> <Gumber> and if you want to write a performant vulkan renderer
[16:26:19] <FromDiscord> <Gumber> you either need to know wtf you're doing (which I don't)
[16:26:34] <FromDiscord> <Gumber> or you need to rely on someone smarter than you who does, and use their shit
[16:26:47] <FromDiscord> <Gumber> or you can pretend you know what you're doing like the author of Godot
[16:26:54] <FromDiscord> <Gumber> (okay I swear, I swear, I'm done xD)
[16:27:23] <FromDiscord> <Gumber> but uh yeah, I picked option B and I'm sticking with it - I can write the renderer I just don't know how to architect / design one to be relatively bottleneck-free
[16:27:50] <FromDiscord> <Gumber> and I don't to spend three years learning how - so I'm just going to use this guy's rendergraph - it seems pretty baller even if he did pick C++20/latest to write it in
[16:27:58] <FromDiscord> <Gumber> they sorry
[16:28:18] <FromDiscord> <Gumber> they didn't pick it for ridiculous reasons either - seems like they wanted to use features of C++20 that are actually useful, like spans
[16:28:30] <FromDiscord> <Gumber> https://github.com/martty/vuk
[16:31:51] <FromDiscord> <haxscramper> Technically nim can handle all of the C++, it is only a matter of how ugly you are willing to go
[16:32:13] <FromDiscord> <haxscramper> But if we speak native support we don't even cover C++11 with variadic templates
[16:32:17] <FromDiscord> <haxscramper> And OOP etc.
[16:33:04] <FromDiscord> <Gumber> well yeah
[16:33:17] <FromDiscord> <Gumber> I could patch the stdlib I guess
[16:33:41] <FromDiscord> <Gumber> but it seemed like less work to just write a C interface
[16:36:02] *** Quits: supakeen (~user@python/site-packages/supakeen) (Quit: WeeChat 3.2.1)
[16:36:31] *** Joins: supakeen (~user@python/site-packages/supakeen)
[16:41:25] <FromDiscord> <dom96> HS reunions, such a US thing
[16:41:58] <FromDiscord> <cabboose> Am aus doe
[16:42:40] <FromDiscord> <Rika> me in asia with grade school reunions:
[17:01:19] <FromDiscord> <Gumber> I don't have much, or really any interest in going to them
[17:01:42] <FromDiscord> <Gumber> two of my best friends I went to HS with but they're literally the only people from  my HS I talk to
[17:02:39] <FromDiscord> <Gumber> might be fun to go back and jone on people but other than that...
[17:03:02] <FromDiscord> <Gumber> Australian HS reunions sound fun to me
[17:03:25] <FromDiscord> <Gumber> but that's just because everything about Australia sounds fun - except all of the wildlife that can kill you
[17:03:47] <FromDiscord> <cabboose> That's the best part though‚Üµ(@Gumber aka Zachary Carter)
[17:03:51] <FromDiscord> <Rika> australia right now is kinda hectic wrt covid though
[17:03:56] <FromDiscord> <cabboose> That's why reunions are so magical
[17:03:57] <FromDiscord> <impbox [ftsf]> i think my HS class had a reunion, but i didn't go, happy to never see those people again
[17:04:01] <FromDiscord> <Gumber> thank goodness I just had it then!
[17:04:44] <FromDiscord> <impbox [ftsf]> @Rika it's the worst it's been here, but it still seems like it's better than a lot of other places in the world wrt covid
[17:05:00] <FromDiscord> <Rika> cabboose can you sell me on cps im still trying to understand
[17:05:05] <FromDiscord> <Gumber> it's bad here - I think maybe it's getting better than it was in August but ???
[17:05:12] <FromDiscord> <Gumber> Rika learn what a continuation is first
[17:05:14] <FromDiscord> <Rika> In reply to @impbox "<@!259277943275126785> it's the worst": oh totally eyes the US
[17:05:20] <FromDiscord> <Gumber> go read about them
[17:05:22] <FromDiscord> <Gumber> in other languages
[17:05:26] <FromDiscord> <Gumber> and then you'll start to get it
[17:05:30] <FromDiscord> <Rika> i know what continuations are
[17:05:32] <FromDiscord> <Gumber> okay
[17:05:38] <FromDiscord> <impbox [ftsf]> I think I get CPS now... It basically takes a normal function and turns it into lots of little functions that chain themselves or something
[17:05:40] <FromDiscord> <Gumber> so CPS is just a compile time transformation
[17:05:43] <FromDiscord> <Rika> ive read the paper so many times
[17:05:46] <FromDiscord> <Rika> yes i know
[17:05:56] <FromDiscord> <Rika> i mean understand[ the benefits]
[17:05:56] <FromDiscord> <Rika> sorry
[17:06:02] <FromDiscord> <Gumber> you want to understand the implementation
[17:06:03] <FromDiscord> <Gumber> I got you
[17:06:08] <FromDiscord> <Rika> god damn it
[17:06:09] <FromDiscord> <Gumber> yeah I dunno that shits over my head
[17:06:14] <FromDiscord> <impbox [ftsf]> magic
[17:06:18] <FromDiscord> <Gumber> exactly
[17:06:23] <FromDiscord> <Gumber> for the birds
[17:06:31] <FromDiscord> <Gumber> I'm just gonna make my programs go brrrrrrrrrr with it
[17:06:39] <FromDiscord> <Gumber> when it works with the cpp backend anyway
[17:07:22] <FromDiscord> <Gumber> I took the fibers from my job system and figured out how to replace them with continuatoins
[17:07:27] <FromDiscord> <Gumber> (edit) "continuatoins" => "continuations"
[17:07:40] <FromDiscord> <Gumber> right before I went on my trip back in June to get married
[17:08:22] <FromDiscord> <Gumber> but I'll have to revisit it later - I don't even know if I'm going to end up using that job system in my game - I'll implement some kind of job system just not sure what yet
[17:08:36] <FromDiscord> <cabboose> Sure I can sell you on it
[17:08:38] <FromDiscord> <Gumber> maybe weave will finally be ready for games and be stable by the time I need one
[17:08:40] <FromDiscord> <cabboose> what do you want to do
[17:08:47] <FromDiscord> <Rika> just regular async
[17:08:51] <FromDiscord> <Gumber> no
[17:08:58] <FromDiscord> <Rika> i dont want to really write my own dispatcher...
[17:09:08] <FromDiscord> <Rika> i just want to see if it's easy perf gain
[17:09:13] <FromDiscord> <cabboose> fair enough
[17:09:19] <FromDiscord> <Rika> if not then ill stay
[17:09:26] <FromDiscord> <Rika> on regular async i mnea
[17:09:27] <FromDiscord> <Rika> mean
[17:09:31] <FromDiscord> <Gumber> oh Rika wants async
[17:09:32] <FromDiscord> <Gumber> gotcha
[17:09:41] <FromDiscord> <cabboose> oh yeah I reckon it definitely is. Do you want multithreaded or single threaded
[17:09:54] <FromDiscord> <Rika> i dont know how to mesh threading with  async yet
[17:10:04] <FromDiscord> <Rika> i would like to know how some day (maybe now)
[17:10:19] *** Joins: arkurious (~arkurious@user/arkurious)
[17:10:20] <FromDiscord> <Rika> wait im fucking shivering for some reason one moment
[17:10:38] <FromDiscord> <Gumber> you have a scheduler running on each thread
[17:10:53] <FromDiscord> <Gumber> and the scheduler schedulers work on each cpu
[17:10:55] <FromDiscord> <dom96> The only benefit I see is perf improvement and ability to decide where to alloc these continuations
[17:11:02] <FromDiscord> <Gumber> or you have a scheduler that schedulers work across them
[17:11:06] <FromDiscord> <Gumber> but each one has an event loop
[17:11:07] <FromDiscord> <dom96> still waiting to see that perf improvement üôÇ
[17:11:15] <FromDiscord> <cabboose> me and zevv are looking at a threadpool implementation
[17:11:20] <FromDiscord> <Gumber> nice
[17:11:22] <FromDiscord> <cabboose> for async multithreading
[17:11:28] <FromDiscord> <Gumber> maybe talk to @mratsim
[17:11:34] <FromDiscord> <Gumber> oh shit he had dnd on, my bad
[17:11:41] <FromDiscord> <Rika> dnd doesnt dispatch notifs
[17:11:42] <FromDiscord> <dom96> In reply to @Rika "i dont know how": You can simply run an async loop in each thread (what httpbeast does)
[17:12:04] <FromDiscord> <Rika> i get that
[17:12:15] <FromDiscord> <Rika> okay
[17:12:18] <FromDiscord> <Gumber> yeah I guess closure iterators vs continuations is the thing right
[17:12:22] <FromDiscord> <Gumber> are they really faster
[17:12:35] <FromDiscord> <Gumber> and I guess the proof will be in the pudding
[17:12:41] <FromDiscord> <Gumber> once someone writes something and does some benchmarking
[17:12:44] <FromDiscord> <Anuke> In reply to @Elegantbeef "Simples it s https://play.nim-lang.org/#ix=3ziM": The amount of optional parameters looks more like this, so adding overloads for every parameter isn't a great option https://media.discordapp.net/attachments/371759389889003532/889129379098132500/unknown.png
[17:13:22] <FromDiscord> <Rika> when i encounter procs with many parameters like that i convert some of them to an object
[17:13:40] <FromDiscord> <Rika> like a "SmthOptions" object
[17:13:47] <FromDiscord> <Gumber> tuples
[17:13:48] <FromDiscord> <Rika> most of the time theyre shared anyway
[17:13:53] <FromDiscord> <Gumber> tuples are great for this
[17:14:24] <FromDiscord> <Gumber> no overhead of object
[17:14:25] <FromDiscord> <Gumber> but anyway
[17:15:10] <FromDiscord> <cabboose> @Rika\: give me a day or two to see if we can iron out a implementation for async continuations that doesn't necessarily use the std dispatcher and i'll get back to you
[17:15:32] <FromDiscord> <cabboose> otherwise with continuations you would still have to run the dispatcher
[17:15:34] <FromDiscord> <Rika> hey wait i didnt mean spend time on smth like that
[17:15:37] <FromDiscord> <cabboose> I usually hide it inbetween me doing different continuations
[17:15:44] <FromDiscord> <cabboose> I'm already doing it though
[17:15:55] <FromDiscord> <Rika> oh if its something you had to do even without me asking then ok
[17:16:01] <FromDiscord> <cabboose> yep
[17:17:59] <FromDiscord> <Gumber> but wait
[17:18:06] <FromDiscord> <Gumber> are continuations going to start being used in the stdlib?
[17:18:20] <FromDiscord> <Gumber> like is that the plan?
[17:18:48] <FromDiscord> <Rika> afaik
[17:18:49] <FromDiscord> <Rika> yes
[17:18:57] <FromDiscord> <dom96> there is no plan
[17:18:58] <FromDiscord> <Gumber> okay so someone convinced Araq
[17:18:59] <FromDiscord> <cabboose> ü§∑‚Äç‚ôÇÔ∏è
[17:19:03] <FromDiscord> <Gumber> oh okay
[17:19:07] <FromDiscord> <cabboose> Nope
[17:19:12] <FromDiscord> <Gumber> there is no plan? that sounds ominous
[17:19:20] <FromDiscord> <Gumber> I hope there's a plan...
[17:19:28] <FromDiscord> <Gumber> a plan for something...
[17:19:31] <FromDiscord> <haxscramper> https://github.com/nim-lang/RFCs/issues/295
[17:19:36] *** Joins: max22- (~maxime@2a01cb08833598004251d0191641dba9.ipv6.abo.wanadoo.fr)
[17:19:37] <FromDiscord> <haxscramper> if you are willinng to dig througgh this
[17:19:41] <FromDiscord> <Gumber> thanks
[17:20:20] <FromDiscord> <dom96> The only plan as far as I know is: help CPS be implemented and see where it goes
[17:20:45] <FromDiscord> <haxscramper> from what I see large problems for CPS is untyped AST being unspecified
[17:20:58] <FromDiscord> <haxscramper> Since there is no spec, and compiler does all sort of weird things
[17:21:03] <FromDiscord> <dom96> but I know that Araq was trying to push for CPS to be implemented in the compiler as well
[17:21:18] <FromDiscord> <haxscramper> I'd rather have speced typed AST
[17:21:34] <FromDiscord> <haxscramper> This will benefit everyone
[17:21:55] <FromDiscord> <cabboose> Mmmm, I reckon if more people used or wanted those types of changes and made their voices known about it then they would have to make progress on it
[17:22:09] <FromDiscord> <cabboose> Haxscramper will start a change.org petition XD
[17:22:27] <FromDiscord> <Rika> and get like 5 signatures
[17:22:42] <FromDiscord> <haxscramper> Well, current opinon is that typed ast is approximately int he middle of the tetrahedron of pain
[17:22:43] <FromDiscord> <dom96> "There are dozens of us".meme.png
[17:22:45] <FromDiscord> <cabboose> that's 5 more than what we have now
[17:22:50] <FromDiscord> <Gumber> dom96: you know of very few people who use threads because Nim's memory model was terrible for threading for the longest time
[17:22:51] <FromDiscord> <haxscramper> generics, types, ast
[17:22:58] <FromDiscord> <Gumber> come on now
[17:23:10] <FromDiscord> <Gumber> for  years were like like - how do we write multithreaded code with Nim
[17:23:13] <FromDiscord> <Gumber> and crickets...
[17:23:14] <FromDiscord> <dom96> hm? what do you mean?
[17:23:32] <FromDiscord> <Gumber> you either had to already know an s ton about computer science and concurrent programming
[17:23:45] <FromDiscord> <Gumber> or you had to be Araq and know about the experimental GC's and how channels etc were implemented
[17:23:58] <FromDiscord> <Gumber> because it was like a bi-weekly topic for a couple of years in this IRC
[17:24:04] <FromDiscord> <Gumber> and then eventually we got arenas
[17:24:09] <FromDiscord> <Gumber> and then we got ARC/ORC
[17:24:17] <FromDiscord> <Gumber> but for the longest time no one touched threads because spawn never worked
[17:24:19] <FromDiscord> <Gumber> parallel never worked
[17:24:22] <FromDiscord> <Gumber> threadpool never worked
[17:24:27] <FromDiscord> <Gumber> every DLL had its own GC
[17:24:32] <FromDiscord> <cabboose> continuations works \:')
[17:24:38] <FromDiscord> <Gumber> Nim's multithreading picture was abhorrent
[17:24:38] <FromDiscord> <cabboose> with loony \:')
[17:24:41] <FromDiscord> <cabboose> \:')
[17:24:54] <FromDiscord> <Gumber> so it's a wonder no one used threads and everyone used async - it was the only realistic option for a lot of people
[17:25:02] <FromDiscord> <Gumber> but IMO threads are better in every way
[17:25:02] <FromDiscord> <dom96> You're implying that I am saying that multithreading was good, but I'm confused where I am saying that
[17:25:07] <FromDiscord> <Gumber> no you're saying it's not good
[17:25:11] <FromDiscord> <Gumber> I'm saying it is
[17:25:21] <FromDiscord> <Gumber> and I use threads all the time
[17:25:30] <FromDiscord> <dom96> threading is a necessity üôÇ
[17:25:36] <FromDiscord> <Rika> well yeah
[17:25:47] <FromDiscord> <cabboose> lets get that petition going
[17:25:57] <FromDiscord> <cabboose> üëÄ
[17:25:58] <FromDiscord> <Rika> you have 6 signatures now how nice
[17:26:03] <FromDiscord> <dom96> but yeah, I've disliked this gc-safety stuff from the beginning
[17:26:12] <FromDiscord> <haxscramper> In reply to @Rika "you have 6 signatures": We can write RFC ...
[17:26:15] <FromDiscord> <dom96> afaik ORC/ARC is meant to solve this
[17:26:21] <FromDiscord> <haxscramper> Well,
[17:26:22] <FromDiscord> <Rika> hax im joking ;;;
[17:26:25] <FromDiscord> <Gumber> no it's not
[17:26:36] <FromDiscord> <Gumber> look sharing memory between threads is not safe at all
[17:26:38] <FromDiscord> <dom96> but then I hear that it isn't actually atomic...
[17:26:40] <FromDiscord> <Gumber> arc and orc dont' fix that
[17:26:45] <FromDiscord> <Gumber> (edit) "dont'" => "don't"
[17:26:53] <FromDiscord> <Gumber> they give you a shared heap
[17:26:58] <FromDiscord> <Gumber> that isn't thread local
[17:27:07] <FromDiscord> <dom96> yeah, and it's playing with pointers again
[17:27:09] <FromDiscord> <Gumber> but you still have to use locks and other concurrency primitives
[17:27:11] <FromDiscord> <dom96> this is what should be fixed
[17:27:22] <FromDiscord> <Gumber> use channels then
[17:27:28] <FromDiscord> <cabboose> whispers about CPS and loony
[17:27:32] <FromDiscord> <Gumber> or CPS and loony
[17:27:35] <FromDiscord> <Rika> cab pls
[17:27:35] <FromDiscord> <Gumber> or just use pointers
[17:27:45] <FromDiscord> <dom96> I don't want to use pointers
[17:27:49] <FromDiscord> <Gumber> ü§∑
[17:27:52] <FromDiscord> <dom96> I want safety
[17:27:59] <FromDiscord> <dom96> there is a reason I don't use C/C++
[17:27:59] <FromDiscord> <Gumber> your requirements are diffefrent from mine
[17:28:10] <FromDiscord> <Gumber> (edit) "diffefrent" => "different"
[17:28:14] <FromDiscord> <dom96> and channels can't be used for everything
[17:28:18] <FromDiscord> <dom96> sometimes I need a shared state
[17:28:29] <FromDiscord> <Rika> eh what why wouldnt channels be ideal for that
[17:28:39] <FromDiscord> <Rika> i mean
[17:28:41] <FromDiscord> <Rika> not ideal
[17:28:42] <FromDiscord> <Rika> usable
[17:29:08] <FromDiscord> <dom96> hm, maybe they would be enough
[17:29:11] <FromDiscord> <Gumber> I never claimed channels weren't cumbersome
[17:29:14] <FromDiscord> <dom96> just trying to think of some common cases
[17:29:21] <FromDiscord> <Gumber> but every abstraction has its cost
[17:29:28] <FromDiscord> <dom96> I guess the most common is wanting to share a db connection between threads
[17:29:39] <FromDiscord> <Gumber> if you care that much about safety
[17:29:45] <FromDiscord> <Rika> wait what why
[17:29:47] <FromDiscord> <dom96> but then you could just have a db connection per thread too lol
[17:29:52] <FromDiscord> <Rika> idk why youd need to share the connection
[17:29:52] <FromDiscord> <Rika> yeah
[17:30:13] <FromDiscord> <Gumber> you're waiting around like everyone else for someone to figure out it üôÇ until then we have threads locks mutexes semaphores conditions and pointers
[17:30:17] <FromDiscord> <Gumber> and now continuations üôÇ
[17:30:21] <FromDiscord> <Gumber> oh and closure iterators
[17:30:34] <FromDiscord> <Gumber> but threads are great
[17:30:59] <FromDiscord> <dom96> I think most programmers just want to go for a shared global variable by default
[17:31:09] <FromDiscord> <Gumber> I've used them 100x more than any stdlib async stuff from Nim in the past year or so
[17:31:16] <FromDiscord> <dom96> but maybe channels/state per thread is the right mindset
[17:31:20] <FromDiscord> <dom96> in that case, we're done lol
[17:31:26] <FromDiscord> <dom96> where is our problem? üòõ
[17:31:46] <FromDiscord> <cabboose> @dom96\: a bit offtopic but do I have to wait for another reviewer to check the nimble pull request for it to be accepted?
[17:32:03] <FromDiscord> <Rika> In reply to @dom96 "I think most programmers": a good middleground is to probably make an abstraction that simulates shared state with channels
[17:32:17] <FromDiscord> <Rika> ofc still comes with a cost
[17:32:52] <FromDiscord> <Gumber> sometimes you have to have a shared state
[17:34:28] <FromDiscord> <Gumber> but regardless, memory safety issues are like the last problem I fight on a regular basis
[17:34:40] <FromDiscord> <dom96> okay, so can you give an example of when a shared state is necessary?
[17:34:42] <FromDiscord> <Gumber> and when I do have to fight them I generally know where they're lurking
[17:35:19] <FromDiscord> <Gumber> sure - let's say you have a main thread that is managing a bunch of worker threads and they're spawning closure iterators or continuations
[17:35:43] <FromDiscord> <Gumber> you need the closure iterator context or fiber stack or whatever on all threads
[17:36:02] <FromDiscord> <Gumber> because you're jumping between them
[17:37:14] <FromDiscord> <Gumber> now you could certainly try to copy and synchronize changes to this shared mutable state but you'd be creating more contention trying to synchronize all of the changes between copies
[17:37:44] <FromDiscord> <Gumber> not to mention, you are already going to be locking and putting threads to sleep while they wait for work
[17:38:11] <FromDiscord> <Gumber> so you already have a very complicated situation with a lot of moving pieces
[17:38:44] <FromDiscord> <Gumber> and you'll most likely just make matters worse if you try to distribute copies of this state and synchronize them
[17:38:58] <FromDiscord> <Gumber> is it possible? sure
[17:39:00] <FromDiscord> <Gumber> is it a good idea? no
[17:39:30] <FromDiscord> <dom96> I see, makes sense. Sounds like a very specialised case though, which makes me think that for vast majority of cases shared state isn't necessary and thus making it hard is fine.
[17:39:48] <FromDiscord> <Gumber> it's pretty much any work stealing / task scheduling job system out there involving threads
[17:40:13] <FromDiscord> <Gumber> like pretty much any thick client application that wants to parallelize work across threads is going to be gunning for something like this
[17:40:18] <FromDiscord> <Gumber> lots of little short lived tasks
[17:40:23] <FromDiscord> <Gumber> that take very little CPU time
[17:40:47] <FromDiscord> <Gumber> games are just one example
[17:41:00] <FromDiscord> <Gumber> and they have some unique requirements just because of their reliance on the GPU
[17:41:16] <FromDiscord> <Gumber> but I don't think it's as uncommon as one might expect in the world of systems programming
[17:41:27] <FromDiscord> <Gumber> there's a really good podcast on this topic by the guys from the machinery if anyone is interested
[17:41:58] <FromDiscord> <Gumber> https://anchor.fm/ourmachinery/episodes/S3-EP2-Fiber-Based-Job-Systems-em88k4
[17:42:05] * arfy waves hi
[17:42:13] <FromDiscord> <Gumber> these guys are fucking awesome - if you're not reading their blog or listening to their podcast you should be
[17:42:22] * arfy randomly notes statement modifiers, as in perl would be nice sometimes.
[17:42:44] <FromDiscord> <Rika> ?
[17:42:51] <FromDiscord> <Gumber> https://ourmachinery.com/post/ blog is here
[17:43:48] <arfy> cart.title = title if title.
[17:44:12] <arfy> in other words, set the title only if the new variable has a value
[17:44:17] <FromDiscord> <Gumber> `cart.title = if title: title else: ""`
[17:44:33] <FromDiscord> <Gumber> (edit) "title:" => "title.len > 0:"
[17:44:42] <arfy> huh wait that works?
[17:44:44] <FromDiscord> <Gumber> yes
[17:44:45] <FromDiscord> <Rika> yes
[17:44:46] <FromDiscord> <Gumber> ternary
[17:44:50] <FromDiscord> <Gumber> equivalent of a ternary
[17:44:59] <FromDiscord> <Rika> if expression technically
[17:45:06] <arfy> right
[17:45:21] <FromDiscord> <Anuke> How would I get the entire AST of a proc that was not passed into a macro?
[17:45:36] <FromDiscord> <Gumber> `dumpAST`
[17:45:39] <FromDiscord> <Gumber> but that's a macro
[17:45:40] <FromDiscord> <Gumber> so....
[17:46:11] <FromDiscord> <Rika> i believe its complicated to get the ast of something outside the macro's scope but i think its possible
[17:46:15] <FromDiscord> <Rika> just a bit hard
[17:46:43] <FromDiscord> <leorize> @Anuke\: if you have the symbol\: getImpl
[17:47:36] <FromDiscord> <Anuke> I have the proc right next to the macro, but I don't have its symbol. Is it possible to look up a symbol?
[17:48:20] <FromDiscord> <Rika> is your macro typed
[17:48:59] <FromDiscord> <leorize> hmm, what exactly are you trying to do?
[17:50:21] <FromDiscord> <Anuke> In reply to @amadan "Workaround I've used before": What I'm trying to do is implement what is mentioned in this comment here. I want a macro that tags varargs[untyped], and calls a proc with optional arguments automatically "filled in". To do this, I want to grab the AST from the proc I want to call, loop through the argument and append them to a `call` if they're not present in the varargs.
[17:50:29] <FromDiscord> <Anuke> (edit) "tags" => "takes"
[17:50:33] <FromDiscord> <Anuke> tags -> takes
[17:50:58] <FromDiscord> <leorize> you need typed
[17:51:15] *** Quits: max22- (~maxime@2a01cb08833598004251d0191641dba9.ipv6.abo.wanadoo.fr) (Ping timeout: 260 seconds)
[17:51:23] <FromDiscord> <leorize> but if you use typed then it can't sem...
[17:51:59] <FromDiscord> <leorize> the other solution is to pass the symbol and the parameters separately
[17:52:14] <FromDiscord> <Anuke> But the last argument is a code block that needs to be further transformed by another macro, I don't think that can be typed
[17:54:45] <FromDiscord> <Anuke> This is getting really complicated, so I think I'll actually use an object for all the optional arguments instead like Rika suggested, at least until a newer nim version is released
[17:54:48] <FromDiscord> <Anuke> thanks anyway
[17:55:26] <FromDiscord> <leorize> how about this\: `call_opt foo(a, b)` -\> `call_opt foo, a, b`
[17:55:39] <FromDiscord> <leorize> type the first argument only
[17:55:58] <FromDiscord> <leorize> so you get the proc symbol, but the rest will be figured out later
[17:56:46] <FromDiscord> <leorize> you will be basically redoing sigmatch so maybe it's not worth it
[18:03:38] *** Joins: max22- (~maxime@2a01cb08833598007f19dd049ca78c46.ipv6.abo.wanadoo.fr)
[18:09:21] <FromDiscord> <mratsim> In reply to @cabboose "me and zevv are": https://github.com/status-im/nim-taskpools this is Weave simplified
[18:09:48] <Zevv> without the casting and the raw pointers?
[18:09:51] <FromDiscord> <mratsim> less than 1000 loc
[18:09:56] <Zevv> because that was a total show stopper for me on weave
[18:12:05] <FromDiscord> <mratsim> mmm you would have to point me to where you saw this on Weave. I remember raw pointers as workaround to Nim limitations and casting for the custom mempool
[18:12:34] <Zevv> I mean the things like `let bufIn = cast[ptr UncheckedArray[float32]](input[0].unsafeAddr)`
[18:39:50] <FromDiscord> <Gumber> I have two C++ functions that return pointers to opaque types
[18:40:20] <FromDiscord> <Gumber> well they return a std:vector of these types, wrapped in result type
[18:40:33] <FromDiscord> <Gumber> the two types are `VkImage` and `VkImageView`
[18:40:54] <FromDiscord> <Gumber> when I call the function that is supposed to return the result vector of `VkImageViews` however
[18:40:58] <FromDiscord> <Gumber> I get a weird error:
[18:41:07] <FromDiscord> <Gumber> sent a code paste, see https://play.nim-lang.org/#ix=3zlq
[18:41:27] <FromDiscord> <Gumber> I looked in the generated C++ code and there are some aliases defined for result<std::vector<VkImage>>
[18:41:39] <FromDiscord> <Gumber> but nothing for `result<std::vector<VkImageView>>>`
[18:41:59] <FromDiscord> <Gumber> sent a code paste, see https://play.nim-lang.org/#ix=3zlt
[18:42:13] <FromDiscord> <Gumber> sent a code paste, see https://play.nim-lang.org/#ix=3zlu
[18:42:25] <FromDiscord> <Gumber> sent a code paste, see https://play.nim-lang.org/#ix=3zlv
[18:42:29] <FromDiscord> <Gumber> `Result[T] {.importcpp: "vkb::detail::Result", header: vkbHeader.} = object`
[18:42:48] <FromDiscord> <Gumber> anyone have any idea?
[18:42:53] <FromDiscord> <Gumber> the C++ type is defined by a macro
[18:43:07] <FromDiscord> <Gumber> sent a code paste, see https://play.nim-lang.org/#ix=
[18:43:15] <FromDiscord> <Gumber> `VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImageView)`
[18:43:32] <FromDiscord> <Gumber> I'm calling `get_images()` right before that line and the codegen seems to be fine with that one
[18:46:27] <FromDiscord> <Gumber> oh and here's the C++ for `get_images` and `get_image_views`
[18:46:48] <FromDiscord> <Gumber> sent a code paste, see https://play.nim-lang.org/#ix=3zlx
[18:47:05] <FromDiscord> <Gumber> (edit) "https://play.nim-lang.org/#ix=3zlx" => "https://play.nim-lang.org/#ix=3zly"
[18:47:44] <FromDiscord> <Gumber> seems to me like it couldn't construct the `std::vector` for some reason
[18:47:57] <FromDiscord> <Gumber> but I have no clue why....
[18:48:10] <FromDiscord> <Gumber> maybe I need to make the alised types for it? I dunno let me try that
[18:50:40] <FromDiscord> <Gumber> nope, no dice
[18:51:25] <FromDiscord> <Gumber> this is making my brain hurt... going to go get coffee
[19:02:38] <FromDiscord> <fae> Is the automatic deref experimental feature popular? I don‚Äôt see it used in many codebases
[19:03:44] <FromDiscord> <fae> Like are there downsides to using it? Does it make code less clear what is a ref and what is not? And if so is that an issue
[19:11:27] <FromDiscord> <leorize> it's not frequently used because not many people use ref afaik
[19:13:48] <FromDiscord> <fae> If you need to do some type of unsafe casting ref/ptr are your only options right? Since their size is the same
[19:13:53] <FromDiscord> <dom96> do you have a link to the docs for this experimental feature?
[19:14:24] <FromDiscord> <fae> https://nim-lang.org/docs/manual_experimental.html#automatic-dereferencing
[19:15:24] <FromDiscord> <leorize> yea, if you want the unsafe stuff
[19:17:21] <FromDiscord> <dom96> the reason you wouldn't use it is because you'd pass the ref to every function
[19:17:32] <FromDiscord> <dom96> it's not typical to have some that take the non-ref and some that take the ref
[19:18:08] <FromDiscord> <fae> So it‚Äôs overall just not a very useful feature
[19:18:19] <FromDiscord> <fae> Or at least, a niche one
[19:19:44] <FromDiscord> <dom96> yep
[19:21:19] <NimEventer> New Nimble package! loony - Lock-free threadsafe MPMC with high throughput, see https://github.com/shayanhabibi/loony
[19:22:50] <FromDiscord> <Gumber> No one has a any ideas for my cpp issue?
[19:23:41] <FromDiscord> <Gumber> @haxscramper  is probably my only hope
[19:25:21] <FromDiscord> <Gumber> Maybe I can just reinterpret cast the result
[19:25:34] <FromDiscord> <Gumber> Doubt it tho
[19:30:48] <FromDiscord> <deech> Are there any compile time procs for getting the current time? `now()` and `getTime()` use `importc`, I can shell out to `date` but thought I'd ask first.
[19:32:45] <FromDiscord> <xflywind> `getTime` can be used with `--experimental:vmopsDanger` at compile time.
[19:36:02] <FromDiscord> <deech> `static: echo getTime()` with that flag gives the error: `Error: cannot evaluate at compile time: localInstance`
[19:36:27] <FromDiscord> <xflywind> devel?
[19:36:54] <FromDiscord> <deech> sent a code paste, see https://play.nim-lang.org/#ix=3zlS
[19:39:12] <NimEventer> New thread by HJarausch: --gc:orc  when is it usable (huge compile times), see https://forum.nim-lang.org/t/8439
[19:41:44] <FromDiscord> <xflywind> In reply to @deech "`static: echo getTime()` with": It may be a bug.
[19:48:31] <FromDiscord> <Yardanico> In reply to @deech "Are there any compile": Yes
[19:48:47] <FromDiscord> <Yardanico> CompileTime and CompileDate, although they're constants
[19:48:55] <FromDiscord> <Yardanico> and represented as strings
[19:50:39] <FromDiscord> <xflywind> this works
[19:50:47] <FromDiscord> <xflywind> sent a code paste, see https://play.nim-lang.org/#ix=3zlU
[19:52:12] <FromDiscord> <deech> That does work! I wonder why `echo getTime()` doesn't.
[19:53:03] <FromDiscord> <xflywind> it call procs uses threadvar variables and `$` is not registered in vmops.
[19:53:26] <FromDiscord> <xflywind> (edit) "call procs" => "calls a proc" | "threadvar" => "`threadvar`" | "uses`threadvar`variables and ... `$`proc" 03added "the" | "uses`threadvar`variables andthe`$` ... is" 03added "proc"
[20:10:23] *** Quits: Gustavo6046 (~Gustavo60@user/gustavo6046) (Quit: ZNC 1.8.2 - https://znc.in)
[20:12:36] <FromDiscord> <dom96> huh, I could have sworn exporting modules was now a thing
[20:13:12] <FromDiscord> <Yardanico> what do you mean? you can export modules by "export module" after importing one, yes
[20:13:15] <FromDiscord> <dom96> oh, I just can't do `export dir / module`
[20:13:19] <FromDiscord> <dom96> I have to do `export module`
[20:13:22] <FromDiscord> <dom96> do we have a bug for this?
[20:13:35] <FromDiscord> <Yardanico> is it really a bug though? export works on a module const name symbol
[20:13:36] <FromDiscord> <Gumber> It's been like that forever
[20:13:39] <FromDiscord> <Gumber> It's not a bug
[20:13:56] <FromDiscord> <Gumber> Forever means five years
[20:13:59] <FromDiscord> <Gumber> At least
[20:14:05] <FromDiscord> <Gumber> Since I joined
[20:14:42] <FromDiscord> <dom96> seems like it's something that should be supported at least
[20:14:48] <FromDiscord> <Gumber> Why
[20:14:56] <FromDiscord> <Gumber> It works as intended
[20:15:05] <FromDiscord> <Gumber> I don't see any benefit
[20:15:30] <FromDiscord> <dom96> if I end up with two modules of the same name then I'll have to rename one
[20:15:33] <FromDiscord> <Gumber> Just adding complexity for the sake of it
[20:15:37] <FromDiscord> <Yardanico> In reply to @dom96 "if I end up": of course
[20:15:40] <FromDiscord> <Yardanico> export is not related to that at all
[20:15:42] <FromDiscord> <Gumber> Yeah
[20:15:46] <FromDiscord> <Yardanico> you have to use "import x as y"
[20:15:48] <FromDiscord> <Gumber> You have to do that anyway
[20:16:02] <FromDiscord> <Gumber> If you want to qualify symbols
[20:16:34] <FromDiscord> <dom96> I suppose
[20:16:37] <FromDiscord> <fae> You want to export without importing first?
[20:16:53] <FromDiscord> <dom96> thinking about `export` taking an identifier rather than a path makes sense
[20:17:04] <FromDiscord> <Gumber> yeah it's like you resolve a path and it gets stored in an alias
[20:17:13] <FromDiscord> <Gumber> which is how the module is referred to in that compilation unit
[20:17:18] <FromDiscord> <Gumber> and then you can also export that symbol if you want
[20:17:35] <FromDiscord> <Gumber> I think the way it is designed is the right way
[20:17:47] <FromDiscord> <Gumber> the only beef I ever have with Nim imports
[20:17:50] <FromDiscord> <dom96> I wonder how easy we could make the error message nicer: "Cannot import dir / module" is far too vague. Should be fairly easy to append "; have you tried `export module`?
[20:17:53] <FromDiscord> <haxscramper> Is that correct?
[20:17:53] <FromDiscord> <haxscramper> sent a code paste, see https://play.nim-lang.org/#ix=3zm6
[20:18:01] <FromDiscord> <Gumber> not exactly hax
[20:18:11] <FromDiscord> <Gumber> well I'm not sure really
[20:18:17] <FromDiscord> <Gumber> because for Vulkan there's the C++ headers and the C headers
[20:18:30] <FromDiscord> <Yardanico> In reply to @dom96 "I wonder how easy": don't really get you there, how is "cannot import dir/module" related to "export module"?
[20:18:38] <FromDiscord> <Gumber> let me grab the C++ headers for the Vkimage and VkImageView one sec
[20:18:43] <FromDiscord> <dom96> er sorry, s/import/export/
[20:18:48] <FromDiscord> <haxscramper> You need to have s simplified model of the API you are trying to interface with, then this can be debugged easier
[20:19:01] <FromDiscord> <Gumber> I tried to make one
[20:19:03] <FromDiscord> <Gumber> but it compiled
[20:19:17] <FromDiscord> <Gumber> okay nevermind
[20:19:21] <FromDiscord> <haxscramper> Bane of all C++ interop
[20:19:22] <FromDiscord> <Gumber> let me share the example I put together
[20:19:24] <FromDiscord> <haxscramper> "it compiled"
[20:19:35] <FromDiscord> <Gumber> maybe it will shine some light
[20:19:36] <FromDiscord> <Gumber> yeah exactly
[20:19:42] <FromDiscord> <Gumber> like I DON'T want it to compile lol
[20:19:43] <FromDiscord> <Gumber> https://play.nim-lang.org/#ix=3zlV
[20:19:44] <FromDiscord> <Gumber> bad compiler!
[20:20:04] <FromDiscord> <Gumber> I tried to make it more concise by omitting  all the `Result` crap
[20:20:07] <FromDiscord> <Gumber> but it compiled too
[20:20:12] <FromDiscord> <Gumber> soo... `Result` is there
[20:20:25] <FromDiscord> <Gumber> also in the real C++ code
[20:20:35] <FromDiscord> <Gumber> Swapchain is split into a header and implementation file
[20:20:42] <FromDiscord> <Gumber> I tried to do that in the `emit` block but it produced errors
[20:20:49] <FromDiscord> <haxscramper> wandbox.org allows to have multiple files in different languages
[20:20:59] <FromDiscord> <haxscramper> just if you find it more convenient
[20:21:00] <FromDiscord> <Gumber> oh shit - will do that next time thanks for the protip
[20:21:30] <FromDiscord> <Yardanico> In reply to @haxscramper "wandbox.org allows to have": it also allows for compilation flags (like --gc:orc) which is very useful too :)
[20:21:40] <FromDiscord> <Gumber> wowwwww this thing is amazing
[20:21:42] <FromDiscord> <haxscramper> also has nimb devel
[20:21:49] <FromDiscord> <haxscramper> though not nim packages
[20:22:04] <FromDiscord> <Gumber> anyway - yeah I can't figure out wtf is going on
[20:22:06] <FromDiscord> <Gumber> or how to fix it
[20:22:17] <FromDiscord> <Gumber> I'm offering money to any one who can lol $15  USD via paypal is the current bounty
[20:22:51] <FromDiscord> <Gumber> and I can put my code up somewhere but as far as getting it to compile - not going to go through that jungle gym with anyone
[20:25:40] <FromDiscord> <haxscramper> I'm looking into it right now
[20:25:50] <FromDiscord> <Gumber> and about your question earlier `VkImage` and `VkImageView` are both defined using that macro `VK_DEFINE_NON_DISPATCHABLE_HANDLE` which on my cpu-arch resolves to `#define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T object;`
[20:25:53] <FromDiscord> <Gumber> sweet - thank you
[20:26:04] <FromDiscord> <haxscramper> I would have to deal with this crap fountain pattern at some point, so I might as well do it right now
[20:26:04] <FromDiscord> <Gumber> so they're just pointers to opaque types
[20:26:19] <FromDiscord> <Gumber> and make $15
[20:26:22] <FromDiscord> <Gumber> in the process
[20:34:33] <federico3> @dom96 any feedback on https://github.com/nim-lang/nimble/issues/921 ? It's been a while.
[20:36:38] <FromDiscord> <dom96> Really not much feedback to give other than that I support implementing it
[20:37:01] <FromDiscord> <haxscramper> https://github.com/nim-lang/RFCs/issues/398
[20:37:10] <FromDiscord> <dom96> but I think it overlaps a lot with https://github.com/nim-lang/nimble/issues/80
[20:37:33] <FromDiscord> <haxscramper> Well, I will at least link it, though digging throught #398 is nearly impossible unless you want to spend quite some time
[20:40:06] <FromDiscord> <haxscramper> @Gumber aka Zachary Carter do you have a full wrappers somewher?
[20:40:23] <FromDiscord> <haxscramper> I will try to mimimize them instead
[20:45:22] <FromDiscord> <Gumber> yeah
[20:45:34] <FromDiscord> <Gumber> well not really
[20:45:35] <FromDiscord> <Gumber> full
[20:45:43] <FromDiscord> <haxscramper> just thing that fails for you
[20:45:52] <FromDiscord> <haxscramper> I need to reproduce your error, nothing more
[20:46:10] <FromDiscord> <Gumber> okay let me upload my code one sec
[20:46:42] <FromDiscord> <Goel> sent a code paste, see https://play.nim-lang.org/#ix=3zmg
[20:46:59] <FromDiscord> <haxscramper> `if rgbaSeq[n] in [alphaA, alphaB]`
[20:47:25] <FromDiscord> <haxscramper> idk about hidden overhead wrt. to intermediate array construction
[20:52:52] <FromDiscord> <Gumber> https://github.com/zacharycarter/FRAG
[20:52:54] <FromDiscord> <Gumber> @haxscramper
[20:53:22] <FromDiscord> <Gumber> I'm on windows and use vcc to compile everything
[20:53:39] <FromDiscord> <Gumber> I don't know if that's an issue or not
[20:54:38] <FromDiscord> <haxscramper> what file I have to compile
[20:55:14] <FromDiscord> <Gumber> frag.nim
[20:55:18] <FromDiscord> <Gumber> you can just do `nimble install -y`
[20:55:33] <FromDiscord> <Gumber> but there's a lot of C++ libraries that need manual compilation atm
[20:55:43] <FromDiscord> <Gumber> I can try to write some commands to compile them
[20:55:59] <FromDiscord> <Gumber> they're all in `thirdparty`
[20:56:43] <FromDiscord> <Gumber> the ones that need building are `vuk` , `glfw` and `shaderc`
[20:57:04] <FromDiscord> <Gumber> they're all linked statically
[20:57:11] <FromDiscord> <Gumber> and I think all three use cmake
[20:57:21] <FromDiscord> <Gumber> `vk-bootstrap` is compiled inside the `vkb.nim` module
[20:57:45] <FromDiscord> <Gumber> `vuk.nim` `vkb.nim` and `glfw.nim` have some pragmas that may need modifying
[20:57:53] <FromDiscord> <haxscramper> Just so you know `  {.error: "platform not supported!".}` is not really informative, writing what platform is actually supported is more user-friently
[20:57:55] <FromDiscord> <Gumber> vulkan SDK also has to be installed on your system and the paths to it have to be correct
[20:57:59] <FromDiscord> <haxscramper> I'm being picky here, but still
[20:58:04] <FromDiscord> <Gumber> this is all just very fast code
[20:58:09] <FromDiscord> <Gumber> it will all be refactored
[20:58:44] <FromDiscord> <Gumber> I'm not intending for anyone to use this really either - not anytime soon anyway - it's more just to remind myself that that section is platform specific
[20:59:41] <FromDiscord> <Gumber> everything needs to be compiled with `/MTd`
[21:00:17] <FromDiscord> <Gumber> I had to go into Visual Studio and right click on the projects that were generated by `vuk`'s `CMakeLists.txt` and adjust them to be so
[21:00:42] <FromDiscord> <haxscramper> I'm not on windows so it looks like I'm going to have some troubles compiling this, at least I can't do this without going over all `compile:` etc. things, which I certainly not be doing. So I will just examine wrappers and try to replicate them
[21:00:52] <FromDiscord> <Gumber> alrighty
[21:01:03] <FromDiscord> <Gumber> yeah that's what I tried with the minimal reproducible example - but maybe you'll have more luck than me
[21:02:43] <FromDiscord> <Gumber> if you walk back from https://github.com/zacharycarter/FRAG/blob/master/src/fragpkg/app.nim#L35-L47
[21:03:20] <FromDiscord> <Gumber> and more specifically - https://github.com/zacharycarter/FRAG/blob/master/src/fragpkg/app.nim#L54
[21:03:33] <FromDiscord> <Gumber> (edit) "https://github.com/zacharycarter/FRAG/blob/master/src/fragpkg/app.nim#L35-L47" => "https://github.com/zacharycarter/FRAG/blob/master/src/fragpkg/app.nim#L35-L60"
[21:03:47] <FromDiscord> <Gumber> that's the line that is problematic in the generated C++
[21:07:09] <FromDiscord> <Ayy Lmao> Is there a way to do something similar to varargs coercion but with a single value? Ideally not using a converter. So sort of like a converter that only works for a specific function.
[21:08:27] <FromDiscord> <haxscramper>  https://media.discordapp.net/attachments/371759389889003532/889188697696788550/unknown.png
[21:09:30] <FromDiscord> <Gumber> lol
[21:09:46] <FromDiscord> <haxscramper> Why in the world each god-damn C++ library feels like I‚Äôm tasked with unearthing some kind of dinosaur and piecing it back together using nothing but a hammer and perforator
[21:09:55] <FromDiscord> <haxscramper> And five megaton nuke
[21:09:57] <FromDiscord> <Gumber> yeah, this is my life
[21:09:59] <FromDiscord> <Gumber> for the past few days
[21:10:26] <FromDiscord> <Gumber> think I started on this nonsense journey on Thursday last week
[21:10:30] <FromDiscord> <haxscramper> Where does `<VkBootstrap.h>` comes from
[21:10:34] <FromDiscord> <haxscramper> Is it auto-generated?
[21:10:38] <FromDiscord> <Gumber> vk-bootstrap in third party
[21:10:50] <FromDiscord> <Gumber> under the src dir
[21:10:51] <FromDiscord> <Gumber> of course
[21:11:19] <FromDiscord> <Gumber> actually
[21:11:25] <FromDiscord> <Gumber> that's probably the sanest library of them all
[21:11:29] <FromDiscord> <Gumber> minus the lack of an include dir
[21:11:39] <FromDiscord> <Gumber> but I mean, not like that's a hard rule or anything
[21:11:52] <FromDiscord> <haxscramper> ah, yes, I got destroyed by git again
[21:11:56] <FromDiscord> <haxscramper> cloned non-recursive
[21:12:02] <FromDiscord> <Gumber> ah yeah my bad should have warned you
[21:12:12] <FromDiscord> <Gumber> also why does C++ just embrace the ever living fuck out of ambiguity?
[21:12:27] <FromDiscord> <Gumber> like I always felt that way about C
[21:12:37] <FromDiscord> <Gumber> but it's just because of the lack of an ABI and the fact it needs to be that way to be portable
[21:12:53] <FromDiscord> <Gumber> C++ has an ABI and isn't portable but it still tries to just give you 10,000 ways to do things
[21:13:26] <FromDiscord> <Gumber> and most of the time only like four of them are really practical / useful
[21:13:39] <FromDiscord> <Gumber> sometimes more choices / options is not better
[21:14:28] <FromDiscord> <haxscramper> Want some `(T1 arg1, T2 arg2, decltype(arg1 + arg2)& result)`
[21:15:05] <FromDiscord> <Gumber>  https://media.discordapp.net/attachments/371759389889003532/889190368053194823/6KXBnnAAlbCsV5A-4d23dS-FrxjNxyO5FGVMKIL_SCk.mp4
[21:16:39] <FromDiscord> <Gumber> In reply to @haxscramper "Want some `(T1 arg1,": I mean that looks like what I need
[21:16:54] *** Joins: Gustavo6046 (~Gustavo60@user/gustavo6046)
[21:17:18] <FromDiscord> <haxscramper> and btw, never, ever use discard when minimizing C++ shit
[21:17:27] <FromDiscord> <haxscramper> assign to some garbage, but not discard
[21:17:33] <FromDiscord> <Gumber> ah okay
[21:17:38] <FromDiscord> <haxscramper> because nim compiler might try to get smart with you
[21:18:34] <FromDiscord> <haxscramper> It is not guaranteed to happen, but just a safety precaution
[21:19:16] <FromDiscord> <Gumber> here we go
[21:19:19] <FromDiscord> <Gumber> https://play.nim-lang.org/#ix=3zmr
[21:19:22] <FromDiscord> <Ayy Lmao> Discard isn't safe on c++ functions?
[21:19:25] <FromDiscord> <Gumber> I think that might b ethe same error
[21:19:29] <FromDiscord> <Gumber> (edit) "b ethe" => "be the"
[21:19:34] <FromDiscord> <Gumber> just from GCC
[21:19:54] <FromDiscord> <Gumber> In reply to @Ayy Lmao "Discard isn't safe on": it's not that - it's just Nim will generate different C++ when you discard vs assign
[21:20:04] <FromDiscord> <Gumber> so when you're trying to track down a Nim cpp codegen issue
[21:20:22] <FromDiscord> <Gumber> discarding the result from a C++ function you've bound to, won't produce the same result as if you assigned the result to some variable
[21:20:31] <FromDiscord> <Gumber> which is why my minimal reproducible example compiled previously
[21:20:41] <FromDiscord> <Gumber> and now that I've fixed it to not discard the results, it isn't compiling anymore
[21:20:46] <FromDiscord> <Gumber> so I guess now I've reproduced it
[21:20:52] <FromDiscord> <Gumber> just on a different compiler toolchain
[21:20:56] <FromDiscord> <Gumber> and cpu arch
[21:21:00] <FromDiscord> <Gumber> sorry OS
[21:21:11] <FromDiscord> <Gumber> I don't know what cpu-arch the playground is running on
[21:22:14] <FromDiscord> <Gumber> but yay that's progress
[21:23:39] *** Joins: stkrdknmibalz (~test@rrcs-75-87-43-226.sw.biz.rr.com)
[21:23:41] <FromDiscord> <Gumber> I'm going to get ready to mow the lawn - will have my phone on me. @haxscramper PM me your paypal account email and I'll shoot you over the $15 USD
[21:23:49] <FromDiscord> <Gumber> You've already provided me with $15 of help anyway
[21:23:57] <FromDiscord> <haxscramper> sent a code paste, see https://play.nim-lang.org/#ix=3zmu
[21:24:29] <FromDiscord> <Gumber> I have so many gd chores to do because I was on the couch for like 11 days straight with COVID
[21:24:44] <FromDiscord> <Gumber> but it feels good to be able to do chores again lol
[21:25:20] <FromDiscord> <haxscramper> Nim should use `--error-format:json` from G++
[21:25:29] <FromDiscord> <Gumber> https://tenor.com/view/chefs-kiss-french-chef-perfect-dish-excellent-food-perfection-gif-20341505
[21:25:39] <FromDiscord> <Gumber> @dom96 really? can we fix gif embeds?
[21:25:42] <FromDiscord> <Gumber> that is lame af
[21:25:48] <FromDiscord> <Rika> no
[21:25:53] <FromDiscord> <Gumber> that's a discord gif embed
[21:25:54] <FromDiscord> <Gumber> not a link
[21:25:57] <FromDiscord> <Rika> image embeds are not separate from website embeds
[21:26:03] <FromDiscord> <Gumber> yo that is terrible
[21:26:09] <FromDiscord> <Gumber> why is discord so bad
[21:26:19] <FromDiscord> <Gumber> it's literally one of the worst pieces of software I've used in a while
[21:26:22] <FromDiscord> <Rika> i mean
[21:26:30] <FromDiscord> <Rika> its w/e
[21:26:33] <FromDiscord> <Rika> you get used to it
[21:26:36] <FromDiscord> <Gumber> no log files, can't differentiate b/w external links and internal ones
[21:26:44] <FromDiscord> <Rika> i dont know any other chat app that distinguishes embeds like that
[21:26:45] <FromDiscord> <Gumber> I don't want my software to make me get used to things
[21:26:49] <FromDiscord> <Gumber> I want it to do the things it should do
[21:26:56] <FromDiscord> <Gumber> I can't imagine it's that difficult
[21:27:01] <FromDiscord> <Rika> "discord gifs" are not internal
[21:27:05] <FromDiscord> <Rika> theyre from tenor
[21:27:05] <FromDiscord> <Gumber> serve them up with some query parameter
[21:27:09] <FromDiscord> <Gumber> okay so proxy them
[21:27:31] <FromDiscord> <Rika> it's "disable link embeds" not "disable external link embeds"
[21:28:54] <FromDiscord> <Rika> w/e
[21:30:55] <FromDiscord> <haxscramper> ahhhffs,
[21:31:02] <FromDiscord> <haxscramper> `Result` is not default constructible
[21:31:46] <FromDiscord> <haxscramper> sent a code paste, see https://play.nim-lang.org/#ix=3zmA
[21:31:49] <FromDiscord> <Gumber> crap...
[21:32:06] <FromDiscord> <Gumber> In reply to @Rika "it's "disable link embeds"": yeah but that's what I want
[21:32:25] <FromDiscord> <Gumber> In reply to @haxscramper "this is not the": yeah the error you quoted is the one I got locally
[21:32:51] <FromDiscord> <haxscramper> sent a code paste, see https://play.nim-lang.org/#ix=3zmB
[21:32:54] <FromDiscord> <haxscramper> `no matching function for call to ‚ÄòResult<std::vector<int> >::Result()‚Äô`
[21:32:59] <FromDiscord> <haxscramper> waiut a sec
[21:33:25] <FromDiscord> <haxscramper> In reply to @Gumber "https://play.nim-lang.org/#ix=3zmr": yes, it is the same one
[21:34:13] <FromDiscord> <haxscramper> I need to explicitly handle non-default-constructible types in hcparse, I forgot about that, again
[21:36:15] <FromDiscord> <Gumber> oh okay
[21:36:44] <FromDiscord> <Gumber> In reply to @haxscramper "I need to explicitly": so does that mean it is indeed a nim codegen bug?
[21:36:51] <FromDiscord> <Gumber> or is it like - I can abuse importcpp or something to make it work?
[21:38:21] <FromDiscord> <haxscramper> No, it means you need to mark `gget_image_views` as `{.constructor.}` and you can't have globals of type `Result`
[21:38:54] <FromDiscord> <haxscramper> Because nim genreates globals as top-level variables, which have to be initialized, but without arguments you can't do this
[21:39:02] <FromDiscord> <haxscramper> works
[21:39:08] <FromDiscord> <haxscramper> sent a code paste, see https://play.nim-lang.org/#ix=3zmD
[21:39:16] <FromDiscord> <haxscramper> sent a code paste, see https://paste.rs/kpa
[21:39:33] <FromDiscord> <haxscramper> sent a code paste, see https://play.nim-lang.org/#ix=3zmF
[21:39:41] <FromDiscord> <Gumber> fml
[21:39:52] <FromDiscord> <Gumber> because a constructor
[21:39:56] <FromDiscord> <Gumber> that's not really a constructor
[21:40:01] <FromDiscord> <Gumber> makes so much sense
[21:40:06] <FromDiscord> <Gumber> I love importcpp
[21:40:19] <FromDiscord> <Gumber> okay thank you for solving this for me - I'm now going to bang my head against the wall for a few minutes
[21:40:22] <FromDiscord> <haxscramper> But this is still not the same error
[21:40:25] <FromDiscord> <Gumber> oh
[21:40:34] <FromDiscord> <haxscramper> Yes, we just came up with new unrelated error
[21:40:38] <FromDiscord> <Gumber> lolol
[21:41:38] <FromDiscord> <haxscramper> sent a code paste, see https://play.nim-lang.org/#ix=3zmG
[21:42:05] <FromDiscord> <haxscramper> sent a code paste, see https://play.nim-lang.org/#ix=3zmH
[21:42:24] <FromDiscord> <Gumber> okay thanks - I'll give this a go
[21:42:27] <FromDiscord> <haxscramper> My guess is that somewhere you mixed types
[21:42:32] <FromDiscord> <Gumber> probably
[21:42:42] <FromDiscord> <haxscramper> so `get_images` is declared as returning T on the nim side
[21:42:50] <FromDiscord> <haxscramper> but in reality it returns Z
[21:43:11] <FromDiscord> <haxscramper> but nim genreates `T temp;` and then does `temp = <>`
[21:44:03] <FromDiscord> <Gumber> yeah
[21:44:22] <FromDiscord> <Gumber> just gotta go through all the layers I guess and figure it out - tried that a few times but to no success
[21:44:29] <FromDiscord> <Gumber> okay thanks - again PM me so I can paypal you lol
[21:44:43] <FromDiscord> <Gumber> going to take a break and work on the lawn, but I'll be back in a bit and try to continue fixing this crap
[22:35:49] *** Quits: neurocyte01 (~neurocyte@user/neurocyte) (Ping timeout: 252 seconds)
[22:54:12] *** Quits: max22- (~maxime@2a01cb08833598007f19dd049ca78c46.ipv6.abo.wanadoo.fr) (Ping timeout: 245 seconds)
[23:02:53] <FromDiscord> <Smarc> sent a code paste, see https://play.nim-lang.org/#ix=3zn5
[23:05:09] <FromDiscord> <Recruit_main707> you need to compile with `--threads:on`
[23:09:30] <FromDiscord> <Smarc> sent a code paste, see https://play.nim-lang.org/#ix=3zn8
[23:10:02] <FromDiscord> <Smarc> nvm, I fucked up
[23:10:46] <FromDiscord> <enthus1ast> @dom96\: can you check if i have crashed the forum?
[23:10:53] <FromDiscord> <enthus1ast> it seems like it
[23:12:43] <FromDiscord> <gerwy> Hi‚Üµis Aporia still good? It seems it wasn't updated in a while and also when i want to build it, it says it cannot import asyncio, which i checked and there is no library like that, maybe it changed the name in the past
[23:12:55] <FromDiscord> <gerwy> i guess it could be `asyncdispatch`
[23:13:15] <FromDiscord> <enthus1ast> or who else has access to server logs \:)
[23:13:15] <FromDiscord> <enthus1ast> i can reproduce this\:
[23:13:16] <FromDiscord> <enthus1ast> image.png https://media.discordapp.net/attachments/371759389889003532/889220111515418644/image.png
[23:14:22] <FromDiscord> <gerwy> i have access to forum normally
[23:14:46] <FromDiscord> <gerwy> (edit) 04removed "normally"
[23:17:38] <FromDiscord> <dom96> In reply to @Gumber "<@!132595483838251008> really? can we": save gif -> reupload and it should work
[23:18:06] <FromDiscord> <dom96> enthus1ast: report it on the issue tracker
[23:18:23] <FromDiscord> <Yardanico> In reply to @Life Sucks "Hi is Aporia still": it haven't been maintained for a long time, so even after you fix all deprecated/removed code (I did a bit of that in my fork around a year ago) a lot of stuff might still not work
[23:18:25] <FromDiscord> <Yardanico> also it relies on gtk2
[23:18:33] <FromDiscord> <dom96> In reply to @Life Sucks "Hi is Aporia still": Aporia is quite old by now
[23:18:40] <FromDiscord> <gerwy> :<
[23:18:47] <FromDiscord> <gerwy> It seemed like a cool project
[23:18:47] <FromDiscord> <enthus1ast> should i report a live crash on the issue tracker? @dom96 ?
[23:19:16] <FromDiscord> <dom96> sure, there are others already there
[23:19:19] <FromDiscord> <dom96> PRs welcome üôÇ
[23:19:56] <FromDiscord> <enthus1ast> ok
[23:20:35] <FromDiscord> <enthus1ast> i mean if someone wants evil to nim project, the forum would be down all the time ;)
[23:21:31] <FromDiscord> <dom96> yeah, maybe
[23:22:03] <FromDiscord> <dom96> I'd probably just configure nginx to disallow those requests
[23:23:00] <FromDiscord> <enthus1ast> in my case its nothing special, i even don't know exactly if i crash it
[23:23:10] <FromDiscord> <enthus1ast> it seems like
[23:23:25] <FromDiscord> <enthus1ast> maybe you can see it in the server logs
[23:23:39] <FromDiscord> <enthus1ast> if it was restarted by systemd?
[23:24:11] <FromDiscord> <dom96> I can but not right now
[23:24:32] <FromDiscord> <enthus1ast> ok
[23:28:10] <FromDiscord> <Smarc> sent a code paste, see https://play.nim-lang.org/#ix=3znh
[23:28:34] *** Joins: max22- (~maxime@2a01cb088335980099348db52b55749a.ipv6.abo.wanadoo.fr)
[23:29:22] <FromDiscord> <Yardanico> that library are you using for sounds?
[23:29:30] <FromDiscord> <Smarc> slappy
[23:29:46] <FromDiscord> <Yardanico> but generally the error is because you're using a global variable in another thread, and nim with the default GC (refc) has thread-local heap
[23:29:58] <FromDiscord> <Yardanico> In reply to @Smarc "slappy": does it actually support threading?
[23:30:53] <FromDiscord> <Smarc> Hm it doesn't mention it in the readme, so I don't really know..
[23:31:24] <FromDiscord> <dom96> Try to avoid globals if possible
[23:32:39] <FromDiscord> <Smarc> sent a code paste, see https://play.nim-lang.org/#ix=3znk
[23:32:45] <FromDiscord> <Smarc> So I guess slappy is not suited for threading? Is is there some way around?
[23:33:37] <FromDiscord> <Yardanico> try using --gc:orc and wrap the code that errors with a {.cast(gcsafe).} block
[23:33:52] <FromDiscord> <Yardanico> sent a code paste, see https://play.nim-lang.org/#ix=3znl
[23:34:24] <FromDiscord> <Yardanico> see https://nim-lang.org/docs/manual.html#threads-gc-safety
[23:34:53] <FromDiscord> <Smarc> same result unfortunately
[23:36:47] <FromDiscord> <Yardanico> can you show the code?
[23:37:30] <FromDiscord> <enthus1ast> @Smarc  maybe give the thread the path to the audio file to play
[23:37:39] <FromDiscord> <Smarc> sent a code paste, see https://play.nim-lang.org/#ix=3znm
[23:37:40] <FromDiscord> <Yardanico> nonono
[23:37:47] <FromDiscord> <Yardanico> you should put the cast inside the proc
[23:38:00] <FromDiscord> <Smarc> oh
[23:38:06] <FromDiscord> <Yardanico> and compile with --gc:orc
[23:39:26] <FromDiscord> <Smarc> It compiles and runs! Thank you for your help guys :)
[23:39:43] <FromDiscord> <Yardanico> just be careful, if you use same global variables from different threads at the same time you need locks
[23:40:01] <FromDiscord> <Smarc> Although the random offset does not really work out, since the file are a bunch of clicking-sounds and sometimes it (obviously) just plays the ending noise
[23:40:13] <FromDiscord> <Smarc> But I did not find a better way to work with an ogg file
[23:40:18] <FromDiscord> <dom96> ORC still isn't gc-safe, right?
[23:40:27] <FromDiscord> <Yardanico> In reply to @dom96 "ORC still isn't gc-safe,": it depends on what you mean by that
[23:40:36] <FromDiscord> <dom96> I'm wondering whether it's safe to do that cast
[23:40:38] <FromDiscord> <Yardanico> current gcsafe analysis is incorrect for gc:orc as you can use global variables in different threads, you just need locking
[23:40:39] <FromDiscord> <dom96> with ORC
[23:40:55] <FromDiscord> <Yardanico> to not read/write same variable from different threads at the same time
[23:41:01] <FromDiscord> <Yardanico> arc/orc have a shared heap
[23:41:05] <FromDiscord> <dom96> afaik you still cannot because allocs/deallocs aren't atomic
[23:41:14] <FromDiscord> <Yardanico> wdym?
[23:41:18] <FromDiscord> <Yardanico> it's a shared heap
[23:41:29] <FromDiscord> <dom96> you still need to use alloc0 etc. for shared heap
[23:41:33] <FromDiscord> <Yardanico> no
[23:41:35] <FromDiscord> <dom96> (edit) "alloc0" => "allocShared"
[23:41:43] <FromDiscord> <Yardanico> arc/orc with --threads:on use a shared heap by default
[23:41:54] <FromDiscord> <dom96> do you have any sources/docs for this?
[23:42:35] <FromDiscord> <Yardanico> https://nim-lang.org/docs/gc.html
[23:43:05] <FromDiscord> <Yardanico> it has been thoroughly discussed before in forum threads, and it's one of the advantages of arc/orc over refc
[23:43:30] <FromDiscord> <Yardanico> https://forum.nim-lang.org/t/6549
[23:43:35] <FromDiscord> <Yardanico> "Offers a shared heap. Enabled via --threads:on."
[23:44:33] <FromDiscord> <dom96> right, and then there is: https://forum.nim-lang.org/t/6549#43004
[23:45:10] <FromDiscord> <Yardanico> yes, so as I said you need to use locks
[23:45:15] <FromDiscord> <Yardanico> if you access the same variable from multiple threads
[23:45:28] <FromDiscord> <Yardanico> or atomics of course
[23:45:37] <FromDiscord> <dom96> what if Nim decrements the ref count outside my lock?
[23:47:11] <FromDiscord> <dom96> also I discussed this earlier today which gave me the message that this isn't safe https://irclogs.nim-lang.org/19-09-2021.html#12:56:36
[23:47:29] <FromDiscord> <dom96> CC @Gumber aka Zachary Carter
[23:47:36] <FromDiscord> <Yardanico> "but you still have to use locks and other concurrency primitives"
[23:47:40] <FromDiscord> <Yardanico> as I said, you have to use locks
[23:47:57] <FromDiscord> <Gumber> I mean by nature it's unsafe
[23:48:08] <FromDiscord> <Gumber> you can never be certain about what is reading or writing to that memory
[23:48:17] <FromDiscord> <Gumber> unless you use concurrency primitives to synchronize those actions
[23:48:35] <FromDiscord> <Gumber> you also can't be certain about the order in which code will execute in critical sections a lot of time
[23:48:53] <FromDiscord> <Gumber> so yeah - sharing memory between threads without thinking about these things will almost always result in data races or dead locks
[23:49:05] <FromDiscord> <Gumber> and just slapping on locks isn't going to help unless you understand what you're doing
[23:49:20] <FromDiscord> <Gumber> you need to understand how system threads behave and how they're implemented to some degree along with schedulers
[23:49:23] <FromDiscord> <Gumber> on the OS
[23:49:33] <FromDiscord> <Gumber> and you need to understand about thread contention etc...
[23:49:56] <FromDiscord> <Gumber> so there's a lot to learn - I don't know half of it but you have to start somewhere if you want to eventually understand everything about the topic
[23:53:27] <FromDiscord> <dom96> we need an article about this
[23:53:40] <FromDiscord> <dom96> and possibly a change to Nim so that it gives clearer warnings
[23:53:52] <FromDiscord> <Gumber> it's not a specific Nim thing
[23:53:53] <FromDiscord> <Gumber> though
[23:54:01] <FromDiscord> <dom96> Like: "This is unsafe under --gc:default, but is fine under --gc:orc"
[23:54:03] <FromDiscord> <Gumber> it's any language that has the capability to schedule system threads on the OS
[23:54:16] <FromDiscord> <Gumber> sharing memory between threads isn't safe on the default gc either
[23:54:17] <FromDiscord> <dom96> yes, but I only worry about this gc safety concept
[23:54:19] <FromDiscord> <Gumber> only if you use channels
[23:54:22] <FromDiscord> <dom96> which most other languages don't have
[23:54:33] <FromDiscord> <Gumber> on the default gc every thread has its own local heap
[23:56:11] <FromDiscord> <Gumber> so you allocate memory on the thread heap
[23:56:27] <FromDiscord> <Gumber> and then if you want another thread to be able to use it you have to pass it to that thread as a pointer or through a channel
[23:56:51] <FromDiscord> <Gumber> and it will be copied if it goes through a channel
[23:57:08] <FromDiscord> <Gumber> so if you don't pass a ref or a pointer through the channel
[23:57:14] <FromDiscord> <Gumber> it will pass a copy of whatever is in memory there
[23:57:18] <FromDiscord> <Gumber> now...
[23:57:40] <FromDiscord> <Gumber> the GC knows the ref count on the object went up but it isnt' aware it crossed thread boundaries
[23:57:56] <FromDiscord> <Gumber> so you need to think about how that could cause issues
[23:58:08] <FromDiscord> <Gumber> another thing is - if you have let's say a separate Nim process that you're loading symbols from
[23:58:18] <FromDiscord> <Gumber> let's say you compile your Nim code to a shared library (dll on windows) (so on linux)
[23:58:36] <FromDiscord> <Gumber> and you're `dlopen` `dlclose` ing symbols from that library
[23:58:42] <FromDiscord> <Gumber> like you might do in let's say a plugin architecture
[23:58:53] <FromDiscord> <Gumber> each Nim process is going to have it's own runtime and own GC
[23:58:59] <FromDiscord> <Gumber> and they're not going to be aware of one another
[23:59:12] <FromDiscord> <dom96> okay, I think I see it more clearly now
[23:59:15] <FromDiscord> <Gumber> so you could have them stomping on eachother and collecding memory from eachother
[23:59:27] <FromDiscord> <Gumber> to mitigate this - Nim had this flag like `-d:useNimRealtimeRTL` or something
[23:59:39] <FromDiscord> <Gumber> and it would prevent this situation from happening - but then half the stdlib wouldn't work
[23:59:49] <FromDiscord> <Gumber> so yeah - this is the problem summarized as concisely as I can
[23:59:52] <FromDiscord> <dom96> so I think still, with arc/orc you need to be careful. It all depends where Nim adds code to inc/dev ref count
[23:59:54] <FromDiscord> <dom96> (edit) "inc/dev" => "inc/dec"
