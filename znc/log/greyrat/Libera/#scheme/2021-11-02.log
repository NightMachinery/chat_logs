[00:22:28] *** Joins: rgherdt (~rgherdt@2a02:8109:86c0:d8d:c0fd:cce1:aeae:bfb0)
[00:27:10] *** Joins: Nselm (~Nselm@p200300d56f1ca8e8405dc66eb7cff6d9.dip0.t-ipconnect.de)
[01:24:42] *** Quits: Nselm (~Nselm@p200300d56f1ca8e8405dc66eb7cff6d9.dip0.t-ipconnect.de) (Quit: Client closed)
[01:33:09] *** Quits: gproto23 (~gproto23@user/gproto23) (Remote host closed the connection)
[01:43:51] <saltrocklamp[m]> https://github.com/gwerbin/idris2-float-utils/blob/main/support/chez/float-utils.ss#L1 is there some elegant way to implement unbool as a single macro, like `(unbool 2 my-func)`? in common lisp i would either have a cond that just returns each version, or something that manually generates a function body with a manually-consed-together parameter list
[01:45:24] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[01:52:35] *** Quits: rgherdt (~rgherdt@2a02:8109:86c0:d8d:c0fd:cce1:aeae:bfb0) (Ping timeout: 268 seconds)
[02:00:02] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Ping timeout: 260 seconds)
[02:17:15] *** Quits: Inline (~Inline@2a02:908:1252:7a80:86ce:9852:a68c:aeee) (Ping timeout: 268 seconds)
[02:23:15] *** Joins: taiju (~taiju@240b:253:ec40:2400:2cdc:1f32:d88a:fa10)
[02:25:02] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[03:07:16] *** Joins: s-liao (~s-liao@101.86.103.113)
[03:10:32] <gwatt> saltrocklamp[m]: you could pass the desired argument list in instead of the argument count.
[03:11:19] <gwatt> That would would something like (syntax-rules () [(unbool arg-list func) (lambda arg-list (if (func . arglist) 1 0))])
[03:16:39] *** Quits: evdubs (~evdubs@cpe-66-8-236-219.hawaii.res.rr.com) (Read error: Connection reset by peer)
[03:17:16] *** Joins: evdubs (~evdubs@cpe-66-8-236-219.hawaii.res.rr.com)
[03:25:24] *** Joins: X-Scale` (~ARM@46.50.2.72)
[03:26:22] *** Quits: X-Scale (~ARM@92.250.98.212) (Ping timeout: 260 seconds)
[03:26:47] *** X-Scale` is now known as X-Scale
[03:28:09] *** Quits: taiju (~taiju@240b:253:ec40:2400:2cdc:1f32:d88a:fa10) (Ping timeout: 268 seconds)
[03:38:34] <saltrocklamp[m]> huh, interesting! so you'd write `(unbool (x y z) foo)`?
[03:54:05] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[03:58:29] *** Parts: pranavats (3fba1d1b34@jabberfr.org) ()
[03:59:05] *** Joins: cross (~cross@spitfire.i.gajendra.net)
[03:59:45] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Quit: ec)
[04:14:58] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[04:31:41] *** Quits: bandali (~bandali@jir.shemshak.org) (Changing host)
[04:31:41] *** Joins: bandali (~bandali@gnu/bandali)
[04:43:29] *** Joins: grace (~grace@192.54.222.148)
[05:14:12] *** Quits: seninha (~seninha@user/seninha) (Quit: Leaving)
[05:16:06] *** Quits: elderK (uid205007@id-205007.helmsley.irccloud.com) (Quit: Connection closed for inactivity)
[05:17:14] *** Joins: seninha (~seninha@user/seninha)
[05:19:53] *** Joins: elderK (uid205007@id-205007.helmsley.irccloud.com)
[06:05:30] *** Quits: ahlk (~user@2600:1700:31c0:3a10::43) (Read error: Connection reset by peer)
[06:05:49] *** Joins: ahlk (~user@2600:1700:31c0:3a10::43)
[06:08:38] *** Quits: seninha (~seninha@user/seninha) (Quit: Leaving)
[06:39:21] *** Joins: apg (~apg@97-120-5-215.ptld.qwest.net)
[06:40:02] *** Quits: clacke (88d96f2df3@knopi.disroot.org) (Ping timeout: 260 seconds)
[07:14:20] *** Quits: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net) (Remote host closed the connection)
[07:18:47] *** Joins: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net)
[07:20:24] *** Quits: s-liao (~s-liao@101.86.103.113) (Quit: Client closed)
[08:02:18] *** Quits: grace (~grace@192.54.222.148) (Ping timeout: 256 seconds)
[09:04:28] *** Joins: poselyqualityles (~poselyqua@user/poselyqualityles)
[09:16:54] *** Quits: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net) (Ping timeout: 260 seconds)
[09:39:12] *** Quits: hendursaga (~weechat@user/hendursaga) (Remote host closed the connection)
[09:39:53] *** Joins: hendursaga (~weechat@user/hendursaga)
[09:54:50] *** Joins: gproto23 (~gproto23@user/gproto23)
[10:08:34] *** Joins: rgherdt (~rgherdt@ip5f5af428.dynamic.kabel-deutschland.de)
[10:18:11] *** Quits: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de) (Quit: Leaving)
[10:25:53] *** Joins: lockywolf (~lockywolf@vultr-seoul-openbsd.lockywolf.net)
[10:43:12] *** Quits: skapata (~Skapata@user/skapata) (Remote host closed the connection)
[10:44:23] <mdhughes> > (define-syntax unbool (syntax-rules () [(_ p? v ...)  (if (p? v ...) 1 0)] ))
[10:44:23] <mdhughes> > (unbool string? "")
[10:44:23] <mdhughes> 1
[10:45:27] <mdhughes> What I actually use that style for is (define-syntax ¬ (syntax-rules () [(_ p? v ...)  (not (p? v ...))] ))
[10:45:43] <mdhughes> So I can just negate any test with an extra ¬ at the front.
[10:46:17] *** Quits: klovett (~klovett@mobile-166-170-40-35.mycingular.net) (Quit: ZZZzzz…)
[10:46:40] *** Joins: klovett (~klovett@mobile-166-170-40-35.mycingular.net)
[10:46:45] *** Quits: klovett (~klovett@mobile-166-170-40-35.mycingular.net) (Client Quit)
[11:04:45] *** Joins: s-liao (~s-liao@101.86.103.113)
[11:11:27] *** Joins: hexteex (~hexteex@gateway/tor-sasl/hexteex)
[11:11:39] *** Joins: jzdun (~jzdun@188.146.15.90.nat.umts.dynamic.t-mobile.pl)
[11:11:48] *** Quits: jzdun (~jzdun@188.146.15.90.nat.umts.dynamic.t-mobile.pl) (Client Quit)
[11:18:51] *** Quits: kopiyka (~user@2001:983:fe8b:1:b26e:bfff:fe2b:503f) (Remote host closed the connection)
[11:35:19] *** Joins: hendursa1 (~weechat@user/hendursaga)
[11:35:19] *** Quits: poselyqualityles (~poselyqua@user/poselyqualityles) (Ping timeout: 268 seconds)
[11:38:51] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[11:55:29] *** Quits: madage (~madage@user/madage) (Remote host closed the connection)
[12:03:55] *** Joins: madage (~madage@user/madage)
[12:04:41] *** Quits: pony (uid524992@smol/hors) ()
[12:04:55] *** Joins: pony (sid524992@smol/hors)
[12:15:29] *** Joins: hexteetx (~hexteex@gateway/tor-sasl/hexteex)
[12:18:30] *** Quits: hexteex (~hexteex@gateway/tor-sasl/hexteex) (Ping timeout: 276 seconds)
[12:20:51] *** Quits: hexteetx (~hexteex@gateway/tor-sasl/hexteex) (Quit: Leaving)
[12:27:49] *** Joins: hexteex (~hexteex@gateway/tor-sasl/hexteex)
[12:56:05] <dpk> what's the current state of the argument on whether define-record-type field names are identifiers or symbols?
[13:31:59] <dpk> SRFI 99 seems to imply strongly they're the latter
[13:32:49] <dpk> but i recall a (probably later?) SRFI explicitly asserting the opposite, which of course i now can't find
[13:43:13] <dpk> ah, the Clinger and Wand paper on hygienic macros summarizes (pp. 72–4, https://dl.acm.org/doi/pdf/10.1145/3386330)
[13:43:26] *** Quits: s-liao (~s-liao@101.86.103.113) (Ping timeout: 256 seconds)
[13:46:39] <dpk> okay, the later SRFI was 150 and confirms (well, matches) my reading of 99: "it is clear from the relationship with the accompanying procedural interface that field names have to be unhygienic"
[13:50:51] <dpk> the non-normative section of SRFI 150 has several points that don't seem to make sense
[13:51:31] <amazigh> Are field names available in the environment where they are used at runtime? I was under the impression, that field names and the record type were dealt with the same way, but I do not remember exactly how. (IIRC SRFI-9 prescribed that record type are not reified at runtime)
[13:51:56] <dpk> mainly the first point of each section: you can't pass an identifier procedurally in standard Scheme. unless it means you pass a syntax-case object which is an `identifier?` …
[13:53:37] <dpk> but it also doesn't say how the procedural layer actually matches/compares field names
[13:54:14] <dpk> amazigh: no, i don't think so. i was wondering that myself, but no spec says they get bound to anything. they're identifiers in the sense of symbol + mark, but they have no bindings
[13:54:36] <amazigh> I remember different behavior between guile and chez regarding procedural layer
[13:55:21] <amazigh> if fields are only symbols at runtime, are the fields ordered somehow?
[13:55:40] <amazigh> s/at runtime/in the procedural layer/
[13:56:24] <dpk> presumably, if a field name is an identifier in the sense of syntax-case, they match if they're bound-identifier=?, and if they're anything else they match if they're … `eqv?`, maybe? or `equal?`?
[13:56:55] <dpk> i also don't know what 'keyword' means in the non-normative section. presumably *not* a keyword in the SRFI 88 sense
[13:57:35] <amazigh> FWIW, python's asyncpg allows both access to record fields by index and string, which is a good use case for procedural records (ref: https://magicstack.github.io/asyncpg/current/api/index.html#record-objects)
[13:58:08] <dpk> also, what does rtd-field-names from the inspection layer return when called on a syntactically-defined RTD? *crickets*
[13:58:50] <dpk> presumably … identifiers. whatever they are in procedure-call land. (syntax objects remains my best guess)
[14:00:09] <amazigh> SRFI-999 ftw ;)
[14:00:47] <dpk> oh! it does say: "In addition, field names may also be other types of Scheme datums, like numbers and strings, or SRFI 88 keyword objects."
[14:06:17] <mdhughes> R6RS-lib 6.4 makes it clear those are returned as symbols. Lesser specs, who knows.
[14:06:29] *** Joins: s-liao (~s-liao@101.86.103.113)
[14:07:26] <dpk> we can ignore R6RS — its record system is incompatible with everything else, including itself
[14:07:28] <mdhughes> And fields are definitely ordered, that's how the rtd- functions interact with them.
[14:07:58] <mdhughes> R6 record system actually works, and provides useful features. Unlike any of the other half-assed SRFIs.
[14:08:02] <dpk> R7RS deliberately made field names identifiers, not symbols, according to foof, although this has caused consternation
[14:08:35] <mdhughes> Of course it did, why not make everything awful for the incompetent impls?
[14:11:04] <mdhughes> I use records all over, and the difference between them in Chez or CHICKEN is just shameful. I have some little scripts that generate all the boilerplate for bad Schemes, because I can't be arsed to type that out myself, and it still only gets them halfway usable.
[14:11:43] <mdhughes> Of course bad schemes don't have a macro system powerful enough to fix their broken bits, which is why they're in that state to begin with.
[14:15:01] <dpk> you are the one who brought R6RS up. i tried to explain, admittedly not very well, why that is not relevant to my question, which is about a debate in the development of R7RS. if you want to shit on everyone else's work, please do it quietly
[14:15:42] <mdhughes> Well, it is relevant in that there's a working, good example. You just have to delete everything that's been done on R7 and switch back to R6.
[14:16:01] <mdhughes> Seriously, if Chez didn
[14:16:21] <mdhughes> didn't exist, I'd have to live in sin^W^W^W use Common Lisp, since at least their shit also works.
[14:32:57] <amazigh> please.
[14:33:45] <amazigh> bad schemes is not the word, I guess they have other priorities.
[14:34:31] <amazigh> afaiu procedural records were much debated (for some reasons I do not completly understand), hence there is roots for misunderstanding the spec.
[14:34:40] <amazigh> and I think chicken is not R6RS.
[14:40:27] <mdhughes> It is definitely not, that was an English XOR.
[14:40:52] <mdhughes> There are eggs to make better records or macros in CHICKEN, but I think they were all C4, not sure if any have been brought up to C5.
[14:42:13] <mdhughes> Gambit's even worse than SRFI-9, but Gerbil's got a fantastic record/class system… but it's so poorly documented it's hard to use.
[14:42:40] <wasamasa> if you want any help with porting them, I'm there
[14:42:53] <wasamasa> but I don't get any constructive discussion vibes from you so far
[14:44:00] <mdhughes> "You just have to delete everything that's been done on R7 and switch back to R6." is pretty constructive! :)
[14:44:55] <wasamasa> that's more venting
[14:46:47] *** Joins: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de)
[14:47:43] <mdhughes> SRFI-99 ought to be a bare minimum level for any other Scheme. It's a little snarky to its superior predecessor, but they got most of the functionality.
[14:48:37] <mdhughes> BUT, it loses the ability to construct method names with mutable/immutable flags, again because of a lack of good macro systems.
[14:49:21] <wasamasa> let me guess, good macro system means syntax-case
[14:50:01] <mdhughes> Preferably, but whatever lets you write *anything* as output, hygiene be damned.
[14:50:47] <mdhughes> The point of a macro is you transform DATA->ANY CODE, not DATA(with only the exposed names)->SOME SUBSET OF CODE
[14:51:25] <wasamasa> would ER/IR work for that?
[14:52:25] <mdhughes> Admittedly I haven't built anything with ER. I'm Captain Caveman, high-tech savage of the 20th C.
[14:59:49] *** Quits: s-liao (~s-liao@101.86.103.113) (Quit: Client closed)
[15:00:11] *** Joins: s-liao (~s-liao@101.86.103.113)
[15:01:22] *** Joins: klovett (~klovett@mobile-166-170-40-35.mycingular.net)
[15:09:58] *** Quits: s-liao (~s-liao@101.86.103.113) (Quit: Client closed)
[15:10:14] *** Joins: s-liao (~s-liao@101.86.103.113)
[15:46:46] *** Quits: gproto23 (~gproto23@user/gproto23) (Remote host closed the connection)
[16:09:26] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 260 seconds)
[16:11:14] *** Joins: aeth (~aeth@user/aeth)
[16:29:07] *** Parts: pranavats (3fba1d1b34@jabberfr.org) ()
[16:40:00] *** Joins: ManDay (~manday@user/manday)
[16:45:56] *** Joins: wnklmnn (~wnklmnn@2a02:908:4e2:9740:1b4b:eac0:c8c1:453c)
[16:46:31] *** Joins: seninha (~seninha@user/seninha)
[17:05:51] *** Quits: ManDay (~manday@user/manday) (Ping timeout: 268 seconds)
[17:19:23] *** Joins: ManDay (~manday@user/manday)
[17:36:03] *** Joins: kopiyka (~user@2001:983:fe8b:1:b26e:bfff:fe2b:503f)
[17:43:02] *** Quits: ManDay (~manday@user/manday) (Quit: TURBOquit (tm) - the fastest way to get out of an awkward situation)
[17:46:05] <Zipheir> syntax-case looks like a winner in R7RS-large Yellow, from what I saw of the (early) results.
[17:46:26] *** Quits: s-liao (~s-liao@101.86.103.113) (Quit: Client closed)
[17:47:02] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[17:50:03] *** Joins: s-liao (~s-liao@101.86.103.113)
[17:50:25] *** Quits: hendursa1 (~weechat@user/hendursaga) (Quit: hendursa1)
[17:50:49] *** Joins: hendursaga (~weechat@user/hendursaga)
[17:56:03] *** Joins: robin_ (~robin@user/terpri)
[17:57:25] *** Joins: robin__ (~robin@user/terpri)
[17:57:52] *** Quits: robin (~robin@user/terpri) (Killed (NickServ (GHOST command used by robin__)))
[17:57:56] *** robin__ is now known as robin
[18:01:35] *** Quits: robin_ (~robin@user/terpri) (Ping timeout: 264 seconds)
[18:08:32] *** Quits: s-liao (~s-liao@101.86.103.113) (Quit: Client closed)
[18:12:10] *** Joins: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net)
[18:12:28] *** Joins: skapata (~Skapata@2804:14c:87b0:a6f9:e8c0:35dd:3893:129a)
[18:12:28] *** Quits: skapata (~Skapata@2804:14c:87b0:a6f9:e8c0:35dd:3893:129a) (Changing host)
[18:12:28] *** Joins: skapata (~Skapata@user/skapata)
[18:20:59] *** Quits: madage (~madage@user/madage) (Remote host closed the connection)
[18:21:21] *** Joins: madage (~madage@user/madage)
[18:29:46] *** Quits: hexteex (~hexteex@gateway/tor-sasl/hexteex) (Quit: Leaving)
[18:30:38] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[18:50:39] *** Quits: theruran (uid11305@hampstead.irccloud.com) (Quit: Connection closed for inactivity)
[18:58:00] *** Joins: Avichi (~Avichi@250-150-159-217.sta.estpak.ee)
[18:58:54] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[19:01:29] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[19:15:42] <amazigh> Today convo on chicken mailinglist (about nng / zeromq), reminded me how #scheme is not very *tribal*
[19:16:51] <amazigh> Another instance of that is the tribute of John Shutt in R7RS-large.
[19:19:04] <amazigh> I just read Social Architecture essay (the short version), and P. Hintjens claim a non-tribal community is more productive and has better ideas.
[19:19:13] <amazigh> ref: http://hintjens.com/blog:117
[19:19:42] <amazigh> to be honest, I already read the book with the same title, and I do not grasp everything.
[19:20:41] <amazigh> P. Hintjens created the zeromq community.
[19:21:01] <Zipheir> Hmm.
[19:23:50] <Zipheir> His post recommends "The Benevolent Tyrant" as a "pattern for success".  I'm dubious.
[19:23:58] <hexology> is there any scheme implementation with "persistent data structures"? e.g. immutable vectors that don't actually make a copy of all the data in the vector when you append to it or replace a value
[19:24:15] <hexology> i see chez has immutable vectors for example, but i don't see any indication of whether they're "persistent"
[19:24:23] <Zipheir> hexology: There are many libraries for such things.
[19:24:50] <Zipheir> hexology: These are essentially immutable vectors https://srfi.schemers.org/srfi-224/srfi-224.html
[19:26:41] <Zipheir> I think I'd say the question is not one of "persistence" as much as one of space/time complexity.  We want something close to the (nominally) O(1) update of mutable vectors.
[19:26:51] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[19:27:58] *** Joins: gproto23 (~gproto23@user/gproto23)
[19:28:19] <amazigh> hexology: you can't grow a immutable vector, unlike flexvectors (https://srfi.schemers.org/srfi-214/)
[19:28:33] <amazigh> sorry, chez immutable vectors can't grow
[19:28:38] <Zipheir> Oh yeah, forgot about flexvectors.
[19:28:42] <hexology> thanks both
[19:29:07] <amazigh> IIRC there is also a similar datastructure in pfds by ijp on github
[19:29:17] <Zipheir> That's the imperative-flavored alternative, whereas SRFI 146/224 mappings will be more familiar to functional programmers.
[19:29:19] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[19:29:22] <hexology> yeah my concern is performance, e.g. working with strings and numerical code
[19:29:27] <amazigh> which is R6RS 
[19:29:58] <hexology> what is r6rs?
[19:30:01] <amazigh> there is a srfi for string persistent strings too
[19:30:04] <hexology> rather, what about r6rs
[19:30:05] <Zipheir> hexology: Performance of what operations?
[19:30:20] <Zipheir> hexology: One of the major Scheme standards.
[19:30:33] <Zipheir> hexology: http://www.r6rs.org/
[19:30:39] <amazigh> hexology: pfds is written for guile, but R6RS in mind, which means you can port it to Chez
[19:30:48] <hexology> ah thank you for clarifying
[19:31:05] <amazigh> https://github.com/ijp/pfds
[19:31:35] <amazigh> And chez is still R6RS.
[19:32:21] <Zipheir> In practice, the R-B tree and radix tree mapping implementations are very fast, though somewhat space-inefficient compared to vectors.  I haven't experimented with flexvectors.
[19:32:47] <hexology> partially my interest is 1) i like immutability and functional programming idioms, and 2) i am working on the idris 2 language, which uses chez as its main compiler target, and if i can implement immutable arrays in such a way that i don't have to paper over a mutable backend and implement persistence myself, all the better
[19:33:33] <Zipheir> hexology: What is an immutable array, in this case?
[19:34:07] <amazigh> good question.
[19:34:27] <amazigh> There is also fingertrees that can do for flexvectors, depending on your usecase.
[19:35:08] <Zipheir> hexology: Rather, what kind of operations do you need, and what kind of abstract space/time performance should they have?
[19:35:56] <Zipheir> "Arrayness" seems to come down to a map from the natural numbers to arbitrary objects.
[19:36:39] <Zipheir> Well, from a contiguous subset of the natural numbers to arbitrary objects, more precisely.
[19:43:00] <mdhughes> Persistence is still your own problem in every version I know of, but (vector->immutable-vector), also fxvector, bytevector, string, are in Chez's custom library.
[19:44:06] <amazigh> I was looking at clojure which has strong bias toward persistence, but I can not make sense of the documentation and figure what algorithm they use in their stdlib
[19:44:20] <mdhughes> Getting the system to reliably tell you when it's shutting down so you can persist is rough, checkpointing introduces stutters in your code, and a total intercept of messages to pass to a database slows everything…
[19:44:58] <dpk> hexology: all Scheme data structures are basically mutable, but by convention nearly all Scheme datums are never mutated
[19:45:18] <dpk> we use mutation almost exclusively as a performance hack in hot spots
[19:45:27] <Zipheir> Standard Scheme types also have the built-in tension between "persistent" and "transient" structures.  Strings are an especially bad example.
[19:45:35] <mdhughes> I have puzzled around on making a new Hypercard-like with Scheme, and persistence is the part where I recoil.
[19:46:03] <Zipheir> dpk: Exactly.
[19:46:12] <Zipheir> Unfortunate though that is.
[19:46:42] <dpk> you can define record types with only immutable slots, but only a static, fixed number of them
[19:47:03] <dpk> so if you want persistent, immutable vectors, you'll have to paper them over Scheme's underlying mutable vectors
[19:47:26] <Zipheir> Which sort of eliminates the point, I think.
[19:48:07] <dpk> there are also Ian Price's fectors, and SRFI 101 ‘random-access’ (i.e. log2 access) linked lists
[19:48:13] <Zipheir> Maybe not.  I don't know how subtle the optimizations can get there.
[19:48:17] <amazigh> I gather hexology is looking for an existing practical (that covers most use cases) persistent array library that works with Chez
[19:49:00] <amazigh> and that is performant cpu and memory wise
[19:49:01] *** Quits: nckx (~nckx@tobias.gr) (Quit: Updating my Guix System <https://guix.gnu.org>)
[19:49:11] <Zipheir> dpk: One of the lesser-known additions to R7RS-large!
[19:49:15] <hexology> sorry all, had to step away. will respond shortly
[19:49:18] <dpk> a library implementing Clojure-like vectors would be handy. SRFI- and R7RS Large-docket level handy
[19:49:22] <hexology> but yes amazigh, more or less that
[19:50:04] <amazigh> what datastructure use clojure for vectors then?
[19:50:18] <Zipheir> I still think it would be more useful to compare these structures in terms of the operations provided and their complexity.  "Clojure-like vector", "array", etc. are all very fuzzy terms.
[19:50:22] <Zipheir> Exactly.
[19:50:32] <amazigh> 5 min looking around they seem to recommend different implementation depending on the use case (size of the vector)
[19:50:52] <dpk> amazigh: https://hypirion.com/musings/understanding-persistent-vector-pt-1
[19:51:35] <Zipheir> Sounds like a HAMT.
[19:52:04] <dpk> yes, but it's a sequence rather than a mapping
[19:52:23] <dpk> gives O(log32 n) or O(log64 n) access to elements in Clojure's implementation, iirc
[19:52:41] <Zipheir> Nice.
[19:52:49] <dpk> which they, not unfairly, call ‘effectively O(1)’
[19:53:27] <Zipheir> I'd like to see a proof of that.  The explanation seems rather ad-hoc.
[19:53:40] <hexology> Zipheir: what did you mean about strings being a bad example of tension vs transient and persistent? 
[19:53:58] <dpk> i think Rich Hickey wrote a paper about them, but i can't find it
[19:54:31] <Zipheir> hexology: According to the standards, strings are mutable, thus string operations always return "newly allocated" results (strings can't be "reused").
[19:54:44] <hexology> i see
[19:54:59] <Zipheir> hexology: So, even though very few programs use string mutation, we all pay the cost for providing it.
[19:55:24] <amazigh> a quick glimpse a the intro, I think that is what mit/scheme (included in scm libraries under a bsd-like license) is, except they expose a map interface instead of an array interface.
[19:55:38] <hexology> so for example in python, strings are immutable, but often interned, and there are optimizations where the runtime can implement operations like `+=` on strings without copying and allocating
[19:55:49] *** Joins: nckx (~nckx@tobias.gr)
[19:56:24] <hexology> that makes for reasonably fast text processing operations, which can be important in data science / natural language processing, parsing logs, even things like constructing pretty cli outputs without lots of overhead
[19:56:34] <Zipheir> hexology: Indeed.
[19:56:39] <hexology> "overhead" meaning "user-perceived slowness" in this case
[19:56:55] <hexology> i am also interested in things like "construct a 500x10 matrix by stacking 500 10-vectors" not making a copy of all that data if at all possible
[19:57:12] <Zipheir> hexology: More or less an impossible optimization technique with mutable strings, though.
[19:57:22] <hexology> i see
[19:57:23] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 264 seconds)
[19:58:15] <hexology> also i have no formal training in compiler design or cs theory in general :) so i would be in pretty deep over my head if i tried to do this all from scratch
[19:58:32] <hexology> i could learn of course, but i'd rather not shave _too_ many yaks
[19:58:50] <dpk> here's another blog post with some maths around O(log32 n) https://hypirion.com/musings/persistent-vector-performance
[19:58:50] <Zipheir> hexology: I'd really suggest not worrying about performance until it becomes a problem.
[19:59:05] *** Joins: aeth (~aeth@user/aeth)
[19:59:09] <amazigh> hexology: I have some code around that implements something similar to clojure's array.
[19:59:12] <amazigh> +1 Zipheir 
[19:59:34] <hexology> well i have been doing some benchmarks on toy programs, e.g. "loop over a big text file and do some stuff", and python beats the pants off a lot of other librares at that task
[19:59:46] <hexology> s/libraries/languages
[20:00:25] <amazigh> hexology: if you tried that with Chez, you prolly benchmarked the GC..
[20:00:56] <Zipheir> Python has been optimized to within an inch of its correctness by a ton of people working very hard.  Most Schemes haven't seen that kind of effort.
[20:01:07] <hexology> indeed, but that's the point
[20:01:15] <hexology> also it has been optimized specifically for those tasks
[20:01:18] <hexology> so it might just be unfair
[20:01:19] <amazigh> disable GC, and re do the benchmark maybe
[20:01:51] <hexology> how would that work? climbing memory usage forever?
[20:02:05] <amazigh> I did some benchmarks where Chez beats both pypy and python, actually two benchmarks.
[20:02:06] <Zipheir> dpk: That's useful, but I'd still like to see a simple mathematical presentation of the structure...
[20:02:23] <amazigh> even beating C/C++/Java with Chez.
[20:02:31] <Zipheir> Functional folks seem to have a very different idea of "structure" than the software-engineering folks...
[20:02:52] <hexology> i have heard that kind of thing before amazigh, that chez will beat hand-optimized C programs in some tasks
[20:03:43] <amazigh> re memory, no, but on short programs it seems the speed up of Chez is hidden because of GC work.
[20:04:04] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 268 seconds)
[20:04:33] *** Joins: aeth (~aeth@user/aeth)
[20:05:56] <hexology> amazigh: what kind of benchmarks where those? i'd be interested to see them
[20:06:06] <hexology> (if only to get more experience reading scheme code)
[20:07:12] <amazigh> the C/C++ and Java benchmark are bitroted
[20:07:19] <amazigh> but see this https://lists.sr.ht/~sircmpwn/public-inbox/%3CCE6ZY445PGFR.3DU38TTDZCFEP%40len%3E#%3C82aa5270bb3e0f67df9e5b9f6e9d9ae0@hyper.dev%3E
[20:07:21] <rudybot> https://teensy.info/AEkTq6d4rz
[20:07:48] <amazigh> the json parser written only with Chez is as fast as C++, and slower that cpython/simdjson and pypy that also use simdjson.
[20:08:09] <hexology> that's really cool
[20:08:24] <amazigh> The second graph, show ffi overhead, and chez is faster than calling c.
[20:09:07] <amazigh> but again, that is choice, I prefer to have the freedom to code only with Scheme, unlike python where you always need to context-switch to another language to gain some kind of perfs.
[20:09:22] <amazigh> I think my approach as one-man-team is more scalable.
[20:09:45] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[20:09:47] <amazigh> even if in some cases, Python or whatever will be faster.
[20:10:13] <hexology> my day job is python, so in my hobby code i like to have fun exploring different languages
[20:10:55] <amazigh> I'd like to explore idris one day.
[20:12:23] <hexology> i think most active discussion happens on the community discord server now
[20:12:36] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[20:12:48] <hexology> since chez is the main compiler target for idris 2, if you're already an experienced chez hacker you might find it especially interesting
[20:13:05] <hexology> there is also a gambit compiler target but i don't know how well-maintained it is
[20:17:29] <Zipheir> Ugh, more Discord.
[20:23:06] *** Joins: Inline (~Inline@2a02:908:1252:7a80:9e2e:d238:6ddc:c88f)
[20:30:18] <gwatt> In R7RS, the section on `parameterize` states that when restoring the original value of the parameter, the value is not passed to the conversion function. Has anyone written/seen code that actually depends on that behavior?
[20:52:39] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[20:57:06] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[20:58:21] *** Quits: gproto23 (~gproto23@user/gproto23) (Ping timeout: 268 seconds)
[21:16:02] *** Joins: gproto23 (~gproto23@user/gproto23)
[21:16:05] *** Joins: xgqtd_ (~user@static62133140007.ostnet.pl)
[21:20:24] *** Quits: xgqtd (~user@static62133140007.ostnet.pl) (Ping timeout: 260 seconds)
[21:21:11] *** xgqtd_ is now known as xgqt
[21:32:12] *** Quits: gproto23 (~gproto23@user/gproto23) (Remote host closed the connection)
[21:32:37] *** Joins: gproto23 (~gproto23@user/gproto23)
[21:36:51] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[21:41:39] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[22:05:27] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[22:07:18] <mdhughes> For parsing & making output, I took advantage of mutable strings to make a StringBuffer modelled on the Java API. But that's a rare case where mutable strings don't suck.
[22:08:25] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[22:11:40] <gwatt> mdhughes: what made you choose to directly manipulate strings over using a string output port?
[22:12:41] <mdhughes> I needed to backtrack and read what I'd written; I could've just kept a buffer of the last few chars but that's just as much overhead.
[22:13:00] <gwatt> makes sense
[22:13:01] <mdhughes> And it gives me nice advantages like editing text, searching the output, etc.
[22:34:30] *** Parts: pranavats (3fba1d1b34@jabberfr.org) ()
[22:35:21] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[22:37:06] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[22:40:11] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[22:48:17] *** Joins: robin_ (~robin@user/terpri)
[22:50:34] *** Quits: robin (~robin@user/terpri) (Ping timeout: 268 seconds)
[23:04:36] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[23:07:42] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[23:09:57] *** Quits: Avichi (~Avichi@250-150-159-217.sta.estpak.ee) (Quit: Client closed)
[23:31:54] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[23:36:50] *** Joins: ec (~ec@gateway/tor-sasl/ec)
