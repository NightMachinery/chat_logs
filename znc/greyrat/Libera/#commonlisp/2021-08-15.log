[00:00:36] *** Joins: lisp123_ (~lisp123@45.86.200.16)
[00:01:19] *** Quits: rain3 (~rain3___@2a02:2f09:d30b:1300:514:bcc7:8202:1798) (Ping timeout: 258 seconds)
[00:04:23] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 258 seconds)
[00:13:46] *** Joins: lisp123 (~lisp123@45.86.200.16)
[00:16:34] *** Joins: lisp123__ (~lisp123@45.130.83.208)
[00:17:17] *** Quits: lisp123_ (~lisp123@45.86.200.16) (Ping timeout: 252 seconds)
[00:19:41] *** Quits: cage (~cage@dynamic-adsl-78-15-36-212.clienti.tiscali.it) (Remote host closed the connection)
[00:19:42] *** Quits: amb007 (~a_bakic@net219-37-245-109.mbb.telenor.rs) (Read error: Connection reset by peer)
[00:20:02] *** Quits: lisp123 (~lisp123@45.86.200.16) (Ping timeout: 252 seconds)
[00:20:03] *** Joins: amb007 (~a_bakic@cable-94-189-181-220.dynamic.sbb.rs)
[00:21:50] *** Joins: tyson2 (~user@toroon12-3096782677.sdsl.bell.ca)
[00:25:07] *** Quits: amb007 (~a_bakic@cable-94-189-181-220.dynamic.sbb.rs) (Read error: Connection reset by peer)
[00:25:20] *** Joins: amb007 (~a_bakic@cable-94-189-181-220.dynamic.sbb.rs)
[00:28:13] *** Quits: peterhil_ (~peterhil@dsl-hkibng32-54fb52-57.dhcp.inet.fi) (Quit: Must not waste too much time here...)
[00:31:38] *** Joins: peterhil (~peterhil@dsl-hkibng32-54fb52-57.dhcp.inet.fi)
[00:32:16] *** Quits: bothillinois (~twi@191.101.31.62) (Changing host)
[00:32:16] *** Joins: bothillinois (~twi@user/bothillinois)
[00:33:15] *** Quits: lisp123__ (~lisp123@45.130.83.208) (Remote host closed the connection)
[00:36:12] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[00:37:50] *** Joins: kakuhen (~kakuhen@user/kakuhen)
[00:39:05] *** Joins: lisp123 (~lisp123@45.130.83.208)
[00:39:16] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 258 seconds)
[00:39:57] *** Quits: bothillinois (~twi@user/bothillinois) (Quit: leaving)
[00:40:54] *** Quits: derelict (~derelict@user/derelict) (Quit: WeeChat 3.2)
[00:42:41] *** Joins: lisp123_ (~lisp123@45.130.83.208)
[00:43:07] *** Quits: seanw (spwhitton@debian/spwhitton) (Quit: leaving)
[00:43:19] *** Joins: asarch (~asarch@2806:10ae:7:defb:627b:ef7f:734a:76f5)
[00:44:14] *** Quits: lisp123 (~lisp123@45.130.83.208) (Ping timeout: 252 seconds)
[00:46:59] *** Quits: lisp123_ (~lisp123@45.130.83.208) (Ping timeout: 252 seconds)
[00:48:27] <nij-> Anyone had experience with loading maxima into the lisp repl?
[00:48:54] <lotuseater> you mean calling maxima from CL
[00:49:50] <nij-> Yeah.. uhm I guess it's the same cuz it's implemented in cl.
[00:53:08] *** Joins: dsk (~dsk@user/dsk)
[00:58:13] *** Joins: derelict (~derelict@user/derelict)
[01:00:59] <pl> nij-: it might be... an experience
[01:01:26] <pl> Maxima is, iirc, a weird amalgam of MACLISP, Franz and Common Lisp
[01:02:13] <pl> and I think it doesn't use any of the modern build options
[01:04:13] <random-nick> there's this clim-based frontend for maxima which uses maxima from CL https://github.com/lokedhs/maxima-client
[01:05:17] <random-nick> it seems to use maxima which is built separately
[01:07:18] <nij-> maxima-client seems to be under construction..
[01:08:01] <nij-> pl: Hmm based on the stats provide by github, most of the code seems to be written in CL: https://github.com/calyau/maxima
[01:08:21] <pl> nij-: github code detection would be unable to differentiate
[01:08:36] <nij-> That's fair. Oh dear :(
[01:08:38] <pl> (being mostly based on file names)
[01:08:46] <pl> nij-: it loads into CL just fine
[01:08:50] <nij-> I wonder why there's no CAS that uses lisp repl style.
[01:08:53] <pl> just be ready to deal with weird code
[01:11:39] <nij-> pl: how would you load?!
[01:11:39] <pl> https://github.com/calyau/maxima/blob/master/INSTALL.lisp will be of interest
[01:11:54] <nij-> Here's a version that claims to be loadable: https://github.com/bld/embeddable-maxima
[01:12:17] <nij-> But following its instruction leads to an error ---- Just performed compiling #<QUADPACK-FORTRAN-FILE "em-quadpack" "fortran" "dqawfe"> but failed to mark it done
[01:12:48] <nij-> pl! Thanks lemme try that method.
[01:13:11] <pl> nij-: Common Lisp evolved, among other things, from MACLISP (and Franz was essentially MACLISP ported to Unix), and thus Maxima was updated to be compatible - but huge amounts of code are veery old style
[01:13:31] <pl> also consider that it doesn't take much to make most ancient Lisp code compilable on CL
[01:13:41] <pl> (this was a design goal, in a way)
[01:17:42] <nij-> compiling.. I'm very excited.
[01:18:01] <nij-> Wanted to do this months ago, but I was toooooo newb to even formulate what I wanted.
[01:18:02] <nij-> (ha)
[01:19:40] *** Joins: lisp123 (~lisp123@45.130.83.208)
[01:24:12] <nij-> pl do you know why all CAS don't use sexprs as their syntax of lang?
[01:24:21] <kakuhen> I found an outdated documentation in CLiki. Not sure if relevant to this channel
[01:24:22] <kakuhen> https://www.cliki.net/Common%20lisp%20implementation
[01:24:35] <kakuhen> >Fink CLISP fails to includes threads, and MacPorts anything fails to include FFI.
[01:24:37] <kakuhen> Both of these statements are false
[01:24:44] <nij-> Look at this pearl by stylewarning, it is a tiny cas with sexpr nicely https://github.com/stylewarning/cl-permutation
[01:25:16] <kakuhen> I have copies of SBCL and CCL from MacPorts. They are virtually identical to copies you can contain upstream. That is to say, SB-ALIEN definitely exists in SBCL, and CCL comes with it's own FFI and the Objective-C bridge, too.
[01:25:32] <pl> nij-: most CAS are geared towards standard algebraic input (even Maxima does that, in a way)
[01:25:42] <pl> internal representation is rarely exposed
[01:26:03] <kakuhen> s/contain/obtain
[01:26:37] <nij-> pl but that makes it harder for people to add new mathematical structures..
[01:26:39] <akater[m]> kakuhen: Feel free to edit CLiki if you're certain. (Know what Fink is?)
[01:28:23] *** Quits: psycomic (~psycomic@2a01cb0588c5e400f4f85b0ac9afcceb.ipv6.abo.wanadoo.fr) (Remote host closed the connection)
[01:28:41] *** Joins: psycomic (~psycomic@2a01cb0588c5e40025479cb87bc8ba9a.ipv6.abo.wanadoo.fr)
[01:29:22] <moon-child> mathematica's 'canonical' format is m-expressions, it allows the use of traditional mathematical notation as shorthand
[01:29:34] *** Quits: tyson2 (~user@toroon12-3096782677.sdsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[01:30:17] *** Quits: lisp123 (~lisp123@45.130.83.208) (Ping timeout: 268 seconds)
[01:30:23] <akater[m]> moon-child: It's not Mexprs that allow that but rather the FrontEnd interface.
[01:30:53] <kakuhen> akater[m]: I don't personally use Fink, but CLISP is no longer in Fink, and so the statement is vacuously true I guess?
[01:31:05] <kakuhen> Anyway I didn't know I was able to edit CLiki myself, so I'll do that soon
[01:31:33] <kakuhen> A quick search in fink's main repo shows no results for Fink, so I'm not sure how useful including the first half of that sentence is :P
[01:31:38] <kakuhen> no results for CLISP*
[01:31:40] <akater[m]> …You could have the same with sexprs, and I heard loke's interface does that.
[01:32:02] <lotuseater> mathematica is very consistent and mnemonic in naming
[01:32:17] <akater[m]> kakuhen: I have no idea what Fink is so you know better.
[01:32:55] <akater[m]> Yes, Mathematica is great.  It brought me to Lisp.
[01:34:20] <nij-> akater[m]: loke?
[01:35:06] <lotuseater> akater[m]: oh cool
[01:35:49] <akater[m]> I guess maxima-client is written by loke and used to be called CLIMaxima.
[01:36:28] <lotuseater> it could be interesting to work at Wolfram, but their code case must be huge with much legacy stuff in older C++
[01:37:02] <nij-> lotuseater: I never know how to get started with mathematica. Any thought? Is there a cl binder?
[01:37:18] <lotuseater> hm no you do Wolfram Language
[01:37:38] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[01:38:36] <akater[m]> Yep, maxima-client is by @loke@functional.cafe (ActivityPub account)
[01:39:25] <akater[m]> lotuseater: I was under the impression they only used C but I might be wrong.
[01:40:06] <lotuseater> i think SMP the ancestor was mostly in C and Fortran
[01:40:26] <lotuseater> then it evolved, started using C++ and Java or so
[01:41:23] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 268 seconds)
[01:44:03] *** Quits: asarch (~asarch@2806:10ae:7:defb:627b:ef7f:734a:76f5) (Quit: Leaving)
[01:45:25] <akater[m]> lotuseater: I'm sorry, are you aware a PM chat was initiated (by you)?  I'm using Matrix bridge, there might be surprising behaviour on both sides.
[01:46:06] *** Quits: psycomic (~psycomic@2a01cb0588c5e40025479cb87bc8ba9a.ipv6.abo.wanadoo.fr) (Ping timeout: 272 seconds)
[01:47:38] <lotuseater> *magic*
[01:50:59] <Josh_2> Hi
[02:02:04] *** Joins: lisp123 (~lisp123@45.130.83.208)
[02:06:22] *** Quits: taiju (~taiju@240b:253:ec40:2400:e1d1:588c:bc3f:1887) (Ping timeout: 245 seconds)
[02:09:51] *** Quits: pve (~pve@178-55-250-142.bb.dnainternet.fi) (Quit: leaving)
[02:10:53] *** Quits: specbot (~specbot@common-lisp.net) (Remote host closed the connection)
[02:10:53] *** Quits: minion (~minion@common-lisp.net) (Remote host closed the connection)
[02:11:11] *** Joins: karlosz (~karlosz@router.cloyne.org)
[02:11:35] *** Quits: lisp123 (~lisp123@45.130.83.208) (Ping timeout: 268 seconds)
[02:15:38] *** Joins: seanw (spwhitton@debian/spwhitton)
[02:17:01] *** Joins: specbot (~specbot@common-lisp.net)
[02:17:38] *** Joins: minion (~minion@common-lisp.net)
[02:19:28] *** Joins: kulernil (~kulernil@gateway/tor-sasl/kuler)
[02:21:55] *** Quits: kuler (~kulernil@gateway/tor-sasl/kuler) (Ping timeout: 244 seconds)
[02:30:06] *** Quits: selwyn_ (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[02:30:42] *** Quits: hendursa1 (~weechat@user/hendursaga) (Ping timeout: 244 seconds)
[02:31:04] *** Quits: attila_lendvai (~alendvai@2a02:ab88:3707:bb00:5ee0:c5ff:feb2:29e2) (Ping timeout: 272 seconds)
[02:32:47] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[02:33:04] *** Joins: hendursa1 (~weechat@user/hendursaga)
[02:34:05] <lotuseater> hey Josh_2 :)
[02:35:37] <Josh_2> 'ello
[02:37:50] *** Quits: karlosz (~karlosz@router.cloyne.org) (Quit: karlosz)
[02:39:36] *** Joins: akoana (~ah@user/akoana)
[02:52:16] *** Quits: gaqwas (~john@dynamic-095-118-127-244.95.118.pool.telefonica.de) (Ping timeout: 256 seconds)
[03:02:27] *** Quits: hendursa1 (~weechat@user/hendursaga) (Quit: hendursa1)
[03:03:17] *** Joins: hendursaga (~weechat@user/hendursaga)
[03:08:18] *** Quits: kulernil (~kulernil@gateway/tor-sasl/kuler) (Remote host closed the connection)
[03:08:55] *** Joins: kulernil (~kulernil@gateway/tor-sasl/kuler)
[03:10:05] *** Joins: blihp (~phil@c-68-43-233-92.hsd1.mi.comcast.net)
[03:11:39] *** Joins: lisp123 (~lisp123@45.130.83.208)
[03:13:34] *** Quits: lisp123 (~lisp123@45.130.83.208) (Remote host closed the connection)
[03:14:10] *** Joins: lisp123 (~lisp123@45.130.83.208)
[03:17:12] *** Quits: kulernil (~kulernil@gateway/tor-sasl/kuler) (Ping timeout: 244 seconds)
[03:19:43] *** Quits: blihp (~phil@c-68-43-233-92.hsd1.mi.comcast.net) (Quit: Leaving)
[03:19:50] *** Quits: lisp123 (~lisp123@45.130.83.208) (Read error: Connection reset by peer)
[03:19:56] *** Joins: blihp (~phil@c-68-43-233-92.hsd1.mi.comcast.net)
[03:20:17] *** Quits: blihp (~phil@c-68-43-233-92.hsd1.mi.comcast.net) (Client Quit)
[03:20:30] *** Joins: blihp (~phil@c-68-43-233-92.hsd1.mi.comcast.net)
[03:24:12] *** Quits: blihp (~phil@c-68-43-233-92.hsd1.mi.comcast.net) (Client Quit)
[03:24:27] *** Joins: blihp (~phil@c-68-43-233-92.hsd1.mi.comcast.net)
[03:31:00] *** Joins: Qwnavery (~Qwnavery@user/qwnavery)
[03:45:14] *** Quits: dsk (~dsk@user/dsk) (Ping timeout: 272 seconds)
[03:51:21] *** Joins: lisp123 (~lisp123@45.130.83.208)
[03:59:07] *** Quits: lisp123 (~lisp123@45.130.83.208) (Read error: Connection reset by peer)
[04:20:56] *** Joins: lisp123 (~lisp123@45.130.83.208)
[04:22:24] *** Quits: lisp123 (~lisp123@45.130.83.208) (Remote host closed the connection)
[04:23:23] *** Joins: lisp123 (~lisp123@45.130.83.208)
[04:26:54] *** Quits: lisp123 (~lisp123@45.130.83.208) (Read error: Connection reset by peer)
[04:27:51] *** Quits: Bike (~Bike@71.69.170.70) (Quit: Connection closed)
[04:35:07] *** Joins: Fare (~fare@2601:184:4a7f:995c:b74b:fb2d:eb17:da16)
[04:36:41] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[04:46:31] *** Quits: random-nick (~random-ni@87.116.165.220) (Ping timeout: 258 seconds)
[04:52:24] *** Joins: Spawns_Carpeting (~pi@user/spawns-carpeting/x-6969421)
[04:52:43] <Spawns_Carpeting> Is anyone here familar with SBCL and the --script command line flag?
[04:55:41] *** Joins: lisp123 (~lisp123@45.130.83.208)
[05:04:55] *** Quits: lisp123 (~lisp123@45.130.83.208) (Ping timeout: 258 seconds)
[05:13:44] *** Quits: makomo (~makomo@user/makomo) (Ping timeout: 258 seconds)
[05:25:27] *** Joins: Bike (~Bike@71.69.170.70)
[05:25:27] *** ChanServ sets mode: +o Bike
[05:32:15] <Josh_2> What bout it?
[05:40:59] *** Joins: dsk (~dsk@user/dsk)
[05:46:03] *** Parts: akoana (~ah@user/akoana) ()
[05:50:01] <hayley> It is like --load, but SBCL quits immediately after and the debugger is disabled, from memory.
[05:51:21] <lotuseater> so it says to the debugger "you have no power here!" :D
[06:03:34] *** Joins: lisp123 (~lisp123@45.130.83.208)
[06:04:30] *** Quits: nij- (~jin@2001-48F8-9021-806-0-0-0-14F5-dynamic.midco.net) (Ping timeout: 272 seconds)
[06:06:01] <White_Flame> it also ignores your .sbclrc
[06:06:35] *** Quits: lisp123 (~lisp123@45.130.83.208) (Read error: Connection reset by peer)
[06:11:04] *** Quits: Spawns_Carpeting (~pi@user/spawns-carpeting/x-6969421) (Quit: ZNC 1.7.2+deb3 - https://znc.in)
[06:12:45] *** Joins: Spawns_Carpeting (~pi@user/spawns-carpeting/x-6969421)
[06:45:31] <kakuhen> When I have a funcallable-standard-object, the function of the object is called the "instance function," right?
[06:45:39] <kakuhen> I'm guessing this based off the name set-funcallable-instance-function
[06:46:18] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 256 seconds)
[06:46:57] <Bike> Probably yes, but what is the context?
[06:47:42] <kakuhen> im writing documentation for some of my code
[06:48:10] <kakuhen> I have a funcallable-standard-object with two slots, one of which hosts a function, and I want a precise word that tells the reader I mean the function of the instance, not the function in that one slot.
[06:48:46] <kakuhen> funcallable-standard-class* sry
[06:49:03] <Bike> ah. in that case "instance function" should do, sure.
[06:51:44] <kakuhen> sweet thanks
[06:52:12] *** Joins: kuler (~kulernil@gateway/tor-sasl/kuler)
[06:53:04] *** Quits: kuler (~kulernil@gateway/tor-sasl/kuler) (Remote host closed the connection)
[06:53:27] *** Joins: kuler (~kulernil@gateway/tor-sasl/kuler)
[07:04:47] *** Quits: White_Flame (~quassel@user/white-flame/x-6930243) (Remote host closed the connection)
[07:06:00] *** Joins: White_Flame (~quassel@user/white-flame/x-6930243)
[07:19:47] *** Joins: prxq (~quassel@x4db59413.dyn.telefonica.de)
[07:24:15] *** Quits: prxq_ (~quassel@x4db3fbdd.dyn.telefonica.de) (Ping timeout: 268 seconds)
[07:25:09] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[07:27:32] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Ping timeout: 272 seconds)
[07:32:08] <beach> Good morning everyone!
[07:32:19] <lotuseater> Good morning beach :)
[07:34:01] *** Quits: Josh_2 (~user@37.25.47.130) (Ping timeout: 248 seconds)
[07:39:42] <loke[m]> <nij-> "maxima-client seems to be..." <- Maxima can load using asdf.
[07:40:24] <loke[m]> And Climaxima works fine, even though it's not "complete".
[07:43:24] <loke[m]> Things like wxmaxima runs Maxima in a separate process and communicates with it using a separate protocol. Climaxima doesn't do that. It's all Lisp in a single process.
[07:44:11] <beach> Hey loke[m].  I was about to recommend that nij- talk to you about Maxima.
[07:46:53] <loke[m]> beach I actually just woke up, I saw the notification on my phone.
[07:47:01] <beach> Heh, OK.
[07:47:23] <beach> Did you party last night?
[07:48:12] <beach> I guess you could be on vacation in some remote Scandinavian country or so.
[07:50:02] <Qwnavery> (cdr '(defvar *test* "test"))
[07:50:07] <Qwnavery> It's absurd.
[07:50:11] <loke[m]> The readme should probably be improved. A lot of the difficulty in building's comedy from the step that converts the documentation to sexps. It needs to run all the examples in the code so that the results can be recorded in the internal format. But if you're OK with not having the documentation then that step can be skipped.
[07:50:26] <lotuseater> Sweden or Norway must be beautiful. A friend of mine is travelling now with a camper there.
[07:50:44] <lotuseater> Qwnavery: why?
[07:50:56] <Qwnavery> lotuseater: Because every other language lacks it.
[07:51:04] <Qwnavery> It's a good kind of absurd.
[07:51:08] <loke[m]> beach no. It's weekend so I usually sleep till noon. 😃
[07:51:10] <Qwnavery> It makes sense.
[07:51:12] <beach> Qwnavery: "it"?
[07:51:25] <beach> loke[m]: Good for you!
[07:51:32] <lotuseater> yes what exactly do you mean?
[07:51:58] <Qwnavery> I get it. You can write code that writes code because you can treat code as lists.
[07:51:59] <lotuseater> and there are also other languages that are kind of homoiconic
[07:52:58] <beach> Qwnavery: What is "absurd" is that people still program in languages that are *not* homoiconic.
[07:53:15] <Qwnavery> beach: exactly.
[07:53:49] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[07:54:49] <Qwnavery> lotuseater: I sorta got it yesterday, it just sunk in like 2 minutes ago.
[07:55:13] <Qwnavery> (macroexpand (my-brain))
[07:55:19] <lotuseater> good so our efforts are a good investement
[07:55:28] <beach> Qwnavery: As I often say, people spend a lot of energy and time to avoid learning Common Lisp.
[07:55:58] <Qwnavery> beach: but why?
[07:56:03] <Qwnavery> It's liberating.
[07:56:56] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 268 seconds)
[07:57:43] <Qwnavery> also, beach I'd like to apologize for my arrogance about mentoring the other day. lotuseater taught me some fundamentals, I wouldn't have realized how neccessary mentorship is without him.
[07:58:08] <beach> Qwnavery: There are several explanations, but mostly because it is not taught in teaching programs, and when people finally discover it, they have already invested a lot of effort into something sub-optimial, so then it becomes hard to admit the situation.
[07:58:13] <lotuseater> Qwnavery: So today you can spend thinking of why PUSH is a macro but VECTOR-PUSH is not.
[07:58:31] <hayley> I may have a theory, but I only really joined the pieces up yesterday. It is sure liberating, but it seems in some environments that you are treated like a moron who can't think for themselves, despite being hired to be good at programming and design.
[07:58:32] * lotuseater hides away
[07:58:43] <beach> Qwnavery: Sure, no problem.  Good luck with further learning.
[07:59:59] <beach> hayley: How is that observation related to not learning Common Lisp?
[08:00:56] <hayley> beach: Right. People then say that Lisp is impractical because of this flexibility, so other people decide to not learn Lisp.
[08:01:59] <beach> hayley: I still don't understand whether the person being treated like a moron is the one that might want to learn Common Lisp, or the one that then absolutely won't.
[08:02:21] <lotuseater> Or they like more to believe such phrases "Learn full Java in 24 hours".
[08:03:07] <hayley> Okay, I don't understand what I just said.
[08:03:17] <hayley> Just a moment...
[08:03:27] <beach> No wonder *I* didn't then.
[08:03:42] <hayley> Sorry.
[08:04:10] <lotuseater> beach: How do you deal/argue with people who say "Nobody needs that." like one narrow-minded again did with me last week? It gives me the feeling/confirmation of this thought deep down in my mind "Nobody needs YOU."
[08:05:05] <beach> lotuseater: I long ago gave up trying to argue with people about things like that.
[08:06:07] <beach> I find the only thing that kind of works in convincing people is to show that you can produce good work with less effort.
[08:06:07] <lotuseater> Yes I thought of that too.
[08:06:19] <hayley> beach: Well, for example, it is commonly said (outside of Lisp communities) that one can seriously make a mess out of metaprogramming facilities, so one should not use metaprogramming. The people saying those things do not believe anyone is competent enough to be reasonable in their use of metaprogramming.
[08:07:21] <beach> hayley: I see.  To me, that is more a reflection on their own competence than on that of others.
[08:07:25] <lotuseater> Everything that such people do not know or understand has then automatically of course no meaning.
[08:07:47] <hayley> So we have a contradiction wherein someone is supposed to either be good at program design, or is learning to make good decisions, but they also cannot be trusted to design anything.
[08:08:02] <beach> Makes sense.
[08:09:16] <beach> hayley: I understand programmers are mostly hired to follow orders and to be interchangeable, but that is a really dumb hiring practice in my opinion.
[08:10:17] <hayley> Another thing I have been thinking about is that many people think programming is a hard and slow process, and only a few people can do it. So those people can come up with a lot of theories based on this assumption, and a language like Common Lisp can be useful in violating the former assumption.
[08:10:18] <beach> lotuseater: I think that's a very typical sign of most humans.
[08:11:09] <beach> lotuseater: However, I think that, as software developers, we have an obligation to fight such thoughts in ourselves.  Of course, being able to do that already assumes that we are able to question our own abilities.
[08:11:11] <lotuseater> Yes so widening the horizont is good.
[08:11:27] <hayley> Now, it may very well be that hard problems remain hard. But then effort is spent thinking about what to do, rather than how to communicate it to the computer.
[08:11:28] <Qwnavery> Programming is a tool. "Programmers" for better sense of a word, shouldn't exist. All corporate looks for are code monkeys, not individuals who can design, structure and implement systems.
[08:13:21] <Qwnavery> It's why "products" like Windows exist.
[08:13:27] <lotuseater> jap
[08:13:28] <hayley> Recently I have been thinking about how the people who make such an assumption and write a lot based on it also espouse poor programming style. Of course, the direct result is that programming is hard for those people, but if they want to go around saying things based on this assumption, they need to make sure programming won't be easy.
[08:13:29] <beach> Qwnavery: Sure, but those companies are in for a surprise.  Apparently, there is a huge shortage of software developers on the horizon.  I am thinking that this is an opportunity to tell companies about ways to improve productivity by using the right tools, and people with the right training.
[08:13:40] <lotuseater> oh sry that should have gone to gilberth
[08:14:17] <beach> lotuseater: gilberth is around?
[08:14:41] <beach> hayley: Makes sense.
[08:14:43] <lotuseater> yes I write with him in query since last week
[08:14:50] <hayley> For example, some people I disagree with wrote that "the requirement of open source can [...] expose sensitive or secure information". Security by obscurity ain't security at all.
[08:15:04] <lotuseater> as I got to know he's from Germany too
[08:15:09] <beach> lotuseater: He is one of the best hackers I know.
[08:15:38] <lotuseater> Oh I thought that. :) I can learn much from him.
[08:15:50] <hayley> beach: I think there is some similarity with your "The psychology of learning" article.
[08:16:03] <beach> hayley: Yeah.
[08:16:03] <Qwnavery> beach: there will never be a shortage of code monkeys. Developers on the other hand... I feel like the biggest roadblock is shitty management. Corporate structure pushes arrogant and incompetent people to management positions. Even the best developers and software environment can't restructure that mess.
[08:16:35] <hayley> And (as I now have some mental backlog) I agree that hiring for interchangeability is a bad idea.
[08:16:50] <beach> Qwnavery: That doesn't seem to be the case.  Apparently, the number of "programmers" doubles every 5 years.  But teaching programs won't be able to keep up with that demand.
[08:17:32] <lotuseater> No they call themselves mostly "software developers".
[08:17:57] <Qwnavery> or worse yet; "software engineers"
[08:18:40] <beach> Qwnavery: There is this myth that management decides what programmers do.  But in reality, they have lots of freedom to do what they see fit, simply because management doesn't understand what they do.  Few programmers seem to realize this though, and make mistakes such as ask for permission.
[08:18:54] <hayley> Yesterday I started to think about the similarities in things I had critiqued before, and they seem to all make this initial assumption that programming is hard, so either programmers can't be trusted to design anything, or most people would never consider it.
[08:19:23] <lotuseater> Better to ask for forgiveness. :)
[08:19:47] <Qwnavery> hm.
[08:20:02] <Qwnavery> I feel though that there is an alternative approach.
[08:20:06] <hayley> "Good program design is, ultimately, the defiant insistence on acting as if one already is allowed to make drastic design changes." - probably not the late David Graeber
[08:20:47] <White_Flame> people also tend to skip making prototypes
[08:20:54] <White_Flame> and whatever emerges from that becomes their ad-hoc architecture
[08:21:08] <lotuseater> beach: I bet gilberth would like to hear from you sometime again. :)
[08:21:10] <White_Flame> which is now too entrenched to refactor and actually design
[08:21:45] <Qwnavery> White_Flame: Recommend the TAO design Process.
[08:21:50] <lotuseater> White_Flame: "no who needs prototypes, my stuff always works as intended directly ..."
[08:21:59] <beach> lotuseater: I think you are right.  We have met a number of times.
[08:22:03] <Bike> oh, i didn't know graeber died
[08:22:11] <hayley> Yes, you should plan to throw one out. Or two. Sometimes three. (Though yesterday, someone said you should always throw code out rather than design "good code", which is far too much.)
[08:22:22] <beach> lotuseater: He is basically the reason McCLIM exists.
[08:22:30] <hayley> Bike: Yeah, a pity.
[08:25:03] *** Quits: blihp (~phil@c-68-43-233-92.hsd1.mi.comcast.net) (Quit: Leaving)
[08:49:56] *** Quits: dtman34 (~dtman34@c-73-62-246-247.hsd1.mn.comcast.net) (Ping timeout: 258 seconds)
[08:59:13] *** Joins: dtman34 (~dtman34@c-73-62-246-247.hsd1.mn.comcast.net)
[09:09:39] *** Quits: Qwnavery (~Qwnavery@user/qwnavery) (Quit: WeeChat 3.2)
[09:11:53] *** Quits: dsk (~dsk@user/dsk) (Ping timeout: 252 seconds)
[09:39:56] *** Quits: Bike (~Bike@71.69.170.70) (Quit: Connection closed)
[09:45:41] *** Joins: lisp123 (~lisp123@45.130.83.208)
[09:53:09] *** Quits: khrbt (~znc@user/khrbt) (Quit: ZNC 1.7.2+deb3 - https://znc.in)
[09:53:46] *** Joins: khrbt (~znc@2601:646:8600:2f6:3fa:485d:475e:2130)
[09:53:46] *** Quits: khrbt (~znc@2601:646:8600:2f6:3fa:485d:475e:2130) (Changing host)
[09:53:46] *** Joins: khrbt (~znc@user/khrbt)
[09:59:03] *** Quits: khrbt (~znc@user/khrbt) (Quit: ZNC 1.7.2+deb3 - https://znc.in)
[10:06:45] *** Joins: khrbt (~znc@user/khrbt)
[10:10:30] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[10:13:33] *** Quits: notzmv (~zmv@user/notzmv) (Read error: Connection reset by peer)
[10:25:44] *** Joins: notzmv (~zmv@user/notzmv)
[10:29:42] *** Quits: z3t0 (~z3t0@107-159-14-254.on.dsl.ebox.net) (Read error: Connection reset by peer)
[10:32:17] *** Quits: d4ryus (~d4ryus@ppp-188-174-54-240.dynamic.mnet-online.de) (Quit: WeeChat 3.2)
[10:35:15] *** Joins: d4ryus (~d4ryus@ppp-188-174-54-240.dynamic.mnet-online.de)
[10:49:13] *** Quits: lisp123 (~lisp123@45.130.83.208) (Ping timeout: 248 seconds)
[10:49:19] *** Joins: lisp-newbie (~lisp-newb@2a0d:6fc0:789:3600:4d13:a99d:a8f9:cfe8)
[11:00:14] *** Joins: lisp123 (~lisp123@45.130.83.208)
[11:00:38] *** Joins: Lord_of_Life_ (~Lord@user/lord-of-life/x-2819915)
[11:01:02] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 258 seconds)
[11:01:52] *** Lord_of_Life_ is now known as Lord_of_Life
[11:05:01] *** Quits: lisp123 (~lisp123@45.130.83.208) (Ping timeout: 268 seconds)
[11:07:20] *** Joins: lisp123 (~lisp123@45.130.83.208)
[11:08:02] *** Joins: lisp123_ (~lisp123@5.30.23.247)
[11:10:05] *** Quits: lisp123_ (~lisp123@5.30.23.247) (Client Quit)
[11:12:25] *** Quits: lisp123 (~lisp123@45.130.83.208) (Ping timeout: 268 seconds)
[11:12:25] *** Quits: srji (~srji@static.43.141.203.116.clients.your-server.de) (Read error: Connection reset by peer)
[11:27:03] *** Joins: psycomic (~psycomic@2a01cb0588c5e40085e2f0a623c428bc.ipv6.abo.wanadoo.fr)
[11:42:19] *** Joins: pve (~pve@87-93-137-180.bb.dnainternet.fi)
[11:47:25] *** Parts: pranavats (3fba1d1b34@jabberfr.org) (Disconnected: Replaced by new connection)
[11:47:33] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[11:48:15] *** Parts: pranavats (3fba1d1b34@jabberfr.org) (Disconnected: Replaced by new connection)
[11:48:19] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[11:56:31] <psycomic> what's a good resource to understand the internals of the common lisp condition system? I'm making a programming language and I would like to a lisp-like debugger.
[11:57:56] <moon-child> phoe wrote a book about it
[11:58:05] <hayley> phoe's book The Common Lisp Condition System and the implementation presented.
[11:58:19] <hayley> Though, really, the debugger only requires an INVOKE-DEBUGGER function.
[11:58:42] <hayley> https://github.com/Apress/common-lisp-condition-system/tree/master/Sources%20-%20PCS
[11:59:01] <psycomic> thanks
[11:59:06] *** Quits: lad (~lad@user/lad) (Ping timeout: 256 seconds)
[11:59:48] <beach> psycomic: What is unique about your language?
[12:00:26] <psycomic> beach: Nothing, for the moment
[12:00:48] <psycomic> i'm just making the virtual machine
[12:00:51] <beach> psycomic: Also the Common Lisp "debugger" is not really one.  It is just what I call a "backtrace inspector".
[12:01:05] <psycomic> yeah, i know
[12:01:17] *** Joins: nij- (~jin@2001-48F8-9021-806-0-0-0-14F5-dynamic.midco.net)
[12:01:18] <psycomic> that's what i meant
[12:01:28] *** Joins: dsk (~dsk@user/dsk)
[12:01:48] <beach> psycomic: I see.  So what is the purpose of this language?  Is it to teach yourself about language implementation techniques?
[12:01:51] <beach> Or something else?
[12:02:04] <psycomic> basically yes
[12:02:19] <beach> Got it.
[12:02:59] <psycomic> actually, it's the macro system of an assembler, integrated into my game engine
[12:03:05] <beach> OK.
[12:03:19] *** Joins: gaqwas (~john@dynamic-095-117-104-051.95.117.pool.telefonica.de)
[12:03:29] <psycomic> i will use it for high level stuff, and use assembly for performance critical things
[12:03:55] <psycomic> i could probably use guile or lua, but i wanted to try and implement my own lang
[12:04:18] <beach> Language design is tricky business though.
[12:04:47] <psycomic> i'm basically reading everything i can find before writing any code
[12:04:55] <hayley> Doesn't hurt to take a stab at it still. Though using assembler for anything other than the hottest of hot loops is an interesting choice.
[12:05:08] <moon-child> language design is heavily intertwined with implementation design
[12:05:16] <moon-child> I agree about using assembly outside of inner loops
[12:05:28] <beach> psycomic: I don't actually know of any literature on programming-language design.  What are you reading?
[12:06:54] <psycomic> beach: the lambda the ultimate papers, lisp in small pieces, essentials of programming languages, RABBIT: an optimizing compiler for scheme, and "the anatomy of lisp", but it's outdated
[12:07:17] <moon-child> beach: I don't know of any literature either--though I'm sure some exists--but I have found discussions of language committees to be very instructive
[12:07:21] <beach> I see.  Mostly about implementing existing languages, it seems.
[12:07:35] <beach> moon-child: Yes, that sounds like a good idea.
[12:07:58] <psycomic> yep, not really programming language design, actually
[12:08:51] <beach> psycomic: Right.  I am making the distinction because you are creating your own language.  And to me, making the right choices in language design is an order of magnitude more difficult than implementing an existing (well-designed) language.
[12:09:06] <mfiano> Crafting Interpreters was just released, but I have not read it.
[12:10:27] <mfiano> I have talked to the author about game development and language design a lot in the past, so I know he is competent to write about such a topic.
[12:10:29] <hayley> When I skimmed it (in the years-long "draft" phase), it mostly discussed two implementations of a sort of Java-like language.
[12:10:34] *** Joins: makomo (~makomo@user/makomo)
[12:10:46] <beach> mfiano: Good to know.
[12:10:50] *** Joins: rain3 (~rain3___@2a02:2f09:d30b:1300:514:bcc7:8202:1798)
[12:11:16] <psycomic> beach: i guess so. i'm also trying out different well designed programming languages, to have a better understanding of what makes a language good
[12:11:21] <beach> psycomic: My current favorite example is the wish by plenty of relative newbies who wish that EVAL would have access to lexical variables in Common Lisp.  Such a, seemingly innocent, decision would make it impossible to write optimizing compilers for Common Lisp.
[12:11:23] <hayley> So it wasn't much of a language design book. That said, the author demonstrated a reasonable bytecode implementation.
[12:11:54] <psycomic> beach: I'm not that much of a newbie
[12:12:06] *** Joins: srji (~srji@static.43.141.203.116.clients.your-server.de)
[12:12:08] *** Quits: jans (~Thunderbi@193.138.218.216) (Remote host closed the connection)
[12:12:39] <beach> psycomic: Hence "relative" :).  And that is but one of many such suggestions that we have to argue about on a regular basis.
[12:12:47] *** Joins: jans (~Thunderbi@193.138.218.216)
[12:12:58] <hayley> While totally ridiculous, I wonder if you could use a lot of type splitting and inference to generate a fast path where you don't find a call to EVAL or get a reference to the EVAL function, and optimize that path.
[12:13:15] <beach> Possibly.
[12:13:49] <hayley> On the other hand, EVAL couldn't be a function if it has access to the caller's lexical environment.
[12:13:53] <beach> psycomic: People can be experienced application programmers, and still have no clue about language design.
[12:14:17] <beach> hayley: Why is that?
[12:14:24] <psycomic> beach: what do you think are good example of good language design?
[12:15:01] *** Quits: lisp-newbie (~lisp-newb@2a0d:6fc0:789:3600:4d13:a99d:a8f9:cfe8) (Ping timeout: 258 seconds)
[12:15:16] <beach> psycomic: Common Lisp is very good.  They pushed the limits as much as they could without making it impossible to create good compilers.  Python went one step too far.
[12:15:32] <beach> psycomic: And most languages like Java don't go far enough.
[12:15:37] <hayley> Correction, EVAL couldn't implicitly access the lexical environment of the caller, i.e. (let ((x ...)) (eval 'x))
[12:15:41] *** Joins: lisp-newbie (~lisp-newb@147.236.159.123)
[12:15:55] <beach> hayley: Why is that?
[12:16:24] <hayley> I don't think there is a mechanism in Common Lisp which allows it.
[12:16:26] <psycomic> beach: i guess by "going too far" you mean "being too dynamic"?
[12:16:38] <beach> hayley: Oh, Common Lisp.  Sure.
[12:16:57] <moon-child> hayley: I think the assumption was a common lisp-like language where the mechanism was 'we said so'
[12:17:03] <psycomic> python is basically scheme without parenthesis, though. And scheme has a lot of optimizing compilers.
[12:17:13] <hayley> Right, Common Lisp.
[12:17:22] <hayley> Er, no. Definitely not.
[12:17:40] <beach> psycomic: Right.  For example, if you can add slots to individual instances, you pretty much make it necessary to do slot access by hash tables, which gives you a factor 10-100 performance penalty.
[12:17:55] <beach> psycomic: That's an example of a not-so-great decision.
[12:18:17] <beach> [though there may be ways around it, of course, as I am sure #commonlisp participants will point out]
[12:18:22] <psycomic> every object in python is a hash table?
[12:18:57] <beach> I don't know how it is implemented.  But no, Python is not essentially Scheme without parentheses.
[12:19:00] <hayley> But PyPy does a decent job optimizing Python code. One could use something like Self maps/JavaScript "hidden classes"...and I think there is some weird class parameter which specifies a list of slot names.
[12:19:19] <mfiano> Python is far from Scheme.
[12:20:00] <hayley> https://docs.python.org/3/reference/datamodel.html#slots I think the existence of foo.__dict__ for some object foo basically forces you to use a hash table though.
[12:20:10] <moon-child> inline caching is thattaway
[12:20:34] <beach> psycomic: So I think we are getting close to some examples of what I mean.
[12:20:41] <psycomic> what do you think about scheme, then. i personally like the design that tries to keep it simple and minimal (at the expense of being unpractical)
[12:20:53] <hayley> moon-child: It is 2021, why are you only using monomorphic inline caching
[12:20:54] *** Quits: d4ryus (~d4ryus@ppp-188-174-54-240.dynamic.mnet-online.de) (Quit: WeeChat 3.2)
[12:21:27] <hayley> https://bibliography.selflanguage.org/_static/pics.pdf Oops, missed the 20th birthday of polymorphic inline caching.
[12:21:38] <beach> psycomic: This is not the right forum for comparing languages, but I use generic functions every day, so I could not live without CLOS.  But the, I guess Scheme is slowly acquiring more Common Lisp features.
[12:21:55] <beach> *But then,
[12:22:13] <White_Flame> *30th birthday?
[12:22:18] <mfiano> Guile has a rather featureful CLOS
[12:22:23] <mfiano> including a MOP
[12:22:44] <beach> Yes, but Guile is not a language.  It is a programming system.
[12:22:45] <kakuhen> i find the metaobject protocol to be a really great extension
[12:22:47] <hayley> White_Flame: Yeah, one of those.
[12:22:58] <mfiano> It is a virtual machine for several languages
[12:23:04] <mfiano> But yes, I meant Guile Scheme
[12:23:18] <beach> It still has no independent standard.
[12:23:30] <kakuhen> so-called """functors""" from C++ are just adding specifying the metaclass in CLOS, and then you make sure to add an instance function
[12:23:32] <beach> psycomic: Which reminds me of a second example, namely that some people want generic dispatch to work on arbitrary types.
[12:23:45] <kakuhen> in C++ you do nasty operator overload stuff just to pretend you have a funcallable object
[12:23:57] <kakuhen> so that's one aspect of MOP I like a lot -- doesn't need to do things i find a bit gross heh
[12:24:01] <psycomic> beach: doesn't ISLISP do that?
[12:24:27] <beach> I don't remember.  But generic dispatch on Common Lisp classes can be very fast.
[12:24:46] <beach> General types are way more difficult, even from a semantic point of view.
[12:25:31] <psycomic> method dispatch would be a lot harder
[12:25:42] <mfiano> Dispatching on types is arguably more useful for static, nomimal type systems.
[12:25:51] <beach> Yes.
[12:26:14] <mfiano> CL is very dynamic with a (relatively) weird hybrid of nominal/structural types
[12:26:33] <beach> psycomic: All I am saying is that design decisions like this can determine whether it is hard, or even impossible, to write a good compiler.
[12:26:58] <beach> psycomic: That's why I was interested in your language, and your reason for creating your own.
[12:27:08] <psycomic> i'll be careful then
[12:27:39] <psycomic> but you gotta admit that very few "popular" languages actually care about good compilers
[12:27:49] <psycomic> Javascript, Ruby, Python
[12:28:04] <mfiano> Are any of those compiled?
[12:28:11] <psycomic> bytecompiled
[12:28:14] <mfiano> Sure, ok
[12:28:25] <beach> psycomic: Yes, but then, that's no favor to the application programmer.  For Python, you basically have to write C code to get performance.
[12:28:33] <hayley> I would say type dispatch in Common Lisp is perhaps harder due to having AND and OR types. Oh, there's also SATISFIES. Good luck with that one.
[12:28:45] <beach> psycomic: Python itself is estimated to be 50x slower than a good Common Lisp system.
[12:28:51] <mfiano> hayley: ^^
[12:29:03] <hayley> JavaScript has JIT compilers (V8 for example), Ruby has a JIT (which I didn't find to be that great in MRI, but TruffleRuby is great apparently), and Python has PyPy.
[12:30:02] *** Joins: d4ryus (~d4ryus@ppp-188-174-54-240.dynamic.mnet-online.de)
[12:30:14] <psycomic> well, thanks for the insight
[12:30:34] *** Quits: d4ryus (~d4ryus@ppp-188-174-54-240.dynamic.mnet-online.de) (Client Quit)
[12:30:35] <beach> Sure.  Good luck!
[12:30:46] <hayley> GraalVM also handles JavaScript and Python too.
[12:31:39] *** Joins: d4ryus (~d4ryus@ppp-188-174-54-240.dynamic.mnet-online.de)
[12:32:42] <hayley> In the context of JavaScript, I think the usual strategy is to use the usual optimizations (Lars Bak at least moved to the V8 compiler after Self) where applicable, and assume no one uses the non-optimizable stuff, which usually turns out to be true.
[12:35:40] <hayley> That is in part because no one wants to be caught writing code that can't be compiled, so those developers just pretend those constructs don't exist.
[12:35:44] *** Joins: hendursa1 (~weechat@user/hendursaga)
[12:38:18] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 244 seconds)
[12:42:50] *** Quits: Skyfire (~pyon@user/pyon) (Quit: WeeChat 3.2)
[12:46:18] *** Joins: dickbar__ (~dickbaren@dyndsl-031-150-249-066.ewe-ip-backbone.de)
[12:47:20] *** Quits: d4ryus (~d4ryus@ppp-188-174-54-240.dynamic.mnet-online.de) (Quit: WeeChat 3.2)
[12:48:38] <contrapunctus> Can client code add slots to an existing CLOS class, short of redefining the class entirely?
[12:49:24] <hayley> Stealth mixins?
[12:49:37] <beach> Adding a slot to a class basically amounts to redefining it.
[12:50:22] <beach> contrapunctus: You would have to execute something like REINITIALIZE-INSTANCE on the class metaobject.
[12:51:14] <beach> http://metamodular.com/CLOS-MOP/initialization-of-class-metaobjects2.html
[12:51:29] *** Joins: Qwnavery (~Qwnavery@user/qwnavery)
[12:52:37] *** Quits: hendursa1 (~weechat@user/hendursaga) (Remote host closed the connection)
[12:52:39] <pjb> psycomic: well, invoke-debugger is the implementation-provided debugger function, but actually the power of CL debugging comes from *debugger-hook* #| --> #<function swank:swank-debugger-hook> |#  which can be set to any function as you can see.  Hence we can use different debuggers, possibly more sophisticated debuggers.
[12:52:58] *** Joins: hendursa1 (~weechat@user/hendursaga)
[12:53:41] <psycomic> pjb: like the one in McClim? That's really interesting. Common lisp is even more flexible than i thought
[12:54:11] <pjb> exactly.
[12:54:15] <pjb> It's a general notion: languages are powerful in what they DO NOT provide.  eg. C does not provide I/O operators. (pascal does: write, writeln) and for this reason is decried as less powerful than C, arguably rightly so.
[12:54:27] *** Joins: Skyfire (~pyon@user/pyon)
[12:54:42] *** Quits: dsk (~dsk@user/dsk) (Ping timeout: 245 seconds)
[12:55:06] <psycomic> that's an interesting view of power
[12:55:10] <contrapunctus> hayley, beach: would it be terrible if, instead of that, I had a plist/alist as a slot? (I'm trying to implement arbitrary properties for objects.)
[12:55:17] <pjb> CL provides I/O operators, and this poses all kind of problems (eg. cannot switch easily between binary and text streams on stdio,  listen works only on interactive (text) streams, etc.
[12:55:28] *** Joins: copec (~copec@206.214.226.4)
[12:56:40] <pjb> Yes. What saves lisp, is that it has macros, and most of the CL language is just defined with normal macros, that you can substitute for your own macros. So in a sense, lisp does not provide a language (C++ is like that too).  Therefore even while the CL library provides some things, like I/O, this can be avoided, and replaced by custom code.
[12:57:09] <psycomic> are they code examples of this? using *debugger-hook* to modify the debugger?
[12:57:29] <mfiano> https://github.com/phoe/trivial-custom-debugger
[12:57:35] <pjb> C++ doesn't provide a (usable) programming language.  Each shop has to define what subset of C++ they will use, what kind of smart pointer, what template library, etc.  You need that to define the actual C++ derived programming language used at a given place.
[12:57:36] <beach> contrapunctus: I think it all depends on your requirements in terms of flexibility, power, etc.
[12:57:36] <psycomic> thanks!
[12:57:46] <pjb> psycomic: swank is one such example.
[12:57:56] <pjb> Note the result of *debugger-hook* #| --> #<function swank:swank-debugger-hook> |#
[12:58:15] <psycomic> and in the command line, *debugger-hook* --> NIL
[12:58:20] <psycomic> that makes sense
[12:58:41] <pjb> In that case it uses the standard invoke-debugger function.
[12:59:41] <pjb> Note that a custom debugger will have to use implementation specific API to inspect the stack, local frames, insert break points, etc.  Some stuff can be done conformingly, but this require heavy lifting. Have a look for example at cl-stepper.
[13:00:08] <pjb> https://github.com/informatimago/lisp/blob/master/common-lisp/lisp/stepper.lisp
[13:00:14] <psycomic> i see
[13:01:38] *** Quits: dickbar__ (~dickbaren@dyndsl-031-150-249-066.ewe-ip-backbone.de) ()
[13:06:29] <pjb> good languages (languages that are easy to use and are powerful) feature:  only expressions, no statement; only first class data types; homoiconicity;  orthogonality.
[13:07:31] <psycomic> pjb: very few languages are actually good if you go by that definition
[13:08:04] <pjb> psycomic: for eaxmple, python or C are bad, because they distinguish statements from expression (eg. in C you have to write if(a==b){print("Yep");}else{print("Nope");}  but you have to use  print((a==b)?"Yep":"Nope")  instead of print(if(a==b){"yep";}else{"nope";}); )
[13:08:07] <beach> psycomic: That's why we use Common Lisp.
[13:09:02] <pjb> for example, bash is bad because you cannot pass arrays to function, or store them in ararys, etc.  (even string handling is badly implemented).
[13:09:06] <beach> psycomic: Another essential feature is automatic memory management.
[13:09:20] <MichaelRaskin> homoiconicity is overrated, reasonable and well-defined own-AST-representation/manipulation is more than enough
[13:09:28] <psycomic> macros are not first class datatypes in common lisp, for obvious reasons
[13:09:49] <beach> psycomic: A third one is "uniform reference semantics".
[13:09:58] <mfiano> MichaelRaskin: I disagree. Just look at languages like Nim
[13:09:59] <pjb> almost all languages are bad for lack of homoiconicity.  Ruby has a way to represent identifiers as symbol, and a data syntax rich enough to represent code, but it's not homoiconic, so you have to convert the representation, and it's not pretty…
[13:10:37] <pjb> and most languages are not orthogonal, in that they have all kind of special cases and contextual interdictions.
[13:10:43] <MichaelRaskin> Nim has very weird compile-time sublanguage
[13:10:46] *** Joins: d4ryus (~d4ryus@ppp-188-174-54-240.dynamic.mnet-online.de)
[13:10:59] *** Quits: Fare (~fare@2601:184:4a7f:995c:b74b:fb2d:eb17:da16) (Ping timeout: 258 seconds)
[13:11:00] <pjb> Only lisp languages (and perhaps some very rare exception) match those critiria indeed.
[13:11:11] <MichaelRaskin> Julia has macros done better than Common Lisp (sure, more expensively too) without formally speaking homoiconicity
[13:11:45] <pjb> MichaelRaskin: a language can have macro. The question is whether you can easily implement a macro system in a language?
[13:11:51] <pjb> Can you easily implement a macro system in Julia?
[13:12:08] <psycomic> In Julia, you cannot use list functions on the AST, you have to create specific functions to work on the AST
[13:12:15] <psycomic> that makes it inferior to lisp
[13:12:21] <pjb> For example, you may not like the macro system of CL (unhigienic, etc) and may want to replace it. Can you do that in CL? Yes. Can you do that in Julia?
[13:12:23] <MichaelRaskin> You cannot implement a macro system in any language without in-language support, short of writing an interpreter
[13:13:35] <MichaelRaskin> You can only write a wrapper for CL macro system, not really a replacement, it has to resolve down to the native macro system.
[13:13:41] <MichaelRaskin> (Same can be done in Julia)
[13:15:40] <mfiano> Hmm. My favorite feature of CL hasn't been mentioned as a good language quality yet.
[13:16:10] *** Quits: retropikzel (~retropikz@2001:999:200:1f35:89a7:512c:3e01:fea2) (Ping timeout: 256 seconds)
[13:16:12] <pjb> I guess you'd have to use a pre-processor or wrapper, but in lisp it's trivial to do.  In C, pre-processors are common, but they're relatively hard to do, since you have to write a (partial) C parser, and C pre-processors may not combine well (not orthogonal).
[13:16:41] <pjb> See for example C programming language extension: Cedro pre-processor <https://sentido-labs.com/en/library/cedro/202106171400/>
[13:16:57] <pjb> The only good C pre-processor is elpp ;-)
[13:17:13] <pjb> https://github.com/informatimago/elpp/blob/master/elpp.el
[13:17:49] <psycomic> one of the most important feature of common lisp is that you can redefine anything at run-time
[13:17:58] <psycomic> very few languages are that dynamic
[13:18:03] * hayley was going to say "Late binding of all things"
[13:19:42] *** Joins: cage (~cage@dynamic-adsl-78-15-36-212.clienti.tiscali.it)
[13:21:24] <MichaelRaskin> For all this reference uniformity, the fact that you kind of effectively can turn this in a first class value but only via a closure is a bit annoying
[13:21:34] <beach> psycomic: That is not true, and that's another good decision they made.  You can not redefine standard operators.
[13:22:55] <beach> psycomic: If you were allowed to redefine (say) CADR at run time, then the compiler could not make assumptions about the meaning of a form like (CADR x), and again, you would be limited in the kind of code you could generate.
[13:23:49] <beach> psycomic: But thanks for giving another example of a possible bad design decision a "relative newbie" could make.
[13:23:53] <psycomic> i didn't know that
[13:25:14] <beach> The special operators are also fixed.  You can not alter the meaning of LET.
[13:25:22] <beach> Another good decision.
[13:25:36] <psycomic> are all builtin functions like this?
[13:25:40] <beach> Yes.
[13:25:59] <White_Flame> well, you could shadow CL:LET with your own LOL:LET, so (let (....) ...) expands to something else, probably into CL:LET
[13:26:09] <psycomic> i guess that makes sense
[13:26:23] <White_Flame> *probably including CL:LET
[13:26:29] *** Joins: retropikzel (~retropikz@2001:999:200:1f35:416a:ba48:25b6:f78f)
[13:26:31] <beach> clhs 11.1.2.1.2
[13:26:32] <specbot> Constraints on the COMMON-LISP Package for Conforming Programs: http://www.lispworks.com/reference/HyperSpec/Body/11_abab.htm
[13:26:46] <beach> psycomic: ^
[13:27:19] <beach> psycomic: The people who created Common Lisp were (are) very smart and very knowledgeable, and they seem to have taken all these things into consideration before making final decisions.
[13:27:53] <psycomic> maybe i'll implement common lisp instead :-)
[13:27:57] <mfiano> Meta-circularity is what I favor most. Being able to invoke any phase of the compiler in any other is unique and immensely powerful.
[13:28:10] <beach> mfiano: Ah, yes.
[13:29:01] *** Joins: cpu6502 (~textual@61.69.157.152)
[13:29:53] <pjb> psycomic: notably, the CL standard allows for subset of CL (and also for supersets (extensions) of CL).
[13:31:01] <pjb> psycomic: so it is a great idea to implement a subset of CL for a student project, since this allows you to implement it trivially in CL (often just by defining a package exporting only the operators of your subset), which helps you test your language and debug test programs even before you complete your own implementation!
[13:31:49] <mfiano> I think it's a distinguishing feature of Lisps, or at least CL to have that kind of power. Macros are just a part of this functionality IMO.
[13:32:01] <psycomic> pjb: but if i do that i miss on the most interesting thing: implementing the runtime
[13:32:06] <mfiano> and it doesn't get nearly as much recognition when discussing Lisp features as it should
[13:34:14] <pjb> psycomic: not at all. I'm talking of writing two implementation: one that is easy to do using CL, and one that you will have to debug, your own one.
[13:34:54] <psycomic> ah, okay
[13:34:58] <pjb> psycomic: but having both implementations is nice, since this let you compare them, and test unit tests on both.  So you can validate your unit tests on CL, becofe using them to validate your implementation.
[13:37:04] *** Quits: kakuhen (~kakuhen@user/kakuhen) (Quit: Leaving...)
[13:37:06] <beach> mfiano: I agree.
[13:37:12] *** Quits: amk (~amk@176.61.106.150) (Remote host closed the connection)
[13:38:04] <psycomic> yeah, that's clever. But i don't think i want to implement an existing language. I want to try out things, implement my own toy language and make design mistakes. It is the best way i found to learn
[13:39:01] <mfiano> Everyone writes their own toy Lisp at some point. Enjoy
[13:39:02] <beach> Now you know what will happen, so you are prepared.
[13:39:28] <mfiano> When you are ready to put your toys away, CL is here (to stay)
[13:39:43] *** Joins: amk (~amk@176.61.106.150)
[13:43:10] <psycomic> also, on an unrelated note, how are lexical environments and closures optimized? I once wrote a scheme implementation that allocated frames on the heap, but there has to be a better way
[13:43:40] <mfiano> lexical variables may not even be stack allocated
[13:44:05] <mfiano> Depending on the implementation's register allocator
[13:44:11] <mfiano> or the state of it rather
[13:44:58] <beach> psycomic: Typically, a function object consists of code and a static environment.  The latter typically in the form of a vector.
[13:45:19] <beach> psycomic: Invoking the function object consists of passing the static environment as an implicit argument to the code.
[13:45:45] <beach> psycomic: So the static environment is allocated on the heap, but only when the function object is created.
[13:46:03] <beach> psycomic: Allocating frames is a different story altogether.
[13:46:18] <beach> psycomic: A good Common Lisp system will use the processor stack for that.
[13:46:25] <mfiano> register spilling is fun
[13:47:14] <beach> psycomic: But Scheme is special because of first-class continuations, so for Scheme, it may be a better choice to allocate activation records ("stack frames") on the heap.
[13:47:55] <psycomic> okay, thanks
[13:47:57] <MichaelRaskin> \\
[13:49:40] <mfiano> This is one of those times where I feel like I ought to learn/use Scheme more, not being familiar with first-class continuations at all. But I don't think I'd gain much by taking time away from CL :)
[13:50:02] *** Joins: Giddy (~Giddy@95.81.239.67)
[13:50:10] <MichaelRaskin> Well, first-class undelimited continuations _are_ a concept that you best learn in Scheme
[13:50:34] <psycomic> mfiano: continuations are very interesting, and provide a way to optimize function calls
[13:50:59] <mfiano> I admit I haven't read about CPS since compiler theory studies many years ago
[13:51:06] <mfiano> Before I knew about Lisp
[13:51:13] *** Quits: Giddy (~Giddy@95.81.239.67) (Client Quit)
[13:51:28] <psycomic> you also get free coroutines, exceptions and nondeterminism
[13:51:36] <beach> psycomic: I think you are confused.
[13:51:37] *** Joins: Hdka (~Hdka@95.81.239.67)
[13:51:44] <psycomic> how so?
[13:51:54] <beach> psycomic: How do first-class continuations make it possible to optimize function calls?
[13:52:15] *** Parts: Hdka (~Hdka@95.81.239.67) ()
[13:52:32] <psycomic> continuation passing style makes function calls simple gotos with arguments
[13:53:02] <beach> psycomic: But that has nothing to do with first-class continuations.  Only with whether the compiler optimized tail calls.
[13:54:15] <psycomic> in CPS, everything is a tail call
[13:55:45] <beach> You are not listening.  *First-class* continuations are what is special in Scheme, and is manifested by CALL-WITH-CURRENT-CONTINUATION, and that is what makes the implementation of invocation records a more complicated decision.
[13:56:30] <beach> psycomic: CPS can use an ordinary stack, and is used in Common Lisp implementations for representing intermediate code.
[13:56:49] <psycomic> yep, you're right i'm confused
[13:57:25] <psycomic> i missed the *first-class* in your sentence
[13:57:41] <psycomic> my bad
[14:04:07] <rain3> "This is one of those times where I feel like I ought to learn/use Scheme more, not being familiar with first-class continuations at all. But I don't think I'd gain much by taking time away from CL" but aren't delimited continuatios which we can use in CL more powerful than the universal continuations of Scheme? That's what I've heard
[14:04:14] *** Quits: cpu6502 (~textual@61.69.157.152) (Quit: Textual IRC Client: www.textualapp.com)
[14:04:57] <rain3> "delimited continuations are no less general than the regular ones. Regular continuations are also delimited, because they cannot capture control beyond the program's startup function. If we place a prompt at the top of the main function of the program and use that for making delimited continuations, we basically get regular continuations: continuations that can potentially return all the way to the top, just as far as regular
[14:04:57] <rain3> continuations. (We can even set it up so that if any such a delimited continuation does actually get that far, the process will exit.) Delimiting is actually an extra bit of expressive power, not a constraint."
[14:07:23] <rain3> '"Delimited" in continuations doesn't refer to a non-first-class hack. Delimited continuations are first-class, built-into-the-language objects (unless kludged otherwise, which is true of any continuations). They are just semantically nuanced relative to undelimited continuations in that they allow the program to clamp the future computation to within a specified dynamic contour. When the restarted continuation bubbles out to
[14:07:23] <rain3> that boundary, it terminates and returns a value to whomever dispatched the continuation. And of course, it can be called again and again to do the same thing. That's why delimited continuations behave like functions and are composable.'
[14:08:11] <beach> rain3: The point of Scheme-style first-class continuations is that you can invoke a continuation any number of times, with different inputs.
[14:09:02] <beach> rain3: That power also makes it semantically complicated.  Like do you re-open a file that was closed the first time you invoked the continuation when you invoke it a second time?
[14:09:27] <beach> rain3: Do you un-execute the UNWIND-PROTECT forms that were executed?
[14:10:21] <rain3> difficult problem, I have heard that's the reason CL chose not to have such continuations http://www.nhplace.com/kent/PFAQ/unwind-protect-vs-continuations-overview.html
[14:10:28] <beach> Yes.
[14:10:42] *** Quits: lisp-newbie (~lisp-newb@147.236.159.123) (Quit: This computer has gone to sleep)
[14:10:43] <beach> Another design decision that was very likely carefully considered.
[14:11:03] *** Joins: lisp-newbie (~lisp-newb@147.236.159.123)
[14:11:49] *** Joins: shka (~herr@109.231.62.239)
[14:11:53] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Ping timeout: 248 seconds)
[14:13:03] *** Joins: taiju (~taiju@240b:253:ec40:2400:e1d1:588c:bc3f:1887)
[14:16:39] <rain3> mfiano: you may enjoy implementing this technique in CL https://pages.lip6.fr/Christian.Queinnec/PDF/www.pdf , it is almost trivial (and maybe useful in some apps too , I haven't used it much yet but I think it's good to have it in the toolkit)
[14:25:26] *** Joins: random-nick (~random-ni@87.116.179.221)
[14:28:22] *** Quits: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431) (Quit: Leaving)
[14:31:50] *** Parts: pranavats (3fba1d1b34@jabberfr.org) ()
[14:33:07] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[14:35:32] *** Quits: nij- (~jin@2001-48F8-9021-806-0-0-0-14F5-dynamic.midco.net) (Ping timeout: 245 seconds)
[14:36:25] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 248 seconds)
[14:41:33] *** Quits: lisp-newbie (~lisp-newb@147.236.159.123) (Quit: This computer has gone to sleep)
[14:41:49] *** Joins: lisp-newbie (~lisp-newb@147.236.159.123)
[14:42:00] *** Quits: lisp-newbie (~lisp-newb@147.236.159.123) (Remote host closed the connection)
[14:42:10] *** Joins: lisp-newbie (~lisp-newb@147.236.159.123)
[14:42:21] *** Quits: lisp-newbie (~lisp-newb@147.236.159.123) (Remote host closed the connection)
[14:44:06] *** Joins: tfeb (~tfb@88.98.95.237)
[14:52:57] *** Quits: Qwnavery (~Qwnavery@user/qwnavery) (Ping timeout: 248 seconds)
[14:54:29] *** Joins: attila_lendvai (~alendvai@2a02:ab88:3707:bb00:5ee0:c5ff:feb2:29e2)
[14:55:02] *** Quits: pve (~pve@87-93-137-180.bb.dnainternet.fi) (Ping timeout: 268 seconds)
[14:58:40] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[15:01:17] *** Joins: treflip (~user@95.79.32.99)
[15:05:08] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[15:07:00] *** Quits: tfeb (~tfb@88.98.95.237) (Quit: died)
[15:08:25] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 248 seconds)
[15:10:53] *** Joins: Qwnavery (~Qwnavery@193-116-69-198.tpgi.com.au)
[15:11:05] *** Quits: Qwnavery (~Qwnavery@193-116-69-198.tpgi.com.au) (Changing host)
[15:11:05] *** Joins: Qwnavery (~Qwnavery@user/qwnavery)
[15:11:24] *** Parts: Qwnavery (~Qwnavery@user/qwnavery) ()
[15:13:32] *** Joins: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431)
[15:26:46] *** Quits: kuler (~kulernil@gateway/tor-sasl/kuler) (Remote host closed the connection)
[15:27:23] *** Joins: kuler (~kulernil@gateway/tor-sasl/kuler)
[15:29:37] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[15:32:38] *** Quits: hendursa1 (~weechat@user/hendursaga) (Remote host closed the connection)
[15:32:57] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 248 seconds)
[15:33:03] *** Joins: hendursa1 (~weechat@user/hendursaga)
[15:44:48] *** Joins: lisp-newbie (~lisp-newb@192.117.240.42)
[16:04:55] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[16:12:16] *** Joins: knobo (~knobo@c092BBF51.dhcp.as2116.net)
[16:29:53] *** Joins: nij- (~jin@2001-48F8-9021-806-0-0-0-85A7-dynamic.midco.net)
[16:31:06] *** Quits: rain3 (~rain3___@2a02:2f09:d30b:1300:514:bcc7:8202:1798) (Ping timeout: 256 seconds)
[16:47:39] *** Joins: frgo (~frgo@p200300deef0cee00588f7d35cd48dfd2.dip0.t-ipconnect.de)
[16:50:13] <mfiano> Thanks. I'll put it in my reading queue.
[16:55:24] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[17:01:28] *** Quits: gaqwas (~john@dynamic-095-117-104-051.95.117.pool.telefonica.de) (Remote host closed the connection)
[17:02:38] *** Quits: treflip (~user@95.79.32.99) (Remote host closed the connection)
[17:03:54] <lotuseater> mfiano: Is yours also as long as it nearly reaches earth's moon?
[17:05:27] <mfiano> Yes, and also my line of yaks waiting for a haircut reaches the horizon, and I have a recursive stove of back burners
[17:05:29] *** Quits: lisp-newbie (~lisp-newb@192.117.240.42) (Quit: This computer has gone to sleep)
[17:07:22] *** Joins: lisp-newbie (~lisp-newb@192.117.240.42)
[17:11:20] *** Quits: sander (~sander@user/sander) (Ping timeout: 256 seconds)
[17:13:06] <lotuseater> Would like to help, but I'm sure you're out of reach.
[17:13:10] *** Quits: amb007 (~a_bakic@cable-94-189-181-220.dynamic.sbb.rs) (Ping timeout: 268 seconds)
[17:13:36] *** Joins: amb007 (~a_bakic@net219-37-245-109.mbb.telenor.rs)
[17:13:36] *** Quits: amb007 (~a_bakic@net219-37-245-109.mbb.telenor.rs) (Read error: Connection reset by peer)
[17:14:40] <lisp-newbie> hi, how can I produce a symbol in a different package? https://quickref.common-lisp.net/alexandria.html#index-symbolicate
[17:14:52] <mfiano> INTERN
[17:15:39] *** Joins: sander (~sander@user/sander)
[17:15:50] *** Joins: amb007 (~a_bakic@87.116.175.34)
[17:18:12] <lisp-newbie> thanks,
[17:20:09] *** Quits: amb007 (~a_bakic@87.116.175.34) (Ping timeout: 248 seconds)
[17:20:22] *** Joins: amb007 (~a_bakic@net219-37-245-109.mbb.telenor.rs)
[17:28:06] *** Joins: gaqwas (~john@dynamic-095-117-104-051.95.117.pool.telefonica.de)
[17:28:06] *** Quits: gaqwas (~john@dynamic-095-117-104-051.95.117.pool.telefonica.de) (Remote host closed the connection)
[17:28:28] *** Joins: gaqwas (~john@dynamic-095-117-104-051.95.117.pool.telefonica.de)
[17:30:15] *** Quits: lisp-newbie (~lisp-newb@192.117.240.42) (Quit: This computer has gone to sleep)
[17:34:45] *** Quits: amb007 (~a_bakic@net219-37-245-109.mbb.telenor.rs) (Read error: Connection reset by peer)
[17:35:07] *** Joins: amb007 (~a_bakic@87.116.175.22)
[17:45:13] *** Quits: amb007 (~a_bakic@87.116.175.22) (Ping timeout: 268 seconds)
[17:46:04] *** Joins: amb007 (~a_bakic@net219-37-245-109.mbb.telenor.rs)
[17:52:12] *** Quits: attila_lendvai (~alendvai@2a02:ab88:3707:bb00:5ee0:c5ff:feb2:29e2) (Ping timeout: 245 seconds)
[17:52:40] *** Joins: Fare (~fare@2601:184:4a7f:995c:6673:ae1a:2c58:c2c5)
[17:52:46] *** Joins: rain3 (~rain3___@2a02:2f09:d30b:1300:514:bcc7:8202:1798)
[18:07:18] *** Joins: pve (~pve@178-55-175-93.bb.dnainternet.fi)
[18:07:47] *** Joins: Josh_2 (~user@37.25.47.130)
[18:10:10] *** Quits: hendursa1 (~weechat@user/hendursaga) (Quit: hendursa1)
[18:10:36] *** Joins: hendursaga (~weechat@user/hendursaga)
[18:11:49] <Josh_2> hi
[18:16:47] <beach> Hello Josh_2.
[18:18:45] *** Quits: gaqwas (~john@dynamic-095-117-104-051.95.117.pool.telefonica.de) (Remote host closed the connection)
[18:23:32] *** Joins: lisp123 (~lisp123@5.30.23.247)
[18:25:55] *** Quits: amb007 (~a_bakic@net219-37-245-109.mbb.telenor.rs) (Ping timeout: 268 seconds)
[18:27:20] <pve> I keep hearing about how the people who designed CL were smart and knowledgeable, and that is very reassuring. But I'm curious, is there anything they got wrong?
[18:27:45] <beach> Sure.
[18:27:53] <beach> For one thing, they ran out of time.
[18:27:54] <pve> I mean something that most experts would agree was a mistake
[18:28:00] <pve> oh
[18:28:58] <beach> Also the pathname module is not that great.  It might have been at the time, but should perhaps have been left out.
[18:30:36] <beach> It is also hard to distinguish mistakes from concessions to existing Lisp dialects.
[18:30:40] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[18:31:20] *** Joins: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3)
[18:31:24] *** Joins: gaqwas (~john@dynamic-095-117-104-051.95.117.pool.telefonica.de)
[18:31:44] <pve> beach: I can imagine
[18:32:16] <beach> pve: The work we started on WSCL is meant to fix the stuff that they likely would have fixed if they had not run out of time.
[18:32:44] *** Joins: amb007 (~a_bakic@net219-37-245-109.mbb.telenor.rs)
[18:32:46] <pve> beach: Yes, I've been following the discussion with one eye.
[18:33:19] <lotuseater> So the commitee got a deadline in 1984/94?
[18:33:21] <mfiano> beach: Oh, did you see the discussion yesterday about something I found should probably be included in WSCL?
[18:33:42] <beach> Briefly, yes.  I made a mental not of it.
[18:34:10] <beach> The "active elements in LOOP?
[18:34:16] <beach> "active elements"
[18:34:45] <mfiano> Yes. Currently it seems LOOP's ACROSS keyword is unspecified whether it iterates over inactive elements beyond a fill pointer
[18:34:55] <beach> lotuseater: I don't know.  I am just seeing all these things that I have no other explanation for, so I am guessing.
[18:35:00] *** Quits: Fare (~fare@2601:184:4a7f:995c:6673:ae1a:2c58:c2c5) (Ping timeout: 272 seconds)
[18:35:04] <beach> mfiano: Right.
[18:36:15] <lotuseater> Oh okay. As you also told a while ago, the standardization did cost much money.
[18:36:17] <mfiano> CLtL2 mentions something like "nearly everything except AREF" honor active elements only, but doesn't explicitly say how ACROSS is implemented, and this passage isn't in the HyperSpec at all.
[18:36:42] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[18:36:44] <lisp123> Is 5am the goto for unit testing, and does anyone have a good example repo to study when it comes to documentation / code organisation / testing?
[18:36:57] <lisp123> I remember one floating around but I forgot now
[18:38:20] <mfiano> lisp123: There is no go to unit testing library. See https://sabracrolleton.github.io/testing-framework
[18:38:46] <beach> lisp123: The existence of so many libraries makes me think the entire abstracting idea is wrong.
[18:39:16] <beach> *abstraction idea
[18:39:48] <lisp123> mfiano: thanks for the link
[18:40:01] <lisp123> beach: Sorry, I didn't quite follow
[18:42:35] *** Quits: amb007 (~a_bakic@net219-37-245-109.mbb.telenor.rs) (Ping timeout: 268 seconds)
[18:42:58] <lisp123> beach: Do you mean that the number of testing libraries indicates everyone tends to do their own for their own needs and its hard to abstract away?
[18:43:05] *** Joins: gin (~gin@user/gin)
[18:44:43] <gin> is it okay to type S-expression by hand into a file (foo.txt) and then load it using (with-open-file (in "foo.txt") (read in))? is this a good alternative for JSON?
[18:46:22] *** Joins: Fare (~fare@2601:184:4a7f:995c:6239:425f:2109:ce11)
[18:47:52] <mfiano> Whether it's better or not than JSON is easy: Yes. It's hard to say if it's a good idea for your project. It probably depends on how well you trust the source data, and whether you value compiler feedback earlier.
[18:50:48] <MichaelRaskin> Also, remember about #.
[18:50:50] <mfiano> Dynamically binding *READ-EVAL* can help with the former (though not completely).
[18:52:42] <pve> not completely?
[18:53:01] <mfiano> There's more that can blow up your image than evaluation.
[18:53:26] <mfiano> For example, what if the untrusted source included something like "1d999"
[18:54:02] <mfiano> Note: JSCL freezes the browser when this is read in the REPL.
[18:54:14] <pve> mfiano: oh ok, I thought you were referring to MichaelRaskin's comment about #. .. sorry
[18:54:19] <mfiano> Sandboxing CL is actually a fairly difficult problem without OS awareness
[18:54:46] <MichaelRaskin> Then it could create a cyclic data structure, which might be fine or not dependig on your expectations
[18:56:08] *** Quits: gaqwas (~john@dynamic-095-117-104-051.95.117.pool.telefonica.de) (Remote host closed the connection)
[18:56:26] <mfiano> Imagine a large file with just a string of digits, being read in as a bignum that exceeds the heap size
[18:57:55] *** Quits: Fare (~fare@2601:184:4a7f:995c:6239:425f:2109:ce11) (Ping timeout: 258 seconds)
[19:03:18] <pjb> mfiano: imagine a small network socket doing the same. at least for the large file you can use file-length to put a bound.
[19:03:46] <pjb> (unless *read-eval* is not nil).
[19:05:58] <mfiano> CLISP's arbitrary precision floats with a large exponent then :)
[19:06:38] *** Joins: gaqwas (~john@dynamic-095-117-104-051.95.117.pool.telefonica.de)
[19:09:48] <beach> lisp123: Yes.
[19:13:51] <lisp123> beach: Thanks
[19:43:50] *** Joins: lisp123_ (~lisp123@45.130.83.208)
[19:45:30] <gin> Thanks mfiano
[19:46:29] <gin> what I needed to know was if it is okay to type a s-exp file by hand and load it using (read file). seems to work fine. not aware of any gotchas.
[19:46:49] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 248 seconds)
[19:46:53] <gin> is there any popular extension name for such s-exp files?
[19:48:51] <mfiano> You mean, (read stream)? Sure
[19:49:23] <mfiano> Use .lisp
[19:49:34] <mfiano> So your and other editors can be aware of the proper editing mode
[19:49:53] <mfiano> others'*
[19:50:42] <beach> gin: You don't "load" a file by using READ.
[19:50:43] <mfiano> Or add the magic header comments for whatever editing environment you want to support
[19:51:04] <gin> mfiano: thanks
[19:51:07] <beach> gin: "loading" means reading it and evaluating the top-level forms.
[19:51:56] <gin> beach: okay, so READ only does the "read" part of read-eval-print-loop? if so, makes sense now.
[19:52:34] <gin> does the REPL also use the very same READ function to read s-exps?
[19:52:59] <mfiano> Depends on the REPL
[19:53:05] <mfiano> There is also read-from-string etc
[19:58:32] <rain3> (time->string 3837526002 :format :y-m-d-hour-min-sec) ; does the name of this function violate any style rule ?
[19:59:34] <mfiano> no?
[19:59:59] <lisp123_> rain3: looks good to me
[20:00:22] <lisp123_> sometimes I do time-to-string, but time->string is good too
[20:00:35] <mfiano> I tend not to name functions with programming language types though, and use words from the problem domain instead.
[20:00:53] <mfiano> Sometimes this cannot be helped, but I consider it a code smell in most cases.
[20:01:01] *** Quits: copec (~copec@206.214.226.4) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[20:01:06] <lisp123_> mfiano: my guess is in this case, he wants to convert time to strings so can't be helped
[20:01:34] <lisp123_> sort of like a utility function (probably from get-universal-time and into something easier to read)
[20:01:55] <rain3> thanks for the insights
[20:01:56] *** Joins: lisp-newbie (~lisp-newb@192.117.240.42)
[20:01:59] <mfiano> Well the name is still ambiguous.
[20:02:25] <mfiano> TIME doesn't say anything of the structure of the input, and string doesn't say anything about the structure of the output.
[20:03:04] <lisp123_> Do you have a suggestion?
[20:03:10] *** Joins: Alfr (~Alfr@user/alfr)
[20:03:49] <mfiano> Not really. These are questions I would ask when reading the code, especially if the documentation is not great.
[20:04:34] <lisp123_> perhaps "ISO-time-string"
[20:05:01] <lisp123_> I don't know, good luck rain3 :)
[20:05:12] <mfiano> I have no idea if it's a universal time or what. I would rely on the documentation if I couldn't infer that from great named functions.
[20:05:50] <rain3> it's general utility as lisp123_ said, a wrapper over get-universal-time
[20:06:06] <rain3> so nothing to worry much about
[20:06:41] <Josh_2> lisp123_: isn't this what local-time is for?
[20:07:24] <lisp123_> Josh_2: I was going to suggest rain3 also look at local-time, but tbh I found it easier to write my own utility from get-universal-time (I can't remember why) - local-time I think is good for more advanced cases
[20:07:42] <Josh_2> hmm
[20:07:52] <lisp123_> rain3: https://common-lisp.net/project/local-time/manual.html FYI
[20:08:01] <Josh_2> I use local-time everytime I want to represent time, or do any sort of computations with dates
[20:08:05] <lisp123_> (p.s. it would be good if a repl could be built into IRC) :D
[20:08:11] <Josh_2> its just super convenient
[20:08:16] <mfiano> As should everyone. It is a fantastic library.
[20:08:27] <Josh_2> Yehp
[20:09:47] <rain3> can local-time easily return strings in month-day-year or day-month-year or month.day.year (with dot) formats for example ?
[20:09:55] <mfiano> sure
[20:10:14] <lisp123_> rain3: https://common-lisp.net/project/local-time/manual.html#Parsing-and-Formatting
[20:10:31] <lisp123_> Depends on how much _time_ you have :D
[20:10:59] <lisp123_> If you just need a simple wrapper around get-universal-time, then just do that. But if you are working on a lot of time-sensitive things, might as well learn local-time
[20:11:24] <rain3> good to know about it
[20:11:56] <mfiano> (local-time:format-timestring nil (local-time:now) :format '(:month "." :day "." :year)) ; => "8.15.2021"
[20:15:38] <mfiano> It's very flexible, for example if you want to pad the components:
[20:15:44] <mfiano> (local-time:format-timestring nil (local-time:now) :format '((:month 2) #\. (:day 2) #\. :year))
[20:15:52] <mfiano> "08.15.2021"
[20:18:57] <lisp123_> Does anybody have an opinion on whether to define test systems in ASDF as a secondary system e.g. "foobar/test"
[20:19:11] <lisp123_> ASDF best practices seem to suggest the former but I am seeing examples of the latter
[20:20:29] <rain3> It would be useful to add those 2 examples by mfiano , to this page https://common-lisp.net/project/local-time/  or somewhere in the documentation
[20:24:26] *** Joins: john__ (~john@dynamic-095-117-104-051.95.117.pool.telefonica.de)
[20:27:31] <pjb> gin: you can use whatever extension you want. .sexp or .data or whatever.
[20:27:42] <gin> pjb: thanks
[20:29:21] <pjb> lisp123_: I just use foo.bar.test to test foo.bar, but foo-bar/test could be used too.
[20:29:25] *** Quits: lisp123_ (~lisp123@45.130.83.208) (Remote host closed the connection)
[20:30:22] *** Joins: lisp123 (~lisp123@45.130.83.208)
[20:32:23] *** Joins: lisp123_ (~lisp123@45.130.83.208)
[20:32:36] <lisp123_> pjb: thanks
[20:33:32] *** Quits: lisp123 (~lisp123@45.130.83.208) (Read error: Connection reset by peer)
[20:37:48] *** Quits: Aksej (~Aksej@picard.host.weltraumschlangen.de) (Quit: ZNC 1.7.2+deb3 - https://znc.in)
[20:45:39] *** Quits: john__ (~john@dynamic-095-117-104-051.95.117.pool.telefonica.de) (Quit: Leaving)
[20:49:07] *** Joins: lad (~lad@user/lad)
[20:51:19] <jmercouris> anyone know a way to get profiling beyond sb-profile:profile
[20:51:24] <jmercouris> I see how long my function takes
[20:51:30] <jmercouris> but what about the functions that my function calls?
[20:51:36] <jmercouris> I want to see how long those take as well
[20:51:56] <mfiano> You're looking for the statistical profiler. See the manual
[20:52:49] <jmercouris> I see
[20:53:07] <jmercouris> thanks for the tip, will look
[20:55:33] *** Joins: amb007 (~a_bakic@87.116.175.42)
[20:56:54] <lisp123_> Is there a way to force SLIME to load in the current window? Might be one of the most annoying things about Emacs not having decent behaviour for new buffers..
[20:57:16] <lisp123_> slime-repl* that is
[20:57:54] <lisp123_> Maybe I should just write some elisp to switch current buffer to *slime-repl sbcl*...will try that out now
[20:59:01] <mfiano> That is one thing Sly handles better, but no, Emacs window management is hard to tame without things like purpose.el
[21:01:38] <lisp123_> https://pastebin.com/xVkw2GEU
[21:02:18] <lisp123_> If anybody is interested - the above works when slime is already loaded, just press C-c s to switch to it in the current buffer
[21:02:30] <lisp123_> current window*
[21:03:06] *** Quits: amb007 (~a_bakic@87.116.175.42) (Ping timeout: 256 seconds)
[21:04:58] *** Joins: amb007 (~a_bakic@net219-37-245-109.mbb.telenor.rs)
[21:13:07] *** Quits: gaqwas (~john@dynamic-095-117-104-051.95.117.pool.telefonica.de) (Remote host closed the connection)
[21:14:02] *** Quits: lisp-newbie (~lisp-newb@192.117.240.42) (Quit: This computer has gone to sleep)
[21:15:04] *** Joins: khrbt_ (~znc@user/khrbt)
[21:15:54] *** Quits: khrbt (~znc@user/khrbt) (Ping timeout: 258 seconds)
[21:26:33] *** Quits: amb007 (~a_bakic@net219-37-245-109.mbb.telenor.rs) (Read error: Connection reset by peer)
[21:28:16] *** Joins: amb007 (~a_bakic@cable-94-189-181-220.dynamic.sbb.rs)
[21:29:54] *** Joins: gaqwas (~john@dynamic-095-117-104-051.95.117.pool.telefonica.de)
[21:46:16] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 272 seconds)
[21:47:11] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[21:47:56] *** Quits: char (~charles@cpe-76-186-124-165.tx.res.rr.com) (Remote host closed the connection)
[22:04:07] *** Joins: blihp (~phil@c-68-43-233-92.hsd1.mi.comcast.net)
[22:14:55] <Josh_2> Is there a library around that will verify a file is the mimetype it claims to be?
[22:15:03] <Josh_2> Specifically images
[22:20:36] <mfiano> That is not really a solved problem period.
[22:21:02] <Josh_2> Sure but checking the header of a file is better than not
[22:21:03] <mfiano> Usually the magic bytes in the header of a binary file are few and easy to have false positives.
[22:23:14] <Josh_2> What do you suggest I do? Just dont worry and make sure nothing is arbitrarily executed?
[22:23:59] <mfiano> Probably easiest to just use uiop to call file(1)
[22:24:38] <mfiano> The hard part isn't reading the file from lisp. It's knowing where and how much to read, and what to compare the results with
[22:26:25] <mfiano> It's hard to say. I don't know what you are trying to do. If it's one file format, construct a full parse tree for you to type check :)
[22:26:49] <Josh_2> Its not one file format ;(
[22:27:48] <Josh_2> currently its png, gif, jpeg and zip, but its so easy to add new file types that I plan on adding compressed formats
[22:27:53] <Josh_2> adding other*
[22:29:42] <pjb> Josh_2: it's compounded by the problem that reading and validating any file format may also involve security bugs, and executing random code…
[22:30:00] <pjb> Josh_2: (hence termination problem, hence unsolved problem).
[22:30:14] <mfiano> Try loading them with opticl, chipz, or whatever and hope they have conditions to catch
[22:30:28] <Josh_2> I think that might be what I have to do
[22:31:16] <Josh_2> Thats basically what my system would do right now anyway because images are resized by imagemagick, so if they arent images then imagemagick will have a fit
[22:32:37] <mfiano> This problem isn't possible to solve, really.
[22:32:53] <mfiano> Mostly because anyone can create a file format, and implementors often get them wrong
[22:33:03] <mfiano> Ever try parsing a later revision of MP3's ID3?
[22:33:04] <Josh_2> Yes I understand
[22:33:27] <mfiano> There are literally thousands of non-standard files, and a useful player has to support all the hacks to make them load
[22:33:41] <mfiano> err thousands of variants
[22:33:53] <mfiano> This is why web standards are a joke with browser wars and all
[22:34:00] <Josh_2> Right
[22:34:21] <Josh_2> I will just go with trying to open them with the relevant libraries/external programs and handle conditions
[22:34:24] <Josh_2> Thanks for the info :)
[22:36:01] <mfiano> Imagine a world where a Lisp implementation just has to be close to standard conforming, where "close" is up to the implementor :)
[22:36:48] <mfiano> Luckily we all care about CL conformance enough to not make mistakes many others have
[22:37:51] <lisp123_> Is there a way to confirm if a program is compliant with ANSI CL?
[22:38:04] <lisp123_> I guess the issue is there are parts that are undefined
[22:40:22] <pjb> lisp123_: the best way would be to run this program on all implementations and check that you get the same results.
[22:40:28] <lisp123_> So to rephrase, is there a way to confirm a program is compliant with ANSI CL, once accounting for all undefined parts of the standard that are left up to the implementors choice
[22:40:51] <lisp123_> pjb: Yes, that I agree. But I wonder if its possible to check a program and all its dependencies against the Standard
[22:41:09] <lotuseater> so *all* implementations :D
[22:41:32] <pjb> not really, because you can still use operators that have implementation specific behavior, but the checking of the results depends on the specifications of the program.
[22:43:07] <lisp123_> pjb: Understood, thanks
[22:43:13] <pjb> For example (defun main () (print (length (lisp-implementation-type)))) (main) will print an integer with different values. What are the specifications of this program?
[22:43:52] <pjb> If the specification is to print SOME integer representing the lenght of the implementation type string, then it's ok and conforming. If the spec is to print 4, then it works only in sbcl, therefore it's not conforming.
[22:44:23] <lisp123_> I was wondering if one could split the evaluation into parts that are per the standard, and into parts that are implementation dependent
[22:44:31] <lisp123_> But I guess its too tall of an ask
[22:44:43] <mfiano> Also note that no implementation is fully conforming, so code you write likely will not be either.
[22:45:12] <mfiano> A prime example is the many errors with MIT LOOP, which most implementations derive from
[22:46:14] <lisp123_> Thanks
[22:46:30] <pjb> lisp123_: definitely. But this is unrelated to the conformity property of a program.
[22:46:50] <pjb> As my exemple demonstrate, conformity depends on the specifications of the program.
[22:47:02] *** Joins: boeg (sid41541@id-41541.tinside.irccloud.com)
[22:47:30] <boeg> How would i go about filtering out non-alphanumerical characters in a string?
[22:47:37] <mfiano> remove-if-not
[22:47:43] <boeg> ah
[22:47:44] <pjb> Now, perhaps you can perform some static analysis of CL code and determine that some expressions are conforming in the absolute.
[22:47:47] <boeg> mfiano:
[22:47:51] <boeg> mfiano: thanks
[22:48:03] <pjb> lisp123_: ^ but I'd guess very few of them would be tagged as such.
[22:48:47] <mfiano> boeg: (remove-if-not #'alphanumericp "hello-world-123") ;=> "helloworld123"
[22:48:47] <lisp123_> pjb: Yes, that's what I was thinking. But I agree with you that very few would be tagged as such I guess - if a return value is implementation dependent, then any function calling that would also be 'tainted'
[22:49:05] <pjb> lisp123_: For example, (= 42 (answer-to-the-big-question-of-the-universe-and-all))  will return an implementation-specific value.  Even if the function answer-to-the-big-question-of-the-universe-and-all is 100% conforming at all step, the final result is not the same on all implementations.
[22:49:30] <pjb> lisp123_: = returns a generalized boolean, not T or NIL.  So the actual result can vary from implementation to implementation.
[22:49:33] <lotuseater> boeg: and #'alphanumericp :)
[22:49:44] <mfiano> lotuseater: like i said
[22:49:55] <boeg> :)
[22:50:13] <lotuseater> oh damn, sorry mfian
[22:50:18] <pjb> To have an expression that would definitely be conforming whatever its specifications and the implementation, you'd have to do a lot of extra work, such as (not (not (= 42 (answer-to-the-big-question-of-the-universe-and-all))))
[22:50:22] <lotuseater> i overread that
[22:50:23] <lisp123_> pjb: Damn, something as basic as #'= can cause such (subtle) variations :(
[22:50:34] <pjb>  and prove that answer-to-the-big-question-of-the-universe-and-all returns the same on all implementations.
[22:50:39] <lotuseater> but i remember back when i missed filter
[22:51:25] <lisp123_> Possibly a good LaaS (Lisp as a Service) would be to take some code and test it in every implementation
[22:51:45] <lisp123_> pjb: Thanks for the insight
[22:51:57] <pjb> The point about generalized booleans is that in general, it doesn't matter, since you just test the result and go on.
[22:53:02] <lotuseater> but surely one can do (setf (symbol-function 'filter) #'remove-if-not) if it should provide the same API with its key args
[22:53:06] <pjb> But the program you will write to determine if an expression is conforming in the absolute, won't be very stable (and you need to solve or avoid the termination problem).
[22:53:44] <mfiano> lotuseater: But..but..but
[22:53:48] <pjb> lisp123_: the tainting depends on what the calling function does of the result. So it can be processed.
[22:53:48] <lisp123_> Can you expand on the last part?
[22:53:58] <mfiano> REMOVE-IF-NOT is DEPRECATED. We have to be prepared for the next standard!
[22:54:05] <lotuseater> mfiano: yes I know :D
[22:54:11] <lotuseater> it is? o_O
[22:54:29] <pjb> lisp123_: basically, I'd expect the program to determine, yes, no, yes, no, yes, no, etc or about, for each embedded subexpression.
[22:54:41] <mfiano> remove-if/complement solves that, for whoever the hell cares
[22:54:42] <pjb> (conforming (not-conforming (conforming (not-conforming …))))
[22:54:42] <lotuseater> one must be careful and think when to use remove-if or remove-if-not
[22:54:47] <mfiano> Lisp ain't changing, so I don't
[22:54:56] <lotuseater> yes and that is wonderful!
[22:55:25] <lisp123_> pjb: Yes. So by 'termination problem' do you mean any potential issues with recursion?
[22:55:35] <pjb> or loops.
[22:55:36] <mfiano> to be honest, I find the "filter" terminology ambiguous
[22:55:49] <mfiano> am i filtering out stuff, or what?
[22:55:49] <lisp123_> THanks, understood
[22:55:55] <mfiano> i never liked that term :)
[22:55:56] <lisp123_> Appreciate it
[22:56:05] <pjb> lisp123_: and then, real programs use extensions such as threads, gray streams, sockets, etc…
[22:56:15] <lisp123_> mfiano: Worst part is I don't think there is an official function for filter :S
[22:56:23] <pjb> But you can still write a conforming program but it's even harder to prove it.
[22:56:46] <mfiano> lisp123_: we mentioned it is remove-if-not, a much better name
[22:56:52] <lotuseater> yes and I was used to filter in Haskell before, it just takes a lambda and a list
[22:57:11] <pjb> (defun filter (predicate list) (remove-if-not predicate list))
[22:57:15] <pjb> be happy!
[22:57:31] <akater[m]> I hope `-if-not` functions don't get wiped.  `:test-not` probably should go but functions are fine.
[22:57:35] <lisp123_> pjb: For that I was thinking of applying the same conforming test to those extensions (but after this discussion I agree that this idea of conformance checking is not feasible)
[22:57:40] <lotuseater> lisp123_: you can do as you please in your personal packages or utility libs of course :)
[22:58:50] <akater[m]> pjb: Is `(setf (fdefinition 'filter) #'remove-if-not)` not recommended?
[22:58:57] <lisp123_> lotuseater: Indeed. Right now I don't have a filter function there, I forgot how I did when I need it
[22:59:05] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 252 seconds)
[22:59:23] <lotuseater> akater[m]: the example of pjb hides away the keywords
[22:59:38] <mfiano> (remove-if (complement #'alphabumericp) string)
[22:59:45] <mfiano> there, no remove-if-not
[23:00:09] <mfiano> (not even indirectly)
[23:00:25] <pjb> lisp123_: but in practice, if you run your program on several implementations and find the same results, you're quite good.
[23:00:30] <lotuseater> lisp123_: or sometimes when one needs TAKE-WHILE and DROP-WHILE
[23:00:43] <pjb> lisp123_: do as in the shuttle: have 5 different implementations, and let them vote for the results.
[23:00:48] <lotuseater> ooh right, COMPLEMENT
[23:01:16] *** Joins: lisp-newbie (~lisp-newb@192.117.240.42)
[23:01:32] <lisp123_> pjb: Indeed :)
[23:01:33] *** Quits: retropikzel (~retropikz@2001:999:200:1f35:416a:ba48:25b6:f78f) (Quit: Leaving)
[23:01:49] <pjb> akater[m]: you can do it, (setf fdefinition), but the compiler wouldn't know it's a function, so it would keep warning about undefined function filter.
[23:02:15] <pjb> akater[m]: you'd have to add a (declaim (ftype (function (t t) t) filter))
[23:02:54] *** Quits: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3) (Ping timeout: 272 seconds)
[23:03:55] <lotuseater> or more declaiming that the first argument is a boolean function ^^
[23:04:31] <pjb> No that would be an error. (filter 42 'foo) will signal an error. If you declare that the first argument is a function, then (filter 42 'foo) may crash.
[23:05:07] <lotuseater> ah so remove-if-not can also do that
[23:05:20] <lotuseater> I wasn't aware of that detail.
[23:06:26] <lotuseater> ah i think it's because everything except nil has ⊤ as superclass
[23:06:54] <pjb> (typep 'nil 't) #| --> t |#  (subtypep 'nil 't) #| --> t ; t |#
[23:07:05] <lotuseater> ha.
[23:07:32] <lotuseater> also more flexible
[23:11:37] <lotuseater> ⊤ and ⊥ :)
[23:17:47] <akater[m]> lotuseater: “function designator” is the proper term but there is no such type by default.
[23:17:53] *** Joins: Fare (~fare@2601:184:4a7f:995c:ccdd:65c8:2890:7f7d)
[23:18:43] <lotuseater> okay
[23:20:45] <jmercouris> mfiano: don’t get me started talking about web standards
[23:20:52] <jmercouris> You’ll throw me into a blind rage
[23:21:23] <lotuseater> jmercouris: there are serious web standards? :D (of course there are)
[23:21:44] <jmercouris> Are there though?
[23:21:56] <jmercouris> The only one I take seriously is http
[23:22:21] <lotuseater> yes I mean such things that are there for a long time
[23:22:48] <lotuseater> and of course the great standardized javascript and its frameworks
[23:30:23] *** Quits: lisp-newbie (~lisp-newb@192.117.240.42) (Quit: This computer has gone to sleep)
[23:30:36] *** Joins: lisp-newbie (~lisp-newb@192.117.240.42)
[23:30:36] *** Quits: lisp-newbie (~lisp-newb@192.117.240.42) (Client Quit)
[23:31:33] <Josh_2> Does anyone know how I can generate output like <style scoped> ... </style> with spinneret?
[23:32:05] <Josh_2> Closest I have gotten is <style scoped=''> ... </style> which doesn't work :(
[23:36:40] *** Joins: attila_lendvai (~alendvai@catv-86-101-74-70.catv.broadband.hu)
[23:38:54] <gin> Is there a way to make quicklisp write to a .cache/ directory I specify?
[23:46:43] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[23:59:16] *** Quits: rain3 (~rain3___@2a02:2f09:d30b:1300:514:bcc7:8202:1798) (Ping timeout: 272 seconds)
