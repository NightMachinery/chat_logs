[00:05:52] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[00:06:23] *** Joins: dre (~dre@2001:8003:c932:c301:b2f8:56ee:c2d1:3969)
[00:07:05] *** Quits: srhm (~srhm@user/srhm) (Read error: Connection reset by peer)
[00:07:37] *** Joins: srhm (~srhm@user/srhm)
[00:12:55] *** Quits: Inline (~Inline@2a02:908:1252:7a80:98b1:ebcb:2d91:63eb) (Ping timeout: 260 seconds)
[00:13:56] *** Quits: casionaut (~casionaut@user/casionaut) (Quit: o7)
[00:14:56] *** Quits: paule32 (~paule32@user/paule32) (Quit: Leaving)
[00:23:05] *** Joins: dre_ (~dre@120.156.30.159)
[00:25:17] *** Quits: charro (~rcharles@pool-100-16-139-7.washdc.fios.verizon.net) (Ping timeout: 264 seconds)
[00:25:58] *** Quits: dre (~dre@2001:8003:c932:c301:b2f8:56ee:c2d1:3969) (Ping timeout: 268 seconds)
[00:28:07] *** Joins: akoana (~ah@user/akoana)
[00:35:44] *** Parts: pranavats (3fba1d1b34@jabberfr.org) ()
[00:46:01] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[01:05:44] *** Quits: shka (~herr@83.175.151.96.piasta.pl) (Ping timeout: 258 seconds)
[01:09:41] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 264 seconds)
[01:10:10] *** Quits: Qwnavery (~Qwnavery@user/qwnavery) (Quit: WeeChat 3.3)
[01:20:11] *** Quits: theBlackDragon (~dragon@fvwm/admin) (Ping timeout: 246 seconds)
[01:20:25] *** Joins: theBlackDragon (~dragon@fvwm/admin)
[01:34:11] *** Quits: aartaka (aartaka@gateway/vpn/protonvpn/aartaka) (Ping timeout: 260 seconds)
[01:43:16] *** Quits: attila_lendvai (~alendvai@catv-176-63-5-138.catv.broadband.hu) (Ping timeout: 268 seconds)
[01:49:11] *** Quits: cage (~cage@dynamic-adsl-84-220-249-98.clienti.tiscali.it) (Quit: rcirc on GNU Emacs 27.1)
[01:51:23] *** Quits: LoopMacro (~LoopMacro@c-24-22-157-127.hsd1.wa.comcast.net) (Ping timeout: 264 seconds)
[02:01:58] *** Joins: Inline (~Inline@2a02:908:1252:7a80:ecd:fc0d:36b6:b42b)
[02:18:30] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[02:20:55] *** Quits: Inline (~Inline@2a02:908:1252:7a80:ecd:fc0d:36b6:b42b) (Quit: Leaving)
[02:21:47] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 260 seconds)
[02:22:06] *** Joins: Inline (~Inline@2a02:908:1252:7a80:ecd:fc0d:36b6:b42b)
[02:23:29] *** Joins: Yehowshua (~Yehowshua@2601:c9:8000:14b8:843c:4bf2:b79e:94f0)
[02:28:03] *** Quits: lottaquestions_ (~nick@2607:fa49:5041:a200:1dd8:c34c:18ca:32be) (Quit: Konversation terminated!)
[02:33:00] *** Quits: lotuseater (~user@p200300e7871bd300c158d62dc7544d08.dip0.t-ipconnect.de) (Ping timeout: 268 seconds)
[02:37:01] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Remote host closed the connection)
[02:37:15] *** Joins: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3)
[02:46:20] *** Quits: igemnace (~ian@user/igemnace) (Ping timeout: 260 seconds)
[02:49:11] *** Joins: Qwnavery (~Qwnavery@user/qwnavery)
[02:50:34] *** Quits: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3) (Quit: ERC (IRC client for Emacs 27.1))
[02:56:56] *** Joins: X-Scale` (~ARM@83.223.251.139)
[02:57:03] *** Quits: random-nick (~random-ni@87.116.179.142) (Ping timeout: 268 seconds)
[02:57:40] *** Quits: X-Scale (~ARM@50.77.166.178.rev.vodafone.pt) (Ping timeout: 268 seconds)
[02:58:56] *** X-Scale` is now known as X-Scale
[02:59:47] *** Quits: Inline (~Inline@2a02:908:1252:7a80:ecd:fc0d:36b6:b42b) (Ping timeout: 264 seconds)
[03:04:15] *** Quits: srhm (~srhm@user/srhm) (Read error: Connection reset by peer)
[03:04:58] *** Joins: srhm (~srhm@user/srhm)
[03:14:35] *** Joins: charro (~rcharles@pool-100-16-139-7.washdc.fios.verizon.net)
[03:18:59] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Ping timeout: 264 seconds)
[03:27:09] *** Joins: igemnace (~ian@user/igemnace)
[03:27:18] *** Joins: Guest-liao (~Guest-lia@101.86.103.113)
[03:30:03] *** Quits: igemnace (~ian@user/igemnace) (*.net *.split)
[03:30:03] *** Quits: Qwnavery (~Qwnavery@user/qwnavery) (*.net *.split)
[03:30:03] *** Quits: theBlackDragon (~dragon@fvwm/admin) (*.net *.split)
[03:30:03] *** Quits: frgo (~frgo@p548a30d7.dip0.t-ipconnect.de) (*.net *.split)
[03:30:03] *** Quits: molson (~molson@2001-48F8-704A-CA1-0-0-75F-1046-static.midco.net) (*.net *.split)
[03:30:03] *** Quits: raeda (~raeda@72.49.219.33) (*.net *.split)
[03:30:03] *** Quits: terrorjack (~terrorjac@static.3.200.12.49.clients.your-server.de) (*.net *.split)
[03:30:03] *** Quits: rgherdt (~rgherdt@2a02:8109:86c0:d8d:b8f0:f2c4:2c4e:e90a) (*.net *.split)
[03:30:03] *** Quits: snits_ (~quassel@ip98-179-76-75.ph.ph.cox.net) (*.net *.split)
[03:30:03] *** Quits: fengshaun_ (~fengshaun@S010680615f0c2c0a.cg.shawcable.net) (*.net *.split)
[03:30:03] *** Quits: pieguy128_ (~pieguy128@bras-base-mtrlpq5031w-grc-48-67-70-102-17.dsl.bell.ca) (*.net *.split)
[03:30:03] *** Quits: sander (~sander@user/sander) (*.net *.split)
[03:30:03] *** Quits: mmk2410_ (~mmk2410@mmk2410.org) (*.net *.split)
[03:30:03] *** Quits: jmercouris (sid438340@id-438340.hampstead.irccloud.com) (*.net *.split)
[03:30:03] *** Quits: mister_m (~user@c-73-110-154-209.hsd1.il.comcast.net) (*.net *.split)
[03:30:03] *** Quits: stylewarning (sid241636@id-241636.helmsley.irccloud.com) (*.net *.split)
[03:30:03] *** Quits: minion (~minion@common-lisp.net) (*.net *.split)
[03:30:03] *** Quits: sp (~sp@user/susam) (*.net *.split)
[03:30:03] *** Quits: jgkamat (~jay@user/jay) (*.net *.split)
[03:30:03] *** Quits: saturn2 (~visitant@user/clone-of-saturn/x-1551297) (*.net *.split)
[03:30:03] *** Quits: travv0 (sid293381@user/travv0) (*.net *.split)
[03:30:03] *** Quits: Odin- (~odin@cybernetic.anarchism.is) (*.net *.split)
[03:30:03] *** Quits: cognemo (~cognemo@cpe-46-164-24-121.dynamic.amis.net) (*.net *.split)
[03:30:03] *** Quits: defaultxr (~defaultxr@99-138-110-241.lightspeed.cicril.sbcglobal.net) (*.net *.split)
[03:30:04] *** Quits: totoro (~totoro@user/totoro) (*.net *.split)
[03:30:04] *** Quits: jemoka (~jemoka@user/jemoka) (*.net *.split)
[03:30:09] *** Quits: specbot (~specbot@common-lisp.net) (Remote host closed the connection)
[03:30:24] *** Joins: mmk2410 (~mmk2410@mmk2410.org)
[03:30:25] *** Joins: rgherdt (~rgherdt@2a02:8109:86c0:d8d:1581:8730:7925:b76d)
[03:30:26] *** Joins: Qwnavery (~Qwnavery@220.240.248.227)
[03:30:29] *** Joins: stylewarning (sid241636@id-241636.helmsley.irccloud.com)
[03:30:37] *** Joins: snits (~quassel@ip98-179-76-75.ph.ph.cox.net)
[03:30:37] *** Joins: jmercouris (sid438340@id-438340.hampstead.irccloud.com)
[03:30:43] *** Joins: travv0 (sid293381@helmsley.irccloud.com)
[03:30:45] *** Quits: mmk2410 (~mmk2410@mmk2410.org) (Changing host)
[03:30:45] *** Joins: mmk2410 (~mmk2410@user/mmk2410)
[03:30:47] *** Joins: igemnace (~ian@112.202.85.161)
[03:30:48] *** Joins: Odin- (~odin@cybernetic.anarchism.is)
[03:30:50] *** Quits: Qwnavery (~Qwnavery@220.240.248.227) (Changing host)
[03:30:50] *** Joins: Qwnavery (~Qwnavery@user/qwnavery)
[03:31:01] *** Joins: defaultxr (~defaultxr@99-138-110-241.lightspeed.cicril.sbcglobal.net)
[03:31:23] *** Quits: travv0 (sid293381@helmsley.irccloud.com) (Changing host)
[03:31:23] *** Joins: travv0 (sid293381@user/travv0)
[03:31:33] *** Joins: specbot (~specbot@common-lisp.net)
[03:31:33] *** Joins: minion (~minion@common-lisp.net)
[03:31:50] *** Joins: cognemo (~cognemo@cpe-46-164-24-121.dynamic.amis.net)
[03:31:53] *** Joins: pieguy128 (~pieguy128@bas1-quebec14-67-70-102-17.dsl.bell.ca)
[03:32:03] *** Joins: frgo (~frgo@p548a30d7.dip0.t-ipconnect.de)
[03:32:09] *** Joins: saturn2 (~visitant@user/clone-of-saturn/x-1551297)
[03:32:10] *** Joins: molson (~molson@2001-48F8-704A-CA1-0-0-75F-1046-static.midco.net)
[03:32:19] *** Joins: sander (~sander@user/sander)
[03:32:21] *** Joins: totoro (~totoro@173.82.187.126)
[03:32:23] *** Quits: Qwnavery (~Qwnavery@user/qwnavery) (Client Quit)
[03:32:24] *** Quits: totoro (~totoro@173.82.187.126) (Changing host)
[03:32:24] *** Joins: totoro (~totoro@user/totoro)
[03:32:26] *** Joins: jgkamat (~jay@user/jay)
[03:32:28] *** Joins: fengshaun (~fengshaun@S010680615f0c2c0a.cg.shawcable.net)
[03:32:28] *** Joins: jemoka (~jemoka@user/jemoka)
[03:32:31] *** Joins: raeda (~raeda@72.49.219.33)
[03:32:45] *** Joins: Qwnavery (~Qwnavery@user/qwnavery)
[03:32:50] *** Joins: terrorjack (~terrorjac@static.3.200.12.49.clients.your-server.de)
[03:32:58] *** Joins: sp (~sp@user/susam)
[03:35:23] *** Joins: theBlackDragon (~dragon@fvwm/admin)
[03:49:51] *** Quits: Yehowshua (~Yehowshua@2601:c9:8000:14b8:843c:4bf2:b79e:94f0) (Ping timeout: 256 seconds)
[03:49:59] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 260 seconds)
[03:51:30] *** Joins: Lord_of_Life (~Lord@user/lord-of-life/x-2819915)
[03:56:05] *** Quits: Guest-liao (~Guest-lia@101.86.103.113) (Ping timeout: 256 seconds)
[03:57:42] *** Joins: Guest-liao (~Guest-lia@101.86.103.113)
[04:03:15] *** Quits: jasom (~aidenn@2600:8802:7fa0:500:f833:278f:1567:d354) (Ping timeout: 268 seconds)
[04:06:52] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[04:09:40] *** Joins: mfiano (~user@2603-7081-2d02-95bd-0250-b6ff-fef3-da40.res6.spectrum.com)
[04:11:06] *** Quits: mfiano (~user@2603-7081-2d02-95bd-0250-b6ff-fef3-da40.res6.spectrum.com) (Remote host closed the connection)
[04:11:47] *** Joins: mfiano (~user@2603-7081-2d02-95bd-0250-b6ff-fef3-da40.res6.spectrum.com)
[04:15:09] *** Joins: jasom (~aidenn@2600:8802:7fa0:500:f833:278f:1567:d354)
[04:15:35] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[04:29:16] *** Quits: robin (~robin@user/terpri) (Ping timeout: 245 seconds)
[04:29:58] *** Joins: Yehowshua (~Yehowshua@2601:c9:8000:14b8:843c:4bf2:b79e:94f0)
[04:30:39] *** Joins: robin (~robin@user/terpri)
[04:34:31] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 265 seconds)
[04:36:17] *** Joins: aeth (~aeth@user/aeth)
[04:36:21] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Ping timeout: 245 seconds)
[04:39:27] *** Joins: taiju (~taiju@240b:253:ec40:2400:ac8a:e88c:83e1:ca6d)
[04:41:39] *** Quits: igemnace (~ian@112.202.85.161) (Remote host closed the connection)
[04:51:51] *** Joins: Guest7490 (~Guest74@modemcable110.164-177-173.mc.videotron.ca)
[04:52:17] <Guest7490> Hi. Has anybody implemented the SANE network protocol in lisp?
[04:54:13] *** Quits: brettgilio (~brettgili@x-node.gq) (Quit: Leaving...)
[04:54:13] *** Quits: herlocksholmes (~herlocksh@x-node.gq) (Quit: Leaving...)
[04:56:37] *** Joins: herlocksholmes (~herlocksh@x-node.gq)
[04:56:58] *** Joins: brettgilio (~brettgili@x-node.gq)
[04:57:51] *** Quits: Guest-liao (~Guest-lia@101.86.103.113) (Ping timeout: 256 seconds)
[05:04:47] *** Quits: raeda (~raeda@72.49.219.33) (Quit: Leaving)
[05:07:35] *** Quits: Qwnavery (~Qwnavery@user/qwnavery) (Quit: WeeChat 3.3)
[05:23:11] *** Quits: taiju (~taiju@240b:253:ec40:2400:ac8a:e88c:83e1:ca6d) (Ping timeout: 264 seconds)
[05:25:13] *** Quits: Bike (~Glossina@71.69.170.70) (Quit: Lost terminal)
[05:27:29] *** Joins: Guest-liao (~Guest-lia@101.86.103.113)
[05:28:24] *** Joins: ahc71 (~ahc@121.98.229.241)
[05:30:13] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[05:42:43] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[05:53:01] *** Quits: Guest7490 (~Guest74@modemcable110.164-177-173.mc.videotron.ca) (Ping timeout: 245 seconds)
[05:57:13] *** Joins: Qwnavery (~Qwnavery@user/qwnavery)
[06:00:13] *** Quits: Qwnavery (~Qwnavery@user/qwnavery) (Client Quit)
[06:15:29] *** Quits: Yehowshua (~Yehowshua@2601:c9:8000:14b8:843c:4bf2:b79e:94f0) (Ping timeout: 256 seconds)
[06:16:33] *** Joins: Oladon (~olad@98.43.81.226)
[06:30:29] *** Quits: rogersm (~rogersm@90.166.177.48) (Read error: Connection reset by peer)
[06:30:35] *** Joins: rogersm_ (~rogersm@90.166.177.48)
[06:30:37] <beach> Good morning everyone!
[06:39:51] *** Quits: Guest-liao (~Guest-lia@101.86.103.113) (Ping timeout: 256 seconds)
[06:45:50] *** Quits: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se) (Ping timeout: 268 seconds)
[06:50:46] *** Joins: Guest-liao (~Guest-lia@101.86.103.113)
[06:53:34] *** Joins: lottaquestions (~nick@2607:fa49:5041:a200:e4df:eb9a:d895:20c9)
[07:07:34] *** Joins: ebrasca (~user@librepanther.com)
[07:11:35] *** Quits: Guest-liao (~Guest-lia@101.86.103.113) (Ping timeout: 256 seconds)
[07:19:03] *** Quits: semz (~none@user/semz) (Ping timeout: 260 seconds)
[07:31:47] *** Joins: semz (~none@user/semz)
[07:41:43] *** Quits: hendursaga (~weechat@user/hendursaga) (Remote host closed the connection)
[07:44:05] *** Joins: hendursaga (~weechat@user/hendursaga)
[07:45:32] *** Quits: semz (~none@user/semz) (Ping timeout: 246 seconds)
[07:46:30] *** Parts: akoana (~ah@user/akoana) ()
[07:51:56] *** Quits: ebrasca (~user@librepanther.com) (Remote host closed the connection)
[07:58:10] *** Joins: Guest-liao (~Guest-lia@101.86.103.113)
[07:58:29] *** Joins: semz (~none@user/semz)
[08:06:23] *** Quits: Skyfire (~pyon@user/pyon) (Quit: WeeChat 3.3)
[08:39:04] *** Joins: lisp123 (~lisp123@5.30.23.247)
[08:40:33] *** Quits: Guest-liao (~Guest-lia@101.86.103.113) (Ping timeout: 256 seconds)
[08:41:55] *** Joins: dec0d3r (~dec0d3r@2001:8003:480a:e00:e07:e7c3:7efc:ed0f)
[08:41:59] <lisp123> At what stage should one start adding error checking and conditions to code?
[08:42:46] <lisp123> Its a lot of burden at earlier stages of prototyping, and many internal functions don't need them because their inputs & outputs are somewhat certain
[08:42:55] <lisp123> But of course once you get to the user input stage, its very important
[08:43:02] <beach> I would say "as early as possible", and most of the checking should be at the protocol level so that errors don't propagate and make debugging harder.
[08:43:27] <beach> Yes, you don't do error checking for "internal" functions.
[08:44:04] <lisp123> beach: Thanks, by protocol do you mean external I/O?
[08:44:19] <beach> http://metamodular.com/protocol.pdf
[08:44:27] <beach> It's a generalization of "interface".
[08:44:46] <beach> This is the general idea, but it could be hard in some cases, where "hard" could mean "computationally too expensive".
[08:46:01] <lisp123> Thanks!
[08:46:06] <beach> Sure.
[08:48:31] <beach> Bertrand Meyer described this idea and called it "programming by contract".
[08:48:38] <beach> His work is worth reading.
[08:49:02] <beach> Or "design by contract", rather I guess.
[08:54:59] *** Quits: charro (~rcharles@pool-100-16-139-7.washdc.fios.verizon.net) (Ping timeout: 264 seconds)
[08:56:48] <beach> In fact, every serious programmer should already have read his work, and if not, should read it urgently.
[08:57:17] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Ping timeout: 246 seconds)
[08:57:18] <beach> But then, we know what the reality of software development looks like.
[09:01:53] *** Joins: easye (~user@oxi.slack.net)
[09:04:47] <lisp123> beach: Thanks, I will read
[09:26:44] <White_Flame> lisp123: add error checking when the default lisp error reports stop being helpful because they're too low level, or occur too late :-P
[09:27:38] <White_Flame> and those 2 aspects guide what should be checked early
[09:28:03] <White_Flame> so you can predict what actually needs to be checked
[09:28:43] <lisp123> White_Flame: lol, you can guess why I started this conversation, I have no idea of how to solve this current error ;)
[09:28:59] <White_Flame> then add more error checking! ;)
[09:29:51] <White_Flame> https://xkcd.com/722/
[09:30:11] *** Joins: Qwnavery (~Qwnavery@user/qwnavery)
[09:30:21] <lisp123> White_Flame: lol
[09:30:40] *** Quits: Qwnavery (~Qwnavery@user/qwnavery) (Client Quit)
[09:30:56] *** Quits: bcasiello (~bcasiello@066-189-087-112.biz.spectrum.com) (Ping timeout: 245 seconds)
[09:31:19] <lisp123> That's basically me right now
[09:31:42] <White_Flame> add error checking for things you think are obviously correct and don't need checking
[09:32:37] <lisp123> I don't know which function is causing the error, so I'm just randomly adding error checking for each :)
[09:33:18] <lisp123> (I kid a bit, its not that random, but its definitely very inefficiently done)
[09:34:08] <hayley> You don't have backtraces?
[09:35:22] <lisp123> hayley: I'm getting an error when compiling the file vs. evaluating the form (its a reader macro). So I suspect its to do with the whole read time vs. compile time vs. run time
[09:35:32] <beach> lisp123: I recommend against that way of doing it.  It is going to add a lot of noise to functions that should never be called with unknown arguments.
[09:35:51] <hayley> You'd still get a backtrace if you had a reader error.
[09:36:19] <beach> lisp123: If you don't know what function is causing the error, then you probably haven't added checks at the protocol level.
[09:36:35] <hayley> For example, if I just type ) at a REPL on SBCL, I can see that the error is caused in SB-IMPL::READ-RIGHT-PAREN, which was called by READ-MAYBE-NOTHING...
[09:38:14] <lisp123> beach: Yes, agree, one learns from painful experiences :) For today, I want to just solve this error, so I'm adding print and error checking everywhere; but I will refactor the code properly in the next few days
[09:39:31] <lisp123> hayley: Thanks. I got "READ error during COMPILE-FILE. The value NIL is not of type SB-INTROSPECT:DEFINITION-SOURCE", so now I'm just trying to figure that out
[09:39:55] <hayley> That does not look like a backtrace to me, though it is more information than "I got an error".
[09:40:00] <lisp123> But no call stack, sorry I think I confused what you meant by backtrace vs. call stack
[09:40:26] *** Parts: pranavats (3fba1d1b34@jabberfr.org) ()
[09:40:35] *** Quits: dec0d3r (~dec0d3r@2001:8003:480a:e00:e07:e7c3:7efc:ed0f) (Remote host closed the connection)
[09:42:39] <lisp123> Okay, so what helped was removing (ignore-errors ...), definitely not going to take that shortcut again
[09:44:56] <lisp123> hayley: So I get backtraces when I evaluate the code, but not when I compile the file
[09:45:12] *** Joins: Guest-liao (~Guest-lia@101.86.103.113)
[09:45:36] <lisp123> Are we meant to get backtraces when compiling a whole file (slime)?
[09:45:51] <lisp123> (or is there a way to turn that setting on)
[09:46:55] <hayley> I'm not sure after reading the CLHS page on COMPILE-FILE.
[09:47:33] <hayley> But reader errors should be the same irregardless of whether you are calling (say) LOAD or COMPILE-FILE. So just stick with LOAD until it works.
[09:48:05] <lisp123> hayley: Thanks! Will do
[09:55:45] *** Quits: gxt_ (~gxt@gateway/tor-sasl/gxt) (Remote host closed the connection)
[09:56:21] *** Joins: gxt_ (~gxt@gateway/tor-sasl/gxt)
[09:57:24] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[10:07:35] *** Quits: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de) (Quit: Leaving)
[10:10:09] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[10:17:50] *** Quits: Guest-liao (~Guest-lia@101.86.103.113) (Quit: Client closed)
[10:23:27] *** Joins: pve (~pve@178-55-112-13.bb.dnainternet.fi)
[10:30:51] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[10:58:36] *** Joins: aartaka (aartaka@gateway/vpn/protonvpn/aartaka)
[11:01:03] *** Joins: dec0d3r (~dec0d3r@2001:8003:480a:e00:e07:e7c3:7efc:ed0f)
[11:11:47] *** Joins: shka (~herr@83.175.151.96.piasta.pl)
[11:34:21] *** Quits: _whitelogger (~whitelogg@uruz.whitequark.org) (Remote host closed the connection)
[11:35:23] *** Joins: _whitelogger (~whitelogg@uruz.whitequark.org)
[11:35:51] *** Joins: hendursa1 (~weechat@user/hendursaga)
[11:38:57] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[12:14:33] *** Joins: paule32 (~paule32@user/paule32)
[12:16:22] *** Joins: casionaut (~casionaut@user/casionaut)
[12:32:03] *** Joins: Guest-liao (~Guest-lia@101.86.103.113)
[12:33:10] *** Quits: hendursa1 (~weechat@user/hendursaga) (Remote host closed the connection)
[12:34:50] *** Joins: hendursa1 (~weechat@user/hendursaga)
[12:44:11] *** Quits: amb007 (~a_bakic@102.215.76.86.rev.sfr.net) (Ping timeout: 264 seconds)
[12:44:23] *** Joins: amb007 (~a_bakic@131.151.22.93.rev.sfr.net)
[13:07:15] *** Quits: mfiano (~user@2603-7081-2d02-95bd-0250-b6ff-fef3-da40.res6.spectrum.com) (Remote host closed the connection)
[13:07:57] *** Joins: mfiano (~user@2603-7081-2d02-95bd-0250-b6ff-fef3-da40.res6.spectrum.com)
[13:11:03] *** Quits: mfiano (~user@2603-7081-2d02-95bd-0250-b6ff-fef3-da40.res6.spectrum.com) (Remote host closed the connection)
[13:11:37] *** Joins: mfiano (~user@2603-7081-2d02-95bd-0250-b6ff-fef3-da40.res6.spectrum.com)
[13:11:53] *** Quits: mfiano (~user@2603-7081-2d02-95bd-0250-b6ff-fef3-da40.res6.spectrum.com) (Remote host closed the connection)
[13:13:13] *** Joins: mfiano (~user@2603-7081-2d02-95bd-0250-b6ff-fef3-da40.res6.spectrum.com)
[13:16:11] *** Quits: mfiano (~user@2603-7081-2d02-95bd-0250-b6ff-fef3-da40.res6.spectrum.com) (Remote host closed the connection)
[13:20:01] *** Quits: Alfr (~Alfr@user/alfr) (Quit: Leaving)
[13:21:09] *** Joins: mfiano (~user@2603-7081-2d02-95bd-0250-b6ff-fef3-da40.res6.spectrum.com)
[13:21:59] *** Joins: cage (~cage@dynamic-adsl-84-220-249-98.clienti.tiscali.it)
[13:25:52] *** Quits: mfiano (~user@2603-7081-2d02-95bd-0250-b6ff-fef3-da40.res6.spectrum.com) (Remote host closed the connection)
[13:26:31] *** Joins: mfiano (~user@2603-7081-2d02-95bd-0250-b6ff-fef3-da40.res6.spectrum.com)
[13:27:17] *** Quits: casionaut (~casionaut@user/casionaut) (Quit: o7)
[13:36:08] *** Quits: molson (~molson@2001-48F8-704A-CA1-0-0-75F-1046-static.midco.net) (Ping timeout: 268 seconds)
[13:46:30] *** Joins: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de)
[13:54:20] *** Joins: Alfr (~Alfr@user/alfr)
[14:02:28] *** Joins: igemnace (~ian@user/igemnace)
[14:07:36] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Ping timeout: 245 seconds)
[14:08:37] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[14:13:32] *** Joins: lthrope (~lthrope@2a02:c7d:e846:1f00:64f1:3862:6841:a2fd)
[14:14:22] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Ping timeout: 268 seconds)
[14:17:54] *** Quits: lthrope (~lthrope@2a02:c7d:e846:1f00:64f1:3862:6841:a2fd) (Quit: Client closed)
[14:19:15] *** Joins: random-nick (~random-ni@87.116.179.142)
[14:25:56] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[14:35:28] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[14:51:34] *** Quits: igemnace (~ian@user/igemnace) (Remote host closed the connection)
[14:53:48] *** Joins: domovod (~domovod@176.196.122.197)
[15:09:20] *** Quits: amb007 (~a_bakic@131.151.22.93.rev.sfr.net) (Ping timeout: 246 seconds)
[15:11:27] *** Joins: amb007 (~a_bakic@128.147.204.77.rev.sfr.net)
[15:19:03] *** Quits: ahc71 (~ahc@121.98.229.241) (Quit: Client closed)
[15:24:59] *** Quits: amb007 (~a_bakic@128.147.204.77.rev.sfr.net) (Ping timeout: 264 seconds)
[15:31:37] *** Joins: didi (~user@user/didi)
[15:32:00] *** Parts: didi (~user@user/didi) (O bella ciao bella ciao bella ciao, ciao, ciao.)
[15:32:41] *** Joins: Inline (~Inline@aftr-37-201-241-28.unity-media.net)
[15:33:44] *** Joins: Lycurgus (~juan@98.4.112.204)
[15:38:49] *** Joins: amb007 (~a_bakic@31.37.22.93.rev.sfr.net)
[15:39:10] <beach> I started reading "Let Over Lambda", and the book is much better written than the other LOL book.  But why on earth would the function GROUP be written as it is on page 14?
[15:40:37] <beach> There are at least 4 problems with this 10-line code snippet.
[15:40:52] <beach> First, the use of IF without an `else' branch.
[15:41:01] *** Quits: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de) (Quit: Leaving)
[15:41:13] <beach> Then the use of tail recursion rather than ordinary recursion.
[15:41:32] <Lycurgus> https://letoverlambda.com/ is the other?
[15:41:39] <beach> And the inner IF should test the base case first, not the recursive case.
[15:42:07] <beach> There is only on "Let Over Lambda" I think, no?
[15:42:38] <Lycurgus> i'm referring to "the other LOL book"
[15:42:40] <hayley> Lycurgus: That is the website for the book Let Over Lambda, but it shares an acronym with Land Of Lisp.
[15:42:48] <Lycurgus> ah
[15:42:53] <beach> lucerne: The other LOL book is "Land of Lisp".
[15:43:18] <Inline> the online pdf version does not have all chapters
[15:43:28] <beach> Then the code uses SOURCE as a Boolean variable in the last IF.
[15:43:49] <Inline> there's errata and a working stripped version of the source code too
[15:43:57] <Inline> the book version of the source code might not work
[15:44:03] <Inline> or be buggy
[15:44:03] <beach> It seems to work.
[15:44:21] <beach> GROUP seems to work.
[15:44:41] <Inline> yeah, some of that initial material is from onlisp
[15:44:42] <beach> But it has the problems I listed above.  In particular tail recursion makes it very hard to follow.
[15:45:07] <beach> Well, that might explain it, but he could have written a better version of it then.
[15:46:36] <beach> Oh, and another problem: there is absolutely no reason not to handle the empty list as input.
[15:49:48] <beach> When written properly, GROUP reads like a proof by induction.  Not this version, though.
[15:55:00] *** Quits: pjb (~pjb@user/pjb) (Ping timeout: 260 seconds)
[15:56:46] <hayley> There is a section on CL-PPCRE, and the book falsely states that the regex library compiles a Lisp form from a regular expression (in reality, it creates a chain of closures corresponding to a NFA corresponding to the regular expression).
[15:57:17] <beach> Right, so the version in LOL is taken from page 47 of On Lisp, but Graham has a better version on page 389.
[15:58:33] <beach> I was totally put off by this version of GROUP, but now that I see it is copied from elsewhere, maybe I'll continue reading.
[15:59:00] <hayley> Or, at least, I cannot find a call to COMPILE or COERCE in CL-PPCRE which would compile any generated code. But it is irrelevant to the GROUP function.
[16:00:35] *** Joins: vats (~vats@1.187.116.43)
[16:02:30] *** Joins: McParen (~mcp@user/mcparen)
[16:03:11] <semz> beach: Is there something by Meyer you'd recommend as a starting point?
[16:03:41] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[16:04:24] <beach> semz: Hold on...
[16:06:31] <beach> There is a new-ish book "Design by Contract".  That sounds promising since it's the essence of what I said before.
[16:07:24] <beach> But I haven't read that one myself.
[16:08:57] *** Quits: Lycurgus (~juan@98.4.112.204) (Quit: Exeunt)
[16:09:56] <beach> Hmm, maybe it's not a book.
[16:10:46] <beach> OK, so let me tell you which one I was referring to before: Object-Oriented Software Construction.
[16:15:22] *** Quits: Guest-liao (~Guest-lia@101.86.103.113) (Quit: Client closed)
[16:15:48] *** Joins: s-liao (~s-liao@101.86.103.113)
[17:04:08] *** Quits: aartaka (aartaka@gateway/vpn/protonvpn/aartaka) (Ping timeout: 246 seconds)
[17:05:26] *** Joins: Bike (~Bike@71.69.170.70)
[17:05:26] *** ChanServ sets mode: +o Bike
[17:14:10] *** Joins: Devon (~devon@c-69-138-77-21.hsd1.va.comcast.net)
[17:17:13] *** Joins: varjag (~user@2a02:2121:283:4033:31d2:178c:6196:bb23)
[17:20:56] *** Quits: srhm (~srhm@user/srhm) (Read error: Connection reset by peer)
[17:20:56] *** Joins: pjb (~pjb@user/pjb)
[17:21:29] *** Joins: srhm (~srhm@user/srhm)
[17:22:17] *** Quits: amb007 (~a_bakic@31.37.22.93.rev.sfr.net) (Ping timeout: 264 seconds)
[17:23:16] *** Joins: amb007 (~a_bakic@199.87.95.79.rev.sfr.net)
[17:24:43] *** Quits: Inline (~Inline@aftr-37-201-241-28.unity-media.net) (Read error: Connection reset by peer)
[17:32:29] *** Quits: amb007 (~a_bakic@199.87.95.79.rev.sfr.net) (Ping timeout: 264 seconds)
[17:35:27] *** Joins: amb007 (~a_bakic@34.87.95.79.rev.sfr.net)
[17:36:17] <lisp123> beach: All yours comments make sense except one. Took me a while to switch from if to when for 1 case and arguably others may choose to resist). Also, I too used to use values of variables as a shortcut for boolean, but don't anymore
[17:36:30] <lisp123> I didn't get your comment on tail vs. ordinary recursion though
[17:38:16] <beach> WHEN or UNLESS should be used in a context where no value is needed, and there is only one branch for the test.
[17:38:46] <beach> Almost invariably, when tail recursion is used, the result becomes so twisted that it is hard to understand.
[17:39:02] <beach> Ordinary recursion can be made to look like a proof by induction.
[17:39:12] *** Joins: Inline (~Inline@2a02:908:1252:7a80:a2c:6d58:9f0f:3734)
[17:39:17] *** Joins: aartaka (aartaka@gateway/vpn/protonvpn/aartaka)
[17:39:27] <beach> Handle the base case first.  Then assume the induction hypothesis holds and handle the other cases.
[17:40:53] <lisp123> beach: ^ yes, that's how I always do it (probably since a lot of example code in books do it that way, and FACTORIAL is the canonical example that everyone learns). What do you mean by 'tail recursion' then?
[17:41:27] <lisp123> Seems very strange that (rec ...) appears above the other entry in the code, so I agree with you there - is that called tail recursion?
[17:41:55] *** Joins: Lycurgus (~juan@98.4.112.204)
[17:42:11] *** Quits: domovod (~domovod@176.196.122.197) (Ping timeout: 245 seconds)
[17:42:50] <beach> It is tail recursion when the recursive call is a tail call.
[17:43:44] <beach> Sometimes, tail recursion is "natural", but often it is obtained by a transformation of non-tail-recursion, and then it looks artificial and hard to follow.
[17:44:07] *** Joins: domovod (~domovod@ec2-35-165-86-158.us-west-2.compute.amazonaws.com)
[17:46:19] <lisp123> Oh, I thought we were meant to write with tail call recursion? I've been using accumulators for that purpose but admittedly haven't focused on much on checking whether what I do is tail call recursive, but I read its something important to do
[17:46:50] <lisp123> If you want time, I would be keen to see how it would look in 'ordinary recursion'
[17:47:10] <beach> We are NOT meant to transform a perfectly good non-tail-recursive function into tail recursuve.
[17:47:43] <beach> (defun ! (n) (if (zerop n) 1 (* n (! (1- n))))) is not tail recursivce.
[17:48:18] <beach> And it is perfectly good because it corresponds to the definition of factorial.
[17:48:37] <lisp123> Agree 100%, i've been doing just like you wrote
[17:49:05] <beach> Good.  Now turn it into a tail recursive version, and watch how it instantly becomes incomprehensible.
[17:49:09] <lisp123> I've been lazy and haven't been doing that extra step in that case to make it tail call recursive, so I guess I should disregard that advice?
[17:49:18] <lisp123> It makes it very disjointed to read
[17:50:31] <lisp123> (let me find an example where I use accumulators, I only use them where it felt natural, not intentionally)
[17:50:31] *** Quits: vats (~vats@1.187.116.43) (Read error: Connection reset by peer)
[17:50:58] *** Joins: vats (~vats@103.158.91.245)
[17:51:31] <Alfr> beach, (defun ! (acc n) (if (zerop n) acc (! (* n acc) (1- n))))
[17:52:35] *** Quits: varjag (~user@2a02:2121:283:4033:31d2:178c:6196:bb23) (Ping timeout: 264 seconds)
[17:53:03] <beach> Exactly!  Now it no longer corresponds to the most "natural" definition of factorial.
[17:53:20] <Alfr> beach, I wouldn't say unrecognizable. But as this is CL, it may be bad anyway as the spec doesn't mandate unlimited tail calls.
[17:53:28] <beach> First of all, the factorial function takes a single argument, so you have to do a LABELS.
[17:53:58] <beach> Alfr: Oh, but you would use iteration in this case anyway.  It is just an example.
[17:54:42] <Alfr> beach, what do you mean?
[17:54:52] <beach> So, yes, you are right, tail recursion won't help.
[17:55:06] *** Quits: vats (~vats@103.158.91.245) (Ping timeout: 245 seconds)
[17:55:35] <beach> You wouldn't use recursion (tail or otherwise) for something simple like factorial.
[17:55:51] *** Joins: vats (~vats@106.79.58.228)
[17:56:43] <lisp123> ehhh, I can't seem to find any examples where I used accumulators anymore...looks like I replaced a lot of them with loops
[17:57:33] <beach> But assume this is Scheme.  Compare (defun length (list) (if (null list) 0 (1+ (length (cdr list))))) to (defun length (list) (labels ((aux (rest acc) (if (null rest) acc (aux (cdr rest) (1+ acc))))) (aux list 0)))
[17:57:47] <beach> The first version reads like a proof by induction.
[17:58:10] <beach> Base case: the list is empty.  Then the length is 0.
[17:59:05] <beach> Induction hypothesis: we know how to compute the length of a list with 0 .. n CONS cells, and we are given a list with n+1 CONS cells.  Add one to the length of the CDR of the list.
[18:00:28] <beach> This is also the reason why you shouldn't write (defun length (list) (if (consp list) (1+ (length (cdr list))) 0))
[18:00:46] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[18:00:47] <beach> In a proof by induction, the base case is always stated first.
[18:01:10] <lisp123> Agree
[18:01:49] <beach> lisp123: So the second version of LENGTH above, is an example of artificial transformation of a "natural" recursive function into an incomprehensible tail-recursive one.
[18:03:36] <lisp123> beach: Whilst I agree with you, one can say its a common enough way of writing that it isn't that hard to follow?
[18:03:54] <beach> lisp123: But sometimes it is tail recursive anyway, like (defun no-numbers (list) (cond ((null list) t) ((numberp (car list)) nil) (t (no-numbers (cdr list)))))
[18:04:17] <beach> One can say that, but it would be incorrect.
[18:04:33] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[18:04:50] *** Quits: vats (~vats@106.79.58.228) (Read error: Connection reset by peer)
[18:04:51] <beach> The point is that one should write code in order for it to be read by humans.
[18:05:07] <beach> And one should make sure to avoid wasting time for those humans unnecessarily.
[18:05:25] <lisp123> beach: We are NOT meant to transform a perfectly good non-tail-recursive function into tail recursuve. -> Is this because (a) the compiler can do it any way (because otherwise the argument is that the tail call version is more "efficient") or (b) should we use iteration in such problems?
[18:06:06] <beach> It is because the result is incomprehensible so we are making life harder for the person reading the code.
[18:06:07] <lisp123> The point is that one should write code in order for it to be read by humans. And one should make sure to avoid wasting time for those humans unnecessarily. -> Very true!!
[18:06:11] *** Parts: pranavats (3fba1d1b34@jabberfr.org) (Disconnected: Replaced by new connection)
[18:06:30] <random-nick> transforming a non-tail-recursive function into being tail recursive is pretty much using iteration
[18:06:44] <beach> But yes, in Common Lisp, you should use iteration for "linear" problems.
[18:06:55] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[18:07:13] <beach> random-nick: Semantically, yes, but not syntactically.  And people read syntax.
[18:09:25] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 265 seconds)
[18:09:25] <Alfr> lisp123, if you can use tail recursion, then you can use iteration, instead of calling your function with new arguments you could goto the start of it and update iteration variables and run the body again.
[18:10:19] <beach> Exactly.  It's a bit harder with mutual recursion of course.
[18:10:24] <Alfr> lisp123, this also works the other way around, turning a loop into a tail recursive function.
[18:11:09] *** Joins: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se)
[18:11:46] <lisp123> Can I just use 'ordinary' recursion or is that bad?
[18:12:07] <lisp123> I prefer that to both in the example of factorial (and examples similar in nature)
[18:12:43] <Alfr> lisp123, you can if you're sure that the data you feed it won't cause the program to run out of stack space.
[18:12:49] <random-nick> oh I agree, I'm just saying that the exact same semantics of a tail recursive function can be written as a loop, so it's easy to write a loop instead
[18:13:02] <beach> Maybe something like "natural" recursion is better.  Then it can sometimes be tail recursion if that turns out to be "natural".
[18:13:15] <beach> random-nick: Sure.
[18:13:19] <Alfr> lisp123, thus non-tail recursive implementation of length for a list likely is a really bad idea.
[18:13:36] <lisp123> Alfr: Got it!
[18:14:07] <lisp123> Thanks all
[18:14:41] <Alfr> lisp123, there's nothing wrong with recursion, but the way how implementations use a stack (of a certain size) may cause your program to fail on otherwise good input.
[18:16:35] <beach> lisp123: An example of good use of recursion in Common Lisp is operations on a balanced binary tree.
[18:17:11] <beach> lisp123: Then, the depth is proportional to the logarithm of the number of nodes, so you are unlikely to run out of stack space.
[18:17:41] <beach> Also, binary search, of course.  An even simpler example.
[18:17:48] <lisp123> beach: That's a very nice example to keep in mind, thanks.
[18:18:40] <beach> Though binary search is almost as clear when iteration is used.
[18:20:46] <lisp123> Hmmm. I do quite like recursion on binary searches / binary trees and find iteration harder to follow there
[18:21:12] <beach> For trees you pretty much don't have a choice.
[18:21:13] <_death> example (alexandria:flatten (loop for x = '() then (list x) repeat 100000 finally (return x)))
[18:21:52] <beach> Runs out of stack?
[18:22:00] <_death> yes
[18:22:59] <Alfr> _death, that's quite a degenerate tree.
[18:23:50] <beach> Sure, but flatten should still work.
[18:24:20] <_death> since alexandria is a popular utility library, maybe it's worth reimplementing flatten without recursion
[18:24:35] <beach> Definitely.  Won't be easy though.
[18:24:58] <lisp123> ooooh I would be keen for a copy of that. I use flatten a lot
[18:25:00] <_death> beach: eh? (let ((stack (list x))) (loop until (null stack) do ...))
[18:25:46] <beach> That might work.
[18:25:50] <Alfr> Does it only operate on trees? Wouldn't dfs do it, so manually maintain a stack?
[18:26:04] <_death> that is dfs..
[18:26:21] <_death> or well, depth-first traversal
[18:27:28] *** Quits: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se) (Ping timeout: 252 seconds)
[18:28:20] <Alfr> _death, sorry, didn't see yours. (I don't read while typing my stuff, otherwise I tend to mix in some random words I just read.)
[18:29:27] *** Quits: Inline (~Inline@2a02:908:1252:7a80:a2c:6d58:9f0f:3734) (Ping timeout: 268 seconds)
[18:30:09] <_death> (defun flatten (tree) (let ((result '()) (agenda (list tree))) (loop until (null agenda) do (let ((item (pop agenda))) (typecase item (cons (setf agenda (nconc (list (car item) (cdr item)) agenda))) (null) (t (push item result))))) (nreverse result)))
[18:30:20] <_death> not really tested
[18:31:10] <lisp123> _death: Thansk!
[18:31:49] <beach> _death: Won't that destroy the original list?
[18:31:58] <beach> Oh, no, I see now.
[18:32:43] <beach> You could use list* there, no?
[18:33:00] <beach> ... instead of nconc I mean.
[18:33:01] <_death> yes.. or two pushes
[18:33:07] <beach> That too.
[18:33:28] <_death> list* would be nicer.. for pushes you'd have to use the reverse order
[18:33:38] <beach> Yeah.
[18:34:41] <beach> Also, the first CONS cell on AGENDA will always be freshly allocated, right?
[18:34:52] <beach> So then you can reuse it for the RESULT.
[18:35:42] <beach> ... I mean, when the CAR of AGENDA is an atom.
[18:36:18] *** Joins: Josh_2 (~user@37.25.47.130)
[18:36:33] <Josh_2> Hi hi
[18:37:06] <beach> Hello Josh_2.
[18:37:14] <Josh_2> is there a way to destructure an alist in a similar fashion to a plist like (destructuring-bind (&key a b c &allow-other-keys) '(:a a :b b :c c)) ?
[18:37:23] <Josh_2> Hey beach
[18:37:26] <_death> not sure what you mean.. you maintain a tail instead of push/nreverse but I dunno if it's worth it
[18:37:31] <_death> *you could maintain
[18:37:44] <beach> No, that's not what I mean.
[18:38:05] <_death> beach: well, I doubt TREE would be an atom very often
[18:38:10] <Bike> Josh_2: nothing standard
[18:38:17] <beach> I mean, you PUSH a fresh CONS cell onto RESULT, but you throw away the firs one on AGENDA with POP.
[18:38:17] <Josh_2> Bike: alright
[18:38:23] *** Quits: s-liao (~s-liao@101.86.103.113) (Ping timeout: 256 seconds)
[18:38:58] *** Joins: varjag (~user@2a02:2121:283:4033:c018:db4:ccfd:fea5)
[18:39:03] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[18:39:24] <beach> _death: But I think the first CONS cell on AGENDA is a freshly allocated one when the CAR is an atom, so that CONS cell is not part of the original tree.
[18:40:12] <Bike> Josh_2: i think you could do it with optima/trivia, maybe
[18:40:16] <Alfr> _death, maybe keep push, but then also push cdr after car onto agenda; I think that then result doesn't need to be reversed.
[18:40:36] <Josh_2> Bike: thats alright, I'll just use let and assoc :P
[18:40:50] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[18:40:55] <beach> Alfr: NREVERSE is cheap though.
[18:41:43] *** Joins: Skyfire (~pyon@user/pyon)
[18:42:34] <_death> Alfr: yeah, that could work
[18:43:21] <Alfr> beach, still will visit all conses again. And walking the tree RNL isn't hard given _death's code above.
[18:47:30] *** Joins: s-liao (~s-liao@101.86.103.113)
[18:49:56] *** Quits: s-liao (~s-liao@101.86.103.113) (Client Quit)
[18:50:47] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 264 seconds)
[18:51:18] <_death> git push #commonlisp-flatten alexandria
[18:52:06] <_death> rotatef the args :/
[18:55:09] *** Joins: Guest74 (~Guest74@modemcable110.164-177-173.mc.videotron.ca)
[18:55:16] *** Quits: Lycurgus (~juan@98.4.112.204) (Quit: Exeunt)
[18:56:09] <pjb> beach: in maths, the base case is not always the first one to be written down.  Also, various programming methods leave the iteration initialization aka recursion base case as a last step in building loops/recursions.  Notably, the exact initialization may depend on the iteration/recursive case.
[18:56:35] <pjb> it's like in physics, the conditions to the limit.  That often comes at the end of a problem.
[18:56:48] <jackdaniel> git #commonlisp-flatten alexandria push ?
[18:57:10] <_death> git-push is the command ;)
[18:57:13] <pjb> Now one argument about the order of if branches, is to put the smallest alternative first.
[18:57:25] <jackdaniel> _death: right you are, my apologies :p
[18:57:31] <pjb> (the base case is often the smallest).
[18:58:45] <pjb> For example, you can have recursions where there are several different base cases, but a single simple recursive case.  In this situation, it could be better to put the recursive case first, and all the base cases next.
[18:59:41] *** Quits: sm2n (~sm2n@user/sm2n) (Remote host closed the connection)
[19:00:00] *** Joins: sm2n (~sm2n@user/sm2n)
[19:01:49] <pjb> Josh_2: (destructuring-bind ((k1 . v1) (k2 . v2) . arest) '((one . 1) (two . 2) (three . 3) (four . 4)) (acons `(+ ,k1 ,k2) (+ v1 v2) arest)) #| --> (((+ ONE TWO) . 3) (THREE . 3) (FOUR . 4)) |#  ;-)
[19:01:58] *** Joins: Oladon (~olad@98.43.81.226)
[19:02:06] *** Joins: Inline (~Inline@aftr-37-201-241-178.unity-media.net)
[19:02:13] <pjb> Josh_2: there's no &alist keyword.
[19:02:25] <Josh_2> yeh but I do not want to destructure the entire list
[19:03:56] <pjb> Josh_2: you could write your own defun macro (and others, including destructuring-bind), that would add a &alist keyword to do something similar to &key for a-lists. But you LAMBDA-LIST-KEYWORDS is a constant, so you will have to shadow it too…
[19:03:57] <_death> (destructuring-bind (&key ,@the-keys &allow-other-keys) (alist-plist ,alist) ,@body) ;)
[19:06:54] <beach> _death: http://metamodular.com/flatten.lisp is what I meant.
[19:07:39] <beach> _death: It reuses the CONS cell, so should CONS only about half of yours.
[19:09:32] <_death> interesting.. in the atom case you could use shiftf
[19:09:53] <beach> Oh, good idea.
[19:10:15] <Bike> rotatef, i think
[19:11:16] <beach> Maybe someone can work it out and post a better version?
[19:13:35] *** Quits: amb007 (~a_bakic@34.87.95.79.rev.sfr.net) (Ping timeout: 264 seconds)
[19:14:30] *** Joins: amb007 (~a_bakic@6.33.83.79.rev.sfr.net)
[19:15:08] <beach> Maybe ROTATEF will make the temporary unnecessary.
[19:15:42] <_death> https://plaster.tymoon.eu/view/2687#2687
[19:16:06] <beach> Beautiful! :)
[19:17:00] <_death> updated to make it a bit shorter
[19:17:44] <_death> updated with a cosy DO :)
[19:18:01] <beach> nreverse?
[19:18:07] <lisp123> How come '() vs. nil?
[19:18:11] <_death> no need since I used alfr's trick
[19:18:19] <beach> Oh, OK.
[19:18:47] <_death> lisp123: it signals to the reader that you want an empty list
[19:18:53] <beach> lisp123: NIL means "false" or "default value". '() means "empty list", () means empty parameter list.
[19:19:09] <beach> I think that's in the Common Lisp HyperSpec too.
[19:19:21] <lisp123> I see, thanks. I will update my usage then
[19:22:23] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Ping timeout: 246 seconds)
[19:22:35] <beach> _death: That's a very nice version.
[19:22:36] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[19:23:02] <yitzi> lisp123: It's in the CLHS glossary under () as way to emphasize the use of nil as an empty list.
[19:23:05] <beach> I can't remember where in the Common Lisp HyperSpec they mention the different ways of writing NIL.
[19:23:06] <_death> someone should submit it to alexandria ;)
[19:23:59] <yitzi> beach: Some here http://www.lispworks.com/documentation/lw50/CLHS/Body/26_glo_9.htm#OPCP
[19:24:13] <lisp123> yitzi: Cheers
[19:24:38] <beach> yitzi: No, I recall a complete list of all uses like 'nil nil '() ()
[19:24:58] <beach> lisp123: Oh, and 'nil means the symbol NIL as a form.
[19:25:31] <yitzi> beach: Understand.
[19:25:38] <lisp123> That makes sense
[19:28:20] <beach> clhs 1.4.1.4.4
[19:28:20] <specbot> NIL: http://www.lispworks.com/reference/HyperSpec/Body/01_dadd.htm
[19:29:22] <beach> lisp123: ^
[19:30:46] <lisp123> beach: Thanks, that's a useful link. I will save it down in my bookmarks.
[19:31:40] <beach> Sure.
[19:32:05] <beach> _death: I guess using WITH LOOP clauses instead of LET will save a level of indentation. :)
[19:32:21] <_death> beach: I already took care of that with DO :)
[19:32:35] <beach> Oh, let me see...
[19:33:03] <beach> Yes, I see.
[19:33:21] <_death> sometimes DO is very compact and nice
[19:34:34] <beach> I think this version beats the current one in Alexandria in all possible ways. :)
[19:34:43] <_death> except a docstring
[19:34:56] <beach> That one can be copied. :)
[19:37:00] <_death> in the words of Bob Ross, "there".. "now we can flatten our happy little trees"
[19:37:19] <beach> That was an interesting instance of collaboration between several (4?) people here.
[19:38:11] <beach> We should do stuff like that more often.
[19:39:06] <_death> ;)
[19:39:52] <beach> It beats trying to sort out FFI problems or HTML templates. :)
[19:39:57] <holycow> land of lisp, page 51 has a lit of how to write nil 4 ways
[19:39:59] <holycow> heh
[19:40:00] <holycow> found it
[19:40:36] *** Joins: mister_m (~user@c-73-110-154-209.hsd1.il.comcast.net)
[19:41:12] *** Quits: amb007 (~a_bakic@6.33.83.79.rev.sfr.net) (Ping timeout: 268 seconds)
[19:41:50] *** Joins: heisig (~heisig@p508b531b.dip0.t-ipconnect.de)
[19:42:09] *** Joins: amb007 (~a_bakic@53.127.95.79.rev.sfr.net)
[19:48:17] <Guest74> is there a preferred socket library?  Looks like I'm implementing the sane network protocol and I'm only used to using sb-bsd-sockets.
[19:49:24] <yitzi> Guest74: https://common-lisp.net/project/usocket/
[19:49:52] <lisp123> pjb: "Now one argument about the order of if branches, is to put the smallest alternative first." -> That's sort of like how Elisp encourages. Perhaps RMS had the same view on it
[19:50:27] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 268 seconds)
[19:51:59] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[19:52:28] <Guest74> yitzi: thanks.  Any idea if it can do multicast? I'd like my UPNP stuff to not be limited to sbcl.
[19:52:34] <pjb> lisp123: possibly.
[19:52:52] *** Joins: casionaut (~casionaut@user/casionaut)
[19:56:37] <yitzi> Guest74: no idea. You'd have to look at the docs and code.
[19:56:59] *** Joins: apemangr (~apemangr@170.82.191.148)
[19:59:28] *** Joins: vats (~vats@103.158.91.51)
[20:01:48] <Guest74> yeah, I can't see it so I'm asking.  I'm guessing :stream means a local socket? or is that possible? If you're not familiar with the library I'll stop asking.
[20:02:27] <White_Flame> multicast is just an IP address, right?
[20:02:33] <White_Flame> doesn't change the API
[20:04:54] <_death> :stream means a tcp socket.. if you want udp, that's :datagram
[20:06:20] <Guest74> so no unix sockets?
[20:07:07] <_death> right.. I think it's a recurring issue with usocket
[20:08:42] <Guest74> in sbcl multicast requires setting options on the socekt, multicast address and interface using some c struct.
[20:09:23] <White_Flame> oh wait, yeah, was thinking broadcast, not multicast
[20:10:05] <Guest74> unix sockets would be nice, but I can just get away with tcp for SANE.
[20:10:53] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 264 seconds)
[20:11:40] <Guest74> but is there anything for unix sockets, especially being able to transfer fds in msg?  It'd be nice to have that for clx so can do shared memory.
[20:11:47] <_death> there are other libraries like iolib or fsocket (which has unix domain sockets but not datagram ones)
[20:14:51] *** Quits: anddam (~anddam@user/anddam) (Quit: WeeChat 3.3)
[20:16:18] <_death> you could also choose to add them to usocket
[20:16:33] *** Joins: peterhil (~peterhil@dsl-hkibng32-54fb56-2.dhcp.inet.fi)
[20:16:54] <Guest74> interesting fsocket seems to provide multicast, so I could use that for UPNP.
[20:17:14] <Guest74> I've already got hectares of yaks.
[20:18:58] <Guest74> hrm, fsocket isn't in quicklisp.
[20:19:46] *** Joins: bcasiello (~bcasiello@066-189-087-112.biz.spectrum.com)
[20:20:17] *** Joins: Guest75 (~Guest75@80-109-197-245.cable.dynamic.surfer.at)
[20:29:15] *** Joins: anddam (~anddam@user/anddam)
[20:38:04] <Guest74> anybody know why stumpwm isn't being logged on libera?  Still logged on freenode.
[20:39:59] *** Quits: Guest75 (~Guest75@80-109-197-245.cable.dynamic.surfer.at) (Quit: Client closed)
[20:42:27] *** Joins: tyson2 (~user@cpe00fc8d34ff03-cm00fc8d34ff00.sdns.net.rogers.com)
[20:48:10] *** Quits: dstein64 (~dstein64@dannyadam.com) (Ping timeout: 252 seconds)
[20:48:27] *** Quits: srhm (~srhm@user/srhm) (Read error: Connection reset by peer)
[20:49:12] *** Joins: srhm (~srhm@user/srhm)
[21:01:12] *** Quits: heisig (~heisig@p508b531b.dip0.t-ipconnect.de) (Quit: Leaving)
[21:03:02] *** Joins: dstein64 (~dstein64@dannyadam.com)
[21:04:06] <Josh_2> Wish cl-json is there a way to disable encoding? I am trying to append the received json object to my request
[21:04:34] <Josh_2> if I decode the body then encode it again it does not produce an identical string
[21:05:56] *** Quits: Inline (~Inline@aftr-37-201-241-178.unity-media.net) (Ping timeout: 245 seconds)
[21:06:15] *** Quits: shka (~herr@83.175.151.96.piasta.pl) (Quit: Konversation terminated!)
[21:07:00] <Josh_2> I need something like ((a . a)(b . b)(c . "noencoded"))
[21:07:07] <Josh_2> I think I have had this problem before
[21:08:02] <Josh_2> Actually I think I might be able to do this with jojo
[21:09:41] *** Quits: apemangr (~apemangr@170.82.191.148) (Ping timeout: 264 seconds)
[21:14:47] *** Joins: Inline (~Inline@2a02:908:1252:7a80:b384:bd52:ad64:846c)
[21:18:15] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[21:24:16] *** Quits: domovod (~domovod@ec2-35-165-86-158.us-west-2.compute.amazonaws.com) (Ping timeout: 245 seconds)
[21:24:43] <Josh_2> Nope :cry:
[21:25:18] <Josh_2> If I can't get this to work suppose I could just try and manually verify the signature
[21:32:12] *** Quits: hendursa1 (~weechat@user/hendursaga) (Quit: hendursa1)
[21:32:44] *** Joins: hendursaga (~weechat@user/hendursaga)
[21:37:40] *** Joins: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de)
[21:42:51] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[22:03:09] *** Joins: apemangr (~apemangr@170.82.191.148)
[22:05:10] *** Joins: macaw (~macaw@77-255-134-52.adsl.inetia.pl)
[22:07:16] <lisp123> Anybody have any ideas on this: https://plaster.tymoon.eu/view/2688#2688
[22:09:32] *** Quits: tyson2 (~user@cpe00fc8d34ff03-cm00fc8d34ff00.sdns.net.rogers.com) (Remote host closed the connection)
[22:09:38] <_death> you can read more than one form
[22:14:09] <lisp123> _death: Oh, I see. I currently have something like this (defun reader ... (read stream t nil t) ...), do I need to add a loop to keep reading until I hit #end or something?
[22:14:53] <_death> you can do that, yeah
[22:14:54] *** Quits: amb007 (~a_bakic@53.127.95.79.rev.sfr.net) (Read error: Connection reset by peer)
[22:15:43] <lisp123> Thanks! So does that mean once the function associated with a macro-dispatch-character finishes, control is passed back to the "main" reader?
[22:16:17] <_death> reading is a recursive process
[22:16:34] *** Joins: tyson2 (~user@cpe00fc8d34ff03-cm00fc8d34ff00.sdns.net.rogers.com)
[22:17:45] <lisp123> hmmm ok, I think I get it. Would you do it any other way vs. a loop I noted above (just want to see what possible techniques are out there)?
[22:19:47] *** Joins: amb007 (~a_bakic@laubervilliers-658-1-139-127.w80-15.abo.wanadoo.fr)
[22:20:12] <_death> you have a character stream and you can read the thing you want to read however you want, so long as you don't overstep by more than one character (that's when you can unread-char)
[22:21:03] <lisp123> Got it, thanks!
[22:26:03] *** Quits: cage (~cage@dynamic-adsl-84-220-249-98.clienti.tiscali.it) (Remote host closed the connection)
[22:26:13] *** Joins: cage (~cage@dynamic-adsl-84-220-249-98.clienti.tiscali.it)
[22:26:33] *** Quits: bcasiello (~bcasiello@066-189-087-112.biz.spectrum.com) (Ping timeout: 265 seconds)
[22:33:36] *** Quits: tyson2 (~user@cpe00fc8d34ff03-cm00fc8d34ff00.sdns.net.rogers.com) (Remote host closed the connection)
[22:34:49] <_death> I guess one technique, in some cases, is to use another (and another, and another...) readtable in your READ-calling read macro.. I wonder much code does that in the wild, beyond the first level
[22:35:51] <lisp123> _death: Indeed, that sounds like a good way to do it
[22:36:28] <lisp123> Was just looking at an example where JSON is parsed like that -> https://gist.github.com/chaitanyagupta/9324402 (the famous guide on reader macros)
[22:38:20] <lisp123> Although creating nested levels of readtables definitely sounds like nice way to parse other languages which have their own syntax
[22:39:32] *** Joins: bcasiello (~bcasiello@066-189-087-112.biz.spectrum.com)
[22:40:18] *** Quits: apemangr (~apemangr@170.82.191.148) (Quit: Leaving)
[22:41:04] <_death> named-readtables is a nice library.. internally it has a with-readtable-iterator, which CL maybe should've had in some form
[22:47:34] <lisp123> It is indeed
[22:52:54] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[22:53:10] *** Quits: Guest74 (~Guest74@modemcable110.164-177-173.mc.videotron.ca) (Quit: Connection closed)
[22:55:43] <Josh_2> How do I sign a message with ironclad? I have a public key that i have to download
[22:57:59] <_death> (ironclad:sign-message private-key message)
[22:58:46] <Josh_2> By default is that sha1?
[22:59:04] <_death> sha1 is a hashing algorithm
[22:59:08] <Josh_2> The signature i have to verify is rsa with sha256
[22:59:09] <Josh_2> ye
[23:00:01] <_death> that means the message is hashed using sha256, and then signed using rsa
[23:00:03] <Josh_2> So I just has my string then use sign-message with the key?
[23:00:09] <Josh_2> hash my*
[23:00:29] <_death> (the hash is the message for signing)
[23:01:41] *** Joins: lisp123 (~lisp123@5.30.23.247)
[23:02:20] <Alfr> Josh_2, do you rally want to sign? Having a public key sound to me like you'd like to verify.
[23:02:34] <_death> for example, here's signing a message in the context of the scuttlebutt protocol https://plaster.tymoon.eu/view/2689#2689
[23:02:48] *** Quits: mister_m (~user@c-73-110-154-209.hsd1.il.comcast.net) (Ping timeout: 265 seconds)
[23:03:00] <Josh_2> Uh yeh I think I need to verify
[23:03:03] <Josh_2> sorry _death
[23:03:47] <_death> I updated with verification code
[23:04:44] <Josh_2> does ::public-key return a vector?
[23:05:32] <_death> no, it's something like (make-instance 'ironclad:ed25519-public-key :y y) where y is the octet vector
[23:05:38] <Josh_2> ah okay thanks
[23:05:43] <_death> in your case, it'd be an rsa-public-key
[23:05:50] <Josh_2> Okay tyvm I'll give it a shot
[23:06:45] <Josh_2> Rsa-public-key has e and n
[23:06:51] <_death> correct
[23:07:02] <_death> e is often 65537
[23:07:29] <Josh_2> and n will be my signature i have downloaded?
[23:07:34] <_death> if it's something stupid like 3, it's bad
[23:07:40] <_death> n is the modulus
[23:08:29] <Josh_2> So how do I turn my downloaded cert into an rsa-public-key object?
[23:08:42] <Josh_2> Sorry for the lame questions, the first time around this stuff is always cryptic to me
[23:08:46] <_death> the signature is S=m^d (mod n)
[23:11:29] <_death> you need to extract the key from the cert using some asn.1 library
[23:11:38] *** Joins: mister_m (~user@c-73-110-154-209.hsd1.il.comcast.net)
[23:12:09] <Josh_2> Alrighty
[23:14:34] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 260 seconds)
[23:20:14] *** Quits: bcasiello (~bcasiello@066-189-087-112.biz.spectrum.com) (Ping timeout: 260 seconds)
[23:20:50] *** Quits: cross_ (~cross@spitfire.i.gajendra.net) (Remote host closed the connection)
[23:22:50] <Josh_2> Hmm I tried the asn1 library made by Fukamachi, however when I call (asn1:decode ..) on my downloaded signature a condition is signalled :(
[23:23:41] <Josh_2> I will try asinine
[23:23:50] <_death> well, it depends on the format of your certificate
[23:24:34] <_death> it could be in PEM format, which contains base64 of DER encoded data of the X.509 certificate
[23:24:47] <_death> welcome to cryptographic world
[23:25:32] <_death> if it's just a single cert that you need the key from, you can use the openssl tool or something
[23:26:58] *** Joins: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se)
[23:28:12] <Josh_2> It is not, it maybe be a different signature each request
[23:30:46] <_death> cl-tls may also be helpful, though I've not used it in this context
[23:31:07] <Josh_2> from some example code I have found in C# they are using a class called X509Certificate2 for their cert
[23:31:13] <Josh_2> idk if thats helpful
[23:31:18] <Josh_2> alright i'll check cl-tls
[23:31:21] *** Quits: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se) (Ping timeout: 245 seconds)
[23:31:27] <_death> https://github.com/shrdlu68/cl-tls/blob/master/src/x509/x509.lisp
[23:32:19] *** Quits: casionaut (~casionaut@user/casionaut) (Quit: o7)
[23:32:54] <Josh_2> cl+ssl also has some x509 stuff
[23:33:02] <_death> yeah, but very limited interface
[23:34:15] <Josh_2> cl-tls is not in ql :(
[23:35:07] <_death> post an issue ;)
[23:35:35] <Josh_2> Maybe if it works
[23:36:53] <Josh_2> Hmm, got an error 'expected asn.1 sequence'
[23:37:09] *** Quits: Skyfire (~pyon@user/pyon) (Quit: br)
[23:37:40] <_death> https://en.wikipedia.org/wiki/X.509#Certificate_filename_extensions
[23:38:47] <Josh_2> Okay I downloaded it to my machine, linux is reporting "Openssl PEM format"
[23:39:28] *** Joins: Skyfire (~pyon@user/pyon)
[23:39:31] <_death> cl-tls also has some pem code
[23:40:29] *** Joins: ahc85 (~ahc@121.98.229.241)
[23:43:39] <Josh_2> https://plaster.tymoon.eu/view/2690#2690 I had to convert what I downloaded back to text and then used cl-tls::parse-pem
[23:43:54] <Josh_2> I assume that vector is my key?
[23:44:16] <_death> (cl-tls:x509-decode (cdar (cl-tls::parse-pem (alexandria:read-file-into-string "/etc/ssl/certs/Hongkong_Post_Root_CA_1.pem")))) works, after patching cl-tls to remove some missing type specifiers
[23:44:36] <_death> no, that vector represents the certificate in DER format
[23:44:47] <Josh_2> Man this kinda suck :joy:
[23:45:06] *** Quits: Bike (~Bike@71.69.170.70) (Quit: Connection closed)
[23:46:40] <Josh_2> Hey that worked! One piece of the puzzle complete I guess :joy:
[23:46:42] <_death> after x509-decode, you get an object that you can inspect.. in a tbs-certificate instance, there's subject-pki slot, which contains a plist with a :subject-public-key indicator that contains a plist with the public exponent and modulus
[23:47:47] <_death> the modulus is already represented as a number, which is good as that's what ironclad wants
[23:50:33] *** Quits: ahc (~ahc@121.98.229.241) (Quit: Client closed)
[23:54:28] <Josh_2> Alrighty! I now have my ironclad:rsa-public-key
[23:54:36] <_death> now, RSA also has different signature schemes.. probably old PKCS#1, but could also be PSS
[23:54:55] <Josh_2> One sec lemme see if I can find out
[23:55:14] <_death> anyway, you can probably figure things out from here.. ;)
[23:55:18] <Josh_2> probably not
[23:55:21] <Josh_2> xD
[23:55:49] <_death> bruteforce works in crypto programming, if not crypto itself ;)
[23:56:16] <Josh_2> paypal docs dont say anything about pss or pkcs...
[23:56:26] <Josh_2> oooo
[23:56:40] <Josh_2> Its pkcs1 from some example code I can see on stackoverflow
[23:56:54] <_death> so that's the default for ironclad:verify-signature
[23:57:20] *** Joins: Oddity (Oddity@user/oddity)
