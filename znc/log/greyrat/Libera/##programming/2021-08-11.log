[00:01:48] *** Quits: jamea (~jamea@177.239.85.103) (Ping timeout: 268 seconds)
[00:03:53] *** Quits: merijn (~merijn@83-160-49-249.ip.xs4all.nl) (Ping timeout: 248 seconds)
[00:08:24] *** Quits: gitgoood (~gitgood@80-44-15-108.dynamic.dsl.as9105.com) (Remote host closed the connection)
[00:08:43] *** Joins: gitgoood (~gitgood@80-44-15-108.dynamic.dsl.as9105.com)
[00:08:56] *** Joins: gambl0re (~gambl0re@24.140.237.124)
[00:13:00] *** Joins: gilesc (~textual@2603-8001-3600-dad7-5818-2741-ece0-27c4.res6.spectrum.com)
[00:16:20] *** Joins: lavos (~molt@95.155.22.30)
[00:17:13] *** Quits: molt (~molt@79.140.150.21) (Ping timeout: 248 seconds)
[00:19:15] *** Quits: pizdets_ (~pizdets@183.182.111.62) (Ping timeout: 245 seconds)
[00:20:44] *** Joins: pizdets (~pizdets@183.182.114.167)
[00:23:54] *** Joins: cog (~Atlas@2604:3d08:b27f:ae00:912f:6c43:4e9d:1b80)
[00:25:00] <vdamewood> Oh, Yay.OpenSSL 3.0 beta 2 has been released!
[00:25:58] *** Quits: tomgus1 (~tomgus1@90.208.15.36) (Read error: Connection reset by peer)
[00:26:01] *** Joins: tomgus1_ (~tomgus1@90.208.15.36)
[00:26:25] *** tomgus1_ is now known as tomgus1
[00:27:48] *** Quits: mnd999_ (~mark@2001:8b0:da3:76a2:4630:5b97:83a2:3e21) (Ping timeout: 258 seconds)
[00:30:23] *** Joins: merijn (~merijn@83-160-49-249.ip.xs4all.nl)
[00:32:12] *** Joins: tradar (~tradar@user/tradar)
[00:32:39] *** Quits: gambl0re (~gambl0re@24.140.237.124) (Ping timeout: 268 seconds)
[00:34:01] *** Quits: kurtthemaker (~kurt@S010644a56e3e0ee9.cn.shawcable.net) (Remote host closed the connection)
[00:35:28] *** Quits: merijn (~merijn@83-160-49-249.ip.xs4all.nl) (Ping timeout: 258 seconds)
[00:36:03] *** Quits: user51 (~user51@176.228.90.248) (Remote host closed the connection)
[00:36:46] *** Joins: kurtthemaker (~kurt@S010644a56e3e0ee9.cn.shawcable.net)
[00:36:58] *** Quits: elnavigator (~elnavigat@105.196.134.207) (Ping timeout: 268 seconds)
[00:37:05] *** Quits: magla (~gelignite@55d43c1b.access.ecotel.net) (Quit: Stay safe!)
[00:39:25] *** Quits: enoq (~enoq@194-208-179-35.lampert.tv) (Quit: enoq)
[00:41:41] *** Joins: kill (~killown@user/killown)
[00:41:57] <kill> what about rust for web development?
[00:42:48] <webnet4> what about it?
[00:43:50] *** Quits: Hercules (~Hercules@user/hercules) (Quit: Leaving)
[00:44:36] <pulse> sounds wrong
[00:44:43] <kill> about performance, if there are any huge gains in comparison with wordpress / php in case someone is considering to create a site
[00:45:05] *** Quits: Haxxa (~Haxxa@122-199-44-36.ip4.superloop.com) (Quit: Haxxa flies away.)
[00:45:12] <webnet4> there are gains if you rewrite it in VB probably
[00:45:23] *** Joins: matrixskp (~matrixskp@121-75-182-31.dyn.vf.net.nz)
[00:45:29] <kill> do you know rust?
[00:45:37] <kill> or are you just a hater
[00:45:38] <webnet4> the programming language?
[00:45:45] <kill> yeah a hater
[00:45:50] <kill> nice try, thanks no
[00:45:55] <webnet4> ok then don't use it
[00:46:03] *** Joins: Haxxa (~Haxxa@122-199-44-36.ip4.superloop.com)
[00:46:04] <kill> I will use it.
[00:46:07] <kill> ignored
[00:46:11] <kill> no time for trolls
[00:46:14] <webnet4> then why ask lol
[00:46:23] <webnet4> php is slow as crap
[00:46:34] *** Joins: snake (~snake@user/snake)
[00:46:36] <webnet4> big surprise you can gain performance by rewriginf some php app
[00:47:09] <InPhase> kill: It's probably a fine idea once Rust gets frameworks developed to help with the repetitive work that should be library based.
[00:47:43] <InPhase> kill: Until then it would involve doing more simple things, or taking responsibility to do more work manually.
[00:49:01] *** Joins: SGautam (uid286066@id-286066.charlton.irccloud.com)
[00:49:03] <kill> InPhase, I will give it a try
[00:49:21] <webnet4> woah didn't see that outcome manifesting
[00:49:48] <Izem> rust has networking/web stuff
[00:50:04] <Izem> e.g. net lib, deno
[00:50:12] <InPhase> kill: https://blog.logrocket.com/the-current-state-of-rust-web-frameworks/  It looks like there are many attempts at this, with most marked not production ready, but a few that are.
[00:50:15] <bayaz> Title: The current state of Rust web frameworks - LogRocket Blog 
[00:50:24] <InPhase> kill: I cannot personally vouch for the accuracy of these assessments.
[00:51:02] *** Joins: qu4nt1n (~qu4nt1n@78.198.214.34)
[00:51:09] <kill> InPhase, I would use it just for simple website, focused on SEO, no need for complexity
[00:51:34] <kill> not even login is necessary
[00:52:09] *** Joins: anton (~anton@tloks.com)
[00:52:15] <InPhase> kill: It might be a valuable learning experience then.
[00:52:44] <InPhase> kill: I do think it is probably a sensible future tool for this.
[00:53:00] *** Quits: qu4nt1n (~qu4nt1n@78.198.214.34) (Client Quit)
[00:53:02] <InPhase> kill: I just don't know when the "do it now" time was, is, or will be.  :)
[00:53:30] *** Joins: inky (~inky@46.36.113.172)
[00:53:42] <webnet4> they have their own TLS lib by now at least right?
[00:53:43] <kill> I will try
[00:54:18] <webnet4> if not RIP killown
[00:54:27] <Caffeinated> lol
[00:56:19] <InPhase> webnet4: rustls looks reasonable for use.
[00:56:33] *** Quits: Camilo (~hugh@37.120.133.74) (Ping timeout: 258 seconds)
[00:56:55] *** Quits: anton (~anton@tloks.com) (Client Quit)
[00:57:47] *** Joins: olle (~olle@i5E86667D.versanet.de)
[00:58:19] *** Joins: Camilo (~hugh@host-92-20-143-244.as13285.net)
[00:58:23] <olle> "Messy company culture/structure is as strong a fault predictor as messy code."
[00:58:33] *** Quits: jmft2 (~JMFT@82.3.54.26) (Ping timeout: 268 seconds)
[00:58:36] <olle> Should we talk more about "clean company"? Instead of only "clean code"?
[00:58:46] <olle> As a community.
[00:58:51] *** Quits: scabby (~scabby@user/scabootssca) (Ping timeout: 258 seconds)
[00:58:52] *** Quits: matrixskp (~matrixskp@121-75-182-31.dyn.vf.net.nz) (Quit: My comp has gone to sleep to save energy. ZZZzzzâ€¦)
[00:58:53] *** Joins: anton (~anton@tloks.com)
[00:59:12] *** Quits: Booster2ooo (~Booster2o@user/booster2ooo) (Quit: Lost the game...)
[00:59:28] <kill> I use python + flask already, wordpress is not being an option anymore
[00:59:47] <kill> but rust looks interesting, I just used it for parse some nginx logs
[00:59:51] <kill> very very fast
[00:59:54] <CuriousErnestBro> what's a tool for testing API's? I wanna send json data to mine
[00:59:57] <kill> infinitly fast
[01:00:08] <CuriousErnestBro> I think postman has now sign ups 
[01:00:08] *** Quits: yaboiburner (~yaboiburn@c-69-180-160-103.hsd1.mn.comcast.net) (Remote host closed the connection)
[01:00:36] *** Quits: Rashad (~textual@46.185.170.67) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[01:00:54] *** Quits: anton (~anton@tloks.com) (Remote host closed the connection)
[01:02:14] <Caffeinated> nothing is infinitely fast
[01:02:57] <Caffeinated> ~300M/s
[01:03:45] <Caffeinated> er 300million M/s
[01:04:04] *** Joins: Rashad (~textual@46.185.170.67)
[01:05:00] <webnet4> nice rustls should work unless you need SSL1 SSL2 SSL3, TLS1 or TLS1.1, or plan to run it on anything other than intel/arm
[01:06:17] <Caffeinated> nice rustls i like rustls it is fast
[01:06:38] *** Joins: Narrat (~omnius@p200300df5f0ae5b806ea56fffe2e7cdc.dip0.t-ipconnect.de)
[01:07:40] <InPhase> webnet4: You just listed the protocols that every expert says not to use...
[01:07:58] *** Quits: gamara (~gamara@66-203-186-167.ded.execulink.com) (Ping timeout: 246 seconds)
[01:08:07] *** Quits: jaysicks (~jaysicks@84-236-11-22.pool.digikabel.hu) (Remote host closed the connection)
[01:08:29] <c705> yeah do not use anything less than TLS 1.2. and fwiw, i believe 1.2 is EOL or quickly heading to EOL
[01:09:16] *** Quits: tradar (~tradar@user/tradar) (Ping timeout: 244 seconds)
[01:09:22] *** Joins: wootehfoot (~wootehfoo@user/wootehfoot)
[01:09:43] *** Quits: webnet4 (~0x100@32.211.211.39) (Remote host closed the connection)
[01:09:55] *** Joins: webnet4 (~0x100@32.211.211.39)
[01:10:00] *** Joins: jaysicks (~jaysicks@84-236-11-22.pool.digikabel.hu)
[01:10:31] *** Quits: gaurav_ (~usr123@124.253.244.157) (Remote host closed the connection)
[01:11:10] <CuriousErnestBro> ah a good day of abusing rust
[01:11:26] <CuriousErnestBro> http://0x0.st/-Jut.png
[01:11:27] <bayaz> Type: image/png Size: 169.5 kB 
[01:11:27] *** Joins: tradar (~tradar@user/tradar)
[01:11:38] *** Quits: webnet4 (~0x100@32.211.211.39) (Remote host closed the connection)
[01:11:50] *** Joins: webnet4 (~0x100@32.211.211.39)
[01:11:55] *** Quits: trace987 (~trace@ip5f5a6a70.dynamic.kabel-deutschland.de) (Remote host closed the connection)
[01:12:40] <webnet4> if they support TLS1.2 then why would they drop support for it
[01:13:04] *** Quits: vysn (~vysn@user/vysn) (Ping timeout: 272 seconds)
[01:13:13] <webnet4> you should be fine
[01:13:13] <webnet4> jk be afraid
[01:13:45] *** Quits: slavfox (~slavfox@93.158.232.111) (Quit: ZNC 1.8.2 - https://znc.in)
[01:14:58] *** Quits: GeDaMo (~GeDaMo@user/gedamo) (Quit: Leaving.)
[01:15:15] <webnet4> is it weird they have such activist stances on these matters, but also support session resumption?
[01:15:59] *** Quits: mickey8 (~user@user/mickey) (Ping timeout: 244 seconds)
[01:18:05] <Izem> CuriousErnestBro what is that editor?
[01:18:10] *** Joins: slavfox (~slavfox@93.158.232.111)
[01:18:24] <CuriousErnestBro> Izem visual studio code
[01:18:47] <Izem> ok
[01:19:35] *** Joins: jmft2 (~JMFT@81.149.115.87.dyn.plus.net)
[01:21:09] <CuriousErnestBro> Izem you probably want to know the theme?
[01:21:33] <Izem> no, just the editor
[01:22:33] *** Quits: tradar (~tradar@user/tradar) (Quit: tradar)
[01:22:42] *** Quits: bytecrawler (~bytecrawl@gateway/tor-sasl/bytecrawler) (Ping timeout: 244 seconds)
[01:23:34] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[01:26:09] *** Joins: sklv2 (~sklv@gateway/tor-sasl/sklv)
[01:26:33] *** Joins: sklv3 (~sklv@gateway/tor-sasl/sklv)
[01:26:55] *** mnrmnaugh is now known as KeziahMason
[01:28:25] *** Joins: sklv4 (~sklv@gateway/tor-sasl/sklv)
[01:29:07] *** KeziahMason is now known as mnrmnaugh
[01:29:25] *** Quits: sklv1 (~sklv@gateway/tor-sasl/sklv) (Ping timeout: 244 seconds)
[01:29:31] <beaky> nice theme it is now my current favorite theme
[01:29:31] *** Quits: Pickchea (~private@user/pickchea) (Quit: Leaving)
[01:29:48] <beaky> the ayu theme
[01:30:05] <pyzozord> beaky: did you build that wall in the end? :P
[01:30:27] *** Quits: sklv2 (~sklv@gateway/tor-sasl/sklv) (Ping timeout: 244 seconds)
[01:30:34] <beaky> no i still dont know how to prove my solution is the most 'minimal' blocks
[01:31:04] <beaky> i have only modeled the problem and output but not the proof or solution algorithm
[01:31:23] <beaky> since there needs to be a proof that it is the most optimal i.e. minimal solution
[01:31:24] <pyzozord> I ran into the same problem first time. Except without formal proofs. I just didn't know how to answer the question "is this the most optimal configuration" even on paper
[01:32:00] *** Quits: sklv3 (~sklv@gateway/tor-sasl/sklv) (Ping timeout: 244 seconds)
[01:32:16] <pyzozord> This time around I just ignored it and wrote simple stack solution. And it was correct
[01:32:43] <Izem> what problem?
[01:32:59] <pyzozord> Izem: https://app.codility.com/programmers/lessons/7-stacks_and_queues/stone_wall/
[01:33:01] <bayaz> Title: StoneWall coding task - Learn to Code - Codility 
[01:33:12] <beaky> i think the proof would look like this: assume it is not the minimal solution i.e. you can 'reuse' a wall, so you find that its impossible to do so, thus a contradiction
[01:33:57] <beaky> now i will actually type this out in agda 
[01:35:07] *** Quits: lavos (~molt@95.155.22.30) (Quit: Leaving)
[01:35:30] *** Joins: molt (~molt@95.155.22.30)
[01:35:44] <Caffeinated> so you keep saying
[01:36:44] <pyzozord> beaky: if you figure out how to prove it let me know (in plain english though :P), I'd be curious to find out. 
[01:36:55] *** Joins: scabby_ (~scabby@user/scabootssca)
[01:37:07] <Izem> question unclear :/
[01:38:08] *** Joins: Donitz (~Donitz@85-156-203-108.elisa-laajakaista.fi)
[01:39:21] *** Quits: rtypo (~alex@user/rtypo) (Ping timeout: 248 seconds)
[01:42:34] <pyzozord> I don't know that counts as a formal proof but you can write a brute force algorithm and just count
[01:43:29] *** Quits: wovixo (~wovixo@128.104.205.49) (Quit: Leaving)
[01:43:51] *** Quits: Thedarkb (~Thedarkb@85.255.236.109) (Read error: No route to host)
[01:44:08] *** Joins: Thedarkb (~Thedarkb@85.255.236.109)
[01:46:06] *** Joins: Joanna (uid57472@id-57472.tooting.irccloud.com)
[01:46:21] <pyzozord> No matter how you "cut" the blocks from the image you always end up with 7 blocks, so that might be something useful for the formal proof?
[01:47:04] *** Quits: biberu (~biberu@user/biberu) (Read error: Connection reset by peer)
[01:47:24] <beaky> yes tha tis the way the proof by contradiction goes i think soon i will finish typing this up after a few more sips of tea
[01:48:45] <pyzozord> I discovered the "cutting" idea year ago, but I didn't know how to make sure it was true for all inputs, not just the example
[01:48:49] <Lyn> I heard PostgreSQL doesn't store the data in any ordered way - isn't that a huge performance loss when trying to look up data?
[01:51:19] *** Quits: Izem (~Izem@8.21.10.18) (Quit: Going offline, see ya! (www.adiirc.com))
[01:52:58] <c705> lookup tables are cheap, so not nessecarily
[01:53:05] <c705> aka hash tables
[01:54:13] <beaky> yes for retrieval an index is used
[01:54:45] <beaky> an index can be used* you usually have to define an index over the data / queries you expect to run
[01:56:23] *** Quits: wedr (~wedr@pool-108-20-128-8.bstnma.fios.verizon.net) (Quit: Leaving)
[01:59:14] *** Joins: lavos (~molt@79.140.150.21)
[01:59:28] *** Joins: exvicesindaco (~exvicio@user/exvicesindaco)
[01:59:37] *** Quits: lavos (~molt@79.140.150.21) (Client Quit)
[02:00:00] *** Joins: lavos (~molt@79.140.150.21)
[02:00:07] *** Quits: thaw (~thaw@static-47-207-6-117.tamp.fl.frontiernet.net) (Ping timeout: 246 seconds)
[02:00:30] *** nekodesu is now known as nekobased
[02:03:44] *** Quits: molt (~molt@95.155.22.30) (Ping timeout: 272 seconds)
[02:06:28] *** Joins: Rounin (~david@84.212.130.215)
[02:06:49] *** Joins: jmcantre1 (~weechat@user/jmcantrell)
[02:07:02] *** Joins: biberu (~biberu@user/biberu)
[02:07:39] <pyzozord> how about this: the wall needs to be built from cuboids, that means that each change in elevation of the wall requires at maximum 1 cuboids. That means that the highest minimal number of blocks requierd is N where N is the number of changes in elevation of the wall. so we know that there must be <=N blocks.
[02:08:25] <pyzozord> Then I'm not sure how to capture the idea that some specific elevation patterns like 121 require only two blocks
[02:09:05] <pyzozord> That would prove it I guess.
[02:09:16] *** Joins: gamara (~gamara@66-203-186-167.ded.execulink.com)
[02:09:45] *** Quits: __jmcantrell__ (~weechat@user/jmcantrell) (Ping timeout: 248 seconds)
[02:10:03] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[02:10:57] *** Quits: TechTest (uid283215@id-283215.tooting.irccloud.com) (Quit: Connection closed for inactivity)
[02:12:03] *** Quits: aradesh (~aradesh@user/aradesh) (Quit: WeeChat 1.9.1)
[02:12:05] *** Joins: sklv (~sklv@gateway/tor-sasl/sklv)
[02:12:19] *** Joins: jmcantre2 (~weechat@user/jmcantrell)
[02:12:47] <pyzozord> "highest minimal" is kind of bs but you get what I mean. The upper bound of potentially minimal :P
[02:13:47] *** Quits: jmcantre1 (~weechat@user/jmcantrell) (Ping timeout: 268 seconds)
[02:13:49] *** Joins: pretty_dumm_guy (trottel@gateway/vpn/protonvpn/prettydummguy/x-88029655)
[02:15:38] *** Quits: __jmcantrell__ (~weechat@user/jmcantrell) (Ping timeout: 268 seconds)
[02:15:45] *** Quits: JackFin (~ircuser@S01069050ca4e3573.cg.shawcable.net) (Quit: Connection closed)
[02:15:55] *** Quits: sklv4 (~sklv@gateway/tor-sasl/sklv) (Ping timeout: 244 seconds)
[02:15:59] *** Quits: gamara (~gamara@66-203-186-167.ded.execulink.com) (Quit: Client closed)
[02:16:02] *** Quits: znedw (~znedw@home.znedw.com) (Quit: The Lounge - https://thelounge.chat)
[02:19:22] <pyzozord> Or here is another one, I think this one might be best. Here are all 3-element patterns that produce reduced number of blocks (2). All 3-element patterns not listed produce ful number of blocks (3)
[02:19:33] <pyzozord> [n,n,n] = 1, [n+1,n,n] = 2, [n,n+1,n] = 2, [n,n,n+1] = 2, [n+1,n+1,n] = 2, [n,n+1,n+1] = 2, [n+1,n,n+1] = 2
[02:19:42] *** Joins: znedw (~znedw@home.znedw.com)
[02:19:56] <pyzozord> I guess +1 should be changed to +m
[02:20:25] <pyzozord> Yey, I think I just made my first proof by induction
[02:20:54] *** Quits: lavos (~molt@79.140.150.21) (Quit: Leaving)
[02:21:29] *** Quits: anon16 (~anon16@user/anon16) (Ping timeout: 248 seconds)
[02:21:39] <pyzozord> I need to read some math books about this, this could be quite fun
[02:21:48] *** Quits: xeno (~xeno@user/xeno) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[02:22:01] <beaky> i am almost done iwth the proof all i have to do is convince agda that my proof is terminating
[02:22:34] <beaky> it is an inductive proof over the stack of previous blocks and the array H 
[02:23:00] *** Joins: xeno (~xeno@user/xeno)
[02:23:39] *** Joins: anon16 (~anon16@user/anon16)
[02:24:25] <pyzozord> I think I tought myself something important just now. This could be useful with future competetive programming challanges
[02:24:43] <beaky> yes this is why it is an important exercise to prove your algorithm correct 
[02:25:13] *** Quits: sklv (~sklv@gateway/tor-sasl/sklv) (Ping timeout: 244 seconds)
[02:27:12] <pulse> scientists prove, engineers test and benchmark
[02:27:36] *** Quits: kill (~killown@user/killown) (Quit: Leaving)
[02:29:02] <c705> scientists don't prove jack shit. science is about modeling and predictions
[02:29:11] *** Quits: olle (~olle@i5E86667D.versanet.de) (Ping timeout: 268 seconds)
[02:29:17] <pyzozord> I think engineers have something to learn from engineers scientists and scientists have something to learn from engineers
[02:29:36] <pyzozord> oops too many engineers, replace one with scientists
[02:30:11] <pyzozord> oh actually no, just remove second engineers, no need to replace anything
[02:30:11] <Caffeinated> rofl
[02:31:15] *** Joins: merijn (~merijn@83-160-49-249.ip.xs4all.nl)
[02:31:17] <pulse> mathematicians prove, scientists model, engineers solder wires together
[02:31:45] <Caffeinated> and universities charge lots of money to become a software engineer
[02:31:57] *** Quits: Akuli (~Akuli@82-203-165-178.bb.dnainternet.fi) (Quit: Leaving)
[02:32:03] *** Quits: gdarko (~me@dg.mk) (Remote host closed the connection)
[02:33:34] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[02:34:02] *** Quits: mei (~mei@user/mei) (Read error: Connection reset by peer)
[02:35:11] *** Joins: gamara (~gamara@66-203-186-167.ded.execulink.com)
[02:35:23] *** Joins: gdarko (~me@dg.mk)
[02:35:52] <gamara> hey anyone know why this bash script isn't working? The command is valid, and the file just contains IP ranges like 1.1.1.1-4.4.4.4 
[02:35:52] <gamara> while read ip; do
[02:35:53] <gamara>         sudo iptables -A INPUT -m iprange --src-range $ip -j DROP \n
[02:35:53] <gamara> done < iprange.txt
[02:36:11] <gamara> ignore the \n
[02:36:25] *** Quits: jmcantre2 (~weechat@user/jmcantrell) (Ping timeout: 248 seconds)
[02:36:28] *** Quits: chomwitt (~chomwitt@ppp-2-85-147-24.home.otenet.gr) (Remote host closed the connection)
[02:36:32] <Caffeinated> pastebin is good for putting code so you don't flood a channel
[02:36:36] *** Quits: mci64 (~mci64@185.242.190.95) (Ping timeout: 268 seconds)
[02:36:40] *** Quits: mrig (~mrig@user/mrig) (Quit: WeeChat 3.2)
[02:36:46] <gamara> i figured it was 3 lines but I will take note nexttime
[02:36:52] *** Joins: Fluxx (~Fluxx@user/fluxx)
[02:37:26] <Caffeinated> termbin.com port 9999 is awesome for pasting from console..
[02:37:48] <Caffeinated> cat mysource.| nc termbin.com 9999
[02:38:08] <gamara> it seems to only be passing the first half of the ip
[02:38:19] <gamara> ange
[02:38:21] <gamara> range*
[02:38:56] *** Quits: wootehfoot (~wootehfoo@user/wootehfoot) (Read error: Connection reset by peer)
[02:39:05] <Caffeinated> if that's bash i would try putting double quotes " around anything with $vars in it
[02:39:18] <Caffeinated> just to make sure it/they are expanded properly
[02:39:32] <gamara> its bash
[02:39:46] *** Joins: mickey86 (~user@user/mickey)
[02:39:47] <Caffeinated> ok just fyi there is also a #bash channel on Libera :D
[02:39:51] *** Quits: gilesc (~textual@2603-8001-3600-dad7-5818-2741-ece0-27c4.res6.spectrum.com) (Quit: Textual IRC Client: www.textualapp.com)
[02:40:00] <gamara> oh really ok I will go there in the future thanks
[02:40:02] <gamara> sorry about that
[02:40:08] <Caffeinated> eh no worries
[02:40:21] <Caffeinated> i've found them very helpful there
[02:40:37] <Caffeinated> their reference website is a huge rabbit hole heh
[02:40:37] *** Quits: lunarkitty (uid501895@user/pyra) (Quit: Connection closed for inactivity)
[02:40:50] *** Joins: anton (anton@tloks.com)
[02:41:35] *** Quits: LiftLeft (~LiftLeft@154.21.114.33) (Ping timeout: 258 seconds)
[02:41:46] *** Joins: matrixskp (~matrixskp@121-75-182-31.dyn.vf.net.nz)
[02:41:49] *** Joins: jmcantre1 (~weechat@user/jmcantrell)
[02:42:04] *** Joins: Inline_ (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431)
[02:42:08] *** Quits: Camilo (~hugh@host-92-20-143-244.as13285.net) (Ping timeout: 268 seconds)
[02:42:21] *** Quits: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431) (Ping timeout: 258 seconds)
[02:42:24] *** Quits: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de) (Ping timeout: 276 seconds)
[02:43:44] *** Joins: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de)
[02:45:02] *** Quits: __jmcantrell__ (~weechat@user/jmcantrell) (Ping timeout: 258 seconds)
[02:47:20] *** Quits: gitesh (uid423739@id-423739.charlton.irccloud.com) (Quit: Connection closed for inactivity)
[02:47:34] *** Quits: gdarko (~me@dg.mk) (Quit: ZNC 1.8.2 - https://znc.in)
[02:49:12] *** Quits: DushyantBaweja_c (uid510682@id-510682.charlton.irccloud.com) (Quit: Connection closed for inactivity)
[02:50:30] *** Joins: rtypo (~alex@user/rtypo)
[02:50:42] *** Quits: exvicesindaco (~exvicio@user/exvicesindaco) (Quit: Going offline, see ya! (www.adiirc.com))
[02:51:41] *** Quits: Hanii (~textual@2a00:23c5:c587:6d00:2851:91a4:af4c:7957) (Quit: Textual IRC Client: www.textualapp.com)
[02:51:52] *** Quits: FoodMan (~FoodMan@cpc104776-belf12-2-0-cust417.2-1.cable.virginm.net) (Ping timeout: 272 seconds)
[02:52:04] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[02:52:16] *** Joins: gdarko (~me@dg.mk)
[02:52:28] *** Quits: __jmcantrell__ (~weechat@user/jmcantrell) (Client Quit)
[02:52:31] *** Quits: nekobased (~nano@user/nekobit) (Quit: free(neko);)
[02:53:14] *** Quits: plastico (~plastico@neomutt/plastico) (Quit: WeeChat 3.2)
[02:53:23] *** Joins: LiftLeft (~LiftLeft@212.102.59.168)
[02:55:05] *** Quits: jmcantre1 (~weechat@user/jmcantrell) (Ping timeout: 248 seconds)
[02:55:39] *** Quits: Tazmainian (~Tazmainia@41.193.169.28) (Read error: Connection reset by peer)
[02:57:10] *** Joins: lunarkitty (uid501895@user/pyra)
[02:57:23] *** Quits: ixil (~ixil@82.197.178.137) (Remote host closed the connection)
[02:58:25] *** Quits: bcd (~bcd@83-84-164-51.cable.dynamic.v4.ziggo.nl) (Remote host closed the connection)
[02:58:27] *** Quits: SGautam (uid286066@id-286066.charlton.irccloud.com) (Quit: Connection closed for inactivity)
[02:59:28] *** Quits: Narrat (~omnius@p200300df5f0ae5b806ea56fffe2e7cdc.dip0.t-ipconnect.de) (Quit: They say a little knowledge is a dangerous thing, but it's not one half so bad as a lot of ignorance.)
[03:01:14] *** Joins: nekodesu (~nano@user/nekobit)
[03:01:36] *** Quits: gamara (~gamara@66-203-186-167.ded.execulink.com) (Quit: Client closed)
[03:02:18] *** Joins: BrianG61UK (~BrianG61U@2a02:8010:66b7:dddd:994b:13cd:c8da:96fc)
[03:05:32] *** Quits: BrianG61UK (~BrianG61U@2a02:8010:66b7:dddd:994b:13cd:c8da:96fc) (Client Quit)
[03:05:48] *** Quits: merijn (~merijn@83-160-49-249.ip.xs4all.nl) (Ping timeout: 272 seconds)
[03:07:24] <beaky> nice i have almost finish proving the solution to the wall problem correct but i still havent figured out how to make the proof terminating https://bpa.st/D7VA the idea is that you can only support a new length of wall with an existing block if and only if there is a previous 'support' of equal size, and the height of the support grows if and only if there is a higher section of the wall
[03:07:26] <beaky> being placed (since you can 'extend' the length of the support to fit). all that remains to be proven is (1) termination and (2) that the wall is indeed using the supports and not adding extra blocks
[03:07:26] <bayaz> Title: View paste D7VA 
[03:09:03] *** Joins: BrianG61UK (~BrianG61U@2a02:8010:66b7:dddd:994b:13cd:c8da:96fc)
[03:10:25] *** Quits: matrixskp (~matrixskp@121-75-182-31.dyn.vf.net.nz) (Quit: Textual IRC Client: www.textualapp.com)
[03:11:03] *** Joins: BrianG61UK_ (~BrianG61U@2a02:8010:66b7:dddd:9882:5d69:12df:2a8c)
[03:11:29] *** Quits: Pixi (~Pixi@user/pixi) (Quit: Leaving)
[03:11:47] *** Joins: Pixi (~Pixi@user/pixi)
[03:14:40] *** Quits: Inline_ (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431) (Ping timeout: 272 seconds)
[03:15:14] *** Quits: cog (~Atlas@2604:3d08:b27f:ae00:912f:6c43:4e9d:1b80) (Remote host closed the connection)
[03:15:26] <Caffeinated> cvplay-by-pl;ay
[03:15:27] *** Quits: Burgundy (~yomon@5-12-93-72.residential.rdsnet.ro) (Ping timeout: 268 seconds)
[03:15:37] <Caffeinated> gah keyboard crunchies
[03:15:41] <beaky> so how do i prove termination
[03:15:49] <Caffeinated> just stop
[03:15:51] <Caffeinated> lol
[03:16:01] <beaky> but i am so close to a complete proof
[03:16:19] <Caffeinated> its amazing how so many people live in their own tiny world
[03:16:25] *** Quits: AsenMx (~AsenMx@78.90.248.234) (Ping timeout: 248 seconds)
[03:17:07] <pyzozord> beaky: yeah I can't read that
[03:17:16] <Caffeinated> haha
[03:17:18] <pyzozord> looks like gibbrish to me
[03:17:28] <Caffeinated> it most likely is
[03:17:37] <beaky> but i ran it and it outputted 7 for the example
[03:17:37] <webnet4> aw posting gifs is a no-go on bpa.st
[03:17:58] <pyzozord> webnet4: https://imgur.com/upload
[03:18:15] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[03:18:17] <webnet4> imgur broke non-js clients without just cause
[03:18:23] <webnet4> i'm boycotting
[03:18:40] <pyzozord> beaky: looks like your support idea is very similar to my idea with patterns
[03:19:14] <pyzozord> webnet4: understandable
[03:19:17] <beaky> pyzozord: so i define a data type named 'support' indexed by a natural number n which is the proof that you can support a new block of height n (since it takes a proof that there is already a previous block of that size there) and if you have a higher block then you can support higher walls
[03:20:02] <beaky> like a dependently-typed stack
[03:20:41] *** Quits: jmft2 (~JMFT@81.149.115.87.dyn.plus.net) (Ping timeout: 258 seconds)
[03:20:42] <pyzozord> yep got that, your idea is simpler and more elegant, mine patterns idea is more "brute force"
[03:21:13] *** Quits: LucaTM (~LucaTM@user/lucatm) (Quit: Textual IRC Client: www.textualapp.com)
[03:21:31] <beaky> the idea is that n is monotonically increasing so it is not possible to 'support' a new wall block of smaller height you must therefore add a new block (that i also have to prove next)
[03:22:58] <beaky> or in other words it is only possible to reuse a smaller block if that wall is already itself supported by that smaller block of the exact same size (by recursively checking down the Support data type until it is found, and if not then the new block is added)
[03:24:04] <beaky> because it is monotonic i dont need to check the entire stack (so in the > case i grow the wall with a new block)
[03:25:15] <beaky> wait its not monotonic it is strictly increasing
[03:25:20] *** Quits: snake (~snake@user/snake) (Read error: Connection reset by peer)
[03:25:39] *** Joins: snake (~snake@user/snake)
[03:25:45] <Caffeinated> lol
[03:26:29] *** Quits: Duckle (~Duckle@user/duckle) (Quit: Ping timeout (120 seconds))
[03:27:20] *** Joins: DarkCthulhu (~DarkCthul@96.74.77.193)
[03:27:42] *** Joins: Izem (~Izem@bras-base-london1483w-grc-43-65-95-173-5.dsl.bell.ca)
[03:27:52] <DarkCthulhu> woof woof
[03:28:00] <beaky> hello im beaky
[03:28:26] <Twix> Hello beaky
[03:28:32] <Caffeinated> hahaha
[03:28:36] *** Quits: vin (~vin@user/crash) (Ping timeout: 272 seconds)
[03:28:39] *** Joins: Duckle (~Duckle@user/duckle)
[03:29:06] <pyzozord> oh i just realized my proof won't work, you can't just sum 3-element and 2-element patterns
[03:30:07] <audiocat> i need some git help. i have a project that contains ~30 directories (python & vba) that are all their own separate projects. this is for a client. because of the size, should i just create one repo, or should i create one repo for each project?
[03:31:49] <Twix> audiocat, as you like. If you decide to use a repo for each subproject, use a meta tool like west or repo to manage it
[03:31:52] <DarkCthulhu> Could there be cross-dependencies between different modules at some point? I tend to go towards a monorepo in that case. Setting up and managing automation for 30 repos is a lot of work. 
[03:32:29] *** Joins: vin (~vin@user/crash)
[03:32:41] *** Quits: DarkCthulhu (~DarkCthul@96.74.77.193) (Remote host closed the connection)
[03:33:01] *** Joins: DarkCthulhu (~DarkCthul@96.74.77.193)
[03:33:09] <audiocat> Twix, could you send me a llink to "repo"?
[03:33:28] *** Quits: Natch (~natch@c-e070e255.014-297-73746f25.bbcust.telenor.se) (Remote host closed the connection)
[03:33:31] *** Joins: jmcantre1 (~weechat@user/jmcantrell)
[03:34:11] *** jmcantre1 is now known as jmcantrell
[03:34:20] <dre> audiocat, just monorepo
[03:34:22] <dre> kiss
[03:34:24] *** Parts: Izem (~Izem@bras-base-london1483w-grc-43-65-95-173-5.dsl.bell.ca) (Closing Window)
[03:34:29] * Twix does google
[03:34:38] * Twix hits the fist link
[03:34:39] <Twix> https://gerrit.googlesource.com/git-repo/+/refs/heads/master/README.md
[03:34:40] <bayaz> Title: repo 
[03:35:04] <Caffeinated> search skills do seem to be in short supply in most people these days
[03:36:47] *** Quits: __jmcantrell__ (~weechat@user/jmcantrell) (Ping timeout: 258 seconds)
[03:37:34] <Twix> this one is a bit hard. But if you append "tool" or "git" to it, you still get fast where you want
[03:38:09] <pyzozord> well will need to actually read those mathy books to make proofs after all, no suprise
[03:38:29] <Twix> but i think i would use west these days. As it allows for a bit more integration into the build system ...
[03:39:30] *** Quits: dermato (~dermatobr@154.21.23.75) (Ping timeout: 268 seconds)
[03:40:17] <beaky> yes i highly recommend the software foundations book for an introduction to proofs https://softwarefoundations.cis.upenn.edu/
[03:40:18] <bayaz> Title: Software Foundations 
[03:40:24] <beaky> using coq
[03:40:35] *** Quits: webnet4 (~0x100@32.211.211.39) (Remote host closed the connection)
[03:40:48] *** Joins: webnet4 (~0x100@32.211.211.39)
[03:41:35] <beaky> it is a book but the book really is the set of coq files you download and work through in coq by reading the comments and hitting 'next' in the ide
[03:42:42] *** Joins: dermato (~dermatobr@154.21.23.75)
[03:43:30] <cis> a coq carousel, if you will
[03:43:47] *** Joins: DarkCth74 (~DarkCthul@2607:fb90:9cf3:a6a2:bbb4:e8ed:40cc:5432)
[03:44:41] *** DarkCthulhu is now known as Guest9736
[03:44:55] *** Quits: DarkCth74 (~DarkCthul@2607:fb90:9cf3:a6a2:bbb4:e8ed:40cc:5432) (Client Quit)
[03:45:14] *** Joins: DarkCth39 (~DarkCthul@2607:fb90:9cf3:a6a2:bbb4:e8ed:40cc:5432)
[03:45:49] *** DarkCth39 is now known as DarkCthulhu
[03:46:20] *** Quits: Guest9736 (~DarkCthul@96.74.77.193) (Ping timeout: 272 seconds)
[03:47:06] <pyzozord> nic, thanks for the recommendation
[03:47:48] *** Parts: Raguile (~Raguile@user/raguile) ()
[03:47:50] <DarkCthulhu> I wish there was some structured way to find things when you don't know precisely what they're called. Today, the process is just fuzzily describing the concept in some verbose way and hoping someone described it that way too on the internet. That is a little non-deterministic and relies heavily on a mental model that's at least somewhat correct. 
[03:48:14] *** Quits: gitgoood (~gitgood@80-44-15-108.dynamic.dsl.as9105.com) (Ping timeout: 272 seconds)
[03:49:15] <beaky> yes irc helps alot in that i think 
[03:50:55] <DarkCthulhu> True, I think in that scenario, relying on people is probably the most deterministic way to get an answer. 
[03:51:05] *** Quits: jaysicks (~jaysicks@84-236-11-22.pool.digikabel.hu) (Ping timeout: 248 seconds)
[03:51:07] <edgar-rft> me orders some coq au vin
[03:51:22] <Caffeinated> they're called "search engines"
[03:51:32] *** Joins: jaysicks (~jaysicks@62-165-243-200.pool.digikabel.hu)
[03:51:57] * vdamewood gives edgar-rft some coq au vinegar.
[03:52:00] *** Quits: zwr (~zwr@2804:d45:b966:fb00:fb3d:9212:4807:9b0e) (Remote host closed the connection)
[03:52:02] *** Quits: webnet4 (~0x100@32.211.211.39) (Remote host closed the connection)
[03:52:38] *** Joins: nevrgofulspecial (~0x100@32.211.211.39)
[03:52:40] <DarkCthulhu> Caffeinated: wow. I had no idea such things existed.
[03:52:47] <Caffeinated> apparently
[03:52:54] <DarkCthulhu> Please enlighten me
[03:53:39] *** Quits: shokohsc (~shokohsc@161.88.195.77.rev.sfr.net) (Remote host closed the connection)
[03:53:58] <LjL> sometimes when i spell out the concept in whichever way i can, but i do that explicitly, suddenly i remember the term
[03:54:23] *** Joins: shokohsc (~shokohsc@161.88.195.77.rev.sfr.net)
[03:54:26] <LjL> it happens when i'm typing it in search engines sometimes, or when i'm talking to someone and just giving up and telling them "look i mean this thing, i don't know how to say it, ..... <thing is recalled>"
[03:54:55] *** Quits: Crescendo (~Crescendo@user/crescendo) (Ping timeout: 268 seconds)
[03:55:27] *** Joins: Crescendo (~Crescendo@user/crescendo)
[03:55:47] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[03:57:23] *** Quits: jaysicks (~jaysicks@62-165-243-200.pool.digikabel.hu) (Ping timeout: 268 seconds)
[03:57:31] *** Joins: jaysicks (~jaysicks@80-95-81-41.pool.digikabel.hu)
[03:57:38] <DarkCthulhu> LjL: I know what you mean.. sometimes I've repeated that exact same thought process many times to arrive at the name but never thought to "memoize" that lookup 
[03:58:24] <DarkCthulhu> ...which in case would be memoRIzation
[03:59:00] *** Quits: jmcantrell (~weechat@user/jmcantrell) (Ping timeout: 272 seconds)
[04:00:42] *** Quits: Auron (~Auron956@user/auron) (Remote host closed the connection)
[04:02:03] *** Joins: foxish (~foxish@50-202-37-133-static.hfc.comcastbusiness.net)
[04:02:05] *** Quits: dermato (~dermatobr@154.21.23.75) (Ping timeout: 258 seconds)
[04:02:18] *** Parts: foxish (~foxish@50-202-37-133-static.hfc.comcastbusiness.net) ()
[04:02:59] *** Joins: DarkCthulhu_ (~foxish@50-202-37-133-static.hfc.comcastbusiness.net)
[04:03:01] *** Quits: DarkCthulhu (~DarkCthul@2607:fb90:9cf3:a6a2:bbb4:e8ed:40cc:5432) (Quit: bye)
[04:04:18] *** Quits: pretty_dumm_guy (trottel@gateway/vpn/protonvpn/prettydummguy/x-88029655) (Quit: WeeChat 3.2)
[04:05:02] *** Joins: dermato (~dermatobr@154.21.23.75)
[04:06:36] *** Quits: DarkCthulhu_ (~foxish@50-202-37-133-static.hfc.comcastbusiness.net) (Client Quit)
[04:07:12] *** Joins: jmcantrell (~weechat@user/jmcantrell)
[04:08:41] *** Quits: jaysicks (~jaysicks@80-95-81-41.pool.digikabel.hu) (Ping timeout: 248 seconds)
[04:09:04] *** Joins: jaysicks (~jaysicks@188-143-64-124.pool.digikabel.hu)
[04:10:17] *** Quits: __jmcantrell__ (~weechat@user/jmcantrell) (Ping timeout: 248 seconds)
[04:13:46] *** Joins: oft_gegong (~oft_gegon@70.90.132.249)
[04:14:26] <oft_gegong> programming is 97%bad. You edit text files thinking you're a god. you're a god because you're a god, not so you can manipulate a screen.
[04:15:31] <LjL> ok
[04:15:34] *** Quits: nevrgofulspecial (~0x100@32.211.211.39) (Remote host closed the connection)
[04:15:46] *** Joins: nevrgofulspecial (~0x100@32.211.211.39)
[04:20:21] <oft_gegong> that being said we have to do programming because it's the only thing to do in this abominable world.
[04:20:26] *** Joins: mrteals (~mistertea@pool-98-116-189-184.nycmny.fios.verizon.net)
[04:20:53] *** Quits: Mangy_Dog (Mange@user/mangy-dog/x-7397214) (Ping timeout: 252 seconds)
[04:21:43] <Caffeinated> is that what you really believe?
[04:21:56] <oft_gegong> 38%yes
[04:22:07] <Caffeinated> if so I think you really ought to go outside more
[04:22:10] *** Joins: rty (~rty@212.102.39.157)
[04:22:44] <oft_gegong> the outside of full of extra actors that don't know anything except to consume space. like the Truman Show.
[04:22:53] <Caffeinated> what's with all the xx% cruft
[04:22:58] <Caffeinated> oh dear
[04:23:00] <Caffeinated> I see now
[04:23:07] <Caffeinated> Carry on o/
[04:23:35] <oft_gegong> the xx% is my attempt at control
[04:24:14] *** Quits: nevrgofulspecial (~0x100@32.211.211.39) (Remote host closed the connection)
[04:24:27] *** Joins: nevrgofulspecial (~0x100@32.211.211.39)
[04:25:15] <oft_gegong> if I was a god and a programmer I would hate myself. Imagine what I could do..almost nothing.
[04:25:45] *** Quits: amahl (~amahl@dsl-jklbng12-54fbca-64.dhcp.inet.fi) (Ping timeout: 268 seconds)
[04:25:54] *** Quits: nevrgofulspecial (~0x100@32.211.211.39) (Remote host closed the connection)
[04:26:06] *** Joins: nevrgofulspecial (~0x100@32.211.211.39)
[04:26:30] *** Quits: Crescendo (~Crescendo@user/crescendo) (Read error: Connection reset by peer)
[04:26:42] *** Joins: Crescendo (~Crescendo@user/crescendo)
[04:28:25] <oft_gegong> if I could relearn programming from scratch: I would go outside and scream.
[04:30:05] <jmcantrell> anyone know of an example of a backup retention policy algorithm (hourly, daily, etc)?
[04:30:29] <oft_gegong> jmcantrell: you mean like rsync through a cron/anacron job?
[04:30:41] *** Quits: mrteals (~mistertea@pool-98-116-189-184.nycmny.fios.verizon.net) (Ping timeout: 268 seconds)
[04:31:57] <jmcantrell> oft_gegong: i'm dealing with btrfs snapshots. just trying to determine which snapshots need to be deleted based on a retention policy. ideally it would be a generic command line utility similar to logrotate
[04:33:19] <jmcantrell> borg prune works similarly. i'm trying to pull the algorithm from that, but i didn't want to reinvent the wheel too much
[04:34:11] <beaky> nice i have figured out how to make my proof terminate it turns out there was a longstanding issue with agda's with-abstraction clauses and the termination checker that has gotten resolved https://github.com/agda/agda/blob/v2.6.1/CHANGELOG.md#termination-checking
[04:34:32] <Caffeinated> lol
[04:37:16] *** Joins: penguino (~mrpenguin@user/mrpenguin)
[04:38:43] <oft_gegong> I take these weird psyche drugs. I can't learn anymore.
[04:39:18] *** Joins: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431)
[04:40:03] *** Quits: lockywolf (~lockywolf@vultr-seoul-openbsd.lockywolf.net) (Quit: ZNC 1.8.2 - https://znc.in)
[04:40:07] *** Joins: gambl0re (~gambl0re@24.140.237.124)
[04:40:19] *** Joins: lockywolf (~lockywolf@vultr-seoul-openbsd.lockywolf.net)
[04:40:48] *** Quits: jarthur (~jarthur@2603-8080-1540-002d-193e-00d5-a539-86a3.res6.spectrum.com) (Ping timeout: 272 seconds)
[04:44:50] *** Quits: rty (~rty@212.102.39.157) (Quit: rty)
[04:47:29] *** Joins: jarthur (~jarthur@2603-8080-1540-002d-bda2-5884-d97f-5fa4.res6.spectrum.com)
[04:50:32] *** Quits: federico_it (~textual@151.95.116.125) (Quit: Textual IRC Client: www.textualapp.com)
[04:51:01] *** Quits: shailangsa (~shailangs@host86-185-58-139.range86-185.btcentralplus.com) (Ping timeout: 268 seconds)
[04:51:29] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[04:54:45] *** Joins: jmcantre1 (~weechat@user/jmcantrell)
[04:55:20] *** Joins: jmcantre2 (~weechat@user/jmcantrell)
[04:55:58] *** Quits: jmcantrell (~weechat@user/jmcantrell) (Ping timeout: 268 seconds)
[04:56:35] *** Joins: jmcantrell (~weechat@user/jmcantrell)
[04:57:21] <audiocat> anyone really good with git?
[04:58:03] *** Quits: __jmcantrell__ (~weechat@user/jmcantrell) (Ping timeout: 258 seconds)
[04:59:12] *** Quits: jmcantre1 (~weechat@user/jmcantrell) (Ping timeout: 258 seconds)
[04:59:16] <oft_gegong> I can call git --help | less and search stuff :D
[04:59:35] <mawk> yes audiocat ask your question
[05:00:25] *** Quits: jmcantre2 (~weechat@user/jmcantrell) (Ping timeout: 248 seconds)
[05:00:37] *** Quits: lunarkitty (uid501895@user/pyra) (Quit: Connection closed for inactivity)
[05:01:38] *** Quits: nevrgofulspecial (~0x100@32.211.211.39) (Remote host closed the connection)
[05:01:53] *** Joins: merijn (~merijn@83-160-49-249.ip.xs4all.nl)
[05:01:57] *** Joins: webnet4 (~0x100@32.211.211.39)
[05:02:10] <audiocat> mawk, i got a zip from a client of a code repo on which i am to work. but then he needed to make a change and sent me an updated zip. the original code is at a remote repo I created. and the new code is at a local repo. i had to do a new `git commit` for the newest changes at my local repo. i tried to push to the remote repo but it said i need to pull first. i tried to pull and it said one of my files 
[05:02:11] <audiocat> would be overwritten by merge. so what should i do? would `git stash`, `git pull`, `git stash pop` work?
[05:02:30] <webnet4> git uses SHA1, isn't that the reason TLS1.1 is now shunned?
[05:03:18] <oft_gegong> audiocat: I'm 7%sure `git pull` is what you want.
[05:03:32] <Caffeinated> 7% sure
[05:03:33] <Caffeinated> lol
[05:04:04] *** Quits: Donitz (~Donitz@85-156-203-108.elisa-laajakaista.fi) (Read error: Connection reset by peer)
[05:08:02] <mawk> audiocat: commit your local changes
[05:08:05] <mawk> all of them
[05:08:11] <mawk> or if you don't want to, yes, use git stash
[05:08:12] <audiocat> mawk, i did
[05:08:17] <mawk> no, otherwise it wouldn't say it
[05:08:18] <audiocat> it says i need to pull
[05:08:30] <audiocat> yes, it says i need to pull
[05:08:34] <InPhase> audiocat: What does git status show?
[05:08:55] <audiocat> Your branch and 'origin/master' have diverged,
[05:08:55] <audiocat> and have 11 and 3 different commits each, respectively.
[05:08:55] <audiocat>   (use "git pull" to merge the remote branch into yours)
[05:08:55] <audiocat> nothing to commit, working tree clean
[05:09:04] <audiocat> in
[05:09:04] <mawk> I mean if it says "your local files would be overwritten" either you didn't commit something, or you have local files that you didn't git add and that would be overwritten
[05:09:06] <audiocat> InPhase, 
[05:09:07] <mawk> did you git add everything?
[05:09:13] <audiocat> yes
[05:09:27] <mawk> show the whole of git status in a pastebin
[05:09:31] <mawk> from first line to last line
[05:09:35] <audiocat> that is the whole git status
[05:09:36] <Caffeinated> i guess there's no one in #git
[05:09:43] <audiocat> minus "On branch master"
[05:09:51] <audiocat> Caffeinated, #git is dead
[05:09:59] <Caffeinated> ah huh
[05:10:07] <Caffeinated> "need answers RIGHT NOW" lol
[05:10:16] *** Quits: snake (~snake@user/snake) (Quit: Leaving)
[05:10:22] <audiocat> essentially
[05:10:26] <Caffeinated> lmao
[05:10:48] <mawk> show what "git pull" says then audiocat 
[05:10:49] <Caffeinated> superhero syndrome
[05:11:06] <oft_gegong> you can take the blue pill, stay in wonderland. Or I show you a git channel to join by taking the red pill.
[05:11:26] <audiocat> mawk, https://bpa.st/NAXA
[05:11:28] <bayaz> Title: View paste NAXA 
[05:11:31] *** Quits: ghost64 (~ghost64@user/ghost64) (Read error: Connection reset by peer)
[05:11:41] <Caffeinated> or go back to hillsboro
[05:12:41] <mawk> audiocat: are you sure you didn't omit lines at the end of "git status" that said that assets/live/index.html isn't tracked?
[05:12:52] <mawk> anyway, do git add assets/live/index.html and commit it
[05:13:04] <mawk> or, do what it says exactly in the message
[05:13:07] <audiocat> mawk, https://bpa.st/RBZA
[05:13:08] <bayaz> Title: View paste RBZA 
[05:13:09] <mawk> move it, do the git pull, move it back
[05:13:19] <mawk> is it in your .gitignore then?
[05:13:28] <mawk> did you use git update-index?
[05:13:39] <audiocat> oh, it is
[05:13:43] <audiocat> that's confusing
[05:13:58] <audiocat> it's in my .gitignore
[05:14:04] <audiocat> this is an inherited project
[05:14:06] <Caffeinated> lol
[05:14:36] <audiocat> mawk, i did nto use git update-index
[05:14:39] <audiocat> not
[05:14:41] <webnet4> i never found a use for the .gitignore
[05:15:25] <audiocat> webnet4, it's useful in some cases
[05:15:51] <mawk> webnet4: you add files you do not want to commit in it
[05:15:55] <mawk> for instance .o files from C compilation
[05:16:11] <webnet4> jst don't commit them?
[05:16:21] <webnet4> or add them
[05:16:27] <mawk> why would you ever add them?
[05:16:31] <mawk> you don't want them in the repo
[05:16:37] <audiocat> don't add them*
[05:16:40] <webnet4> thats what i mean, why are they added?
[05:16:45] <mawk> they're not added
[05:16:49] <mawk> but they show up in "git status"
[05:16:51] *** Joins: ghost64 (~ghost64@user/ghost64)
[05:16:55] <mawk> and we don't want that
[05:16:59] <webnet4> lol just to clean up that menu?
[05:17:14] <mawk> the menu is basically useless if you don't do that
[05:17:23] <mawk> and also it prevents adding accidentally the files
[05:17:35] <mawk> for instance credentials, which is problematic if added automatically
[05:17:36] <webnet4> why would you add them
[05:17:47] <mawk> git add *
[05:17:48] *** Quits: BrianG61UK (~BrianG61U@2a02:8010:66b7:dddd:994b:13cd:c8da:96fc) (Quit: Leaving)
[05:17:52] <mawk> some people do that
[05:17:52] <webnet4> oooooooooooooooooooooooooh
[05:17:55] <mawk> you don't have enough imagination
[05:17:56] <webnet4> crazy
[05:18:01] *** Quits: BrianG61UK_ (~BrianG61U@2a02:8010:66b7:dddd:9882:5d69:12df:2a8c) (Quit: Leaving)
[05:18:23] <mawk> git add **/*.c
[05:18:27] <mawk> to add all the newly written c files
[05:18:32] <oft_gegong> or temporary vim temp files
[05:18:50] <mawk> and if I didn't write a gitignore, then all the automatically-generated .c files from unit tests would be added which is undesired
[05:19:24] <webnet4> must be an older version that doesn't add all sorts of unrelated files into the repo
[05:19:28] <audiocat> mawk, what is your solution for me
[05:19:37] <Caffeinated> haha
[05:20:01] <oft_gegong> audiocat: I thought the solution was to clean your .gitignore file
[05:20:02] <Caffeinated> "become more proficient at git"
[05:20:17] *** Joins: mrteals (~mistertea@pool-98-116-189-184.nycmny.fios.verizon.net)
[05:20:27] <mawk> well remove it from the gitignore and commit it audiocat
[05:20:33] <audiocat> ok
[05:20:37] <mawk> because clearly the branch you want to pull from has it committed
[05:20:46] <mawk> so you want to commit it too to keep/merge your changes
[05:21:34] <audiocat> yay, a fuckton of conflicts
[05:21:38] <audiocat> i guess that's progress
[05:21:39] <audiocat> thanks mawk
[05:21:43] <mawk> lol
[05:21:47] <mawk> yeah you have to fix them now
[05:21:57] <audiocat> tbh i want to wipe the repo and start anew
[05:22:00] <oft_gegong> you can do it audiocat we believe in you
[05:22:05] <audiocat> but i cant create repos for my company
[05:22:10] <mawk> if you never did it before maybe look up how to do it, you have to make sure to remove the conflict tags
[05:22:31] <mawk> well if you want to keep only your changes you can do that audiocat , push by force to the remote repo
[05:22:33] *** Quits: webnet4 (~0x100@32.211.211.39) (Remote host closed the connection)
[05:22:38] <mawk> or create a new branch with just your changes
[05:22:46] *** Joins: webnet4 (~0x100@32.211.211.39)
[05:23:08] <audiocat> the only change i made was removing our relevant file from .gitignore
[05:23:29] <audiocat> mawk, the remote repo came from a zip, and my local repo im trying to push is from an updated version of that zip
[05:23:34] <mawk> you have 11 commits more than the remote
[05:23:41] <mawk> according to git status
[05:23:46] <audiocat> right
[05:24:06] <mawk> well that's the change that conflicts
[05:24:13] <mawk> so you have to merge them by hand now
[05:24:28] <mawk> I mean, fix the conflicts
[05:24:31] <audiocat> mawk, unless i create a new repo...
[05:24:40] <mawk> if you want, but why?
[05:24:43] <audiocat> that'd literally take 30 seconds
[05:24:45] <mawk> you can push your changes to another branch
[05:24:45] <Caffeinated> in which case thanks for coming...lol
[05:24:50] <mawk> instead of creating a new repo
[05:24:57] <mawk> you just said you don't have the power to create new repos
[05:25:05] <audiocat> mawk, if i do that i'd need to fix all these conflicts, there are like 20
[05:25:15] <audiocat> mawk, i'm just going to ask my boss to create another repo
[05:25:16] <mawk> you don't need to fix conflicts if you push only your changes to another branch
[05:25:28] <mawk> git checkout -b yournewbranch; git push -u origin yournewbranch
[05:25:30] <mawk> that's just it
[05:25:33] <mawk> no conflict to fix
[05:26:37] <mawk> you can create as many branches as you like, with whatever content you want on them
[05:26:48] <mawk> you don't have to base them off the latest remote master that has conflicting changes
[05:26:59] <mawk> you can even create orphan branches that do not stem from any other branch
[05:27:33] <oft_gegong> or create a bash script to automate the git commands to get the system fully upgraded /guesses
[05:28:19] <audiocat> mawk, well i need master to be the latest working version of the code
[05:28:49] <mawk> well what are the 3 commits that are in master and that you don't have audiocat ? aren't they necessary?
[05:28:55] <mawk> if they are not necessary you can do a force push
[05:29:05] <mawk> to put your changes by force, and forget the remote changes
[05:29:07] <audiocat> mawk, they are not necessary
[05:29:11] <mawk> so do a force push
[05:29:13] <audiocat> how?
[05:29:14] <mawk> git push --force, that's all
[05:29:24] <audiocat> ah ok great
[05:29:43] <audiocat> how do i undo this last pull with all the conflicts? git reset --hard HEAD~1?
[05:29:45] <mawk> then remote master will be the same as your local branch
[05:29:53] <mawk> no
[05:29:55] <mawk> do git status
[05:29:57] <mawk> it will tell you how to undo
[05:30:01] <mawk> git merge --abort I think
[05:30:14] <mawk> or git rebase --abort
[05:30:18] <mawk> depending on your pull policy
[05:32:10] *** Quits: ^-^hi (~hi^-^@user/-hi/x-1729478) (Ping timeout: 258 seconds)
[05:33:39] *** Joins: gt (~gt@2001:19f0:9002:6dc:42e5:a008:491c:b050)
[05:33:52] *** Joins: ^-^hi (~hi^-^@user/-hi/x-1729478)
[05:34:38] <oft_gegong> what if tomorrow you woke up and you started typing a 1000 lined C program you saw in a dream. you compiled it. but would you run it?
[05:35:36] <webnet4> 1000 line, so no libc?
[05:35:46] <oft_gegong> lol
[05:35:51] *** Quits: Hrmmm (~Hrmmm@198-27-172-195.fiber.dynamic.sonic.net) (Quit: Hrmmm)
[05:36:00] *** Quits: merijn (~merijn@83-160-49-249.ip.xs4all.nl) (Ping timeout: 258 seconds)
[05:36:17] * oft_gegong shrugs
[05:36:55] <oft_gegong> alright I'm out, later yall
[05:36:57] <webnet4> whats the program do?
[05:37:02] <webnet4> NOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
[05:37:17] <oft_gegong> webnet4: the program does something with some libraries and exits 0
[05:37:55] *** Joins: brabrax_ (~brabrax@user/brabrax)
[05:37:57] <webnet4> do i have to call syscall_exit ?
[05:38:11] * oft_gegong faints
[05:38:22] <oft_gegong> too much brain power needed...must exit irc
[05:38:41] *** Quits: brabrax (~brabrax@user/brabrax) (Ping timeout: 258 seconds)
[05:38:41] <webnet4> or maybe even exit_group
[05:38:42] *** brabrax_ is now known as brabrax
[05:39:09] <oft_gegong> it's return 0 from int main(int _argc, char *argv[])
[05:39:34] <webnet4> oh ok
[05:39:34] <oft_gegong> *_argv
[05:39:45] <webnet4> what about envp though?
[05:39:50] <oft_gegong> now can I leave? please? nooooo
[05:40:02] * oft_gegong fake dies
[05:40:05] <webnet4> ok bye
[05:40:39] <oft_gegong> yeah. what about envp? I have no idea how a C accesses environmental variables.
[05:40:57] <webnet4> libc has some environ defined
[05:40:59] <webnet4> double pointer
[05:41:23] <oft_gegong> hmmm...interesting... *mega fake dies*
[05:41:56] *** Quits: oft_gegong (~oft_gegon@70.90.132.249) (Quit: Leaving)
[05:42:16] *** Quits: jaysicks (~jaysicks@188-143-64-124.pool.digikabel.hu) (Quit: Leaving)
[05:42:49] <webnet4> array of pointer
[05:42:54] <webnet4> oops
[05:44:03] *** Quits: nekodesu (~nano@user/nekobit) (Ping timeout: 258 seconds)
[05:44:04] *** Quits: Rounin (~david@84.212.130.215) (Ping timeout: 268 seconds)
[05:44:26] *** Joins: nekodesu (~nano@user/nekobit)
[05:44:49] *** Quits: mrteals (~mistertea@pool-98-116-189-184.nycmny.fios.verizon.net) (Ping timeout: 258 seconds)
[05:45:19] *** Quits: xsperry (~as@user/xsperry) ()
[05:47:46] *** Joins: BrianG61UK (~BrianG61U@2a02:8010:66b7:dddd:3d8b:fd76:a0eb:7165)
[05:48:26] *** Joins: BrianG61UK_ (~BrianG61U@2a02:8010:66b7:dddd:9882:5d69:12df:2a8c)
[05:54:24] *** Quits: lockywolf (~lockywolf@vultr-seoul-openbsd.lockywolf.net) (Ping timeout: 258 seconds)
[05:57:43] *** Quits: t3nj1n_ (~t3nj1n@pool-96-246-146-100.nycmny.fios.verizon.net) (Quit: WeeChat 2.8)
[05:57:58] *** Quits: Twipply (~Twipply@user/twipply) (Quit: Leaving)
[05:58:42] *** Quits: Lyn (~Lyn@user/law) (Ping timeout: 272 seconds)
[05:58:50] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[05:59:40] *** Joins: jmcantre1 (~weechat@user/jmcantrell)
[06:02:04] *** Quits: jmcantrell (~weechat@user/jmcantrell) (Ping timeout: 258 seconds)
[06:02:48] <webnet4> otherwise you'd have to check values on stack to get ergc/argv/envp in _start or entrypt
[06:03:36] *** Quits: __jmcantrell__ (~weechat@user/jmcantrell) (Ping timeout: 258 seconds)
[06:03:37] <webnet4> on linux*
[06:07:35] <webnet4> or it's all sitting right there  argc, argv[1,2,3...N], envp[1..blah...]  at $esp
[06:09:49] *** Quits: TheAceOfHearts (~TheAceOfH@24.41.239.76) (Quit: So long, and thanks for all the fish!)
[06:10:10] <gt> I decided to build my own app from the ground up. I already wrote 80% of the backend code (I can CRUD all my crucial entities through a rest api + postgresql). However I got a bunch of doubts on the frontend side 
[06:11:22] <gt> is there any frontend savvy discussion in here or should I move to some other channel? I got a couple of design/implementation questions I need help with
[06:14:36] <vdamewood> gt: The discussions that happen in the channel are the ones you create.
[06:20:57] *** Joins: Yonle (~Yonle@user/yonle)
[06:25:27] *** Quits: xff0x (~xff0x@2001:1a81:53d2:1c00:df20:e0ed:5860:3ed0) (Ping timeout: 258 seconds)
[06:26:09] <gt> very good, I'm trying to see how to phrase them in a condensed manner so that they're answerable and NOT rabbit hole inducing
[06:26:55] *** Joins: jmcantrell (~weechat@user/jmcantrell)
[06:27:07] *** Joins: bkool (~bkool@c-73-8-91-229.hsd1.il.comcast.net)
[06:27:18] *** Joins: xff0x (~xff0x@2001:1a81:53fa:2600:8056:588e:c971:d9df)
[06:29:10] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[06:30:18] *** Quits: jmcantre1 (~weechat@user/jmcantrell) (Ping timeout: 268 seconds)
[06:30:35] <^-^hi> for the sake of all meanings of efficiency and decency, don't make your offline apps depend on web
[06:31:17] <^-^hi> there is no reason your data should go through json and http when your database is right there
[06:32:47] *** Quits: jmcantrell (~weechat@user/jmcantrell) (Ping timeout: 268 seconds)
[06:33:07] *** Quits: jarthur (~jarthur@2603-8080-1540-002d-bda2-5884-d97f-5fa4.res6.spectrum.com) (Ping timeout: 258 seconds)
[06:33:15] <^-^hi> there is no reason to bundle a website (let's not talk about DOM and JS and how much atrocious websites are in efficiency) and a whole browser and a whole server in a single app
[06:33:27] *** Joins: jmcantrell (~weechat@user/jmcantrell)
[06:34:49] *** Quits: cthulchu (~Cthulchu@193.194.107.250) (Ping timeout: 248 seconds)
[06:35:00] *** Joins: jarthur (~jarthur@2603-8080-1540-002d-e001-f283-3e2e-ec80.res6.spectrum.com)
[06:35:03] <Arahael> Interesting survey - mind you, this is heavily biased towards those devs who use stackoverflow, for obvious reasons, but: https://insights.stackoverflow.com/survey/2021
[06:35:05] <bayaz> Title: Stack Overflow Developer Survey 2021 
[06:36:29] *** Quits: akevinhuang (~thekevinh@user/thekevinhuang) (Ping timeout: 268 seconds)
[06:36:34] *** Quits: __jmcantrell__ (~weechat@user/jmcantrell) (Ping timeout: 258 seconds)
[06:37:57] <^-^hi> gt that was my advise to you
[06:38:12] *** Quits: entuland (~entuland@user/entuland) (Ping timeout: 256 seconds)
[06:39:06] *** Quits: webnet4 (~0x100@32.211.211.39) (Remote host closed the connection)
[06:39:18] *** Joins: webnet4 (~0x100@32.211.211.39)
[06:43:19] <InPhase> Arahael: F# is the second highest paid language?  Both of the survey respondants who use F# must have nice positions.
[06:43:56] *** Joins: TheAceOfHearts (~TheAceOfH@24.41.239.76)
[06:44:12] <Arahael> InPhase: Heh.  Actually I've used F# professionally as well.
[06:44:51] *** Quits: anton (anton@tloks.com) (Quit: anton)
[06:44:51] <gt> ^-^hi: thanks for the wisdom
[06:44:59] *** Joins: anton (anton@tloks.com)
[06:46:58] *** Quits: Krufu (~AnCELASTR@216.243.47.158) (Read error: Connection reset by peer)
[06:47:12] *** Joins: ______GOD______ (~GOD@187.147.11.7)
[06:47:12] *** Quits: ______GOD______ (~GOD@187.147.11.7) (Changing host)
[06:47:12] *** Joins: ______GOD______ (~GOD@user/god/x-9778998)
[06:47:20] *** Joins: Burkuf (~AnCELASTR@216.243.47.158)
[06:48:49] *** Joins: Donitz (~Donitz@85-156-203-108.elisa-laajakaista.fi)
[06:48:52] <______GOD______> When a company hiring rep says "the engineering team is very diverse...and there is lots of mentoring...in pairs...", does that mean what it seems to? Basically the strong programmer "mentors" doing most of the work?
[06:49:33] <dre> no not in my experience 
[06:49:46] <______GOD______> Oh?
[06:49:53] <dre> usually the strong programmer sits on their ass more. "builds character" and all that :P 
[06:50:12] <dre> I mean every company is different
[06:50:35] <Arahael> ______GOD______: It's probably a reference to pair programming.  It's somewhat controversial, but it's indeed a valid mentoring strategy and there are some good advantages for doing it that way.
[06:50:43] <dre> but my company pairing is pretty 50-50 each person. or really whoever opened up the issue
[06:50:47] <PlanckWalk> I've never worked anywhere that fitted that description
[06:51:20] <______GOD______> Arahael: Are there any advantages for the mentor?
[06:51:24] *** Joins: Izem (~Izem@8.21.10.18)
[06:51:48] <dre> less rubbish in the codebase
[06:51:54] *** Quits: rtypo (~alex@user/rtypo) (Ping timeout: 268 seconds)
[06:52:24] <______GOD______> Or is it basically "train the diversity and affirmative action hires and eventually get fired when they can do it enough to get by?" 
[06:52:47] <Arahael> ______GOD______: It results in fewer bugs if you do it right, but the mentor, if their skills and ability level are wildly different, will end up wanting to do some of their own coding so that they can get shit done faster.  As with all things, it's a good tool to have, but I wouldn't want to pair 100% all the time.
[06:53:01] *** Joins: kmh (~kmh@p200300df5f0c180024ffd0b69acc61a1.dip0.t-ipconnect.de)
[06:53:14] <______GOD______> Guess it really depends on the pairing
[06:53:34] <______GOD______> Thanks for the good answers though
[06:54:07] <Arahael> ______GOD______: Keep an open mind about it. It's also a good opportunity to see what other people struggle with.
[06:54:19] <dre> ^ that too 
[06:54:33] <Arahael> ______GOD______: As for your question as to "... eventually get fired...", I think that's the wrong perspective and attitude, especially for a competent developer.
[06:54:57] <______GOD______> Well, was more saying "replaced" by a cheaper hire
[06:55:04] *** Quits: kmh_ (~kmh@p200300df5f0d0200dc05e9b97966e73c.dip0.t-ipconnect.de) (Ping timeout: 272 seconds)
[06:55:08] <Arahael> ______GOD______: There's always way too much stuff for devs to get done, if you can delegate stuff to a cheaper hire, you should totally do so.
[06:55:17] <dre> ^
[06:55:46] <______GOD______> Companies can't actually, but seem to try to anyway
[06:55:56] <Arahael> They often do.
[06:56:05] <Arahael> Maybe the ones you've been in haven't been able to do that.
[06:56:57] <______GOD______> It's a larger company, so some things will be new
[06:57:20] <______GOD______> Was amazed such an app company has that many employees 
[06:57:28] <Izem> I would suspect diversity hires would tend to overperform
[06:57:46] <______GOD______> Oh? Haven't resided in America then
[06:58:01] <Izem> nope
[06:58:29] <dre> thankfully, there's a rather large number of companies and hires that are all doing different things.
[06:58:41] *** Joins: shailangsa (~shailangs@host86-145-14-24.range86-145.btcentralplus.com)
[06:58:50] <______GOD______> When NASA basically had no diversity, it landed people on the moon...after diversity...it didn't...that's what history says anyway
[06:59:15] <______GOD______> That's diversity in America anyway 
[06:59:28] <dre> I think NASA landed people on the moon before coca-cola was invented, Since coke, no moon. really makes you think 
[06:59:46] <cis> Coke's been around since the late 1800s, hasn't it?
[06:59:54] <dre> dammit 
[07:00:03] <cis> 1892
[07:00:05] <Izem> I take it you haven't lived anywhere else either
[07:00:20] <______GOD______> I have resided in more than 10 countries long term
[07:00:21] *** Quits: Church (~aleph@pool-98-116-232-112.nycmny.fios.verizon.net) (Quit: WeeChat info:version)
[07:00:23] <dre> imagine actually believing that coke exists lmaoing at ur life
[07:00:36] <cis> Back when it was filled with cocaine!
[07:00:41] <dre> ______GOD______, how long is "long term" 
[07:00:59] <______GOD______> At least months. Most a year or more, I think
[07:01:04] <cis> Now it's only filled with coca-leaf by products. Coke is the only company in the entire US that's been granted a license to import coca leaves by the DEA.
[07:01:53] <______GOD______> Resided in Japan and saw how nicely polite a society can be without diversity
[07:02:11] <cis> They ship them to NJ, extract the cocaine, sell that to a medical supply company, and then the rest of whatever's left goes into that sweet, sweet syrup.
[07:02:24] <dre> yeah but they're also dying because no babies 
[07:02:52] <______GOD______> Ah, japanese culture has always been a little suicidal
[07:03:06] <dre> ba-dum-tss
[07:03:06] <______GOD______> For a long while anyway
[07:03:20] *** Joins: lockywolf (~lockywolf@vultr-seoul-openbsd.lockywolf.net)
[07:04:26] *** Joins: Church (~aleph@pool-98-116-232-112.nycmny.fios.verizon.net)
[07:05:22] <dre> I think it's more to do with japan having a homogeneous culture; and American culture was founded on christian faith which is now in disfavour, so it has to be filled with diverse array of corporate shit to plug up all the gaps in shallow lives. 
[07:05:27] *** Quits: webnet4 (~0x100@32.211.211.39) (Remote host closed the connection)
[07:05:44] *** Joins: webnet4 (~0x100@32.211.211.39)
[07:05:54] <dre> like this is american culture now: https://www.youtube.com/watch?v=6swmTBVI83k 
[07:06:09] <cis> America was hardly founded on Christian faith.
[07:06:48] <dre> err, maybe not "founded on" 
[07:07:14] <dre> but christian faith has been the backbone to many western nations I'd argue
[07:07:36] <cis> It's the culture the west is steeped in.
[07:10:46] *** Parts: Izem (~Izem@8.21.10.18) (Closing Window)
[07:15:24] <Arahael> Izem: (Hmm, you've left already, but I want to respond here): Diversity hires, I suspect, don't neccessarily perform better: We're still human and still have the same frailities and limitations.  However, I think I recall that diversity hires can tend to stick with the company for longer if the company demonstrates that they look after their employees effectively.
[07:15:41] <Arahael> Anecedotal evidence: I'm deaf, and I've been with my workplace for over 10 years.
[07:16:20] *** Joins: mrteals (~mistertea@pool-98-116-189-184.nycmny.fios.verizon.net)
[07:16:47] *** Quits: epolanski (uid312403@id-312403.brockwell.irccloud.com) (Quit: Connection closed for inactivity)
[07:17:31] *** Quits: anton (anton@tloks.com) (Quit: anton)
[07:19:16] <Joanna> Arahael: Iâ€™ve been wondering what you do for lip reading if people wear masks or are you strictly text chat now ?
[07:19:42] <Arahael> Joanna: I've never really done the lipreading thing.  The trouble with the masks, though, is that i don't know if people are tlaking to me at all.
[07:20:21] *** Quits: paravida (~myChateau@user/paravida) (Remote host closed the connection)
[07:20:41] <Joanna> I see people staring but I canâ€™t tell what their intentions are because I canâ€™t see facial expression and thatâ€™s kind of disconcerting
[07:21:07] <Joanna> How do you get by without lip reading ?
[07:22:09] <Joanna> Pen and paper?
[07:22:22] <Arahael> A combination of instant messaging, gestures, sign language, and google live transcribe for which I have a Pixel 3 phone dedicated to that app.
[07:25:39] <Joanna> Do a lot of non deaf people know sign language ? Body language is rather underestimated until you realize that a lot of communication is non verbal
[07:26:12] <Joanna> But not seeing facial expressions is a major setback
[07:27:46] *** Joins: Guest50 (~Guest50@184.15.54.182)
[07:28:51] <Arahael> Not many in Australia, no.
[07:30:19] *** Quits: juliaEnv (~mathAndRh@ip-86-49-241-245.net.upcbroadband.cz) (Quit: Going offline, see ya! (www.adiirc.com))
[07:31:47] <Joanna> I wonder if different countries have different sign language. Did you know apes can learn sign language and communicate? Thatâ€™s pretty amazing
[07:31:53] *** Quits: flynn (~mcbloch@user/flynn) (Remote host closed the connection)
[07:32:07] *** Joins: flynn (~mcbloch@user/flynn)
[07:32:33] *** Joins: merijn (~merijn@83-160-49-249.ip.xs4all.nl)
[07:33:08] <Burkuf> Arahael: Which company do you think is most likely to be succesful: One that hires everyone from the same university or one that hires everyone from different universities?
[07:36:30] <Arahael> Burkuf: I'm not sure how I'd answer that.
[07:36:42] <Arahael> Joanna: And yes, different countries have different sign languages.
[07:37:43] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[07:38:52] <Burkuf> Arahael: If every programmer went to the same University, they are more likely to have had the same teachers, who focused on the same topics... So they are more likely to be strong in certain areas and weak in other areas...
[07:39:06] *** Quits: dermato (~dermatobr@154.21.23.75) (Remote host closed the connection)
[07:39:17] *** Joins: smallville7123 (~smallvill@cpe-172-193-72-46.qld.foxtel.net.au)
[07:39:38] <Burkuf> Do you prefer programmers who are more likely to be similar to each other, or do you prefer programmers who are more likely to be different from each other?
[07:40:57] *** Quits: jmcantrell (~weechat@user/jmcantrell) (Ping timeout: 248 seconds)
[07:41:01] <^-^hi> Burkuf: studying at the same university i no big deal
[07:41:08] <webnet4> theres no right answer, and you completely disregard self taught programmers
[07:41:15] <^-^hi> i doubt it has any significance
[07:41:24] <Arahael> Burkuf: It's way more complex than that.
[07:43:41] <Burkuf> ^-^hi: Some people who ran some statistics say it has significance... It's up to you whether you believe in their findings or not...
[07:44:08] <^-^hi> also a lot of university instruction is trash because the professors' job has been mostly being professors rather than programmers. not everyone who teaches CS actively develops.
[07:44:19] <Joanna> Arahael: how do you pick programmers? Give them some crashing code and see if they can fix it ?
[07:44:34] <Burkuf> Joanna: Give them some working code and see if they can crash it
[07:58:38] <Joanna> Burkuf: that would be qa
[07:59:57] *** Quits: b1101 (~b1101@ool-44c01641.dyn.optonline.net) (Remote host closed the connection)
[08:00:23] *** Joins: xsperry (~as@user/xsperry)
[08:00:47] *** Joins: dermato (~dermatobr@154.21.23.75)
[08:07:07] *** Quits: merijn (~merijn@83-160-49-249.ip.xs4all.nl) (Ping timeout: 268 seconds)
[08:13:59] *** Joins: jmcantrell (~weechat@user/jmcantrell)
[08:17:00] *** Quits: __jmcantrell__ (~weechat@user/jmcantrell) (Ping timeout: 258 seconds)
[08:21:12] *** Quits: TheAceOfHearts (~TheAceOfH@24.41.239.76) (Quit: So long, and thanks for all the fish!)
[08:24:35] *** Joins: mambang (~mambang@user/mambang)
[08:29:01] <^-^hi> should i learn x86 assembly?
[08:29:29] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 248 seconds)
[08:30:30] *** Joins: Lord_of_Life (~Lord@user/lord-of-life/x-2819915)
[08:33:17] <PlanckWalk> Do you know any other assembly?  If you do, possibly not.
[08:33:56] <PlanckWalk> If you don't know any other, then learning at least one assembly language gives a better idea of what a CPU is doing.
[08:34:35] <PlanckWalk> Though it could be a simplified teaching assembly language instead of x86 hideous mess.
[08:37:03] <Arahael> ^-^hi: I'd not bother with x86 assembly, learn something much simpler, such as 8051.  I like 8051.
[08:37:48] *** Quits: bkool (~bkool@c-73-8-91-229.hsd1.il.comcast.net) (Quit: Leaving)
[08:37:48] *** Quits: mambang (~mambang@user/mambang) (Quit: Leaving)
[08:38:11] *** Joins: gggp (~gggp@60.10.23.162)
[08:38:28] *** Quits: webnet4 (~0x100@32.211.211.39) (Remote host closed the connection)
[08:38:41] *** Joins: webnet4 (~0x100@32.211.211.39)
[08:38:57] <^-^hi> I read some stuff on assembly for a time and I think I have an idea of what stack, cache, register, system call and this kind of stuff mean
[08:40:42] *** Joins: amigojapan (uid86330@id-86330.brockwell.irccloud.com)
[08:40:46] <^-^hi> PlanckWalk, do the kind of people who do security stuff like trying to exploit buffer overflow, row hammer and spectre bugs know assembly?
[08:41:00] <^-^hi> or use it regularly?
[08:41:29] *** Joins: user51 (~user51@176.228.90.248)
[08:43:33] <webnet4> for the people actually developing these exploits, yeah they're going to want to know how the cpu works
[08:45:39] <webnet4> though it could be some AI just making lucky guesses too!
[08:48:52] <webnet4> s/AI/self driving simulator/
[08:49:04] *** Quits: mrteals (~mistertea@pool-98-116-189-184.nycmny.fios.verizon.net) (Ping timeout: 268 seconds)
[08:49:18] <PlanckWalk> Yes, for exploits like that you would definitely need to know assembly
[08:49:47] <PlanckWalk> For rowhammer and spectre you need to know hardware details too
[08:50:21] <PlanckWalk> As in to discover them, not to just use them.
[08:51:44] *** Quits: lilgopher (~textual@c-73-51-174-246.hsd1.il.comcast.net) (Read error: Connection reset by peer)
[08:52:20] *** Quits: Guest50 (~Guest50@184.15.54.182) (Quit: Client closed)
[08:52:44] *** Quits: gggp (~gggp@60.10.23.162) (Remote host closed the connection)
[08:53:08] *** Joins: gggp (~gggp@60.10.23.162)
[08:56:29] *** Quits: ^-^hi (~hi^-^@user/-hi/x-1729478) (Ping timeout: 258 seconds)
[08:57:36] *** Joins: elnavigator (~elnavigat@105.196.84.133)
[09:00:13] *** Quits: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431) (Remote host closed the connection)
[09:00:44] *** Joins: ^-^hi (~hi^-^@user/-hi/x-1729478)
[09:00:46] *** Quits: compscipunk (~compscipu@107-214-234-232.lightspeed.sndgca.sbcglobal.net) (Quit: WeeChat 3.2)
[09:13:21] *** Joins: mci64 (~mci64@185.242.190.95)
[09:16:49] *** Quits: elnavigator (~elnavigat@105.196.84.133) (Ping timeout: 268 seconds)
[09:23:40] *** Quits: mci64 (~mci64@185.242.190.95) (Quit: Connection closed)
[09:27:01] *** Joins: elnavigator (~elnavigat@105.196.84.133)
[09:28:04] *** Quits: repne_scasb (inhahe@107-213-219-122.lightspeed.miamfl.sbcglobal.net) ()
[09:28:10] *** Joins: Guest16 (~Guest16@103.86.19.117)
[09:28:30] <Guest16> what/use/function is(of) viewport in HTML?
[09:28:55] <Guest16> how to add text inside rectangle/cirlce created using svg in html?
[09:29:47] *** Joins: mci64 (~mci64@185.242.190.95)
[09:29:50] *** Quits: b30wulffz (~b30wulffz@20.204.87.0) (Quit: ZNC 1.7.5+deb4 - https://znc.in)
[09:29:50] *** Quits: amanr (~therojjha@20.204.87.0) (Quit: ZNC 1.7.5+deb4 - https://znc.in)
[09:30:02] *** Quits: riff-IRC (~riff-IRC@user/riff-irc) (Remote host closed the connection)
[09:30:07] *** Quits: mci64 (~mci64@185.242.190.95) (Client Quit)
[09:31:03] <vdamewood> Guest16: https://developer.mozilla.org/en-US/docs/Web/CSS/Viewport_concepts
[09:31:06] <bayaz> Title: Viewport concepts - CSS: Cascading Style Sheets | MDN 
[09:31:24] *** Joins: repne_scasb (inhahe@107-213-219-122.lightspeed.miamfl.sbcglobal.net)
[09:31:48] *** Joins: riff-IRC (~riff-IRC@user/riff-irc)
[09:32:02] *** Joins: mci64 (~mci64@185.242.190.95)
[09:32:14] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[09:32:22] <vdamewood> As for adding text inside of an SVG, I'd just add another text element and use CSS positioning to position it over/under the SVG.
[09:32:34] *** Quits: mci64 (~mci64@185.242.190.95) (Client Quit)
[09:32:38] <vdamewood> (And by over/under, I mean in Z-axis layers.)
[09:33:02] <webnet4> HTML5, but whos counting anyway
[09:33:26] *** Joins: Levalicious (~Levalicio@2601:401:503:5460:f436:19ec:68:8a90)
[09:33:53] *** Joins: mci64 (~mci64@185.242.190.95)
[09:34:29] *** Quits: mci64 (~mci64@185.242.190.95) (Client Quit)
[09:34:57] <vdamewood> webnet4: These days, it doesn't really matter. HTML5 is the only HTML people develop with anymore.
[09:35:13] *** Quits: webnet4 (~0x100@32.211.211.39) (Remote host closed the connection)
[09:35:22] *** Joins: mci64 (~mci64@185.242.190.95)
[09:35:26] *** Joins: webnet4 (~0x100@32.211.211.39)
[09:35:27] <Guest16> i dont know what is z-axis layer but i think you are saying to add text tag within/nested inside svg tag
[09:35:37] *** Quits: Gaboradon (~Gaboradon@cpe-86-58-57-5.static.triera.net) (Quit: Shutdown)
[09:35:52] <webnet4> maybe thats why youtube is so sluggish, its trying to render a bunch f SVG data constantly
[09:35:55] *** Quits: jmcantrell (~weechat@user/jmcantrell) (Ping timeout: 268 seconds)
[09:38:24] <PlanckWalk> Guest16: No, a separate element that is rendered in the same region as the SVG.
[09:38:59] <Guest16> <svg>xyz</svg><text>abc</text>
[09:39:03] <Guest16> like this?
[09:39:22] <PlanckWalk> Yes, with CSS to draw the text above or below the SVG
[09:39:39] *** Quits: mci64 (~mci64@185.242.190.95) (Client Quit)
[09:39:55] <PlanckWalk> If you need it above some parts of the SVG and below others, then that would be different.
[09:40:16] <Guest16> above & below means? front & back?
[09:40:25] *** Joins: mci64 (~mci64@185.242.190.95)
[09:40:28] <PlanckWalk> Rendered before or after, basically.
[09:40:44] <PlanckWalk> Whether the text obscures the SVG or the SVG obscures the text.
[09:41:13] *** Joins: TechTest (uid283215@id-283215.tooting.irccloud.com)
[09:41:15] *** Joins: qu4nt1n (~qu4nt1n@78.198.214.34)
[09:41:50] <PlanckWalk> "z-layer" is used to describe priority for which things "in front" obscure other things "behind"
[09:42:42] <Guest16> ok
[09:43:06] *** Quits: mci64 (~mci64@185.242.190.95) (Client Quit)
[09:44:07] <Guest16> if i want to change border color of any shape from UI/browser, is it possible using HTML?
[09:44:22] *** Joins: mci64 (~mci64@185.242.190.95)
[09:44:51] <Guest16> i.e. from black to red or white or any color user like
[09:45:27] <webnet4> you could let the user input their color in the URL
[09:46:14] <Guest16> by touching at border , there should be pop-up for color picker
[09:46:21] <webnet4> or a cookie
[09:50:43] *** Joins: __that__ (~Guest98@195.59.168.126)
[09:50:46] <__that__> Morning all
[09:51:31] *** Joins: jmcantrell (~weechat@user/jmcantrell)
[09:52:25] <__that__> is there anyone here who can help me with a simple query? I understand the query but I unable to draw what actually happens under the hood. https://dpaste.com/68RUFWXE3. 
[09:54:39] <webnet4> i'd hate to see a complex query
[09:54:49] *** Quits: __jmcantrell__ (~weechat@user/jmcantrell) (Ping timeout: 248 seconds)
[09:55:20] *** Quits: mci64 (~mci64@185.242.190.95) (Quit: Connection closed)
[09:55:38] <__that__> I just would like to see how the whole thing unfolds
[09:55:50] *** Quits: audiocat (~audio@2603-8081-1800-00ad-f351-4ddf-8729-f716.res6.spectrum.com) (Ping timeout: 252 seconds)
[09:55:57] *** Joins: mci64 (~mci64@185.242.190.95)
[09:59:00] *** Joins: jazzy (~jaziz@2600:380:8638:b14c:3d37:fea7:101f:573e)
[10:00:38] <webnet4> can you break it into segments to see what's happening?
[10:00:54] <PlanckWalk> Well, there's the nice clean theoretical view of what that query means, and the nastiness that query optimizers do to make it efficient.
[10:01:58] <__that__> webnet4 how I do that? I am not sure how to do that
[10:02:05] *** Quits: Zeturic (~Orimendix@50-25-46-156.krmtcmta02.res.dyn.suddenlink.net) (Quit: Leaving)
[10:03:06] *** Joins: inhahe_ (inhahe@107-213-219-122.lightspeed.miamfl.sbcglobal.net)
[10:03:08] *** Joins: merijn (~merijn@83-160-49-249.ip.xs4all.nl)
[10:03:39] <__that__> If I knew I would have doen it
[10:04:09] <webnet4> can you explain any part of it completely if you cut out other keywords
[10:04:15] <webnet4> and at which points does it break down
[10:05:38] <webnet4> map out the knowledge gaps and start attacking
[10:06:20] <__that__> webnet4... ok, thanks. I'll go to the sql channel. Hopefully someone understands what happens
[10:06:21] <__that__> thanks
[10:06:36] <password> mind the gap
[10:07:36] *** Quits: Inhahe (inhahe@107-213-219-122.lightspeed.miamfl.sbcglobal.net) (Ping timeout: 272 seconds)
[10:11:23] <PlanckWalk> The main thing here is "left outer join", which guarantees that you get at least one row in the result for every row of the first table.
[10:12:12] <PlanckWalk> If the WHERE clause isn't satisfied, then the values from the second table are treated as NULL
[10:13:53] <PlanckWalk> Err I mean the "ON" clause
[10:16:15] *** Joins: Sauvin (~sauvin@about/linux/staff/sauvin)
[10:16:59] *** Quits: Guest16 (~Guest16@103.86.19.117) (Ping timeout: 258 seconds)
[10:20:28] <PlanckWalk> So for each row in the table (called t1), it looks for rows in t2 (the same table) that have the same ID and later date.  If there aren't any then you get NULLs for the t2 part.
[10:21:34] <PlanckWalk> The WHERE clause picks out only those where that happens (t2.ID IS NULL), so yuo get a list of the rows that are the latest for their ID.
[10:23:08] *** Quits: penguino (~mrpenguin@user/mrpenguin) (Ping timeout: 244 seconds)
[10:24:01] *** Quits: freakazoid333 (~matt@2603-9000-cf0f-80e3-14c2-094e-704a-6e4b.inf6.spectrum.com) (Read error: Connection reset by peer)
[10:25:12] <PlanckWalk> (For extra fun work out what happens with inner, right outer, and full outer joins)
[10:26:02] *** Joins: bytecrawler (~bytecrawl@gateway/tor-sasl/bytecrawler)
[10:29:16] *** Quits: Nact (~l@host-85-27-122-107.dynamic.voo.be) (Quit: Konversation terminated!)
[10:31:46] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[10:33:57] *** Joins: Guest16 (~Guest16@103.86.19.117)
[10:34:22] <Guest16> 	d3.select("#rect1") 	  .transition() 	  .duration(1800) 	  .attr("width", "400") 	d3.select("#rect1")
[10:34:23] <Guest16> 	  .transition()
[10:34:23] <Guest16> 	  .duration(1800)
[10:34:24] <Guest16> 	  .attr("width", "20")
[10:34:40] <Guest16> if i put back to back d3 animation, it ignores first one
[10:35:08] *** Quits: jmcantrell (~weechat@user/jmcantrell) (Ping timeout: 268 seconds)
[10:35:36] <Guest16> how to make it visualize
[10:37:36] *** Quits: merijn (~merijn@83-160-49-249.ip.xs4all.nl) (Ping timeout: 268 seconds)
[10:41:03] *** Joins: jmcantrell (~weechat@user/jmcantrell)
[10:44:12] *** Quits: __jmcantrell__ (~weechat@user/jmcantrell) (Ping timeout: 258 seconds)
[10:45:36] *** Quits: qu4nt1n (~qu4nt1n@78.198.214.34) (Quit: KVIrc 5.0.0 Aria http://www.kvirc.net/)
[10:46:39] *** Quits: mci64 (~mci64@185.242.190.95) (Quit: Connection closed)
[10:47:30] *** Quits: LiftLeft (~LiftLeft@212.102.59.168) (Ping timeout: 272 seconds)
[10:48:03] <password> am i being old and stupid or is there no way to download this ? http://stevedonovan.github.io/winapi/topics/readme.md.html
[10:48:04] <bayaz> Title: Winapi documentation 
[10:49:04] *** Quits: jarthur (~jarthur@2603-8080-1540-002d-e001-f283-3e2e-ec80.res6.spectrum.com) (Quit: jarthur)
[10:49:30] <deniska> https://github.com/stevedonovan/winapi
[10:49:56] <password> did you end up googling?
[10:49:58] <deniska> https://luarocks.org/modules/steved/winapi you probably want to get it through luarocks? Not sure about how lua works :)
[10:49:58] <bayaz> Title: winapi - LuaRocks 
[10:50:02] <deniska> password: sure
[10:51:16] *** Joins: pandakekok9 (~job@wikimedia-commons/pandakekok9)
[10:52:23] <password> now i just need to figure out how to get it compiled , lol
[10:54:53] <password> "Edit build-gcc.bat and set LUA_INCLUDE and LUA_LIB to the proper directories for your system. Right now they're hardcoded for Steve's PC, but maybe they'll work if your name is Steve, too. :)"
[10:54:55] <password> urg
[10:55:14] <password> and this is supossedly one of the nicer ways to do clipboard stuff in lua
[10:55:16] <d3x0r> ^-^hi you should use nasm, their docs are pretty good for instructions, and it's got a good macro processor
[10:55:26] <d3x0r> (for learning x86/64 asm)
[10:57:33] *** Joins: Lord_of_Life_ (~Lord@user/lord-of-life/x-2819915)
[10:57:46] <vdamewood> Ugh, 'edit this batch file' is such a pain in the ass when there are actual build system generators out there.
[10:58:04] <d3x0r> :)
[10:58:14] <password> i hate opensource for this reason
[10:58:18] <d3x0r> but why when mk.sh is so easy?
[10:58:36] <password> i have to go an install a whole toolchain just because some fart was lazy
[10:58:44] *** Joins: sandstone (~sandstone@182.70.239.73)
[10:58:46] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 258 seconds)
[10:58:48] *** Lord_of_Life_ is now known as Lord_of_Life
[10:58:58] <d3x0r> it should already be installed
[10:59:10] <password> mingw?
[10:59:19] <d3x0r> :) oh that.
[10:59:21] <vdamewood> yep, MSVC is already installed... oh, you wanted mingw64?
[10:59:39] <password> sparse instructions said i need ming
[10:59:53] <password> fuck knows what i acutally need
[10:59:59] <d3x0r> cygwin :)
[11:00:01] <password> and how many other steps are missing
[11:00:01] <vdamewood> Well, with a name like build-gcc.bat, I doubt it's Visual Studio.
[11:00:13] <^-^hi> password, why use winapi in lua to begin with?
[11:00:40] <password> becuase thats what i found to solve my problem
[11:00:49] <^-^hi> what is your problem?
[11:00:53] <vdamewood> https://www.reddit.com/r/ProgrammerHumor/comments/cw58z7/it_works_on_my_machine/
[11:01:11] <d3x0r> sounds like a solutoni that's just added more problems - making it more rube goldberg-esque :)
[11:01:33] <password> clipboard access
[11:01:38] <sandstone> i'm trying to put up a fairly regular website. what's the programming language recommended by ##programming for the back-end server? i tried to use the Node.js but callbacks in JavaScript are too much for me. i like static typing, functional programming and an unopinionated outlook from the language and the framework if there is one.
[11:01:44] <password> d3x0r thats why i hate open source :P
[11:01:57] <^-^hi> mentioning winapi and lua names together alone makes my skin crawl
[11:01:58] <d3x0r> hey my sources are cmake and build with whatever compiler you have :p
[11:02:10] <password> ^-^hi why?
[11:02:14] <^-^hi> password, what clipboard access?
[11:02:29] <password> ^-^hi what do you mean?
[11:02:35] <deniska> sandstone: which languages are you already familiar with?
[11:02:37] <password> being able to read and set it
[11:02:47] <^-^hi> password: just that?
[11:02:49] <d3x0r> sandstone JS :) oh wait...
[11:02:58] <^-^hi> there should be commands out there for it
[11:03:05] <password> ok fluffy
[11:03:07] <d3x0r> so use promises - oh those are callbacks too
[11:03:11] <deniska> my goto is python+django, but that's not statically typed :)
[11:03:19] *** Quits: Guest16 (~Guest16@103.86.19.117) (Quit: Connection closed)
[11:03:19] <password> that was a useless side quest
[11:03:32] <d3x0r> JS is statically typed - whatever a thing is is it's type :p
[11:03:48] <password> like hey i found a library that potentially solves my issues , someone else: there should be a different library that does that
[11:03:49] <^-^hi> password: because winapi sucks so bad, and lua isn't a microsoft language, it has to be a sketchy buggy binding
[11:03:53] <vdamewood> Naw, everything is an Object.
[11:04:01] <d3x0r> evertyhing is itself :)
[11:04:18] <password> lol ^-^hi your working on so many assumptions here and not helping at all
[11:04:31] <password> just more noise
[11:04:35] <d3x0r> just because you can access extended properties on numbers doesn't really make them objects
[11:04:39] <user51> good morning
[11:04:44] <password> lua is not negotiable in this case
[11:04:53] <password> not even remotely
[11:05:07] <password> hai user51 , I'll just say morning today
[11:05:09] <^-^hi> password: i have seen C winapi and i have used lua, i have embedded lua in C, i  have ported stuff to windows
[11:05:18] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[11:05:19] <password> congrats
[11:05:31] <sandstone> deniska: i know the regular ones. Perl, Python, Haskell, etc. i know basic C too. i don't like to use JavaScript since i read Joe Armstrong's blog. but i don't know if Haskell, Erlang or OCaml are good enough to use on the backend without worrying about libraries and community support as it's not as big as JavaScript.
[11:05:33] <password> you have spent an afternoon
[11:05:54] <password> still you don't have a better solution
[11:06:09] <password> your exactly the type at my hackerspace
[11:06:25] <password> you mention a solution and they come up with 3-5 issues
[11:06:29] <d3x0r> what does this joe armstrong have to say?
[11:06:30] <password> with no better alternative
[11:06:32] <^-^hi> password: https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/clip
[11:06:33] <bayaz> Title: clip 
[11:06:38] <^-^hi> call that from lua
[11:06:45] <^-^hi> and stop being a troll
[11:06:53] <vdamewood> sandstone: I personally prefer Python for my backends.
[11:06:59] <^-^hi> to people trying to help you
[11:06:59] *** Joins: mei (~mei@user/mei)
[11:07:01] *** Quits: Levalicious (~Levalicio@2601:401:503:5460:f436:19ec:68:8a90) (Read error: Connection reset by peer)
[11:07:02] <d3x0r> he just needs the clipboard :) - though sounds more like something you should implement in C with a lua interface
[11:07:07] <d3x0r> for the 3 or 4 commands you need
[11:07:18] <password> ah yes , let me recompile closed source
[11:07:30] <^-^hi> that is fucking embedded in windows
[11:07:35] <password> ^-^hi PRO TIP
[11:07:42] *** Joins: LucaTM (~LucaTM@user/lucatm)
[11:07:51] <password> TELLing someone their solution is wrong is not masterbtion not helping
[11:07:58] <d3x0r> vdamewood :) so JS is single threaded... my Node.JS was taking 44% of my 8core 16 thread processor serving web pages - that's pretty good huh? (most of it gets offloaded to network threads)
[11:08:04] <^-^hi> why am i wasting my time with this fool
[11:08:05] <password> don't be a pile of your own shit actually be constructive
[11:08:15] <sandstone> vdamewood: i see. do you use a framework?
[11:08:16] <d3x0r> (had a bug that infinitely loaded images over and over on  webpage)
[11:08:25] *** Quits: jmcantrell (~weechat@user/jmcantrell) (Ping timeout: 248 seconds)
[11:08:27] <password> everyone always so keen to tell people their wrong , its funny
[11:08:29] <vdamewood> sandstone:Django, usually.
[11:08:35] <password> anywya
[11:08:51] <^-^hi> password, ok go recompile a whole lua binding with cygwin to goddamn copy with a clipboard
[11:09:06] <vdamewood> ^-^hi: Do you have a better idea?
[11:09:07] <password> sure
[11:09:16] *** Joins: mrig (~mrig@user/mrig)
[11:09:27] <^-^hi> vdamewood: there is a clip command
[11:09:40] <sandstone> password: https://joearms.github.io/#2013-04-02%20Red%20and%20Green%20callbacks
[11:09:40] <bayaz> Title: Joe's Blog â€” a non-linear personal web notebook 
[11:10:02] *** Joins: akronymus (~akronymus@85.31.8.181)
[11:10:34] <sandstone> is Rust a viable option to do back-end programming?
[11:10:55] <user51> betteridge strikes again..
[11:11:18] <webnet4> better than c#
[11:11:22] <password> sandstone what is that?
[11:11:27] <user51> oh wait, i thought it was the page title, sorry :D
[11:11:29] <sandstone> password: never mind.
[11:11:35] <password> ok
[11:11:53] *** Quits: LucaTM (~LucaTM@user/lucatm) (Read error: Connection reset by peer)
[11:12:06] *** Quits: MrMobius (~MrMobius@208.58.206.154) (Read error: Connection reset by peer)
[11:13:18] *** Joins: LucaTM (~LucaTM@user/lucatm)
[11:14:03] <sandstone> user51: next time you parse the string "Hitler", don't go shouting Godwin's Law. you might just happen to be in a top-tier Nazi cabal meeting performing as a jester.
[11:14:23] <akronymus> Ah yes, godwins law.
[11:14:37] <akronymus> Coined by dunning and kruger.
[11:14:59] <akronymus> Ok, even I don't know where I wanted to go with this.
[11:15:09] <sandstone> i don't know what's the fascination in the internet folks about these stupid random "laws".
[11:15:26] <sandstone> nobody cares about them in the real world. they're not laws to begin with.
[11:15:26] <password> well to be fair , the longer a discussion teh more stuff it includes
[11:15:47] *** Quits: Joanna (uid57472@id-57472.tooting.irccloud.com) (Quit: Connection closed for inactivity)
[11:16:53] *** Quits: Yonle (~Yonle@user/yonle) (Read error: Connection reset by peer)
[11:16:59] *** Joins: Yonle_ (~Yonle@user/yonle)
[11:17:24] <sandstone> the people who invoke that seem to think that they have won the argument just by the virtue of the invocation. that's so silly.
[11:17:35] <akronymus> Yeah, that it is.
[11:18:06] <akronymus> Mentioning hitler/nazis can be, and quite often, is actually relevant to the discussion at hand.
[11:18:09] <password> sandstone they invoke them like its some kind of argument defeating trap card
[11:18:29] <akronymus> "Totschlagargument" password
[11:18:57] <akronymus> Dunno about a english translation.
[11:19:03] <password> oh good to know theres a word for it
[11:19:10] <akronymus> A german one at that.
[11:19:11] <sandstone> it's like some "damage Infinity" level card to them. Mike Godwin himself stated that invocation of the law is meaningless. if it's a fact, invoking is just a measure to distract from the conversation.
[11:19:18] <^-^hi> sandstone: it is to tell people "there are so many people doing this that we have a name for it, go look it up in google and see the negative remarks and feel ashamed"
[11:19:31] <^-^hi> pretty clear how that works
[11:19:34] <password> I used to used them often in everyday disagreements because i just could not be hassled to explain stuff to people
[11:20:00] <akronymus> I just tell them outright I can't be arsed to, usually.
[11:20:06] <akronymus> Except in here apparently.
[11:20:07] <password> now i"m just like , Everyone has the right to be wrong in an situation
[11:20:18] <akronymus> That's where you are wrong. /s
[11:20:42] <password> akronymus , sure its your right
[11:21:01] <sandstone> ^-^hi: comparing someone to Hitler is not a crime. it's not even factually wrong in many cases. there have been many many genocidal leaders in history. Hitler was one of the most recent and very bad in general.
[11:21:13] *** Quits: elnavigator (~elnavigat@105.196.84.133) (Ping timeout: 248 seconds)
[11:21:22] <akronymus> Eh, hitler wasn't that bad in the grand scheme of things.
[11:21:25] <death916> its low effort
[11:21:29] <akronymus> In terms of deaths.
[11:21:45] <akronymus> Communism has killed way more than fascism.
[11:21:53] <^-^hi> sandstone: no it pops up in such unexpected situations you can't imagine
[11:21:55] <password> hitler was bad , he ruined the style of moustache forever!
[11:22:05] <sandstone> ^-^hi: why is that a problem?
[11:22:06] <akronymus> That's fair.
[11:22:13] <akronymus> And a pretty useful pattern.
[11:22:26] <^-^hi> sandstone: that is not a problem. people just make fun of that.
[11:22:26] <password> no one can have the moustache as hitler without being compared
[11:22:38] <password> because we all knew his powers was in his moustache
[11:22:51] <akronymus> I thought it was in his haircut.
[11:23:09] <password> he had an haircut?
[11:23:13] *** Joins: furrymcgee (~devuan@31.179.186.66)
[11:23:14] * password googles
[11:23:17] <webnet4> isms dont kill people famine does
[11:23:23] <akronymus> Anyways: What programming languages would the nazis use if they weren't defeated?
[11:23:27] <sandstone> ^-^hi: invoking Hitler should not be a bigger taboo than invoking Vlad the Impaler, for example. or Julius Caesar. or Joseph Stalin, etc.
[11:23:29] <password> famisms
[11:23:33] *** Parts: furrymcgee (~devuan@31.179.186.66) ()
[11:23:40] <password> akronymus ?
[11:23:57] <sandstone> password: what are you, the resident communist?
[11:24:09] <^-^hi> sandstone: if they were invoked in discussions about systemd, we would come up with vlad law as well.
[11:24:16] <akronymus> password to make the topic relevant to the channel again.
[11:24:16] <beaky> hello my name is beaky overnight i figured out how to compolete my proof from the other day 
[11:24:29] <akronymus> systemd was a mistake
[11:24:32] <user51> beaky: i hope you werre paid overtime :)
[11:24:40] *** Joins: vysn (~vysn@user/vysn)
[11:24:40] *** Joins: furrymcgee (~devuan@31.179.186.66)
[11:24:43] *** Joins: elnavigator (~elnavigat@105.196.223.220)
[11:24:43] <akronymus> Or at least the implementation of it.
[11:24:53] <^-^hi> systemd sucks though
[11:25:02] <akronymus> Systemd solved a problem.
[11:25:07] <sandstone> ^-^hi: i'm not sure i get the reference. does using systemd feel like you're being impaled in a field?
[11:25:09] <akronymus> Then it just kept growing into a cancer.
[11:25:40] <sandstone> ^-^hi: Poettering would have to take up the epithet then, lol.
[11:25:53] <^-^hi> sandstone: no but i saw its developer being compared to hitler
[11:26:34] <akronymus> I saw so many people compared to hitler by now, that that means nothing anymore.
[11:26:40] <^-^hi> yeah
[11:26:49] <akronymus> Hell, I'VE been compared to hitler before.
[11:27:03] <sandstone> ^-^hi: Lennart Poettering, the grand-German-impaler-who-claimed-to-be-the-victim-of-an-online-conspiracy-to-murder-him-through-an-assassin-hired-using-Bitcoin.
[11:27:25] <akronymus> sandstone hey hey people.
[11:27:55] <akronymus> Whenever I hear bitcoin assassin i think of sseths ss13 video.
[11:28:22] <beaky> but i like systemd i use it to start and run services in linux
[11:28:43] <^-^hi> we have to make a lennart law
[11:28:51] <beaky> systemd feels like a system
[11:28:51] *** Joins: Pickchea (~private@user/pickchea)
[11:29:16] <sandstone> akronymus: he real did claim that. i don't know the extent to which the Linux community can go to oppose the design choices they don't like. but apparently, hiring hitmen using Bitcoin is better than just protesting online.
[11:29:22] <sandstone> s/real/really/
[11:29:44] *** Joins: aradesh (~aradesh@user/aradesh)
[11:30:20] <sandstone> password: i didn't mean to offend. i just wanted to stop the communism v capitalism debate. if akronymus thinks "communism" killed people, there's no way you can make him "change his mind" on the IRC.
[11:30:43] <password> sandstone hmm?
[11:31:02] <sandstone> password: resident communist.
[11:31:08] <password> your not the one that peeved me off here
[11:31:37] <akronymus> Wait, did I peeve you?
[11:31:44] <sandstone> can we stop this.
[11:31:56] <^-^hi> hitler the nickname is not allowed on libera
[11:32:01] <^-^hi> what a shame
[11:32:32] *** ^-^hi is now known as __hitler__
[11:32:38] <sandstone> or i'll have to bring out the big guns, a la the great old womaniser Thorstein Veblen and the debate would become three sided with the Institutionalist School joining in too. like the Syrian Civil War.
[11:32:39] <password> theres variations
[11:32:42] *** __hitler__ is now known as hi^-^
[11:32:43] <password> hither
[11:32:53] *** password is now known as ^-^hi
[11:32:59] *** sandstone is now known as Stalin
[11:32:59] <^-^hi> :D
[11:33:07] *** Stalin is now known as Stalin_
[11:33:32] <akronymus> Oof, "*******" is already in use
[11:33:41] *** Joins: Booster2ooo (~Booster2o@user/booster2ooo)
[11:33:56] <Stalin_> where the little bitch Trotsky at? and bring me some young peasant girls, right now.
[11:34:05] <hi^-^> ^-^hi
[11:34:20] *** Joins: absc (~absc@dynamic-adsl-94-34-201-166.clienti.tiscali.it)
[11:34:31] <^-^hi> hi^-^
[11:34:34] *** Joins: jmcantrell (~weechat@user/jmcantrell)
[11:34:35] <Stalin_> deniska: do you have any suggestions?
[11:34:39] *** ^-^hi is now known as password
[11:34:49] *** Stalin_ is now known as sandstone
[11:35:07] <password> sandstone or some young pleasant girls
[11:35:17] <password> present girls
[11:35:30] *** Joins: mnd999_ (~mark@2001:8b0:da3:76a2:4630:5b97:83a2:3e21)
[11:35:51] <sandstone> password: peasant girls serve as pleasant presents too.
[11:36:13] <sandstone> password: very earthly. whatever.
[11:36:19] <password> :D
[11:36:25] <password> pheasant girls
[11:37:10] <sandstone> pissant girls
[11:37:34] *** rf` is now known as envex
[11:37:42] *** Parts: hi^-^ (~hi^-^@user/-hi/x-1729478) (what the fuck)
[11:37:52] *** Quits: __jmcantrell__ (~weechat@user/jmcantrell) (Ping timeout: 258 seconds)
[11:38:48] <sandstone> hi^-^ probably couldn't control his urge to invoke the big Hitler on me. or was it Gilles de Rais or Maquis de Sade?
[11:40:35] <sandstone> so, i see this is becoming too vulgar for the refined palattes of the IRC folks, so i'll come back to the topic on discussion. does anybody have got any suggestion for a static backend language?
[11:42:24] *** Joins: Burgundy (~yomon@5-12-93-72.residential.rdsnet.ro)
[11:42:36] *** Joins: AsenMx (~AsenMx@78.90.248.234)
[11:42:49] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[11:43:04] *** Joins: epolanski (uid312403@id-312403.brockwell.irccloud.com)
[11:43:05] *** Quits: Yonle_ (~Yonle@user/yonle) (Ping timeout: 248 seconds)
[11:43:40] <password> statically typed?
[11:43:46] <sandstone> password: yeah.
[11:43:53] <deniska> Cshorp
[11:43:58] <password> is there such a thing?
[11:44:01] <sandstone> deniska: do you use it?
[11:44:02] <password> :P
[11:44:04] <deniska> or java-land
[11:44:13] <deniska> sandstone: not for web
[11:44:27] <password> aparently c is not static typed either
[11:44:30] <sandstone> deniska: have you used Haskell?
[11:44:41] <sandstone> deniska: for back-end, i mean.
[11:44:42] <deniska> sandstone: more or less for hello-worlding
[11:44:50] *** Joins: Yonle (~Yonle@user/yonle)
[11:45:17] <password> try brainfuck XD
[11:45:17] <sandstone> let's see. thanks for the replies!
[11:45:20] <deniska> password: "static" vs "dynamic" means whether you can point to identifier and ask the question "what type is it" at compile time
[11:45:31] <sandstone> deniska: i think he knows it.
[11:45:31] *** Quits: twomoon (~twomoon@ip72-199-58-150.sd.sd.cox.net) (Quit: Leaving)
[11:45:36] <deniska> password: C type system is primitive and bad, but it may answer this question
[11:45:43] <sandstone> deniska: just messing with.
[11:45:55] *** Quits: jmcantrell (~weechat@user/jmcantrell) (Ping timeout: 258 seconds)
[11:46:01] * password points to void ptr , what type is?
[11:46:14] <deniska> Now we have a specific term for type systems we don't like: "weak typing"
[11:46:20] <deniska> password: it's the type void ptr, duh
[11:46:33] <webnet4> you need to use extra warning opetion -Wconversion with C
[11:46:37] <sandstone> deniska: typing systems can be difficult to define and categorise.
[11:46:43] <password> btw i was not asking i was stating
[11:46:50] <webnet4> and -Werror
[11:46:50] <sandstone> deniska: but some languages do have a lot of support for typing and many don't.
[11:47:31] <akronymus> I wouldn't call most language even having a type system.
[11:47:40] <akronymus> Something like HM is a type system.
[11:47:43] <sandstone> deniska: terms like strong typing and weak typing don't have standard definition. it's a spectrum of type systems, i think. with assembly at the bottom and something like Haskell or Idris at the top.
[11:47:47] <akronymus> A few basic types isn't one.
[11:48:29] <akronymus> And no, objects don't make a type system either.
[11:48:46] * vdamewood wonders if assembly language can be considered as having a type 'system' at all.
[11:49:06] <sandstone> vdamewood: hence, the bottom.
[11:49:14] <password> a type system that has one type?
[11:49:20] <akronymus> I'd put asm in the same category as the untyped lambda calculus
[11:49:22] <password> sure why nut
[11:49:27] <akronymus> As in, no type.
[11:49:37] *** Joins: exvicesindaco (~exvicio@user/exvicesindaco)
[11:49:38] <sandstone> password: when you can have peasant girls.
[11:49:39] * password pulls out the null set
[11:49:47] <password> yeah when?!
[11:49:56] <vdamewood> Yeah, I don't really see lacking a property means that it's at a perticular end of a spectrum, since it simply completely lacks a property.
[11:50:25] <vdamewood> After all, something that's black lacks color. That doesn't mean that it's an extreme form of red (or violet), it means it's completely off the spectrum.
[11:50:33] *** Quits: sandstone (~sandstone@182.70.239.73) (Quit: leaving)
[11:50:47] <akronymus> https://en.wikipedia.org/wiki/Comparison_of_programming_languages_by_type_system
[11:50:50] <bayaz> Title: Comparison of programming languages by type system - Wikipedia 
[11:53:40] <vdamewood> Yay, all of the sudden I'm sleepy.
[11:53:46] <password> same
[11:53:48] <password> and cold
[11:53:56] <password> wind picked up and now its cold
[11:54:01] <password> i should get mah jacket
[11:54:29] <beaky> woah could programming language theory and the whole field of type theory be wrong? https://blog.ploeh.dk/2021/08/09/am-i-stuck-in-a-local-maximum/
[11:54:29] <bayaz> Title: Am I stuck in a local maximum? 
[11:54:39] <vdamewood> password: Are you in Oz?
[11:54:45] <password> nop
[11:55:06] <beaky> a whole field of computer science studying the wrong theory
[11:55:09] <vdamewood> Oh? Hmm... mind if I ask where then?
[11:55:30] *** Joins: exvicesindaco_ (~exvicio@host-87-17-228-139.retail.telecomitalia.it)
[11:56:05] *** Joins: jmcantrell (~weechat@user/jmcantrell)
[11:56:59] <vdamewood> It's fscking hot here.
[11:57:29] <vdamewood> Now that it's cooled down for the night, it's 34 degrees (Celsius) out.
[11:57:37] <vdamewood> er rno, 24 degrees.
[11:57:58] <password> its winter here
[11:58:04] <vdamewood> root, I hope that statement doesn't ring true when the heat wave hits.
[11:58:12] <vdamewood> password: Yeah, hence my guess of Oz.
[11:58:20] <vdamewood> (As Oz--tralia)
[11:58:23] <password> wait Oz is in souther hemisphere
[11:58:30] <akronymus> https://pbs.twimg.com/media/EvQkCeDXUAcvfuJ.jpg:large https://preview.redd.it/hp3wsb72gpw61.jpg?auto=webp&s=3c5d41ff44a4db52726d6960ffdaff9a1b43a362
[11:58:30] <bayaz> Type: image/jpeg Size: 220.0 kB 
[11:58:31] <bayaz> Type: image/jpeg Size: 162.4 kB 
[11:58:32] <password> oztralia , lol
[11:58:32] <vdamewood> As in*
[11:58:37] <password> nvm
[11:58:40] <password> me is slow
[11:58:42] <akronymus> I think some of you are gonna appreciate those pics
[11:59:04] <vdamewood> So, yes, Oztralia?
[11:59:05] *** Quits: exvicesindaco (~exvicio@user/exvicesindaco) (Ping timeout: 248 seconds)
[11:59:07] *** exvicesindaco_ is now known as exvicesindaco
[11:59:37] *** Quits: __jmcantrell__ (~weechat@user/jmcantrell) (Ping timeout: 268 seconds)
[12:00:35] <password> no I'm the wizard of south africa
[12:00:36] *** Quits: soapsudsxx (~soapsudsx@209.221.40.143) (Remote host closed the connection)
[12:00:40] <password> not of Oz
[12:01:05] *** Quits: Yonle (~Yonle@user/yonle) (Quit: Logged out)
[12:02:29] *** Joins: ArtOfWar (~ttt@107-190-27-93.cpe.teksavvy.com)
[12:02:42] <ArtOfWar> Hi how you
[12:02:56] <webnet4> sup arty
[12:02:58] *** Quits: jmcgnh (~jmcgnh@wikipedia/jmcgnh) (Ping timeout: 240 seconds)
[12:03:12] <ArtOfWar> How many years studying to be able to work and code at home? 2?
[12:03:15] <ArtOfWar> which language?
[12:03:15] <password> oh hey
[12:03:28] <password> warofart is just 2 letter swap
[12:03:32] <ArtOfWar> :-)
[12:04:09] <password> you just need to find one employer foolish enough to employ you
[12:04:22] <akronymus> Art of war you say?
[12:04:46] <akronymus> https://www.nexusmods.com/xcom/mods/638
[12:04:48] <bayaz> Title: Art Of War 
[12:04:58] <password> fart woar
[12:05:07] *** Joins: jmcgnh (~jmcgnh@wikipedia/jmcgnh)
[12:05:21] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[12:05:29] <akronymus> Fart O' war
[12:06:06] <password> nothing personaly its just such a fun nick to play with
[12:06:13] *** Quits: webnet4 (~0x100@32.211.211.39) (Remote host closed the connection)
[12:06:25] *** Joins: webnet4 (~0x100@32.211.211.39)
[12:06:45] *** Joins: Guest16 (~Guest16@103.86.19.117)
[12:06:47] *** Quits: Guest16 (~Guest16@103.86.19.117) (Client Quit)
[12:08:14] *** Joins: mobidrop (~mobidrop@user/mobidrop)
[12:08:32] *** Quits: jmcantrell (~weechat@user/jmcantrell) (Ping timeout: 258 seconds)
[12:08:47] <vdamewood> password: Oh, that would have been my second guess.
[12:08:57] *** Joins: merijn (~merijn@83-160-49-249.ip.xs4all.nl)
[12:08:59] <password> hmm?
[12:09:09] <vdamewood> za
[12:09:09] <password> oh regarding my wizardyness
[12:09:13] <vdamewood> Yeah.
[12:09:51] <vdamewood> My third would have been Argentina.
[12:10:06] <password> ah
[12:10:16] *** Quits: Pickchea (~private@user/pickchea) (Quit: Leaving)
[12:10:18] * password knwos precious little about people and cultures
[12:12:28] <vdamewood> I find South African history Boering.
[12:12:31] *** Joins: Camilo (~hugh@host-92-20-143-244.as13285.net)
[12:12:44] <password> heh
[12:12:55] <vdamewood> (pun aside, it's actually quite fascinating.)
[12:13:36] *** Joins: jmcantrell (~weechat@user/jmcantrell)
[12:13:55] <user51> part of war? :)
[12:14:04] *** Quits: NEYi (~NEYi@109.251.216.38) (Quit: Leaving)
[12:14:30] *** Joins: Rounin (~david@84.212.130.215)
[12:16:41] *** Quits: __jmcantrell__ (~weechat@user/jmcantrell) (Ping timeout: 248 seconds)
[12:17:25] *** Joins: trace987 (~trace@ip5f5a6a70.dynamic.kabel-deutschland.de)
[12:18:53] *** Quits: elnavigator (~elnavigat@105.196.223.220) (Ping timeout: 258 seconds)
[12:19:21] *** Quits: unixpro1970 (~unixpro19@c-73-181-185-205.hsd1.wa.comcast.net) (Ping timeout: 268 seconds)
[12:19:22] *** Joins: zwr (~zwr@2804:d45:b966:fb00:2262:77f0:28ac:c0e)
[12:19:29] *** Quits: webnet4 (~0x100@32.211.211.39) (Remote host closed the connection)
[12:25:53] *** Joins: elnavigator (~elnavigat@105.196.223.220)
[12:25:57] <password> vdamewood heh that makes one of us :P
[12:28:02] <vdamewood> password: You don't think South African history is fascinating?
[12:28:12] <merijn> I never got why they didn't just call it "the farmer's wars"
[12:28:13] <password> not really
[12:28:36] *** Joins: qu4nt1n (~qu4nt1n@78.198.214.34)
[12:28:38] <password> merijn what did they call it?
[12:28:56] <CuriousErnestBro> huh InPhase why is rindolf banned?
[12:29:23] *** Joins: unixpro1970 (~unixpro19@c-73-181-185-205.hsd1.wa.comcast.net)
[12:29:29] <password> on shit is he still banned , wtf?
[12:29:47] <merijn> password: They call it "the Boer wars" in English for some weird reason
[12:30:16] <password> that literally means farmers war
[12:30:28] <password> Boereoorlog
[12:30:34] <merijn> Well, yes, which is why its weird they don't translate it
[12:30:50] <merijn> Why translate "oorlog", but not "boer"?!
[12:31:10] <password> because boer is the name of it
[12:31:12] <CuriousErnestBro> Boers are descendants from the VOC (dutch east india company)
[12:31:20] *** Joins: scabootssca_ (~scabby@user/scabootssca)
[12:31:28] <password> i work for the dutch -__-
[12:31:40] <CuriousErnestBro> it's not used as "farmer" that's why it's not tranlsated 
[12:31:51] *** Quits: qu4nt1n (~qu4nt1n@78.198.214.34) (Client Quit)
[12:32:07] *** Joins: alycidyne (~kova@91-160-172-214.subs.proxad.net)
[12:32:54] <merijn> CuriousErnestBro: Except, no one in the conflict is named that, since it was the Transvaalrepubliek and Oranje Vrijstaat, both mostly made up of farmers and thus boerenoorlog
[12:33:03] <edgar-rft> why is "edgar" not translated? my real name is "wealthy spear"!
[12:33:15] <alycidyne> Hello, can (C) unions replace pointer conversions?
[12:33:23] <merijn> edgar-rft: That argument makes sense, if anyone was using Boer as a name in that conflict
[12:33:28] <merijn> edgar-rft: But they weren't
[12:33:35] *** Joins: Tazmainian (~Tazmainia@41.193.169.28)
[12:33:44] <vdamewood> alycidyne: How do you mean?
[12:34:01] <merijn> alycidyne: Well, pointer conversions are (mostly) UB, and unions are not, so... :p
[12:34:13] <merijn> Or rather
[12:34:17] *** Quits: scabby_ (~scabby@user/scabootssca) (Ping timeout: 248 seconds)
[12:34:18] <merijn> Pointer conversion is not
[12:34:23] * edgar-rft is cooking a soup from C onions
[12:34:28] <merijn> Accessing a converted pointer as the wrong type is UB
[12:34:34] <vdamewood> alycidyne: in general, accessing one member of a union after setting another is undefined behavior.
[12:34:39] <alycidyne> vdamewood: in C++
[12:34:50] <vdamewood> No, in C, too.
[12:34:53] <beaky> yes pointer conversion is one of the things everyone likes to laud c for being such a low level language that lets you do anything but turns out it is undefined behavior
[12:34:53] <merijn> alycidyne: Also in C, iirc, but I'd have to look it up in the spec
[12:34:55] *** Joins: NEYi (~NEYi@109.251.216.38)
[12:35:19] <CuriousErnestBro> merijn interesting..
[12:35:20] <merijn> So, I guess, technically unions *are* a replacement for pointer conversion...carry on
[12:35:32] <CuriousErnestBro> tech union when?
[12:35:44] <akronymus> catch (exception e) { throw new Exception("",e); }
[12:35:47] <akronymus> This is fine, right?
[12:35:52] <beaky> nice im a tech bro myself
[12:35:58] <merijn> CuriousErnestBro: I'm already in the union for academia :p
[12:36:19] <alycidyne> The major advantage I see in unions is that they allow eliminating many situations of pointer aliasing
[12:36:33] <alycidyne> And also allow a considerable strengthening of the type system
[12:36:56] <merijn> *strengthening*?
[12:36:58] <merijn> How?
[12:37:08] <akronymus> Tagged unions
[12:37:23] <akronymus> Allow you to have a object that is EITHER this type OR that type.
[12:37:34] <merijn> tagged/discriminated unions are different from C unions, though
[12:37:44] <akronymus> You can use c unions to implement them.
[12:37:52] <alycidyne> akronymus: you don't even need to tag them; a union on its own simply restricts the possible cases enough
[12:37:59] <merijn> tagged/discriminated unions (or ADTs even, if we take it a step further) are a great idea
[12:38:03] <merijn> C style unions are dumb
[12:38:18] <alycidyne> akronymus: tagging is for run time typing
[12:38:24] <akronymus> alycidyne but a naked union has the problem of not preventing access to the wrong type 
[12:38:27] <merijn> alycidyne: How would you know which value is in the union, though?
[12:38:46] <akronymus> C style unions are useful.
[12:39:02] <akronymus> But dangerous
[12:39:39] <alycidyne> akronymus: so you would consider `union {float f; int i} conv = { .f = myfloat }; myint = conv.i;` wrong?
[12:39:56] <merijn> alycidyne: That is incorrect C, yes
[12:40:33] <alycidyne> what if you need to interpret a float as an int? for e.g. the fast inverse square or, heck, checking for a signaling NaN on a microcontroller?
[12:40:47] <akronymus> Then you just do a (type) cast.
[12:41:04] * password stillwants to ban floats
[12:41:17] <akronymus> But yeah, that is one of the rare-ish cases for a naked union.
[12:41:22] <alycidyne> akronymus: (float)4 will *represent* 4 as a float - which is not what bit manipulation is about
[12:41:24] <akronymus> Hence useful.
[12:41:31] <akronymus> Oh, 
[12:41:55] <akronymus> Yeah, then the naked union seems like the way to go.
[12:42:01] <password> hmmm
[12:42:05] <password> i have an idea!
[12:42:12] * password squirrels off into the distance
[12:42:14] <edgar-rft> merijn: I think the main reason is because the "Boer wars" happened between the UK and the dutch-related "Boer Republics", what was a common term at that times  -> https://en.wikipedia.org/wiki/Boer_Republics
[12:42:15] <bayaz> Title: Boer Republics - Wikipedia 
[12:42:17] <akronymus> In many cases, you want a tagged one though.
[12:42:35] <alycidyne> akronymus: fine, for, uh, *normal* application dev, yes
[12:42:45] <alycidyne> thing is, C was designed for abnormal applications
[12:42:51] <akronymus> (x) doubt
[12:43:04] <akronymus> C was designed to be a portable language.
[12:43:15] <merijn> edgar-rft: Which is still weird, because why not just the farmer's republics? :p
[12:43:55] <alycidyne> It's funny - people make bit manipulation sound like an obscene term
[12:44:04] *** Quits: password (~password@user/password2) (Quit: Connection closed)
[12:44:06] <vdamewood> alycidyne merijn: Oops. The C standard says: If the member used to read the contents of a union object is not the same as the member last used to store a value in the object, the appropriate part of the object representation of the value is reinterpreted as an object representation in the new type as described in 6.2.6 (a process sometimes called "type punning"). This might be a trap representation.
[12:44:14] <akronymus> Bit fiddling is useful.
[12:44:20] <akronymus> I wouldn't even call it abnormal.
[12:44:21] <merijn> alycidyne: The only correct way to interpret a float "as int" (i.e. convert the bits) is by taking float*, casting to char*, copying the bytes from char* to int* and then read the int
[12:44:28] <edgar-rft> merijn: probably propaganda reasons, they wanted to create a term that sonds more like "enemies" instead of simple farmers
[12:44:30] <akronymus> Just not what most people intend to do.
[12:44:41] <merijn> vdamewood: Yeah, so not UB, but implementation defined, it seems
[12:44:49] <merijn> vdamewood: Still not portable, though :p
[12:45:04] <alycidyne> merijn: that's exactly what we were comparing unions to - and which we was decided was superior to...
[12:45:19] <akronymus> merijn wouldn't converting it to a void
[12:45:21] <merijn> alycidyne: casting float* to int* isn't portable or safe either
[12:45:29] <akronymus> void* then int* work?
[12:45:33] <merijn> akronymus: No
[12:45:46] <merijn> akronymus: That's still accessing an object through a non-compatible pointer
[12:45:50] <alycidyne> vdamewood: yeah, I keep that fact always ready in my mind - that type punning in C is explicitly allowed ^^'
[12:45:57] <merijn> akronymus: THe pointer *conversions* are well defined
[12:46:00] *** Joins: v0id_ptr (~longlong@user/ptr-frac7al/x-0038398)
[12:46:02] <akronymus> Got it.
[12:46:18] <merijn> akronymus: But C spec *explicitly* says that "accessing as a "non-compatible object type"" is UB
[12:46:20] <alycidyne> vdamewood: (via unions, I meant.)
[12:46:28] <merijn> akronymus: And float and it aren't compatible types under C rules
[12:46:33] <vdamewood> alycidyne: Yeah, and the referenced section 2.6.6 just says that excess bytes are unspecified.
[12:46:41] <merijn> akronymus: The only exception is that *all* types are compatible with char*
[12:46:42] <vdamewood> alyc6.2.6 I mean
[12:46:44] <akronymus> I had the assumption that void* allows you to just treat it as a collection of bits.
[12:46:48] <alycidyne> vdamewood: got it
[12:46:59] <edgar-rft> C was designed as an unfinished software prototype, the letter C was meant as something like a version number (according to Dennis Ritchie in "The development of the C language").
[12:47:14] <merijn> akronymus: So casting a pointer to char* allows you to read byte-wise data (which you can write to another pointer that just happens to be to a float)
[12:47:15] <akronymus> C is a derivative of B too.
[12:47:20] <alycidyne> edgar-rft: C came from B, that's why the type system is... somewhat lacking
[12:47:24] <akronymus> See: Pointer syntax.
[12:47:41] <vdamewood> alycidyne: So anyway, yeah, using uinions is a way you can convert pointer types, assuming your implementation implements all the pointers the same way.
[12:47:45] <akronymus> oh right. char = byte for most intents and purposes.
[12:47:54] <merijn> akronymus: char = byte per the C spec
[12:48:01] <alycidyne> So C is a miracle of evolution and a disaster of design
[12:48:08] <edgar-rft> yes, B .. BCPL .. C - something like that
[12:48:08] <merijn> (although the C spec does not require bytes to be 8 bit, because fuck you)
[12:48:17] *** Joins: Auron (~Auron956@user/auron)
[12:48:38] <alycidyne> merijn: can we not diss 9-bit bytes please?
[12:48:53] <merijn> You joke, but I've seen C implementations with 32 bit bytes
[12:48:55] <akronymus> Yeah, at the time non-8bit per byte machines were reasonable common.
[12:48:58] * alycidyne has a soft spot for 36-bit mainframes
[12:49:15] *** Quits: gggp (~gggp@60.10.23.162) (Remote host closed the connection)
[12:49:22] <beaky> nice i like 32-bit mainframes like ibm 360
[12:49:24] <akronymus> 12 bit gang represent. :p
[12:49:32] *** Joins: amahl (~amahl@dsl-jklbng12-54fbca-64.dhcp.inet.fi)
[12:49:38] *** Joins: gggp (~gggp@60.10.23.162)
[12:49:39] <alycidyne> I like them long, you know what I mean? ;)
[12:49:42] <akronymus> https://en.wikipedia.org/wiki/12-bit_computing
[12:49:42] <bayaz> Title: 12-bit computing - Wikipedia 
[12:49:51] <akronymus> Specifically that table to the right though
[12:50:17] <akronymus> https://en.wikipedia.org/wiki/31-bit_computing
[12:50:18] <bayaz> Title: 31-bit computing - Wikipedia 
[12:50:24] <akronymus> D:
[12:51:15] *** Quits: gggp (~gggp@60.10.23.162) (Remote host closed the connection)
[12:51:38] *** Joins: gggp (~gggp@60.10.23.162)
[12:52:37] *** Quits: zwr (~zwr@2804:d45:b966:fb00:2262:77f0:28ac:c0e) (Ping timeout: 258 seconds)
[12:53:04] <alycidyne> Anyway, I asked because I'm reaching the, ah, nether parts of unions - specifically, what happens when the members are arrays
[12:53:31] <alycidyne> I'm investigating how unions would impact contiguous matrix allocation
[12:53:32] <akronymus> (âˆ©ï½€-Â´)âŠƒâ”â˜†ï¾Ÿ.*ãƒ»ï½¡ï¾Ÿmagic alycidyne
[12:54:31] <beaky> nice are c unions like noita in real life
[12:54:33] *** Joins: gggp_ (~gggp@60.10.23.162)
[12:54:33] <alycidyne> *starry eyes*
[12:54:48] *** Quits: elnavigator (~elnavigat@105.196.223.220) (Ping timeout: 272 seconds)
[12:55:01] <edgar-rft> Let's treat everything in the real-world that's outside of the C specification as undefined behaviour :-)
[12:55:31] <alycidyne> edgar-rft: isn't that kind of the definition of UB to begin with? ;)
[12:55:59] <edgar-rft> Sorry, I can't understand, you behave undefinedly!
[12:56:11] <vdamewood> some people are undefined behavior.
[12:56:44] <alycidyne> vdamewood: true dat
[12:57:17] <akronymus> We can just assume UB never happens.
[12:57:22] <akronymus> And thus optimize it away.
[12:57:24] *** Joins: entuland (~entuland@user/entuland)
[12:57:26] <akronymus> Goodbye cruel world.
[12:57:45] *** Quits: gggp (~gggp@60.10.23.162) (Ping timeout: 248 seconds)
[12:58:05] <vdamewood> ?
[12:58:13] <furrymcgee> rust?
[12:58:28] <vdamewood> Oh, you have to be kidding me. I typed out a whole question, and my client deletes it on me when it hit the quesiton mark.
[12:58:36] <akronymus> I was referring to edgars comment about real world being UB.
[12:58:38] <vdamewood> Can we optimize some people away?
[12:58:49] <furrymcgee> ignore
[12:58:58] <akronymus> And further that compilers area allowed to just assume UB doesn't happen and thus optimize it away.
[12:59:10] *** Joins: bcd (~bcd@user/bcd)
[13:00:07] *** Quits: AbleBacon (~AbleBacon@user/AbleBacon) (Read error: Connection reset by peer)
[13:00:07] <beaky> nice i like rust
[13:00:35] <alycidyne> akronymus: the real problem is what I call idiotic UB - e.g. uninitialized variables or `a = a++`
[13:01:44] <edgar-rft> Real-world behaviour once was perfectly specified until the linker got broken...
[13:02:03] *** Quits: moose (~moose@user/moose) (Read error: Connection reset by peer)
[13:03:14] <vdamewood> printf("%i %i %i\n", i++, i++, i++);
[13:03:30] <alycidyne> vdamewood: oh dear lord
[13:03:39] <akronymus> Doesn't scream UB to me.
[13:03:44] <vdamewood> I feel so evil.
[13:04:00] *** Joins: plastico (~plastico@neomutt/plastico)
[13:04:19] <alycidyne> akronymus: evaluation of function arguments is not a sequence point in C
[13:04:34] <akronymus> Wait what?
[13:04:44] *** Quits: img (~img@user/img) (Quit: ZNC 1.8.2 - https://znc.in)
[13:04:52] <akronymus> printf("%i %i %i\n", incrementandreturnvalue(), incrementandreturnvalue(), incrementandreturnvalue()); This wouldn't work either?
[13:05:08] <merijn> akronymus: function calls are sequence points
[13:05:17] <alycidyne> akronymus: nope. in `foo(bar(), baz())`, `bar()` isn't specified to happen before `baz()`
[13:05:19] <merijn> akronymus: But you don't know in which order those 3 will be evauated
[13:05:27] <akronymus> D:
[13:05:34] <vdamewood> The order of the evaluation of function arguments is unspecified.
[13:05:54] <merijn> akronymus: Pro-tip: The more you learn about C's *actual* spec, the more you realise it's a wildly stupid language :p
[13:06:15] <akronymus> C isn't stupid. Just not well designed.
[13:06:19] <merijn> akronymus: There's two C languages: 1) the one people *think* C is (and like), and 2) the language C actually *is* (and sucks)
[13:06:22] <vdamewood> It makes perfect sense for its goals, it's just that its goals are from 1988.
[13:06:34] <akronymus> ^
[13:06:34] <merijn> vdamewood: And for wildly irrelevant hardware ;)
[13:06:45] <akronymus> It was relevant at the time
[13:06:51] <beaky> what would a hardware architecture optimized for lazy evaluation like haskell look like
[13:07:00] <akronymus> LISP machines?
[13:07:04] <beaky> since i like lazy evaluation but it is so cache unfriendly and stuff
[13:07:06] <alycidyne> vdamewood: s/1988/1972/
[13:07:16] <beaky> nice i like lisp 
[13:07:38] <vdamewood> alycidyne: I could see that, but I'd way in 1972, C was designed for one system, the PDP11/40.
[13:07:46] <vdamewood> I'd say*
[13:08:16] <alycidyne> vdamewood: yeah, fair point
[13:08:45] <akronymus> I wish lisp were more mainstream.
[13:08:50] <akronymus> So many good ideas in it.
[13:10:09] <beaky> yes like the keyboard that came with lisp http://xahlee.info/kbd/space-cadet_keyboard.html
[13:10:10] <bayaz> Title: Space Cadet Keyboard 
[13:10:22] <vdamewood> I would also say there is a third form of 'C' that people 'know', and it's C++ with a fake mustache.
[13:11:46] <vdamewood> I like my keyboard layout. I can type Ã¾ings like Ã¾is.
[13:12:07] <vdamewood> and Ã¾Ã¦t
[13:12:21] <alycidyne> Anyway, my specific problem with arrays in unions is alignment. See, I have a lang with dynamic arrays and strong typing
[13:12:38] *** Joins: GeDaMo (~GeDaMo@82-69-2-253.dsl.in-addr.zen.co.uk)
[13:12:38] *** Quits: GeDaMo (~GeDaMo@82-69-2-253.dsl.in-addr.zen.co.uk) (Changing host)
[13:12:38] *** Joins: GeDaMo (~GeDaMo@user/gedamo)
[13:13:07] <death916> \tfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffv     
[13:13:08] <death916>                                                                                                          r]
[13:13:14] <death916> sorry
[13:13:18] <death916> i set my book on laptop
[13:13:31] *** Joins: elnavigator (~elnavigat@105.196.154.34)
[13:13:36] * vdamewood takes his finger off the +q button.
[13:13:40] * Arahael thought it was a cat. He was disapointed.
[13:13:40] <death916> lol
[13:14:13] <akronymus> Arahael Ferrets > cats though
[13:14:14] <death916> if it was a cat id be home and not at work
[13:14:31] *** Joins: Atque (~Atque@user/atque)
[13:14:32] <death916> although there is a pack of cats in the parking lot so i guess it could be here
[13:14:35] <vdamewood> death916: Still more disapointment.
[13:14:38] <death916> haha
[13:14:49] <death916> for real tho
[13:14:53] <vdamewood> Anyway, sleepy time.
[13:14:54] <Arahael> death916: If it were a cat, the next time it would happen would get a +q.  A book, on the other hand, isn't a sentient creature so difficult to threaten... ;)
[13:15:07] <death916> you never know these days
[13:15:13] <Arahael> akronymus: Ferrets bite and play too rough all the time!
[13:15:15] <death916> they could have achieved sentience when we were all on our phones
[13:15:19] <alycidyne> The lang uses unions in a lot of places to replace most C idioms. I'm currently trying to write code which contiguously allocates a matrix by uniting a single buffer with an array of arrays, but now things are... muddy. Should the runtime actually recalculate array lengths and alignments?
[13:15:32] <Arahael> akronymus: Cats, by contrast, are merely unpredictable.
[13:15:56] <death916> merely is understating it
[13:16:18] <akronymus> https://www.youtube.com/watch?v=d2CTVqt2wxU Arahael
[13:16:24] <alycidyne> `union { float b[]; float M[][]; }` (both dynamic arrays) is giving some... weird conclusions for me
[13:16:42] <akronymus> Is M jagged?
[13:16:44] *** Joins: Pickchea (~private@user/pickchea)
[13:16:44] *** Quits: bytecrawler (~bytecrawl@gateway/tor-sasl/bytecrawler) (Ping timeout: 244 seconds)
[13:16:58] <alycidyne> akronymus: nope
[13:17:09] <merijn> Arahael: Depends how well socialised they are
[13:17:11] <akronymus> Good.
[13:17:16] <merijn> Ferrets are funny as fuck
[13:17:57] <GeDaMo> alycidyne: what kind of weirdness?
[13:18:03] <merijn> But you better have your house completely locked down to keep them out of everything and good ventilation if you want guests to come over despite the smell
[13:18:20] <merijn> Arahael: What? Most cats are super-predictable
[13:18:23] <alycidyne> well, okay, technically `union { float b[n*m]; float M[n][m]; }`
[13:18:33] <akronymus> I'd probably do a `union{struct {float b[]; int len};  struct { float M[][]; int dim1; int dim2;}}`
[13:18:40] <merijn> Arahael: Most people are just bad at predicting mental state/desires of cats :p
[13:18:59] <merijn> akronymus: That looks like a stoat or weasel, though
[13:19:00] <akronymus> Oh. the first is just a linear accessor to the same data?
[13:19:07] <akronymus> merijn close enough
[13:19:10] <Arahael> merijn: Imagine not being able to hear a cat, who is trying to meow and get your attention, though. ;)
[13:19:12] <merijn> oh, wait, the title says weasel >.>
[13:19:16] *** Joins: img (~img@user/img)
[13:19:33] <alycidyne> akronymus: that would be true in C; I was writing in my lang (Gamma)
[13:19:33] <Arahael> That youtube doesn't appear to have captions.
[13:19:42] <merijn> Arahael: Ours rarely meows, she mostly communicates visually and by headbutt
[13:19:42] <akronymus> Got it. alycidyne
[13:19:45] <alycidyne> akronymus: (https://setun-90.github.io/gamma-spec.html if you're interested)
[13:19:50] <merijn> Arahael: It just has random music as soundtrack
[13:19:50] <Arahael> merijn: Very nice.
[13:20:00] <akronymus> I guess length is a property of arrays? alycidyne
[13:20:02] <Arahael> Ah, I'll check it out. (Curiously doesn't play in mpv either)
[13:20:31] <merijn> Arahael: It's just a weasel hyperactively jumping around a thumb
[13:20:42] <merijn> Which sounds like the normal default state of any mustelid, tbh
[13:20:49] <Arahael> Ok, that weasle looks cute. :)
[13:21:03] <akronymus> Do not look at the upload date though
[13:21:08] <alycidyne> akronymus: yes, which also leads to another big question for me. Can't fixed-size arrays already be considered dependent types? Whenever I try to add dependent types to the language, unpleasant things happen for me
[13:21:54] <Arahael> merijn: I've heard that weasles often think your hand is your head?
[13:22:00] <akronymus> I wouldn't say so. alycidyne
[13:22:03] <Arahael> merijn: So if they want to show you something, they take your hand?
[13:22:08] <merijn> Arahael: Doubt it, they're pretty smart
[13:22:12] <merijn> but, like, in a dumb way
[13:22:20] <Arahael> Heh...
[13:22:20] <akronymus> Hand is convenient to drag you with
[13:22:45] <merijn> tbh, ferrets are *the* poster child for "what's the difference between int and wis in D&D?"
[13:22:55] <Arahael> Yeah?
[13:22:58] <merijn> Ferrets are for sure high int, low wis >.>
[13:23:20] <merijn> Arahael: They are super clever at achieving dumb shit that brings them in trouble >.>
[13:23:40] <Arahael> Cats, by contrast, are just selfish.
[13:23:51] <alycidyne> More worringly, I don't know how to... reuse fixed-length arrays for memory allocation.
[13:24:15] <alycidyne> I feel like there's an evident truth right in front of me... but my experience is blinding me.
[13:24:18] <merijn> Arahael: My girlfriend used to have two ferrets. At one point one of them started digging out plants in the pots (because they like digging)
[13:24:30] <merijn> Arahael: Used a waterspray to get it to stop
[13:25:14] *** Quits: inhahe_ (inhahe@107-213-219-122.lightspeed.miamfl.sbcglobal.net) ()
[13:25:18] <merijn> Arahael: First spritz. He stops, looks up confused and worried. 10s back to digging. Spray again, confused again but only 5s. And eventually he just ignores it entirely and keeps digging >.>
[13:25:28] <Arahael> Heh.
[13:25:46] <merijn> Arahael: They're all curiosity and exploring, but 0% self-preservation >.>
[13:25:46] <Arahael> So it didn't stop?
[13:26:11] *** Joins: node1 (~node1@user/node1)
[13:26:50] *** Quits: node1 (~node1@user/node1) (Remote host closed the connection)
[13:27:10] *** Joins: node1 (~node1@user/node1)
[13:27:15] <alycidyne> One idea I had a while ago was eliminating the free store and instead simply stack-allocating everything, using function calls to establish context
[13:28:12] <Arahael> alycidyne: There's a scheme implementation that implements their GC using the stack like that.
[13:28:27] *** Joins: chomwitt (~chomwitt@2a02:587:dc02:6400:12c3:7bff:fe6d:d374)
[13:28:47] <alycidyne> e.g. `client_t c; handle(&c);` and so on, where the calling function serves double duty as the initial context or environment
[13:29:01] <alycidyne> Arahael: Chicken Scheme perchance?
[13:29:09] <Arahael> alycidyne: Yeah.
[13:29:13] *** Joins: Inhahe (inhahe@107-213-219-122.lightspeed.miamfl.sbcglobal.net)
[13:29:27] *** Joins: DnzAtWrk (~DnzAtWrk@mobile-access-6df05f-197.dhcp.inet.fi)
[13:29:27] *** Joins: susepointe (~mzamenski@79.142.69.168)
[13:29:39] <Arahael> They called it "chenny on the stack" or something, but I can't remember the spelling.
[13:29:52] <susepointe> Is cmake worse than php? i heard it was
[13:30:05] <GeDaMo> "CONS Should Not CONS Its Arguments, Part II: Cheney on the M.T.A." https://junk.8325.org/hbaker/CheneyMTA.html
[13:30:06] <bayaz> Title: Cheney on the M.T.A. 
[13:30:22] <susepointe> Oh btw, i forgot to introduce myself
[13:30:23] <Arahael> That might be it!
[13:30:37] <susepointe> Hello, I am a long-term Linux user who codes as a hobby.
[13:30:46] <beaky> yes using continuation passing style you can tailcallify everything and thus also handle free variables in (recursive) functions with the stack (or stackless too)
[13:30:59] <Arahael> susepointe: cmake is worse than php in the same way that apples are worse than... Uh...  Oranges. :) They do very different things.
[13:31:19] <susepointe> ah ok
[13:31:31] <alycidyne> Arahael: even the Wikipedia article on Chicken Scheme details some fascinating things honestly
[13:32:04] <Arahael> alycidyne: Scheme is one of the lnaguages that have been on my list of languages to learn and use... For 15 years now. :(
[13:32:41] <alycidyne> Arahael: "use" is perhaps too strong a commitment, sadly. :-/
[13:32:45] <beaky> yes during that time rust finally arrived so i guess scheme will have to wait until we rewrit ethe world in rust
[13:32:51] *** Joins: federico_it (~textual@151.95.116.125)
[13:32:54] <susepointe> Cmake is used for downloading dependencies in Cpp right?
[13:33:11] <susepointe> or something like that
[13:33:26] *** Quits: __that__ (~Guest98@195.59.168.126) (Quit: Client closed)
[13:33:33] <Arahael> susepointe: I think it can, but usually no, usualy it's used for configuring the current program with the current dependencies you already have.  You usually have to download the dependencies and install them manually.
[13:33:44] <Arahael> susepointe: Mind you, I'm not really a cmake user.
[13:33:47] <beaky> yes cmake is worse than php at least php is honest about its flaws and about aiming to be a programming language
[13:34:15] <susepointe> Ah. i knew it was something to do with dependencies
[13:34:33] <alycidyne> beaky: the community's honesty still doesn't compensate their attitude :-/
[13:34:54] <beaky> cmake proudly advertises itself as a modern robust 'designed' build system when its really a lump of mud put together in an adhoc way presented 
[13:34:59] <amigojapan> beaky: there Is already an OS written in rust
[13:35:11] <beaky> nice i must uninstall gentoo and install that rust os then
[13:36:12] <alycidyne> the same that the Rust architect's attitudes towards problems irks me. Especially the `unsafe` - I am extremely worried about people's attitudes towards "unsafe", this IMO frames it so wrong
[13:36:27] <merijn> Why?
[13:36:37] <amigojapan> beaky: https://www.redox-os.org/
[13:36:38] <bayaz> Title: Redox - Your Next(Gen) OS - Redox - Your Next(Gen) OS 
[13:36:48] *** Joins: jmft2 (~JMFT@81.149.115.87.dyn.plus.net)
[13:37:03] *** Quits: c705 (c705@alpine/contributor/c705) (Ping timeout: 268 seconds)
[13:37:47] *** Joins: gitesh (uid423739@id-423739.charlton.irccloud.com)
[13:37:57] <Arahael> alycidyne: What's wrong with unsafe?
[13:38:11] <DnzAtWrk> hehe, makefiles
[13:38:14] <beaky> no longer will i use gentoo cflags -march=native -Ofast -flto -fpgo -fomg-optimize i will now have an os with [RUSTFLAGS] -opt-level=3 -mcpu-arch=native -lto=full
[13:38:42] <alycidyne> Arahael: the very idea of "unsafe" itself, along with the implied characterisation
[13:38:55] <merijn> alycidyne: "safety" has a specific *technical* meaning in Rust. The language guarantees a bunch of things *cannot* ever happen, when using the language. But since we're all pragmatic adults, sometime we (think) we know better. The "unsafe" stuff merely means "if you fuck up as a programmer, the compilers guarantees about what cannot happen hold"
[13:39:18] <Arahael> alycidyne: What's the idea of "unsafe" you don't like?
[13:39:31] <Arahael> alycidyne: To me, it's a "Here's the escape hatch: There are dragons, and worse".
[13:39:37] <merijn> alycidyne: Rust's language spec says: Your code will never have race conditions and you cannot leak memory *IFF* you don't use unsafe
[13:39:50] <merijn> alycidyne: If you use unsafe, it's all dragons and UB and you better know what you're doing
[13:40:17] <alycidyne> merijn: that right there! the notion that programmers don't need to know what they're doing
[13:40:22] <DnzAtWrk> why is gamedev so unpopular with rust?
[13:40:23] <merijn> alycidyne: No
[13:40:34] <beaky> rewrite factorio in rust
[13:40:37] <merijn> alycidyne: People are flawed and people fuck up
[13:40:43] <merijn> alycidyne: Literally all the time
[13:40:55] <merijn> There's billions hours of research showing this in every single possible field
[13:40:59] <alycidyne> merijn: what I meant was that you made me realize what irks me in the world of today
[13:41:08] <beaky> why doesnt redox os use the seL4 kernel instead of a new one
[13:41:13] <merijn> Did you think airplanes were safe because "pilots need to not make mistakes"?
[13:41:18] <Arahael> alycidyne: Programmers shoudl know what they're doing, but it's also convenient to have the compiler check and enforce as much as it can.  But where you need to, there is a clear way to get past it.
[13:41:26] <DnzAtWrk> people are flawed and make mistakes, and that is okay
[13:41:32] <merijn> No, airplanes are safe because we designed everything about airplanes so that pilots fucking up doesn't kill people
[13:41:39] *** Joins: RohitShinde[m] (~rohitsmat@2001:470:69fc:105::d66d)
[13:41:39] <DnzAtWrk> less okay with airplanes tho
[13:41:47] <merijn> Programming languages should be designed so that programmers fucking up don't kill people either
[13:41:56] <merijn> Or 'cause billion dollar outtages
[13:42:07] <DnzAtWrk> you're just shifting responsibility on the developers of the language
[13:42:11] <DnzAtWrk> who wants to take on that burden
[13:42:29] <merijn> If you approach to "removing bugs" is "all programmers should just be perfect and never make mistakes", then I have some bad news for you
[13:42:39] <DnzAtWrk> programs can literally never be perfect
[13:42:44] <DnzAtWrk> radiation from space can add bugs
[13:42:48] <DnzAtWrk> and all kinds of other things
[13:42:59] <Arahael> DnzAtWrk: It's helpful to constrain the nature of such bugs, though.
[13:43:04] <deniska> if something can't be perfect doesn't mean it can't be improved
[13:43:06] <alycidyne> merijn: well I always put it on myself to not repeat bugs
[13:43:12] <DnzAtWrk> yes, you use RAM for example which uses checksums or whatever 
[13:43:19] <merijn> alycidyne: Well I hope you don't write C, then :p
[13:43:31] <merijn> Because I'm a paranoid motherfucker when it comes to writing correct C
[13:43:37] <alycidyne> merijn: what worries me about that is that, to me, it can be an argument to not improve oneself
[13:43:43] <merijn> And I don't think any of my C code of more than 100 lines is bug free
[13:43:52] <deniska> "to avoid bugs you just should get good at programming" is a flat earth theory of programming :)
[13:43:52] <alycidyne> merijn: ah okay, sorry I'm wasting your time then
[13:43:54] <DnzAtWrk> easier to just add redundant systems
[13:43:57] <DnzAtWrk> than to make the one unicorn software
[13:44:06] <merijn> alycidyne: Bad programmers writing in a safe language can still write shitty, unmaintainable, slow code
[13:44:10] *** Joins: zwr (~zwr@2804:d45:b966:fb00:c513:305c:1efa:a7fb)
[13:44:19] <merijn> alycidyne: You still have to be *good*
[13:44:38] <alycidyne> merijn: yes, but people don't care about those qualities. They only care about whether the code works, not *how* it does
[13:44:39] <merijn> It just means that you don't randomly destroy things when you write a line of code while tired at 4 PM on friday
[13:44:51] <merijn> deniska: Word
[13:44:51] <Arahael> When you're a surgeon, you have multiple systems in place to ensure you don't accidentally cause a big mess.  Are you suggesting that we should remove all the safeties?
[13:45:00] <merijn> deniska: Also, why is it so freaking popular?!
[13:45:03] <alycidyne> merijn: what I'm worried is that it destroys the value of quality
[13:45:04] <DnzAtWrk> lol
[13:45:13] <DnzAtWrk> you do know about the first x-ray machines right?
[13:45:15] <merijn> deniska: And why is it always popular with the people who don't know C, but claim they love C?!?
[13:45:31] <merijn> alycidyne: Therac-25
[13:45:31] <piou> alycidyne: as someone that gets called to review lots of company code, the average time it takes me to find important bugs in C programs is about 10 minutes. I have seen companies with very nice codebases, so I won't say it doesn't exist, but after reading millions of lines of C I am absolutely with merijn on that one.
[13:45:51] <deniska> the amount of bugs per lines of code is constant, so we can only work in two directions: make fewer lines of code necessary to achieve the same goal, and reduce what kinds of bugs can be introduced, so we're left with milder bugs
[13:45:56] <merijn> alycidyne: There is no quality tobegin with
[13:45:57] <DnzAtWrk> https://www.youtube.com/watch?v=L_-vf8RBzuc
[13:46:00] <DnzAtWrk> lol killer bugs
[13:46:06] <merijn> alycidyne: ALl software and all programmers are fucking awful at what they do
[13:46:10] <user51> man, i just like scripting languages
[13:46:13] *** Quits: node1 (~node1@user/node1) (Quit: Leaving)
[13:46:21] <user51> they're pretty safe
[13:46:25] *** RohitShinde[m] is now known as RohitShinde[m]1
[13:46:31] <merijn> And then sooner you learn to accept this sad reality, the more productive you will be
[13:46:33] <alycidyne> user51: :-(
[13:46:37] <deniska> a program crash is annoying and often undesired, but less annoying and undesired than letting an attacker put random bytes in RAM and jump to them as if it's an executable code
[13:46:37] <piou> alycidyne: I think it's important for programers to get better, but there are more important things to get better at than constantly fighting against buffer overflows. I'd rather they concentrate their energy on good architecture, good design, improved performance etc
[13:46:43] <alycidyne> merijn: no, I'm just demotivated now
[13:46:59] <alycidyne> piou: that too, but you also have to follow rules at some point
[13:47:02] <merijn> DnzAtWrk: So many stupid human errors fucking up everything
[13:47:02] *** Parts: RohitShinde[m]1 (~rohitsmat@2001:470:69fc:105::d66d) ()
[13:47:13] <merijn> alycidyne: The point is: Have the computer check the rules
[13:47:17] <Arahael> alycidyne: As a question, what sort of car do you drive?
[13:47:19] <merijn> Instead of doing it yourself
[13:47:34] <merijn> DnzAtWrk: Did you know about the time the US accidentally almost nuked itself? :p
[13:47:43] <DnzAtWrk> yes
[13:47:45] <DnzAtWrk> birds
[13:47:49] <piou> alycidyne: that's the whole point: reducing the number of rules you have to follow by leveraging these incredible machines we have allows you to focus on the important rules instead.
[13:47:51] <merijn> DnzAtWrk: Because they dropped an unsecured (armed!) nuke out of a plan by accident >.>
[13:47:56] <DnzAtWrk> ah
[13:48:01] <DnzAtWrk> it wasn't the radar incident?
[13:48:08] <alycidyne> Arahael: a 206 my dad bought... more and more rarely nowadays.
[13:48:26] <merijn> DnzAtWrk: No, I didn't mean "someone almost launched one", more "they literally dropped an armed one by accident" >.>
[13:48:38] <DnzAtWrk> hah. Well nukes are harmless unless armed
[13:48:39] <DnzAtWrk> afaik
[13:48:44] <alycidyne> merijn: the 1961 Goldsboro crash?
[13:48:49] <deniska> to be fair detonating a nuke actually takes effort :)
[13:48:58] <DnzAtWrk> and pistons of certain materials
[13:49:00] <alycidyne> merijn: okay, then what reason would you have to write elegant code?
[13:49:03] <DnzAtWrk> quickly launched into a core using some kind of guns
[13:49:08] <Arahael> alycidyne: Manual or auto?
[13:49:13] <alycidyne> Arahael: manual
[13:49:17] <Arahael> alycidyne: With a clutch?
[13:49:19] <merijn> DnzAtWrk: btw
[13:49:25] <alycidyne> Arahael: yes ofc
[13:49:39] <merijn> DnzAtWrk: If you like reading about "human fuck ups that terrify you"
[13:49:40] <Arahael> alycidyne: Why? Why not just change the gears at the correct time directly?
[13:50:03] <merijn> DnzAtWrk: You should read the details about the Rocky Flats nuclear weapons plant cleanup...it's...quite a thing
[13:50:15] <piou> alycidyne: you have all reasons to write elegant code, it's easier to maintain, easier to verify, easier to optimize. Reducing the number of bugs that can happen has nothing to do with making code less elegant.
[13:50:16] <DnzAtWrk> hehe, yeah I may have seen it
[13:50:25] <merijn> DnzAtWrk: List of highlight: https://twitter.com/ademrudin/status/1339404811364515840
[13:50:26] <DnzAtWrk> have you read about the people who researched nuclear weapons?
[13:50:29] <DnzAtWrk> https://www.youtube.com/watch?v=aFlromB6SnU
[13:50:38] <DnzAtWrk> derpy derp I'll just use a screwdriver to invoke fission
[13:50:42] <DnzAtWrk> whups, I dropped it
[13:50:43] <DnzAtWrk> I'm ded
[13:50:46] <merijn> Ah, the demon core, yeah
[13:50:53] <alycidyne> Arahael: because it's not just changing gears, mind you
[13:50:54] <merijn> DnzAtWrk: That happened multiple times too >.>
[13:50:58] <DnzAtWrk> very smart
[13:51:28] <alycidyne> Arahael: reduced weight, you learn to coordinate better, you can coast, etc.
[13:51:41] <alycidyne> Arahael: simplified repair
[13:51:48] <CuriousErnestBro> hey merijn you know kojac
[13:51:55] <CuriousErnestBro> I just had a call with them
[13:51:59] <merijn> DnzAtWrk: If you wanna read "whacky stories during the manhattan project" (and a bunch not during the Manhattan project), I highly recommend Feynman's biography "Surely you're joking, Mr. Feynman"
[13:52:08] <Arahael> alycidyne: You realise I'm using a metaphor here, and that it fits really well?
[13:52:12] <piou> that's a fun book, I second that recommendation
[13:52:15] <alycidyne> Arahael: Yes I do
[13:52:19] <CuriousErnestBro> they want me to list my "competences" and "character", how do I say I'm a sick cunt in polite english?
[13:52:20] <DnzAtWrk> that was the wrong video about the x-ray machines. I meant therac 25
[13:52:21] <DnzAtWrk> https://en.wikipedia.org/wiki/Therac-25
[13:52:22] <bayaz> Title: Therac-25 - Wikipedia 
[13:52:44] <merijn> piou: Feynman was...something :p
[13:53:02] <Arahael> alycidyne: When I use languages with sum types, as an example, I don't worry about trying to ensure I've covered every known enum case - if I miss one, I can trust that the compiler will tell me. This affords immense improvements in productivity.
[13:53:25] <piou> merijn: Sometimes I ask people who their hero is, their role model, someone that inspired them growing up to become more than themselves. Feynman is definitely mine.
[13:53:31] <DnzAtWrk> "The system distinguished between errors that halted the machine, requiring a restart, and errors which merely paused the machine (which allowed operators to continue with the same settings using a keypress). However, some errors which endangered the patient merely paused the machine, and the frequent occurrence of minor errors caused operators to become accustomed to habitually unpausing the machine. "
[13:53:37] <DnzAtWrk> ah yes
[13:53:51] <CuriousErnestBro> mine is christiano ronaldo 
[13:54:13] <DnzAtWrk> reminds me of that one final destination movie
[13:54:19] <DnzAtWrk> which I didn't watch because I don't have the guts for it
[13:54:20] *** Quits: susepointe (~mzamenski@79.142.69.168) (Ping timeout: 258 seconds)
[13:54:21] <alycidyne> And for the record, Therac-25 isn't just about bad programming or human errors - it's also about them not being corrected
[13:54:29] <alycidyne> You can commit errors, but not in production
[13:54:39] <CuriousErnestBro> piou you're surely joking mr. feynman is one of the few books I've read, I particularly enjoyed the drumming story in south america
[13:54:49] <CuriousErnestBro> that one stuck for some reason
[13:54:53] <DnzAtWrk> was that even a mantra at that point alycidyne?
[13:55:07] <akronymus> Anything I missed?
[13:55:14] <akronymus> Had to unscrew some JS
[13:55:21] <alycidyne> DnzAtWrk: why? Should it not be for some reason?
[13:55:33] <DnzAtWrk> it was 1982
[13:55:37] <alycidyne> DnzAtWrk: at that point, perhaps
[13:55:40] <CuriousErnestBro> piou did you study physics?
[13:56:14] <DnzAtWrk> anyway, if an error is going to kill someone, make it a fatal error
[13:56:15] <DnzAtWrk> got it
[13:56:17] <piou> CuriousErnestBro: yeah, I did. Only two years formally but still.
[13:56:18] <DnzAtWrk> oh wait.... hahaha
[13:56:18] <alycidyne> Even I will agree that trying to write flawless code the *first* time, or writing and forgetting is terrible practice.
[13:56:44] <CuriousErnestBro> piou nice, the physics uni was to far away so now I'm an econometrician 
[13:56:52] <piou> alycidyne: Thing is we're not much better at finding and fixing bugs later on. There will always be bugs to be fought, the point is to avoid those that are avoidable, and expecting humans to do the job just isn't reasonnable: it's been tried for 50 years now and by now we can say with confidence that it doesn't work, it's reasonnable to try another solution.
[13:57:02] <CuriousErnestBro> it's pretty much the same thing :^)
[13:57:44] <akronymus> DnzAtWrk if you kill someone just restart
[13:57:45] <Arahael> There are also many problems that a computer is very well suited for.  Type checking is one of them.
[13:57:49] <akronymus> -erlang programmers
[13:57:54] <Arahael> There's little reason to do something by hand that is far better done by computers.
[13:57:57] <alycidyne> piou: under the assumption that people don't improve later on... which, I will concede, is more frequent than it should be :-/
[13:57:59] <piou> CuriousErnestBro: that's a very interesting topic :) I love stats and economy.
[13:58:13] <DnzAtWrk> probably a good idea to have a lot of hardware protection for x-ray machines
[13:58:15] <Caffeinated> piou: lets use 'mindblock' like in THX-1138 :P
[13:58:19] <DnzAtWrk> will simply won't allow you to use lethal doses
[13:58:24] <akronymus> alycidyne even stagnation is preferable over regression
[13:58:36] <DnzAtWrk> which*
[13:58:43] <alycidyne> akronymus: I wasn't arguing against that
[13:59:01] <akronymus> I mean the that people don't improve being frequent
[13:59:04] <CuriousErnestBro> piou I hope you don't have the illusion that policy is made by well informed and statistically justified arguments :')
[13:59:06] <deniska> And rust is not popular in gamedev because gamedev is a very conservative field and rust is fewer than 3 decades old :)
[13:59:11] <akronymus> I tried to elaborate on that by saying many even regress
[13:59:38] <piou> alycidyne: even important bugs like security issues. Know how many companies I've seen that have a process to communicate from the security team to the developpers in order to inform them of what security issue was found and how to avoid it in the future? At this point, one. And then people move on to other things and are replaced by new programmers that don't know anything. 
[14:00:00] <piou> alycidyne: I *want* people to get better. I just want them to get better on things that matter more than bugs that don't have any reason to be in the first place.
[14:00:03] *** Quits: gggp_ (~gggp@60.10.23.162) (Read error: Connection reset by peer)
[14:00:29] <alycidyne> piou: but that's a management problem, which is a culture problem, which, we know, is not a problem of reason
[14:00:52] <piou> It's the exact problem you are facing when you say "humans should do it"
[14:01:00] <piou> That's real life at work there.
[14:01:10] <alycidyne> piou: but because humans design the process to begin with
[14:01:23] <alycidyne> piou: or, at least, are *supposed* to design
[14:02:02] <DnzAtWrk> hehe
[14:02:21] <DnzAtWrk> I've seen some damn insecure production systems which looks like they were intended to be used in internal lans in labs
[14:02:24] <piou> alycidyne: I really don't get your point. On one hand you say "humans are able to avoid bugs, we shouldn't rely on machines to do it, just get good" and on the other one you're saying "the issue is the process that humans developped and implemented" -> are humans able to be good or not? Is it really reasonnable to wait for them to get good?
[14:02:45] <DnzAtWrk> systems which would give you direct access to a device if you just happened to be on the same network
[14:02:52] <piou> alycidyne: again, we've tried for 50 years now, it's not working. We don't have to subject ourselves to this. Just avoid the damn problem and focus on more important ones.
[14:02:53] <DnzAtWrk> and those are sold to be used wherever
[14:03:05] <piou> It's not about being lazy.
[14:03:37] <alycidyne> piou: or rather, it's that the critical people we depend on are lazy
[14:04:07] <Arahael> alycidyne: I dunno about you, but I very much appreciate not having to figure out how to iterate over an array all the time without worrying about how it's indexed.
[14:04:11] *** Joins: herjazz (~herjazz@p6758124-ipngn30801marunouchi.tokyo.ocn.ne.jp)
[14:04:11] <piou> alycidyne: maybe they are, maybe they aren't, but that's something you need to work with
[14:04:24] <Arahael> alycidyne: I _detest_ off-by-one errors.  They should rarely occur.
[14:04:37] <deniska> "people are lazy" to me sounds similar to "humans only have two hands"
[14:04:51] <deniska> yeah, they do, and if your machine requires 3 hands to operate, your machine is broken
[14:05:04] <deniska> (or requires more than a single person)
[14:05:26] <alycidyne> deniska: that's not on the same level as writing code...
[14:05:36] <deniska> alycidyne: absolutely the same
[14:05:37] <piou> alycidyne: by your own account we don't live in the idealistic world where "just get good" works. Reduce the possibility of mistakes as much as possible, take the human out of the equation where you can. Don't worry, there'll still be plenty of important bugs to be made and improvements to be gained. People can get good at things that matter instead.
[14:05:40] <deniska> it's a human-machine interaction
[14:06:04] <alycidyne> deniska: you can't ask a human to grow an extra hand, but you can ask him to learn almost any rule
[14:06:06] <akronymus> Programming languages should get out of your way to let you express your thoughts.
[14:06:12] <deniska> if you create a machine humans consistently have problems interacting with, that means the machine is poorly designed
[14:06:26] <akronymus> If it gets in your way of doing so, it is "broken"
[14:06:38] <alycidyne> deniska: that said, there is an interest in keeping rules simple, I won't deny that
[14:06:51] <deniska> alycidyne: humans are bad at learning and following rules
[14:06:56] <alycidyne> What I am against is making them *limited*
[14:07:07] <akronymus> If you have a gun that every second person shoots themselves into the foot with, it is a bad gun.
[14:07:15] <akronymus> The same can be said for programming.
[14:07:21] <alycidyne> deniska: really? with all the rules we learn about interacting with people? which are, let's face it, rules?
[14:07:27] <pyzozord> That's an interesting line of thought. On one hand I believe that mistakes are unavoidable. Bridges fall, rockets explode etc. On the other hand maybe those mistakes are because simply because we don't understand the environment well enough and in completly synthetic environment like mathematics it is possible to have "full proof". I have two questions 1) does anyone know of cases where 
[14:07:33] <pyzozord> mathematical proofs were disproved later? 2) Can a electornical computer simulate a completly synthetical environment?
[14:07:55] <alycidyne> akronymus: oh my god, the person shot themselves in the foot because they pointed it there
[14:07:58] <piou> alycidyne: humans can learn rules -> we should base our bug fighting strategy on rules -> except humans are bad at choosing and enforcing rules -> the bug strategy is not working -> rely as little as possible on human rules
[14:07:59] <akronymus> pyzozord we actually have a proof that we can't prove everything in maths.
[14:08:00] <deniska> alycidyne: these rules were created by, like, evolutionary processes of us as social animals
[14:08:19] <deniska> alycidyne: we didn't have any evolutionary pressure to get good at programming and won't have one for thousand of years
[14:08:22] <deniska> thousands*
[14:08:33] <alycidyne> deniska: that doesn't change the fact that they're rules and, thus, arbitrary
[14:08:36] <akronymus> alycidyne But every second person? At that point I CAN'T blame the people but something must be wrong with the gun.
[14:08:57] *** Joins: susepointe (~mzamenski@047-024-178-065.res.spectrum.com)
[14:08:59] <pyzozord> akronymus: well if that's true then that concludes everything. Although that begs the question, if nothing is fully provable, then how certain can be of the proof that nothing can be proved?
[14:09:15] <akronymus> I didn't say nothing is provable
[14:09:24] <akronymus> I said that we can't prove everything.
[14:09:33] <mrig> judges are arbitrary, rules are like borders on a moving substrate, that judges arbiter. 
[14:09:33] <pyzozord> sorry s/nothing/everything/
[14:09:39] <deniska> alycidyne: as arbitrary as humans having two hands really, could be 6 if very long term history was different :)
[14:09:45] <akronymus> GÃ¶dels incompleteness pyzozord
[14:09:49] <piou> alycidyne: are you saying that people always follow these rules? Because we definitely don't live in the same world in that case. IÂ see lots of people breaking the law on little things, deciding not to greet someone because they're having a bad day or are just thinking of something else, etc... Even simple social rules get broken all the time, even by people that normally follow them.
[14:10:01] <mrig> language is fluid, this is very clear.
[14:10:19] <piou> alycidyne: frankly the "we learn social rules" argument sounds designed to show that people are bad at enforcing those regularly
[14:10:23] <mrig> The use of the word arbitrary is a wonderful example of this.
[14:10:44] <akronymus> deniska I doubt it, as energy expenditure per amount of manipulation capacity would rise.
[14:10:45] <alycidyne> akronymus: I was going to ask you if you knew anything about the people buying the guns, but from what I'm know about commerce, you're not supposed to
[14:11:08] *** Joins: Yonle (~Yonle@user/yonle)
[14:11:39] <deniska> akronymus: spoyders have 8 limbs
[14:11:42] *** Joins: rsx (~dummy@ppp-188-174-141-119.dynamic.mnet-online.de)
[14:11:42] <akronymus> alycidyne I believe it is a good assumption that WELL over 50% of people that buy guns are knowledgeable/proficient enough with them to not shoot themselves into the foot with every gun.
[14:12:05] <akronymus> So, if half of the people shooting themselves in the foot with the same gun model something has to be wrong with that model.
[14:12:07] *** causative_ is now known as halberd
[14:12:08] <deniska> akronymus: they just weren't pressured into using tools :)
[14:12:16] *** halberd is now known as causative
[14:12:16] <alycidyne> akronymus: okay, is it *always* the case?
[14:12:28] <akronymus> deniska they do have 8 limbs, but don't have opposable thumbs
[14:12:42] <deniska> akronymus: Goodâ€¦ for usâ€¦
[14:12:57] <akronymus> alycidyne basically what I originally wanted to express: If half the people use the tool wrong, then the tool sucks.
[14:13:04] <alycidyne> piou: turns out only a few rules account for most of the behavior, the rest are mostly case-by-case
[14:13:07] *** Quits: chomwitt (~chomwitt@2a02:587:dc02:6400:12c3:7bff:fe6d:d374) (Ping timeout: 258 seconds)
[14:13:38] <deniska> akronymus: I'd argue that for the other half of people it's just a matter of time until they use the tool wrong
[14:13:57] <deniska> and people do work with dangerous tools
[14:13:59] <akronymus> That too.
[14:14:14] <deniska> so it's risk/benefit analysis as always
[14:14:15] <akronymus> Mining drills are dangerous, they have TONS of torque.
[14:14:22] <alycidyne> akronymus: so... there's no reason to learn it?
[14:14:27] <piou> alycidyne: then if people are only good at regularly enforcing a few rules that sounds like the best thing to do is to reduce the number of rules they have to follow to their minimum -> use the damn machine wherever possible
[14:14:39] <akronymus> But they also have safety systems that make it much harder to get into a dangerous situation
[14:15:09] <akronymus> alycidyne Not no reason. But reason to avoid it in favor of better tools.
[14:15:19] <akronymus> If possible
[14:15:49] <deniska> we may have a discussion of "we're using this dangerous tool because despite being dangerous it's useful in this certain way"
[14:15:59] <alycidyne> piou: yes, but also, don't restrict the rules just so that the machine or a procedure can be used
[14:16:12] <Arahael> alycidyne: Well, that's why we have "unsafe" in the language!!!
[14:16:27] <Arahael> We've finally come around to the original point!
[14:16:40] <piou> alycidyne: why? there's no foundation to that, you haven't given a single argument to support that
[14:16:42] *** Quits: trace987 (~trace@ip5f5a6a70.dynamic.kabel-deutschland.de) (Remote host closed the connection)
[14:16:45] <deniska> but the discussion of "even though safer tools exist, we should've learned not to put our hands in rotating bits so we could continue using dangerous tools" is a different one
[14:17:05] *** Joins: trace987 (~trace@ip5f5a6a70.dynamic.kabel-deutschland.de)
[14:17:23] <piou> alycidyne: I'm struggling to see what the issue you have with letting the machine do its work is. You've mentionned that one of your fears is that it doesn't push people to improve, but clearly there will always be things to improve on. And clearly you're not proposing that everyone writes in machine code which would give even more things to learn and more possibility of errors so it would also
[14:17:29] <piou> give the most margin for improvement by the same line of reasonning. So what's your actual issue with the idea?
[14:18:41] <akronymus> Malloc and free are useful.
[14:18:46] <piou> Do you feel that it restricts human expression maybe? Because we're writting programs that do the exact same thing with stricter languages so I would like to see in what way. Yeah, I'm really curious to get to the heart of the matter.
[14:18:51] <akronymus> Most people shoot themselves into the foot with it frequently.
[14:19:01] <akronymus> So we made better tools.
[14:19:05] <akronymus> new and delete.
[14:19:10] <akronymus> Those still had problems.
[14:19:22] <akronymus> So we made even better tools
[14:19:26] <akronymus> Like GC
[14:19:28] <alycidyne> piou: yes, I also agree that using a stricter language is good. I just think that unsafe is not the way to do it
[14:19:35] <deniska> akronymus: these are primitives of a memory allocation management system, but doesn't mean that exposing it directly to users is useful
[14:19:47] *** Joins: sunbae (~euk@user/sunbae)
[14:19:51] *** Quits: susepointe (~mzamenski@047-024-178-065.res.spectrum.com) (Ping timeout: 276 seconds)
[14:19:51] <piou> alycidyne: yes what? Sorry, but I'm struggling to understand your point
[14:20:22] <piou> alycidyne: also it seems to me that you're arguing in favour of unsafe mechanics and languages so I understand even less
[14:20:26] <alycidyne> piou: one issue I have is that unsafe introduces a second rule system to Rust - a rule system that could be simply there from the beginning
[14:20:43] <piou> Oh, the "unsafe" keyword in rust specifically, right.
[14:21:02] <Arahael> alycidyne: It does'nt add a second rule systme to rust, it merely relaxes the rules, so that you can violate them.
[14:21:40] <akronymus> deniska it can be useful, but in most cases it isn't.
[14:21:44] <piou> alycidyne: so you see no advantage to having 90% of the program checked for you and only having to carefully review the remaining 10% that are clearly labelled and easilly grepable?
[14:21:45] <alycidyne> Arahael: relaxing the rules creates a new rule system
[14:22:03] *** Quits: pulse (~pulse@user/pulse) (Ping timeout: 268 seconds)
[14:22:06] <akronymus> sometimes you need to set that specific register to something.
[14:22:17] <akronymus> For interfacing with a certain chip for example.
[14:22:36] <Arahael> akronymus: So, set unsafe, then set that register, what's the problem?
[14:22:41] <akronymus> Indeed
[14:22:48] <alycidyne> piou: if it's your code, then no, but now that you mention it, I forgot that most people don't maintain their own code, so in which case, yes, unsafe has a point there.
[14:23:07] <piou> As a code reviewer I love the idea of being able to quickly jump to the heart of where specific bugs can occur without having to carefully trace down inputs from their entry point to their exploitation point
[14:23:11] <akronymus> I was trying to express that sometimes you just need to break out of the safe environment and use a dangerous tool
[14:23:12] <alycidyne> piou: as it turns out, I also find the latter phenomenon disgusting.
[14:23:27] <mrig> Arbiter or arbitrary has a wonderful root in arbor, or tree :)
[14:24:17] <Arahael> akronymus: Yes...  hence why unsafe is there.
[14:24:29] * Arahael gives up trying to follow the conversation. :(
[14:24:32] <piou> alycidyne: if no one but the people having wrote the code should read it, how are you supposed to identify bugs in the code in the first place? Proof-reading never claims to find everything, but it pretty much always finds something for a reason
[14:24:48] <akronymus> Arahael I was arguing FOR your point.
[14:25:13] <Arahael> akronymus: Ah, good. :)  I'm very confused about alycidyne's point, though.
[14:25:32] * Arahael muses: There are too many people with nicks that start with 'a'.
[14:25:33] <alycidyne> piou: are you saying that people can't find bugs in their own code? I've already found bugs in code which I wrote before
[14:25:41] <piou> alycidyne: I'm not saying that
[14:25:54] <piou> alycidyne: I'm saying that two pairs of eyes work better
[14:25:57] <akronymus> You tend to overlook bugs in your own code.
[14:26:00] <piou> alycidyne: demonstrably better
[14:26:01] *** Joins: silasfox (~silasfox@62.159.27.1)
[14:26:06] <akronymus> Same with writing.
[14:26:52] <Booster2ooo> Hello, little regex question: https://regex101.com/r/g76XWJ/1 How can I exclude (\w*) from matching one or more specific keywords like "Excluded" ?
[14:26:53] <piou> alycidyne: and, I say that as someone that does lots of code review: you don't know what you don't know and you might not be able to know that a specific bug is possible in the code you wrote
[14:26:55] <bayaz> Title: regex101: build, test, and debug regex 
[14:27:07] *** Joins: __jmcantrell__ (~weechat@user/jmcantrell)
[14:27:07] *** Quits: jmcantrell (~weechat@user/jmcantrell) (Killed (copper.libera.chat (Nickname regained by services)))
[14:27:07] *** __jmcantrell__ is now known as jmcantrell
[14:27:36] *** Joins: chomwitt (~chomwitt@2a02:587:dc02:6400:12c3:7bff:fe6d:d374)
[14:27:49] <alycidyne> If it helps, I am of Dijkstra's view that software is a branch of mathematics... which, I now see, is contrary to the objectives of most commercial software development
[14:27:53] <piou> alycidyne: good examples of that are xxe or pretty much anything related to cryptography. As the saying goes: any imbecile can write a cryptographic system that he cannot break, but that doesn't mean the system is unbreakable.
[14:27:53] <Arahael> As someone who also does a lot of code review: It's a fools errand to even hope that by reading the code, you'll catch all the bugs. :(
[14:28:27] <piou> Arahael: I'm not arguing that code review find everything either, just that it almost always finds *something*
[14:28:36] <Arahael> piou: Right!
[14:29:20] <Booster2ooo> I guess using a negative lookahead works ... https://regex101.com/r/bQpZaA/1
[14:29:20] <alycidyne> I say this because I realize there is no hope of there being one software product which will then converge towards maximal correctness
[14:29:21] <bayaz> Title: regex101: build, test, and debug regex 
[14:29:43] <alycidyne> Which, of course, is how mathematics would do it
[14:31:05] <alycidyne> I had wanted to not add my code to the mess that is the industry, but oh well
[14:31:08] <DnzAtWrk> where are video streams normally located in linux?
[14:31:11] <DnzAtWrk> I need to create one
[14:31:23] <DnzAtWrk> from a kinect
[14:31:49] *** Joins: Mangy_Dog (~Mange@user/mangy-dog/x-7397214)
[14:32:17] *** Quits: merijn (~merijn@83-160-49-249.ip.xs4all.nl) (Ping timeout: 258 seconds)
[14:32:26] *** Joins: merijn (~merijn@83-160-49-249.ip.xs4all.nl)
[14:32:29] <GeDaMo> https://en.wikipedia.org/wiki/Video4Linux ?
[14:32:30] <bayaz> Title: Video4Linux - Wikipedia 
[14:32:31] <DnzAtWrk> ah nevermind, found a virtual webcam driver
[14:33:15] <alycidyne> And now I remember that I had admonished myself to not comment on Rust because of discussions like this. I am exhausted for nothing.
[14:35:30] <alycidyne> Right, all this happened because of my comments on people's attitudes as represented through a keyword. Ugh.
[14:35:42] <alycidyne> I regret it for both my sake and your sakes
[14:37:01] <Arahael> alycidyne: Not attitudes, we were really confused and trying to understand your point.
[14:37:29] *** Quits: elnavigator (~elnavigat@105.196.154.34) (Ping timeout: 268 seconds)
[14:37:29] *** Quits: merijn (~merijn@83-160-49-249.ip.xs4all.nl) (Ping timeout: 248 seconds)
[14:38:24] *** Joins: merijn (~merijn@83-160-49-249.ip.xs4all.nl)
[14:39:29] <pyzozord> Well then, if Godel's Incompleteness Theorm is true that would mean that this whole push for rigorious languages is pointless, isn't it? I mean it sounds like a nice research subject that can produce some nice ideas/tools that could be adopted by engineers that will be actually useful in real world but nothing beyond that
[14:40:13] <pyzozord> It kind of makes me feeel lke mathematical proof is kind of pointless too, although I don't know nowhere near enough about mathematics to put any weight on that intuition
[14:40:41] <bjs> pyzozord: why is proof pointless?
[14:40:45] <bjs> just because of incompleteness
[14:40:47] <alycidyne> pyzozord: mathematical proof is useful *to us humans*, who know how to use it
[14:41:09] <mercenary> You would have to prove that mathematical proofs are pointless. Which is pointless in itself
[14:42:03] <pyzozord> bjs: I'm not sure I'm right, but it seems like if it's incomplete you can't relay on it
[14:42:15] <bjs> pyzozord: I think you have completeness and soundness confused
[14:43:03] <bjs> pyzozord: math being incomplete doesn't mean proofs might be wrong.  It means that some things might be true (like, actually really honestly true) but you cannot write a proof.
[14:43:03] <pyzozord> yeah possibly, but isn't it all kind of relaying and dependent on each other at some point?
[14:43:08] <bjs> pyzozord: no
[14:43:12] *** Joins: elnavigator (~elnavigat@105.196.154.34)
[14:43:16] <bjs> pyzozord: well yes, but that part isn't affected by incompleteness
[14:43:21] *** Quits: jmcantrell (~weechat@user/jmcantrell) (Ping timeout: 248 seconds)
[14:43:41] <alycidyne> Arahael: well my point comes mostly from my attitude which comes from my perspective on things as a former mathematics student, so not really worth nearly crushing one's keyboard typing.
[14:44:29] <bjs> pyzozord: math is sound (if there's a proof, it's valid and correct and you can rely on it) but incomplete (some things might just not have a proof).
[14:44:57] <Arahael> alycidyne: It's my observation that mathematicians tend to write code very differently to most software developers do - and do so with different aims and priorities.
[14:45:12] <pyzozord> bjs: is it possible that the provable thing is depending on the improvable thing?
[14:45:47] <pyzozord> bjs: my point is, if you dig enough, aren't you always arriving at the improvable thing?
[14:45:47] *** Quits: davros (~davros@host86-184-180-96.range86-184.btcentralplus.com) (Remote host closed the connection)
[14:45:48] <bjs> pyzozord: no
[14:46:16] *** Quits: akronymus (~akronymus@85.31.8.181) (Ping timeout: 246 seconds)
[14:46:19] *** Quits: nicolapcweek94 (wasp@tilde.institute) (Quit: WeeChat 2.9)
[14:46:31] <bjs> pyzozord: if you dig enough you eventually reach the "axioms" of mathematics:  simple statements of fact we assume to be true.  Then a "proof" is just combining these axioms together to show that something is true.
[14:47:01] <alycidyne> Arahael: I can imagine, and given the Curry-Howard correspondance, I'd be curious to see what programs theorems would give - or what theorems most models would give
[14:48:06] *** Joins: mikeliuk (~mikeliuk@109.249.187.96)
[14:48:08] <bjs> pyzozord: math is sound, so that these proofs are valid.  But there may be statements you can make that that are true that you cannot use the axioms to prove.
[14:48:17] <alycidyne> Arahael: that said, what characteristics have you seen in 'mathematicians' code?
[14:48:18] <bjs> pyzozord: infact there's strong parallels to computing: we have the halting problem.
[14:48:48] *** Quits: merijn (~merijn@83-160-49-249.ip.xs4all.nl) (Ping timeout: 272 seconds)
[14:49:01] <Arahael> alycidyne: Mathematicians code from what I've seen have less focus on maintainability, and are much more focused on the particulars of the algorithm.  The algorithm comes first.
[14:49:17] <Arahael> alycidyne: Whereas in most software developers code, the data, or presentation, usually comes first.
[14:49:21] <Arahael> Algorithms are secondary.
[14:49:22] <bjs> pyzozord: the halting problem doesn't affect our programs in any way, it doesn't change whether any program halts or not. It's just saying that you cannot just "Look" at a program and always know whether it halts.  Incompleteness of arithmetic says the same thing,  you cannot just "Look" at a statement and know if it's true (make a proof).
[14:49:55] <bjs> But of course, some things are true and some programs really do halt
[14:49:58] *** Joins: merijn (~merijn@83-160-49-249.ip.xs4all.nl)
[14:50:08] <bjs> and occasionally the two overlap and you have a program that can halt _and_ you can prove it :)
[14:50:18] <alycidyne> Arahael: I've also noticed that in physics code
[14:50:19] <pyzozord> hehe
[14:51:11] <pyzozord> Ok, that makes me feel better about proofs.
[14:51:13] <alycidyne> My perspective is that comes from how the industry tries to implement features
[14:51:41] <bjs> pyzozord: for your interests you may want to read up on Russel's paradox.  The "old" system that mathematics used to use was actually unsound and not just incomplete.
[14:52:34] <alycidyne> Actually, I think the whole rift between mathematics and commercial software comes from this emphasis on features - in the mathematical perspective, they would be whole sub-programs (!) in their own right
[14:53:09] <pyzozord> So is there a future where programming has moved on to fully provable code? Meaning everything that can be proved is proved? Also... How much is really unprovable? It must be some insiginficant fraction, right? If more than 50% of code would be unprovable then that sounds kind of pointless
[14:53:43] <alycidyne> pyzozord: more than 50% of *today's* code, at least
[14:53:55] <bjs> pyzozord: the problem is that incompleteness/halting problem aren't a silly sideeffect of the system we happen to use.  They are very general statements about systems that are powerful "enough"
[14:54:25] *** Joins: akevinhuang (~thekevinh@user/thekevinhuang)
[14:54:58] <bjs> pyzozord: if you've ever seen a proof of either of these you'll see you don't really need *much* power in your system to get these problems.  So in general "no" we won't move onto fully provable code, but this is of course not the whole story.  There are certainly attempts that try to do "provable" code (see: Agda).
[14:55:17] *** Quits: merijn (~merijn@83-160-49-249.ip.xs4all.nl) (Ping timeout: 258 seconds)
[14:55:37] *** Quits: Pickchea (~private@user/pickchea) (Ping timeout: 248 seconds)
[14:55:43] *** Joins: merijn (~merijn@83-160-49-249.ip.xs4all.nl)
[14:55:49] <pyzozord> bjs: not sure what do you mean by powerful system
[14:55:59] <bjs> pyzozord: have you ever seen a proof of the halting problem?
[14:56:26] <pyzozord> bjs: nope
[14:56:53] <bjs> pyzozord: Go take a look,  you might be surprised by (1) how relatively simple the proof is but more importantly (2) how few assumptions the proofs make about computers
[14:57:49] *** Joins: jmcantrell (~weechat@user/jmcantrell)
[14:58:33] <pyzozord> I'm afraid I might not be qualified to read mathematical proofs yet, I have serious educational gaps, especially in mathematics. But I'll definitely take a look when I've cought up with my maths.
[14:58:46] <pyzozord> I'm planning to ready Annotated Turing, so maybe after that
[14:58:50] <bjs> pyzozord: no no,  there's basically no maths
[14:58:55] <bjs> there's no turing machines
[14:59:06] <bjs> there's no computer programs or code (at least nothing past 2-3 lines of pseudocode to give you the idea)
[15:00:35] <bjs> pyzozord: wikipedia has a nice proof sketch it looks like https://en.wikipedia.org/wiki/Halting_problem#Proof_concept
[15:00:36] <bayaz> Title: Halting problem - Wikipedia 
[15:00:47] <pyzozord> bjs: thanks, was about to ask for some link
[15:00:57] *** Quits: merijn (~merijn@83-160-49-249.ip.xs4all.nl) (Ping timeout: 248 seconds)
[15:01:05] *** Joins: akronymus (~akronymus@85.31.8.181)
[15:01:30] *** Joins: merijn (~merijn@83-160-49-249.ip.xs4all.nl)
[15:01:57] *** Joins: night_wulfe (~wulfe@cpe-174-103-156-213.cinci.res.rr.com)
[15:02:08] *** Quits: pavonia (~user@user/siracusa) (Quit: Bye!)
[15:02:29] <jinsun> bjs: so seems like just being able to loop forever is "powerful" enough system ?
[15:02:45] <bjs> jinsun: and something akin to higher-order functions.
[15:02:58] <bjs> but roughly yes
[15:02:59] *** Joins: archie (~archie@host-79-18-227-8.retail.telecomitalia.it)
[15:03:08] <archie> hello
[15:04:02] <bjs> jinsun: you need to be able to loop forever in a semantic way. e.g. a language that is otherwise just a regular language + a "loop forever" primitive is not powerful enough. because you can tell if it loops by just "looking" at the program.
[15:05:14] <archie> someone can help me with this? https://bpa.st/T4LQ
[15:05:15] <bayaz> Title: View paste T4LQ 
[15:05:15] *** Quits: night_wulfe_ (~wulfe@cpe-174-103-156-213.cinci.res.rr.com) (Ping timeout: 258 seconds)
[15:05:26] *** Joins: Twipply (~Twipply@user/twipply)
[15:05:37] <pyzozord> bjs: actually I am familiar with that proof, so I did see that before
[15:07:04] *** Quits: merijn (~merijn@83-160-49-249.ip.xs4all.nl) (Ping timeout: 268 seconds)
[15:07:13] *** Joins: merijn (~merijn@83-160-49-249.ip.xs4all.nl)
[15:08:02] <GeDaMo> archie: is the "# rules.json" in the file?
[15:08:28] <archie> GeDaMo yes, solved though https://github.com/nlohmann/json/issues/2066
[15:08:51] <archie> for some reason ifs needs full path
[15:10:18] <archie> that's still an issue though :|
[15:10:29] *** Quits: rustyshackleford (uid236774@id-236774.brockwell.irccloud.com) (Quit: Connection closed for inactivity)
[15:10:31] <archie> have to convert the path to the full path somehow
[15:10:34] <archie> :\
[15:11:29] *** Quits: Crescendo (~Crescendo@user/crescendo) (Read error: Connection reset by peer)
[15:12:29] <jinsun> bjs: okay, yes first class functions are also used, and we should be able to loop forever conditionally, so that having loop forever in the code is not enough to tell that it forever
[15:13:43] *** Joins: Crescendo (~Crescendo@user/crescendo)
[15:14:26] <bjs> jinsun: right, if the code contains `while ( true ) { ... }` and nothing to "break" the loop then you can prove it doesn't halt.  But if the language lets you go `while ( C ) { ... }` then you can only prove it halts if you prove C is true at some point
[15:14:37] <alycidyne> How does one work in an industry which one wants to destroy?
[15:14:55] *** Quits: user51 (~user51@176.228.90.248) (Remote host closed the connection)
[15:15:19] <archie> alycidyne money
[15:15:50] <alycidyne> ?
[15:16:23] <alycidyne> I meant how are you supposed to resist yourself
[15:16:56] <mrig> alycidyne: work at your profession and with that construct something that is conducive to the future that you wish to live in.
[15:17:05] <archie> alycidyne focus on money
[15:17:42] <mrig> profession != job
[15:18:01] *** Quits: merijn (~merijn@83-160-49-249.ip.xs4all.nl) (Ping timeout: 248 seconds)
[15:18:08] *** Quits: Rashad (~textual@46.185.170.67) (Read error: Connection reset by peer)
[15:18:31] *** Joins: merijn (~merijn@83-160-49-249.ip.xs4all.nl)
[15:19:05] <bjs> jinsun: I'd like to be able to give you a concrete definition of what "powerful enough" machine is, but as you may know (Church-Turing e.g.) we don't even have a good concrete definition of what a machine is (we know a Turing Machine is probably one kind of machine,  but we cannot even prove that...)
[15:19:20] *** Quits: archie (~archie@host-79-18-227-8.retail.telecomitalia.it) (Quit: Client closed)
[15:19:23] <alycidyne> mrig: okay, so I should basically create a community of logician-ontologist-programmers?
[15:19:48] <mrig> my ideal would be to aim to cultivate a field that you are proud to pass on to the next generation.
[15:20:05] <mrig> anything else is frivolous.
[15:20:36] <alycidyne> And develop eternally valid APIs so that programs in them would be valid for as long as the laws of information hold
[15:21:07] <mrig> stability of API's would be a great thing
[15:21:12] <alycidyne> And make any innovation useless
[15:21:23] <mrig> I think that understanding the underlying process is important.
[15:21:38] <alycidyne> mrig: that's the whole point
[15:22:21] *** Joins: Pickchea (~private@user/pickchea)
[15:23:04] <mrig> innovation is a counter to entropy, that will never be obsolete.
[15:23:24] <mrig> but how you want that entropy to behave is another matter altogether.
[15:23:30] *** Joins: Guest41 (~Guest41@195.59.168.126)
[15:24:06] *** Parts: Guest41 (~Guest41@195.59.168.126) ()
[15:24:42] *** Quits: swinnenb (~swinnenb@user/swinnenb) (Quit: This is the hidden truth, the world between the lines.)
[15:25:09] <alycidyne> mrig: ah yes, we must distinguish innovation from reinvention/reimplementation.
[15:26:41] *** Joins: password (~password@user/password2)
[15:26:49] <mrig> I think that this is achieved by drawing out the cycles and passing on knowledge to future generations in a lucid way.
[15:27:21] <mrig> not by endless mindless expansion, which leads to cavitation.
[15:29:17] *** Quits: merijn (~merijn@83-160-49-249.ip.xs4all.nl) (Ping timeout: 268 seconds)
[15:30:09] <alycidyne> mrig: the problem is, nature is based on expansion
[15:30:15] *** Quits: exvicesindaco (~exvicio@host-87-17-228-139.retail.telecomitalia.it) (Quit: Going offline, see ya! (www.adiirc.com))
[15:30:20] *** Joins: merijn (~merijn@83-160-49-249.ip.xs4all.nl)
[15:30:26] <mrig> That is a pretty limited view, to my mind.
[15:30:38] <mrig> it is based upon cyclic rhythms.
[15:30:57] <alycidyne> mrig: sorry, I meant biology (which constitutes our most basal thinking)
[15:30:58] <mrig> economics uses this as its first principle.
[15:31:13] <mobidrop> evolution is a divergent process, always creating new species to fill new niches
[15:31:38] <mrig> mobidrop: that is half of the story or picture, I think.
[15:31:48] <alycidyne> mobidrop: thank you, I couldn't have said it better
[15:32:20] <alycidyne> That, IMO, is evolution's response to not finding the global maximum
[15:32:31] <alycidyne> -_-
[15:33:33] <mobidrop> mrig, yes there's more to nature than just the material side IMO
[15:33:50] <GeDaMo> https://www.quantamagazine.org/a-new-thermodynamics-theory-of-the-origin-of-life-20140122
[15:34:25] <merijn> mobidrop: Hah
[15:34:38] <merijn> mobidrop: If evolution is divergent, explain why it keeps wanting to make crabs :p
[15:34:52] <merijn> mobidrop: https://en.wikipedia.org/wiki/Carcinisation
[15:34:53] <bayaz> Title: Carcinisation - Wikipedia 
[15:35:29] <akronymus> Go back to monke or forward to crabbo
[15:35:35] <mobidrop> merijn, it made everything else, just a little error I guess :)
[15:35:42] <akronymus> Your choice
[15:35:42] <merijn> mobidrop: 5 times? :p
[15:35:46] <mobidrop> merijn, really cool though, seems like crabs are inherently efficient somehow
[15:35:59] *** Joins: gitgoood (~gitgood@80-44-15-108.dynamic.dsl.as9105.com)
[15:36:04] <mobidrop> merijn, well it also had to evolve sight 3 different times, I guess important things will occur
[15:36:40] <mrig> heh, awesome example :D
[15:36:55] <akronymus> Eyes evolved independently so many times.
[15:37:00] <alycidyne> merijn: that actually made me lol
[15:37:26] <alycidyne> I will always say, the human body is a miracle of nature and a disaster of engineering.
[15:37:36] <merijn> There's many other cases of convergent evolution, btw
[15:37:47] *** Joins: interop_madness (~interop_m@user/interop-madness/x-0950004)
[15:37:58] *** Joins: swinnenb (~swinnenb@user/swinnenb)
[15:37:59] <mrig> GeDaMo: I pointed this notion out about life to a physicist 25 years ago, He then insulted me. :|
[15:38:05] <merijn> It's really less of a "divergent" process and more of an iterative/fix point optimisation process
[15:39:04] <mobidrop> we like to think of evolution as an optimization algorithm or a search algorithm, but really it's just trying to live
[15:39:11] <mobidrop> the only requirement is: don't die, and reproduce
[15:39:41] <alycidyne> mobidrop: evolution operates on characteristics, not on individuals, that's why we consider it an algorithm
[15:39:50] <alycidyne> mobidrop: trying to live is for mere individuals
[15:40:04] <mobidrop> it's not searching or optimizing for some supreme being
[15:40:11] *** Quits: jmcantrell (~weechat@user/jmcantrell) (Quit: WeeChat 3.2)
[15:40:30] <alycidyne> mobidrop: it's about the supreme being *for a given environment*
[15:40:51] <akronymus> mobidrop "don't die" is optional
[15:41:04] <mrig> mobidrop: are you certain that this is the only requirement and raison d'etre, if so upon what logic are you basing this not inconsequential assumption?
[15:41:22] <alycidyne> Trying to consider characteristics outside of their environment is an exercise in futility
[15:41:29] <merijn> mobidrop: It *is* an optimisation algorithm
[15:41:33] <mobidrop> akronymus, don't die comes before the reproduce part (in most cases)
[15:41:35] <mrig> It could be to stave off entropy for your future generations as an example.
[15:41:43] <merijn> mobidrop: That's optimising for "continuing to exist"
[15:42:07] <akronymus> Actually: The only thing that matters is ensuing the continuation of the existance of the DNA.
[15:42:24] <akronymus> And even that is incidental
[15:42:25] <mobidrop> merijn, yes exactly, the determining factor is the floor, not the ceiling in evolution
[15:42:31] <merijn> There's interesting research that links self-sacrifice to genetical similarity
[15:42:40] <akronymus> There is no reason for anything.
[15:42:56] <mrig> reason means measure, you get that right?
[15:42:57] <akronymus> It is just that the stuff that reproduces itself becomes more common
[15:42:59] <merijn> See also Dawkin's book on "The Selfish Gene"
[15:43:08] <merijn> akronymus: Not just
[15:43:11] <mrig> At its core it means to measure.
[15:43:13] <merijn> there's a meta-level too
[15:43:21] <alycidyne> I actually think that self-awareness is the ultimate rebellion against nature :D
[15:43:30] <alycidyne> Or even decision making
[15:43:34] <alycidyne> decido ergo sum
[15:43:38] <merijn> Because it's not just "genes within a species" but also "competition between groups of the same species"
[15:43:53] <mrig> alycidyne: I would agree that consciousness is a force that pushes in the opposite direction to nature.
[15:44:03] <mrig> Like to think of it that way.
[15:44:07] <akronymus> merijn I mean, it started with replicating of molecules in close proximity and the additional complexity allowed more effective reproduction and so on.
[15:44:09] <merijn> Vengefulness has little useful impact on individual survival, but clear impact on group survival
[15:44:20] <akronymus> Competition is incidental
[15:44:30] <mobidrop> mrig, well at least beings with the intelligence to override instinct, we can rebel against nature but animals can't
[15:44:35] <alycidyne> mrig: perhaps hence why I am so obsessed with people knowing what they are doing...
[15:44:44] <akronymus> Non-competitive genes just didn't survive.
[15:45:00] <akronymus> There is no other reason why competition is a thing.
[15:45:25] <alycidyne> akronymus: AFAIK competition comes from scarcity
[15:45:51] <akronymus> Yes.
[15:46:01] <akronymus> But only because non-competing ones died out
[15:46:08] <alycidyne> more precisely, as one arbiter for the distribution of scarce resources
[15:46:08] <akronymus> Hence incidental
[15:46:09] <mrig> mobidrop: yes exactly.
[15:46:17] *** Quits: Crescendo (~Crescendo@user/crescendo) (Ping timeout: 248 seconds)
[15:46:19] <akronymus> There is no meaning behind life
[15:46:21] <mrig> does differentiate us from other animals.
[15:46:26] <alycidyne> the other being cooperation. The problem is, cooperation requires communication
[15:46:39] <mrig> akronymus: sure they did.
[15:46:49] *** Joins: Crescendo (~Crescendo@user/crescendo)
[15:46:53] <mrig> akronymus: non competitive people make better archers :P
[15:47:04] <mobidrop> merijn, exactly it's about group survivor or gene survival, otherwise it wouldn't make sense that some species create 1000 offspring only for 99% of them to die before reproducing
[15:47:22] <mrig> they are also better at maintain stable food sources.
[15:47:27] <akronymus> Why are non competitive people better at building arches? mrig
[15:47:36] <mrig> such as animal populations that are a food source.
[15:47:46] <mobidrop> my pet peeve with evolution is that when people see it as an optimization algorithm they think it's going somewhere to create the best organism
[15:48:02] <mobidrop> but it's really just optimizing for continuation of the species
[15:48:04] <mrig> akronymus: not in such a hurry perhaps, are doing it for other reasons.
[15:48:06] *** Joins: TheAceOfHearts (~TheAceOfH@24.41.239.76)
[15:48:09] <merijn> mobidrop: The problem thinking there is "one" evolution
[15:48:22] <merijn> mobidrop: It's an algorithm running independently many times in parallel :p
[15:48:27] <akronymus> mobidrop yeah, all that is happening is that the best one at keeping the genetic code "alive" "wins"
[15:48:39] <mrig> alycidyne: I like it when people know themselves and their own limits well.
[15:48:40] <mobidrop> merijn, haha yes, it's not one thing, just as the human mind isn't one single object
[15:48:54] <akronymus> And even that is by incidence rather than any goal
[15:49:12] <alycidyne> mrig: and also why I dread so much my entry into the software job market
[15:49:28] <merijn> Entirely different topic: Is there a unicode n-dash?
[15:49:43] *** Joins: juliaEnv (~mathAndRh@ip-86-49-241-245.net.upcbroadband.cz)
[15:50:14] *** Quits: amigojapan (uid86330@id-86330.brockwell.irccloud.com) (Quit: Connection closed for inactivity)
[15:50:43] <mrig> akronymus: Suppose life is a punishment, it would not require a meaning if it is an effect :)
[15:50:50] <GeDaMo> U+2013 â€“
[15:50:59] <alycidyne> merijn: ^
[15:51:33] <merijn> Cool, can't have wrong typography in my dataset ;)
[15:51:34] <mrig> alycidyne: perhaps you could find a way to target some ulterior goal, rather than focusing on the immediate?
[15:51:56] <GeDaMo> It's listed as en dash
[15:51:57] <akronymus> mrig evolution can't target anything besides the immediate
[15:52:04] <akronymus> It is purely reactive
[15:52:15] <pyzozord> I'm reading about leader algorithm now https://codility.com/media/train/6-Leader.pdf. I have a question about the O(n). The O(n) method uses observation that when removing two different elements from the array, the leader is still there in the reduced array. So it uses a stack to keep finding and "removing" different elements to select candidate for the leader. I'm not sure but isn't it essentially 
[15:52:21] <pyzozord> just checking if there are two consecutive numbers? 
[15:55:00] <piou> mrig: reminds me of https://www.smbc-comics.com/comics/1620834595-20210512.png
[15:55:00] <bayaz> Type: image/png Size: 722.3 kB 
[15:55:27] <DPA> akronymus: evolution is proactive. There must have been a valid mutation ahead of time, or it'll die out. The proactive measure is random change, sometimes for the better, most of the time, not.
[15:55:52] *** Joins: mci64 (~mci64@194.25.223.4)
[15:56:34] *** Joins: amigojapan (uid86330@id-86330.brockwell.irccloud.com)
[15:57:02] *** Quits: elnavigator (~elnavigat@105.196.154.34) (Ping timeout: 268 seconds)
[15:57:05] *** Joins: pulse (~pulse@user/pulse)
[15:57:12] <mrig> piou: heh, good cop bad cop :D
[15:58:51] <merijn> pyzozord: It's more of a math trick
[15:59:04] <merijn> pyzozord: Consider this
[15:59:32] <merijn> pyzozord: 1) The leader is *more* than 50% of the array (by definition)
[16:00:08] <merijn> pyzozord: 2) removing two *different* elements either removes 2 non-leader elements *or* 1 leader element and 1 non-leader
[16:00:44] <merijn> Since more than 50% is the leader and we decrease the leader and non-leader fractions equally, the leader of the subsequence doesn't change
[16:01:21] *** Joins: Leone (~Leo@45.72.231.86)
[16:01:25] <merijn> So the percentage of leader values either stays constant or increases as we shrink the array
[16:01:54] <merijn> And when we're done, we know the entire resulting array all equal values are grouped
[16:02:15] <merijn> So you are in the same situation as after sorting (and can do a linear count)
[16:02:49] <merijn> So it's basically the same as the "sort first, then linear sum" algorithm, except you don't bother eating the "n log n" cost of sorting, because you don't care about the sort
[16:03:31] *** Quits: Fluxx (~Fluxx@user/fluxx) (Ping timeout: 258 seconds)
[16:03:53] *** Quits: gitgoood (~gitgood@80-44-15-108.dynamic.dsl.as9105.com) (Ping timeout: 248 seconds)
[16:04:19] *** Quits: Atque (~Atque@user/atque) (Quit: ...)
[16:06:01] *** Quits: v0id_ptr (~longlong@user/ptr-frac7al/x-0038398) (Ping timeout: 248 seconds)
[16:06:42] *** Quits: scabootssca_ (~scabby@user/scabootssca) (Ping timeout: 272 seconds)
[16:07:30] <pyzozord> merijn: got it, thanks. I'm wondering if this stack thing isn't essentially just checking "are two things next to each other? if yes, that's your leader candidate"
[16:13:03] *** Quits: Pickchea (~private@user/pickchea) (Ping timeout: 268 seconds)
[16:14:04] *** Quits: mikeliuk (~mikeliuk@109.249.187.96) (Quit: Connection closed)
[16:14:29] *** Joins: cthulchu (~Cthulchu@193.194.107.250)
[16:17:11] *** Quits: Leone (~Leo@45.72.231.86) ()
[16:19:15] *** Quits: DasBrain (~DasBrain@user/dasbrain) (Killed (NickServ (GHOST command used by DasBrain_)))
[16:19:22] *** Joins: DasBrain_ (~DasBrain@user/dasbrain)
[16:20:58] *** Quits: chomwitt (~chomwitt@2a02:587:dc02:6400:12c3:7bff:fe6d:d374) (Ping timeout: 240 seconds)
[16:21:23] *** Joins: JimmyRustles (Haddock@cpc119394-smal16-2-0-cust17.19-1.cable.virginm.net)
[16:22:02] *** DasBrain_ is now known as DasBrain
[16:22:52] *** Quits: sunbae (~euk@user/sunbae) (Quit: leaving)
[16:24:32] <pyzozord> meaning: maybe that stack is not needed and I can just do linear scan with a 1 element lookahead?
[16:24:48] <merijn> You can't
[16:25:08] <merijn> because what if you start with 6,6,4,6,4,4,4 or whatever
[16:25:44] <merijn> pyzozord: basically, push 6, push 6 (not different), grab the 4, then pop 1 6 (removing one 6 and one 4)
[16:25:46] *** Joins: user51 (~user51@176.228.90.248)
[16:26:31] <merijn> pyzozord: you need a stack to track elements in a row that are similar, afaict
[16:27:58] <pyzozord> ok, thanks
[16:28:12] *** Joins: elnavigator (~elnavigat@105.196.154.34)
[16:28:35] <merijn> pyzozord: Because you can only throw away pairs of different elements (not identical ones)
[16:28:54] <merijn> pyzozord: But in the example code they don't bother with an actual stack, since all elements on the stack will ever be the same value
[16:29:02] <merijn> (if you get a different one, you just pop)
[16:29:10] <merijn> so you can replace the stack with a counter
[16:30:23] <merijn> So you only need to store "the value currently on the stack" and a counter of how many
[16:30:37] *** Joins: rtypo (~alex@user/rtypo)
[16:30:51] <pyzozord> mrig: in that case, couldn't I solve it with two pointer as well? I mean i starts at 0, j starts at 1, if A[i] != A[j] then i++, j++ else j++?
[16:31:07] <pyzozord> merijn: ^
[16:31:15] <merijn> No, because i++ doesn't make sense
[16:31:18] *** Joins: Pickchea (~private@user/pickchea)
[16:32:00] <merijn> Consider: 6,6,3,4,6,4,4,4
[16:32:07] <merijn> At no point should the stack contain 3
[16:32:14] <merijn> But in your pointer increment example, it will
[16:33:10] <merijn> The stack of the algorithm goes: {} -> {6} -> {6,6} -> {6} -> {} -> {6} -> {} -> {4} -> {4,4}
[16:33:47] <merijn> The more I think about it, the more elegant I think the algorithm is :)
[16:34:06] *** Joins: scabby (~scabby@user/scabootssca)
[16:34:11] <pyzozord> (this is me doing exploratory learning on top of a guided learning, so please bare with me)
[16:36:27] <pyzozord> merijn: I meant something like this https://ideone.com/5U6NQA
[16:36:29] *** Quits: Pickchea (~private@user/pickchea) (Ping timeout: 268 seconds)
[16:36:30] <bayaz> Title: Ideone.com 
[16:36:41] *** Joins: gitgoood (~gitgood@80-44-15-108.dynamic.dsl.as9105.com)
[16:36:50] <merijn> How does I make that jump?
[16:36:55] *** Quits: gitgoood (~gitgood@80-44-15-108.dynamic.dsl.as9105.com) (Read error: Connection reset by peer)
[16:37:09] <pyzozord> merijn: in which line? (just to avoid confusion)
[16:37:14] <user51> pyzozord: whats the problem? (i just logged in)
[16:37:18] <user51> power failure..
[16:37:19] <merijn> line 4
[16:37:46] <pyzozord> user51: just exploring the third algorithm from here https://codility.com/media/train/6-Leader.pdf
[16:37:47] <bayaz> Type: application/pdf Size: 132.3 kB 
[16:38:01] <merijn> user51: Determine the leader of a sequence of length N (where the leader is the element with more than N/2 values) in linear time
[16:38:32] <pyzozord> merijn: jumps because A[i] != A[j] this kind of simulates removing two different elements from the array
[16:38:56] <merijn> pyzozord: Yeah, but how do you implement that?
[16:39:14] <merijn> Your original pointe rlogic doesn't do that
[16:39:45] <pyzozord> merijn: yeah I know i realized that the original example was too simplistic
[16:40:14] <pyzozord> I just started this code problem which litearlly asks to implement a leader algorithm https://app.codility.com/programmers/lessons/8-leader/dominator/ so I'll try that method with two pointers and paste the code here
[16:40:15] <bayaz> Title: Dominator coding task - Learn to Code - Codility 
[16:40:22] <user51> uh
[16:40:35] <user51> is there any time an alogirthm like this be useful?
[16:40:48] <pyzozord> user51: when you trayna get a job :D
[16:40:54] <merijn> user51: When N is very big?
[16:41:10] <pyzozord> merijn: I know it's kind of pointless exercise but I'm trying to fit this idea in my head and it just seems simpler to me without a stack
[16:41:22] <pyzozord> (if I can figure out a version without a stack)
[16:41:50] *** Joins: exvicesindaco (~exvicio@user/exvicesindaco)
[16:43:18] <user51> it says the sequence has only one leader, so it means that only one number will have more than n/2 occourances, right?
[16:43:33] <merijn> By definition, yes
[16:43:36] <pyzozord> user51: right
[16:43:46] <merijn> You cannot have 2 values with more than n/2 occurrences
[16:44:01] <merijn> Because then your sequence wouldn't be length n
[16:44:36] <user51> i suppose you could be done without processing all of them too
[16:44:51] <merijn> I don't see how, tbh
[16:45:36] <user51> but honestly, fuck all this o notation crap. the simpliest solution would be to iterate and increment an array whose index is the element you're currently at
[16:46:00] <merijn> user51: How does that work if your elements are, say, uint64_t values?
[16:46:15] <merijn> user51: You're just gonna allocate a 2^64 element array? :p
[16:46:20] <user51> associative array, binary tree?
[16:46:46] <merijn> user51: That's far less efficient then O(n), though
[16:46:59] <merijn> The binary tree is basically the O(n log n) sorting based version
[16:47:12] *** Quits: nekodesu (~nano@user/nekobit) (Quit: free(neko);)
[16:47:35] *** Quits: Yonle (~Yonle@user/yonle) (Read error: Connection reset by peer)
[16:47:39] <merijn> "simplest" solutions are nice, right up until the point where you have so much data they don't work
[16:47:39] *** Quits: sebbu (~sebbu@user/sebbu) (Read error: Connection reset by peer)
[16:48:11] *** Joins: v0id_ptr (~longlong@user/ptr-frac7al/x-0038398)
[16:48:22] <alycidyne> Continuing on dependent types, I'm wondering -- don't range types count as dependent types too?
[16:48:29] <alycidyne> e.g. 0..15
[16:48:36] <merijn> It depends
[16:48:47] <merijn> I mean 0..15 in most languages is just a value, not a type
[16:48:55] <alycidyne> merijn: ah
[16:49:09] <edgar-rft> what's if the length of my sequence has changed while I was searching for the occurrences of n?
[16:49:35] <merijn> alycidyne: A dependently typed range would mean that that, say, 0..10 and 0..15 have different types
[16:49:35] <alycidyne> I thought of this because I wondered about making arrays depend not on values, but on ranges
[16:49:49] *** Joins: dr_bot (~dr_bot@cpe-24-209-62-187.neo.res.rr.com)
[16:49:59] <alycidyne> e.g. n4[n1] == an array of ints indexed by a byte
[16:50:03] <merijn> edgar-rft: Then you have a different problem :p
[16:50:31] <merijn> alycidyne: You could have first-class arrays with indices without dependent types, tbh
[16:50:52] *** Joins: Yonle (~Yonle@user/yonle)
[16:50:55] <edgar-rft> let's differentiate all our problems
[16:50:58] <merijn> alycidyne: In our compiler course one of the (optional) extension is to implement array types in our C based language
[16:51:04] *** Joins: tlaxkit (~hexchat@170.253.40.255)
[16:51:05] <user51> merijn: it doesn't mention space complexity, though
[16:51:18] <alycidyne> merijn: ... how (the first one you mentioned)?
[16:51:20] <merijn> user51: I'm not talking about space, time
[16:51:55] <merijn> alycidyne: Syntax like "int[k] vectorMultiply(int[m] foo, int [n] bar);"
[16:52:13] <merijn> alycidyne: here 'm' and 'n' are variables inside the function body, but cannot be passed by the user
[16:52:21] <merijn> alycidyne: Instead, the compiler passes them automatically
[16:52:41] <alycidyne> merijn: yeah, I'm seeing that idea constantly coming up, but I don't see how those aren't dependent types
[16:52:58] <merijn> alycidyne: So if I do "int[5] test = {0,1,2,3,4};" and call "vectorMultiply(test, test)" then the compiler will pass 'm' and 'n' as 5
[16:52:59] <edgar-rft> in atomic operations we also have to deal with Heisenberg uncertainty
[16:53:02] *** Joins: sebbu (~sebbu@user/sebbu)
[16:53:30] *** Joins: qwedfg (~qwedfg@user/qwedfg)
[16:53:34] *** Quits: v0id_ptr (~longlong@user/ptr-frac7al/x-0038398) (Ping timeout: 272 seconds)
[16:53:56] <merijn> alycidyne: dependent types would be more like being able to do: "int[n+m] vectorAppend(int[m] foo, int[n] bar)"
[16:54:11] <alycidyne> merijn: hm
[16:54:16] <merijn> alycidyne: Where the size of the result vector *explicitly* uses the sizes of n and m
[16:54:28] <merijn> alycidyne: But that means you need to be able to do actual computation on types at compile time
[16:55:22] <merijn> alycidyne: You might also wanna look up the famous "lambda cube" paper, which describes 3 ways to extend the (typed) lambda calculus and the differences between "types depending on types", "types depending on values" and "values depending on types"
[16:55:53] <merijn> alycidyne: "dependent types" is short hand for the middle "types depending on values"
[16:55:54] <akronymus> Welp, managed to eff up the develop branch at work.
[16:56:05] <akronymus> At least it should be fixed now
[16:56:21] <alycidyne> merijn: I already looked that up
[16:56:23] *** Joins: Joanna (uid57472@id-57472.tooting.irccloud.com)
[16:57:02] *** Joins: bytecrawler (~bytecrawl@gateway/tor-sasl/bytecrawler)
[16:57:06] <alycidyne> I'm more wondering -- even without "int[n+m]", I could do that in the function body (for the actual array allocation) without relying on dependent types, or not?
[16:57:40] *** Quits: BrianG61UK (~BrianG61U@2a02:8010:66b7:dddd:3d8b:fd76:a0eb:7165) (Read error: Connection reset by peer)
[16:57:47] <akronymus> int[n+m] seems wrong to me.
[16:58:07] <akronymus> Oh wait, thats for appending 
[16:58:09] <akronymus> nvm
[16:58:15] <akronymus> Thought it was for multi dim
[17:01:01] <alycidyne> merijn: and about the compiler passing `k` from `int[k]`, it makes my heart sink that glibc internally stores the length of each array - basically, the programmer can't know the length of his own arrays, but the compiler can? :-(
[17:01:29] <alycidyne> or, even worse, the runtime?
[17:01:47] *** Quits: jmft2 (~JMFT@81.149.115.87.dyn.plus.net) (Ping timeout: 268 seconds)
[17:01:49] <merijn> alycidyne: Why can't you know the length?
[17:02:24] <alycidyne> merijn: well, when passing arrays to functions
[17:02:25] <merijn> alycidyne: "foo(int[n] array)" becomes similar to "foo(size_t n, int* array)"
[17:02:26] <pyzozord> merijn: got 93% for this algorithm https://ideone.com/SdYX8z, it got one answer incorrect
[17:02:36] <user51> merijn: any reason you couldn't do a recursive solution?
[17:02:39] <merijn> alycidyne: Except programmers can fuck up and pass the wrong size around
[17:03:06] <merijn> user51: The stack based solution for that problem works fine as O(n) solution?
[17:03:49] <merijn> alycidyne: When you pass an array to a function, the size argument is usable as (const) variable inside the function body
[17:04:22] <alycidyne> merijn: yes, I know that already, I guessed how "foo(int[n] array)
[17:04:27] <alycidyne> " works
[17:04:44] <merijn> alycidyne: But then the programmer *does* know the size of the array?
[17:05:03] <akronymus> alycidyne malloc and free actually write the length into memory too.
[17:05:05] <alycidyne> merijn: yes, in *your* extension, but not in regular C
[17:05:11] <akronymus> Well, malloc does.
[17:05:22] <akronymus> Free reads it
[17:05:36] <alycidyne> akronymus: even worse! :-(
[17:05:41] <merijn> alycidyne: eh
[17:05:48] <merijn> alycidyne: How did you think malloc/free worked?
[17:05:56] <merijn> How would you know the size of the freed thing?!
[17:06:03] <akronymus> pyzozord whats the task?
[17:06:32] <pyzozord> akronymus: https://app.codility.com/programmers/lessons/8-leader/dominator/
[17:06:34] <bayaz> Title: Dominator coding task - Learn to Code - Codility 
[17:06:36] <merijn> alycidyne: Should we change free to be "void free(void *ptr, size_t allocation_size)"?
[17:06:43] <merijn> alycidyne: Would that make it better?
[17:07:13] <beaky> fat pointers all along
[17:07:51] <akronymus> Does sizeof(pointer)/sizeof(pointer[0]) work?
[17:07:53] *** Quits: scabby (~scabby@user/scabootssca) (Ping timeout: 248 seconds)
[17:07:54] <alycidyne> merijn: I... actually didn't think about -- when I thought of an idea for a replacement for 'malloc/free' I thought of a 'void setbuf(void **p, size_t s);` which would free if `s` were 0
[17:07:58] <akronymus> For element count
[17:07:59] <merijn> akronymus: No
[17:08:03] <akronymus> F
[17:08:10] <merijn> akronymus: That only works on arrays
[17:08:11] <akronymus> Guess it gets the size of the pointer itself
[17:08:16] <merijn> akronymus: Yes
[17:08:31] <akronymus> Oh I was thinking arrays actually.
[17:08:38] <merijn> For arrays it does work
[17:08:59] <alycidyne> To be frank, dynamic memory allocation is being a huge conceptual pain in the ass
[17:09:01] <akronymus> Sizeof(pointer) returns the size of the malloc'd memory?
[17:09:11] <merijn> "int foo[10]; size_t size = sizeof foo / sizeof foo[0];" works
[17:09:21] <merijn> akronymus: You can't malloc arrays in C
[17:09:28] <akronymus> I meant in general.
[17:09:44] <bjs> akronymus: in general sizeof(pointer) returns the sizeof a pointer value
[17:09:45] <merijn> akronymus: sizeof pointer returns the size of the pointer (malloc'ed or not)
[17:09:48] <akronymus> If you have a pointer you got from malloc, can you use sizeof to get the size of the allocated memory?
[17:09:54] <merijn> akronymus: No
[17:09:56] <akronymus> Ok
[17:10:09] <akronymus> So, there is no way to retrieve that information?
[17:10:13] <akronymus> By the programmer?
[17:10:15] <merijn> akronymus: There are malloc implementation that don't store sizes at all
[17:10:17] <alycidyne> merijn: and that is what I find ludicrous about C
[17:10:20] <merijn> bucket allocators mostly
[17:10:25] <akronymus> Oh got it.
[17:10:31] *** Joins: CoderGuy (~CoderGuy@user/coderguy)
[17:10:39] <akronymus> So that's why you need to save what malloc returns.
[17:10:40] <bjs> akronymus: well the programmer *tells* malloc how big it needs to be
[17:10:41] <alycidyne> merijn: actually I thought all allocators worked that way, even under Windows
[17:10:50] <merijn> alycidyne: What way?
[17:10:53] <bjs> akronymus: and malloc gives you a pointer to a free region at least that big.
[17:10:55] <akronymus> Oh yeah.
[17:10:57] <alycidyne> merijn: bucket allocators as you said
[17:11:04] <akronymus> I had that the wrong way around
[17:11:06] <CoderGuy> is it better to have an option Label.setEditable();  or to have an entirely seperate class EditableLabel? Designed to just be editable
[17:11:53] <akronymus> > https://app.codility.com/programmers/lessons/8-leader/dominator/
[17:11:55] <bayaz> Title: Dominator coding task - Learn to Code - Codility 
[17:12:00] <akronymus> No f# option. >:(
[17:12:12] <beaky> yes no rust or haskell option either unfortunately
[17:12:16] <beaky> but there is scala at least
[17:12:54] *** Quits: smallville7123 (~smallvill@cpe-172-193-72-46.qld.foxtel.net.au) (Ping timeout: 258 seconds)
[17:13:28] <beaky> i used to hate scala because of how long it took to compile stuff on my intel atom netbook but then ive come around and now love scala because of how high level it is compared to most other jvm based programming languages even compared to clojure which is not statically typed but insists on unityping being the most simple thing ever when in fact unityping 'complects' values that could be made
[17:13:30] <beaky> simplex if only they were distinct types
[17:14:05] <beaky> but rich hickey says type systems complect values with their type
[17:14:27] <beaky> so type systems are a dead end in programming language design according to him
[17:15:23] <alycidyne> merijn: still, would `int[n+m]` be possible in a function body (i.e. as a declaration) without needing dependent types?
[17:15:55] *** Joins: scabby (~scabby@user/scabootssca)
[17:16:02] <merijn> As declaration? Sure. As result type I don't think so
[17:16:14] <akronymus> beaky I like not having to check all the time if something is a number or string or something else.
[17:16:38] <alycidyne> merijn: right, because that then could really save not just my bacon, but my whole programming language
[17:16:43] <pikapika> akronymus, hi uwu
[17:16:43] <merijn> akronymus: You just have to wait for beaky to watch a pro-type systems talk to change his opinion :p
[17:16:47] <akronymus> No
[17:16:48] <akronymus> no
[17:16:50] <akronymus> no
[17:16:52] <akronymus> nononononono
[17:17:00] *** Parts: akronymus (~akronymus@85.31.8.181) ()
[17:17:04] <pikapika> What
[17:17:07] <beaky> yes i just need to watch more philip wadler
[17:17:19] <alycidyne> pikapika: I think you scared him off >_>
[17:17:29] <pikapika> Why
[17:17:38] *** Joins: wedr (~wedr@pool-108-20-128-8.bstnma.fios.verizon.net)
[17:17:39] <InPhase> alycidyne: Are you really fixated on old-style C?  Because these problems are greatly improved in C++.
[17:17:40] <beaky> im just anti type systems because a few comments on hackernews says type systems are just academic uselessness and rich hickey says so too with his Maybe Not talk
[17:17:42] *** Joins: chomwitt (~chomwitt@ppp-2-85-147-24.home.otenet.gr)
[17:17:45] <pyzozord> merijn: yeah I got the two pointer solution to work 100%, I had a OBOE error, https://ideone.com/W5X3Ch. SO I guess the answer is, no stack needed after all
[17:17:56] <pyzozord> s/SO/So/
[17:18:20] <beaky> nice now prove the two-pointer solution correct
[17:18:58] *** Quits: scabby (~scabby@user/scabootssca) (Remote host closed the connection)
[17:19:07] <beaky> not using dependent types since dependent types are complex according to leslie lamport and ron pressler
[17:19:13] <alycidyne> InPhase: yes, because I don't want to deal with inheritance and OOP
[17:19:16] <pyzozord> beaky: here, https://imgur.com/a/snJx2ju, solid proof :D
[17:19:22] *** Joins: scabby (~scabby@user/scabootssca)
[17:19:24] *** Joins: akronymus (~akronymus@85.31.8.181)
[17:19:35] <beaky> nice that wokrs
[17:19:39] <bjs> alycidyne: C is weird,  but you can always tag every array with their size.  C doesn't do this automatically but you can obviously make one yourself
[17:20:00] *** Joins: speckz (~speckz@2600:1700:ce0:bf00:893d:bb35:4f4d:5fa5)
[17:20:13] <pikapika> bjs, redis does htat for strings
[17:20:17] <alycidyne> bjs: I know, but this is one rare thing I would like in the language
[17:20:20] <beaky> yes it is why i use rust so that i can have proper arrays 
[17:20:33] <bjs> alycidyne: I mean most languages do this
[17:20:34] <DnzAtWrk> uff
[17:20:36] <DnzAtWrk> screw nvidia
[17:20:37] <pikapika> ie in a pascal style
[17:20:45] <pikapika> rather than storing the length in a struct
[17:20:47] <DnzAtWrk> why do they need so many personal details for a simple download
[17:20:53] <pyzozord> merijn: I think my solution is simpler then the one proposed by the pdf, but essentially it does the same exact thing, just implemented differently. But I think less complex conceptually. Let me know what you think
[17:20:56] <beaky> but i like nvidia they make the hardawre that powers deep learning the most important human activity of our time
[17:21:03] <DnzAtWrk> I want cudnn
[17:21:10] <DnzAtWrk> Had to answer a bunch of questions with "none of your business"
[17:21:12] <DnzAtWrk> >:(
[17:21:17] <pikapika> DnzAtWrk, and they do everything in their power to make sure drivers don't work too
[17:21:17] <beaky> and nvidia came up with cuda the most successful parallel programming paradigm ever made
[17:21:39] <d3x0r> too bad cuda is proprietary - enter OpenCL
[17:21:51] <beaky> yes opencl is the least successful parallel programming paradigm ever made i think
[17:21:57] <DnzAtWrk> I want GPU support for darknet
[17:21:58] <d3x0r> haha
[17:22:02] <DnzAtWrk> does it work without CUDA?
[17:22:08] <d3x0r> yes
[17:22:11] <bjs> alycidyne: C arrays are like,  they almost don't really exist, they're more of a syntax hack than anything else
[17:22:14] <DnzAtWrk> what does it use if GPU=1
[17:22:19] <DnzAtWrk> without CUDNN=1
[17:22:22] <alycidyne> bjs: C arrays are one massive joke
[17:22:41] <pikapika> C arrays are natural
[17:22:48] <pikapika> What other way is there to make arrays?
[17:22:52] <alycidyne> -_-
[17:23:02] <DPA> I only use OpenCL. Skrew CUDA & Nvidia.
[17:23:03] <pikapika> All arrays are C arrays. At least any that are sane.
[17:23:08] <d3x0r> (other ways to make arrays) with a wrapped structure that has a size :) and methods...
[17:23:10] <mrig> there is an array of different choices.
[17:23:13] <bjs> pikapika: what do you mean?
[17:23:13] <pikapika> I know "arrays" are linked lists or hash tables in some languages
[17:23:15] <d3x0r> everything in C is an array though :)
[17:23:29] <pikapika> bjs, what other sane implementation of arrays exists other than a continuous block of memory?
[17:23:42] <bjs> pikapika: we're not complaining about the contiguous aspect of it, that's fine
[17:23:52] <alycidyne> pikapika: we are talking about the data type, not the implementation
[17:23:57] <pikapika> If you want bounds checking, it comes with a cost
[17:24:09] <pikapika> And you are free to write your own class anyways
[17:24:11] <bjs> pikapika: C arrays are much deeper problem than just bounds checking
[17:24:18] <bjs> pikapika: C doesn't have classes
[17:24:19] <alycidyne> pikapika: the C array data type is a disgrace to typing
[17:24:31] <bjs> C arrays aren't even really a data type, they are very close to being a syntax hack
[17:24:34] <pikapika> bjs, structs with functions acting on them are basically lightweight calsses
[17:24:36] *** Quits: elnavigator (~elnavigat@105.196.154.34) (Ping timeout: 268 seconds)
[17:24:45] * mrig loves a good language tennis session.
[17:24:50] <pikapika> alycidyne, are you complaining that arrays turn into pointers?
[17:24:51] <d3x0r> can even fill in function pointers in the struct
[17:24:52] <alycidyne> even Fortran had better arrays than C - in the 1950s
[17:24:56] <d3x0r> get vtable support 
[17:25:09] <bjs> pikapika: they don't "turn into" pointers
[17:25:18] <d3x0r> they were already a pointer
[17:25:37] <pikapika> Yes but static arrays had a length information in the method they were declared in
[17:25:47] <DPA> Inheritance was a mistake. Always use composition.
[17:25:48] <pikapika> They degrade into "just pointers" when passed to another method
[17:25:49] <d3x0r> to the compiler, not the runtime
[17:25:59] <akronymus> Immutable arrays-like datastructures are pretty awesome. 
[17:26:05] <alycidyne> pikapika: you know what, I actually am, because I now realize that my language has a major inconsistency following this line of reasoning
[17:26:09] <bjs> pikapika: they dont degrade,  they really are just pointers.  The "array"ness is just a syntactic illusion mostly
[17:26:54] <pikapika> bjs, I know they are. I am saying that the length information is lost when passed to a function. Thats what I meant by degrading. int a[10]; printf("%d\n",sizeof(a)/sizeof(int));
[17:26:56] <akronymus> C arrays get in your way. They hide away what the metal is doing.
[17:27:05] <pikapika> vs void method(int a[],...) {}
[17:27:14] <bjs> e.g. the moment you try to pass an array to a function the illusion falls apart. You don't have an array that gets copied over like other data types in C, you see them for what they really are
[17:27:20] <alycidyne> akronymus: so much for a portable assembler :^)
[17:27:23] <bjs> just a raw pointer to a random bit of memory
[17:27:26] <pikapika> Why should an array be copied over?
[17:27:35] <pikapika> in most langauges heavy objects are passed by reference anyways
[17:27:38] <merijn> bjs: That doesn't mean arrays don't exist in C or don't degrade to pointers
[17:27:41] <bjs> pikapika: C doesn't do that
[17:27:50] <pikapika> What doesn't C do
[17:27:52] <akronymus> But most languages provide a way to recover the length.
[17:27:52] <pikapika> what are you talking about
[17:27:57] <merijn> bjs: arrays exist in the spec and *do* degrade to pointers
[17:28:02] *** Joins: wovixo (~wovixo@128.104.205.49)
[17:28:04] <pikapika> akronymus, thats because the "array" is really a class
[17:28:07] <pikapika> with the real array inside
[17:28:11] <pikapika> and a bunch of metadata with it
[17:28:13] <pikapika> like its length
[17:28:17] <bjs> merijn: I'm well aware of what the spec says, but it's a big complicated pile of words to say how arrays are a lie
[17:28:21] <pikapika> And you are free to make such a struct in C too
[17:28:27] <alycidyne> bjs: and I now realize this is a massive inconsistency in my language. I'm going to fix that in my spec right now.
[17:28:27] <pikapika> Except you actually see it for what it is
[17:28:36] <merijn> bjs: Which is why "int foo[10]; size_t n = sizeof foo / sizeof foo[0];" works and returns the correct result
[17:29:17] <bjs> merijn: okay but like, arrays arent' first-class values like everything else. That information is almost entirely syntactic
[17:29:17] <merijn> bjs: Well, they did try to add an extension that made it work, but no one implemented it correctly, so they quietly gave up and abandonned that :p
[17:29:27] <bjs> they are unlike almost every other "datatype" in C
[17:29:32] <merijn> sure
[17:29:38] <merijn> Which is yet another reason C sucks
[17:29:42] <pikapika> akronymus, do you think other programming langauges have some magic? Their arrays have some magical bits in the ram where the length is automatically recorded? Any time you encounter a length remembering, bounds checked array, thats because the metadata is stored in a struct somewhere
[17:29:50] <merijn> It can't even do the one thing it's supposedly good at right
[17:29:54] * akronymus tunes out of the fight.
[17:30:06] <pikapika> akronymus, why
[17:30:08] <merijn> pikapika: Doesn't have to be, can be done statically at compile time too :p
[17:30:11] <bjs> merijn: well,  can't really blame it, it's old and they tried to hack arrays in for niceness
[17:30:17] <bjs> and it works just about
[17:30:17] <pikapika> akronymus, tell me what magic do you think arrays have in other langs
[17:30:22] <merijn> bjs: I don't blame K&R
[17:30:22] <akronymus> Because these fights won't ever result in anything productive.
[17:30:31] <merijn> bjs: I blame all the morons who try and claim it's still great
[17:30:39] *** Joins: enoq (~enoq@194-208-179-35.lampert.tv)
[17:30:46] <pikapika> akronymus, you just spouted some absolute bs and are trying to avoid responding now
[17:31:02] <akronymus> You basically always want to have the length anyways. 
[17:31:02] <alycidyne> pikapika: we are talking about a data type, not about an implementation. It's not because it is implemented with a buffer that it must be nothing more than a buffer in the *source code*
[17:31:04] *** Joins: elnavigator (~elnavigat@105.196.130.195)
[17:31:06] <bjs> merijn: C is great at working almost everywhere and having good compilers written for it
[17:31:35] <akronymus> The small overhead is worth it IMO, because it allows you to reason about it easier.
[17:31:58] <pikapika> alycidyne, I don't see whats the issue. You have fat arrays in Java, Python etc and thats because they store a struct internally with its metadata. Just the same as say the vector class works in C.
[17:32:07] <pikapika> Its just syntax sugar for the same crap
[17:32:08] <akronymus> And, hell, most compilers can optimize the metadata away if you truly don't use it.
[17:32:14] <bjs> pikapika: there is no C "Vector class"
[17:32:19] <bjs> that's kind of the point
[17:32:23] <pikapika> bjs, the vector class isn't magic
[17:32:40] <pikapika> Its made from C (in this case C++, but the only thing truly "new" is templates really) primitives
[17:32:41] <bjs> pikapika: there *is no* vector class. C doesn't even have classes.  arrays aren't a struct type
[17:32:56] <pikapika> bjs, classes are just a funny syntax for structs and methods operating on structs
[17:32:58] * akronymus hides
[17:33:08] <pikapika> How do you think classes are implemneted?
[17:33:09] <pikapika> lmao
[17:33:16] <bjs> pikapika: but C doesn't have classes. they're not implemented
[17:33:27] <pikapika> And has that ever been an issue?
[17:33:28] <bjs> and even though it has structs, arrays aren't implemented using structs.
[17:33:32] <pikapika> "class" is just syntactic sugar
[17:33:40] <pikapika> bjs, do you know how vector is implemented?
[17:33:44] <bjs> pikapika: I don't know why you keep talking about classes, "class" doesn't exist in C
[17:33:50] <DPA> I think class methods suck. I wish there was an explicit interface construct. Something like:
[17:33:50] <DPA> interface a { void something(); }; struct x { interface a a; interface b b; }; void something(struct x* this){ puts("Hello"); }; implementation x::a = { .something = something }; struct x x; a::something(x.a);
[17:33:50] <DPA> I currently do thet with 2 structs and a pointer, but it's not ideal.
[17:33:53] <pikapika> bjs, classes are just structs and methods
[17:34:00] <pikapika> quick
[17:34:01] <bjs> pikapika: C *does not have* classes. ?
[17:34:03] <pikapika> tell me the difference between
[17:34:06] <d3x0r> hooray for C# :)
[17:34:11] <Noisytoot> almost everything is just syntactic sugar
[17:34:20] <merijn> It's all just transistors!!!
[17:34:21] <d3x0r> DPA
[17:34:41] <pikapika> struct A {...}; A *A_ctor(...) void A_append(A *a,int e) { ... } vs class A { A() {...} void append(int e) {...} }
[17:34:46] <pikapika> bjs
[17:34:58] *** Quits: YHVH (~yhvh@2601:982:8300:8090:a09d:5f40:6d86:e7a) (Ping timeout: 240 seconds)
[17:35:10] <d3x0r> #define new(A) A##_ctor()
[17:35:17] <pikapika> lmfao
[17:35:18] <bjs> pikapika: are you confusing C with C++ ? C++ has vectors and classes.  C does not have a "class" keyword.  It only has struct/union.  Even still,  the C array "type" does not use struct/union.
[17:35:21] *** Joins: Suchiman (sid3778@about/csharp/suchiman)
[17:35:26] <pikapika> People have been doing lightweight oop in C for any practical size project
[17:35:28] <merijn> pikapika: The former doesn't let you do RAII
[17:35:33] <pikapika> bjs, did you read what I just wrote
[17:35:36] <bjs> pikapika: yes
[17:35:43] <merijn> RAII is, like, literally the only good thing about classes in C++
[17:35:46] <pikapika> merijn, raii is orthogonal to having a struct to record an array and its length
[17:35:49] <merijn> If you don't get RAII, why even bother
[17:35:52] <pikapika> which is really all that C++ vector does
[17:35:55] <Twix> C++ is not C with funny macros or something. But you can build your own class-like patterns in C.
[17:36:07] <pikapika> in C you would write my_vector { int *arr; int capacity; int len; }
[17:36:10] <davve_> best thing about C++ is the libraries
[17:36:24] <merijn> davve_: The best thing about C++ is the stdlib
[17:36:32] <pikapika> bjs, tell me the real difference if any between struct A {...}; A *A_ctor(...) void A_append(A *a,int e) { ... } vs class A { A() {...} void append(int e) {...} }
[17:36:32] *** Joins: mjbatty (~mjbatty@82.2.17.205)
[17:36:34] <merijn> davve_: The worst thing is "needing to depend on literally anything else" :p
[17:36:37] <bjs> pikapika: but we're not talking about vectors, or classes, or structs. We're talking about C's array "type".
[17:36:43] <pikapika> bjs, struct A {...}; A *A_ctor(...) void A_append(A *a,int e) { ... } vs class A { A() {...} void append(int e) {...} }
[17:36:48] <bjs> pikapika: the latter doesn't exist, because C doesn't have a "class" keyword
[17:36:49] <merijn> davve_: Because C++ dependencies and libraries are a fucking nightmare :p
[17:36:51] <pikapika> tell me whats the real difference if any
[17:36:58] <bjs> pikapika: maybe you're confusing C with C++
[17:37:03] <pikapika> bjs, tell me how the former isn't practically the same as the latter
[17:37:21] <bjs> pikapika: the latter uses a feature the language doesn't have
[17:37:23] <Twix> In Zephyr RTOS, people have a struct member containing "public" visible data and do funny pointer calculation things to obtain the overlaying object of that handle. So you can even implement public and private ~class~ struct members in C :D
[17:37:24] <pikapika> thats fucking how people have been doing lightweight oop in C for ages. Coupling structs with methods working on struct pointers.
[17:37:37] <bjs> pikapika: yes I don't know what point you're trying to make
[17:37:51] <pikapika> bjs, so the fact that C does not have "classes" is irrelevant
[17:37:58] <pikapika> You have structs, you have pointers, you have functions
[17:38:08] <bjs> pikapika: what is your point?
[17:38:10] <pikapika> C++ vector isn't some magical thing
[17:38:13] <pikapika> It stores the same shit inside
[17:38:15] <bjs> nobody said it was
[17:38:24] <bjs> a C++ vector is not a C array.
[17:38:25] <pikapika> A dynamically allocated array, its capacity and its length essentially
[17:38:33] <pikapika> A C++ vector is just a class wrapping a C array
[17:38:46] <pikapika> C arrays are all that exists in the universe
[17:38:46] *** Quits: pulse (~pulse@user/pulse) (Ping timeout: 268 seconds)
[17:38:56] <pikapika> Everything esle is built around them
[17:38:56] <bjs> it's not wrapping a C "array", because C array 'types' don't really exist.  It might use the square brackets but that's not really what's going on
[17:38:57] <akronymus> pikapika is "TopMind" by chance a nick of yours?
[17:39:03] <bjs> no, C arrays *dont* exist at all, you only have pointers
[17:39:04] <Twix> gets a bit more complicated if we talk about virtual functions and inheritance
[17:39:10] <pikapika> and C++ also only has pointers
[17:39:19] <pikapika> a vector only has a T* pointer inside
[17:39:20] <pikapika> Thats all
[17:39:22] *** Quits: furrymcgee (~devuan@31.179.186.66) (Quit: leaving)
[17:39:24] <bjs> Yes.
[17:39:44] <pikapika> So whats the problem? You can do the exact same thing in C
[17:39:49] <bjs> But it's wrapped up in a nice object that *does* exist in the language and is more of a first-class syntax
[17:39:52] <bjs> pikapika: but C doesn't
[17:40:06] <pikapika> Nothing stopping you from writing a vector struct and associated functiuons in C
[17:40:10] <bjs> C's "array" type *isnt* a struct that's a wrapped up pointer
[17:40:20] <pikapika> Its a library issue not a language syntax issue
[17:40:29] <pikapika> bjs, and nothing is stopping you for writing your own struct
[17:40:33] <bjs> no arrays are clearly part of the languae
[17:40:41] <pikapika> vector isn't part of C++ syntax
[17:40:42] <bjs> pikapika: yes nobody is arguing you can't, what's your point?
[17:40:49] <pikapika> its just a class built from primitive C++ syntax elements
[17:42:18] <bjs> pikapika: yes but in C the array "type" just isn't one
[17:42:28] <pikapika> What isn't one?
[17:42:40] <bjs> the C++ library might have one, that's great and it's nice.  there are lots of C libraries with vector-like things and wrappers
[17:42:52] <pikapika> Its the same thing essentially
[17:42:56] <bjs> pikapika: it's really not
[17:42:59] <bjs> that's the point
[17:43:02] <pikapika> How is it not?
[17:43:03] <bjs> C arrays aren't like a struct
[17:43:08] <pikapika> Duh?
[17:43:10] <bjs> they're just a pointer and some fancy clothing
[17:43:14] <pikapika> Thats the point
[17:43:22] <pikapika> Why impose a struct cost needlessly on it?
[17:43:23] <akronymus> But doesn't that get in the way?
[17:43:27] <bjs> pikapika: structs don't have costs
[17:43:29] <pikapika> If the programmer needs they can make their own struct
[17:43:29] <akronymus> According to your own definition
[17:43:30] *** Quits: herjazz (~herjazz@p6758124-ipngn30801marunouchi.tokyo.ocn.ne.jp) (Quit: leaving)
[17:43:32] <pikapika> Oh?
[17:43:33] <pikapika> lmfao
[17:43:39] <bjs> pikapika: why are you laughing?
[17:43:57] <pikapika> struct Array { int *storage; int len; int cap; }
[17:44:01] <pikapika> does len and cap come from thin air
[17:44:03] <bjs> pikapika: who says it should have the other fields?
[17:44:04] <pikapika> or some special ghost ram
[17:44:09] <merijn> bjs: Because everyone knows a word of overhead on your arrays is the kinda bloat and overhead that makes software slow
[17:44:12] <merijn> bjs: /s
[17:44:19] <pikapika> bjs, the two other fields exist anywhere there is a fat array
[17:44:23] <bjs> `struct Array { int* storage }`   is what C arrays *should* have been like
[17:44:27] <pikapika> its just hidden from you by the syntax in the other languages
[17:44:42] <akronymus> bjs forgot the length
[17:44:50] <bjs> akronymus: no C arrays don't store their length
[17:44:52] <pikapika> bjs, any language that has an array with its length recorded has to store the length somewhere
[17:44:53] <merijn> So many people complaining about "waste" and "overhead" online who've clearly never worked on any code that's actually high-performance/performance sensitive >.>
[17:44:56] <bjs> C arrays dont eixst
[17:45:02] <akronymus> Oh, the "should" confused me bjs
[17:45:05] <pikapika> And arrays don't exist anywhere else either
[17:45:13] <pikapika> the length field always exists
[17:45:19] <pikapika> All arrays are just a pointer and a length
[17:45:21] <bjs> pikapika: no there is no "length field" in C arrays
[17:45:37] <pikapika> bjs, and nobody stopping you from wrapping it in a struct with the length field
[17:45:39] <bjs> no they are not, they are just a pointer. The length is just an artefact the compiler knows, but it's not part of the actual C object
[17:45:42] <pikapika> Why impose a length coupling needlessly?
[17:45:45] *** Cyp_ is now known as Cyp
[17:45:49] <pikapika> bjs, lmfao
[17:45:59] <bjs> pikapika: why are you laughing now?
[17:46:23] <pikapika> What universe are you from? How do you think all these fancy languages like Java and Python get you the length when you type arr.length or len(arr)?
[17:46:28] <bjs> pikapika: we are talking about C
[17:46:32] <akronymus> pikapika because there is basically never a situation where you pass the array to something without also needing the length.
[17:46:33] *** Joins: jmft2 (~JMFT@82.3.54.26)
[17:46:44] <pikapika> bjs, C is just telling you what arrays really are
[17:46:48] <pikapika> in any language
[17:46:53] <pikapika> Arrays are just a pointer
[17:46:55] <merijn> wut
[17:46:56] <pikapika> Thats what they are
[17:46:57] <pikapika> and nothing else
[17:47:02] <bjs> pikapika: C's arrays do not really exist. They are just a figment of the imagination of the syntax.  They do not store the length.
[17:47:07] <bjs> pikapika: Python's list/array types do not use C arrays.
[17:47:11] <akronymus> But it isn't. It hides away that it really is just a pointer + offset
[17:47:12] <pikapika> Its on you to store the length
[17:47:13] <bjs> They malloc().
[17:47:16] <akronymus> By having an index
[17:47:18] <pikapika> ....
[17:47:22] <pikapika> what do you think malloc returns
[17:47:26] <bjs> pikapika: a pointer.
[17:47:27] <bjs> not an array.
[17:47:30] <pikapika> ....
[17:47:32] <bjs>  
[17:47:37] <pikapika> so where does the array exist?
[17:47:39] <pikapika> Its all pointers
[17:47:40] <bjs> it doesn't
[17:47:42] <pikapika> as I was saying all this while
[17:47:42] <akronymus> It doesn't.
[17:47:42] <bjs> there is no array
[17:47:49] <pikapika> its a pointer and a length
[17:47:53] <akronymus> So, BY YOUR OWN DEFINITION, that is getting in your way.
[17:47:55] <merijn> You guys are conflating meta-layers and therefore talking past eachother
[17:48:00] <pikapika> nobody stopping you from writing your own struct to wrap a pointer in C
[17:48:01] <sandman13> I wish to have that level of confidence
[17:48:06] *** Quits: alycidyne (~kova@91-160-172-214.subs.proxad.net) (Quit: leaving)
[17:48:16] <bjs> pikapika: yes and that's not a C array.  It might be an "array" in common parlence but it's not using C's array "type" to do it.
[17:48:20] <merijn> pikapika: You are confusing "the implementation of something" with "the specification of something"
[17:48:24] <bjs> pikapika: that is exactly what Python's `list` is.
[17:48:28] *** Joins: olle (~olle@p578524f9.dip0.t-ipconnect.de)
[17:48:34] <bjs> It's a C struct, that contains a pointer to some malloc()'d memory
[17:48:34] <pikapika> int *arr=malloc(sizeof(int)*100): arr[10]=235;
[17:48:35] <DPA> C arrays do exist. They do store the length at compile time. Try sizeof(int[10])/sizeof(int) for example. There are some fake arrays in C that are really just pointers, but real arrays do exist.
[17:48:36] <pikapika> This works in C
[17:48:38] <merijn> How arrays happen to be implemented is completely irrelevant to how a compiler can handle/treat them
[17:48:46] <olle> Coupling is only defined for modules, not functions?
[17:48:46] <bjs> pikapika: that isn't an array though
[17:48:54] <bjs> just calling it "arr" doesn't mean you're using C's arrays
[17:48:57] *** Joins: mjbatty_ (~mjbatty@82.2.17.205)
[17:49:01] <pikapika> Arrays are just a pointer to a continuous block of memory
[17:49:04] <pikapika> Thats all that exists in hardware
[17:49:10] <pikapika> Thats what arrays are in any language
[17:49:14] <bjs> pikapika: no.  C has a feature called "arrays"
[17:49:18] <bjs> your code does not use that feature.
[17:49:24] <akronymus> And the square brackets hide away that it really is just a pointer offset.
[17:49:32] <pikapika> Thats just a name. Whatever is the name of the data structure, at the end its just a pointer to a buffer of memory
[17:49:35] <pikapika> Thats all that exists
[17:49:38] <pikapika> akronymus, exactly
[17:49:44] <bjs> pikapika: yes it's a name, it's a name of a very specific feature in C.
[17:49:46] <pikapika> Even asm has various base+len*offset instructions
[17:49:49] <bjs> that your example up there did not use.
[17:49:52] <akronymus> So, it gets in your way pikapika
[17:49:53] <pikapika> bjs, and in any opther language
[17:50:03] <bjs> pikapika: no, other languages use the same word to mean similar or related but different features
[17:50:17] <pikapika> other languages use "arrays" to mean hash tables or linked lists...which aren't arrays
[17:50:23] <bjs> e.g. Python has an 'array' type, and that array type is a C struct with a pointer to some malloc()d memory. It does not use *C*'s arrays anywhere
[17:50:40] <pikapika> dude a pointer to a memory is an array in C. Thats all that there is.
[17:50:51] <bjs> pikapika: no there is a language feature called arrays, and your example just isn't using it
[17:50:54] <pikapika> an array is just a block of memory
[17:50:55] *** Quits: mjbatty (~mjbatty@82.2.17.205) (Quit: Client closed)
[17:50:58] <DPA> std::array<int, size> is the same as int[size] in c. It's just that C++ is really bad at C, and can't deal with the latter as nicely.
[17:51:04] <pikapika> Language features are irrelevant
[17:51:13] *** Parts: olle (~olle@p578524f9.dip0.t-ipconnect.de) ()
[17:51:14] <pikapika> All arrays are a block of memory in hardware
[17:51:15] <bjs> no I don't know how to say this more clearly, there is a language feature called "array" and that's what we're talking about
[17:51:22] <pikapika> Rest is all just fancy naming and layers wrapping around it
[17:51:57] <bjs> pikapika: I mean you are free to call that whatever you want, but C does not call that an array.
[17:52:00] <pikapika> Ok? And that language feature really is just a reference to a region of memory. In any language, anywhere. Everything is just a fancy syntax to do a base+len*offset deferernce against a memory address
[17:52:30] <bjs> pikapika: yes we were talking about the *language feature called "array" in C*
[17:52:34] <merijn> pikapika: Language have specifications that exist apart from actual computers used now (or ever), so that's not true
[17:52:37] <user51> pyzozord: meh, this codality thing is fucked
[17:52:56] <pikapika> bjs, which is just a pointer. So is a Java array or a Python array or an array anywhere else.
[17:52:58] <merijn> pikapika: It's only true in the context of "languages as implemented on current x86/x64 hardware" really
[17:53:01] *** Joins: mikeliuk (~mikeliuk@109.249.187.96)
[17:53:13] <bjs> pikapika: yes, but the key point is that a Python 'array' type is *not* using a C array
[17:53:14] <akronymus> I wonder what ritchie would think of this.
[17:53:17] <bjs> it's using malloc()
[17:53:38] <pikapika> And malloc is returning a pointer to a region of memory
[17:53:38] <sandman13> Doesn't C use an abstract machine to define it's specification? Hardware is unknown to C
[17:53:47] <merijn> Fuck it, even malloc is C specific
[17:53:53] <bjs> pikapika: yes, not a C array.
[17:53:54] <pikapika> A local array in a function is also a pointer to a region of memory, a different region usually, called the stack
[17:54:01] <merijn> malloc is not a syscall and there are languages that don't ever use malloc
[17:54:05] <merijn> sandman13: It is
[17:54:18] <pikapika> Thats irrelevant. malloc is just a way to mark a region of memory.
[17:54:25] <sandman13> merijn: sbrk()/mmap() is the syscall right?
[17:54:26] <pikapika> All other languages have to use the memory too
[17:54:31] <merijn> sandman13: Which is why limiting your discussion of C "the language" to "how we currently happen to implement it on one specific machine" is silly
[17:54:31] <pikapika> in one way or the other
[17:54:37] <bjs> pikapika: how is it irrelevant? the whole conversation is about why you shouldn't use C "array"
[17:54:45] <merijn> sandman13: sbrk() has been outdated for 2 decades or more :p
[17:54:49] <pikapika> Tell me a magical machine which doesn't have memory addressing and pointers
[17:54:49] <bjs> and why it's weird/confusing and why malloc is better
[17:54:53] <pikapika> Never seen one
[17:54:53] <merijn> sandman13: But yeah, mmap is what you commonly ue
[17:55:01] <bjs> pikapika: what are you talking about?
[17:55:04] <pikapika> bjs, you are the only one who is confused
[17:55:16] <bjs> pikapika: C has a feature, a feature it calls "array". Your code up there used malloc() it did not use C arrays
[17:55:20] <pikapika> A local array and a malloc do the same thing. One is typically allocating ont he stack, other on the heap.
[17:55:25] <bjs> pikapika: NO they do not.
[17:55:29] <merijn> sandman13: It's why you wanna separate "abstract semantics of a language" from "concrete implementation"
[17:55:34] <pikapika> Both are just marking a region of memory and returning a pointer to the first element
[17:55:38] <bjs> You are falling into a very common trap to think that a C array is like some malloc()d memory
[17:55:50] <pikapika> How is it not? Is it some special kind of uber ram?
[17:55:52] <merijn> sandman13: You can talk about semantics, implementation, or how to map semantics to an implementation
[17:55:57] <pikapika> RAM is ram, whatever name you happen to give it
[17:56:03] <bjs> pikapika: YES it is
[17:56:13] <merijn> sandman13: But when people confuse the 2, you get endless discussions of people talking past each other
[17:56:20] <pikapika> Stack and heap are just funny names we give to regions of ram
[17:56:20] <merijn> See, exhibit #1 right here ;)
[17:56:27] <bjs> pikapika: they are not just funny names.
[17:56:30] <sandman13> merijn: Right. And if you consider that, you kind of get what is UB :D
[17:56:30] <DPA> sizeof() - the difference between arrays and pointers
[17:56:44] <akronymus> merijn i think all but 1 person here understand the difference.
[17:56:53] <bjs> pikapika: there is a big difference in C between stack-allocated things and heap-allocated things
[17:56:54] <merijn> sandman13: tbh, it's why I think compiler construction is one of the most important courses
[17:56:54] *** Quits: Yonle (~Yonle@user/yonle) (Ping timeout: 272 seconds)
[17:56:59] <pikapika> bjs, a stack is just a base address and an index to the top element. The "heap" in typical programns is the same, just growing in the opposite direction.
[17:57:03] <pikapika> Its just regions of memory.
[17:57:08] <merijn> sandman13: It's the one course that hammers home the difference between those 3 things :)
[17:57:24] <sandman13> merijn: Too much focus on parsing though. They present it as if it's the hardest job.
[17:57:28] <bjs> pikapika: I know exactly how stacks and malloc and heap and memory work, I think you're not apprecating that there is the whole C language between you and the machine
[17:57:30] <merijn> sandman13: I know
[17:57:37] <pikapika> merijn, all that is a moot point when practically any real implemnetation of arrays on existing real hardware is just a pointer+length
[17:57:51] <bjs> pikapika: NO that is not how C arrays are implemented.
[17:57:54] <bjs> They do not have a length
[17:57:59] <merijn> sandman13: I TAed for compiler construction a few years and pushed to just allow GLR parser generators like ANTLR, because I think parsing is the least interesting bit of the course
[17:58:09] <DPA> They do, at compile time only.
[17:58:11] <pikapika> bjs, and there's nothing stopping you from storing a length in a struct of your making
[17:58:16] <bjs> pikapika: if you look in memory, you will not see a length thing
[17:58:16] <pikapika> Thats how arrays are implemented in other languages
[17:58:23] *** Quits: mci64 (~mci64@194.25.223.4) (Quit: Connection closed)
[17:58:29] <bjs> pikapika: sure and nobody is arguing that, and yes I've said that is how Python's 'array' type is implemented for example
[17:58:32] <pikapika> RAM can't read your mind. you have to record a length somewhere
[17:58:37] <bjs> pikapika: no you do not
[17:58:39] <pikapika> So whats the point?
[17:58:40] <bjs> C does not store that length anyhwere
[17:58:48] <akronymus> And I, as a programmer, don't care about the actual implementation. I'd rather think about how to solve my problem without having to track the pointers by myself and such.
[17:58:51] <pikapika> And C is not stopping you from writing a struct that does
[17:59:00] <merijn> sandman13: It's why I like parser combinators in Haskell/F#/etc. they are very easy to use and everyone understand recursive descent parsing fairly quickly
[17:59:02] <bjs> pikapika: yes and I just said that is what Python e.g. does
[17:59:05] <pikapika> Moot point
[17:59:09] <pikapika> bjs, so whats the problem?
[17:59:13] <pikapika> Its a solved problem then
[17:59:17] <pikapika> A very trivially solved problem
[17:59:21] <bjs> pikapika: yes it's solved because these things *dont use* C arrays
[17:59:22] <pikapika> There has to be something that implements that layer
[17:59:29] <pikapika> bjs, C arrays are just a pointer
[17:59:30] <bjs> pikapika: I do not want C arrays to store their length
[17:59:45] <pikapika> a[k] is *(a+k)
[17:59:47] <bjs> pikapika: yes but a pointer is not just a C array
[17:59:52] <pikapika> A pointer is a pointer
[17:59:52] <bjs> C array is a language feature
[17:59:55] <pikapika> Its just an address
[18:00:00] <bjs> no they are not addresses either
[18:00:03] <pikapika> A C array is just a thin syntax over the pointer
[18:00:05] <pikapika> Oh?
[18:00:05] <bjs> You really need to read the C standard
[18:00:10] <akronymus> If you try to use a struct array in c you'll have to use defines and/or header files everywhere.
[18:00:18] <akronymus> Thus it isn't a first class citizen 
[18:00:23] <sandman13> merijn: Oh yeah. They are pretty good. There was a similar project in C: https://github.com/orangeduck/mpc
[18:00:27] <akronymus> Which makes the default mode the naked arrays.
[18:00:30] <pikapika> Stadnard defines things in an implementation independent manner
[18:00:41] <bjs> pikapika: the standard defines the language.
[18:00:48] <merijn> sandman13: Yeah, but parametric types really make them shine :p
[18:01:00] <pikapika> Sure you could theoretically have a language implementation where pointers aren't addresses, but mathematically you'll end up with a one-to-one correspondence or even an equivalence anyayws
[18:01:04] <bjs> pikapika: you seem to be disregarding the fact there's a whole language between you an the hardware here
[18:01:09] <sandman13> merijn: With Haskell and friends yeah :D
[18:01:17] <pikapika> bjs, and an os with virtual memory
[18:01:21] <bjs> pikapika: no you're completely misunderstanding C's object model and the relationship of the spec with the implementation
[18:01:21] <pikapika> But the concept is the same
[18:01:37] <pikapika> How?
[18:01:39] <InPhase> bjs: https://wandbox.org/permlink/V7MLpesNLbhhotK7
[18:01:40] <bjs> You seem to think that C is just a think wrapper around the hardware/asm or something
[18:01:42] <bayaz> Title: [Wandbox]ä¸‰ã¸( ã¸Õžà¨Š Õž)ã¸ ï¾Šï½¯ï¾Šï½¯ 
[18:02:05] <pikapika> Its not, and it doesn't matter. The thing we were discussing is that arrays are just pointers and pointers are arrays in practice.
[18:02:13] <akronymus> Arrays in C
[18:02:17] *** Joins: Lockna[m] (~l0cknamat@2001:470:69fc:105::d697)
[18:02:28] <bjs> pikapika: no they are not, C arrays are a very specific feature.  You can't just get a random pointer and call it an "array"
[18:02:40] <bjs> that is just not what C is, it's not what the standard says, your code will be wrong if you do that.
[18:02:47] <akronymus> In most other languages arrays have a length.
[18:02:47] <pikapika> Really? I can't. I can use the [] syntax on any pointer.
[18:02:54] <merijn> InPhase: https://gist.github.com/merijn/0392ae239b9a091986ae ;)
[18:03:06] <bjs> pikapika: yes.
[18:03:13] <bjs> that's how C pointers work
[18:03:18] <akronymus> Pretty sure for non-arrays it is UB
[18:03:23] <pikapika> An array is just a base address + an offset
[18:03:24] <merijn> akronymus: No
[18:03:30] <merijn> akronymus: As long as you use [0]
[18:03:30] <akronymus> Fair nuff
[18:03:36] <pikapika> in other words, *(ptr+i)
[18:03:38] <akronymus> Oh I meant in the general case
[18:03:40] *** Quits: inom (~inom@176.59.108.224) (Read error: Connection reset by peer)
[18:03:41] <akronymus> of [n]
[18:03:50] <merijn> akronymus: THe spec explicitly defines "a[i]" as equivalent to "*(a + i)"
[18:03:57] <sandman13> is the result 4?
[18:04:01] <pikapika> Its upon the programmer to not do stupid shit like dereference memory that doesn't exist
[18:04:01] <merijn> So, as long as i = 0 it's fine :)
[18:04:04] <merijn> sandman13: Nope
[18:04:11] <akronymus> But if it isn't 0?
[18:04:13] <bjs> pikapika: it's on the programmer to do a lot of things correctly in C
[18:04:19] <merijn> sandman13: Bonus question: Is the result undefined, implementation defined or standard defined? ;)
[18:04:22] <pikapika> akronymus, depends on how its allocated
[18:04:29] <merijn> akronymus: If it isn't 0 then it's UB, because out-of-bounds
[18:04:31] <InPhase> akronymus: Which is why 5[ptr] is valid C syntax.
[18:04:33] <bjs> akronymus: it's UB if you do something you're not allowed,  some objects let you access non-0 indexes others have bounds others don't
[18:04:35] <akronymus> And this is why it gets in the way of me expressing what I want it to do. bjs
[18:05:04] <sandman13> merijn: I don't have that much of C knowledge xD
[18:05:12] <InPhase> akronymus: The "which is" refers to merijns *(a+i) comment.
[18:05:16] <bjs> akronymus: it's really hard to write C correctly, as there are so many things that are just massive UB landmines
[18:05:22] <pikapika> akronymus, other languages impose even more restrictions. "UB" is just a funny word for platform dependent or just the programmer attempting something plain ridiculous in moist cases.
[18:05:27] <bjs> akronymus: and C compilers don't tell you
[18:05:28] <akronymus> bjs yes, it gets in the way
[18:05:32] <merijn> sandman13: It's standard defined behaviour, so same result on all C implementations :)
[18:05:32] <bjs> pikapika: no UB is not "platform dependent"
[18:05:48] <bjs> pikapika: C has implementation dependent behaviour, but it *also* has uB
[18:05:55] <merijn> bjs: In related pedantry
[18:06:01] <sandman13> merijn: My brain hurts parsing it :D
[18:06:04] <merijn> bjs: I had a colleague claim C was a subset of C++
[18:06:06] <pikapika> bjs, example right shift
[18:06:07] <bjs> pikapika: if your program has UB in it anywhere, then the entire program can do whatever.  And C compilers really can do crazy things
[18:06:28] <merijn> bjs: So I wrote an example that's warning free, standard correct C11 and C++11, but does something different in each: https://gist.github.com/merijn/3ea788047b61ccff221af0837be1ec36 :D
[18:06:37] <bjs> merijn: just use class as a variable
[18:06:43] <bjs> or new and delete
[18:06:57] <merijn> bjs: That's an error in one, though, no?
[18:06:59] <pikapika> Thats an implementation problem. There is nothing demanding languages to aggressively use UB as optimizations.
[18:07:02] <merijn> bjs: This compiles correctly in both
[18:07:03] <pikapika> *compilers
[18:07:05] <bjs> merijn: ooh
[18:07:08] <merijn> bjs: But still does something different
[18:07:16] <akronymus> pikapika those restrictions make it easier to write correct code, leaving me to more mental capacity to express what I want
[18:07:26] *** Quits: Lockna[m] (~l0cknamat@2001:470:69fc:105::d697) (Quit: Reconnecting)
[18:07:39] *** Joins: Lockna[m] (~lockna@2001:470:69fc:105::d697)
[18:07:39] <bjs> pikapika: you're thinking about it backwards, UB means there is no bound on what the program can do.
[18:07:52] <merijn> sandman13: I'll give you a hint
[18:07:53] <bjs> implementation dependent gives strong bounds 
[18:08:10] <merijn> sandman13: sizeof is not a function and people who use it as a function will get weird problems
[18:08:13] <pikapika> akronymus, that wasn't what was being considered. A restriction by definition is "getting in your way". Asm is the most flexible language and also the one that least gets in your way.
[18:08:22] *** Quits: elnavigator (~elnavigat@105.196.130.195) (Ping timeout: 268 seconds)
[18:08:30] <akronymus> Having to think about more stuff gets in the way
[18:08:32] <sandman13> merijn: I am aware of that
[18:08:41] *** Quits: AsenMx (~AsenMx@78.90.248.234) (Ping timeout: 248 seconds)
[18:08:42] <pikapika> bjs, thats the theory and any sane compiler should know what to actually do in case of "UB".
[18:08:49] <merijn> sandman13: Well, what do you know about operator precedence rules? ;)
[18:08:55] <pikapika> In "theory" one UB means the whole program could be compiled into anything
[18:08:55] <bjs> merijn: Huh, that's an interesting case
[18:09:04] <pikapika> But a compiler writer would be crazy to do that
[18:09:22] <pikapika> This just proves my point. Most C haters are just irrational people.
[18:09:25] <bjs> pikapika:  I think you are once again misunderstanding how things work.  UB gives the compiler writers more freedom
[18:09:25] *** Quits: Lockna[m] (~lockna@2001:470:69fc:105::d697) (Client Quit)
[18:09:26] <sandman13> merijn: That it is weird xD
[18:09:26] <bjs> and they use that
[18:09:35] <pikapika> C is not a perfect language and there are many criticisms that can be lobbed against it.
[18:09:38] <merijn> sandman13: suffix operators always bind more tightly than prefix
[18:09:40] *** Joins: lockna[m] (~lockna@2001:470:69fc:105::d697)
[18:09:42] <bjs> pikapika: compilers will and *do* take advantage of UB everywhere
[18:09:43] *** lockna[m] is now known as lockna
[18:09:51] <pikapika> But not the ones these irrational C haters are conjuring in their heads
[18:09:55] <merijn> sandman13: Guess what's a unary (prefix) operator :)
[18:09:56] <bjs> if your program has UB, very strange things can and very likely will happen
[18:10:18] <merijn> bjs: But it's still the 80s and optimising compilers don't exist!
[18:10:35] <pikapika> bjs, most things that are UB were defined to be so because its platform dependent. Right shift on signed and unsigned values is platform dependent.
[18:10:46] <bjs> pikapika: no most things that are are UB are UB for optimization reasons
[18:10:50] <pikapika> And thast why right shift beyond the bounds was defined to be UB
[18:11:17] <sandman13> merijn: Casting to (0)?
[18:11:36] <sandman13> i.e. int?
[18:11:43] <merijn> sandman13: No, it's doing (0)["ABC..."]
[18:11:43] <sandman13> or something else. 
[18:11:56] <merijn> sandman13: So that's the same as "ABC"[0]
[18:12:02] <merijn> sandman13: So it's taking the sizeof 'A"
[18:12:05] <merijn> 'A'
[18:12:07] <sandman13> wait what?
[18:12:22] <merijn> array indexing is a suffix operator, so higher precedence than sizeof
[18:12:25] <sandman13> Oh I get it
[18:12:27] <merijn> sizeof doesn't have parenthesis
[18:12:35] <sandman13> it's one of the weird things with C
[18:12:39] <merijn> And since sizeof char is 1 by definition
[18:12:43] <sandman13> 1[x] kind of thing
[18:12:46] <merijn> It will always print 1
[18:12:52] <sandman13> which is same as x[1]
[18:13:08] <merijn> sandman13: Right, but the sizeof + parens messes everyone up, because they always use sizeof with parenthesis
[18:13:18] <merijn> and forget it's a unary operator
[18:13:32] <bjs> pikapika: you seem to think that if there's UB the compiler will detect and try "figure out" what you really meant. Compilers generally do not do that. They simply assume the UB cannot happen and use that assumption to optimize the code. Re-ordering things, lifting things, or even just deleting whole branches
[18:13:33] <akronymus> I like lisps precedence rules. :P
[18:13:38] <sandman13> merijn: I was tripped by '(0)["ABCDEFGHIJKLMNOPQRSTUWVXYZ"]'
[18:13:48] <akronymus> Inner brace goes first.
[18:13:53] <pikapika> And lastly I would prefer if the irrational C haters actually put actions where their beliefs are and re-implement the entirety of oses and computing infrastructure in their powerful modern languages.
[18:13:56] <bjs> and you just get cascades of broken optimizations and then the final output is very strange
[18:13:59] <sandman13> I knew sizeof is not a function. But never thought about (0)
[18:14:15] <merijn> I mean (0) is just 0
[18:14:31] <akronymus> OS's are built on years and years and years of code.
[18:14:33] <sandman13> merijn: You found another way people can trip :D
[18:14:39] <merijn> sizeof0["ABCD"] (should?) work too, but that's less evil
[18:14:41] <akronymus> You can't just quickly build a new one.
[18:14:45] <pikapika> If these languages are so powerful whats stopping you from writing a new os, drivers, network stacks, infrastructure etc in them>
[18:14:47] <pikapika> If these languages are so powerful whats stopping you from writing a new os, drivers, network stacks, infrastructure etc in them?
[18:14:49] <merijn> akronymus: tbh, you kinda can
[18:14:58] <merijn> akronymus: OSes aren't so much work, it's all the fucking drivers
[18:15:07] <pikapika> And remember don't use any C anywhere. If your language was implemented in C then discard it and write it in asm first.
[18:15:19] <akronymus> merijn yeah. But I think pikapika means featuer parity
[18:15:20] <pikapika> C is too unreliable and dangerous. How do you rely on a language and runtime written in C?
[18:15:54] <beaky> by rewriting it in rust of course
[18:16:04] <pikapika> beaky, rust was written in C or C++ first.
[18:16:06] <pikapika> Its unreliable
[18:16:13] <akronymus> Not really
[18:16:16] <sandman13> OCaml
[18:16:18] <pikapika> We have to start from scratch and make a new rust compiler in asm to be safe.
[18:16:20] <akronymus> Do you know what bootstrapping is?
[18:16:24] <pikapika> sandman13, and what was ocaml implemented in
[18:16:34] <bihtori> Is this trolling?
[18:16:37] <merijn> Haskell was bootstrapped in Lazy ML :p
[18:16:51] <pikapika> akronymus, yes. And there is often a C compiler somewhere in the history of bootstrapping of most languages.
[18:16:53] <DPA> Setting up the ring switching and memory protection stuff in an OS on modern amd64 systems can't be understood by mere mortals anymore.
[18:16:56] <akronymus> https://www.youtube.com/watch?v=PjeE8Bc96HY
[18:16:59] <sandman13> Okay I will bite.
[18:17:00] <akronymus> pikapika
[18:17:04] <pikapika> And since people here strongly believe C is too dangerous and unreliable it means the whole chain is fucked
[18:17:08] <pikapika> And they should rewrite it in asm
[18:17:17] <akronymus> Even if you can't trust a intermediary step you can eventually trust it
[18:17:19] <beaky> yes even ken thompson himself believes so
[18:17:32] <sandman13> First off nobody is telling that they are going to rewrite everything in other language.
[18:17:42] <merijn> bihtori: Trolling is indistinguishable from aggressive Dunning-Kruger :p
[18:17:45] <sandman13> Secondly, people love complaining.
[18:17:47] *** Joins: pulse (~pulse@user/pulse)
[18:17:53] <pikapika> But clearly C is too dangerous and unreliable. How can you trust a language whos bootstrapping involved a C compiler in some early step, or in the language itself used to write the first version etc
[18:18:07] <sandman13> If you are at it
[18:18:16] <sandman13> don't even trust electricity for that matter.
[18:18:27] *** Quits: Rounin (~david@84.212.130.215) (Ping timeout: 258 seconds)
[18:18:30] <sandman13> It can zap you.
[18:18:33] <pikapika> I am not the one whos saying C can never be trusted.
[18:18:33] <merijn> Don't trust your silicon :p
[18:18:39] <pikapika> Tell that to the others who are saying that
[18:18:46] <merijn> The only people who think CPUs don't have bugs are people not involved in hardware :p
[18:18:46] <sandman13> nobody is saying that
[18:18:48] <pikapika> Its not my arguemnt, its their argument
[18:19:11] <beaky> yes there was a c compiler involved somewhere in the electricity generators used to power computers
[18:19:27] <merijn> I recommend pausing and reflecting on why you feel so personally attacked when people don't like a specific programming language :p
[18:19:47] <sandman13> merijn: At point in time I used to feel attacked too when Rust was around
[18:20:02] <mrig> when someone is wrong on the internet, they are just dammed wrong!
[18:20:05] <pikapika> I am not attacked. I just find it hilarious how most arguments against that language are completely irrational.
[18:20:11] <pikapika> There are proper arguments to be made against C
[18:20:13] <bjs> merijn: CPUs don't have bugs,  they merely have new features the software developers weren't informed of in advance
[18:20:17] <pikapika> But nobody here in the past few days made any.
[18:20:49] <bihtori> pikapika: printf is dangerous and unsafe. Rust's println! is much safer.
[18:21:14] <bjs> It seems clear that sooner rather than later Rust is going to take over a large (but not complete) chunk of what people use C for these days,  with many advantages
[18:21:16] * mrig is amazed that the whole house of cards stands at all, that is some fancy code origami right there.
[18:21:29] <bihtori> Whatever C does, Rust does safely. It's a miracle.
[18:21:32] <pikapika> printf isn't dangerous. Everybody knows how to use escape sequences and to match counts of arguments and escapes
[18:21:52] <mrig> bjs C++ perhaps, I doubt that it will take the c portion.
[18:21:52] <bjs> pikapika: everyone may know,  but the question is not what people know but what people actually do
[18:21:56] <mrig> different mind sets
[18:21:59] <bihtori> pikapika: Language must be designed to prevent as many human mistakes as possible
[18:22:04] <bjs> mrig: a lot of people use C even today for things they shouldn't :P
[18:22:11] <InPhase> merijn: It took me a couple minutes to parse out why that gives sizeof(X) of 1...  A decade of primarily C program in my background, but it's been so long ago that the C requirement of typing out struct slipped out of memory, and my brain failed to process the relevance of the global.
[18:22:13] <bjs> but yeah C++ too, and probably some other random languages
[18:22:20] <sandman13> Hey it's a great learning experience bjs 
[18:22:24] *** andrewSC_ is now known as andrewSC
[18:22:27] <pikapika> bihtori, indeed and i think C++ is a natural step forward in providing more compile time safety than C
[18:22:27] <merijn> InPhase: :)
[18:22:31] <mrig> bjs: would you be able to convince some one such as Linus Torvalds to use C++?
[18:22:33] <pikapika> I don't know rust so can't comment oni t
[18:22:44] *** Joins: inom (~inom@176.59.119.1)
[18:22:48] <bjs> mrig: no and the core of the kernel is probably one thing that's still going to stay C
[18:22:56] <bjs> A lot of the cruft around it that's in C for no reason could probably be rust
[18:22:56] <InPhase> merijn: I always considered that a bit of a nuissance in C anyway.
[18:23:00] <bjs> and probably will be rust eventually
[18:23:04] <merijn> InPhase: If I remind just 1 person every week that C and C++ are terrible languages that no sane person remembers everything about, my mission in life is accomplished :p
[18:23:18] <mrig> Yes there are places for languages, that is for sure.
[18:23:29] <pulse> but C and C++ aren't terrible languages
[18:23:36] <pulse> they're quite nice
[18:23:39] <sandman13> bjs: Maybe C++, I think zig will replace C
[18:23:46] <InPhase> merijn: The failure to remember everything is true of almost every serious language however.
[18:23:47] <user51> pyzozord: it was fun thinking about that problem
[18:23:48] <sandman13> but I won't hold my breath on that
[18:23:52] <user51> so thanks
[18:23:55] <pikapika> Those who say C compilers are "so dangerous" and then continue using oses and languages that involved C in some or the other part of the chain are hypocrites. If you truly believe things are so dire, you should be working hard to bootstrap your own infra completely from scratch.
[18:23:56] <merijn> pulse: Sounds like stockholm syndrome to me :p
[18:23:58] <mrig> I would have loved to have learned C++ slowly over the years.
[18:24:08] <merijn> InPhase: If you include libraries, sure
[18:24:12] <pulse> merijn, as a game developer, i don't mind dangerous languages, i embrace them ;)
[18:24:17] <mrig> it is rather a behemoth to approach at the moment :D
[18:24:23] <bjs> mrig: I think Linus would be more than happy for a large chunk of the disgusting code base to be replaced with code that has less chance of introducing random security vulnerabilities into his nice kernel
[18:24:24] <merijn> InPhase: If we're talking just core language, something like R6RS seems very doable
[18:24:36] <DPA> I don't like cargo, and how rust projects are compiled & linked. I don't like the lack of headers (separate interfaces for independant compilation units). I will never accept a language which don't have these things.
[18:25:04] <merijn> DPA: Rust has seperate headers, they're just generated from the modules instead of hand-written...
[18:25:15] <sandman13> Software Industry in general brings immense sadness to me
[18:25:24] <DPA> merijn: And that's a problem.
[18:25:30] <merijn> sandman13: That's a sign that you know what you're doing :)
[18:25:33] *** Joins: humky (~humky@user/humky)
[18:25:34] <merijn> DPA: Why?
[18:25:47] <bihtori> yeah but it also brings immense cash money so it evens out
[18:25:47] <user51> but their solution is actually bull fucking shit, and it fails if the input is not as excpected
[18:25:54] <bjs> mrig: but the core kernel itself is battle hardened and optimized and very carefully written and is very low-level and is probably not worth re-writing in something else.
[18:25:59] <mrig> bjs: My point is that there are coders with that mind set always, that will be adverse to certain aspects of the aesthetics of language due to their nerdlove of the underlying concepts.
[18:26:07] *** Quits: vysn (~vysn@user/vysn) (Ping timeout: 258 seconds)
[18:26:15] *** Quits: silasfox (~silasfox@62.159.27.1) (Quit: Connection closed)
[18:26:15] <sandman13> I sometimes wish to retire as a farmer and never touch computers at all
[18:26:21] <mrig> I cant see that ever changing.
[18:26:28] <DPA> merijn: Because interfaces should be specified first, and multiple implementations allowed to be implemented independantly. It shouldn't be necessary to have an implementation to use an interface.
[18:26:31] <bjs> mrig: thankfully humans don't live too long
[18:26:32] <user51> mrig: whats 'underlying concepts'
[18:26:41] <mrig> user51: the matrices
[18:26:47] <mrig> the fundamentals
[18:27:39] <DPA> Who controls / designs an interface is important.
[18:27:51] <mrig> bjs: erm lineages of life go on for all known time :D
[18:28:13] <pyzozord> user51: sorry, I haven't been following the discussion, you guys are super chatty today :D
[18:28:22] <piou> pikapika: such dichotomy as "either you trust it fully or you shouldn't trust it at all" is irrational, unefficient and harmful. In a word, stupid.
[18:28:23] <user51> mrig: uh, i dont understand
[18:28:26] <DPA> And the lack of a provides dependency feature in cargo is really annoying.
[18:28:32] <user51> whats wrong with thinking about the fundamentals
[18:28:41] <bjs> mrig: thankfully you cannot inherit the particular features you are concerned about :)
[18:28:45] <bjs> they are learned
[18:28:46] <mrig> user51: what didn't you understand?
[18:29:00] <mrig> bjs: I disagree with that notion :)
[18:29:04] <bjs> all bad teachers are forgiven when their students die
[18:29:06] <bjs> :D
[18:29:12] <pikapika> piou, I am only placing the consequences of the attitudes people display about C here. If they truly believe its so dangerous then anything short of working full time toward bootstrapping a fresh infra is a mismatch of their actions to their beliefs.
[18:29:13] <mrig> some are way more logically minded than others.
[18:29:27] <piou> pikapika: that's in no way a logical consequence, that's just your hyperbole
[18:29:34] <pikapika> Its liek saying all day we are going to die of food shortage and then going about normally in your life instead of building farms etc
[18:29:37] <bjs> mrig: i'm just saying the next generation of programmers will hold onto the "nostalgia" of old technology a lot less
[18:29:37] <mrig> user51: what didn't you understand?
[18:29:58] <pikapika> piou, its not hyperbole. Hyperbole is coming from the irrational C haters.
[18:30:00] <user51> pyzozord: no worries.. just watch out for further alogirthmic bullshit. if you look at their python solution, you might see some problems.
[18:30:00] <sandman13> bjs: and write everything in JS.
[18:30:04] <piou> pikapika: if you need to go to the city 100km from there and the car can only
[18:30:06] <pyzozord> so that first problem was easy. But this next one with counting equi-leaders, is a bit toughter https://app.codility.com/programmers/lessons/8-leader/equi_leader/ couldn't find a solution yet. I think I found a O(n log n) but haven't managed to implement it well, the code got very messy
[18:30:07] <bayaz> Title: EquiLeader coding task - Learn to Code - Codility 
[18:30:09] <mrig> bjs the only way that you could achieve that is be stopping certain types of people from picking up programming.
[18:30:11] <piou> pikapika: if you need to go to the city 100km from there and the car can only take you 99km far doesn't mean that it's suddenly rational to walk the whole way and avoid the car totally*
[18:30:26] <mrig> that is unlikely to go on without some grave frowning :D
[18:30:28] <InPhase> merijn: Well when there's a small core, the standard library sets become essentially part of the core language in practice, even if not in definition.
[18:30:32] <akronymus> I can reasonably write a c compiler for a small subset of a language that will work. Then use that small subset to build up better and better compilers for the language.
[18:30:36] <sandman13> We have been churning code so much that nobody really knows what they are doing and have rndom problems
[18:30:37] <bjs> pikapika: things don't quite work that way,  it's good for people to want the next generation of programs and programmers to use better tools. That's natural, it's good.
[18:30:39] <piou> pikapika: just because something isn't perfect doesn't mean it's not worth using, but it does mean that something better can come out
[18:30:40] <sandman13> *random problems
[18:30:41] <akronymus> Until Ihave a fully featured one
[18:30:47] <pikapika> piou, but people here are claiming C is unreliable and dangerous. If its so dangerous and unreliable that means aything written in it is too. And that means the entirety of modern oses and programmin langiuages.
[18:31:04] <piou> pikapika: you're claiming similarly ridiculous things, don't act like that now
[18:31:09] <akronymus> I think most are saying that c makes it easy to shoot yourself in the foot.
[18:31:19] <user51> mrig:  adverse to certain 
[18:31:19] <user51>               aspects of the aesthetics of language due to their nerdlove of the underlying concepts.
[18:31:23] <user51> this part
[18:31:25] <pikapika> piou, thats not me. Thats people like bjs here.
[18:31:33] <bjs> pikapika: i haven't told anyone to stop using C
[18:31:34] <InPhase> merijn: Like Python is probaby fully learnable, but add in standard and common libraries, and definitely not.  They change fast enough that any person reasonably allocating their time cannot actually keep up, and it would be foolish to try.
[18:31:35] <akronymus> Not that it is inherently unreliable 
[18:31:47] <pikapika> bjs, then your actions don't match the severity of your beliefs.
[18:31:50] <mrig> pikapika: would you like to borrow my sharpening stones; I will trust you with them because I know that you will keep them flat?
[18:31:52] <bjs> pikapika: what actions?
[18:32:05] <pikapika> if C is so dangerous and full of pitfalls everywhere as you beleive, then how can you trust anything written in it?
[18:32:09] <bjs> I said that it's becoming clear that Rust will take over a chunk of the work that people reach for C/C++ today
[18:32:11] <piou> pikapika: you know that it's not all or nothing, stop acting like everyone's so illogical by spouting fallacies, it's annoying
[18:32:15] <bjs> pikapika: who said it was dangerous? I didn't
[18:32:23] <pikapika> ...
[18:32:25] <akronymus> mrig I wouldn't trust most people with my flat plates.
[18:32:27] <InPhase> pikapika: You shouldn't!  Encourage people to use more modern languages when security and reliability matter.
[18:32:28] <pikapika> All that talk about ub
[18:32:31] <sandman13> InPhase: can confirm. When it was Python 2.7, I knew various things about the language which are not applicable and outdated in Python 3.
[18:32:32] <pikapika> Are you forgetting it?
[18:32:52] <mrig> user51: some coders really dislike C++ for its aesthetic qualities and that of the code that is often written with it.
[18:32:55] <pikapika> InPhase, I am not the one saying we have to discard all of computing. I am fine with C, I am fine with Java, or C++ or Rust or modenr langs.
[18:33:03] <bjs> pikapika: yes a program with UB is dangerous
[18:33:12] <bjs> but a program with UB isn't a valid C program
[18:33:13] <akronymus> NOBODY here is saying to discard all computing
[18:33:14] <pikapika> I am just saying, discarding all of the existing infra is the natural consequence of the arguments peopel are making here
[18:33:22] <piou> but it's not
[18:33:23] <akronymus> How
[18:33:29] <piou> pikapika: that's in no way logical
[18:33:32] <pikapika> UB is everywhere
[18:33:35] <bjs> pikapika: None of the things you've attributed to me have been things I said
[18:33:38] <user51> mrig: ok. gonna write come c++, then.
[18:33:47] <akronymus> If you don't elaborate how, I'll have to file it under the fallacious use of the slippery slope pikapika
[18:33:50] <pyzozord> interesting thing about pushups is that at some point your body kind of wants you to do it, you get into the rythm. Wish I got that going for running again. Ah that was fun
[18:34:01] <pikapika> akronymus, bjs talking about UB here
[18:34:11] <mrig> user51: I am not commenting upon it myself, only stating what I have heard from some professionals. 
[18:34:18] <bjs> pikapika: well, yes and no.  The C standard doesn't graduate different levels of UB but clearly some UB will be worse than others
[18:34:19] <pikapika> If thats the case, and its fact that most programs of any practical size have a bunch of ub
[18:34:23] <sandman13> pikapika: How long have you been doing it? But generally I agree
[18:34:24] * mrig is still very much a learner.
[18:34:25] <pikapika> that means everything is invalid
[18:34:28] <bjs> e.g. bitwise arithmetic on pointers is just a fact of life for modern OS's even if technically UB
[18:34:31] <pikapika> sandman13, doing what?
[18:34:34] <akronymus> UB should definitely be reduced as much as possible.
[18:34:42] <sandman13> sorry pikapika it was meant for pyzozord 
[18:34:47] <ArtOfWar> I'm enjoying a delicious black coffee homebrew
[18:35:00] <bjs> pikapika: people writing C code with UB that do not understand what the compiler is actually doing can be quite dangerous though.  
[18:35:01] <user51> ArtOfWar: pics or it didnt happen
[18:35:22] * ArtOfWar shows in image of rancid colon-brew from Keurig 2.0
[18:35:24] <ArtOfWar> there you go.
[18:35:29] <bjs> pikapika: tools which help the programmer in that way, to either help them understand or to reduce the ability to get into these situations is something we want our future tools to do.
[18:35:35] <mrig> user51: I would have liked to have gotten started on C++ towards the end of the 90's
[18:35:36] <bjs> That doesn't mean we should throw away our current tools
[18:35:37] <piou> A knife is dangerous. It doesn't mean people shouldn't be using knives. It doesn't mean people should expect to die whenever they approach one. It does mean that if another way to perform the same task is safer then it is a good idea to privilege that way (eg: scisors). There is no logical consequence from "it's dangerous" to "you should never use it and if you do you're an hypocrite"
[18:35:53] <pikapika> piou, I am not making that argument. Others here aer.
[18:35:54] <akronymus> Being able to accidentally write UB gets in the way of me writing actually useful code.
[18:35:56] <bjs> pikapika: and it doesn't mean there aren't places you want/need tools like that (e.g. that bitwise arithmetic stuff, is important)
[18:35:57] <pyzozord> sandman13: I started about two months ago. I'm heavily overweight so bare with me :P I couldn't do more than 10 lousy pushups. Right now I can do 30 average pushups or, 22 super proper ones
[18:36:02] <bjs> pikapika: well you keep pointing at me, but I didn't.
[18:36:05] <user51> mrig: i wrote c, but c++ is backwards compatible for the most part iirc. i dont actually know c++ :P
[18:36:23] <piou> pikapika: you are. Stop acting like someone else's proposing that "you shouldn't use your C-based oses because that's hypocrite"
[18:36:28] *** Joins: rustyshackleford (uid236774@id-236774.brockwell.irccloud.com)
[18:36:34] <sandman13> To summarize: C has arrays. UB are a thing which programmers should know about. But C has many gotchas. That doesn't mean anyone should abandon everything and write everything from scratch
[18:36:36] <sandman13> let's move on
[18:36:38] <pikapika> Thats the natural consequence of the arguments
[18:36:38] <sandman13> xD
[18:36:38] <piou> Such fallacies do not help any debate, they're an insult to the intelligence of your interlocutor and drag things to the mud
[18:36:42] <mrig> user51: It is interesting for games and larger systems that are already coded with it.
[18:36:47] <pyzozord> sandman13: fun thing is after you push through the initial muscle acid and leter you just get a little bit of soreness all the time, it's not bothering but you just feel you have that muscle, that's cool :P
[18:36:52] <akronymus> And you are applying the slippery slope fallaciously
[18:36:58] <pyzozord> s/leter/later/
[18:37:00] <akronymus> pikapika
[18:37:01] <mrig> but the timing thing is atrocious.
[18:37:08] <piou> Frankly if your points are as good as you think they are you do not need any "all or nothing" fallacy to support them.
[18:37:18] <mrig> all the specification growth and knowing what was from when, that sort of thing.
[18:37:22] *** Quits: speckz (~speckz@2600:1700:ce0:bf00:893d:bb35:4f4d:5fa5) (Quit: Textual IRC Client: www.textualapp.com)
[18:37:23] <pikapika> Its not my points
[18:37:28] <bjs> pikapika: not at all.  Things are unsafe,  things can go wrong. That's a fact of life, it's a fact of engineering.  We try build better and safer tools so the next generation can do better
[18:37:37] <sandman13> pyzozord: I once tried 15 x 3 three times a day. It was hurtful. :(
[18:37:59] <mrig> The thought of C with concurrent code is frightening though.
[18:38:08] <mrig> Is that UB or a race condition?
[18:38:15] <bjs> mrig: depends^tm
[18:38:22] *** Quits: dr_bot (~dr_bot@cpe-24-209-62-187.neo.res.rr.com) (Quit: Leaving)
[18:38:23] <sandman13> mrig: It's easy. You just have to '#include <libev.h>' xD
[18:38:55] <sandman13> If you are concerned with threads, C11 has threads 
[18:39:01] <bjs> pikapika: but people need to understand UB and the languages they actually use to be able to build better languages.  People who *actually* know C (as in, really have internalised the spec and know how compilers work) are generally people who write lots of C in good places that it needs to be written but also push for new tooling 
[18:39:08] <user51> sandman13: try squatting
[18:39:12] <user51> very tiring
[18:39:13] <bjs> sandman13: but e.g. accessing a normal variable in both threads is UB
[18:39:15] <pikapika> sandman13, 15 pushups each time ?
[18:39:17] <bjs> hence atomics
[18:39:19] <mrig> sandman13: what does that do?
[18:39:21] <sandman13> user51: I do that but without any weights
[18:40:02] <sandman13> pikapika: 3 sets with 15 repettions. 3 times a day. In total 15 * 3 * 3
[18:40:08] <pikapika> Okay
[18:40:35] <sandman13> bjs: It's understandable :D
[18:40:37] <bjs> pikapika: those who are very zealous about how people should never use the language, or how everyone should use it for everything are in my experience (which is certainly not exhaustive, I've not met every programmer that ever lived...) are the ones who are a little less critical of their tools and generally don't really understand how they work as well
[18:41:22] <pikapika> I am not zealous about C. I like many languages. I just am increasingly finding that many of the C hate is based in irrational logic.
[18:41:37] <akronymus> Irrational according to you.
[18:41:45] <mrig> pikapika: ir
[18:41:47] <pyzozord> sandman13: gotta build up to it, like with the freaking competetive programming... I am so heavy that actually my joints weren't ready for it at first
[18:41:48] <mrig> ops
[18:41:49] <akronymus> And you don't strike me as the most rational person
[18:41:53] <sandman13> It's partly to blame to Rust evangelists. :P
[18:42:15] *** Joins: Hercules (~Hercules@user/hercules)
[18:42:30] <pikapika> I just take peoples arguments to their full conclusions. Its not my fault that the result horrifies them and wasn't what they were expecting.
[18:42:42] <bjs> pikapika: you mean you extrapolate out your own conclusions.
[18:42:56] <piou> pikapika: that's bullshit and I think you're smart enough to know it.
[18:43:01] <pyzozord> I think I would be able to do 15*3Â² either :P
[18:43:11] <bjs> pikapika: What you claimed I had said does not match at all with what I actually said, or my actions or my recommendations to other people using C
[18:43:15] <akronymus> pikapika then elaborate the steps of how you come to that conclusion
[18:43:25] <pikapika> Believing UB is so dangerous that the whole program can do anything means all programs are dangerous. Because practically some UB exists in any project of decent size.
[18:43:36] <bjs> pikapika: no that first line is pretty much exactly what the standard says
[18:43:42] <mrig> pikapika: human nature has somewhat the resemblance of a herd or pack omnivore; What on earth made you think that the process of programming would change this facet of our collective persona? :P
[18:43:56] <pikapika> Yes, and the conclusion would be that no large C project is usable.
[18:44:01] <akronymus> No.
[18:44:03] <bjs> pikapika: and yes I did say, I gave a good example of what is (currently? maybe WG14 will change it) is UB
[18:44:10] <bjs> pikapika: no I never said that, that's your own conclusion.
[18:44:10] <piou> 
[18:44:12] <akronymus> The conclusion is that there are risks to large c projects
[18:44:18] *** Quits: bytecrawler (~bytecrawl@gateway/tor-sasl/bytecrawler) (Ping timeout: 244 seconds)
[18:44:18] <LambdaComplex> anyone ever used couchbase before? i would like any and all opinions on it
[18:44:40] <pikapika> bjs, but if you believe the standard that any UB can lead to the program doing naything in the universe, and the fact that most projects have soem UB...the conclusion naturally follows.
[18:44:49] <bjs> pikapika: no it doesn't
[18:45:00] <pikapika> Then you don't beleive the first statement
[18:45:03] <bjs> I do
[18:45:07] <akronymus> The UB in practice is treated as impossible to occur.
[18:45:08] <bjs> I know it's true, i've seen it happen
[18:45:11] <piou> pikapika: the conclusion is that large C projects have risks, not that they're unusable. "Anything can happen" isn't the same as "Anything does happen"
[18:45:15] <pikapika> Then all programs are evil
[18:45:16] <akronymus> Thus it gets removed.
[18:45:23] <bjs> pikapika: suddenly programs have a morality?
[18:45:29] <piou> pikapika: again, you're just fallacies all the way down
[18:45:32] <pikapika> evil as in dangerous/incorrect
[18:45:47] <akronymus> Can you tempblock someone?
[18:45:54] <bjs> pikapika: I mean almost all programs are incorrect, anyone who's done any testing knows that
[18:45:55] <pikapika> piou, theres no fallacy. I am just properly drawing conclusions from your arguments.
[18:46:00] *** Quits: amahl (~amahl@dsl-jklbng12-54fbca-64.dhcp.inet.fi) (Ping timeout: 268 seconds)
[18:46:02] <sandman13> akronymus: /ignore <nick>
[18:46:03] <bjs> even the CPU i'm using to talk to you right now has bugs in it
[18:46:06] <piou> pikapika: no your not
[18:46:07] <bjs> (I know, I've found some myself!)
[18:46:13] <piou> pikapika: and that's been demonstrated formally before
[18:46:16] <akronymus> sandman13 Only temporarily not permanently
[18:46:26] <pikapika> Formal proof?
[18:46:31] <pikapika> Ok show me, mr mathematician
[18:46:33] <piou> pikapika: your "reasonning" is full of holes and hyperboles
[18:46:33] <pikapika> lmfao
[18:46:36] <pikapika> lmfao
[18:46:38] <sandman13> akronymus: You can revert that command some times later.
[18:46:45] <akronymus> Oh fair nuff.
[18:46:53] <akronymus> I'd rather not have to remember that though
[18:47:09] <piou> 16:15  piou> pikapika: the conclusion is that large C projects have risks, not that they're unusable. "Anything can happen" isn't the same as "Anything does happen" -> you've yet to fill that hole up
[18:47:17] <piou> But frankly IÂ don't care at this point
[18:47:22] <LambdaComplex> yes, all programs are evil. we should all turn our computers off and buy some goats
[18:47:23] <sandman13> akronymus: IRC doesn't have that provision IIRC. Try Slack/Discord/Twitter :P
[18:47:26] <pikapika> Thats what you said, not what the others were saying
[18:47:26] * LambdaComplex will make the cheese
[18:47:39] <bjs> pikapika: Look, I'll tell you that I am a little concerned about C programs and their safety (and especially their security implications) because I know how hard it is to get that right and how easily and how badly it can go wrong.  I know about UB and what its limits are and what the standard says but also what the compilers are actually likely to do in various cases
[18:47:40] <sandman13> LambdaComplex: Exactly my thought.
[18:47:50] <akronymus> sandman13 eh, I prefer IRC tbh.
[18:47:57] <akronymus> Just would be a nice to have, I guess.
[18:48:01] <pyzozord> mm goat cheese. It took me few years to convert to goat cheese but now I find it cheesier and thus better
[18:48:06] <pyzozord> more cheesy
[18:48:14] <LambdaComplex> weechat's smart filter > /ignore
[18:48:29] <pikapika> They were treating the spec definition as what real compilers would do in practice. As if encountering the faintest hint of UB, real compilers like gcc just take it as a hint that according to the spec, I can do anything now and then delete your os and launch nukes everywhere.
[18:48:30] <LambdaComplex> pyzozord: i honestly don't know if i've ever had any. maybe i should look next time i'm at the  store
[18:48:34] <bjs> pikapika: I'm not going to sit there and say that C is wonderful and the best ever, it's clearly not.  I'm not going to say RUst fixes everything, it obviously doesn't.  But languages evolve through incremental improvements.
[18:48:44] <pikapika> bjs, nobody would disagree
[18:48:52] <pyzozord> LambdaComplex: old gold goat cheese man, it's like crack!
[18:48:54] <pikapika> That C (or any other language) has security problems
[18:48:56] *** Quits: repne_scasb (inhahe@107-213-219-122.lightspeed.miamfl.sbcglobal.net) ()
[18:49:01] <pikapika> And that people should be working torwad fixing them
[18:49:03] *** Joins: v0id_ptr (~longlong@user/ptr-frac7al/x-0038398)
[18:49:03] <sandman13> bjs: ur wrong /s
[18:49:13] <pikapika> with whatever tools, whether static analysis, or trying to create better langs etc
[18:49:18] *** Joins: repne_scasb (inhahe@107-213-219-122.lightspeed.miamfl.sbcglobal.net)
[18:49:35] <bjs> pikapika: UB is clearly a big issue in C programs, and a lot of effort is spent in avoiding it. Languages that turn UB into detectable (compiler or runtime) errors is a huge advancement
[18:49:45] <sandman13> C is an old language, made some mistake during architectural design. But the ship has sailed.
[18:49:48] <akronymus> I blocked pikapika for now, to force myself to disengage from this. Maybe at another time we can have a productive instead of destructive discussion. Nothing against him, just I know that I will keep engaging otherwise.
[18:49:48] <bjs> Now of course, not all UB were created equal
[18:49:58] <bjs> (even if the standard treats them equally)
[18:50:18] *** Quits: gambl0re (~gambl0re@24.140.237.124) (Ping timeout: 268 seconds)
[18:50:19] *** Joins: davros (~davros@host86-184-180-96.range86-184.btcentralplus.com)
[18:50:23] <pikapika> Most UB is just paltform specific behaviour. Like right shifts.
[18:50:28] <bjs> pikapika: you really do not want UB in your C programs except in places where you really need it
[18:50:31] <sandman13> Compiler usually warns about common ones though
[18:50:52] <pikapika> So the logical thing for a compiler to do would be to just do the platform specific thing in those cases. And in cases where UB was because of something illogical the programmer did, place a warning.
[18:50:55] <bjs> pikapika: well yes and no, there are a variety of reasons that things are UB and a lot of them are just assumptions to the optimizer.
[18:50:56] <pikapika> bjs, indeed
[18:51:05] *** Quits: TheAceOfHearts (~TheAceOfH@24.41.239.76) (Quit: So long, and thanks for all the fish!)
[18:51:12] *** Joins: mci64 (~mci64@194.25.223.4)
[18:51:33] <edk> very few C programs need any UB at all
[18:51:42] *** Joins: gambl0re (~gambl0re@24.140.237.124)
[18:52:18] <pikapika> edk, signed addition can invoke ub
[18:52:31] <bjs> edk: Yeah,  sadly there are places where UB crops up and you cannot really avoid it.
[18:52:36] <pikapika> All I mean is that ub is various things
[18:52:45] <edk> bjs: the only one of those i have ever seen was a data race, of all things
[18:52:59] <bjs> edk: OS's contain some because of just the nature of the OS
[18:53:01] <pikapika> Dereferencing weird memory is UB and also something anyone with a sane mind should avoid because it obviously is wrong
[18:53:16] <bjs> edk: (forging pointers, bitwise arithmetic on pointers, asm that interacts with C machine etc)
[18:53:19] <edk> i'm unconvinced that the things OSs do involve any UB
[18:53:23] <edk> all that stuff is IDB
[18:53:24] <pikapika> signed addition can invoke ub, but theres no reason to avoid it. Any sane compiler should just emit whatever the normal addition instructions are for that platform.
[18:53:25] *** Joins: nekodesu (~nano@user/nekobit)
[18:53:42] <bjs> edk: I think bitwise arithmetic is just UB
[18:53:50] <Twix> eeh .. no
[18:53:51] <pikapika> bjs, flags aren't ub
[18:53:55] <bjs> flags?
[18:53:56] <edk> on pointers it's just a constraint violation
[18:54:01] *** Quits: v0id_ptr (~longlong@user/ptr-frac7al/x-0038398) (Ping timeout: 268 seconds)
[18:54:04] <pikapika> bjs, a common use of bitwise arithmetic
[18:54:09] <pikapika> is to pack a bunch of bools inside an int
[18:54:17] <bjs> pikapika: I'm not saying that all bitwise arithmetic is UB
[18:54:30] <bjs> I'm saying that I think doing bitwise arithmetic on one pointer to get another pointer is UB, I think
[18:54:37] <pikapika> Oh of coures
[18:54:42] <edk> i am fairly sure it is not
[18:54:45] <pikapika> I would never touch the insides of a pointer
[18:54:55] <bjs> edk: hmm, I thought it was.  I'd have to go look at the standard again
[18:55:30] <pikapika> in that I don't know if its ub or not, but its obviously something I don't do
[18:55:42] <akronymus> Bitwise arithmetic on pointers could be used to implement calling a certain function based on some flags.
[18:55:51] <akronymus> If you treat part of the pointer as a bitfield.
[18:56:04] <pikapika> and the rest as a function pointer?
[18:56:09] <akronymus> But then you need to ensure that it is aligned.
[18:56:19] <akronymus> Which seems rather scary to me.
[18:56:20] *** Quits: rsx (~dummy@ppp-188-174-141-119.dynamic.mnet-online.de) (Quit: rsx)
[18:57:53] *** Quits: delial420 (~delial@47.185.98.253) (Quit: Leaving)
[18:58:24] <sandman13> merijn: You seem to have your own Vim color named "delph". Mind sharing the screenshot?
[18:58:47] <edk> bjs: converting the integer back to a pointer is either IDB or just well-defined (the latter if your integer happens to be one you got by converting a pointer to (u)intptr_t)
[18:59:13] <merijn> tbh, it's something I need to redone. It's basically a copy of "what default vim in PuTTy looked like" :p
[18:59:34] <merijn> sandman13: because I hate change :p
[19:01:08] <|smlckz|> beaky: do you know about this project? seems really interesting https://github.com/uwu-tech/Kind/
[19:01:12] <sandman13> merijn: I see. It's hard to have a uniform theme across editors. Despite using same colorscheme, Vim and Emacs have different coloring for same source file :(
[19:01:14] <bjs> edk: I'm pretty sure that any attempt to use the created pointer is UB
[19:01:25] <akronymus> merijn just let some emacs user set the keybindings in vim for oyu. /s
[19:01:46] <bjs> edk: Oh yeah obviously it's implemention defined what value the number has once you cast, and you can forge and get pointers. It's just UB to dereference them. But obviously for an OS that dereferencing is the important part. :P
[19:02:10] *** Joins: ixil (~ixil@mpp-cp1-natpool-1-236.ethz.ch)
[19:02:24] *** Quits: kurtthemaker (~kurt@S010644a56e3e0ee9.cn.shawcable.net) (Quit: leaving)
[19:02:35] <bjs> e.g. a common thing for an OS to do is flip a bit on an address to turn into a "kernel" address and then access the C object through the new pointer
[19:02:39] <bjs> which it has to do because of e.g. virtual memory
[19:03:09] *** Joins: salitos (~salitos@102.167.250.80)
[19:03:11] <sandman13> Looks like Google had a meeting to add banners related to BLM on every programming project of theirs 
[19:03:37] <sandman13> But uBlock Origin to the rescue.
[19:03:58] <sandman13> I never knew what RE2 syntax had to do with US politics
[19:04:05] <akronymus> Urgh, I hate political messaging shoved down my thrat
[19:04:05] <LambdaComplex> i just went to google.com
[19:04:07] <akronymus> throat
[19:04:08] <LambdaComplex> >Introducing YouTube Shorts: Watch and create your own short videos
[19:04:13] <LambdaComplex> guess they're trying to get in on that tiktok money
[19:04:25] * LambdaComplex looks at prozd
[19:04:28] <akronymus> Shorts have been there a while.
[19:04:32] <LambdaComplex> yeah people could already make short videos and they were already great
[19:04:33] <sandman13> akronymus: It's annoying cause US politics doesn't affect me at all
[19:04:39] <akronymus> Thankfully vanced has the ability to block em
[19:04:48] <akronymus> sandman13 i am not from the US either.
[19:05:01] <pikapika> Then don't use an american product
[19:05:03] <sandman13> LambdaComplex: Everybody including their grandmas are doing that kind of thing
[19:05:06] <akronymus> For example, the f# conference last year mentioned blm every halfhour.
[19:05:06] <ArtOfWar> I'm missing like Bin Laden
[19:05:17] <pikapika> I mean I am just saying they are an american company who are directly affected by american happenings
[19:05:18] <akronymus> Which quite frankly made me not watch it.
[19:05:20] <sandman13> ArtOfWar: /usr/bin/laden ?
[19:05:26] <pikapika> so they have a right to include whatever messaging they want
[19:05:27] <ArtOfWar> (sed,awk)
[19:05:29] *** Quits: w0ng (~w0ng@185.218.127.38) (Ping timeout: 260 seconds)
[19:05:30] <ArtOfWar> fuck perl_mod
[19:05:42] <akronymus> And then there are the double standards surrounding blm
[19:05:48] <akronymus> But /topic
[19:05:55] <pikapika> What double standards?
[19:06:00] <akronymus> Don't wanna get TOO political
[19:06:46] *** Quits: nekodesu (~nano@user/nekobit) (Quit: free(neko);)
[19:06:55] <sandman13> NewPipe is good on Android as Youtube alternative
[19:07:13] <sandman13> Just RSS and querying APIs, works for most my usage.
[19:07:21] <DnzAtWrk> thought rss died
[19:07:31] <akronymus> Why would it?
[19:07:37] <sandman13> DnzAtWrk: It didn't. And it's quite good
[19:08:47] *** Joins: BrianG61UK (~BrianG61U@2a02:8010:66b7:dddd:2024:c01e:796c:31e9)
[19:09:39] <sandman13> pikapika: I am just saying it's annoying to see it. I hate being pestered.
[19:09:46] *** Quits: Hercules (~Hercules@user/hercules) (Quit: Leaving)
[19:10:35] <pikapika> Its an american company, their employees are americans. Whom would be directly affected by any happeings in the nation. A picture or cartoon on the google logo is a non-issue for me.
[19:11:15] <sandman13> Show where it is relevant. Not on some dev site.
[19:11:46] <pikapika> As I said, just a picture or cartoon in the corner is a non-issue.
[19:11:58] <pikapika> I have never felt any issue from those
[19:12:48] <sandman13> pikapika: first thing after title and with a font that is larger than anything: https://github.com/google/re2/wiki/Syntax
[19:13:20] *** Quits: user51 (~user51@176.228.90.248) (Ping timeout: 268 seconds)
[19:13:26] <pikapika> Its just a text not even a photo in this case. Even less an issue.
[19:13:51] *** Quits: pandakekok9 (~job@wikimedia-commons/pandakekok9) (Remote host closed the connection)
[19:14:40] <sandman13> annoying, has no relevance to the subject matter in hand. That's all.
[19:15:30] <pikapika> Do you also find it annoying if people wear t-shirts with slogans on them
[19:15:40] <pikapika> its the same tier, much less prominent at that
[19:15:47] <pikapika> and not really a political thing either at that
[19:16:31] <sandman13> Yup. Distracting. 
[19:16:47] <pikapika> Ok, never been a problem for me
[19:16:51] <karstensrage> that seems like virtue signaling
[19:16:59] *** Joins: freakazoid333 (~matt@2603:9000:cf0f:80e3:f0f5:3ffa:9db3:f715)
[19:17:04] <pikapika> Everything is virtue signalling
[19:17:09] <pikapika> Everyone does it
[19:17:59] <karstensrage> well thats an extreme example, its pointless at the least
[19:18:10] *** Joins: contagious_meow (~salitos@197.156.137.171)
[19:18:24] <pikapika> Its not about pointless or not, virtue signalling is basically most of human communnication
[19:18:34] <pikapika> Its an inherent part of how we communicate
[19:19:09] <karstensrage> well maybe you have a different definition of "virtue signaling" for example right now as we are "communicating" i dont call any of this virtue signaling
[19:19:39] <pikapika> Everyone communicates their alliances directly or indirectly. Its in subtle things like clothing and mannerism to direct sloganeering and words.
[19:19:59] <pikapika> And "alliances" are wrt everything not just politics
[19:20:09] *** Quits: salitos (~salitos@102.167.250.80) (Ping timeout: 248 seconds)
[19:20:15] <sandman13> It's empty talk tbh
[19:20:18] <pikapika> The thing with irc is that we are only a name
[19:20:30] <pikapika> and talk outside of programming is discouraged here
[19:20:37] <pikapika> so we don't see much of that directly
[19:20:41] <karstensrage> the topic has community chat
[19:20:59] <pikapika> karstensrage, in fact
[19:21:11] <pikapika> You already virtue signalled by stating you dont like so called "virtue signalling"
[19:21:20] <karstensrage> so what unless your nick is subjectively controversial i never think anything of nicks
[19:21:21] <pikapika> That in itself is a virtue signal to your alliance
[19:21:26] <karstensrage> lol
[19:21:49] <karstensrage> you dont use the standard definition of what virtue signaling is
[19:22:00] <karstensrage> that makes communicating these specific issues very difficult
[19:22:15] <pikapika> Thats all it really is. You virtue signalled you have more in common with the current right wing.
[19:22:26] <karstensrage> what?
[19:22:43] * sandman13 grabs popcorn
[19:22:55] <pikapika> Its usually the current right wing who say they don't like so called "virtue signalling" which ironically itself is a virtue signal to their fellows.
[19:23:13] <pikapika> Of course I could have misread, just as you could have misread blm sloganeering as a "virtue signal"
[19:23:45] *** Joins: amahl (~amahl@dsl-jklbng12-54fbca-64.dhcp.inet.fi)
[19:23:59] <pikapika> A "virtue signal" is just a signal of your alliance/identity
[19:24:15] *** Quits: mci64 (~mci64@194.25.223.4) (Quit: Connection closed)
[19:25:07] <karstensrage> wow you are making quite a few really out there assumptions
[19:25:18] <karstensrage> where did i say "i dont like virtue signaling"
[19:25:57] <karstensrage> irc is a difficult medium over which to commuinicate but dont read things that literally arent there
[19:25:57] *** Joins: YHVH (~yhvh@2601:982:8300:8090:4d87:c05e:6cd6:94a1)
[19:26:10] <pikapika> Then what else is the point of mentioned some act is a "virtue signal" when its just an inherent part of most human communication
[19:26:22] <karstensrage> its not that my argument
[19:26:24] <pikapika> That would imply you dislike it
[19:26:28] <karstensrage> and the point is to point it out
[19:26:35] <karstensrage> thats all
[19:26:56] <karstensrage> its not an inherent part of most communication
[19:26:59] <pikapika> I see. It'd be very tiresome for me to point out something thats happening almost all the time in most communication.
[19:27:25] <karstensrage> yeah you seem to have these weird "virtue signalling" glasses that see it everywhere, i dont
[19:27:39] <pikapika> It is. Its all there is. If you wear a suit to a company thats a virtue signal, if they expect you to be causals thats also a virtue signal. Everything is virtue signalling.
[19:27:44] <karstensrage> maybe consider that others have valid viewpoints that you dont have
[19:27:46] <akronymus> I, thankfully, have NO idea what is going on.
[19:27:50] <pikapika> Virtue signals are just signals of alliance/group
[19:28:22] <pikapika> If you wear a sport team shirt, thats a virtue signal
[19:28:26] <pikapika> it signals your alliance with the team
[19:29:00] <mrig> standard bearers, all love a good fight.
[19:29:04] <karstensrage> maybe google virtual signalling to see what the standard definition is before you apply the term to everything
[19:29:14] <mrig> got to be on the good side though :)
[19:29:23] <karstensrage> any way this is getting stupid
[19:29:27] <pikapika> "the action or practice of publicly expressing opinions or sentiments intended to demonstrate one's good character or the moral correctness of one's position on a particular issue."
[19:29:34] <karstensrage> its like saying eveyrthing is blue by redefining blue
[19:29:36] <mrig> I see the virtue in programming :) will keep at it.
[19:29:51] <pikapika> So its a signal of ones position or alliance
[19:30:04] <mrig> sandman13: salted or sweet? :p
[19:30:05] <pikapika> And nobody wants to think what they are doing is unvirtuous
[19:30:09] <pikapika> So its all virtue signalling
[19:30:21] <karstensrage> k
[19:30:24] <karstensrage> good luck with that
[19:30:27] <karstensrage> im done
[19:31:10] <pikapika> Do you want to signal you are unvirtuous?
[19:31:12] <edk> bjs: i was just in a meeting, but dereferencing those pointers is only UB if they don't point to valid objects, and i think it's basically up to the implementation whether they are
[19:31:32] <mrig> dang it is tricky to decide where to put ones logic, in which stage of a lexer.
[19:31:33] <pikapika> Even many nazis think they are actually doing good
[19:31:43] <pikapika> Most people think they are doing good
[19:31:49] <mrig> I keep forgetting where I'm at an adding it to the wrong stage ...
[19:31:59] <bjs> edk: no I think it's UB anyway,  you cannot e.g. forge a pointer out of thin air (or from an unrelated object) then use that to update another object.  That has to be UB because the compiler _has_ to be able to assume writes to non-volatile unrelated pointers don't update other objects
[19:32:18] <edk> bjs: like the definition would usually be that there's a memory-mapped register at 0xabcdefga and one might as well interpret that as saying there's an object
[19:32:18] <pikapika> You are "done" because you were using a bullshit meaning and were called out on it
[19:32:20] <edk> i don't think it can
[19:32:21] <bjs> I can't see any way that you don't get UB doing this,  unless you happen to be within the same object.
[19:32:25] *** Quits: chomwitt (~chomwitt@ppp-2-85-147-24.home.otenet.gr) (Ping timeout: 248 seconds)
[19:32:58] <bjs> edk: I'm not sure if that case is UB, since there is no corresponding C object really
[19:33:08] *** Quits: BrianG61UK (~BrianG61U@2a02:8010:66b7:dddd:2024:c01e:796c:31e9) (Quit: Leaving)
[19:33:09] <bjs> But I'd have to read the standard (and I... hate reading the standard)
[19:33:21] *** Quits: BrianG61UK_ (~BrianG61U@2a02:8010:66b7:dddd:9882:5d69:12df:2a8c) (Quit: Leaving)
[19:33:28] <edk> C doesn't say that only C can create objects, i don't think
[19:33:35] <mrig> fira mono is quite nice, any takers?
[19:33:35] *** Quits: merijn (~merijn@83-160-49-249.ip.xs4all.nl) (Ping timeout: 258 seconds)
[19:33:47] <bjs> edk: can you just forge a pointer and that creates an object?  I really don't know
[19:33:54] <pyzozord> can someone tell if there is more concise way of writing Array.from({ length: 10 }, () => -1) in javascript?
[19:34:06] *** Joins: snake (~snake@user/snake)
[19:34:08] <edk> the implementation's view might be that the object is always there
[19:34:08] <pyzozord> that's too much typing
[19:34:18] <bjs> edk: but what is the *standards* view of the operation
[19:34:32] <mrig> pyzozord: what is all this => business about ??? :p
[19:34:37] <bjs> edk: clearly an implementation has to do the right thing here otherwise no kernel would work :P
[19:34:40] <akronymus> Thats a lambda mrig
[19:34:42] <edk> the standard doesn't care, it just specifies what an object is and how you can point to its own objects
[19:34:46] <akronymus> Basically a function without a name
[19:34:55] <mrig> akronymus: I thought it was an abbreviation of function?
[19:35:02] <akronymus> In this case, it just returns -1 while taking no parameter
[19:35:03] <edk> it just doesn't say no other object can ever exist, or that you can't get valid object pointers by doing some implementation thing
[19:35:28] <bjs> edk: I can't see any way the standard can't say this is UB
[19:35:47] <edk> the relevant thing the standard thinks is UB is dereferencing a pointer that doesn't pointer to an object
[19:35:57] <mrig> dang this big greasy smudge in the middle of my screen has been bugging me for days, time to get rid of it!
[19:35:59] <bjs> edk: uh no sorry, I can see why it's not UB, the other is definitely got to be UB
[19:36:18] *** Joins: scabby_ (~scabby@user/scabootssca)
[19:36:22] <bjs> edk: but C is more complicated than that, because where the pointer comes from is important
[19:36:34] <bjs> you cannot e.g. have `int x; int y;` then use a pointer to x to get a pointer t oy.
[19:36:49] <edk> well sort of
[19:36:56] *** Joins: dan01 (~dan01@2a02:2f09:381b:db00:f560:a206:5dad:f3e)
[19:37:07] <edk> you can't make such a pointer point to y just by usign pointer arithmetic
[19:37:13] *** Quits: mobidrop (~mobidrop@user/mobidrop) (Remote host closed the connection)
[19:37:19] <bjs> edk: assuming they're not within the same larger object I mean
[19:37:35] <bjs> edk: but you also can't cast to int, do some arithmetic then turn it back into a pointer to y.
[19:37:50] <edk> i'm not sure that is true
[19:37:58] <bjs> The compiler *has* to be able to assume that code that takes a reference to x and does some pointery things can't affect y
[19:38:02] <bjs> otherwise most of the optimizations are bunk
[19:38:18] <edk> if you only do pointery things yes
[19:38:49] *** Quits: scabby (~scabby@user/scabootssca) (Ping timeout: 248 seconds)
[19:38:52] <pyzozord> mrig: that's a closure function defining a value for each item in the array it has full form () => { return -1 } but you can ommit curlies and return if you got just a value
[19:38:58] <edk> but imagine you have some setup like: int a = 0, b = 0; uintptr_t p = (uintptr_t)&a; while (p != (uintptr_t)&b) p++; *(int *)p = 1;
[19:39:41] <akronymus> Anonymus functions are amazingly useful.
[19:40:13] <bjs> edk: I think the equality might save you, but I'm not even convinced that's not UB
[19:40:15] <bjs> :P
[19:40:15] <akronymus> For example, map takes one function that takes 1 value and returns 1 value and a collection of values and it returns a new collection of value.
[19:40:21] <edk> assuming i didn't make any mistakes, which is definitely not a safe assumption at all, that's identical to just setting p = (uintptr_t)&b
[19:40:35] <akronymus> It gets the new collection by applying the function to each element of the collection.
[19:40:49] <bjs> edk: I'm not convinced, all of this stuff is why Linux has to turn of aliasing analysis
[19:41:02] <akronymus> Anyways g2g
[19:41:05] <|smlckz|> edk, what if the compiler reserves space such that (uintptr_t)&a > (uintptr_t)&b ?
[19:41:12] *** Joins: compscipunk (~compscipu@107-214-234-232.lightspeed.sndgca.sbcglobal.net)
[19:41:15] *** Quits: akronymus (~akronymus@85.31.8.181) (Quit: Client closed)
[19:41:19] <edk> |smlckz|: unsigned integers wrap around
[19:41:39] <edk> bjs: they turn off strict aliasing because they like to do type punning; that's different
[19:42:01] <edk> this is the whole reason C added `restrict`
[19:42:07] <|smlckz|> ''undefined behaviour''..
[19:42:20] <mrig> pyzozord: looks pretty concise!
[19:42:27] <edk> unsigned integer wraparound is not overflow so not UB
[19:42:59] *** Joins: gitgood (~gitgood@80-44-15-108.dynamic.dsl.as9105.com)
[19:43:02] <|smlckz|> ?
[19:43:36] <pyzozord> mrig: nah, so much typing... too fat fingers...
[19:44:00] <pyzozord> I like pythons way [-1] * 40
[19:44:04] <pyzozord> now that's concise
[19:44:09] *** Joins: nekodesu (~nano@user/nekobit)
[19:45:39] <mrig> Oh does that declare and array?
[19:45:48] <mrig> the JS
[19:46:03] <pyzozord> yeah, js it's annoying like that
[19:46:33] *** Joins: DushyantBaweja_c (uid510682@id-510682.charlton.irccloud.com)
[19:46:36] <beaky> hello my name is beaky
[19:47:12] <pyzozord> mrig: actually, this made me look up the mdn docs
[19:47:17] <beaky> what are some things that were uncommon in programming until very recently things like source control or docker for example
[19:47:21] <|smlckz|> [re] beaky: do you know about this project? seems really interesting https://github.com/uwu-tech/Kind/
[19:47:34] <pyzozord> mrig: i've been putting up to long with that ugly idiom
[19:47:53] <mrig> pyzozord: I thought that using maps for everything was the JS way?
[19:47:59] *** Joins: freakazoid343 (~matt@2603:9000:cf0f:80e3:455c:99e1:5db:1889)
[19:48:17] *** Quits: gambl0re (~gambl0re@24.140.237.124) (Ping timeout: 268 seconds)
[19:48:30] <mrig> Are arrays perhaps for more concise declarations?
[19:48:49] <beaky> woah 
[19:48:56] <beaky> haskell with dependend types
[19:49:04] <edk> beaky: control flow statements
[19:49:06] <edk> syntax
[19:49:34] <edk> letters, numbers
[19:49:45] <pyzozord> mrig: I guess I can do new Array(10) but the weird thing about that is that there are no actual elements yet, just "slots"
[19:50:02] <sandman13> mrig: Usually no flavor at all
[19:51:58] <pyzozord> mrig: the only annyoing thing about is that if I do const arr = (new Array(10)).fill({ foo: 'bar' }); arr[0].foo = 'baz'; then all elements will have foo: 'baz'
[19:52:10] *** Quits: freakazoid333 (~matt@2603:9000:cf0f:80e3:f0f5:3ffa:9db3:f715) (Ping timeout: 272 seconds)
[19:52:17] <pyzozord> and besides that idiom is even longer than the first one
[19:52:31] <pyzozord> but I guess I can just new Array(10) for immutable types, that works well
[19:53:27] <pyzozord> well, no that's too much worrying then... Once again this idiom has defeated me :(
[19:55:37] *** Quits: Joanna (uid57472@id-57472.tooting.irccloud.com) (Quit: Connection closed for inactivity)
[19:56:51] <|smlckz|> beaky: i am wondering about proved web apps written in that language, i.e. no bugs*
[19:57:02] <|smlckz|> * not really, but imagine
[19:58:56] <mrig> sandman13: metaphorical popcorn with a higher level of abstraction of condiments.
[20:00:24] <beaky> yes that was one of the ideas behind ur/web a software framework for web applications featuring row polymporphic types for the values in the web app so that everything from database to form handler to client is treated in a precise and sound manner preventing things like sql injection or invalid form values breaking the web handler
[20:01:00] <DnzAtWrk> what is the difference between using CUDA only, and using CUDNN
[20:01:07] <DnzAtWrk> why are those two options
[20:01:13] <DnzAtWrk> when compiling this machine learning framework
[20:01:17] <beaky> nice wish i had an nvidia gpu just so i could use cuda the future of parallel programming
[20:01:48] <|smlckz|> this would be interesting in wasm, but js and browsers [ axioms ] can break in so many ways..
[20:02:44] *** Quits: interop_madness (~interop_m@user/interop-madness/x-0950004) (Quit: Leaving)
[20:04:05] <sandman13> mrig: Nope. I like it without any flavor.
[20:05:52] *** Joins: merijn (~merijn@83-160-49-249.ip.xs4all.nl)
[20:07:01] <mrig> pyzozord: oh I was just reading about ArrayBuffers, i'd no idea that javascript had this sort of thing now.
[20:09:47] <|smlckz|> YDKJS, y'know
[20:10:57] *** Quits: merijn (~merijn@83-160-49-249.ip.xs4all.nl) (Ping timeout: 245 seconds)
[20:12:08] *** Joins: AbleBacon (~AbleBacon@user/AbleBacon)
[20:12:23] <d3x0r> DnzAtWrk I found tensorflow.js worked well; npm install'ed and it came with modules that could use my GPU without installing a runtime
[20:12:49] <d3x0r> arraybuffers are sexy - they're just a pointer and a length 
[20:13:06] <d3x0r> they can be allocated in other heaps... and shared between JS threads (workers)
[20:13:37] <d3x0r> sack.vfs provides a mapFile( "filename" ) that returns a arraybuffer to the file (meant to be readonly)
[20:13:45] <bjs> edk: sorry for the delay, here's a little classic C pointer example https://bpa.st/AKRQ  on my GCC 9.3.0 with -O2 I get the fun output shown in the paste
[20:13:46] <bayaz> Title: View paste AKRQ 
[20:15:38] <bjs> edk: the compiler has reasoned that *p cannot alias with y and so has just propagated the constant `2` into the printf. Although you are right, -fno-strict-aliasing doesn't affect this behaviour
[20:16:43] <bjs> Also note it is possible for two pointers to have the same numeric value but be unequal,  I am just lucky here that `==` gave the right answer 
[20:16:51] <bjs> (or wrong? answer)
[20:17:32] <DnzAtWrk> I wish linux would be more modern
[20:17:40] <DnzAtWrk> it could have things like, progress bars when copying files from usb
[20:17:42] <DnzAtWrk> future tech
[20:18:43] <sandman13> DnzAtWrk: Kernel cannot do it xD
[20:18:45] <JanC> what has the kernel to do with the UI?
[20:19:51] <mrig> progress bars will inevitably be either totally inaccurate, else really slow down the process.
[20:20:06] <GeDaMo> DnzAtWrk: https://linux.die.net/man/1/bar
[20:20:07] <bayaz> Title: bar(1): data transfer - Linux man page 
[20:20:11] *** Quits: contagious_meow (~salitos@197.156.137.171) (Read error: Connection reset by peer)
[20:20:28] <edk> bjs: i don't think pointers have a numeric value
[20:20:33] *** Quits: dan01 (~dan01@2a02:2f09:381b:db00:f560:a206:5dad:f3e) (Read error: Connection reset by peer)
[20:21:33] <edk> bjs: anyway, i note that 
[20:21:35] <edk> oops
[20:21:44] <GeDaMo> Pointers are memory addresses which are just numbers
[20:21:50] <edk> patent nonsense
[20:22:02] <edk> bjs: anyway, i note that exchanging lines 9 and 10 fixes the bug, as does a while loop like i used
[20:22:13] <mrig> If you have to parse the whole thing twice to get the start size it will take twice as long to transfer :|
[20:22:32] <DnzAtWrk> jesus I hate linux
[20:22:36] <DnzAtWrk> it's such a time-sink
[20:22:41] <mrig> :)
[20:22:47] <DnzAtWrk> it's like a bloody rabbit hole
[20:22:51] <DnzAtWrk> just goes deeper and deeper and deeper
[20:23:07] <edk> bjs: so gcc may be correctly reasoning that since you haven't yet converted y to an integer you can't possibly be "cashing in" the result of that to get y
[20:23:10] <pulse> linux is like sugar, great in small doses
[20:23:15] <DnzAtWrk> install older nvidia drivers, figure out how to unload old nvidia drivers
[20:23:34] <mrig> DnzAtWrk: you are really supposed to enjoy it, which distro are you using?
[20:23:39] <sandman13> modprobe -r <driver>
[20:24:24] <DnzAtWrk> old version of ubuntu still in boot menu
[20:24:30] <DnzAtWrk> good job, that's totally what overwrite means
[20:24:39] <bjs> edk: well here I have a program, whose only "ill behaviour" is to do some arithmetic to get from a pointer to one object to a pointer to another, and gcc is doing a perfectly sensible optimization
[20:24:58] <edk> because the letter of the rule about converting back from uintptr_t doesn't apply to it
[20:24:59] <sandman13> DnzAtWrk: Did you update grub?
[20:25:34] <bjs> edk: I mean sure I can see what gcc is doing and why swapping lines makes it stop.  But that's the nature of UB.
[20:25:39] *** Joins: user51 (~user51@176.228.90.248)
[20:25:46] *** Quits: user51 (~user51@176.228.90.248) (Client Quit)
[20:25:49] <edk> i mean, your program has UB anyway
[20:25:55] <bjs> edk: where
[20:26:02] <sandman13> I used to think Linux was time sink but when you try to develop on other OSes or know their privacy instance, you begin to admire Linux
[20:26:15] <sandman13> s/instance/stance
[20:26:24] <DnzAtWrk> oh good
[20:26:29] <DnzAtWrk> so much for booting into terminal
[20:26:36] <DnzAtWrk> looks like another re-install is in order
[20:26:41] <sandman13> what
[20:27:03] <edk> well, i guess maybe it only maybe has UB
[20:27:22] <DnzAtWrk> yes, just sda5: clean blah blah
[20:27:24] <DnzAtWrk> then stuck forever
[20:27:25] <edk> you compute p blind, it's not equal to q by construction
[20:27:30] <DnzAtWrk> great, worthless advice stack overflow
[20:27:32] <DnzAtWrk> yet again
[20:27:40] <bjs> edk: it doesn't matter, it's guarded by an equality check just like your test
[20:27:50] <edk> i think it does
[20:27:50] <bjs> edk: well it does matter I guess, that's the point I'm trying to make
[20:27:51] <sandman13> DnzAtWrk: What are you trying to do?
[20:27:59] <DnzAtWrk> reboot into terminal
[20:28:03] <DnzAtWrk> FFFFFF
[20:28:05] <DnzAtWrk> TYPICAL
[20:28:10] <bjs> edk: yes I'm saying it's UB because of it, if x and y were part of the same object (e.g. in a struct) then the UBness would be much less clear to me
[20:28:11] <DnzAtWrk> This is so typical linux
[20:28:17] <DnzAtWrk> getting too old for this
[20:28:44] <DnzAtWrk> next up 30 minutes of blah blah troubleshooting blah blah commands
[20:28:45] <sandman13> DnzAtWrk: Reboot and press Ctrl-Alt-F2 on login screen for that :P
[20:28:45] <edk> bjs: this is all just a tangent about the uintptr_t rule in my eyes, irrelevant to the broader point about constructing pointers in an implementation-defined manner
[20:28:49] <DnzAtWrk> and I have something to accomplish
[20:28:53] <DnzAtWrk> jesus, stopgaps
[20:28:55] <bjs> edk: you can make the same test without uintptr_t
[20:29:14] <edk> but it's still not guaranteed to work because what you're testing here is uintptr_t
[20:29:19] <edk> the only reason it might ever work is the uintptr_t rule
[20:29:36] <DnzAtWrk> ctrl+alt f2 worked
[20:29:37] <edk> and... you've carefully arranged it so the uintptr_t rule doesn't quite apply. so yeah, it doesn't work
[20:29:43] <DnzAtWrk> couldn't prompt the login without it
[20:29:46] <edk> but it doesn't say anything about the broader aliasing question
[20:29:48] <DnzAtWrk> couldn't even adjust the brightness of the screen
[20:29:49] <bjs> edk: I arranged it exactly the way you arranged it earlier
[20:30:10] *** Quits: jazzy (~jaziz@2600:380:8638:b14c:3d37:fea7:101f:573e) (Ping timeout: 272 seconds)
[20:30:18] <edk> i mean. try my thing, it does work
[20:30:49] <sandman13> DnzAtWrk: There's a way to control backlight from there. Kind of forgot what file was that. In my case, my laptop's keys work fine.
[20:31:06] <edk> but my thing is also relying on the uintptr_t rule
[20:31:11] <DnzAtWrk> Yeah I just had to take a shot in the dark and notice the very very dark text
[20:31:15] <DnzAtWrk> on my regular computer monitor
[20:31:18] *** Joins: Natch (~natch@c-e070e255.014-297-73746f25.bbcust.telenor.se)
[20:31:26] <sandman13> Oh.
[20:32:20] <DnzAtWrk> toolkit installation failed, unsupported compiler
[20:32:22] <DnzAtWrk> this shit again
[20:32:29] <sandman13> External graphics cards always have some weird issue with Linux. Not entirely the fault of Linux though.
[20:32:37] *** Quits: gitgood (~gitgood@80-44-15-108.dynamic.dsl.as9105.com) (Ping timeout: 245 seconds)
[20:32:47] <sandman13> DnzAtWrk: what are you trying to compile?
[20:32:49] <DnzAtWrk> what magical gc++devlibfree.3454656
[20:32:52] <DnzAtWrk> does it need this time
[20:32:57] *** Joins: LiftLeft (~LiftLeft@154.21.23.18)
[20:33:00] <DnzAtWrk> cuda toolkit 10
[20:33:44] <bjs> edk: what exactly makes my version UB then
[20:33:53] <sandman13> Is the version correct?
[20:34:06] <edk> more IDB. as i said you compute the value blind
[20:34:18] <edk> i'm not impressed, but i think it's on shakier ground than mine
[20:34:45] *** Joins: user51 (~user51@176.228.90.248)
[20:35:06] <DnzAtWrk> sigh
[20:35:11] <DnzAtWrk> working backwards again
[20:35:15] <bjs> edk: it's clearly UB, you just aren't seeing what you'd see with IDB. The two pointers ended up equal and later accesses just aren't respecting the earlier store
[20:35:20] <DnzAtWrk> every time, I use the latest versions of everything and they work
[20:35:28] <bjs> edk: which is just a classic symptom of UB
[20:35:31] <edk> bjs: i mean no behaviour is ever "clearly UB"
[20:35:34] <DnzAtWrk> But there is always SOME LITTLE **** package that requires an old thing
[20:35:37] <DnzAtWrk> and then all hell breaks lose
[20:35:40] <DnzAtWrk> Every... time
[20:36:02] <bjs> edk: I'm saying the behaviour I observe is fully consistent with UB and not IDB behaviour and the behaviour of the compiler is sensible and clear and desireable and a good reason to make this UB
[20:36:14] *** Quits: mjs2600 (~mjs2600@c-24-91-3-49.hsd1.vt.comcast.net) (Quit: ZNC 1.8.2 - https://znc.in)
[20:36:15] <sandman13> DnzAtWrk: apt-get -f install
[20:36:16] <sandman13> ?
[20:36:18] <edk> i... don't think that makes sense
[20:36:29] <bjs> edk: well why do you think things are UB in the first place?
[20:36:31] <edk> there's nothing *anywhere* that's "consistent with UB and not IDB"
[20:36:46] <sandman13> Usually solves the issue for me but I know the feel.
[20:37:03] <edk> things are UB because they're not defined by the standard; it's a property of programs, not behaviour
[20:37:08] <bjs> edk: UB exists to allow compiler optimizations like this, if this isn't UB then compilers just generally cannot do this kind of propagation
[20:37:18] <edk> i don't think that's the case
[20:37:19] <bjs> edk: yeah but the standard exists not in a vacuum, there's a reason everything that's UB is UB
[20:37:34] <edk> or rather i don't really think i see an argument there
[20:37:39] *** Joins: mjs2600 (~mjs2600@c-24-91-3-49.hsd1.vt.comcast.net)
[20:38:01] *** Quits: bcd (~bcd@user/bcd) (Ping timeout: 248 seconds)
[20:38:17] <edk> what i'm claiming is that you're invoking implementation-defined behaviour, and your implementation defines the pointer conversion as yielding an invalid pointer, or something along those lines
[20:38:36] <edk> you don't invoke UB until you try to use the pointer
[20:38:42] <bjs> edk: yes it's clearly UB
[20:38:58] <edk> no, it's clearly IDB; it only has UB because of your definition
[20:39:15] <bjs> edk: yours is also UB for the same reason,  you construct the same invalid pointer in the same way, do the same equality check
[20:39:16] <edk> the difference being that an implementation could quite reasonably define some other behaviour for the pointer conversion
[20:39:23] <bjs> and then access it
[20:39:29] <bjs> if my access is UB then yours is too
[20:39:44] <edk> i don't construct it in the same way, though
[20:40:11] *** Quits: absc (~absc@dynamic-adsl-94-34-201-166.clienti.tiscali.it) (Quit: Leaving.)
[20:40:12] *** Joins: Zeturic (~Orimendix@50-25-46-156.krmtcmta02.res.dyn.suddenlink.net)
[20:40:41] <edk> but it's immaterial; none of these programs do or don't have UB in a vacuum
[20:40:58] <bjs> I think it is, I think my program *does* have UB in a vacuum
[20:41:29] <edk> i think it's in one of three cases
[20:41:40] <edk> 1) gcc is wrong. the uintptr_t rule covers this case, it's well-defined
[20:41:57] *** Joins: chomwitt (~chomwitt@ppp-2-85-147-24.home.otenet.gr)
[20:42:12] *** Quits: xff0x (~xff0x@2001:1a81:53fa:2600:8056:588e:c971:d9df) (Ping timeout: 258 seconds)
[20:42:21] <edk> 2) it has implementation-defined behaviour and some implementation defines it in such a way that line 14 has UB; this can't be true in a vacuum
[20:42:32] *** Quits: exvicesindaco (~exvicio@user/exvicesindaco) (Ping timeout: 268 seconds)
[20:42:41] <edk> 3) it has implementation-defined behaviour and some implementation defines it in such a way that line 14 does not have UB; this can't be true in a vacuum either
[20:42:49] *** Quits: tlaxkit (~hexchat@170.253.40.255) (Ping timeout: 248 seconds)
[20:43:03] *** Joins: xff0x (~xff0x@2001:1a81:53fa:2600:743d:308e:abb:126)
[20:43:04] <bjs> edk: or (4) it's UB because it's using a pointer from one object to a different unrelated object and dereferencing it
[20:43:05] *** Joins: exvicesindaco (~exvicio@user/exvicesindaco)
[20:43:13] <edk> but it isn't doing that
[20:43:33] <edk> it's using a pointer constructed from an integer in some way
[20:43:49] <bjs> edk: it is, it's got a pointer from `x` which is one object and is turning it into an int, doing some arithmetic and then turning it back into a pointer to a different object that is not reachable from `x`
[20:43:53] <bjs> it's not in the same struct, or in the same array etc
[20:44:12] <edk> right but none of that matters, only that it was converted from an integer, which has IDB
[20:44:25] *** Joins: killown (~killown@user/killown)
[20:44:29] <bjs> edk: no it does matter, because the final intptr was equal to the one got from y
[20:44:45] <killown> most of the time I am using nano for programming, what editor would you recommend to use instead?
[20:44:47] <bjs> since there is no way to construct that pointer in a valid way (is what I claim) then the behaviour always has UB
[20:44:51] <edk> so? either the uintptr_t rule covers it or it doesn't
[20:45:12] <edk> it would be quite permissible for an implementation to define *all* not otherwise defined pointer constructions to create a pointer to the variable named y
[20:46:32] <edk> the rules for (u)intptr_t only cover converting a pointer to one of those two types and then back again, untouched, no arithmetic involved
[20:47:05] <pulse> killown, vim
[20:47:07] <edk> they certainly don't imply that uintptr_t-space has any structural connection to pointer space
[20:47:40] <bjs> edk: you can make similar tests with uintptr_t or without or with a mix https://bpa.st/S2JQ
[20:47:41] <bayaz> Title: View paste S2JQ 
[20:48:19] <killown> is there some way to make vim look like nano in shortcuts aspects, at least for some like ctrl+x, ctrl+o and so on, this :!qw thing is not  for me
[20:48:21] <bjs> Hopefully this one is more obviously UB
[20:48:22] <edk> bjs: but now you're using pointer arithmetic that is very definitely not allowed
[20:48:33] <edk> bjs: i don't dispute the general principle that pointer provenance matters
[20:48:37] *** Quits: bdeshi (~bdeshi@bdeshi.space) (Quit: bouncer disconnect)
[20:48:55] *** Joins: bdeshi (~bdeshi@bdeshi.space)
[20:49:15] *** Joins: exvicesindaco_ (~exvicio@host-82-58-14-246.retail.telecomitalia.it)
[20:49:19] *** Quits: Booster2ooo (~Booster2o@user/booster2ooo) (Read error: Connection reset by peer)
[20:49:21] *** Quits: enoq (~enoq@194-208-179-35.lampert.tv) (Quit: enoq)
[20:49:55] *** Joins: v0id_ptr (~longlong@user/ptr-frac7al/x-0038398)
[20:50:05] <bjs> edk: but I'm saying that gcc is clearly tracking provenance here and is using it in its alias analysis
[20:50:09] <d3x0r> any time you introduce a typecast in C it's really UB.  It's only defined by the programmer.
[20:50:12] <DnzAtWrk> how does update-alternatives work
[20:50:14] <DnzAtWrk> is it permanent?
[20:50:36] <edk> bjs: right but provenance doesn't apply to integers
[20:50:50] <edk> or at least not in the way that you're thinking
[20:51:07] <GeDaMo> DnzAtWrk: I think it changes symbolic links
[20:51:38] <DnzAtWrk> I see it used to point gcc to an older version
[20:51:42] <DnzAtWrk> but does that change remain after restart?
[20:51:47] *** Quits: elastic_dog (~elastic_d@2a01:118f:822:9c00:f583:aa51:9ad4:d4fb) (Ping timeout: 258 seconds)
[20:51:49] <GeDaMo> It should do
[20:51:54] <edk> i think i said but the intptr rule in the standard only applies when you put in an integer that you got out
[20:52:12] *** Quits: exvicesindaco (~exvicio@user/exvicesindaco) (Ping timeout: 245 seconds)
[20:52:12] *** exvicesindaco_ is now known as exvicesindaco
[20:52:14] <d3x0r> (and get it out ya)
[20:52:31] <DnzAtWrk> oh bloody finally
[20:52:43] <DnzAtWrk> not gcc 8, or gcc 9
[20:52:43] <edk> any other time you convert an integer to a pointer, the whole damn thing is implementation-defined
[20:52:46] <DnzAtWrk> but gcc 7 seems to run
[20:52:56] <bjs> edk: you would want to believe but gcc really is tracking provenance through integers
[20:52:57] <DnzAtWrk> I hate everything
[20:53:07] <edk> maybe it is! gcc isn't the standard
[20:53:21] <DnzAtWrk> maybe try to not have a billion breaking changes
[20:53:38] <edk> but i feel like i've tried to say this a bunch of times and you've glossed over the important bit
[20:53:43] *** Joins: jarthur (~jarthur@2603-8080-1540-002d-cd06-376d-051c-caa6.res6.spectrum.com)
[20:54:05] *** Quits: mnd999_ (~mark@2001:8b0:da3:76a2:4630:5b97:83a2:3e21) (Ping timeout: 258 seconds)
[20:54:12] <bjs> edk: but are you saying that gcc is wrong to do so? I don't think it is
[20:54:25] <d3x0r> a billion years ago there was a commit to add 'allow addition to work on function pointers' which also ended up allowing addition on void*  pointers too.  well before it was released as a stable version.
[20:54:40] <edk> no. i'm saying: when you convert an integer to a pointer, either it's a (u)intptr_t value that you got by converting a pointer to that type, or the result is implementation-defined
[20:54:49] <d3x0r> so ... void f(void) {}; a = f+3; is fun.
[20:54:52] <edk> in the former case, you get back the pointer you put in
[20:55:00] *** Quits: v0id_ptr (~longlong@user/ptr-frac7al/x-0038398) (Ping timeout: 256 seconds)
[20:55:12] <bjs> edk: yes of course every time you do a pointer/integer cast it's implementation defined, that's obvious and true and nobody disagrees
[20:55:34] <d3x0r> edk programmer defined... nto really implementation; it will put it in and get it out; and uintptr is a type large enough to hold a pointer.
[20:55:35] <DnzAtWrk> ah, I should probably clear laternatives then
[20:55:35] <edk> well no, not every time, just when the intptr thing applies
[20:55:36] <bjs> what we disagree on is whether that pointer can carry provenance information.  I can't see any reason why it can't ?
[20:55:41] <DnzAtWrk> clear alternatives*
[20:55:44] <edk> we don't disagree
[20:55:51] <d3x0r> (if you had different poitnser sizes, small, far, huge) it might have to be different sizes depending on the mode.
[20:55:54] <edk> my argument is that your program has IDB
[20:56:07] <edk> whether it's correct depends entirely on the implementation's definition
[20:56:53] <bjs> edk: I claim that the IDB doesn't matter because all it means is that the condition is implementation defined, you don't know if it will be true or false
[20:56:53] *** Joins: merijn (~merijn@83-160-49-249.ip.xs4all.nl)
[20:56:58] <bjs> but if it's true then the program has UB
[20:57:10] <edk> no, line 14 has IDB
[20:57:43] <bjs> edk: ... and if it accesses y it's UB
[20:57:45] <bjs> is my claim
[20:57:57] <edk> i don't think that makes any sense
[20:58:12] <edk> if the uintptr rule applies then you get back the pointer you put in
[20:58:18] <edk> provenance and all, presumably
[20:58:31] <edk> if the uintptr rule does not apply, which you seem to think is the case, then you get back whatever random shit gcc wants
[20:59:15] <edk> there's no case where you're guaranteed by the standard to get a pointer with the wrong provenance
[20:59:43] <bjs> edk: I'm saying it doesn't matter, if you get a pointer to x with the right provenance then the behaviour is well defined and fine. If you get a pointer to y and the condition says true then the behaviour is UB because of that provenance
[21:00:14] <edk> well no, if you get a pointer to y it was IDB
[21:00:21] <bjs> edk: ... but then using it to access y is UB
[21:00:24] <edk> why?
[21:00:30] <edk> the implementation should define that
[21:00:45] <bjs> edk: because it doesn't have the right provenance, if you allow tracking provenance through integers
[21:00:59] <bjs> the integer was produced from a pointer to x, so you cannot use it to create a pointer to y
[21:01:24] <bjs> and that is what gcc is relying on in this optimization (although it's clearly very flaky as just swapping some lines around and gcc runs away in the other direction)
[21:01:27] <edk> i feel like this is all just madeu p
[21:01:35] <edk> what you actually did was get a pointer from an implementation-defined black box
[21:02:02] <edk> the provenance of that pointer is also implementation-defined
[21:03:25] *** Quits: bdeshi (~bdeshi@bdeshi.space) (Quit: bouncer disconnect)
[21:03:35] <edk> i don't think there is anything to tell this apart from if you did *(int *)3 = 42;
[21:04:12] *** Joins: bdeshi (~bdeshi@bdeshi.space)
[21:06:03] *** Quits: snake (~snake@user/snake) (Quit: Leaving)
[21:07:25] *** Joins: tlaxkit (~hexchat@170.253.40.255)
[21:07:52] <DnzAtWrk> quora is at the top of the vast majority of google searches
[21:07:53] <DnzAtWrk> why 
[21:08:11] <DnzAtWrk> it's cancerious
[21:08:14] <DnzAtWrk> cancerous*
[21:09:29] *** Quits: tlaxkit (~hexchat@170.253.40.255) (Remote host closed the connection)
[21:09:49] <DnzAtWrk> well, this dependency hell would take days to figure out
[21:09:54] <DnzAtWrk> and I have 1 day
[21:11:58] <pyzozord> Damnt it! Only 55%. Can someone tell me what I'm doing wrong? code: https://ideone.com/tpvhUs problem: https://app.codility.com/programmers/lessons/8-leader/equi_leader/ 
[21:12:01] <bayaz> Title: Ideone.com 
[21:12:02] <bayaz> Title: EquiLeader coding task - Learn to Code - Codility 
[21:12:53] *** Quits: SmokenatorZ (~Smokenato@189-69-11-13.dsl.telesp.net.br) (Quit: Screw you guys, im going home)
[21:16:03] *** Joins: SmokenatorZ (~Smokenato@177.62.67.199)
[21:19:47] <bjs> edk: it's perfectly acceptable (at least, as far as the standard today is written and as far as wg14 have said prior http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_260.htm) to track provenance through those integers and gcc is doing exactly that. Unless the next standard explicitly says this is IDB (or to explicitly allow it) then it's UB
[21:20:09] *** Quits: DnzAtWrk (~DnzAtWrk@mobile-access-6df05f-197.dhcp.inet.fi) (Read error: Connection reset by peer)
[21:20:13] *** Joins: oft_gegong (~mint@70.90.132.249)
[21:20:20] <edk> bjs: i mean when you convert an integer to a pointer what you get back is entirely implementation-defined
[21:21:29] <bjs> edk: but if you are allowed to track provenance through integers, then the pointer you get back would have x's provenance but could be any bitpattern. if it was y's bitpattern it would be UB (since there is no text saying it's ok) to use that pointer to access y
[21:22:17] <edk> bjs: i still say it's IDB because it's implementation-defined whether you do track provenance or not, by virtue of the result being implementation-defined in general
[21:22:34] <edk> which is to say the implementation is supposed to documente exactly what happens when you convert an integer to a pointer
[21:22:37] <bjs> edk: if it doesn't track the provenance then you must see y=42 too
[21:22:48] <bjs> so in that case ,gcc is just wrong
[21:22:52] <edk> well no, it's still implementation-defined
[21:23:18] <edk> the implementation could define it to be meaningless, it could define it to track provenance, it could define it to yield a pointer that is always valid
[21:23:32] <bjs> edk: a pointer that is always valid but equal to y?
[21:24:20] <edk> or that is always valid but points to a certain memory address; it's the implementation's lookout, they can do whatever they want
[21:24:55] <bjs> edk: but it's an integer remember.  The rhs of that equality is perfectly well-defined.  infact all if it is defined
[21:25:01] <bjs> you can't just suddenly decide that it's no longer equal to y
[21:25:12] <edk> i mean it's an integer not a pointer
[21:26:29] *** Quits: mjbatty_ (~mjbatty@82.2.17.205) (Read error: Connection reset by peer)
[21:26:34] *** mnrmnaugh is now known as awk
[21:26:58] <edk> either it's covered by the intptr rules (which are narrow and only cover converting to integer and straight back again, not doing arithmetic) or it's entirely arbitrary and up to the implementation
[21:27:09] *** Joins: Booster2ooo (~Booster2o@user/booster2ooo)
[21:27:20] <bjs> edk: yes it's clearly implementation defined -but then you do an equality check-
[21:27:52] *** Joins: olle (~olle@i5E866611.versanet.de)
[21:27:53] *** Joins: ircseeker3 (~nodebot@108.62.52.153)
[21:28:17] <bjs> but just because the integers are equal does not mean they're both equally valid pointers to the underlying object
[21:28:27] <edk> i mean, they're not pointers at all
[21:28:29] <bjs> (*if you are allowed to track provenance through the integers, which wg14 seem to say you are)
[21:28:39] <bjs> edk: you know what I meant
[21:28:53] *** Joins: gitgood (~gitgood@80-44-15-108.dynamic.dsl.as9105.com)
[21:29:04] <edk> i don't actually. you say then you do the equality check. but you do the check first, the IDB i'm talking about is on line 14
[21:29:48] <bjs> edk: okay, I have two integers. They are equal. But one of them is "bad" to turn back into a pointer. Even though they contain the same value.
[21:30:04] <edk> but turning them back into a pointer is implementation-defined in general
[21:30:14] <oft_gegong> what if all API's and Library capabilities were a +3000% (more) of a mess?
[21:30:17] <edk> so it's not bad or good, it's just implementation-defined
[21:30:39] <bjs> edk: but if you're allowed to track provenance through the integers then one of the pointers might have the wrong provenance and then accessing it is UB
[21:30:45] *** awk is now known as mnrmnaugh
[21:30:46] <edk> you could turn it back into a pointer and always get a null pointer
[21:30:57] <bjs> Yes and if you tried to access the null pointer you got back it'd be UB
[21:31:00] <bjs> (but for other reasons)
[21:31:07] <edk> right, but in the context of an implementation
[21:31:32] *** Quits: merijn (~merijn@83-160-49-249.ip.xs4all.nl) (Ping timeout: 272 seconds)
[21:31:45] <edk> the implementation can define your program to be meaningless because of the provenance issue, yes. but it could also define it to be fine
[21:32:09] <edk> so i don't think this program can be said to have UB or not outside the context of an implementation
[21:32:21] <Mangy_Dog> http://imgur.com/gallery/JRGz0BG. This one done!
[21:33:28] <bjs> edk: I mean there is no way you see that print without UB
[21:33:37] <edk> sure there is
[21:34:19] <edk> integers just work like they do, p happens to equal q, and then you invoke IDB on line 14
[21:34:20] <bjs> the only execution that gives you that print is if you hit the if, and you get the equality. if you're allowed to track provenance (regardless of whether the implemnetation does) then it'd be UB to use that pointer
[21:34:33] <bjs> now whether the newer standard with more text is going to say that or not I don't know...
[21:34:34] <edk> it's entirely down to the implementation what line 14 means
[21:34:35] *** Joins: Pickchea (~private@user/pickchea)
[21:34:37] <edk> *entirely*
[21:34:39] <GeDaMo> Mangy_Dog: neat :)
[21:34:42] *** Joins: elastic_dog (~elastic_d@2a01:118f:822:9c00:f583:aa51:9ad4:d4fb)
[21:34:45] <user51> cheers lads
[21:34:46] <user51> good evening
[21:34:55] <Mangy_Dog> :)
[21:34:56] <oft_gegong> cheers user282069 
[21:35:01] <oft_gegong> user51: *
[21:35:35] *** Parts: olle (~olle@i5E866611.versanet.de) ()
[21:36:27] *** Joins: kapad (~kapad@46.246.193.116.dsl.dyn.forthnet.gr)
[21:36:28] <edk> it could run into UB if the implementation defines the conversion to preserve provenance
[21:37:05] <edk> but it could also run into UB if the implementation defines the conversion to yield a null pointer, or a pointer to a float, or a pointer that's just invalid
[21:37:21] <bjs> edk: no,  if the implementation is allowed to choose that doesn't mean it's implementation dependent it means doing it would be undefined.  Implementation dependent behaviour must be spelled out very clearly
[21:37:27] <bjs> lack of suck text implies UB regardless
[21:38:06] <edk> it's not that the implementation is allowed to choose whether to track provenance, it's that it's implementation-defined to convert integers to pointers
[21:38:27] <edk> as in, the implementation can do anything it likes and is required to document what that is
[21:38:55] <bjs> edk: it doesn't matter how much implementation defined behaviour you had to get through to get to the point, when you try use it, if the implementation is merely *allowed* to track that provenance then it must be UB to access it.
[21:39:14] *** Joins: c705 (c705@alpine/contributor/c705)
[21:39:17] <edk> the implementation is allowed to do *anything*
[21:39:24] <bjs> That's not the same as UB
[21:39:42] <edk> there's no default meaning of line 14 the implementation can opt into or out of
[21:40:18] <edk> nor are there any meaningful constraints on what the implementation can define it to mean
[21:41:23] <bjs> edk: .. and since the standard does not give this a meaningful interpretation (in the case where the cast back does not get you back to what you had before) and does not explicitly say that it's implementation defined behaviour we must infer it is UB
[21:41:35] <edk> it does say it's IDB
[21:41:36] *** Joins: vicfred (~vicfred@user/vicfred)
[21:42:59] <edk> (specifically it says "An integer may be converted to any pointer type. Except as previously specified, the result is implementation-defined, might not be correctly aligned, might not point to an entity of the referenced type, and might be a trap representation.")
[21:44:03] <bjs> edk: yes but the point isn't about creating the pointers or the integer casts those are all "fine"
[21:44:32] <edk> well no they're not fine because it's line 14 that you're saying has UB
[21:44:36] *** Joins: tradar (~tradar@user/tradar)
[21:44:48] <edk> but all line 14 is doing is dereferencing an implementation-defined pointer
[21:45:19] *** Quits: ixil (~ixil@mpp-cp1-natpool-1-236.ethz.ch) (Remote host closed the connection)
[21:46:26] <bjs> edk: yes and we both agree that if the implementaion-defined value you get back is NULL then it's UB,  if you get back x then everything is fine. The question is what happens if you get back y.
[21:46:47] <edk> i don't even accept that if you get back x then everything is fine
[21:46:57] <bjs> You don't?
[21:47:05] <pikapika> Whats the piece of code being discussed?
[21:47:22] <edk> if the implementation defines the result it's surely within the implementation's remit to define the provenance too
[21:47:48] <bjs> edk: well then that line might be UB even if it accesses x
[21:47:52] *** Joins: TheAceOfHearts (~TheAceOfH@24.41.239.76)
[21:47:55] <bjs> with your interpretation
[21:48:00] <edk> i maintain that it's just IDB
[21:48:31] *** Quits: mikeliuk (~mikeliuk@109.249.187.96) (Quit: Connection closed)
[21:48:44] *** Quits: TheAceOfHearts (~TheAceOfH@24.41.239.76) (Client Quit)
[21:49:23] <bjs> edk: I don't really get how it can be just IDB, it's not like it's just a nondet choice between writing to x y or whatever, it's that the pointer was to y but then a later read of y doesn't see the value you wrote
[21:49:34] <bjs> IDB doesn't really "Leak" like that
[21:49:57] <user51> i'm 15% through tenenbaum's book. it's nice, but it feels like i know some of the stuff already =/
[21:50:09] <user51> i used to be so excited learning about bits and bytes :D
[21:50:18] <edk> bjs: i mean that's because the implementation-defined behaviour caused UB in this case
[21:50:33] <bjs> edk: that's what I've been saying
[21:50:48] <edk> bjs: but in that it's no different from... i dunno, if ('b' - 'a' != 1) { *(int *)0 = 1; }
[21:51:04] <edk> i don't think you can say whether this program has UB or not either
[21:51:17] <bjs> sigh fine okay
[21:51:47] <bjs> edk: go read wg14's notes they have a pile of interesting stuff on provenance through integers and what gcc is doing
[21:52:15] <edk> they also haven't added any provenance stuff to a standard yet
[21:52:28] *** Joins: elnavigator (~elnavigat@105.196.130.195)
[21:52:33] *** Joins: ahungry (~user@99-40-9-245.lightspeed.livnmi.sbcglobal.net)
[21:52:35] *** Joins: Guest1645 (~Guest16@103.86.19.117)
[21:53:02] <bjs> edk: well you should be careful with that argument because things the standard doesn't explicitly say are by default UB.
[21:53:03] <bjs> :P
[21:53:10] <edk> yes it does
[21:53:19] <edk> oh, i misread
[21:53:26] <bjs> huh?
[21:53:32] <Guest1645> in d3js, how to split a single circle into multiple with different radius so that i can fill them with different colors
[21:53:33] <edk> no never mind that really didn't make any sense
[21:53:36] <edk> well, consider this
[21:53:39] <bjs> edk: what didn't make sense
[21:53:43] <edk> the thing i said
[21:53:52] <edk> it was a reply to a misread thing that you didn't actually say, ignore it
[21:53:54] <bjs> edk: it's okay i've not been making sense all day, it's only fair you get a chance
[21:53:54] <bjs> :D
[21:54:22] <edk> here's the rule about pointers and void *:
[21:54:26] <pikapika> bjs, what is the code being discussed
[21:54:28] *** Joins: penguino (~mrpenguin@user/mrpenguin)
[21:54:36] <edk> A pointer to void may be converted to or from a pointer to any object type. A pointer to any object type may be converted to a pointer to void and back again; the result shall compare equal to the original pointer.
[21:54:36] <bjs> pikapika: I'm very fed up with discussing it now haha
[21:54:53] <edk> we know equality doesn't imply equal dereferenceable-ness
[21:55:03] <bjs> pikapika: but here you have two people who obivously know C really well who after long discussion and reading of various standards and texts still can't agree on what UB even is :D
[21:55:09] <edk> and we also know the standard doesn't yet spell out how provenance works
[21:55:29] <edk> so i can't see that it's obvious void *a = "hello"; puts(a); is well-defined
[21:55:41] <glguy> Which code are you discussing?
[21:55:47] <bjs> edk: you make a good point,  maybe we should destroy prose documents
[21:56:19] <edk> we're not discussing any specific code other than code we wrote for the discussion
[21:56:33] <pikapika> edk, link please
[21:56:38] <edk> the line 14 i've been talking about is in https://bpa.st/AKRQ
[21:56:39] <bayaz> Title: View paste AKRQ 
[21:56:42] <bjs> glguy: if you have two integers that compare equal in C, if you cast them both into pointers it might be "bad" to use one but not the other
[21:57:03] <bjs> glguy: edk and I are just discussing whether we think it should be UB to do so, or just IDB
[21:57:04] <pikapika> in what sense, like one is a function pointer and the other a data pointer?
[21:57:14] <glguy> bjs: thank you for the summary
[21:57:22] <edk> pikapika: no it's going to be very difficult to explain this
[21:57:23] <bjs> pikapika: no like, two integers. (in this case `intptr_t`s) which compare ==
[21:57:42] <bjs> I think despite what it looked like edk and I agree on 99.99998% of the points :P
[21:58:05] <pikapika>  (uintptr_t)&x + sizeof(int); so that is implying that variables declared on the global grow upward in memory in typical C implementations?
[21:58:11] <bjs> and we're exploring a very subtle and unwritten part of the standard and where it might give rise to UB
[21:58:16] <edk> the required reading would include a large chunk of the C standard and at least one not yet accepted (iirc?) proposal for inclusion into a future version of that standard (which everyone sort of tacitly assumes applies anyway)
[21:58:19] <bjs> pikapika: no
[21:58:40] <pikapika> It seems it was an attempt to get at the address of y by using x 's address
[21:58:45] <bjs> edk: woo C2x,  can't wait to read it on my fusion powered PC
[21:58:47] <pikapika> edk, ok
[21:59:12] <edk> fundamentally it was about whether you can create valid pointers from thin air
[21:59:16] <nitrix> The integers can be trap representations, the conversion to a pointer is implementation-defined. Then using the pointer could have undefined behavior if it points to an invalid object.
[21:59:28] <nitrix> As far as I remember.
[21:59:51] <bjs> Yeah but what do those words really *mean* that's the question, and what actually is C's object model like seriously
[22:00:03] <nitrix> What do you mean, what do they mean?
[22:00:12] <nitrix> I'm using the terminology from the standard.
[22:00:34] <edk> nitrix: you'd have to read a very long and agonising discussion to understand the problem, i fear
[22:01:26] <edk> but when something is implementation-defined, just how much is the implementation required to define, and can you say anything about a program with IDB other than that it has IDB?
[22:01:52] *** Quits: gitgood (~gitgood@80-44-15-108.dynamic.dsl.as9105.com) (Ping timeout: 256 seconds)
[22:02:28] <pikapika> How the fuck did p end up being 42 without affecting x or y
[22:02:53] <bjs> pikapika: uh... "compilers"
[22:03:09] *** Quits: tradar (~tradar@user/tradar) (Quit: tradar)
[22:03:37] <bjs> pikapika: this is the danger I spoke of of (undefined|implementation-dependent)-behaviour
[22:03:46] <bjs> you can get some odd results sometimes
[22:04:17] <bjs> I mean like any other hot or sharp tool it might be dangerous but if you understand what it's doing and what's going on then you can use it effectively and safely
[22:04:17] <oft_gegong> so you can write memory that you shouldn't write to *sometimes*?
[22:04:49] <bjs> oft_gegong: let's just say you're not allowed to do it except for the fact that in some cases people do it anyway
[22:05:28] <oft_gegong> ah. this discussion reminds me of endianess. it can blow a hole in making sense.
[22:07:14] <mercenary> that isn't undefined behaviour is it?
[22:07:31] <oft_gegong> what? endianness?
[22:07:42] *** Quits: Crescendo (~Crescendo@user/crescendo) (Ping timeout: 272 seconds)
[22:07:46] <mercenary> no, that pointer arithmetic
[22:08:48] <pikapika> edk, the addresses turn up unequal on mine
[22:10:02] <oft_gegong> I 0%can own my own computer.
[22:10:02] <mercenary> stack layout is up to the compiler. so they may or may not be equal
[22:10:23] *** Joins: sidy (~sidy@user/sidy)
[22:11:21] <bjs> pikapika: well yeah, the addresses can be anything they want to be
[22:11:34] <bjs> I just picked something that worked on my machine to get the "bad" behaviour to show
[22:11:40] <pikapika> It seems on edk system, the globals storage space grows upward
[22:11:40] <oldlaptop> mercenary: whether "the stack" as you understand it even exists is up to "the compiler"
[22:11:44] <pikapika> or was it yours
[22:11:47] <bjs> pikapika: it was mine
[22:12:14] <mercenary> oldlaptop: this is true. I should have said memory layout
[22:12:24] <oldlaptop> much of what people "know" about how C works is how common implementations on normal machines work
[22:12:44] <vdamewood> Hi, people etc.
[22:13:00] <pikapika> vdamewood, hi uwu
[22:13:21] <bjs> pikapika: I just wanted to hack together an example where I had two integers that compared equal but where accessing through one didn't update the value that would have been accessed through the other
[22:13:35] <oldlaptop> including whether pointers are, in a meaningful sense, "just a number" (that particular assumption has been violated by real machines before)
[22:13:44] <pikapika> I might have to change the increment to get the address of y
[22:13:59] <bjs> pikapika: and as edk and I discussed there can be various reasons why that might happen and what kind of undefined and/or implementation-defined behaviours arise from those reasons
[22:14:00] *** Joins: gitgood (~gitgood@80-44-15-108.dynamic.dsl.as9105.com)
[22:14:57] <pikapika> What you did is something I'd never do anyways. I don't trust pointer offsets other than in arrays and first element of struct.
[22:15:31] <pikapika> other struct elements can be laid out many different ways due to alignment and padding, and the storage of locals, globals etc is not a given that it should be contiguous on some stack etc
[22:15:35] <vdamewood> oldlaptop: Ooooh, got an example exception of the 'just a number' 'rule'?
[22:15:46] *** Joins: TheAceOfHearts (~TheAceOfH@24.41.239.76)
[22:16:00] <vdamewood> s/'rule'/assumption/
[22:16:07] <glguy> pikapika: the interesting thing isn't about memory layout, it's about if the source of an integer matters when casting from uintptr_t to void*
[22:16:21] <glguy> or if only the value of that integer matters
[22:16:29] <pikapika> Oh yeah good point
[22:16:32] <oldlaptop> ISTR the invaluable c-faq.com's section on how NULL works has cause to mention lisp machines
[22:16:45] <nitrix> It's the other way around, pointers aren't integers, uintptr_t is. Making further assumptions creates problems.
[22:17:13] <bjs> glguy: and in what way it matters, and whether where it -came- from matters, and what possibilities there are when you cast it back into a pointer etc
[22:17:56] <oldlaptop> http://c-faq.com/null/machexamp.html most are examples of how a "null" pointer might not be the integer zero, but lisp machines are lisp machines and therefore do not have integer 'pointers' at all
[22:17:57] <bayaz> Title: Question 5.17 
[22:20:57] *** Quits: Pickchea (~private@user/pickchea) (Ping timeout: 245 seconds)
[22:21:51] *** Joins: quartz (~quartz@2603-8001-7700-61a4-0000-0000-0000-0acb.res6.spectrum.com)
[22:22:45] <oft_gegong> assuming you were a C programming god, then would you be OK with that?
[22:23:44] <pyzozord> oh I know that feeling after proper pushups you feel in your chest muscles. I just forgot the name. The name for it is "the pump". I love the pump
[22:24:10] <glguy> bjs: I don't have a lot to contribute to the discussion. It was nice to see that GCC at least respected "The following type designates an unsigned integer type with the property that any valid pointer to void can be converted to this type, then converted back to pointer to void, and the result will compare equal to the original pointer:" https://bpa.st/BBGQ So I guess they covered their standard bases :)
[22:24:11] <bayaz> Title: View paste BBGQ 
[22:24:22] <pyzozord> One of the benefits of being overweight is that your pushups really get you there effectively
[22:24:38] <glguy> It *does* compare equal
[22:24:55] <oft_gegong> pyzozord: I have to do girl push-ups :(
[22:25:09] <bjs> glguy: indeed it does ;)
[22:25:17] <bjs> glguy: the standard said nothing about using the pointer :P
[22:26:06] <pikapika> oft_gegong, whats that
[22:26:25] <edgar-rft> wonderbra
[22:26:48] <pyzozord> oft_gegong: I do too on second set sometimes
[22:27:30] <pyzozord> it's whatever. As long as you get the pump you are good. Listen to your body not to other people
[22:27:41] <oft_gegong> pikapika: girl push ups is where you lay on your knees before going up. men push ups are where you lay on your feet before going up.
[22:28:19] <oft_gegong> why is exercise painful?
[22:28:21] <pikapika> Ok
[22:28:45] <oft_gegong> or rather really uncomfortable.
[22:28:46] <edgar-rft> if I were a C programming god then being OK would be undefined behaviour
[22:28:56] *** Joins: Izem (~Izem@bras-base-london1483w-grc-43-65-95-173-5.dsl.bell.ca)
[22:29:11] <pyzozord> oft_gegong: you might not be duing it correct. I try to imagine I'm on a bench press but reverse, this helps me make better motion and I feel the results
[22:29:22] <vdamewood> oldlaptop: Cool.
[22:29:28] <oft_gegong> pyzozord: oh cool thanks for the tip
[22:30:47] <pyzozord> now back to my brain pushups, stupid multi-leader problem...
[22:31:50] <edgar-rft> all that exercising talk is too exhausting for me
[22:32:51] <oft_gegong> I know I feel my muscles being drained energy already
[22:33:45] <pyzozord> ok alright sorry guys, here: pizza, netflix, beer, midday naps. Betteer?
[22:34:15] <oft_gegong> k
[22:34:47] <DPA> Noooooooo, not netflix! Don't support DRM!
[22:35:01] *** Joins: Hax0r (~TP1@87.101.193.195)
[22:35:49] <pyzozord> hmm, youtube? I'm not sure if that has drm
[22:36:08] <Twix> At least they use a drm variant i can use with linux. And their pricing is ok. So DRM can be tolerated here.
[22:36:12] <pyzozord> I know: cable tv
[22:36:16] *** Quits: exvicesindaco (~exvicio@host-82-58-14-246.retail.telecomitalia.it) (Read error: Connection reset by peer)
[22:36:54] <pyzozord> or forget the tv, just more naps
[22:37:22] <oft_gegong> Zzz Zzz
[22:37:28] <DPA> Youtube doesn't seam to use DRM yet. I can booth, mitm my videos, or use youtube-dl, without any problems.
[22:37:44] <Twix> i think they do DRM if you buy movies
[22:37:51] *** Quits: jmft2 (~JMFT@82.3.54.26) (Ping timeout: 268 seconds)
[22:38:49] <Twix> I like the audible DRM. Its easier to crack the "cryptographic" key than using the api to get key :D
[22:38:50] <DPA> They sell movies? (I always only use it indirectly, I auto download videos with cron. No ads, top res, all preloaded this way.)
[22:38:51] *** Parts: Izem (~Izem@bras-base-london1483w-grc-43-65-95-173-5.dsl.bell.ca) (Closing Window)
[22:39:07] <Twix> yes, they do
[22:39:19] <Twix> you can give them money to watch movies
[22:39:34] <Twix> and you can give them money to have less ads
[22:40:07] <vdamewood> and you an watch some movies for free with ads.
[22:40:11] <Twix> but i also only use youtube using youtube-dl :D
[22:40:44] <vdamewood> Twix: Nice thing about that is you don't have ads in the middle of the video.
[22:41:02] <Twix> :)
[22:42:18] <edgar-rft> youtube was created for using youtube-dl
[22:42:41] <DPA> I try to buy all my movies as blu-ray. I then remove the DRM using MakeMKV, and put it on my intranet server. Then I watch them on my tablet or elsewhere, whenever I feel like it. I just like to actually have the stuff I use.
[22:42:43] <pyzozord> I honestly don't mind midroll ads. What bothers me is large scale recomendation and tracking systems. Marketing is not evil inarcarnate, it's just overrun by evil people
[22:43:30] <InPhase> pikapika: To my earlier comment, rapidly throwing out existing C code is not logical.  Battle-forged C code can be fairly trustworthy, although we need to understand that continued maintenance on legacy C code keeps creating a very large portion of the major security problems we experience, as people introduce mistakes with buffers, pointers, and so on.  This is avoidable by gradually phasing that 
[22:43:32] <pyzozord> mpv + youtube-dl is a very cool setup
[22:43:36] <InPhase> code out and replacing it with modernized replacements that are structured to be naturally resistant to the whole class of issues.
[22:43:53] <oft_gegong> pyzozord: mpv > ffmpeg?
[22:44:11] <pikapika> InPhase, it wasn't my point that one should throw away C code. I think C is okay.
[22:44:15] <InPhase> pikapika: Continuing to create more infrastructure relying on C is a strategical error.
[22:44:39] <pikapika> I was saying it seemed to be the conclusion of how fanatical some people are
[22:44:54] <mawk> who doesn't like C anyway
[22:44:57] <mawk> it's the best language
[22:45:04] <pyzozord> oft_gegong: I believe mpv is fork of a fork of the demo ffmpeg player. Mpv kind of *is* ffmpeg, just with tiny bit of niceiness, but very very modest and mindfull, it's minimal to the extreme (but you do get plenty of cli options)
[22:45:19] <deniska> isn't mpv the fork of mplayer?
[22:45:44] <pyzozord> yeah and mplayer was just forked off of the demo ffmpeg player code I think
[22:45:53] <InPhase> pikapika: My assessment is throw it out slowly.  It takes time to create alternatives and build them up to sufficiently tested to beat out various infrastructure pieces.  But there are enough gains in doing so that the attempt is the winning approach.
[22:46:09] *** Joins: Narrat (~omnius@p200300df5f0ae58d06ea56fffe2e7cdc.dip0.t-ipconnect.de)
[22:46:25] <edgar-rft> wasn't everything forked from the things created by god?
[22:46:53] <deniska> pyzozord: mplayer almost predates ffmpeg, I don't think that's the case
[22:47:08] <oft_gegong> mplayer/mencoder
[22:47:19] <pikapika> Just to be clear I am not a C hater
[22:47:23] <pikapika> I like the language in fact
[22:47:52] <pyzozord> deniska: could be, I could have misread something
[22:48:20] *** Quits: gitgood (~gitgood@80-44-15-108.dynamic.dsl.as9105.com) (Ping timeout: 256 seconds)
[22:48:32] <pyzozord> ah what I was referring to is that mpv is a fork of mplayer2 which is a fork of mplayer
[22:48:39] <beaky> at last the ultimate programming language has finally arrived, the Kind programming language designed to kill Haskell as the one true functional programming language. it's even got dependent types so its strictly more powerful than haskell https://github.com/uwu-tech/kind
[22:48:47] *** Joins: jasonridesabike (~jason@190.104.119.246)
[22:48:53] <edgar-rft> I'm not a C hater, I just simply ignore it.
[22:49:22] <beaky> the design rationale for the Kind programming language explained in a merkle tree enthusiast forum of all places https://old.reddit.com/r/ethereum/comments/ns7yng/my_unedited_uncensored_thoughts_about_ethereum/
[22:49:36] <pyzozord> if I'm not mistaken mpv makes heavy use of ffmpeg. As I understand it it's just a client/ui code on top of mpeg
[22:49:40] <pyzozord> *ffmpeg
[22:49:46] <beaky> nice i like ffmpeg
[22:49:46] <mawk> beaky: "uwu-tech"
[22:49:49] <mawk> sorry I'm not clicking that
[22:49:51] *** Quits: Sauvin (~sauvin@about/linux/staff/sauvin) (Remote host closed the connection)
[22:50:10] <beaky> do not worry there is no anime in it
[22:50:13] <oft_gegong> mawk: you don't trust the URL?
[22:50:20] <beaky> ok one of the contributors has an anime profile pic
[22:50:22] <vdamewood> beaky: well, now I'm not clicking it.
[22:50:48] *** Joins: v0id_ptr (~longlong@user/ptr-frac7al/x-0038398)
[22:50:52] <mawk> yes I trust it oft_gegong , but I don't like the org name of that repo
[22:50:53] <edgar-rft> I only click links with emojis in it
[22:51:04] <beaky> but it is the future of programming wont you guys click on it just to catch a glimpse of our future
[22:51:11] *** Joins: twomoon (~twomoon@ip72-199-58-150.sd.sd.cox.net)
[22:51:19] <pyzozord> ok sold, I will click
[22:51:22] <user51> isn't it more of the same
[22:51:26] <vdamewood> beaky: No cats, No anime, No click.
[22:51:36] <mawk> why does it say js in the repo readme beaky does this have something to do with js
[22:51:37] <beaky> yes sadly they use a c-like syntax instead of the sick haskell-like syntax
[22:51:40] <mawk> is it some kind of transpiler thing?
[22:51:44] <jasonridesabike> I think I can help: https://old.reddit.com/r/ethereum/comments/ns7yng/my_unedited_uncensored_thoughts_about_ethereum?emoji=:)
[22:51:46] <mawk> C-like syntax is best syntax
[22:51:54] <beaky> yes mawk it is implemented in javascript i think
[22:52:05] <pyzozord> nah, wall of text, not ready for that mental effort atm
[22:52:08] <oft_gegong> software technology killed itself with web browsers + javascript technology.
[22:52:20] <vdamewood> I want to implement a C compiler in Python.
[22:52:29] <beaky> but i like javascript
[22:52:31] <mawk> vdamewood: os.system('gcc')
[22:52:32] <user51> sounds interesting
[22:52:39] <user51> why python?
[22:52:44] <vdamewood> mawk: Thanks. You saved me to much time.
[22:52:48] <vdamewood> s/to/so/
[22:52:49] <DPA> I've been playing with the thought of making my own programing language in the past. But I don't like any of the ways to actually do it.
[22:52:49] <DPA> I could write my own compiler & assembler, but it would be a lot of work and end up platform dependent. I could compile to C, but there may be some optimisations I can't do like this.
[22:52:49] <DPA> I could try to do a gcc frontend, but I hear that's very complicated. I could use clang / llvm, but I hear the APIs aren't all that stable, I would prefer copyleft, I'm unsure if the ir would be a good fit for the kinds of constructs I have in mind, and it seams more difficult than just compiling to C...
[22:53:05] <mawk> DPA: try a DSL
[22:53:10] <mawk> using that tool from jetbrains I forgot
[22:53:17] *** Quits: oft_gegong (~mint@70.90.132.249) (Quit: Leaving)
[22:53:19] <mawk> it's like visual programming editor to create your own programmng language
[22:53:22] <vdamewood> user51: It was tongue in cheek. I selected Python because it's not very efficient in terms of speed.
[22:53:23] <mawk> it looks cool
[22:53:39] <mawk> ld is in C and it's not very efficient in terms of speed either vdamewood 
[22:53:48] <mawk> so maybe if you do it in python and use cython you will be fast
[22:53:54] <beaky> it even has 'super inductive' types not even cubical agda has those https://github.com/uwu-tech/Kind/blob/master/blog/1-beyond-inductive-datatypes.md
[22:54:06] <user51> but python is written in c, no?
[22:54:10] <beaky> therefore it is more expressive than the current state of the art proof assistants
[22:54:13] <mawk> yes user51 so what
[22:54:13] <pyzozord> I wouldn't even bother with gcc or clang to write my own toy language, i bet it's a massive commitment to learn their apis
[22:54:17] <mawk> that doesn't mean python is fast
[22:54:27] <beaky> but if you implement them in llvm your language will be screaming-fast 
[22:54:31] <mawk> python is virtually single-threaded for one, and anyway you can make slow programs in C
[22:54:46] <beaky> you can also implement it in graal but graal is oracle so nobody uses it
[22:54:48] <deniska> a language a compiler is written in only influences the compilation time, not the runtime speed of the compilated program
[22:54:49] <mawk> pyzozord: not really (with llvm)
[22:54:56] <user51> maybe you can write an awk
[22:55:03] <mawk> I did a custom C parser with the clang api once, it took me like 2 days to learn the API
[22:55:11] *** Joins: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431)
[22:55:12] <mawk> and output some custom thing from the parsed C AST
[22:55:22] <beaky> nice i like clang it is the most advanced c compiler 
[22:55:23] <mawk> using the C++ API, but you have a python one too
[22:55:26] <user51> it's a pretty decent language by itself, but it could use a few improvements
[22:55:30] <vdamewood> Okay, so I should write a C compiler in Python, then use my compiler to build Python.
[22:55:45] *** Quits: v0id_ptr (~longlong@user/ptr-frac7al/x-0038398) (Ping timeout: 268 seconds)
[22:55:45] <mawk> yes
[22:55:48] <mawk> bootstrap
[22:56:04] <deniska> vdamewood: just write python compiler in python and use it to compile itsels
[22:56:06] *** Joins: gitgood (~gitgood@80-44-15-108.dynamic.dsl.as9105.com)
[22:56:10] <deniska> wait, it's pypy
[22:56:25] <beaky> nice i like pypy
[22:56:26] <mawk> papaye
[22:56:35] <vdamewood> c is for coding, that's good enough for me.
[22:56:42] <mawk> what is D for then
[22:56:47] <bjs> vdamewood: if you implement the compiler in Python does it matter how fast Python itself really is
[22:56:48] <deniska> mawk: debugging
[22:56:48] <beaky> it takes a million years to compile pypy on gentoo because the build process insists on being single-threaded but once it compiles you cant run anything because many libraries arent supported in pypy
[22:56:51] <mawk> :(
[22:56:52] <user51> E's predecessor
[22:57:11] <mawk> beaky: why doesn't it defer to a cpython interpreter for these libs
[22:57:13] <mawk> that would be convenient
[22:57:31] <deniska> beaky: s/on being single-threaded/on drawing mandelbrot set/
[22:57:31] <mawk> you can embed cpython in whatever executable you want
[22:57:38] <user51> vdamewood: if you want a real challange, write it in awk
[22:57:48] <vdamewood> bjs: Well, we're talking about an already off-the-walls-bonkers scenario anyway.
[22:57:56] <deniska> mawk: it's its own python interpreter with its own memory model
[22:58:01] <bjs> vdamewood: writing compilers in Python isn't that "bonkers"
[22:58:01] <vdamewood> user51: That would be awkward.
[22:58:01] <beaky> mawk: yes good question
[22:58:07] <deniska> it can't just run cpython and leverage it for libraries
[22:58:19] <vdamewood> bjs: Writing a C compiler in Python just to compile Python is.
[22:58:23] <beaky> o so thats why
[22:58:29] <bjs> vdamewood: well "just" to compile Python yes :)
[22:58:38] <beaky> i like python it is the most pythonic language
[22:58:50] <vdamewood> it's even more pythonic than rust.
[22:58:51] <user51> vdamewood: i imagine it wouldn't be impossible, but awk's lack of user-defined data structures hurts badly
[22:59:04] <deniska> awk#
[22:59:43] <vdamewood> deniska: What an abomination.
[23:00:05] <beaky> it is alright you should be able to encode data structures using church or scott encoding
[23:00:09] <deniska> vdamewood: which one?
[23:00:14] <vdamewood> Though, can we refer to the .NET varities of Visual Basic as Basic#.
[23:00:18] <vdamewood> ?
[23:00:23] *** Joins: Akuli (~Akuli@87-94-109-27.bb.dnainternet.fi)
[23:00:25] <vdamewood> deniska: awk#
[23:00:31] <user51> awk++ = src.app :)
[23:00:39] *** Quits: Guest1645 (~Guest16@103.86.19.117) (Quit: Connection closed)
[23:00:44] <deniska> I wanted to write "awk++" first, but that can be confused with me endorsing awk
[23:01:00] <vdamewood> oohh... gives me an idea for a language, C++#
[23:01:10] <vdamewood> Or maybe C#++
[23:01:17] <deniska> vdamewood: C++.Net is a thing
[23:01:29] <beaky> the super inductive data types remind me of the cedille programming language another sick research lagnuage where you define everything using church encoding even induction
[23:01:30] <deniska> or Managed C++ how they call it
[23:01:31] <vdamewood> Well, C++/CLI
[23:01:35] <deniska> or that
[23:01:39] <beaky> the super inductive data types of the Kind programming language
[23:01:50] <user51> deniska: i mean, what's a programming language anyway
[23:01:55] <vdamewood> deniska: I was thinking of something that ads C++ features to C#
[23:02:06] <vdamewood> So C++# exists, but not C#++.
[23:02:13] <vdamewood> Let's make C#++.
[23:02:32] <deniska> which features that would be?
[23:02:38] <vdamewood> Then we can make Objective C#++
[23:02:51] <vdamewood> deniska: full templates, multiple inheritance.
[23:03:03] <deniska> Visual Objective C#++ for Applications
[23:03:18] <DPA> Is making a GPL licensed parser, independent of clang / gcc, but then abstracting backends which output C or which links against them, takeing the AST or something like that, a good idea?
[23:03:20] <deniska> from Borland
[23:03:57] <vdamewood> Turbo Visual Objective C#++ for Applications
[23:04:13] <user51> i remember making a shell could be pretty complicated
[23:04:41] <deniska> DPA: if your GPL program creates an output to feed into another program, then GPL is fine
[23:04:54] <deniska> if you actually link with other programs, GPL becomes infectious
[23:05:27] <DPA> GPL programs can link against LLVM, though, right?
[23:05:58] <DPA> It should be fine as long as it's not the other way around.
[23:06:04] <vdamewood> Yes. LLVM is licenced under the Apache License 2.0 (GPL3 compatible) with an exception for Linking with the GPL v2.
[23:06:12] <deniska> but then I believe you need to treat LLVM as far as it was GPL
[23:06:46] <vdamewood> deniska: Not LLVM itself, just anything that's a combination of the two.
[23:07:04] <vdamewood> DPA: Also there is no other way around.
[23:07:06] *** nekodesu is now known as usedoken
[23:07:22] <vdamewood> DPA: I mean, if you link X with Y, it's the same as linking Y with X. There is no difference.
[23:07:24] *** Joins: webnet4 (~0x100@32.211.211.39)
[23:07:41] *** Quits: Hax0r (~TP1@87.101.193.195) (Quit: I'll be back..)
[23:09:08] <DPA> There is. Y doesn't relate to X in any way. X does need Y, but only the plugin, and only optionally.
[23:09:14] *** Quits: Samian (~Sami@2620:10d:c091:480::1:ab1a) (Quit: Textual IRC Client: www.textualapp.com)
[23:09:19] * edgar-rft is searching for the missing link
[23:09:41] <DPA> s/plugin/backend/
[23:09:57] <deniska> DPA: but yeah, from gpl perspective it's not what needs what
[23:10:17] <deniska> it's whether (very roughly speaking) they're in the same address space
[23:10:28] <vdamewood> DPA: Nope. The GPL applies it self to an entire combined work, no matter what's linking to what and why.
[23:11:49] <vdamewood> DPA: So If you have a GPL plugin, it can only be combined with a GPL-compatible app, and when they're combined the GPL applies to the whole lot. (Assuming you're using dlopen and friends as the loading mechanism. Forking a process and using pipes is different.)
[23:11:52] <DPA> What about the off-tree kernel modules? What about all the GPL programs with plugin systems? What about all the mixed programs out there? It can't be that simple.
[23:12:18] *** Joins: freakazoid12345 (~matt@2603:9000:cf0f:80e3:bdfd:43c9:908b:3a3f)
[23:12:36] <vdamewood> off-tree kernel modules are never combined and distributed.
[23:13:03] <vdamewood> GPL programs with plugin systems would require GPL plugins if the plugin would consititute partof a combined work.
[23:13:10] *** Joins: freakazoid333 (~matt@2603:9000:cf0f:80e3:f11a:b8f5:b352:742e)
[23:13:16] <deniska> like, nvidia kernel modules were always distributed in such a way that it's the user installing them who violates the gpl
[23:13:18] <vdamewood> Mixing licenses is fine as long as they're compatible licenses.
[23:13:29] <DPA> "Forking a process and using pipes is different", no, it's not. If that was the case, I could circumvent the GPL using simple, auto generated, IPC. It'd be pointless.
[23:13:56] <vdamewood> DPA: Yes, it is. That's why gcc has such a convoluted infrastructure.
[23:14:05] <webnet4> there are a few distros who ship precompiled NVIDIA, or maybe one might be able to argue design it in such a way to be a quick one-click installer
[23:14:05] <vdamewood> To prevent people from simply forking and piping.
[23:14:07] <deniska> DPA: it's a murky territory, but precisely why stronger licenses like AGPL were invented
[23:14:47] <deniska> and gcc itself relaxes some parts of gpl, giving exemption to compiled programs which may contain parts of gcc used for compilation
[23:14:53] <webnet4> kernel devs too scared to make waves
[23:14:59] <DPA> Also, I can always just use lgpl for the backends.
[23:15:21] <vdamewood> DPA: https://www.gnu.org/licenses/gpl-faq.en.html#GPLPlugins
[23:15:23] <bayaz> Title: Frequently Asked Questions about the GNU Licenses - GNU Project - Free Software Foundation 
[23:15:57] <vdamewood> So, yeah, to correct my previous assertion, it also matter how 'intimiately' the data shared between the modules is.
[23:15:57] *** Quits: freakazoid343 (~matt@2603:9000:cf0f:80e3:455c:99e1:5db:1889) (Ping timeout: 245 seconds)
[23:16:29] <vdamewood> But if you just exec the plugin, and communicate using simple primatives or something like json, it's not a combined work.
[23:16:51] <webnet4> the whole driver is distributed out of compliance anyway, the part you "compile" is basically a giant blob into a tiny shell of an open program
[23:17:10] <deniska> big companies with tons of lawyers often avoid anything gpl related like a plague
[23:17:18] *** Quits: freakazoid12345 (~matt@2603:9000:cf0f:80e3:bdfd:43c9:908b:3a3f) (Ping timeout: 272 seconds)
[23:17:34] <deniska> and they probably already thought of all the tricks one may use to make use of gpl code :)
[23:18:08] <webnet4> the trick is social control
[23:18:24] <deniska> nvidia uses it by shifting responsibility to end users the kernel.org people just wouldn't care about
[23:18:58] <webnet4> they distribute the blob on their site, send them a DMCA
[23:19:06] <webnet4> .
[23:19:06] <deniska> blender plugins violate gpl just by the virtue of blender ppl not really caring
[23:19:16] *** Joins: freakazoid343 (~matt@2603:9000:cf0f:80e3:1940:bcf:9125:e1e8)
[23:19:29] <deniska> webnet4: yeah, but a blob isn't linked with a kernel until it is, by the installation process :)
[23:19:54] <webnet4> it is linked to the kernel version it relies on
[23:20:00] <vdamewood> Can I just mention how much I like the word 'blob'?
[23:20:14] *** Quits: amigojapan (uid86330@id-86330.brockwell.irccloud.com) (Quit: Connection closed for inactivity)
[23:20:21] <deniska> vdamewood: it sounds exactly the same way like what it is :)
[23:20:26] *** Joins: magla (~gelignite@55d48471.access.ecotel.net)
[23:20:27] *** Joins: freakazoid12345 (~matt@2603:9000:cf0f:80e3:c090:44fb:e504:f2e8)
[23:20:31] <vdamewood> deniska: Yep
[23:20:56] <webnet4> the blob makes calls into the kernel
[23:20:59] <webnet4> how is it not linked?
[23:21:15] <vdamewood> webnet4:It's not linked until the user does the linking.
[23:21:27] <webnet4> the nvidia programmer linked to develop it
[23:21:32] <webnet4> how is there NO link
[23:21:59] <vdamewood> I would guess the blob still has missing symbols or something like that.
[23:22:02] <deniska> webnet4: maybe it was developed against clean room linux 5.4 reimplementation, you never know
[23:22:09] <DPA> LLVM / clang isn't going to ever depend on any of my LGPL backends, they can't depend on any of my data structures, and thus they can't be affected by the GPL, even if I link against them.
[23:23:03] <vdamewood> DPA: Well, the LGPL and the GPL are different licenses.
[23:23:22] <pyzozord> so I think I found the answer for all algorithmic competetive programming puzzles for myself.
[23:23:26] <deniska> webnet4: and the result of linking was never distributed, only object files, so gpl isn't concerned with it
[23:23:27] *** Quits: freakazoid343 (~matt@2603:9000:cf0f:80e3:1940:bcf:9125:e1e8) (Ping timeout: 245 seconds)
[23:23:28] *** Quits: freakazoid333 (~matt@2603:9000:cf0f:80e3:f11a:b8f5:b352:742e) (Ping timeout: 256 seconds)
[23:23:36] <vdamewood> With the GPL, the mere act of linking causes the combined work to be GPL.
[23:23:51] <webnet4> the intent of nvidia was to link to GPL code
[23:24:00] <webnet4> i rest my case
[23:24:12] <deniska> woah woah woah, it's the intent of the user who wants to use nvidia driver is to link it against gpl code :)
[23:24:23] <vdamewood> With the LGPL, there is no 'combined work', and the terms of the LGPL only apply to the LGPL'd code itself. (with a few exceptions for  debugging and replacing the LGPL'd code.)
[23:25:02] <webnet4> the user didnt make the BLOB with unresolved GPL symbols
[23:25:19] <vdamewood> webnet4: Cool story. That will have to be decided in a court of law.
[23:25:19] <deniska> symbols can't be gpl
[23:25:35] <vdamewood> And so far, no one is suing.
[23:25:35] <webnet4> linux kernel is gpl 
[23:25:39] <deniska> names of functions aren't copyrightable
[23:25:50] <deniska> otherwise oracle would've won :)
[23:25:54] <webnet4> don't have to sue them, just issue DMCA takedown of the blob
[23:25:56] <pyzozord> I can think for days and get depressed. Or I can do what I am good at: code. I can compensate for my lack of mathematical cunning with just more code. Instead of trying to think of clever ways to solve problems I can just quickly write a brute force. And let my "real" solution design be guided by the tests against the brute force. It helps me find out patterns in solutions, it helps me find OBOEs. 
[23:26:02] <pyzozord> And also, sometimes I can tweak the brute force just a bit and it passes 100%
[23:26:59] <vdamewood> webnet4: DMCA take downs only apply to user-submitted data. Since nVidia both administers the site, and uploaded the content, the DMCA doesn't apply.
[23:27:00] <pyzozord> This has been such a robust techinique. It let me plow through problems I had no idea how to solve
[23:27:19] <webnet4> nvidia.com
[23:27:30] *** Joins: merijn (~merijn@83-160-49-249.ip.xs4all.nl)
[23:27:33] *** Joins: audio (~audio@2603-8081-1800-00ad-5769-2572-6cf8-a685.res6.spectrum.com)
[23:27:37] <deniska> you can't download linux from nvidia.com
[23:27:48] <webnet4> wow you guys are dense
[23:27:49] <webnet4> THE BLOB
[23:27:50] <deniska> only a kernel module part which you then have to link yourself
[23:27:52] <webnet4> ON NVIDIA.COM
[23:27:58] <deniska> sure, blobs areâ€¦ fine
[23:27:59] *** Joins: anon16_ (~anon16_@user/anon16)
[23:28:13] <vdamewood> webnet4: Yeah, that/'s not very respectful and friendly.
[23:28:20] <webnet4> its code that was designed with the intent to link to linux kernel which is GPL
[23:28:32] <deniska> blobs only violate gpl as soon as you redistribute the actual linux kernel linked with a blob
[23:28:39] <webnet4> if they published the source code, that would be fine but its proprietary
[23:28:47] <webnet4> do i need to walk you guys through nvidias history?
[23:29:04] <vdamewood> webnet4: Actually publishing source code wouldn't be enough. It also needs a GPL-compatible license.
[23:29:09] <deniska> nobody violates gpl if the actual product of linking is never distributed
[23:29:13] <webnet4> its GPL code
[23:29:23] <webnet4> but they claim its nvidia crap license code
[23:29:26] <deniska> and blob is not a product of linking :)
[23:29:27] <DPA> This is what Wikipedia says about it: https://en.wikipedia.org/wiki/License_compatibility#GPL_compatibility
[23:29:28] <webnet4> and don't publish
[23:29:28] <bayaz> Title: License compatibility - Wikipedia 
[23:29:30] *** Joins: freakazoid343 (~matt@35.136.210.185)
[23:29:30] *** Quits: freakazoid343 (~matt@35.136.210.185) (Client Quit)
[23:29:33] <webnet4> DMCA takedown the BLOB
[23:29:55] <deniska> If nvidia driver was problematic, so would be google android, or wine
[23:30:10] <vdamewood> webnet4: Well, like I said, the DMCA doesn't apply when the one uploading the content also administers the site.
[23:30:28] <webnet4> go read the DMCA
[23:30:48] <webnet4> if they don't comply they will pay a hefty price
[23:30:53] <DPA> There is no problem linking against GPL-Compatibe licensed code. The GPL just applies to the whole resulting binary in that case.
[23:30:55] <vdamewood> webnet4: I did, ince, a long time ago.
[23:30:58] <vdamewood> once*
[23:31:19] <webnet4> DPA they redistribute it
[23:31:24] <vdamewood> DPA: Yep.
[23:31:26] <deniska> if you can't download linux prelinked with the blob from nvidia.com, they're in the clear
[23:31:28] <webnet4> once you distribute it, its a problem
[23:31:40] <deniska> they don't distribute gpl derivative work
[23:31:51] <webnet4> the BLOB is, why are you ignoring what i'm saying?
[23:32:04] <deniska> The blob isn't gpl derivative work
[23:32:08] <webnet4> rofl
[23:32:23] <webnet4> *waves hands magically*
[23:32:29] <deniska> You can make non-gpl kernel with the same API, and nvidia driver will work with it :P
[23:33:06] *** Quits: freakazoid12345 (~matt@2603:9000:cf0f:80e3:c090:44fb:e504:f2e8) (Ping timeout: 256 seconds)
[23:33:17] <webnet4> you can, but they make cals into LINUX
[23:33:22] <DPA> I guess the big question is, clang & llvm, are their license compatible with gpl3?
[23:33:32] <deniska> webnet4: they make call into whatever kernel you link it with
[23:33:35] <webnet4> the linux PRIVATE ABI
[23:33:39] <vdamewood> DPA: Did you read my comment earlier about their license?
[23:33:53] <deniska> webnet4: APIs aren't copyrightable
[23:34:00] <vdamewood> Nor are ABIs
[23:34:01] <webnet4> what about version dependent ABI
[23:34:09] <deniska> webnet4: doesn't matter
[23:34:12] <webnet4> that hasnt been tested in court lol
[23:34:20] <webnet4> no one uis an authority on that answer
[23:34:34] <beaky> hello so visual studio code has smooth scorlling by default and emacs too has smooth scrolling with pixel-scroll-mode but does vim has smooth scrolling too
[23:34:34] <deniska> we tested oracle vs google, I'm ok with the answer we got, and I hope we won't get another
[23:35:02] *** Quits: mei (~mei@user/mei) (Read error: Connection reset by peer)
[23:35:06] *** Quits: Mangy_Dog (~Mange@user/mangy-dog/x-7397214) (Ping timeout: 272 seconds)
[23:35:19] *** Quits: anon16_ (~anon16_@user/anon16) (Read error: Connection reset by peer)
[23:35:20] <DPA> vdamewood: yes. So llvm is. What about clang?
[23:35:45] <vdamewood> DPA: Same license. It's part of the whole project.
[23:36:33] <DPA> Nice. Then there I see no problem linking against them from a GPL program.
[23:36:47] *** Joins: anon16_ (~anon16_@user/anon16)
[23:37:09] *** Joins: Mangy_Dog (Mange@user/mangy-dog/x-7397214)
[23:37:21] <deniska> DPA: other people might be reluctant to contribute or use your code
[23:37:40] *** Quits: webnet4 (~0x100@32.211.211.39) (Remote host closed the connection)
[23:37:52] *** Joins: webnet4 (~0x100@32.211.211.39)
[23:38:18] * vdamewood has a kitty next to him.
[23:38:49] <deniska> kitties â™¥
[23:39:00] <DPA> I hear that a lot. Their problem. This won't stop me from using it. There are a lot worse things out there, such as CLAs.
[23:39:19] <DPA> And people keep happily signing those...
[23:39:23] <vdamewood> I don't mind CLAs.
[23:39:27] <webnet4> can i redistribute proprietary emacs plyugins, in your world?
[23:39:48] <vdamewood> CLAs exist for a specific reason, that bit Mozilla in the ass a couple of decades ago.
[23:39:58] <vdamewood> Maybe just one decade ago.
[23:40:20] *** usedoken is now known as nekobased
[23:40:49] <vdamewood> Mozilla didn't have CLAs, so when they wanted to relicense Firefox onder a different license set, they had to go around to *every* contributor and ask permission to change the license form MPL to MPL?LGPL?GPL.
[23:40:53] <webnet4> or only NVIDIA is allowed to publish prorprietary emacs plugins
[23:41:08] *** Joins: smilingfrog (~smilingfr@S01061cabc06a4f03.no.shawcable.net)
[23:41:29] <vdamewood> See, now emacs is an evern worse example for your case than Linux, there actually are multiple implementations of emacs.
[23:41:36] <vdamewood> even worse, I mean
[23:41:55] <webnet4> it has portable plugins? wow
[23:42:00] <webnet4> nice work
[23:42:26] <webnet4> ok then proprietary emacs patches, for CUDA
[23:42:41] <pyzozord> I have to say I am so excited about that idea of writing brute force algorithms. It's so simple. I feel like this actually elevates me from depths of algorithmic despair to "there is some hope"
[23:43:00] <webnet4> thats fine for them to make a plugin that loads proprietary nonsense layers for authentication?
[23:43:14] <deniska> you may have harder time pitching proprietary plugins for emacs than nvidia has for graphics driver
[23:43:31] <deniska> but as far as you don't redistribute gnu/emacs+your plugin bundle, you're fine
[23:44:04] <pyzozord> I can't think through the problems. But I can write code that will think through the problem for me
[23:44:09] <vdamewood> deniska: s-gnu/emacs-GNU emacs-
[23:44:26] <deniska> gnuâ‹„emacs
[23:45:01] <vdamewood> GNU Ð˜macs
[23:45:29] <DPA> I will never sign a CLA. If it's a well accepted OSS license, I expect it to be kept as is. If they need rights, the license already provides them. If they want assurance that I am allowed to release stuff, by sending patches, I already do so. (I do accept DCOs though, although I regard them as redundant.)
[23:46:03] <vdamewood> Even better: ÐšÐ“Ð‘ Ð˜Ð¼Ð°ÐºÑ
[23:46:08] <deniska> D:
[23:46:20] <mawk> isn't Î“ a G ?
[23:46:29] <deniska> DPA: depends on your goals I guess
[23:46:33] <vdamewood> mawk: Yes. :D
[23:46:46] <mawk> lol
[23:46:49] <deniska> I typically lean towards more permissive ones nowadays
[23:46:54] <vdamewood> mawk: Take good look at that acronym.
[23:47:11] <mawk> yeah
[23:48:08] <beaky> yes Î“ is supposed to be G but programming language theorists insist on Î“ standing for Context if only they would just call it Gontext
[23:48:44] <vdamewood> The creature is rumbling.
[23:49:01] <Caffeinated> never heard beaky called that before
[23:49:16] *** Quits: Booster2ooo (~Booster2o@user/booster2ooo) (Read error: Connection reset by peer)
[23:49:35] <vdamewood> Not beaky. My little fuzzy murder machine.
[23:50:28] *** Joins: snake (~snake@user/snake)
[23:53:06] <vdamewood> Ð¥Ð•Ð›Ð›Ðž Ð£ÐžÐ Ð›Ð”!
[23:53:50] <vdamewood> deniska: ^ Wanna make your eyes bleed?
[23:53:59] <DPA> Oh, wait, I forgot something important. If I am to use the GPL for a compiler, I'll have to include an exception for the code produced by it, like GCC does right? I didn't have to deal with this before, I'll have to take a look at how GCC does it...
[23:54:33] <webnet4> yeah theres a library exception
[23:54:40] <vdamewood> DPA: gcc has that exception because it copies a bit of specific code into the binary.
[23:55:39] <vdamewood> DPA: One example is that gcc includes a boilerplate implementation of the _start function. That gets linked into your executable when you build with gcc.
[23:55:55] <deniska> vdamewood: that's not as eyes bleeding as replacing R with Ð¯ and other faux-cyrillics from 90s movies :)
[23:56:14] <vdamewood> Actually, I'm not sure _start can be called a function.
[23:56:58] <pyzozord> little fuzzy murder machine, is the best description of a cat I have heard in a long time
[23:57:15] *** Quits: webnet4 (~0x100@32.211.211.39) (Remote host closed the connection)
[23:57:30] *** Joins: webnet4 (~0x100@32.211.211.39)
[23:57:42] <vdamewood> deniska: Like TETÐ¯IS?
[23:57:59] <vdamewood> (Tetyais?)
[23:58:45] <DPA> I think what constitutes inclusion of code from the compiler is quiet difficult to determine. Does a special optimization in the compiler code that gets included count, for example? I think it's better to be safe than sorry here.
[23:59:22] <mawk> vdamewood: Î§Î•Î›Î›ÎŸ Î¥ÎŸÎ¡Î›Î”
