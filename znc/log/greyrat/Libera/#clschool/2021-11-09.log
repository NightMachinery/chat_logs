[00:00:09] <pjb> Jacobis9000: elf files, and other unix binary files, contain instructions to a loader program on how to load the program and data, and to link them with shared libraries.  The data doesn't exist before loading, and it's created upon loading in memory.
[00:01:04] <pjb> Jacobis9000: on the other hand, lisp image contain an image of the memory, with all the data and programs already existing and initialized, and linked. There's no linking with shared libraries.
[00:02:03] <pjb> Jacobis9000: in particular, to create a lisp image, we can use a lisp process, load and compile programs, initialize data, and then *save-the-lisp-image*, ie. make a copy of the current process memory into the image file.
[00:02:30] <pjb> Jacobis9000: thus loading the image file consist merely in copying back the file to memory, and continuing execution to where we were.
[00:03:26] <pjb> Jacobis9000: modulo some details, like open files and network connections that get closed upon reloading (unless the implemention tries to be smart and tries to re-open the files, but nothing can be done for network connections because of protocols).
[00:03:45] *** Joins: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca)
[00:05:02] <pjb> Jacobis9000: you could theorically develop an application, by loading an initial lisp image, edit it (ie. create new function, modify data, modify functions, debug it), then save the lisp image, and iterate, loading the last saved image, until your implementation becomes the application you want.
[00:05:03] *** Joins: shka (~herr@83.175.151.96.piasta.pl)
[00:05:13] <pjb> Jacobis9000: no need to use lisp source files on the external file system.
[00:05:35] <pjb> Jacobis9000: just the REPL.  The file system is only used to save the successive versions of lisp images.
[00:05:58] <pjb> Jacobis9000: Smalltalk works like this too, in general; cf. http://squeak.org/
[00:06:51] <pjb> Jacobis9000: the only problem is that it's difficult to work in teams, since there's this unique and central lisp image.  Squeak Smalltalk has git utilities inside the lisp image, to export/import sources with git repositories. It would be nice if we had that too.
[00:09:29] <pjb> Jacobis9000: there's gst, the gnu smalltalk, and there's ecl, that don't work with images, (they compile to elf binaries).
[00:18:54] *** Quits: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca) (Remote host closed the connection)
[01:13:16] <Jacobis9000> The book is asking me to make text appear with spaces in it, it has never demonstrated how to do this...
[01:22:42] <Jacobis9000> Ah I can do it
[01:27:56] <White_Flame> you can do eeeet
[01:45:23] <Jacobis9000> Cool I just coded a craps game, with directions from the book
[01:45:33] <Jacobis9000> That's the closest thing to my first real program in Lisp
[01:48:17] <White_Flame> neat, better than just a higher/lower number guessing game
[01:49:17] <Jacobis9000> I say directions, it told me the rules of craps and told me which functions it wanted, so gave me a structure, but I programmed the functions
[01:49:20] <Jacobis9000> It was a fun task
[01:49:25] <Jacobis9000> This book is really very good
[01:51:03] <White_Flame> which one?
[01:51:25] <Jacobis9000> Common Lisp: A gentle introduction to symbolic computation
[01:51:56] <White_Flame> ah, I haven't read that one
[01:52:04] <White_Flame> but, it's oft recommended
[01:53:32] *** Quits: shka (~herr@83.175.151.96.piasta.pl) (Ping timeout: 240 seconds)
[02:09:42] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[02:20:20] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[03:17:02] *** Quits: Jing (~hedgehog@2604:a840:3::1033) (Remote host closed the connection)
[03:17:34] *** Joins: Jing (~hedgehog@2604:a840:3::1033)
[03:55:22] *** Quits: johnjay (~pi@192.142.100.50) (Ping timeout: 260 seconds)
[04:04:57] *** Joins: johnjay (~pi@192.142.100.50)
[04:29:43] *** Quits: random-nick (~random-ni@87.116.176.55) (Ping timeout: 250 seconds)
[04:35:19] *** Quits: Jacobis9000 (~jonaholuf@host86-189-251-32.range86-189.btcentralplus.com) (Quit: Lost terminal)
[05:14:39] *** Joins: sjl (~sjl@cpe-66-66-5-59.rochester.res.rr.com)
[05:35:56] *** Quits: pjb (~pjb@user/pjb) (Ping timeout: 245 seconds)
[06:12:33] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[06:12:54] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Client Quit)
[06:16:08] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[06:17:15] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Client Quit)
[06:18:42] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[06:18:43] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Client Quit)
[06:20:22] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[06:21:06] *** ec_ is now known as ec
[06:27:15] *** Joins: lisp123 (~lisp123@5.30.23.247)
[06:30:10] <lisp123> If one is evaluating forms during runtime, what is the preferred way? Say I have (defvar *form*). Should I do (eval *form*) or (apply (car *form*) (cdr *form*))?
[06:30:47] <lisp123> (Or something else)? [This is in the context of writing my own unit testing framework (to add to the many that exist ;)]
[06:31:40] <mfiano> Just thunk them?
[06:33:44] <lisp123> how to do that?
[06:34:24] <mfiano> (defun make-thunk (data) (lambda () (do-something-to data))) (let ((t1 (make-thunk data))) ... some time later ... (funcall t1))
[06:39:09] <mfiano> Generally invoking the compiler at runtime (your first example) is going to incur a larger cost than looking up the function object associated with a particular symbol (the second example). Instead, you can thunk some form to be later funcall'd (my example), or perhaps store the function object separately from its arguments, instead of the symbol indirection.
[06:39:36] <mfiano> Each has their use though. It's hard to recommend something without more context.
[06:41:16] <mfiano> Usually when you find yourself using EVAL and you're not writing a compiler, or a compiler macro, it is usually a sign that there is a better way.
[06:41:49] <mfiano> There are exceptions of course, so I'd like to know what it is you're doing to be able to help any further.
[06:44:00] <lisp123> mfiano: Thanks, that's what I thought. So none of my forms will be known until runtime
[06:44:20] <lisp123> Think of a hash table storing all the forms to evaluate
[06:44:36] <lisp123> (what I thought --> In relation to Eval)
[06:45:19] <mfiano> Well the difference between (apply 'foo ...) and (apply #'foo ...) is usually a level of indirection, since the latter has a direct reference to the function in the lexical environment, and the latter is an indirect reference to a function of that name in the global environment.
[06:45:49] <mfiano> So obviously it has to do some looking up for the former
[06:46:28] <mfiano> err sorry i mixed that up
[06:46:46] <mfiano> 'foo would be indirect, and looked up in the global environment
[06:46:47] <lisp123> Yes, but I get your point
[06:47:01] <mfiano> #'foo would not, it is a direct reference to the lexical function
[06:47:02] <lisp123> But, I don't have functions, I just have lists
[06:47:16] <mfiano> which lexical may mean global, if you don't have an flet, etc
[06:47:19] <lisp123> I could create a function from them, but that sounds like extra work
[06:47:35] <mfiano> well you mentioned APPLY, which means you do
[06:47:51] <lisp123> (apply (car *form*) (cdr *form*))
[06:47:58] <lisp123> taking CAR / CDR Of list
[06:48:27] <mfiano> Right. That is taking the symbol in the CAR and looking for a function object of that name in the lexical environment
[06:49:04] <lisp123> So is that any faster/slwoer than Eval?
[06:49:12] <lisp123> And is there any other preferred way
[06:49:24] <mfiano> That can't be answered. The standard doesn't specify.
[06:49:54] <lisp123> (but thanks for your second last note, that helped clarify something which I should've known but wasn't thinking properly just now)
[06:49:55] <mfiano> The question though is why do you need your data structure to have this shape to begin with?
[06:50:24] <lisp123> I'm just experimenting with runtime stuff
[06:50:38] <mfiano> Not saying it's bad, just wondering why you need anything more than a closure.
[06:50:56] <mfiano> (which could have a very good answer, but I know next to nothing)
[06:51:13] <lisp123> How would you create a closure at runtime?
[06:51:42] <lisp123> THe stupid me just thinks of taking the form and encapsulating it within a lambda expression, but that sounds like extra effort vs. just eval/applying it
[06:51:47] <mfiano> You don't create it at runtime, though you could. The thunk is just funcall'd at runtime.
[06:52:06] <mfiano> A thunk is a zero-argument function. Sorry, that term is not often used in Lisp context.
[06:52:08] <lisp123> Ok I understand that. No, I'm talking purely at runtime
[06:52:44] <lisp123> I'm comfortable with doing stuff before runtime, just wanted to see what was the best way to evaluate a form that is created during runtime
[06:52:44] <mfiano> But to create anything at runtime, you can explicitly call #'compile
[06:53:10] <lisp123> Good idea, for anything requiring more than x number of evaluations, that will help. Thanks
[06:53:24] <mfiano> This is where the metacircularity of the language gets mind numbing :)
[06:53:50] <lisp123> Hehe :)
[06:54:37] <mfiano> There is no best way to do anything. It's all trade-offs all the way down...
[06:54:44] <lisp123> Okay, so there's no better way than EVAL or APPLY at runtime and seems like there's no particular winner between the two (I'm aware that apply has access to the lexical environment which eval doesn't, but apart from that)
[06:54:45] <mfiano> Depends on your implementation, data structures, etc
[06:55:21] <lisp123> Yes, true
[06:56:00] <lisp123> I will use apply for now
[06:57:31] *** Quits: sts-q (~sts-q@212.53.219.160) (Ping timeout: 256 seconds)
[06:58:26] <lisp123> From Stas (SBCL developer): EVAL calls APPLY, but APPLY doesn't call EVAL anymore. So APPLY is the part of evaluation which is used for calling functions once the macros and special forms have been processed.
[06:58:41] <mfiano> Good idea. I might also warn you that global state usually implies a lot of mutability and hard to understand code flow, hard to debug problems, and hard to extend programs. This is my subjective opinion, and you're likely to hear opposing views in the community, but using special variables as traditional global state is in my opinion over-used.
[06:58:43] <lisp123> Not sure if that is in reference to CL though, since they are talking about scheme too
[06:59:50] <lisp123> mfiano: No I agree with you a lot :) This is just for a small experiment / fun I'm doing
[07:00:29] <lisp123> I try to minimise any special variables as much as possible
[07:00:43] <mfiano> Good then carry on :)
[07:06:10] <lisp123> I just looked at the source code for Eval in SBCL
[07:06:31] <lisp123> Confirming it does call APPLY...and its a very complicated function too
[07:06:45] <lisp123> So in SBCL at least, APPLY > EVAL
[07:07:21] <mfiano> I wouldn't come to such a definitive conclusion
[07:08:10] <lisp123> Noted (I won't)
[07:08:13] <mfiano> If you're writing a compiler macro, and you don't use EVAL to check constant variables, you're probably doing it wrong.
[07:08:35] <mfiano> and I don't like RAPL's much :)
[07:08:39] *** Joins: sts-q (~sts-q@212.53.219.241)
[07:09:06] <lisp123> :)
[07:34:37] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Remote host closed the connection)
[07:36:15] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Quit: WeeChat 3.3)
[07:38:07] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[07:55:57] *** Joins: Oladon (~olad@98.43.81.226)
[08:14:24] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (*.net *.split)
[08:14:24] *** Quits: edgar-rft (~edgar-rft@hsi-kbw-109-193-249-223.hsi7.kabel-badenwuerttemberg.de) (*.net *.split)
[08:14:24] *** Quits: paule32_ (~paule32@user/paule32) (*.net *.split)
[08:14:24] *** Quits: zagura (~zagura@user/zagura) (*.net *.split)
[08:15:13] *** Joins: edgar-rft (~edgar-rft@hsi-kbw-109-193-249-223.hsi7.kabel-badenwuerttemberg.de)
[08:15:13] *** Joins: paule32_ (~paule32@user/paule32)
[08:15:13] *** Joins: zagura (~zagura@user/zagura)
[08:58:08] <White_Flame> one thing missed above is if the arguments are evaluated.  (apply #'+ '(1 2 (+ 3 4))) isn't going to work
[08:59:12] <White_Flame> or obv if there are variable names referenced in the CDR portion
[09:12:32] *** Quits: bcasiello (~bcasiello@066-189-087-112.biz.spectrum.com) (Ping timeout: 240 seconds)
[09:13:23] <CodeBitCookie[m]> beach: You answered to me yesterday and I am sorry for the late reply. What do you mean by modular? Like as in a big program broken up into parts? Also In many cases C++ is faster than C. Common Lisp is slower than both of them BY DEFAULT. Writing a program in C++ makes you optimize from the get go and then optimize further, that coming at the cost of reliability whereas in CL, we can just write code fast but it won't be as fast. These
[09:13:23] <CodeBitCookie[m]> relate to all the papers trying to get their CL code to run as fast as C. 
[09:14:24] <beach> Yes, by "modular" I mean a large system broken into parts.
[09:15:02] <beach> And I am willing to bet that the comparisons you are referring to are not with large modular systems.
[09:15:46] <beach> I don't think there are any studies that compare such systems, so from comparing small systems you can't make the conclusions that you cite.
[09:16:18] <CodeBitCookie[m]> So you are saying in larger programs, CL wins? (in performance)
[09:16:34] <CodeBitCookie[m]> in safety and in syntax too?
[09:16:35] <beach> Yes, and here is why...
[09:16:49] <CodeBitCookie[m]> CodeBitCookie[m]: this I agree with.
[09:17:01] <beach> When you have a large C++ program, you need to break it up into independent modules.
[09:17:28] <beach> But if your program is manipulating nontrivial objects, you need to know when those objects can be deallocated.
[09:18:22] <beach> This is not generally possible in modular code.  In fact, it's part of the very definition of modularity that client code is not supposed to know the internals of a module, and the internals of a module can vary over time.
[09:18:35] <beach> So how do C++ programmers deal with this problem?
[09:19:16] <beach> ... i.e., the problem of knowing whether there is still some module having a reference to some object.
[09:19:21] <mfiano> Reference counting pointers?
[09:19:36] <mfiano> Or whatever they are called in C++
[09:19:41] <CodeBitCookie[m]> yeah, smart pointers. 
[09:19:43] <beach> One solution is to use "copy semantics", to make sure that there is exactly one reference to any live object.
[09:20:02] <beach> Then you lose already, because Common Lisp passes only pointers and doesn't copy objects.
[09:20:11] <beach> So you can use reference counters.
[09:20:17] <CodeBitCookie[m]> well no, it doesn't copy.
[09:20:23] <CodeBitCookie[m]> its a bit more to that.
[09:20:35] <beach> "it"?
[09:20:35] <mfiano> Isn't reference counting a problem for cyclic data anyway?
[09:20:44] <beach> If you use copy semantics, it copies.
[09:21:04] <beach> That is, you declare your arguments to be the class or the struct.
[09:21:22] <beach> Now, if you don't want to copy, you can use reference counters.
[09:21:36] <beach> Then, an assignment in Common Lisp is just a register-to-register operation.
[09:21:44] <CodeBitCookie[m]> beach: That is up to the programmer, if he wants to copy, reference or use a pointer to that location.
[09:22:13] <beach> But in the presence of reference counters, and assignment turns into a test, some arithmetic, and a function call.  So again, C++ loses.
[09:22:21] *** Quits: mala (~mala@user/malaclyps) (Quit: ZNC 1.6.1 - http://znc.in)
[09:22:23] <beach> CodeBitCookie[m]: You are not listening...
[09:22:48] <beach> CodeBitCookie[m]: If the programmers uses pointers, then there is no way to tell how many references there are to some object, if the code is modular.
[09:22:57] <White_Flame> mfiano: basic refcounting is a lot slower than GC as well
[09:23:20] <beach> So one solution programmers have is to copy.  And if they copy, they no longer use pointers.  It's that simple.
[09:24:04] <mfiano> White_Flame: I'll take your word for it, but would assume C++ is anything but 'basic'.
[09:24:16] <CodeBitCookie[m]> beach: Well, smart pointers allocate a block of memory near to the location of the memory it is pointing to, which keeps the refcount. Using an offset or just the smart pointers classes can easily get you the number.
[09:24:39] <White_Flame> beach: a lot of C/C++ programs also use global tables of state to avoid dealing with individualized scopes for freeing
[09:24:59] <White_Flame> mfiano: yes, C++ refcounting is basic
[09:25:07] <beach> CodeBitCookie[m]: A simple assignment is more than an order of magnitude slower in the presence of reference counters.
[09:25:26] <White_Flame> plus, as you pass pointers around, refcounting needs to write to the object, even if the code isn't reading it but just transparently passing it around, which causes even more memory pressure
[09:25:40] <beach> White_Flame: I don't know what those global tables are, but it doesn't sound modular to me.
[09:25:53] <White_Flame> beach: correct.  Old-style global memory
[09:26:21] <CodeBitCookie[m]> beach: I don't understand how reference counters relate to any of this.
[09:26:24] <beach> So I am arguing that modular code can't be fast in C++.
[09:26:48] <beach> CodeBitCookie[m]: They are slow, but they are needed in modular code.  So modular C++ code is slow.
[09:27:03] <White_Flame> C++ is also massively dispatch-heavy.  Any runtime behavior is almost always "interpreted", while in Lisp you can codegen & have natively compiled routines specific for a runtime state
[09:27:06] <CodeBitCookie[m]> beach: How does it matter if the code is modular or not? It is still connected.
[09:27:16] <beach> I told you already.
[09:27:22] <White_Flame> or have LIsp config actually compile new code at startup, instead of C++ loading in config and still always branching around at runtime
[09:27:37] <beach> If the code is modular, a single module can't know the number of references to an object, so it can't know when the object can be deallocated.
[09:27:48] <White_Flame> in any case, C/C++ is fast in the small, but slow in the large
[09:28:28] <CodeBitCookie[m]> beach: Ahhh, now I see what you are saying. This needs a bit of thinking
[09:28:49] <White_Flame> beach: all modular C++ code libs come with extensive documentation & policy about ownership of objects and whose responsibility it is to deallocate
[09:29:03] <White_Flame> which of course is extra programmer/designer burden
[09:29:12] <beach> White_Flame: I don't call that "modular" then.
[09:29:31] <mfiano> Let's take the modular, very large, Linux kernel as an extreme example.
[09:29:32] *** Joins: shka (~herr@83.175.151.96.piasta.pl)
[09:29:36] <White_Flame> well, "composable" ;)  But a lot of brick laying by hand
[09:29:39] <beach> Such code must be a huge maintenance headache. 
[09:30:05] <CodeBitCookie[m]> beach: Well than, all of cpp libs arent'  "modular" then.
[09:30:23] <beach> That sounds about right.
[09:30:28] <White_Flame> it is
[09:30:30] <White_Flame> designing safe usage policy is another extra engineering task on top of the software development
[09:30:34] <CodeBitCookie[m]> beach: I was only talking about performance. Not about the programmer headache
[09:30:39] <beach> Modularity requires automatic memory management.
[09:31:14] <beach> CodeBitCookie[m]: But, again, there are no comparisons of performance between languages in large modular programs.
[09:31:54] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[09:32:04] <CodeBitCookie[m]> beach: Two more things: Why isn't CL used more if it's so good? Java uses a GC but its so slowww. Why so?
[09:32:15] <beach> I am convinced that a Common Lisp version of (say) MuseScore would be faster than the original.
[09:32:35] <White_Flame> java's pretty fast.  what slow stuff do you see?  java can even do inlining across virtual function calls etc
[09:32:39] <beach> CodeBitCookie[m]: Your assumption that good things become popular is wrong.
[09:33:36] <mfiano> Because industry would rather hire expendable brainless Java boilerplate writers, than to think of a longterm investment.
[09:33:46] <White_Flame> JITs are amazing things nowadays, I wish a CL were to be written around one
[09:34:05] <beach> mfiano: It is worse than that.  They don't have the knowledge and training to do anything else.
[09:34:15] <CodeBitCookie[m]> White_Flame: I made a game engine in Java, long story short, it was quite slow and I don't only say that, you can read any benchmark, big, or small, modular or not. 
[09:34:21] <beach> mfiano: So don't attribute the behavior to thought out choices. 
[09:34:32] <White_Flame> well, java GC pauses are bad for games
[09:34:39] <mfiano> That is fair.
[09:34:50] <CodeBitCookie[m]> White_Flame: That is what I was mainly referencing, I wasn't clear.
[09:35:04] <White_Flame> but the actual speed of processing (including GC delay) is very competitive
[09:35:06] *** Quits: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 260 seconds)
[09:35:18] <White_Flame> and again things like inline virtual calls are specifically faster than C++
[09:35:30] <beach> CodeBitCookie[m]: malloc/free is slower than a good GC.
[09:36:01] <beach> CodeBitCookie[m]: And in C++, if you free a huge graph, then you have delays as well.
[09:36:28] <mfiano> The Rust community is starting to free on a background thread because of amount of heap data involved to get around the borrow checker...and then they run into classic threading issues.
[09:38:04] <CodeBitCookie[m]> so you are saying that CL is fast, already optimized, powerfull, less headache, small/more modular code, and there is no reason to not use it except for libraries and amount of people who actually care about this language?
[09:38:24] <White_Flame> just like every other minority language
[09:38:37] <White_Flame> (re the library issue & popularity contests)
[09:38:52] <beach> CodeBitCookie[m]: Sounds right.
[09:39:15] <beach> CodeBitCookie[m]: And that's just talking raw performance.
[09:39:46] <beach> CodeBitCookie[m]: If you then take programming effort into account, as Hudak and Jones report, you will get huge differences too.
[09:39:51] <CodeBitCookie[m]> White_Flame: So now, Only the most popular languages are bad and the minority is good?
[09:39:57] <White_Flame> wat
[09:40:15] <CodeBitCookie[m]> beach: That is what I meant by "less headache"
[09:40:29] <beach> I see.
[09:40:31] <CodeBitCookie[m]> White_Flame: White_Flame: ^
[09:40:32] <White_Flame> I'm just saying those 2 issues are not unique to common lisp at all, but rather most languages by count are in that situation
[09:40:45] <CodeBitCookie[m]> White_Flame: Oh, ok
[09:41:15] <White_Flame> and regardless of their strengths, don't have organized industry push (eg, people making money selling training, marketing to convince managers, etc) and aren't in common use
[09:42:46] <CodeBitCookie[m]> Well, the reason I am using C++ for this project I am making which will be really big (hopefully I don't give up in the middle), is because of the bad GUI situation in CL.
[09:43:05] <CodeBitCookie[m]> Over the past few days you have seen me struggle with GUIs in CL.
[09:43:26] <White_Flame> yep, games support for CL is okay, CLIM Is getting usable for enthusiasts, and I personally use web interfaces
[09:44:21] <CodeBitCookie[m]> yeah, although this application would be mostly gui and for teachers and general planning.
[09:44:39] <beach> I am willing to bet that a modest investment in adapting/improving McCLIM to a new task is comparable to the hassle of using FFI to a GUI library in C or C++.
[09:44:53] <White_Flame> however, you can always do heterogeneous programming, to use features & libs from other languages, instead of burdening _all_ of your development as C++ just to gain gui access
[09:45:18] <mfiano> imgui from Lisp for example, works fine.
[09:45:36] * mfiano is a game engine developer
[09:45:47] <White_Flame> and LTK works, though it's slow
[09:45:59] <CodeBitCookie[m]> mfiano: Ah I see.
[09:46:28] <CodeBitCookie[m]> White_Flame: Well, I tried LTK and remember I talked to you about it, but the only thing lacking in it is the theming.
[09:46:48] <White_Flame> web is the only good looking GUI  stuff anyway
[09:46:52] <White_Flame> regarding those sorts of things
[09:46:59] <CodeBitCookie[m]> mfiano: Also IMGUI won't cut it for 10 year old computers which most people use.
[09:47:05] <CodeBitCookie[m]> (atleast in my country)
[09:47:20] <beach> What country is that?
[09:47:43] <CodeBitCookie[m]> White_Flame: Yeah but that reaches very bad performance, requires internet access (most of the time) and ALOT of bloat.
[09:47:56] <mfiano> Really? I develop on a roughly 15 year old PC to be sure my code runs good everywhere.
[09:47:59] <White_Flame> the "bloat" = features & complexity necessary for good rendering
[09:49:18] <CodeBitCookie[m]> beach: Pakistan. Well, atleast in Karachi. Most people use good computers but in markets and most companies just give there employees that old computer.
[09:49:32] <CodeBitCookie[m]> mfiano: Wow. How does OpenGL even work on that?
[09:49:42] <CodeBitCookie[m]> or is that sarcastic?
[09:50:10] <beach> I see.
[09:50:14] <CodeBitCookie[m]> White_Flame: Look, if I can just make GTK work, I will use CL for the project.
[09:50:23] <CodeBitCookie[m]> mfiano: ^
[09:51:32] <mfiano> Modern OpenGL (3.3+) with vertex buffers is actually very old at this point. 12 years iirc. You can go even older with extensions
[09:52:27] <mfiano> Wait, VAO's appeared in 2008
[09:52:36] <mfiano> So older than I thought
[09:52:58] <CodeBitCookie[m]> Well, I also have a 9-10 year old laptop which is kind of my main workstation. Modern OpenGL barely works on that 
[09:53:30] <CodeBitCookie[m]> like it can't process a modern clearscreen call
[09:53:44] <CodeBitCookie[m]> mfiano: How did you do it?
[09:56:07] <White_Flame> hmm, my main machine is "only" 6 years odl
[09:56:08] <mfiano> shrug. cl-opengl works fine with whatever I throw at it. It's pretty surprising what even very old gpu hardware is capable of. sounds like you should be offloading the cpu more.
[09:57:18] <CodeBitCookie[m]> mfiano: what do you mean by offloading the cpu? Also opengl directly fails on that and even all the tests on linux for opengl give back that it can't support opengl 3.3
[09:57:25] <CodeBitCookie[m]> Here is my computer:
[09:57:30] <CodeBitCookie[m]> Dell Studio-1555
[09:57:55] <CodeBitCookie[m]> I put an extra 0.5 GB Ram which makes it total about 1.5 GB ram.
[09:58:10] <mfiano> unless you are doing crazy procedural content generation or newtonian physics, there is little reason for you cpu to be utilized barely at all.
[09:58:54] <CodeBitCookie[m]> mfiano: so, it isn't utilized at all...
[09:59:19] <CodeBitCookie[m]> the cpu is fine with this stuff. Just not modern opengl. Rendering a simple triangle, barely works.
[09:59:52] <mfiano> then you must have failing hardware or your are fill rate limited and you should look into gpu profiling.
[10:00:30] <CodeBitCookie[m]> I mean, I have integrated graphics.
[10:00:45] <CodeBitCookie[m]> mfiano: Is there really any way to know which hardware is failing?
[10:01:17] <CodeBitCookie[m]> Actually, now that I think about it. Some SDL examples work on that computer.
[10:01:29] <mfiano> shrug. i never had the problems you speak of.
[10:02:16] <mfiano> i develop on an old intel integrated gpu and test on a modern nvidia machine.
[10:02:17] <CodeBitCookie[m]> Yeah, that is the response everyone gives me. I am trying to buy a new Desktop anyway so.
[10:02:41] *** Joins: st_iron (uid370243@id-370243.uxbridge.irccloud.com)
[10:02:58] <CodeBitCookie[m]> If your code is open source, would me mind giving me the link?
[10:02:59] <CodeBitCookie[m]> Maybe I can test that code?
[10:04:31] <mfiano> Stopped writing open code a few months ago when my partner needed a year off, so I'm afraid my open source code has bitrotted to unworking status
[10:05:03] <mfiano> well more like a year ago
[10:05:30] <mfiano> hmm february...so not quite
[10:05:42] <CodeBitCookie[m]> well can I atleast see?
[10:05:49] <CodeBitCookie[m]> even if it doesn't work.
[10:06:02] <CodeBitCookie[m]> Also, it's pretty cool you work with a partner.
[10:06:03] <mfiano> it doesn't guaranteed. i have changed too many dependencies
[10:06:13] <CodeBitCookie[m]> Ok.
[10:07:04] <mfiano> Yeah it's just a general-purpose game engine we have been working on for maybe 10 years or so
[10:07:30] <mfiano> But it is nowhere near ready yet, and that's with all the time saved by using Lisp. Save yourself while you still can
[10:07:35] <CodeBitCookie[m]> Woahhhh.
[10:08:07] <CodeBitCookie[m]> mfiano: by saving myself, do you mean using Lisp or making game engines.
[10:08:12] <CodeBitCookie[m]> s/./?/
[10:10:30] <mfiano> I would say if you want to make a game, make a game. Don't generalize it, or try to make much of it re-usable. You can't possibly know how to optimize for the data flow until the game has been written, so it's only going to be a bunch of tradeoffs you thought were the right choice at the time.
[10:11:08] <mfiano> It's very easy to just end up with a glorified screensaver years later. Even if you have a complete engine suitable for the type of game you are making, actual content creation and game logic is an even longer process
[10:11:47] <White_Flame> yeah, even with smaller hobby stuff I've done, if you want to make a game, then make a game and worry abotu the tech later
[10:11:53] <White_Flame> *make the game first
[10:12:42] <CodeBitCookie[m]>  Well, the thing is, if I wanted to make a game, I would have used Unity or Godot. I just really like messing around in memory and I love graphics programming. I don't want to make a game. I just love writing code and outputting graphics onto the screen.
[10:12:43] <White_Flame> eg, get the gameplay style, a handle on what assets you need, etc, and get it working onscreen as directly as possible.  Then I'd say start architecting around only what you need for your game
[10:13:34] <mfiano> The problem with game engines is they are just a set of choices someone made for you. General purpose engines like Unity are great, but incur about 10x performance penalty over just writing your own simpler engine for the data flow your game demands.
[10:14:08] <White_Flame> plus, as with _any_ external framework, there's always going to be an impedance mismatch between your desired usage, and what it provides, and the need to write bridges & adapters between things
[10:14:20] <mfiano> yes this
[10:14:24] <White_Flame> so you end up with your own abstractions anyway
[10:14:40] <mfiano> if you have an engine, chances are you will be hacking it to make your idea work, if it allows you to.
[10:15:01] <White_Flame> or if you're smart, start with what the engine can do, and design around that model
[10:15:07] <mfiano> or writing some 11th hour hack horror stories i've read about from friends in industry
[10:15:42] <White_Flame> save your good ideas for when you're more experienced :)
[10:16:55] <CodeBitCookie[m]> White_Flame: mfiano: hmmm. Thats pretty good advice actually. 
[10:17:40] <CodeBitCookie[m]> Although, I still can't get GTK working ;(
[10:17:44] *** Joins: mala (~mala@user/malaclyps)
[10:18:15] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[10:18:15] <CodeBitCookie[m]> Why isn't cl-cffi-gtk WORKINGLKJARKJAN
[10:18:43] <mfiano> Because foreign code bitrots much faster than conforming CL? :)
[10:19:24] <CodeBitCookie[m]> mfiano: What does that mean/
[10:19:25] <CodeBitCookie[m]> s///?/
[10:20:17] <mfiano> It means it isn't uncommon for Lisp bindings to be constantly fixed as their wrapped libraries change.
[10:20:49] <mfiano> Using pure CL where possible will save you if you value developer time and code longevity.
[10:21:26] <mfiano> Hell, there is code from the 60's that still runs on conforming CL implementations.
[10:22:02] <CodeBitCookie[m]> mfiano: mfiano: This is good fun and all but if I can't write a GUI for my GUI program then what do I do.
[10:22:23] <CodeBitCookie[m]> I have no choice but to not use CL.
[10:22:34] <CodeBitCookie[m]> atleast how I see it.
[10:23:12] <mfiano> Nothing is stopping you from writing a native GL GUI like Shinmera did with Alloy/Kandria.
[10:23:23] <mfiano> Maybe you just need more experience/practice?
[10:23:27] <CodeBitCookie[m]> Also, just, in general. CL-CFFI-GTK just doesn't work with Quicklisp because it has 2 versions. 2 Github Repos.
[10:23:28] <beach> CodeBitCookie[m]: Your situation is unusual.  You don't seem to care about modularity, not the amount of effort you spend.  And you want your code to work on fairly old hardware.  So then, sure, go ahead and use C++.
[10:24:12] <beach> s/not/nor/
[10:26:14] <CodeBitCookie[m]> beach: Wow, you didn't get my point. First, all of those points were for the performance argument we were having. Second, I do care about all of those things really heavily, that is how I got here in the first place. The only reason I am FORCED to use C++ is because I want to use GTK. I don't have enough experience but nor enough time to write my own from scratch. I can develop on newer harware but it needs to work with old too. I
[10:26:14] <CodeBitCookie[m]> can't just disregard the people using older computers. If I wanted to do that I would have used OpenGL to make a GUI.
[10:27:06] <mfiano> I am seeing too many logic errors in your reasoning.
[10:27:09] <CodeBitCookie[m]> Also, Its not just my computer, A lot of computers which I can't name off the top of my head also aren't able to use modern opengl.
[10:27:11] <mfiano> But good luck to you
[10:27:15] <mfiano> I need to sleep
[10:27:57] <CodeBitCookie[m]> mfiano: Can you atleast tell me what are the errors?
[10:28:04] <CodeBitCookie[m]> s/Can you atleast tell me what are the errors?/Can you atleast tell me what the errors are?/
[10:29:21] <CodeBitCookie[m]> Well thanks, and sleep well.
[10:30:00] <CodeBitCookie[m]> Okay, I am going to try once more to fix cl-cffi-gtk into working. 
[10:30:02] <mfiano> I don't like repeating myself, but for starters, "modern OpenGL" as it is called, is actually not modern at all, and is more than 10 years old. A computer of that time would have a harder time browsing the web.
[10:30:06] <mfiano> But good night
[10:30:55] <CodeBitCookie[m]> Also quote from the README on the repo: "
[10:30:55] <CodeBitCookie[m]> The library compiles and runs under Windows 7, but when moving an application
[10:30:55] <CodeBitCookie[m]> window the application will freeze. This bug is not solved at this time."
[10:31:39] <CodeBitCookie[m]> Okay. I will try and see if my code works on other hardware.
[10:35:02] *** Quits: Jing (~hedgehog@2604:a840:3::1033) (Remote host closed the connection)
[10:38:36] *** Joins: Jing (~hedgehog@2604:a840:3::1033)
[10:40:08] <CodeBitCookie[m]> beach: I will ask the owner of the LTK repo to help in themeing. Thanks for the help and maybe I need to calm down a bit and think it over.
[11:04:41] <White_Flame> why is theming a make or break feature for a professional audience?
[11:06:14] <CodeBitCookie[m]> They aren't really professional though.
[11:07:04] <CodeBitCookie[m]> White_Flame: I guess I could make a version with ceramic.
[11:07:21] <CodeBitCookie[m]> And one with McCLIM
[11:07:28] <CodeBitCookie[m]> Would that be too hard to manage?
[11:07:39] <White_Flame> I don't know what your requirements are
[11:08:09] <CodeBitCookie[m]> White_Flame: Requirements for the GUI to work with my application?
[11:08:17] <White_Flame> yes
[11:08:36] <White_Flame> and what your deployment requirements are, too
[11:08:47] <White_Flame> the devil's in the details
[11:09:11] <CodeBitCookie[m]> White_Flame: Okay, if you can help me apply this two line patch to the GTK repo, I would be greatly thankfull.
[11:09:23] <CodeBitCookie[m]> White_Flame: Okay, so:
[11:09:55] <CodeBitCookie[m]> 1. It needs to work on old Harware (upto 10 years old)
[11:10:01] *** Joins: rain3 (~rain3___@2a02:2f09:d10a:400:9e2f:eb47:e2ae:761d)
[11:10:09] <White_Flame> tha'ts not specific enough
[11:10:14] <White_Flame> and your performance will vary a ton
[11:10:32] <White_Flame> I don't mean that I need to hear every requirement, I'm just saying that to answer some of these questions would require more intimate knowledge of your project :-P
[11:10:38] <CodeBitCookie[m]> White_Flame: what do you mean?
[11:11:14] <White_Flame> and again, I skip pretty much all native-OS GUI stuff and go web, so I can't help you with GUI-specific details
[11:11:34] <White_Flame> unless it's just literally a CL question about some of its code & changes
[11:12:41] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Read error: Connection reset by peer)
[11:13:04] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[11:15:46] <CodeBitCookie[m]> <White_Flame> "I don't mean that I need to hear..." <- Oh. Well, Its needs to work, as in I don't have to reinvent the wheel or apply patches for a simple color picker. It needs to be relatively fast meaning not slower than 3-5 seconds for loading a page or going to a new tab. It needs access to other social media quite heavily. It should also not be too heavy in terms of RAM and Harddrive space. Hard-disk space can be compromised for
[11:15:46] <CodeBitCookie[m]> less RAM usage.  
[11:16:22] <CodeBitCookie[m]> White_Flame: Well that's fine.
[11:17:23] <CodeBitCookie[m]> White_Flame: Although I am guessing it can't work offline.
[11:17:48] <White_Flame> social media integration would be a lot harder for a non-web application
[11:18:09] <CodeBitCookie[m]> Yeah, but without the social media integration I meant.
[11:18:21] <CodeBitCookie[m]> Like, just a normal GUI.
[11:18:30] <CodeBitCookie[m]> that doesn't need access to the internet.
[11:18:43] <CodeBitCookie[m]> * White_Flame:  that doesn't
[11:36:20] <CodeBitCookie[m]> White_Flame: Apparently ceramic examples don't work because of lucerne and the owner has no activity since the last commit on any of his repos.
[12:05:59] *** Quits: edgar-rft (~edgar-rft@hsi-kbw-109-193-249-223.hsi7.kabel-badenwuerttemberg.de) (Quit: Leaving)
[12:30:47] <beach> CodeBitCookie[m]: So what I was alluding to before when I mentioned the article by Hudak and Jones was that there is evidence to suggest that programmer productivity can vary by as much as a factor 20 depending the language, and in their article, C++ is the big loser.  
[12:30:57] <beach> So say you have a project that is estimated to take a year.  If you choose a different programming language, you may finish it in a few weeks.  This leaves enough time to gain experience with whatever GUI framework you want, or even to write your own.  Plus the experience thus gained will benefit future projects as well.  
[12:30:58] <beach> Now perhaps the difference is not as much as a factor 20, but even a factor 2 would be significant for the same reason.
[12:32:05] <beach> So saying you don't have enough experience with something, and therefore must avoid using it the same as saying that you don't think that learning it will improve your productivity, so it is a net loss of time.  But you can't know that if you don't have the experience.
[12:33:29] <beach> This the same problem that industry has.  They choose a language based on what their programmers already know.  But, again, the article by Hudak and Jones suggests that the cost of learning a new language is tiny compared to the potential difference is productivity between languages. 
[12:34:23] <il> beach, that's very interesting. Sorry if you posted already, can you share the source of that article?
[12:34:33] <beach> I say "suggests" rather than "shows", because the program they uses is very small.  I don't believe anyone will ever try an experiment with a sufficiently large project, because the cost would be huge. 
[12:34:42] <beach> Let me search for it...
[12:35:10] <beach> https://web.cecs.pdx.edu/~apt/cs457_2005/hudak-jones.pdf
[12:35:27] <beach> The article is about Haskell, but that's not the important part of it as I see it.
[12:36:02] <beach> The important part is that the difference in productivity can be huge, and is rarely taken into account.  In industry, it is even implicitly assumed that all languages are roughly equally productive. 
[12:37:57] <beach> So when I said that CodeBitCookie[m] apparently didn't care about the amount of effort spent, that's what I meant.  Choosing C++ may very well slow down progress so significantly that it would have been better to learn about other GUI frameworks, or even to improve one.
[12:39:41] <beach> Another aspect I often encounter in my encounters with industry is the overemphasis on run-time performance.  "We need all the speed we can get" is the same as saying "We are willing to spend any amount of time, effort, and money, for even the tiniest gain in performance".
[12:40:33] <beach> But then, because they choose a programming language with very low productivity, they don't have enough time to think about algorithms and data structures, so their end result is slow anyway, despite the huge additional effort they spent.
[12:45:35] <beach> Yet another interesting thing that I learned recently about C++ is that its exception system is pretty much useless, and that many organizations have an explicit rule that it must not be used.  
[12:45:40] <beach> I have seen C programs (not C++ programs) that don't use setjmp/longjmp (for reasons of ignorance no doubt) and instead pass error return values from functions.  In one case, the code was more than 80% error handling, completely hiding the purpose of the application.  
[12:45:41] <beach> I can only imagine how much additional effort it takes to write something like that, not to mention maintain it.  
[12:47:17] <beach> In a language without automatic memory management, you can't even compose functions correctly.  You can't say f(g(x)).  You have to say <type> temp1 = g(x); <type> temp2 = f(temp1); free(temp1) return(temp2);
[12:48:19] <beach> Not only is that 5 times as much code as should be required.  It also makes the purpose of the code totally obscure.  Again, what does that fact do to programmer productivity and the maintenance cost of the code.
[12:49:18] <beach> If I were in that situation, I would definitely go reference counters.  But then, like I said, every performance advantage resulting from a good compiler would be lost, 10 times over.
[12:50:11] <beach> Sorry for the rant, but what CodeBitCookie[m] started saying a few hours ago is something that makes me very upset. 
[13:00:44] <CodeBitCookie[m]> beach: Sorry, I thought about it for some time, now I think what you are saying is what I will do.
[13:01:08] <beach> Great!
[13:01:09] <CodeBitCookie[m]> What you are saying now totally makes sense. I was just really confused.
[13:02:32] <CodeBitCookie[m]> Just to recap, I use any GUI framework that works for now to create an application in Common Lisp. After I quickly have created it, I will learn more about GUIs and maybe even write my own. I then will create my dream application in Common Lisp again. In that time I would have only created the basic application if I were to use C++.
[13:02:50] <CodeBitCookie[m]> Thanks for the help, I have to go eat. brb
[13:03:01] <beach> Sure, take care.
[13:06:15] <CodeBitCookie[m]> im back.
[13:06:28] <CodeBitCookie[m]> mom didn't call to eat.
[13:06:42] <CodeBitCookie[m]> McCLIM it is then!
[13:13:55] <beach> If you go McCLIM, you will find that #clim is a very helpful channel.  jackdaniel is very present and he is the main maintainer of the repository. 
[13:15:09] <CodeBitCookie[m]> Yayyyy. It feels great not having to worry about it working with my project.
[13:55:06] *** Joins: pjb (~pjb@user/pjb)
[15:10:29] *** Joins: random-nick (~random-ni@87.116.165.220)
[15:38:09] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[17:01:51] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[17:07:36] *** Quits: pjb (~pjb@user/pjb) (Ping timeout: 245 seconds)
[17:35:21] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 250 seconds)
[17:37:10] *** Joins: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se)
[18:12:18] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[18:28:45] *** Joins: thrig (~thrig@70.97.65.251)
[18:35:36] *** Quits: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se) (Quit: WeeChat 3.3)
[18:35:47] *** Quits: thrig (~thrig@70.97.65.251) (Remote host closed the connection)
[18:38:03] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[18:52:53] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 264 seconds)
[19:54:30] *** Joins: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca)
[19:57:03] *** Joins: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de)
[20:22:33] *** Quits: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca) (Remote host closed the connection)
[20:27:03] *** Joins: Oladon (~olad@98.43.81.226)
[20:59:05] *** Joins: waleee (~waleee@192.165.44.49)
[21:00:44] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[21:07:44] *** Joins: lisp123 (~lisp123@45.86.202.96)
[21:29:55] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[21:44:12] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[21:45:25] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[21:48:19] *** Joins: lisp123_ (~lisp123@5.30.23.247)
[21:52:17] *** Quits: lisp123 (~lisp123@45.86.202.96) (Ping timeout: 256 seconds)
[21:52:20] *** Joins: bcasiello (~bcasiello@066-189-087-112.biz.spectrum.com)
[22:06:37] *** Quits: rain3 (~rain3___@2a02:2f09:d10a:400:9e2f:eb47:e2ae:761d) (Ping timeout: 250 seconds)
[22:06:46] *** Quits: mala (~mala@user/malaclyps) (Quit: ZNC 1.6.1 - http://znc.in)
[22:07:32] *** Joins: mala (~mala@user/malaclyps)
[22:25:41] *** Quits: lisp123_ (~lisp123@5.30.23.247) (Ping timeout: 250 seconds)
[22:31:50] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[22:54:13] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[22:55:35] *** Quits: waleee (~waleee@192.165.44.49) (Ping timeout: 246 seconds)
[23:03:05] *** Joins: beach` (~user@2a01:cb19:150:3400:7057:d018:12f5:5521)
[23:07:52] *** Quits: beach (~user@2a01:cb19:150:3400:1d3c:41a7:29c:8bd8) (Ping timeout: 268 seconds)
[23:16:36] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[23:21:10] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[23:23:17] *** Joins: malaclyps (~mala@user/malaclyps)
[23:25:19] *** Joins: jfb4_ (~jfb4@178.62.2.68)
[23:28:29] *** Joins: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se)
[23:30:46] *** Quits: mala (~mala@user/malaclyps) (*.net *.split)
[23:30:46] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (*.net *.split)
[23:30:46] *** Quits: jfb4 (~jfb4@178.62.2.68) (*.net *.split)
[23:30:47] *** jfb4_ is now known as jfb4
