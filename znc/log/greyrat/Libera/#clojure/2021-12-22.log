[00:01:39] *** Quits: amk (~amk@109.255.169.126) (Remote host closed the connection)
[00:11:02] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[00:12:42] *** Quits: shiranaihito_ (~textual@123-192-192-149.dynamic.kbronet.com.tw) (Quit: My MacBook Air has gone to sleep. ZZZzzz‚Ä¶)
[00:25:12] *** Quits: MajorBiscuit (~MajorBisc@62-52-102.netrun.cytanet.com.cy) (Ping timeout: 256 seconds)
[00:25:34] *** Quits: joe_colben (~joe____co@185.190.112.211) (Remote host closed the connection)
[00:29:55] *** Joins: amk (~amk@109.255.169.126)
[00:39:11] *** Quits: amk (~amk@109.255.169.126) (Remote host closed the connection)
[00:42:11] *** Joins: atw (~user@2601:5c2:c500:76b0::73e)
[00:53:23] *** Joins: matty_matt (~matt@129.222.239.110)
[00:57:37] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[01:11:06] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[01:12:13] *** Joins: matty_ma1 (~matt@129.222.239.110)
[01:15:55] *** Joins: amk (~amk@109.255.169.126)
[01:19:37] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[01:20:21] *** Joins: matty_ma1 (~matt@129.222.239.110)
[01:20:26] *** Quits: amk (~amk@109.255.169.126) (Remote host closed the connection)
[01:25:16] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[01:25:53] *** Joins: matty_matt (~matt@129.222.239.110)
[01:26:52] *** Joins: matty_ma1 (~matt@129.222.239.110)
[01:30:17] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[01:31:02] *** Quits: euandreh (~euandreh@2804:14c:33:9fe5:b7fd:fa95:80d6:f41) (Ping timeout: 240 seconds)
[01:37:46] *** Joins: matty_matt (~matt@129.222.239.110)
[01:47:37] *** Joins: amk (~amk@109.255.169.126)
[01:49:01] *** Quits: ToxicFrog (~ToxicFrog@198-200-100-178.cpe.distributel.net) (Ping timeout: 268 seconds)
[01:52:43] <ridcully_> since kaocha --watch does not like infinite loops, i thought: let's break portal with it.  does not bend
[01:53:54] <ridcully_> clojure.inspector finally is out of my pimped repl.  no more looking at metal PLAF
[01:55:03] *** Joins: MajorBiscuit (~MajorBisc@62-52-102.netrun.cytanet.com.cy)
[02:00:29] *** Quits: amk (~amk@109.255.169.126) (Remote host closed the connection)
[02:01:42] *** Joins: euandreh (~euandreh@2804:14c:33:9fe5:1bce:ba7c:3f01:c9f3)
[02:06:58] *** Joins: amk (~amk@109.255.169.126)
[02:07:27] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 250 seconds)
[02:14:34] *** Quits: MajorBiscuit (~MajorBisc@62-52-102.netrun.cytanet.com.cy) (Ping timeout: 256 seconds)
[02:21:47] *** Joins: matty_ma1 (~matt@129.222.239.110)
[02:27:16] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 268 seconds)
[02:31:43] *** Joins: ToxicFrog (~ToxicFrog@198-200-100-178.cpe.distributel.net)
[02:38:27] *** Joins: kaisyu (uid37155@id-37155.ilkley.irccloud.com)
[02:48:00] *** Quits: schmudde (~schmudde@216.169.6.249) (Ping timeout: 256 seconds)
[02:52:44] *** Quits: Colt (~Colt@user/colt) (Remote host closed the connection)
[02:53:14] *** Joins: Colt (~Colt@user/colt)
[02:59:24] *** Quits: Colt (~Colt@user/colt) (Remote host closed the connection)
[02:59:50] *** Joins: Colt (~Colt@user/colt)
[03:00:25] *** Quits: matty_matt (~matt@129.222.239.110) (Quit: WeeChat 3.2)
[03:04:17] *** Quits: atw (~user@2601:5c2:c500:76b0::73e) (Ping timeout: 240 seconds)
[03:37:52] *** Quits: lunik1 (~lunik1@37.205.14.203) (Ping timeout: 256 seconds)
[03:41:42] *** Joins: atw (~user@2601:5c2:c500:76b0::ec2f)
[03:45:40] *** Joins: lunik1 (~lunik1@37.205.14.203)
[03:46:12] *** Quits: euandreh (~euandreh@2804:14c:33:9fe5:1bce:ba7c:3f01:c9f3) (Ping timeout: 268 seconds)
[03:48:38] <RedNifre> Is there something like Kotlin's throwing TODO("not implemented :(") that you can use in places that you haven't coded yet?
[03:50:12] <ridcully_> as in for a test to pass or just throw?
[03:50:53] <ridcully_> for the later, maybe (assert nil "not implimented :(")
[03:53:55] *** Quits: ajoberstar (~user@97-116-72-197.mpls.qwest.net) (Quit: ERC 5.4.1 (IRC client for GNU Emacs 29.0.50))
[04:04:11] *** Quits: seschwar (~seschwar@user/seschwar) (Quit: :wq)
[04:34:04] *** Joins: euandreh (~euandreh@2804:14c:33:9fe5:157f:fad:702e:d7a)
[04:47:19] <RedNifre> What's a good way to get a seq of LocalDate days of a year? I tried the Java stuff, but .until gives me a java stream, so I'm probably not doing it the idiomatic way here.
[04:47:38] <RedNifre> The goal is to get a seq of business days, excluding custom holidays.
[04:48:12] *** Quits: kaisyu (uid37155@id-37155.ilkley.irccloud.com) (Quit: Connection closed for inactivity)
[05:15:48] *** Joins: schmudde (~schmudde@216.169.6.249)
[05:23:00] *** Quits: cmiles74 (~miles@068-184-030-013.res.spectrum.com) (Ping timeout: 268 seconds)
[06:02:03] *** Joins: matty_matt (~matt@129.222.239.110)
[06:03:18] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Ping timeout: 276 seconds)
[06:04:03] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[06:16:41] <atw> I think you can do (seq (.iterator the-stream)), but that's based on reading docs, not on actually trying it
[06:25:46] <atw> hang on, that doesn't seem to be working. I'll try something else
[06:43:42] *** Quits: DasBrain (~DasBrain@user/dasbrain) (Killed (NickServ (GHOST command used by DasBrain_)))
[06:43:48] *** Joins: DasBrain_ (~DasBrain@user/dasbrain)
[06:45:21] <atw> you can do (iterator-seq (.iterator the-stream)). This appears to be necessary, calling .iterator on a stream yields a java.util.Spliterators$1Adapter, and clojure can't seem to make that into a seq
[06:46:25] <atw> so that allows you to consume the stream, but I also want to see if we can make a seq directly. How are you generating the stream of LocalDates RedNifre?
[07:08:17] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[07:10:37] *** Quits: jespada (~jespada@87.74.33.157) (Ping timeout: 240 seconds)
[07:12:22] *** Joins: jespada (~jespada@87.74.33.157)
[07:18:17] *** Joins: matty_matt (~matt@129.222.239.110)
[07:34:49] *** Joins: matty_ma1 (~matt@129.222.239.110)
[07:34:55] *** Quits: matty_ma1 (~matt@129.222.239.110) (Client Quit)
[07:35:12] *** Joins: matty_ma1 (~matt@129.222.239.110)
[07:49:11] *** Joins: libertyprime (~libertypr@203-109-232-143.dsl.dyn.ihug.co.nz)
[08:03:33] *** Joins: puchka (~marius@165.73.241.3)
[08:12:42] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[08:23:18] *** Joins: matty_matt (~matt@129.222.239.110)
[08:26:52] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[08:28:23] *** Joins: shiranaihito (~textual@123-192-192-149.dynamic.kbronet.com.tw)
[08:36:37] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[09:16:03] *** Joins: matty_matt (~matt@129.222.239.110)
[09:20:42] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[09:26:37] *** Quits: libertyprime (~libertypr@203-109-232-143.dsl.dyn.ihug.co.nz) (Ping timeout: 240 seconds)
[09:35:17] *** Quits: atw (~user@2601:5c2:c500:76b0::ec2f) (Ping timeout: 240 seconds)
[09:47:48] *** Joins: matty_matt (~matt@129.222.239.110)
[09:48:27] *** Joins: libertyprime (~libertypr@203-109-232-143.dsl.dyn.ihug.co.nz)
[09:52:26] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[10:08:14] *** Joins: mbuf (~Shakthi@171.61.232.157)
[10:08:19] *** Quits: libertyprime (~libertypr@203-109-232-143.dsl.dyn.ihug.co.nz) (Ping timeout: 256 seconds)
[10:08:54] *** Joins: libertyprime (~libertypr@203-109-232-143.dsl.dyn.ihug.co.nz)
[10:19:19] *** Joins: matty_matt (~matt@129.222.239.110)
[10:22:57] *** Quits: libertyprime (~libertypr@203-109-232-143.dsl.dyn.ihug.co.nz) (Ping timeout: 240 seconds)
[10:23:56] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 268 seconds)
[10:47:08] *** Joins: struchu (~struchu@staticline-31-183-184-5.toya.net.pl)
[11:11:25] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Ping timeout: 268 seconds)
[11:17:47] *** Joins: MajorBiscuit (~MajorBisc@62-52-102.netrun.cytanet.com.cy)
[11:35:41] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[11:55:27] *** Joins: egli (~user@193-47-178-139-pool.fiber.fcom.ch)
[11:56:29] *** Joins: libertyprime (~libertypr@115-189-97-69.mobile.spark.co.nz)
[12:20:46] *** Quits: libertyprime (~libertypr@115-189-97-69.mobile.spark.co.nz) (Read error: Connection reset by peer)
[12:22:36] *** Quits: schmudde (~schmudde@216.169.6.249) (Ping timeout: 256 seconds)
[13:47:37] *** Joins: matty_matt (~matt@129.222.239.110)
[13:52:08] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[14:37:57] *** Quits: MajorBiscuit (~MajorBisc@62-52-102.netrun.cytanet.com.cy) (Ping timeout: 240 seconds)
[14:40:04] *** Joins: MajorBiscuit (~MajorBisc@c-001-001-037.client.tudelft.eduvpn.nl)
[15:30:25] *** Quits: jespada (~jespada@87.74.33.157) (Ping timeout: 268 seconds)
[15:32:59] *** Joins: jespada (~jespada@87.74.33.157)
[15:32:59] *** Joins: matty_matt (~matt@129.222.239.110)
[16:01:19] *** Joins: joe_colben (~joe____co@185.190.112.211)
[16:11:45] *** Quits: joe_colben (~joe____co@185.190.112.211) (Remote host closed the connection)
[16:49:44] *** Joins: cmiles74 (~miles@068-184-030-013.res.spectrum.com)
[17:49:41] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 252 seconds)
[18:02:03] *** Quits: egli (~user@193-47-178-139-pool.fiber.fcom.ch) (Ping timeout: 256 seconds)
[18:04:16] <RedNifre> atw I create the LocalDate stream the java way, i.e. (.datesUntil first-day last-day)
[18:04:44] <RedNifre> (->> stream .iterator iterator-seq) works, thank you.
[18:05:32] <RedNifre> Another thing, I'm very confused by import, require, :require, refer, use and having them inside or outside of ns. Is there a comprehensive "How to import in Clojure" guide somewhere?
[18:06:36] <RedNifre> e.g. the clj doc on java-time says (refer-clojure :exclude [...]) (use 'java-time), but the excludes does not work and the imported "contains?" from java-time breaks my code everywhere I want to use the collection's contains?.
[18:06:40] <selfsymmetric-mu> RedNifre: Me too! I've just been copying things, and should probably learn it properly.
[18:07:31] <ridcully_> rule of thunmb: :require/:import is always in ns - without the : it's a function you can call in your repl or maybe in standalone script (they are never used in "code")
[18:08:38] <RedNifre> Have a look at the "For the purpose of this guide" part here, what's the proper way to import it then?: https://cljdoc.org/d/clojure.java-time/clojure.java-time/0.3.3/doc/readme
[18:08:48] <ridcully_> avoid use if you can - pick a short alias and stick with it
[18:09:40] <ridcully_> RedNifre: without the : it means someone entered that in a repl
[18:10:43] <ridcully_> the following examples allow for shortest possible code then.  the refer-clojure would also imply a fresh ns in this repl, since clojure.core is usually there when you start it up
[18:11:36] <ridcully_> RedNifre: if you have a look at https://clojuredocs.org/clojure.core/ns there is a full example of all the things.  you most likely would add : and remove '
[18:12:37] <RedNifre> Thanks, I'll check it out. Also, this doesn't work because a ctor is missing, is there an easy fix?: (def custom-holidays (map #(LocalDate. (str "2022" "-" %)) '("12-24" "12-31")))
[18:13:16] <ridcully_> i'd suggest not to refer-clojure+use.  (:require [java.time :as t])
[18:13:38] <RedNifre> My Java brain says to add a type hint on the constructor like LocalDate<String>. but that's probably not a thing in clojure, huh?
[18:13:38] <ridcully_> LocaleDate/parse
[18:13:52] <ridcully_> does it actually have a public c'tor for string?
[18:13:53] * RedNifre nods
[18:14:17] *** Joins: schmudde (~schmudde@216.169.6.249)
[18:14:20] <RedNifre> I think you could pass a date, or maybe that was the local-date function from java-time.
[18:14:48] <ridcully_> i thought it only has static initializers.  parse, of, now, ...
[18:15:17] <RedNifre> yeah, must have been local-date then and I only changed that to LocalDate. when the import broke.
[18:16:04] <RedNifre> Does anyone use Cursive? It has a lot of problems typing parens, which is so insane that I think I have a buggy install or use them completely wrongly :/
[18:18:11] <Para> I do.
[18:18:23] <Para> I have disabled paredit. Helps a ton.
[18:18:50] <Para> Paredit is agressively hindering from simply writing code IMHO - I think we had this discussion just a few days ago :)
[18:19:56] <RedNifre> I guess Paredit is about editing the AST instead of characters?
[18:20:52] <RedNifre> Thanks, I turned it off for now and might revisit it later.
[18:21:59] <ridcully_> i think we have this discussion every month or so ;)
[18:23:46] <ridcully_> paredit (at least the version i know, which is not the one from cursive) is quite smart about inserting parens as pairs.  and it allows you to move code around more structured.  e.g. move forms around or "slurp" and "barf" things out of them
[18:24:23] <ridcully_> there is also parinfer which i totally don't get.  it magically determines the parens from indenting
[18:28:41] *** Quits: puchka (~marius@165.73.241.3) (Ping timeout: 256 seconds)
[18:29:01] *** Joins: seschwar (~seschwar@user/seschwar)
[18:29:12] *** Joins: matty_matt (~matt@129.222.239.110)
[18:30:09] *** Joins: matty_ma1 (~matt@129.222.239.110)
[18:33:25] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[18:35:38] <RedNifre> ridcully_: Yeah, that sounds great in theory, I'll give it a second chance later.
[18:43:50] *** Quits: neirac (~neirac@pc-122-191-45-190.cm.vtr.net) (Quit: ZNC 1.8.2 - https://znc.in)
[18:45:37] *** Joins: neirac (~neirac@pc-122-191-45-190.cm.vtr.net)
[18:56:07] <Para> ridcully_: Cursive has its own slurp/barf stuff, which probably is conflicting.
[18:56:41] <Para> I wish Cursive would just use the scope expand/contraction/navigation shortcuts which IDEA provides as a platform :/
[18:56:47] *** Quits: lunik1 (~lunik1@37.205.14.203) (Ping timeout: 252 seconds)
[18:57:49] <ridcully_> tbf i have disabled the "smart pair" stuff in idea too - but i only use idea when i have to
[18:59:06] *** Quits: struchu (~struchu@staticline-31-183-184-5.toya.net.pl) (Quit: WeeChat 3.3)
[19:03:50] *** Joins: lunik1 (~lunik1@37.205.14.203)
[19:11:45] *** Quits: lunik1 (~lunik1@37.205.14.203) (Ping timeout: 256 seconds)
[19:13:55] *** Joins: lunik1 (~lunik1@37.205.14.203)
[19:25:59] *** Quits: lunik1 (~lunik1@37.205.14.203) (Ping timeout: 268 seconds)
[19:30:37] *** Joins: matty_matt (~matt@129.222.239.110)
[19:38:11] *** Joins: lunik1 (~lunik1@37.205.14.203)
[19:39:20] *** Joins: mwnaylor (~user@2601:5ce:4300:5560::68b3)
[19:39:55] *** Quits: lunik1 (~lunik1@37.205.14.203) (Client Quit)
[19:40:50] *** Joins: puchka (~marius@196.240.128.2)
[19:42:41] *** Joins: AdmiralBumbleBee (~AdmiralBu@47.203.174.105)
[19:44:03] *** Quits: jespada (~jespada@87.74.33.157) (Ping timeout: 256 seconds)
[19:44:49] *** Parts: manicennui (uid349235@id-349235.tinside.irccloud.com) ()
[19:46:29] *** Joins: jespada (~jespada@87.74.33.157)
[19:57:50] *** Quits: mbuf (~Shakthi@171.61.232.157) (Quit: Leaving)
[20:20:45] *** Joins: lunik1 (~lunik1@37.205.14.203)
[20:23:43] *** Joins: neirac_ (~neirac@pc-122-191-45-190.cm.vtr.net)
[20:37:53] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[20:47:04] <RedNifre> How do I find functions efficiently? For example, right now I have '("a" "b" "c") and '(["x" "a"] ["y" "b"] ["z" "a"]) and I want to transform that into {"a" '("x" "z") "b" '("y") "c" '()}, but I don't know what functions to search for.
[20:48:28] *** Joins: matty_ma1 (~matt@129.222.239.110)
[20:49:31] <ridcully_> id guess this is quite special and combines two things i'd say
[20:50:02] <ridcully_> for one you are only interested in some keys?  so your first list could be small but your second list with the tuples huge with many different second values?
[20:50:25] <RedNifre> yeah, one thing is sort of a for-each i in (a b c) and the other is a for i, find all values in ([][][]) where i=second value in vector
[20:50:28] <ridcully_> so the question here is: either build the result up from the second list and the `select-keys` via the first list
[20:50:44] <ridcully_> or use the first list to filter the second and then build the result up from there
[20:50:55] <RedNifre> nah, the first list has 15 strings, the second list has about 250 vectors and the second value in those vectors is always a value from the 15 strings
[20:51:47] <ridcully_> word of warning: maps have no order by default.  so the result there could work with a sorted-map or you would have to investigate into ordered-map
[20:53:14] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 260 seconds)
[20:53:39] <RedNifre> I don't need the keys ordered, only the values in the list, but I think I'll do it in two steps, since just having the list for one key already has value by itself.
[20:54:54] *** Quits: uncleyear (~ian@pppoe.178-66-158-61.dynamic.avangarddsl.ru) (Remote host closed the connection)
[20:55:49] *** Joins: uncleyear (~ian@pppoe.178-66-158-61.dynamic.avangarddsl.ru)
[20:56:36] <RedNifre> This works, but is it idiomatic?: (->> vectors (filter #(= value (% 1))) (map #(% 0)))
[20:58:45] <ridcully_> #(% 0) is just first.  and then i'd use second for the filter
[21:00:52] <RedNifre> üëç
[21:01:30] *** Joins: matty_ma1 (~matt@129.222.239.110)
[21:04:31] <Para> Could also do something like `(keep #(when (= (second %) 3) (first %)) vectors)`
[21:04:47] <Para> (I used 3 in my test, so obviously change that)
[21:04:56] <ridcully_> small transformations like this are also quite readable with `for` and :when
[21:05:14] <Para> ...argh my weechat went nuts again, whyyy doesn't this thing like unicode
[21:05:18] <Para> Or is it putty
[21:05:38] <ridcully_> (for [[v k] vectors :when (= k value)] v) (roughly... untested)
[21:06:51] <ridcully_> Para: my ptsd says, it's putty ;P
[21:08:28] <Para> I'm apparently also running a five year old version of putty. I should probably do a repair install to my home PC.
[21:10:58] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 260 seconds)
[21:16:37] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[21:17:00] *** Joins: matty_ma1 (~matt@129.222.239.110)
[21:22:15] *** Joins: matty_matt (~matt@129.222.239.110)
[21:31:47] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 268 seconds)
[21:39:12] *** Quits: MajorBiscuit (~MajorBisc@c-001-001-037.client.tudelft.eduvpn.nl) (Quit: WeeChat 3.3)
[21:44:56] *** Joins: matty_matt (~matt@129.222.239.110)
[21:47:53] *** Joins: MajorBiscuit (~MajorBisc@62-52-102.netrun.cytanet.com.cy)
[21:48:08] *** Quits: puchka (~marius@196.240.128.2) (Quit: leaving)
[21:49:17] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[22:17:03] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[22:23:27] *** Joins: matty_matt (~matt@129.222.239.110)
[22:26:41] *** Quits: schmudde (~schmudde@216.169.6.249) (Ping timeout: 256 seconds)
[22:27:37] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[22:31:32] *** Joins: schmudde (~schmudde@216.169.6.249)
[22:37:21] *** Joins: matty_ma1 (~matt@129.222.239.110)
[22:39:37] *** Quits: mwnaylor (~user@2601:5ce:4300:5560::68b3) (Ping timeout: 240 seconds)
[22:47:39] *** Quits: schmudde (~schmudde@216.169.6.249) (Ping timeout: 256 seconds)
[22:54:57] <RedNifre> Para oh, sorry for the unicode. I'm also on weechat, everything works, so it might be Putty (I use mosh, everything looks fine to me).
[22:54:59] *** Joins: lxsameer (~lxsameer@user/lxsameer)
[22:55:35] <lxsameer> hey folks, have you ever done something like `(defn X []... (def Y ...) ....)`
[22:58:34] <ridcully_> lxsameer: noe, because you should not
[22:59:05] <ridcully_> you usually see this in beginner code because they not yet know about let
[23:07:38] <jeaye> lxsameer: It's useful in the repl, for being able to inspect internal bits to a function. It's not something you should be committing to production, thouogh.
[23:10:44] <lxsameer> ridcully_: i know, I'm curious whether people actually done it or not
[23:11:22] <jeaye> I'll often add a def into an existing function, like `(defn do-work! [request] (def repl-request request) ...)` and then I can do whatever action calls that function. Afterward, I can evaluate `repl-request` in the REPL and work with the whole value. This is a lot more helpful than logging it, since I have the actual value, so I can call other functions on it.
[23:11:24] <lxsameer> jeaye: why not to do `(defn X [] ... (let [y ..] ....)...)` instead
[23:11:29] <ridcully_> call that function on top level to create some other things top level?  macroish stuff?
[23:11:51] <ridcully_> lxsameer: the temp-def allows you to eval sub-forms
[23:12:30] <jeaye> lxsameer: let won't work in my scenario, since it only affects the local scope. The whole point is to elevate a local val to the global scope so the repl can later access it.
[23:12:49] <lxsameer> so would you mind if the language yell at you when you use a `def` in a `defn`
[23:12:52] <lxsameer> ?
[23:12:55] <ridcully_> for long running stuff it can be also abused as a progress meter
[23:13:04] <jeaye> lxsameer: I wouldn't mind a warning.
[23:13:20] <jeaye> But it should let me do it, since there are reasons why I'd want to do it.
[23:13:52] <lxsameer> thanks for the input folks
[23:18:16] <ridcully_> another problem or no-problem thinking about it: AFAIK def is syncronized against the namespace (?) - so this could be useful to debug parallel stuff or on the other hand could hide your real problem etc
[23:21:01] *** Joins: DasBrain (~DasBrain@user/dasbrain)
[23:22:50] <Para> Yep, defs live in ns.
[23:23:42] <Para> "Creates and interns or locates a global var with the name of symbol and a namespace of the value of the current namespace (*ns*). See http://clojure.org/special_forms for more information."
[23:23:59] *** Joins: matty_matt (~matt@129.222.239.110)
[23:24:37] *** Quits: DasBrain_ (~DasBrain@user/dasbrain) (Ping timeout: 240 seconds)
[23:25:28] <ridcully_> i really meant synchronized.  it has a single lock agsinst the ns to do it (afaik)
[23:30:13] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[23:30:47] *** Joins: birdspider (~birdspide@188-23-93-42.adsl.highway.telekom.at)
[23:37:46] <RedNifre> I find it a bit weird that sometimes you need -> and sometimes ->>. The problem seems to be that some function take the data as the last arguments, while others as the first. Why is that? Wouldn't it be better if all functions took the data as the last argument, so you'd use ->> most of the time?
[23:41:17] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[23:42:12] *** Joins: matty_ma1 (~matt@129.222.239.110)
[23:45:10] <jeaye> RedNifre: There's a very intentional design to this which you're probably missing.
[23:46:09] <jeaye> RedNifre: Clojure's core functions take sequences in the last position and otherwise take the pertinent input in the first position.
[23:46:37] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[23:46:39] <jeaye> RedNifre: So assoc, update, dissoc, etc all work with -> since they're working on one thing. One map, typically.
[23:46:56] <Para> Also assoc supports infinite number of kv pairs, that wouldn't work with ->>
[23:46:59] <jeaye> RedNifre: Wherease filter, map, reduce, sort, etc all work with ->> since they're working with sequences of things.
[23:47:38] *** Joins: matty_ma1 (~matt@129.222.239.110)
[23:47:47] <jeaye> As soon as you see this design, you may realize that you're not designing your own functions to work the same way, which is then impacting how easy it is for you to pipeline your data naturally.
[23:51:26] *** Joins: darkstardevx (~darkstard@50.39.115.145)
[23:51:51] <ridcully_> also if you find yourself battling against -> and ->> to make it work - don't.  use a let in between to keep things sane.  don't bend over backwards to make it work by some tricks
[23:52:53] *** Quits: darkstardevx (~darkstard@50.39.115.145) (Remote host closed the connection)
[23:53:19] *** Joins: darkstardevx (~darkstard@50.39.115.145)
[23:53:46] <sobel> One more thing. The same design that helps -> work so conveniently also helps 'apply'
[23:56:32] <ridcully_> but you will also see apply inside ->> as it takes the sequence last.  so it fits in the transformation pipeline bracket
[23:56:52] <jeaye> I'm not seeing a way to park and take from multiple async channels. i.e. `(let [[r1 r2] (a/all [chan-1 chan-2]))` Am I missing it?
[23:57:33] <jeaye> alts! will go with the first chan to finish and merge surprisingly returns the first value, not all values.
