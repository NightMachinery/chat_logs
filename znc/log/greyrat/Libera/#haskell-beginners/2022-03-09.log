[00:15:25] *** Joins: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl)
[00:29:18] *** Joins: toulene (~toulene@user/toulene)
[00:45:24] *** Quits: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl) (Ping timeout: 240 seconds)
[00:49:24] *** Joins: coot (~coot@213.134.190.95)
[01:01:52] *** Quits: romesrf (~romes@44.190.189.46.rev.vodafone.pt) (Ping timeout: 250 seconds)
[01:03:00] *** Joins: romesrf (~romes@44.190.189.46.rev.vodafone.pt)
[01:17:46] *** Quits: coot (~coot@213.134.190.95) (Quit: coot)
[01:20:50] *** Joins: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl)
[01:25:42] *** Quits: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl) (Ping timeout: 256 seconds)
[01:44:37] <boborygmy> Hey all, I have a question, I guess, or a request for where to look for more info:
[01:44:37] <boborygmy> There's this Ed Kmett post (but my question is simple!):
[01:44:37] <boborygmy> https://www.schoolofhaskell.com/user/edwardk/online-lca
[01:44:37] <boborygmy> He defines a data type that apparently creates an adhoc operator definition
[01:44:37] <boborygmy> at the same time:
[01:44:50] <boborygmy> type Id = Int
[01:44:50] <boborygmy> data Path = [Id] :# !Int
[01:44:50] <boborygmy> empty :: Path
[01:44:50] <boborygmy> empty = [] :# 0
[01:44:50] <boborygmy> cons :: Id -> Path -> Path
[01:44:51] <boborygmy> cons a (ys :# n) = (a:ys) :# (n + 1)
[01:45:42] <boborygmy> I don't think I've seen that kind of technique before with the :#
[01:45:57] <geekosaur> it's just a data constructor expressed as an operator
[01:46:06] <geekosaur> no different from lists using (:)
[01:46:40] <geekosaur> data [] a = [] | a : [] a -- sadly you can't write this but it's the same idea
[01:46:59] <geekosaur> you can define normal operators too
[01:47:11] <geekosaur> a <> b = mappend a b
[01:47:21] <geekosaur> defines the operator <>
[01:50:12] <boborygmy> I guess I'm just a bit thrown by how it's introduced on the right and then when you evaluate the Paths, it shows up as "[1,2,3,4,5] :# 5"
[01:50:49] <geekosaur> data constructors are always on the right, type constructors on the left
[01:50:56] <geekosaur> if I understand what you're confused about
[01:51:12] <geekosaur> (you can also define type operators, but they're even more mind bending)
[01:51:24] <boborygmy> ha, not there just yet..
[01:52:09] <boborygmy> are there any writeups somewhere where an operator comes into being this way?
[01:54:00] <geekosaur> Idon't think I've seen a specific writeup
[01:54:41] <geekosaur> @src (.)
[01:54:41] <lambdabot> (f . g) x = f (g x)
[01:54:57] <romesrf> @src ($)
[01:54:57] <lambdabot> f $ x = f x
[01:55:29] <boborygmy> @src (:)
[01:55:29] <lambdabot> Source not found. My pet ferret can type better than you!
[01:55:53] <romesrf> boborygmy: nice try hahaha, I would expect that to work. you're on the right track i believe
[01:56:03] <geekosaur> lists are wired into the compiler though
[01:56:06] <romesrf> ^
[01:56:14] <geekosaur> at some point there have to be some fundamental built-in things
[01:56:29] <boborygmy> Well in any case I cannot look away right now, this is blowing my mind a bit
[01:56:41] <romesrf> @src (elemIndex)
[01:56:41] <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
[01:56:45] <boborygmy> This learning haskell is full of surprises
[01:56:48] <romesrf> @src (,)
[01:56:48] <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
[01:56:52] <geekosaur> @src elemIndex
[01:56:52] <lambdabot> elemIndex x = findIndex (x==)
[01:56:52] <romesrf> boborygmy: indeed
[01:57:01] <geekosaur> tuple syntax is also wired in
[01:57:15] <romesrf> geekosaur: was phishing for that :)
[01:57:20] <geekosaur> and kinda special since comma has several other meanings
[01:57:22] <boborygmy> Yes. But this thing acts almost like a tuple
[01:57:56] <ski> but doesn't use commas
[01:58:01] <boborygmy> in that you're defining something like thing operator thing and it just is there to keep the two things around
[01:58:07] <boborygmy> Right
[01:58:32] <ski> it's not really much different from `data Path = MkPath [Id] !Int'
[01:59:23] <boborygmy> I would've thought something like a tuple ([],!Int)
[02:00:18] <boborygmy> I'm going to try your MkPath
[02:01:56] <boborygmy> OK I get it, yes!
[02:02:57] <romesrf> cool!
[02:03:40] <boborygmy> Thanks all
[02:04:50] <romesrf> boborygmy: I'd recap it like this: You can define functions whose name are operators. Operators by default are infix (that means they go in between 2 things). When defining the function you can use the operator as infix on both sides of =
[02:04:59] <romesrf> (<>) :: a -> a -> a
[02:05:03] <romesrf> a <> b = ...
[02:05:47] <boborygmy> Yes. I knew that but I don't know why this particular thing threw me.
[02:05:52] <geekosaur> alsonote that a name composed of symbol characters is always an operator, a name composed of alphanumerics/_/' is always a function
[02:06:12] <romesrf> boborygmy: This principle is even broader: you can define any 2 argument function with infix notation
[02:06:22] <geekosaur> you can also use a function as an operator (wrap it in ``) or an operator as a function (wrap it in ())
[02:06:47] <romesrf> elem :: a -> [a] -> Bool
[02:06:54] <romesrf> x `elem` list = ...
[02:07:01] <romesrf> you can define it like this ^^
[02:07:03] <boborygmy> yep
[02:08:07] <geekosaur> > (+) 4 3
[02:08:09] <lambdabot>  7
[02:08:14] <geekosaur> going the other way
[02:08:27] <geekosaur> or: (+) a b = ...
[02:08:49] <romesrf> @src (+)
[02:08:49] <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
[02:08:51] <romesrf> hehe
[02:08:54] <boborygmy> yeah. I've been working haskell-mooc problems and not sitting down and defining data types for awhile
[02:09:22] <boborygmy> every time lambdabot says that I want to go read Prelude and friends
[02:09:30] <geekosaur> % :info +
[02:09:30] <yahb> geekosaur: type Num :: * -> Constraint; class Num a where; (+) :: a -> a -> a; ...; -- Defined in `GHC.Num'; infixl 6 +
[02:17:23] *** Joins: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:6da2:b132:dfcb:fb0e)
[02:22:49] *** Quits: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:6da2:b132:dfcb:fb0e) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[02:23:35] *** Joins: da39a3ee5e6b4b0d (~textual@mx-ll-171.5.29-46.dynamic.3bb.co.th)
[02:54:17] *** Quits: da39a3ee5e6b4b0d (~textual@mx-ll-171.5.29-46.dynamic.3bb.co.th) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[03:11:54] *** Quits: SanchayanMaity (sid478177@id-478177.hampstead.irccloud.com) (Read error: Connection reset by peer)
[03:11:55] *** Quits: dsal (sid13060@id-13060.lymington.irccloud.com) (Read error: Connection reset by peer)
[03:12:10] *** Joins: SanchayanMaity (sid478177@id-478177.hampstead.irccloud.com)
[03:12:14] *** Joins: dsal (sid13060@id-13060.lymington.irccloud.com)
[04:00:37] *** Quits: kilolympus (~kilolympu@31.205.200.235) (Ping timeout: 240 seconds)
[04:04:31] *** Joins: kilolympus (~kilolympu@31.205.200.235)
[04:06:11] *** Joins: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl)
[04:24:17] *** Joins: mvk (~mvk@2607:fea8:5cc3:7e00::45ee)
[04:36:00] *** Quits: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl) (Ping timeout: 272 seconds)
[04:46:05] *** Quits: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb) (Read error: Connection reset by peer)
[05:14:14] *** Joins: alt-romes (~romes@44.190.189.46.rev.vodafone.pt)
[05:17:09] *** Quits: romesrf (~romes@44.190.189.46.rev.vodafone.pt) (Ping timeout: 256 seconds)
[06:09:10] *** Joins: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:6da2:b132:dfcb:fb0e)
[06:09:22] *** Quits: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:6da2:b132:dfcb:fb0e) (Client Quit)
[06:12:36] *** Joins: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:20af:a1b:4b5f:e73)
[06:15:19] *** Quits: alt-romes (~romes@44.190.189.46.rev.vodafone.pt) (Quit: WeeChat 3.4)
[06:21:32] *** Joins: da39a3ee5e6b4b0_ (~textual@2403:6200:8876:d2a9:ecfc:ebe1:b77a:f914)
[06:24:12] *** Quits: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:20af:a1b:4b5f:e73) (Ping timeout: 240 seconds)
[06:32:07] *** Joins: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl)
[06:46:38] *** Quits: da39a3ee5e6b4b0_ (~textual@2403:6200:8876:d2a9:ecfc:ebe1:b77a:f914) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[07:06:44] *** Quits: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl) (Ping timeout: 272 seconds)
[07:16:18] *** Joins: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:ecfc:ebe1:b77a:f914)
[07:35:54] *** Joins: adam_ (~m-2jewo5@129.153.21.50)
[07:42:57] *** Parts: adamcstephens[m] (~adamcstep@2001:470:69fc:105::1:72a2) ()
[08:01:55] *** Quits: adam_ (~m-2jewo5@129.153.21.50) (Remote host closed the connection)
[08:02:12] *** Joins: adamcstephens_ (~m-2jewo5@129.153.21.50)
[08:13:25] *** Joins: strawburr (~user@172.56.40.24)
[08:22:05] *** adamcstephens_ is now known as adamcstephens
[08:29:49] *** Quits: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:ecfc:ebe1:b77a:f914) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[08:55:37] *** Joins: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:ecfc:ebe1:b77a:f914)
[09:05:28] *** Quits: strawburr (~user@172.56.40.24) (Remote host closed the connection)
[09:07:43] *** Joins: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl)
[09:29:38] *** Quits: soxen (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net) (Ping timeout: 256 seconds)
[09:29:52] *** Quits: boborygmy (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net) (Ping timeout: 272 seconds)
[09:31:11] *** Joins: coot (~coot@213.134.190.95)
[09:36:31] *** Joins: boborygmy (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net)
[09:36:33] *** Joins: soxen (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net)
[09:37:28] *** Quits: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl) (Ping timeout: 272 seconds)
[09:46:37] *** Quits: mvk (~mvk@2607:fea8:5cc3:7e00::45ee) (Ping timeout: 240 seconds)
[09:59:23] *** Quits: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:ecfc:ebe1:b77a:f914) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[10:09:20] *** Joins: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:ecfc:ebe1:b77a:f914)
[11:12:53] *** Joins: da39a3ee5e6b4b0_ (~textual@171.5.29.46)
[11:12:57] *** Quits: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:ecfc:ebe1:b77a:f914) (Ping timeout: 240 seconds)
[11:13:00] *** Quits: boborygmy (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net) (Ping timeout: 240 seconds)
[11:13:44] *** Quits: soxen (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net) (Ping timeout: 272 seconds)
[11:38:22] *** Joins: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl)
[11:53:15] *** Quits: geekosaur (~geekosaur@xmonad/geekosaur) (Ping timeout: 256 seconds)
[11:55:08] *** Joins: geekosaur (~geekosaur@xmonad/geekosaur)
[12:19:33] <Christoph[m]> Do infixl and infixr also work with infix constructors?
[12:21:05] <merijn> Christoph[m]: Yes
[12:21:08] *** Joins: jespada (~jespada@148.252.132.235)
[12:59:40] *** Quits: coot (~coot@213.134.190.95) (Quit: coot)
[13:08:00] <dminuoso> In fact, even with type constructors!
[13:08:45] <dminuoso> Christoph[m]: https://hackage.haskell.org/package/servant-0.19/docs/src/Servant.API.Sub.html#%3A%3E
[13:16:49] <Christoph[m]> That's good to know! But in the example, there's a type constructor, but no =-sign and value constructor. Is this new type inhabited?
[13:17:27] <dminuoso> Christoph[m]: Its completely uninhabited.
[13:17:42] <dminuoso> Good deduction
[13:18:15] <dminuoso> Are you familiar with servant?
[13:18:33] <Christoph[m]> No, I'm not.
[13:19:00] <Christoph[m]> What is an uninhabited type good for?
[13:19:08] <dminuoso> To explain, once you enable DataKinds, we can have type-level strings (which too are uninhabited)
[13:19:19] <dminuoso> With these things, we can elaborate a type like this:
[13:19:57] <dminuoso> type Endpoint = "users" :> Get '[JSON] [User]
[13:20:07] <dminuoso> Where `"users"` is a type level string (its uninhabited)
[13:20:11] <dminuoso> '[] is a type level list
[13:20:34] <dminuoso> And `JSON` is also created using `data JSON`
[13:20:52] <dminuoso> This is step one
[13:21:18] <dminuoso> So we get to describe a `GET /users` endpoint that would, on a Content-Type of application/json, return a list of users
[13:21:55] <dminuoso> Using typeclasses we can then do pattern matching on types, like the above, which lets us built in a router that we can connect endpoint handlers, that have corresponding types
[13:23:23] <dminuoso> So uninhabited types are useful in type level computations using type families (which can be thought of as functions that operate on the type level) and typeclasses (which can be thought of as case-of on the type level)
[13:28:28] <Christoph[m]> <dminuoso> "So we get to describe a `GET /..." <- Hm. But Endpoint is built with :>, sonit is uninhabited, too. Doesn't that mean that there is nothing in this type that could return the list of users?
[13:32:12] <Christoph[m]> Also, all these type level computations are performed by the compiler, right? Does that mean that I have to decide everything at compile time? Or does the servant application recompile itself if necessary, like xmonad does when its configuration changes?
[13:34:58] <dminuoso> Christoph[m]: Yes, that type is uninhabited too!
[13:35:36] *** Quits: jespada (~jespada@148.252.132.235) (Ping timeout: 272 seconds)
[13:35:50] <dminuoso> So given `type Endpoint = ...`
[13:35:52] <dminuoso> We can have:
[13:35:57] *** Joins: jespada (~jespada@148.252.132.235)
[13:36:05] <dminuoso> serve :: HasServer api '[] => Proxy api -> Server api -> Application
[13:36:32] <dminuoso> And we use `serve (Proxy :: Proxy Endpoint) server`
[13:36:59] <dminuoso> So we pass the type itself around as an argument (via the proxy trick), and the HasServer typeclass then has a thick machinery to construct a router based on that.
[13:37:11] <dminuoso> The second argument is the thing why we do all of this elaborate trick
[13:37:47] <dminuoso> `Server` is a typefamily at the end, which means it is able to turn `Endpoint` into say `IO [User]`
[13:37:53] <dminuoso> Or equivalently, if we had:
[13:38:12] <dminuoso> `type Endpoint = "user" :> Capture "user identifier" Int :> Get '[JSON] User`
[13:38:23] <dminuoso> We this tyep family would turn this into a function `Int -> IO User`
[13:38:39] <dminuoso> So the type family ensures that our server implementation correctly lines up with the API specification.
[13:38:46] <dminuoso> And HasServer derives a matching router that connects these together
[13:38:54] <dminuoso> (And in reality we can even add multiple endpoints)
[13:45:02] <Christoph[m]> I see! Uninhabited types serve as arguments to type functions aka type families, and the resulting types can then be inhabited!
[13:47:48] <dminuoso> Yes, you can also feed them into typeclasses equivalently.
[13:48:04] <dminuoso> A simple example might be
[13:48:15] <dminuoso> % data Foo a tag = Foo a
[13:48:16] <yahb> dminuoso:
[13:48:24] <dminuoso> % data Thing
[13:48:24] <yahb> dminuoso:
[13:48:27] <dminuoso> % data Another
[13:48:27] <yahb> dminuoso:
[13:48:36] <dminuoso> instance SomeClass (Foo a Thing)
[13:48:39] <dminuoso> instance SomeClass (Foo a Another)
[13:50:22] *** Joins: romesrf (~romes@44.190.189.46.rev.vodafone.pt)
[13:55:39] *** Quits: jespada (~jespada@148.252.132.235) (Ping timeout: 256 seconds)
[13:56:53] <Christoph[m]> % instance SomeClass (Foo a Thing)
[13:56:53] <yahb> Christoph[m]: ; <interactive>:37:10: error: Not in scope: type constructor or class `SomeClass'
[13:57:47] <Christoph[m]> Oh, dminuoso, you have to type it...
[13:58:08] <Christoph[m]> I seem to have my own environment.
[14:10:33] <Christoph[m]> But still, it looks as if the type list of users has to be known at compile time.
[14:11:32] <dminuoso> Christoph[m]: What do you mean?
[14:12:04] *** Joins: jespada (~jespada@148.252.132.235)
[14:15:05] *** Quits: zaquest (~notzaques@5.130.79.72) (Remote host closed the connection)
[14:16:11] *** Joins: zaquest (~notzaques@5.130.79.72)
[14:21:32] <Christoph[m]> <dminuoso> "type Endpoint = "users" :> Get '..." <- If you want add a user to the type list, you'll have to recompile, right? Or is User uninhabited, too?
[14:26:01] *** Quits: da39a3ee5e6b4b0_ (~textual@171.5.29.46) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[14:28:45] <dminuoso> So you woudl have:
[14:28:53] <dminuoso> data User = User { name :: Text, age :: Int }
[14:29:00] <dminuoso> with an appropriate ToJSON instance
[14:29:14] <dminuoso> type API = "users" :> Get '[JSON] [User]
[14:29:36] <dminuoso> Describes an API with a single endpoints `GET /users`, which responds to Content-Type: application/json
[14:29:46] <dminuoso> The corresponding Haskell handler will be expected to have the type:
[14:30:09] <dminuoso> `Handler [User]`
[14:30:16] <dminuoso> For simplicity we can think of `Handler` as just `IO`
[14:30:33] <dminuoso> So we could say the handler will be exected of the shape `IO [User]`
[14:45:46] *** Joins: coot (~coot@213.134.190.95)
[14:52:01] *** Quits: jespada (~jespada@148.252.132.235) (Read error: Connection reset by peer)
[14:54:28] *** Quits: awpr (uid446117@id-446117.lymington.irccloud.com) (Quit: Connection closed for inactivity)
[14:55:23] <Christoph[m]> So even though the type API is uninhabited, it can pass the inhabited type it's attached to to Handler? Is there also a type Admin which can be passed to Handler? Or would one use the type string "admin" for that?
[15:08:36] *** Quits: geekosaur (~geekosaur@xmonad/geekosaur) (Remote host closed the connection)
[15:13:15] *** Joins: geekosaur (~geekosaur@xmonad/geekosaur)
[15:20:58] *** Quits: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl) (Ping timeout: 256 seconds)
[15:22:22] *** Joins: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl)
[15:29:16] <dminuoso> Christoph[m]: So we have this cool thingÖ
[15:29:22] <dminuoso> data Proxy a = Proxy
[15:29:31] <dminuoso> Which is essentially just a unit () but with a phantom type
[15:30:05] <dminuoso> We can use this to pass a type around manually/explicitly.
[15:30:27] <dminuoso> Roughly the idea is this:
[15:30:48] <dminuoso> We apply the above `serve` function to `Proxy :: Proxy API`
[15:30:52] <dminuoso> If you recall
[15:30:56] <dminuoso> serve :: HasServer api '[] => Proxy api -> Server api -> Application
[15:31:02] <dminuoso> So that sets api ~ API
[15:31:06] <dminuoso> Which now means:
[15:31:47] <dminuoso> We require an instance `HasServer API` (which serve then has access to). servant provides all the necessary typeclass instances to make this happen
[15:35:01] *** Parts: coot (~coot@213.134.190.95) ()
[15:35:28] *** Joins: coot (~coot@2a02:a310:e241:1b00:ec1a:e9df:79ac:66ba)
[15:39:22] *** Quits: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl) (Ping timeout: 250 seconds)
[15:39:29] *** Joins: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl)
[16:11:30] *** Quits: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl) (Ping timeout: 268 seconds)
[16:13:42] <Christoph[m]> It's a lot to take in!
[16:14:25] <Christoph[m]> Why is there a type variable api and not the type API in HasServer?
[16:15:03] <dminuoso> Christoph[m]: serve is the function from `servant` that *takes* an arbitrary api type.
[16:15:15] <dminuoso> Since it must be able to taek an arbitrary api type, it is polymorphic over the api type
[16:15:40] <dminuoso> Generally, a polymorphic type is something the caller/user *must* choose
[16:15:58] <dminuoso> We can pretend that anything that is polymorphic has, semantically, an extra argument slot for the type choice
[16:16:10] <dminuoso> (In fact in many cases this is what GHC ends up doing internally!)_
[16:16:16] <dminuoso> So for instance:
[16:16:18] <dminuoso> % :t id
[16:16:18] <yahb> dminuoso: a -> a
[16:16:38] <dminuoso> The caller has to specify a) what type they want for a, and b) the first argument slot.
[16:16:51] <dminuoso> In most cases that choice is inferred based on usage
[16:17:37] <dminuoso> So if you specify `id "Foo"`, then GHC will know that `"Foo" :: String`, and infer that you chose `a ~ String`
[16:19:02] <dminuoso> We could imagine a version of Haskell in which we could specify that choice.
[16:19:04] <dminuoso> Say:
[16:19:07] <dminuoso> id @String "Foo"
[16:19:33] <dminuoso> Where `id @String` would chose String for the first type variable occurence in `id`
[16:19:54] <Christoph[m]> Oh! I expexted
[16:19:54] <Christoph[m]> id ("foo" :: String)
[16:20:10] <dminuoso> Sure! You can do that as well.
[16:20:28] <dminuoso> In many cases you can use type annotatinos like that to guide type inference when GHC cant infer it
[16:21:08] <dminuoso> So the proxy trick gives us a formal way to pass a type via a separate parameter instead
[16:21:21] <dminuoso> So anyhow
[16:21:26] <dminuoso> 13:00:56       dminuoso | serve :: HasServer api '[] => Proxy api -> Server api -> Application
[16:21:39] <dminuoso> The `Proxy` is a shallow, meaningless thing that has no meaningful data at the value level
[16:21:51] <dminuoso> But it carries a phantom type, so if we adopt the earlier notion of:
[16:21:54] <dminuoso> id @String "Foo"
[16:22:33] <dminuoso> It would be nice if we could say `serve @API ...` where @API would specify the type as a type-level structure to `serve`. We have to resort to the `Proxy` pattern to make this work nicely
[16:22:51] <dminuoso> So rather than being able to say `serve @API`, we would say `serve (Proxy :: Proxy API) ...`
[16:23:14] <dminuoso> And this is our way of telling GHC "hey, I want api ~ API`, where ! denotes type equality, your chocie for the type
[16:23:56] <dminuoso> And now that you gave `serve` that type, its usage of the type family (which can turn types into types), can transform that API type into a type corresponding to the handlers that is expected to buidl a server.
[16:24:29] <dminuoso> So the type family knows "hey, you have just a single endpoint that returns a list of users", so `Server API` would give you `IO [User]`.
[16:24:50] <dminuoso> That means the time you specify `serve (Proxy :: Proxy API)`, serve then expects a next argument of `IO [User]`
[16:25:07] <dminuoso> Ensuring you dont accidentally specify say `IO [Groups]` for that endpoint
[16:27:10] <dminuoso> Christoph[m]: From an above perspective what all of this lets you do is this: You have one `foo-api` library that exposes these shallow uninhabitated types. A big singular API type that expresses multiple API endpoints.
[16:27:56] <dminuoso> Then you could have a `foo-server` library that depends on `foo-api`, and via type families/typeclasses automatically has a matching server that for each endpoint has an exact matching handler function. If the endpoint has parameters, the handler automatically is expected to be a function of these parameters.
[16:28:12] <dminuoso> At the same time you could also have a `foo-client` library that depends on `foo-api` and does the inverse of the above
[16:28:22] <dminuoso> then you have a `foo-docgen` that automatically generates swagger definitions and a markdown documentation
[16:28:30] <dminuoso> And all things are guaranteed to be coherent via the type system
[16:29:22] <dminuoso> To make this work, servant passes the API shape (what endpoints do we have, what URL fragments, where do you capture parameters, what types do they return, what HTTP headers do they set or read...) inside the type system itself. We store data at the type level
[16:39:44] *** Joins: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl)
[16:57:50] *** Joins: soxen (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net)
[16:57:50] *** Joins: boborygmy (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net)
[17:13:09] *** Joins: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:ecfc:ebe1:b77a:f914)
[17:16:17] *** Joins: benin (~benin@183.82.26.94)
[17:26:39] *** Joins: jespada (~jespada@148.252.132.116)
[17:31:53] *** Quits: da39a3ee5e6b4b0d (~textual@2403:6200:8876:d2a9:ecfc:ebe1:b77a:f914) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[17:33:48] <Christoph[m]> I think I start to get it. A phantom type in a function declaration provides a slot for an argument with no usable value, but it's type carries the information we want to provide. It's consumed at compile time and used to sort out which data to expect in the other slots of the function.
[17:34:53] <dminuoso> Exactly.
[17:35:15] <dminuoso> The term "phantom type" is used incorrectly here though
[17:36:33] <dminuoso> Or maybe it isnt quite, at any rate
[17:39:40] <dminuoso> Christoph[m]: If you go further, you end up with something like this: https://gist.github.com/dminuoso/e86fbe58f27e47170c2e4564c91a45e9
[17:40:31] <dminuoso> Here we dont use `type API = ...` anymore, but `data Routes route = Routes { _getHistory :: route :- ... }`
[17:40:56] <dminuoso> :- takes the role of the special type family, it takes two arguments
[17:41:42] <dminuoso> First it takes an argument that is either `data AsApp` or `data AsClient`, and depending on whether you use `Routes AsApp` or `Routes AsClient`, the types of the respective fields change.
[17:41:49] <dminuoso> So for instance:
[17:41:59] <dminuoso> AsApp :- "devices" :> Get '[JSON] History     ===>
[17:42:05] <dminuoso> AppM History
[17:42:07] <dminuoso>  
[17:42:17] <dminuoso> AsApp :- "devices" :> Capture "device_name" T.Text :> "event" :> Capture "event_type" EventType :> Post '[JSON] NoContent     ===>
[17:42:26] <dminuoso> T.Text -> EventType -> AppM NoContent
[17:43:03] <dminuoso> Equivalently you might have `AsClient`, which would give you a client monad instead, or maybe `AsDoc` which just gives you `Text` for each field
[17:56:14] *** Quits: soxen (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net) (Ping timeout: 256 seconds)
[17:56:17] *** Quits: boborygmy (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net) (Ping timeout: 240 seconds)
[18:22:47] *** Joins: boborygmy (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net)
[18:22:47] *** Joins: soxen (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net)
[18:34:10] *** Quits: jespada (~jespada@148.252.132.116) (Read error: Connection reset by peer)
[18:36:35] *** Quits: benin (~benin@183.82.26.94) (Quit: The Lounge - https://thelounge.chat)
[19:01:22] *** Joins: jespada (~jespada@148.252.132.116)
[19:06:12] *** Quits: yrlnry (~mjd@pool-74-109-20-19.phlapa.fios.verizon.net) (Ping timeout: 272 seconds)
[19:24:13] *** Joins: yrlnry (~mjd@67.205.255.173)
[19:27:39] *** Quits: jespada (~jespada@148.252.132.116) (Read error: Connection reset by peer)
[19:32:45] *** Joins: jespada (~jespada@cpc121022-nmal24-2-0-cust171.19-2.cable.virginm.net)
[19:33:55] *** Joins: jespada_ (~jespada@cpc121022-nmal24-2-0-cust171.19-2.cable.virginm.net)
[19:37:00] *** Quits: jespada (~jespada@cpc121022-nmal24-2-0-cust171.19-2.cable.virginm.net) (Ping timeout: 240 seconds)
[19:47:22] *** Quits: jespada_ (~jespada@cpc121022-nmal24-2-0-cust171.19-2.cable.virginm.net) (Ping timeout: 272 seconds)
[19:54:07] *** Joins: jespada (~jespada@cpc121022-nmal24-2-0-cust171.19-2.cable.virginm.net)
[19:57:45] *** Quits: hololeap (~hololeap@user/hololeap) (Read error: Connection reset by peer)
[19:59:04] *** Joins: hololeap (~hololeap@user/hololeap)
[19:59:20] <Christoph[m]> That sounds like magic! Why would you overload the functions that extremely? Why not have more functions with simpler types instead?
[20:13:16] *** Joins: vicfred (~vicfred@user/vicfred)
[20:17:49] *** Joins: Midjak (~Midjak@82.66.147.146)
[20:22:31] *** Quits: vicfred (~vicfred@user/vicfred) (Quit: Leaving)
[20:26:48] *** Quits: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl) (Ping timeout: 268 seconds)
[20:32:42] *** Quits: coot (~coot@2a02:a310:e241:1b00:ec1a:e9df:79ac:66ba) (Quit: coot)
[20:44:28] *** Joins: mvk (~mvk@2607:fea8:5cc3:7e00::45ee)
[21:03:22] *** Joins: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl)
[21:07:27] *** Quits: romesrf (~romes@44.190.189.46.rev.vodafone.pt) (Ping timeout: 256 seconds)
[21:07:57] *** Quits: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl) (Ping timeout: 240 seconds)
[21:30:48] *** Joins: awpr (uid446117@id-446117.lymington.irccloud.com)
[21:43:18] *** Joins: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl)
[21:58:55] *** Joins: coot (~coot@213.134.190.95)
[22:04:45] *** Quits: ChaiTRex (~ChaiTRex@user/chaitrex) (Remote host closed the connection)
[22:07:16] *** Joins: ChaiTRex (~ChaiTRex@user/chaitrex)
[22:17:17] *** Quits: merijn (~merijn@c-001-001-005.client.esciencecenter.eduvpn.nl) (Ping timeout: 240 seconds)
[22:25:30] <dminuoso> Christoph[m]: You dont have to. What we get is the guaranteed coherence between all of them.
[22:26:39] <dminuoso> Say I want to assert that `this endpoint takes an Int in the URL here, and returns a list of User`. Now if my type system guarantees that the server implementation *demands* an Int (and errors out if not supplied by a client), and *guarantees* I consume an Int and produce a list of User (via the type system)...
[22:27:19] <dminuoso> And the type system guarantees a client matches exactly in the same way (in that the client implementation will *demand* an Int (that it would forward to the server), and produce an `IO [User]` as its output..
[22:27:47] <dminuoso> the type system will assert coherence between all these parts, so one doesnt accidentally drift.
[22:28:16] <dminuoso> Say if you had a python flask api, nothing prevents you from writing in the documentation "I return a list of User", but in reality you return a single user.
[22:29:01] <dminuoso> Christoph[m]: the above client is completely automatically inferred. I dont have to do *anything*
[22:30:06] <dminuoso> Broadly what you would do is just this:
[22:30:30] <dminuoso> myClient :: Routes AsClientM; myClient = client (Proxy :: Proxy API)
[22:30:50] <dminuoso> Done. The completely client implementation is constructed generically to match the API specification, which again matches the server specification - guaranteed by the type system
[22:31:46] <dminuoso> Then you can simply use `do { Right history <- runClientM (_getHistory myClient) env; ... }`
[22:32:06] <dminuoso> Anyway. This is a long and elaborate story. To get back to where we came from:
[22:32:57] <dminuoso> The reason this works is because we construct the specification of the API as type-level structure, and use type families to compute matching client/server/documentation/etc type signatures, and type families to generate matching client/server/documentation implementatinos.
[22:33:18] <dminuoso> The types themselves? Uninhabited. But we treat them as data, just at the type level.
[22:35:07] <dminuoso> Whether all of this is a good idea is a different subject. The price of all the above is that subtle bugs usually lead to type unification errors. So rather than GHC saying "The handler _postStage requires 2 arguments, the first of which takes a String. You handler has Int", you get "Couldn't matched expected type String with actual type Int, in ..., in... *huge* *type* *signature*
[22:35:20] <dminuoso> It's still better than pythons "dont error at all"
[22:36:32] <dminuoso> (Dont want to come across as bashing python, I just took it as an example)
[22:37:50] *** Quits: jespada (~jespada@cpc121022-nmal24-2-0-cust171.19-2.cable.virginm.net) (Read error: Connection reset by peer)
[22:38:16] *** Joins: jespada (~jespada@cpc121022-nmal24-2-0-cust171.19-2.cable.virginm.net)
[23:59:34] *** Joins: liz_ (~liz@2a00:23c5:9680:501:b62e:99ff:fee4:47fa)
