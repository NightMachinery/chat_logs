[00:22:50] *** Quits: subbu (~subbu@user/subbu) (Quit: Leaving)
[00:23:13] *** Joins: subbu (~subbu@user/subbu)
[02:14:19] <edipofederle[m]> Hi Guys, I'm working on the sliced with Enumerator::ArithmeticSequence, I am checking on MRI how they do it, but I cannot really understand how this part works: https://gist.github.com/edipofederle/621db8218f37b77dfd021cbe7827b3a6
[02:14:19] <edipofederle[m]> Bassicaly the `rb_arithmetic_sequence_extract` looks returns the same values (for `aseq.begin` and `aseq.end`. 
[02:14:19] <edipofederle[m]> Could somone give some help here? 
[02:23:59] <enebo[m]> do that?
[02:24:42] <enebo[m]> I see it call two different methods which look for begin and end from the arithmtic sequenece
[02:25:12] <enebo[m]> static inline VALUE... (full message at https://libera.ems.host/_matrix/media/r0/download/libera.chat/fb1f1cb07e631e9163f72b30b4fa458e2c99ef81)
[02:25:43] <enebo[m]> static inline VALUE... (full message at https://libera.ems.host/_matrix/media/r0/download/libera.chat/fb1f1cb07e631e9163f72b30b4fa458e2c99ef81)
[02:25:47] <enebo[m]> bah
[02:25:57] <enebo[m]> but end calls id_end
[02:27:18] <enebo[m]> edipo.federle: or do you mean it just gets beg and end out of original object?
[03:46:22] *** Quits: subbu (~subbu@user/subbu) (Quit: Leaving)
[04:01:08] *** Joins: subbu (~subbu@user/subbu)
[04:34:07] *** Quits: subbu (~subbu@user/subbu) (Quit: Leaving)
[12:47:11] *** Quits: _whitelogger (~whitelogg@uruz.whitequark.org) (Ping timeout: 264 seconds)
[12:47:20] *** Joins: _whitelogger (~whitelogg@uruz.whitequark.org)
[12:55:23] <edipofederle[m]> enebo:  I mean, for example, given: `#p [0,1,2,3,4,5,6,7,8,67,645,34][(4..).step(-5)]`, how at the point in the code I paste on GIST, the aseq.beg and aseq.end as calculated with 8 and 9, respectively. 
[18:24:13] <enebo[m]> edipo.federle: are you putting a println into that source code?
[18:25:04] <edipofederle[m]> enebo:  I'm using GDB... I am investigate a big deeper now, but still confussing :d 
[18:25:29] <enebo[m]> yeah I mean I assume begin will be 4 in the above and end will be nil
[18:26:08] <enebo[m]> MRI does give the answer based on 4 and -5 so I am surprised to see it different at that point
[18:26:36] <edipofederle[m]> Yep, I am checking here: https://github.com/ruby/ruby/blob/master/range.c#L439
[18:26:48] <edipofederle[m]> that is where MRI initialize range step begin/end
[18:27:48] <enebo[m]> This may be obvious question but are you sure you are not hitting an earlier ranges breakpoint?
[18:28:06] <enebo[m]> I know by default MRI will load rubygems for example
[18:29:14] <edipofederle[m]> Yes, I am sure, I'm looking at it when I "see" that is my code begins evaluated. 
[18:29:39] <edipofederle[m]> I will try check a bit more, and I let you know which more details and example, maybe
[18:29:49] <enebo[m]> My other thought is I don't know how tagged integers print out
[18:29:56] <edipofederle[m]> s/which/with/
[18:30:17] <enebo[m]> beg and end are VALUE but they mark a bit to not really heap alloc
[18:30:28] <edipofederle[m]> good point
[18:30:42] <enebo[m]> deeper in this code they will make a long/int out of this
[18:30:59] <enebo[m]> err not even yet in this method
[18:31:10] <enebo[m]> since it will make the arithseq here
[18:31:11] <edipofederle[m]> I will try check in that direction so
[18:31:40] <enebo[m]> I mean I would assume it is a high bit so I would have thought you would see a large negative
[18:32:31] <enebo[m]> https://github.com/ruby/ruby/blob/master/range.c#L458
[18:32:50] <enebo[m]> This is the line you get to though right...at this point it is still just a VALUE
[18:33:15] <enebo[m]> but I am grasping a little bit here...it seems fairly clear this would not work if it was not begin of 4 and step of -5
[18:33:28] <edipofederle[m]> yep
[18:34:02] <enebo[m]> I usually just read the code and I when I am curious I usually build with some printlns (which is really rare because I usually understand the intent enough)
[18:34:31] <enebo[m]> in this case I feel on the Java side you just take the values you would expect 4, nil, -5
[18:34:40] <enebo[m]> but I can see why you are trying to understand why you are not seeing what you expect
[18:35:19] <edipofederle[m]> enebo[m]: Actually, just curiosity on how it works on MRI side.. 
[18:35:33] <enebo[m]> On JRuby side this endless is already making the right thing but we do not handle it in Array#[] yet as an argument
[18:35:38] <enebo[m]> yeah 
[18:35:41] <enebo[m]> Makes sense 
[18:36:20] <edipofederle[m]> great! Thanks for the points
[18:36:48] <enebo[m]> edipo.federle: https://devdriven.com/2008/01/ruby-internals-why-ruby_fixnum_flag-should-be-0x00/
[18:37:24] <enebo[m]> Yeah fixnum representation is explained here and it does answer the question
[18:38:56] <edipofederle[m]> cool
[18:39:27] <enebo[m]> I think we talked about gdb like 1/2 a year ago right?  There was some file people used so they could run things like inspect() on values?
[18:39:47] <enebo[m]> if not I think there is something people use so they can properly print out a VALUE
[18:40:17] <edipofederle[m]> Yes, this is true
[18:40:53] <enebo[m]> cool.  Now I am again curious to use gdb :)
[19:16:22] *** Joins: subbu (~subbu@user/subbu)
[21:08:42] <edipofederle[m]> The "Can't find any online and idle self-hosted or hosted runner in the current repository, account/organization that matches the required labels: 'ubuntu-latest'
[21:08:42] <edipofederle[m]> Waiting for a self-hosted or a hosted runner to pickup this job..." is normal now on CI tasks? 
[22:07:57] <enebo[m]> edipo.federle: I have not seen that yet but hmm
[22:19:04] *** Joins: nilsding (~nilsding@user/nilsding)
[23:35:19] *** Quits: subbu (~subbu@user/subbu) (Quit: Leaving)
