[00:00:06] *** Quits: hornhack (~hackingho@user/hackinghorn) (Ping timeout: 272 seconds)
[00:00:22] *** Joins: hackhorn (~hackingho@user/hackinghorn)
[00:02:36] *** Quits: hackinghorn (~hackingho@user/hackinghorn) (Ping timeout: 240 seconds)
[00:04:06] *** Quits: mro (~mro@port-92-195-184-77.dynamic.as20676.net) (Ping timeout: 245 seconds)
[00:06:15] *** Quits: hackhorn (~hackingho@user/hackinghorn) (Ping timeout: 256 seconds)
[00:26:40] *** Quits: chrisz (lyab2f3gnl@55d46f86.access.ecotel.net) (Remote host closed the connection)
[00:27:39] *** Joins: mro (~mro@port-92-195-184-77.dynamic.as20676.net)
[00:45:06] *** Quits: mro (~mro@port-92-195-184-77.dynamic.as20676.net) (Read error: Connection reset by peer)
[00:45:12] *** Joins: mro_ (~mro@port-92-195-184-77.dynamic.as20676.net)
[00:49:23] *** Joins: chrisz (rc21r7u6rf@d53629b0.access.ecotel.net)
[00:56:28] *** Quits: bartholin (~bartholin@109.53.1.147) (Ping timeout: 272 seconds)
[01:08:39] *** Quits: rond_ (~rond_@90.251.109.52) (Quit: Client closed)
[01:09:05] *** Quits: mro_ (~mro@port-92-195-184-77.dynamic.as20676.net) (Quit: Leaving...)
[01:12:16] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 240 seconds)
[01:17:36] *** Joins: Anarchos (~Anarchos@88.168.112.216)
[01:19:27] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[02:16:07] *** Quits: Tuplanolla (~Tuplanoll@91-159-69-98.elisa-laajakaista.fi) (Quit: Leaving.)
[03:03:12] *** Quits: Anarchos (~Anarchos@88.168.112.216) (Quit: Vision[]: i've been blurred!)
[03:17:04] *** Quits: chrisz (rc21r7u6rf@d53629b0.access.ecotel.net) (Ping timeout: 272 seconds)
[03:17:04] *** Quits: Haudegen (~quassel@178.115.237.87.static.drei.at) (Ping timeout: 272 seconds)
[03:18:10] *** Joins: chrisz (ekf12rm0a0@d5360152.access.ecotel.net)
[03:21:30] <ns12> Hello, I noticed that the Unix module does not have syslog(3). How do I use syslog(3) from OCaml?
[03:27:56] <leah2> i guess you could open /dev/log and write yourself
[03:29:56] <leah2> or use https://github.com/geneanet/ocaml-syslog
[03:31:30] <dh`> the format expected by /dev/log isn't totally standard, using the libc interface is preferable
[03:33:00] <leah2> did it really change after 1985? :p
[03:34:02] *** Quits: Soni (~quassel@autistic.space) (Ping timeout: 250 seconds)
[03:34:22] <dh`> we changed it in netbsd a few years back to add some bells and whistles, I forget what
[03:39:18] <companion_cube> have you looked at extunix as well?
[03:39:31] <d_bot_> <Et7f3 (@me on reply)> You can mix binding and Printf.ksprintf or Format module
[03:40:13] <d_bot_> <Et7f3 (@me on reply)> And `syslog` have the type int -> string -> unit
[03:40:21] *** Joins: rgrinberg (~textual@2806:101e:7:134:4c27:f276:4d75:f0f0)
[03:41:30] <d_bot_> <Et7f3 (@me on reply)> Wait a API that doesn't return fd ðŸ¤” very strange for POSIX world
[03:47:23] *** Joins: vicfred (~vicfred@user/vicfred)
[03:49:14] *** Quits: oriba (~oriba@dynamic-078-054-198-245.78.54.pool.telefonica.de) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
[03:59:33] *** Quits: rgrinberg (~textual@2806:101e:7:134:4c27:f276:4d75:f0f0) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[04:07:52] *** Joins: Soni (~quassel@autistic.space)
[04:15:40] *** Joins: rgrinberg (~textual@2806:101e:7:134:4c27:f276:4d75:f0f0)
[04:32:10] <d_bot_> <mbacarella> There's also https://github.com/janestreet/async/blob/master/log_extended/src/log_extended.mli
[04:32:40] <d_bot_> <mbacarella> (`syslog` can block)
[05:03:22] *** Quits: kaph_ (~kaph@net-109-116-124-149.cust.vodafonedsl.it) (Read error: Connection reset by peer)
[05:04:43] *** Joins: kaph (~kaph@net-109-116-124-149.cust.vodafonedsl.it)
[05:31:16] *** Quits: vicfred (~vicfred@user/vicfred) (Ping timeout: 256 seconds)
[06:31:24] *** Joins: mbuf (~Shakthi@110.225.240.104)
[06:40:20] *** Joins: gravicappa (~gravicapp@145.255.0.191)
[07:09:56] *** Quits: Nahra` (~user@static.161.95.99.88.clients.your-server.de) (Remote host closed the connection)
[07:10:21] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 245 seconds)
[07:46:56] *** Joins: bobo (~bobo@37.170.120.80)
[07:47:16] *** Quits: spip (~bobo@37.165.89.121) (Ping timeout: 256 seconds)
[07:51:24] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Remote host closed the connection)
[07:52:11] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[08:37:18] *** Joins: Haudegen (~quassel@178.115.237.87.static.drei.at)
[08:55:49] *** Quits: zebrag (~chris@user/zebrag) (Quit: Konversation terminated!)
[09:01:29] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Remote host closed the connection)
[09:01:46] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[09:03:32] *** Quits: rgrinberg (~textual@2806:101e:7:134:4c27:f276:4d75:f0f0) (Ping timeout: 252 seconds)
[09:46:39] *** Joins: rgrinberg (~textual@2806:101e:7:134:b8e9:103c:7bf9:67b)
[09:47:50] *** Quits: rgrinberg (~textual@2806:101e:7:134:b8e9:103c:7bf9:67b) (Client Quit)
[10:10:23] *** Joins: rgrinberg (~textual@2806:101e:7:134:b8e9:103c:7bf9:67b)
[10:13:46] *** Joins: Anarchos (~Anarchos@88.168.112.216)
[10:17:26] *** Quits: gravicappa (~gravicapp@145.255.0.191) (Ping timeout: 256 seconds)
[10:42:22] *** Quits: gopiandcode (~gopiandco@137.132.219.136) (Ping timeout: 256 seconds)
[10:46:17] *** Joins: gopiandcode (~gopiandco@137.132.219.136)
[10:55:08] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Remote host closed the connection)
[10:55:27] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[11:07:51] *** Joins: namkeleser (~namkelese@101.175.104.107)
[11:17:35] *** Joins: mro (~mro@2002:5cc3:9158:0:5f2:56e1:7166:f772)
[11:24:53] *** Quits: Anarchos (~Anarchos@88.168.112.216) (Quit: Vision[]: i've been blurred!)
[11:29:06] *** Quits: rgrinberg (~textual@2806:101e:7:134:b8e9:103c:7bf9:67b) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[11:32:22] *** Quits: nd__ (~nd@ip-176-199-211-174.um44.pools.vodafone-ip.de) (Quit: leaving)
[11:34:29] *** Joins: cedric (~cedric@2a01:cb11:821:7c00:cab8:9456:dab5:65e4)
[11:35:41] <d_bot_> <undu> There's Aldo https://opam.ocaml.org/packages/logs-syslog/
[11:40:03] *** Quits: namkeleser (~namkelese@101.175.104.107) (Quit: Ping timeout (120 seconds))
[11:51:44] *** Joins: gravicappa (~gravicapp@145.255.0.191)
[12:09:39] *** Quits: chrisz (ekf12rm0a0@d5360152.access.ecotel.net) (Ping timeout: 256 seconds)
[12:11:18] *** Joins: chrisz (zutkc684um@d536135b.access.ecotel.net)
[12:13:28] *** Joins: jlrnick (~josephler@gw.lipn.univ-paris13.fr)
[12:20:21] *** Joins: olle (~olle@h-158-174-165-122.NA.cust.bahnhof.se)
[12:41:19] *** Quits: xgqt (~xgqt@gentoo/developer/xgqt) (Remote host closed the connection)
[12:41:43] *** Joins: xgqt (~xgqt@gentoo/developer/xgqt)
[13:18:08] *** Quits: epony (epony@user/epony) (Read error: Connection reset by peer)
[13:32:37] *** Quits: jlrnick (~josephler@gw.lipn.univ-paris13.fr) (Ping timeout: 240 seconds)
[14:32:54] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Remote host closed the connection)
[14:33:12] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[14:35:13] *** Joins: bartholin (~bartholin@158.110.71.61)
[15:11:22] *** Quits: Haudegen (~quassel@178.115.237.87.static.drei.at) (Quit: Bin weg.)
[15:18:34] *** Quits: olle (~olle@h-158-174-165-122.NA.cust.bahnhof.se) (Remote host closed the connection)
[15:49:00] *** Quits: mro (~mro@2002:5cc3:9158:0:5f2:56e1:7166:f772) (Remote host closed the connection)
[15:53:23] *** Joins: jlrnick (~josephler@gw.lipn.univ-paris13.fr)
[15:58:08] *** Joins: mro (~mro@port-92-195-145-88.dynamic.as20676.net)
[15:59:47] *** Quits: mro (~mro@port-92-195-145-88.dynamic.as20676.net) (Remote host closed the connection)
[15:59:57] *** Joins: mro (~mro@port-92-195-145-88.dynamic.as20676.net)
[16:00:01] *** Quits: mro (~mro@port-92-195-145-88.dynamic.as20676.net) (Remote host closed the connection)
[16:01:01] *** Joins: namkeleser (~namkelese@101.175.104.107)
[16:16:30] *** Quits: terrorjack (~terrorjac@2a01:4f8:1c1e:509a::1) (Quit: Ping timeout (120 seconds))
[16:16:37] *** Joins: olle (~olle@212-181-59-82.customer.telia.com)
[16:18:11] *** Joins: Haudegen (~quassel@91.114.49.10)
[16:18:13] *** Joins: terrorjack (~terrorjac@2a01:4f8:1c1e:509a::1)
[16:45:44] *** Quits: namkeleser (~namkelese@101.175.104.107) (Quit: Client closed)
[17:47:54] <ns12> It's surprising the the Unix module works on Windows. Why not have a separate Windows module instead?
[17:48:48] *** Joins: mro (~mro@port-92-195-145-88.dynamic.as20676.net)
[17:48:51] <olle> Windows is Linux under the hood ;D
[17:48:56] <olle> Soon enough...
[17:50:09] <octachron> Unix is a OS-independent Unix-like API
[17:51:30] <ns12> But there are so many functions that don't work on Windows.
[17:56:51] <octachron> Well, Windows is not a very Unix-like OS unsurprisingly.
[17:59:34] <Corbin> ns12: It's desirable, when building portable general-purpose languages, to erase or hide the differences between platforms. Lots of codebases have a couple special pages of code just for Windows, which only activate when on particular platforms.
[17:59:58] *** Quits: mro (~mro@port-92-195-145-88.dynamic.as20676.net) (Remote host closed the connection)
[18:01:38] <ns12> Corbin: "erase or hide the differences between platforms" - But that is clearly not possible with Windows, as evidenced by the large number of functions in the Unix library that are not implemented on Windows.
[18:04:09] <Corbin> ns12: Yes. And this is something of a swing in the wrong direction; being Unix-specific is just as much of a problem as being Windows-specific. Compare with languages that call this sort of thing an "OS" or "system" or "platform" module.
[18:05:32] <d_bot_> <Bluddy> this is a historical accident
[18:05:43] <d_bot_> <Bluddy> all of this stuff should have been abstracted away
[18:05:46] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[18:06:04] <d_bot_> <Bluddy> but instead, the Unix module was left as the `system` module
[18:06:20] <d_bot_> <Bluddy> and some Windows compatibility was provided
[18:06:31] <ns12> What is a better way? To have an "OS" module that has "Unix" and "Windows" submodules?
[18:07:35] *** Quits: adanwan (~adanwan@gateway/tor-sasl/adanwan) (Remote host closed the connection)
[18:07:50] *** Joins: adanwan (~adanwan@gateway/tor-sasl/adanwan)
[18:08:31] <olle> SIG
[18:08:40] <olle> module signature
[18:10:26] *** Joins: mro (~mro@port-92-195-145-88.dynamic.as20676.net)
[18:10:52] <Corbin> It depends on policy. Note that it's always possible, in any language, to make a portable program into a non-portable one by adding a platform-specific module. So, as a result, we should probably try to minimize *any* platform-specific code.
[18:12:37] <ns12> But the Unix module is really useful ...
[18:14:21] <companion_cube> Corbin: there's portable IO abstractions in OCaml, they're named `Sys` and all the channel primitives
[18:14:34] <companion_cube> Unix is, well, for unix. It's even a separate library you have to require explicitly
[18:16:13] <Corbin> companion_cube: ns12 might have a bit of a point. Stuff like high-level file access, envp access, Internet addresses and other BSD socket API; this could be portable.
[18:17:08] <ns12> Corbin: I don't think networking is portable.
[18:17:40] <companion_cube> I think the socket part of `Unix` works on windows.
[18:17:41] <ns12> Networking is probably not a compulsory part of a Unix system.
[18:18:12] <Corbin> ns12: BSD's socket API won an API war in the 80s. Nobody really expected such a thing. Since Windows NT, Windows has BSD sockets too.
[18:20:07] <companion_cube> ns12: I think the basics of the socket API are in posix
[18:20:14] <companion_cube> no real system will lack them
[18:22:32] <ns12> It's a bit inconsistent that some signal-related things are in "Sys" while others are in "Unix". I assume that this is due to historical reasons.
[18:23:04] <companion_cube> Sys is a bit higher level, but, yeah
[18:23:07] <companion_cube> same for file operations
[18:23:07] <Corbin> companion_cube: https://twistedmatrix.com/documents/current/core/howto/choosing-reactor.html might be interesting food for thought. This is what a portable networking+etc. library offers for supported platforms. Note that GUI toolkits like Wx and Qt get specialized implementations, too.
[18:23:55] <companion_cube> ah yes, you might be looking for Lwt
[18:24:21] <companion_cube> this is twisted, not python's `open`
[18:25:18] <Corbin> Python did choose "os" instead of "Unix" for their standard module, although it's still got a lot of POSIX and UNIX stuff out in the open.
[18:25:34] <ns12> Maybe Unix and Windows functionality should be separated into separate modules. Like Haskell's System.Posix (https://github.com/haskell/unix) and System.Win32 (https://github.com/haskell/unix), or Standard ML's Posix and Windows modules.
[18:26:47] <ns12> Corbin: Yeah, there are a number of functions in "os" that don't work on Windows.
[18:26:47] <companion_cube> I imagine we could have a Windows module
[18:26:58] <companion_cube> but no one really cares enough to do so
[18:27:24] <ns12> * https://github.com/haskell/win32
[18:28:04] <Corbin> companion_cube: If Greenspun kept making laws, they'd eventually get to "inside any portable high-level multicore language implementation, there's an event loop"; maybe exposing something Twisted-ish in the language core is not such a bad idea. (See also JS, Deno, etc.!)
[18:28:48] <companion_cube> lol no
[18:28:52] <companion_cube> where's java's event loop?
[18:29:10] <companion_cube> JS is now irrevocably founded on event loops, Deno just follows suit
[18:29:17] <companion_cube> (and neither is multicore)
[18:29:24] <companion_cube> does poly/ML have an event loop?
[18:29:37] <Corbin> It's called "new I/O" or NIO. I'm told the N could have been for "non-blocking".
[18:29:52] <companion_cube> yeah and it's not the default way of doing IO
[18:30:02] <companion_cube> you only use it if you need itâ€¦ like in OCaml
[18:30:23] <Corbin> Java's classic networking was built on the thread-per-connection paradigm. This is why a vanilla Minecraft server cannot support 1000 clients on a laptop.
[18:30:39] <Corbin> It's also why nginx has displaced Apache.
[18:30:44] <companion_cube> sure
[18:30:57] <companion_cube> servers are where you might want to use NIO
[18:31:02] <companion_cube> all programs are not servers
[18:31:29] <d_bot_> <mbacarella> Greenspun's Eleventh Rule: any sufficiently advanced program contains a slow, buggy ... network server
[18:31:48] <Corbin> GUI clients also need evented I/O, because they must simultaneously check networking and also redraw the screen. Actually, they simultaneously do networking/disk/joysticks/etc., lots of IO.
[18:31:48] <companion_cube> guess you shouldn't write anything more complicated than ocamlopt then :p
[18:32:03] <companion_cube> Corbin: do they now? do you have sources on that?
[18:32:16] <companion_cube> does jetbrains' stuff use NIO?
[18:32:38] <d_bot_> <mbacarella> oh actually I missed the opportunity:
[18:32:38] <d_bot_> <mbacarella>
[18:32:39] <d_bot_> <mbacarella> Zawinski's Law of Software Envelopment states: Every program attempts to expand until it can ~~read mail~~run a network server. Those programs which cannot so expand are replaced by ones which can.
[18:33:35] <companion_cube> (also remember that apache doesn't use threads, it uses worker processes)
[18:35:32] <Corbin> companion_cube: I don't want to throw HCI numbers at you, but it is relatively well-known that we must refresh a screen several dozen times per second in order to create a decent illusion of motion. Similarly, we must empty network buffers several times per second if we want to maintain good throughput.
[18:35:53] <Corbin> So, when would you *not* want an event loop?
[18:39:05] <companion_cube> ah well, you can have a loop alright
[18:39:24] <companion_cube> doesn't mean you have to use async IOs
[18:39:27] *** Quits: cedric (~cedric@2a01:cb11:821:7c00:cab8:9456:dab5:65e4) (Quit: Konversation terminated!)
[18:40:58] <d_bot_> <mbacarella> no shame in using a while loop that polls ðŸ˜›
[18:41:22] <Corbin> Sure. But that's only because of the legacy APIs providing sync IO options. In a new implementation, the problem of sync IO evaporates, and we aren't left with any compelling reason to readd it.
[18:41:49] <companion_cube> I mean it's not like epoll is new
[18:43:37] <companion_cube> Corbin: also, plot twist, you can use async IOs with OCaml's unix, just set your socket as non blocking
[18:43:42] <companion_cube> it's there if you need it
[18:44:02] <companion_cube> but I think it's wrong to suggest all IOs should be non blocking
[18:44:14] *** Quits: mro (~mro@port-92-195-145-88.dynamic.as20676.net) (Remote host closed the connection)
[18:45:35] <Corbin> companion_cube: Sure, and then just remember to invoke select() so that it will correctly timeout. And set up a priority queue of timers to give a source of timeouts for select(). And also set subprocesses to not block, and put filesystem access in a threadpool, and...
[18:45:49] <Corbin> Anyway, I'm happy to be wrong. Why should we have blocking I/O?
[18:45:58] <companion_cube> because it's simpler? :)
[18:46:06] <d_bot_> <mbacarella> yeah that. you don't have to think of any of that stuff.
[18:46:30] <companion_cube> a lot of OCaml tools do stuff like: read a file (or files); do a lot of computations; write a file (or files)
[18:46:37] <companion_cube> you need precisely 0 non blocking IOs for that
[18:46:46] <companion_cube> that's valid for ocaml itself, Coq, a lot of formal method stuffâ€¦
[18:47:17] <d_bot_> <mbacarella> most programming is not sexy interactive application. most programming is, like, processing program logs into compliance reports
[18:47:56] <d_bot_> <mbacarella> please don't make me think of async I/O when i'm bottlenecked on reading things from storage volumes and writing them back to other storage volumes ðŸ˜­
[18:48:22] <companion_cube> to read files, anyway, async IOs will rarely be worth it
[18:48:31] <companion_cube> it's only recently started being usable on linux
[18:48:31] <haesbaert> 15:00 < Corbin> It's also why nginx has displaced Apache.
[18:49:00] <haesbaert> well that's not entirely accurate, one process per socket was something in apache1 design, apache2 is a completely different beast
[18:49:15] <companion_cube> the damage is done anyway I suppose
[18:49:40] <haesbaert> IIRC even late apache1 didn't do it anymore
[18:50:02] <companion_cube> the funny stuff is that back then, people used a lot of php, which is one process per connection _anyway_
[18:50:39] <haesbaert> very true
[18:50:52] <companion_cube> people still use Rails a lot, which is thread-per-connection
[18:51:05] <companion_cube> (although that's changing maybe? ruby introduced some weird async thing?)
[18:51:08] <d_bot_> <mbacarella> "back then"
[18:51:08] <d_bot_> <mbacarella>
[18:51:10] <d_bot_> <mbacarella> i had to edit php code yesterday ðŸ˜­
[18:51:12] <companion_cube> :D
[18:51:17] <haesbaert> there's nothing inheritenly wrong with process/thread per connection though
[18:51:22] <companion_cube> same goes for Django, which is more popular than anything built on twisted
[18:51:22] <olle> hehe
[18:51:31] <companion_cube> haesbaert: no, and I like it, personnally :p
[18:51:34] <haesbaert> this is not windows 95 where a new process is a world event
[18:51:46] <olle> You can usually use message queues to distribute tasks in a web context
[18:51:55] <olle> No need for async etc
[18:52:10] <haesbaert> companion_cube: "back then" there was this article "how to handle 10k http requests/s"
[18:52:20] <haesbaert> that's when people started to hit "limits" on one fd per process
[18:52:28] <companion_cube> yeah :D
[18:52:32] <Corbin> companion_cube: I want to peel apart your memes; sorry. On your first point: using a programmable-semicolon analogy, there's no reason why non-blocking I/O must *feel* different from blocking I/O. That's a language decision.
[18:52:47] <companion_cube> this is #ocaml, not #haskell
[18:52:49] <companion_cube> thank you
[18:53:27] <olle> It does matter if code executes in the order you read it
[18:53:55] <olle> Leaving that "paradigm" creates... something different. :)
[18:53:57] <haesbaert> oh now I remember Corbin
[18:54:35] <olle> I'm more in to "defer", I think :d
[18:54:46] <olle> "defer" to a later point which does not matter that much
[18:56:12] <Corbin> companion_cube: As usual, I'm not telling you how to change OCaml. I'm telling you two things simultaneously: (1) OCaml is just another programming language; (2) programming languages intended for people should have ergonomic considerations.
[18:57:10] <haesbaert> olle: as long as you don't add concurrency within a single stream I think you're fine
[18:57:47] <dh`> corbin, you're confusing nonblocking I/O with asynchronous I/O
[18:58:03] <haesbaert> but you can achieve a similar thing even without queues, multiple processes calling accept on the same file descriptor which was passed down makes the kernel wake up one process at a time
[18:58:16] <companion_cube> Corbin: effects are going to help us, no worries
[18:58:51] <companion_cube> get rid of monads and all that
[18:59:37] <dh`> furthermore, asynchronous I/O is inherently concurrent and concurrency is hard for most people; consequently, ergonomic considerations mean that the default should be synchronous I/O
[19:00:08] <companion_cube> concurrency is hard for everyone, only sometimes you can't avoid it
[19:01:23] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 252 seconds)
[19:01:37] *** Quits: olle (~olle@212-181-59-82.customer.telia.com) (Remote host closed the connection)
[19:01:38] <Corbin> dh`: I'm happy to split the nuance, and I'll admit that I'm talking about async paradigms. The conversation started with a mention of Java NIO, which is sometimes called "non-blockinhg I/O".
[19:02:30] <Corbin> companion_cube: The monads are still there; each effect is carried by a functor, just like a monad, and the effect laws are analogues of the monad laws. Or are you thinking of "monad" purely in terms of e.g. Haskell syntax?
[19:03:00] <companion_cube> each effect is carried by an effect handler, not sure where the functor is
[19:03:15] <companion_cube> it's not even typed, as of OCaml 5.0 :D
[19:03:21] <companion_cube> it's like the exception type
[19:03:37] <Corbin> BTW I'm not sure if there's any non-concurrent stuff running in my userland right now. I'm on a typical Linux; all X11 clients are concurrent with X11, and all services are concurrent with systemd.
[19:04:03] <dh`> I have no idea what Java may mean by it but in Unix, nonblocking I/O means something specific and almost certainly isn't what you're interested in from what else you've been saying
[19:04:20] <companion_cube> Corbin: you don't have a terminal emulator?
[19:05:15] <Corbin> companion_cube: My terminal emulator is concurrent with X11 and has a non-trivial time-dependent interaction between keystroke events from the kernel and window-repainting events sent to X11.
[19:05:16] <dh`> there is no non-concurrent stuff in any general-purpose operating system since MS-DOS, if you look at the whole system
[19:05:30] <dh`> even if you boot single-user with only one process running
[19:06:02] <companion_cube> sure, concurrent with other processes is a thing
[19:06:10] <companion_cube> generally you try to minimize the interactions with the rest
[19:06:36] <companion_cube> then again most code is also incorrect when you account for concurrency
[19:06:48] <companion_cube> like if you write a file, you can't protect against race conditions on the file
[19:06:55] <companion_cube> unless you use good stuff like sqlite
[19:07:06] <Corbin> Yes, most software is incorrect.
[19:07:52] <companion_cube> => concurrency is hard
[19:09:25] <ns12> companion_cube: "like if you write a file, you can't protect against race conditions on the file" - Isn't file locking the solution?
[19:09:26] <haesbaert> and parallelism even harder
[19:09:41] <companion_cube> ns12: only if everyone agrees to use it
[19:10:19] *** Joins: zebrag (~chris@user/zebrag)
[19:10:27] <companion_cube> also it seems horribly hard to do correctly.
[19:12:06] <dh`> file locking is straightforward as long as NFS isn't involved
[19:12:53] <dh`> but realistically, for nearly everything, you just don't update the same file twice at the same time; it doesn't make sense to even attempt so it doesn't happen
[19:14:38] <companion_cube> yeah, that's the theory
[19:16:31] <sleepydog> does bash use concurrency?
[19:16:49] <companion_cube> it probably uses select underneath
[19:16:54] <companion_cube> it's clearly single process single thread
[19:17:02] <companion_cube> (source: htop)
[19:17:31] <sleepydog> Corbin: I think almost all of coreutils is single threaded :)
[19:18:56] <sleepydog> I will cede GUIs are more complex, but for most network services you can get very far with just multi-process and some timeout mechanism like alarm(2)
[19:19:24] <companion_cube> GUIs have an event loop, and a lot of callbacks
[19:19:32] <reynir> you can write this in bash just fine  { sleep 10; echo 1; } & { sleep 5; echo 2; } & wait
[19:19:33] <companion_cube> that is, if you exclude the React-like stuff in browers
[19:20:03] <haesbaert> sleepydog: I think they were talking about concurrency, not being multi-threaded, I think it would clarify the discussion if we just called I/O multiplexing
[19:20:56] <Corbin> sleepydog: bash supports job control, yes.
[19:21:12] <sleepydog> my understanding is we're discussing if an I/O event loop is a fundamental necessity for a modern programming language runtime
[19:22:32] <haesbaert> but the job control on a shell doesn't imply you need to do IO/multiplexing, historically it was all done via signals (IIRC)
[19:22:47] <Corbin> Yeah. Although right now I'm defending something a little easier: Is there a reason to include sync I/O for user-level code, including the code for the runtime? The runtime could still have sync I/O at its bedrock. (I see this as similar to the page of assembly required to write a kernel; I know it's sometimes required.)
[19:23:26] <companion_cube> it still is the simplest and quickest way to interact with files
[19:23:30] <companion_cube> so, yes
[19:24:31] <sleepydog> i can see arguments for both. it can actually be difficult to reach the full capabilities of physical storage these days using sync I/O
[19:24:49] <sleepydog> especially if what you are doing does not benefit from readahead
[19:24:52] <Corbin> companion_cube: It is quite simple, sure. It's not as fast as a threadpool, which lets the process enqueue multiple disk actions on the kernel; in turn, the kernel's disk scheduler is then able to choose how to interleave. Access to threadpools can be made async-only.
[19:25:10] <companion_cube> you're assuming the calling code is async
[19:25:21] <companion_cube> it's definitely faster than a threadpool if you don't have other threads
[19:25:40] <Corbin> Faster for "file", yes; faster for "files", not necessarily.
[19:25:56] <companion_cube> ah well, that depends on what you do
[19:26:08] <companion_cube> that said I am indeed excited for domainslib
[19:26:18] <companion_cube> and its pool-like abstraction.
[19:26:24] <companion_cube> all in direct style.
[19:30:23] <haesbaert> sleepydog: weellllll technically if the stuff is mounted as async the kernel will reserve a descriptor and return control to you so you can queue a lot still
[19:30:54] <haesbaert> a modern ahci had 1024 descriptor IIRC
[19:32:53] <companion_cube> the fun part is: I'm thinking of removing lwt from my IRC bot(s)
[19:33:02] <companion_cube> because it's just less convenient than threads
[19:33:27] <haesbaert> this is different than a network card where a "flow" will be hashed into one transmit queue, and one transmit queue cannot saturate a 10gbit/link
[19:37:42] <sleepydog> haesbaert: if you are reading a file, taking some action based on the contents of that read, and then reading the next file, or some other section of that file, no amount of "invisible" async will help
[19:38:11] <sleepydog> the explicit async at least forces a programmer to think about what else they could do while waiting for an I/O to complete
[19:38:52] <companion_cube> if there's anything else to do, of course.
[19:39:01] <sleepydog> yes, definitely
[19:39:20] <sleepydog> and it's perfectly valid to say "let the other threads in the program do something productive"
[19:40:37] <sleepydog> it is just as easy to come up with use cases that really *need* async to work well as it is to come up with use cases that are needlessly complicated by requiring async for everything
[19:41:55] <companion_cube> totally
[19:42:15] <companion_cube> but just removing sync IOs is pulling the ladder on simple solutions for simple problems
[19:42:27] <companion_cube> (e.g. reading a config file)
[19:46:54] *** Joins: spip (~bobo@37.172.152.150)
[19:47:11] *** Quits: bobo (~bobo@37.170.120.80) (Ping timeout: 256 seconds)
[19:49:52] <sleepydog> I think Go does a really good job in this regard. For the most part, when it comes to I/O, you can write code in a direct style, with minimal callbacks, and the complexity of the event loop is hidden from you. Seemingly you get the best of both worlds.
[19:52:13] <companion_cube> hopefully we get there with effects
[19:52:27] <companion_cube> however, I often hear that Go interop with C is problematic
[19:52:34] <companion_cube> is it related?
[19:53:54] <sleepydog> somewhat. one reason it's problematic is because of Go's calling convention. That is not related. However, another reason is that it is hard, in general, to consistently run a goroutine on the same thread. So C routines and system calls which use thread-local storage are problematic.
[19:54:33] <companion_cube> we'll see how it goes with effects, I'm curious :)
[19:54:58] <sleepydog> yes, i've never used a language with effects, it will be exciting!
[19:55:41] *** Quits: bartholin (~bartholin@158.110.71.61) (Ping timeout: 256 seconds)
[19:59:52] *** Joins: bartholin (~bartholin@158.110.71.61)
[20:17:06] *** Joins: motherfsck (~motherfsc@user/motherfsck)
[20:17:13] *** Quits: jlrnick (~josephler@gw.lipn.univ-paris13.fr) (Ping timeout: 256 seconds)
[20:18:22] *** Quits: Haudegen (~quassel@91.114.49.10) (Quit: Bin weg.)
[20:22:31] <dh`> there's a nice paper on how the haskell foreign function interface deals with that problem (running language threads on consistent OS threads)
[20:23:19] <dh`> anyway, there's several different considerations in this discussion that I think are being run together
[20:23:44] <dh`> one is whether a language or library should have a synchronous I/O interface, and the answer there is almost certainly yes
[20:24:00] *** Quits: chrisz (zutkc684um@d536135b.access.ecotel.net) (Remote host closed the connection)
[20:24:07] <dh`> one is whether the implementation of that interface should use async I/O under the covers
[20:24:47] <dh`> there is no compelling inherent reason not to, especially if you also have an async I/O interface
[20:25:16] <dh`> it's much more likely that the async interface will work if the sync interface (which will be used much more often and more thoroughly) uses the same infrastructure.
[20:25:40] <dh`> however, there are several extrinsic reasons not to, beginning with the dodgy async I/O implementations in most OSes
[20:49:34] <companion_cube> dh`: what is the point of using async IOs if you're going to block on them immediately, though?
[20:51:35] *** Quits: lobo (~lobo@user/lobo) (Quit: lobo)
[20:55:01] *** Joins: lobo (~lobo@user/lobo)
[20:59:35] *** Quits: bartholin (~bartholin@158.110.71.61) (Quit: Leaving)
[21:08:13] *** Quits: mbuf (~Shakthi@110.225.240.104) (Quit: Leaving)
[21:14:02] *** Joins: mro (~mro@port-92-195-145-88.dynamic.as20676.net)
[21:17:57] *** Quits: mro (~mro@port-92-195-145-88.dynamic.as20676.net) (Ping timeout: 240 seconds)
[21:23:30] *** Joins: Tuplanolla (~Tuplanoll@91-159-69-98.elisa-laajakaista.fi)
[21:40:18] *** Joins: Haudegen (~quassel@178.115.237.87.static.drei.at)
[22:00:44] *** Joins: dextaa_ (~dextaa@user/dextaa)
[22:06:25] *** Joins: gareppa (~gareppa@user/gareppa)
[22:08:24] *** Quits: gareppa (~gareppa@user/gareppa) (Remote host closed the connection)
[22:12:05] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[22:19:33] *** Joins: rgrinberg (~textual@2806:101e:7:5086:c127:9b59:bd2c:b6b3)
[22:39:13] <d_bot_> <mimoo> if someone needs a project idea, it'd be really nice if OCaml had a playground like Golang and Rust have (https://go.dev/play/, https://play.rust-lang.org/)
[22:40:06] <companion_cube> I was about to link sketch.sh but it fails on my browser
[22:40:13] <companion_cube> might be google tag manager
[22:47:18] <d_bot_> <mseri> https://sketch.sh/ works fine on the ipad
[22:47:32] <companion_cube> I do block googletagmanager
[22:47:35] <companion_cube> cause fuck google
[22:54:48] <d_bot_> <mseri> Oh I need to study. What is google tag manager? I block lots of things but that was not on my radar
[22:57:11] <d_bot_> <undu> google analytics, I have it permanently blocked using ublock _and_ umatrix
[22:59:20] <d_bot_> <VPhantom> Yeah GoogleTagManager is a lot more than just a new name for Analytics: it's also a gateway to load all sorts of other JS at the webmaster's (or his marketing consultant's) whim. Facebook tracking, etc.
[23:05:06] <d_bot_> <glennsl> There's also https://betterocaml.ml/
[23:05:39] <d_bot_> <glennsl> And https://try.ocamlpro.com/
[23:05:54] <d_bot_> <glennsl> I'm sure we could do with a few more though. OCaml peeps like variety
[23:08:49] *** Joins: vicfred (~vicfred@user/vicfred)
[23:09:42] *** Quits: rgrinberg (~textual@2806:101e:7:5086:c127:9b59:bd2c:b6b3) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[23:10:56] *** Quits: motherfsck (~motherfsc@user/motherfsck) (Ping timeout: 256 seconds)
[23:12:01] *** Joins: vicfred_ (~vicfred@user/vicfred)
[23:13:36] *** Joins: travv0 (sid293381@user/travv0)
[23:14:17] *** Quits: vicfred (~vicfred@user/vicfred) (Ping timeout: 240 seconds)
[23:23:19] *** Joins: mro (~mro@port-92-195-145-88.dynamic.as20676.net)
[23:42:27] *** Quits: gravicappa (~gravicapp@145.255.0.191) (Ping timeout: 268 seconds)
[23:43:52] <d_bot_> <Et7f3 (@me on reply)> https://reasonml.github.io/en/try ðŸ‘€
[23:47:37] *** Joins: azimut_ (~azimut@gateway/tor-sasl/azimut)
[23:50:15] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Ping timeout: 240 seconds)
