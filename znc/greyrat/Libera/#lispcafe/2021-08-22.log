[00:02:25] *** Joins: mark-eliot (~mark-elio@154.6.18.155)
[00:02:29] <mark-eliot> hey
[00:03:15] <mark-eliot> anyone here
[00:03:34] <aeth> perhaps
[00:03:37] <aeth> define 'here'
[00:03:53] <mark-eliot> just wondering how active the chat is
[00:04:06] <aeth> If by 'here', you mean online and in this channel, then plenty are. If by 'here', you mean right behind you, then not many are
[00:04:11] <mark-eliot> or if everyone is afk
[00:04:30] <mark-eliot> aeth: funny lol
[00:05:21] <aeth> two caveats: IRC is less active on the weekends (I guess people do different things, like e.g. gaming)
[00:05:28] <aeth> and this channel seems to be more active in a few hours
[00:05:40] <mark-eliot> ah i see
[00:05:44] <mark-eliot> thats fair
[00:07:10] <mark-eliot> what do people do while they are online anyway? i doibt people are just chatting lol
[00:07:28] <mark-eliot> i usually am programming and chatting or getting high and chatting
[00:08:30] *** Quits: mark-eliot (~mark-elio@154.6.18.155) (Quit: Lost terminal)
[00:10:12] *** Joins: ramenbytes (~vir@071-009-124-057.res.spectrum.com)
[00:13:39] <aeth> right, people are probably programming/browsing/working and have IRC in the background
[00:14:27] <contrapunctus> Or lying in bed checking IRC
[00:15:05] <contrapunctus> After a long day of obsessively fiddling with documentation.
[00:16:34] *** Joins: razzy (~razzy@user/razzy)
[00:18:40] *** Joins: notzmv (~zmv@user/notzmv)
[00:24:27] *** Quits: ramenbytes (~vir@071-009-124-057.res.spectrum.com) (Remote host closed the connection)
[00:25:19] <lotuseater> hmpf now i was gone, he was joined and arrgggh :D murphy's law at its best
[00:27:48] <lotuseater> i still can't decide what series to watch now in parallel
[00:30:07] <lotuseater> hm I don't need to be high at all, especially not for chatting with you people :)
[00:30:20] *** Quits: razzy (~razzy@user/razzy) (Ping timeout: 250 seconds)
[00:31:27] * gilberth is bored, reads the original McCarthy paper, and, as bug haunted as he is, spots two missing "]"s in 'eval'.
[00:31:50] <lotuseater> ah cool
[00:32:08] <lotuseater> sad that part 2 can't come out anymore ^^
[00:32:46] * lotuseater eats insta-noodles
[00:32:58] <gilberth> Anyhow, as bored as I am, I'll write a quick m-expr parser.
[00:33:05] <lotuseater> cool
[00:33:13] <lotuseater> quick and dirty
[00:34:22] <lotuseater> i once tried to read and understand the paper by Timothy Hart from 1963 on how to build macros into the language
[00:35:02] <gilberth> Not so dirty actually. The definitions McCarthy gives also includes syntax, although obvious, not formally defined in his mapping of m-exprs to s-exprs.
[00:35:39] <lotuseater> i should reconsult portions of this paper again
[00:37:20] <gilberth> Well, you'll notice two things: (1) there is no SETQ (2) there are no closures or anonymous functions.
[00:37:57] <lotuseater> ah
[00:38:41] <gilberth> You could however pass a quoted lambda expression. So the latter is open for debate.
[00:39:56] <gilberth> But then Standard Lisp or original elisp also have no lexical closures.
[00:40:55] <pl> lexical closures only arrived with Scheme, I think? 
[00:41:06] <gilberth> I believe so.
[00:41:08] <lotuseater> was another time
[00:41:32] <lotuseater> C has none upto today as I see it
[00:42:14] <gilberth> Does C have a garbage collection?
[00:42:34] <lotuseater> not really
[00:42:40] <gilberth> I mean, once you have lexical closures, you pretty much need a garbage collection.
[00:42:56] <gilberth> lotuseater: Really? Not at all.
[00:43:08] <lotuseater> this does go hand in hand? ok, new to me
[00:43:27] <lotuseater> gilberth: but you could use one for your c program runtime
[00:44:13] <pl> C++ has lexical closures
[00:44:15] <pl> iirc
[00:44:17] <gilberth> And? That does not make the language having it. And good luck for having a precise garbage collector.
[00:45:02] <gilberth> pl: Real ones, where you could also assign a lexical closed over?
[00:45:04] <lotuseater> of course
[00:45:25] <pl> gilberth: no idea, never got to test it as I got out of C++ before it happened
[00:46:09] <lotuseater> look at how Java since version 8 adapted lambdas
[00:46:23] <gilberth> Many languages fake lexical closures, by copying the closed over values, not closing over the reference, which does imply that the closed over lexical may not be on the stack, but dynamically allocated => Need for GC.
[00:46:39] <lotuseater> i see
[00:47:23] <lotuseater> you even don't really want to do recursive things
[00:49:39] <gilberth> See: (defun cons (x y) (lambda (op &optional arg) (ecase op (car x) (cdr y) (rplaca (setq x arg)) (rplacd (setq y arg))))) (defun car (x) (funcall x 'car)) (defun rplaca (x y) (funcall x 'rplaca x y) x) etc.
[00:50:14] <gilberth> * (funcall x 'rplaca y) ;rather
[00:50:26] <White_Flame> gilberth: C has some conservative GC libraries, which snoop for any values that are in the heap range
[00:51:01] <gilberth> White_Flame: Sure, but still: C the language doesn't have that.
[00:51:01] <White_Flame> and C++ still just does smart pointers & refcounting as far as I'm aware
[00:51:18] <lotuseater> smaaart
[00:51:23] <White_Flame> """smart"""
[00:51:26] <gilberth> Which is no GC in my book, but syntactic sugar.
[00:51:32] <White_Flame> like """smart devices""" :-P
[00:53:38] <gilberth> Point is: You can't write a GC for C conforming to the standard as long as you want a lexical being a C lexical.
[00:54:28] <gilberth> You may have access to the heap, when you implement your own malloc, which is fine. But you don't have access to the CPU stack or registers.
[00:58:01] <gilberth> And: There is nothing in the standard, which demands, that lexicals need to be kept on a stack. It would be fine for a compiler to put lexicals as 'static' variables at fixed locations into heap, when it can prove that a function is re-entered ever.
[00:59:09] <pl> one can make C garbage collected and pass standard test suite, yet fail on most program code
[00:59:37] <gilberth> Or implement recursion by putting all lexicals into static locations and evacuate old values onto the stack on re-entry and restore them later. I did this with my itty TTL CPU design.
[01:03:28] <gilberth> pl: Well, you can't because you could cast a pointer to an integer end then "encrypt" it in any way. The promise is, that a pointer cast to an integer yields some integer value, which when cast back yields the same pointer. Could well be some hash or what ever. However you could say XOR that integer you got with 0xdeadbeef stash it and retrieve it again, xor again, and get the same pointer back.
[01:04:04] <pl> gilberth: that only requires that it's not copying GC :P
[01:04:08] <gilberth> So once a pointer to an object is cast to an integer, that object could never be reclaimed.
[01:04:26] <pl> also, it can be a handle instead of a pointer
[01:04:32] <pl> because pointer arithmetic is actually UB :P
[01:04:54] <gilberth> pl: Nope. Copying has nothing to do with that. The integer does not need to be a machine address.
[01:05:12] <gilberth> pl: pointer arithmetic is well defined.
[01:05:40] <pl> gilberth: at least by ANSI, only within confines of array iirc
[01:06:06] <moon-child> uintptr_t, where available, can round-trip void*
[01:06:15] <moon-child> and void* can round-trip T* (assuming T is an object type)
[01:06:33] <gilberth> You add an integer to a pointer, you get a new one. It must however point into the original object or just one offset beyond. When you subtract pointers, both pointers must point to the same object.
[01:07:33] <gilberth> pl: Yes. ISO C is the same. So pointer arith is not per se UB. UB is when you don't play by the rules.
[01:08:28] <gilberth> But otherwise: The assumption that you deal with machine addresses leads to UB.
[01:09:06] <pl> gilberth: but IIRC for the pointer to be guaranteed to work after round-trip, it's value must be the same from start to end, right?
[01:09:22] <gilberth> pl: Yes.
[01:10:15] <gilberth> Or: (char*)((uintptr_t)x + 1) is UB.
[01:11:52] <pl> and nothing stops you from implementing a compiler that does some magic on casts
[01:11:55] <moon-child> but how about (char*)((uintptr_t)x + 1 - 1)?  Spec is not entirely clear.  Newer spec is getting a 'provenance' model, under which I think that expression would be 'based on' x and hence well-defined
[01:12:26] <gilberth> moon-child: x + 1 - 1 is ok.
[01:12:40] <pl> I think Symbolics C had to do magic because you can't implement C directly on either 3600 or Ivory
[01:14:20] <pl> (due to issues in making sizeof(char)=1 when (void*)1+1 and (char*)1+1 are different values)
[01:14:21] <moon-child> gilberth: spec says '[intptr_t] designates a signed integer type with the property that any valid pointer to void can be converted to this type, then converted back to pointer to void, and the result will compare equal to the original pointer'.  It doesn't say anything about converting intptr_t that happen to compare equal to an intptr_t converted from void*
[01:15:26] <gilberth> My point was, that the following is ok, too: uintptr_t hidden; void hide (void *p) { hidden = p ^ 0xdeadbeefl; } void *reveal (void) { return (void*)(hidden ^ 0xdeadbeefl; } int main (void) { hide (strdup ("Hello, world!\n")); puts (reval ()); }
[01:16:43] <gilberth> moon-child: You say, that the uintptr_t I get could be a trap representation? As allowed for char?
[01:18:42] <gilberth> Hmm.
[01:30:10] *** Joins: razzy (~razzy@user/razzy)
[01:30:25] * gilberth read the C standard again and still is puzzled.
[01:32:36] <gilberth> It is less than clear. It doesn't mention that (uintptr_t)p could be a trap representation. It mentions that a pointer cast to an integer may yield a value outside the range of any integer type, yet defines uintptr_t as an integer type.
[01:34:35] <gilberth> So IMHO it contradicts itself a bit. Heck, I even cannot find, that it promises (uintptr_t)(void*)0 == 0 to be true. Which makes sense.
[01:35:05] *** Quits: razzy (~razzy@user/razzy) (Ping timeout: 248 seconds)
[01:37:56] *** Quits: shka (~herr@109.231.62.239) (Ping timeout: 250 seconds)
[01:38:59] *** emacsoma1 is now known as emacsomancer
[01:47:25] <gilberth> Curious: McCarthy wrote
[01:47:28] <gilberth> eval [caddar [e]; append [pair [cadar [e]; evlis [cdr [e]; a]; a]]
[01:47:31] <gilberth> instead of
[01:47:41] <gilberth> eval [caddar [e]; append [pair [cadar [e]; evlis [cdr [e]; a]]; a]]
[01:48:30] <gilberth> His pair function only takes two arguments, while PAIRLIS as an optional third argument, which would make the append superfluous. Last minute change?
[01:49:09] <gilberth> That's one of missing "]"s.
[01:55:46] <pjb> gilberth: yes, he didn't used emacs with paredit!
[02:00:15] *** Joins: z147_ (~z147@gateway/tor-sasl/z147)
[02:01:26] *** Quits: z147_ (~z147@gateway/tor-sasl/z147) (Client Quit)
[02:02:06] <gilberth> But now I know where LABELS come from. The original Lisp has ((LABEL FOO (LAMBDA (X) ..)) ..) for what would be (LABELS ((FOO (X) ..)) ..) in CL. Only that LISP is a Lisp-1.
[02:02:38] <pjb> gilberth: nope, LISP 1.5 was a lisp-2 (lisp-n actually).
[02:02:54] <pjb> gilberth: everything was stored in the symbol plist, even the symbol name.
[02:02:58] *** Quits: z147 (~z147@gateway/tor-sasl/z147) (Ping timeout: 244 seconds)
[02:03:20] <gilberth> pjb: I am refering to the April 1960 paper.
[02:03:26] <pjb> ok.
[02:04:09] <pjb> http://informatimago.com/develop/lisp/com/informatimago/small-cl-pgms/aim-8/index.html
[02:04:09] -ixelp- The Original LISP
[02:04:37] <pjb> and if you prefer M-expressions: http://informatimago.com/develop/lisp/com/informatimago/small-cl-pgms/m-expression/index.html
[02:04:37] -ixelp- A Parser for M-Expressions
[02:06:57] *** Joins: razzy (~razzy@user/razzy)
[02:07:02] <gilberth> Thanks. I have a parser already. And: I play with his definition of eval as given in <http://www-formal.stanford.edu/jmc/recursive.ps>
[02:10:57] <gilberth> pjb: And it's different the AIM-8 uses SUBST to rewrite expressions for bound variables, while the '60 paper has a lexical environment as an a-list passed to eval.
[02:15:38] <gilberth> It's funny that muLISP accepts (a,b,c) for (a b c) and you can write e.g. (lambda (x) ((null x) ..) (t ...)) for a COND. So it's pretty close.
[02:16:56] *** Quits: razzy (~razzy@user/razzy) (Ping timeout: 250 seconds)
[02:17:36] <hayley> https://www.youtube.com/watch?v=vsbubufRot8
[02:17:36] -ixelp- Julia's Song (Live at the Museum of Liverpool) - YouTube
[02:22:32] *** Quits: jurov_ (~jurov@rev-81-92-255-34.radiolan.sk) (Ping timeout: 245 seconds)
[02:23:35] *** Quits: derelict (~derelict@user/derelict) (Quit: WeeChat 3.2)
[02:26:44] <hayley> https://www.youtube.com/watch?v=Tniw8eWShWE
[02:26:44] -ixelp- Cry the Clock Said - YouTube
[02:28:32] <moon-child> gilberth: 'a pointer cast to an integer may yield a value outside the range of any integer type, yet defines uintptr_t as an integer type' that's fine; intptr_t is optional
[02:29:27] <moon-child> 'muLISP accepts (a,b,c) for (a b c) and you can write e.g. (lambda (x) ((null x) ..) (t ...)) for a COND'  thanks, I hate it
[02:31:31] <gilberth> Yes, it's pretty unreadable. muLISP that is.
[02:34:12] *** Joins: jurov (~jurov@rev-81-92-255-34.radiolan.sk)
[02:41:26] <gilberth> moon-child: ok. I overlooked that intptr_t is optional. Yes, so the implementation might as well make any cast of a pointer to an integer UB, when intptr_t is not there. Hmm.
[02:46:49] *** Quits: Alfr (~Alfr@user/alfr) (Killed (tungsten.libera.chat (Nickname regained by services)))
[02:46:54] *** Joins: Alfr (~Alfr@user/alfr)
[02:48:56] <pjb> moon-child: note that in the origins, symbols could contain spaces, so they were separated by commas: (A VERY,NICE LIST) is written in CL (|A VERY| |NICE LIST|)  ; which one do you hate more?
[02:49:17] *** Joins: lisp123 (~lisp123@5.30.23.247)
[02:53:46] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[02:57:25] <moon-child> oh--that actually makes sense
[02:58:42] <moon-child> I mean, poor style, but not _obviously horrible_
[03:02:47] <gilberth> pjb: Does this also apply to M-exprs? Or: f[FOO BAR] == (F (QUOTE |FOO BAR|))?
[03:09:36] *** Joins: derelict (~derelict@user/derelict)
[03:13:45] <gilberth> It's also funny that McCarthy's Lisp has T (or 1) being the only true value and everything else being false within a COND as per AIM-8.
[03:14:46] *** Quits: derelict (~derelict@user/derelict) (Quit: WeeChat 3.2)
[03:15:04] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[03:29:44] *** Quits: makomo (~makomo@user/makomo) (Ping timeout: 250 seconds)
[03:34:30] *** Quits: Alfr (~Alfr@user/alfr) (Remote host closed the connection)
[03:34:54] *** Joins: Alfr (~Alfr@user/alfr)
[03:37:57] <pjb> gilberth: definitely.
[03:38:41] <pjb> only in M-expressions, you'd use semi-colon to separate elements: f[(FOO BAR,BAZ);ANOTHER PARAMETER]
[03:40:25] <gilberth> Or are white spaces just ignored altogether? What is eq[A B;AB]?
[03:41:19] <gilberth> And eq[A; A]?
[03:42:30] *** Quits: Alfr (~Alfr@user/alfr) (Remote host closed the connection)
[03:42:54] *** Joins: Alfr (~Alfr@user/alfr)
[03:47:46] <moon-child> how about 'e q[A;A]'?  How do you distinguish a symbol with spaces in function position from two separate expressions one following the other?
[03:48:32] <gilberth> There are no two expressions following each other without a punctation in between.
[03:49:31] <moon-child> so you need, e.g. 'f[x];g[y]' to perform two function applications?
[03:50:01] <gilberth> There is no PROGN.
[03:50:25] *** Quits: Alfr (~Alfr@user/alfr) (Ping timeout: 252 seconds)
[03:50:32] <gilberth> Neither implicit, nor explicit. Won't make sense, as there are no side effects.
[03:52:56] *** Joins: kakuhen (~kakuhen@user/kakuhen)
[03:53:56] <pjb> gilberth: AFAIK, they're not ignored.
[03:54:08] *** Joins: lisp123 (~lisp123@5.30.23.247)
[03:54:24] <pjb> Now, there were newlines, so perhaps spaces were ignored in m-expressions?
[03:54:47] <kakuhen> off-topic, but, apparently some NeXT source code got leaked; it contains code for appkit, display postscript, their audio server, some mach stuff, and more
[03:54:55] <pjb> moon-child: e;q[A;A]  vs.: e q[A;A]
[03:55:03] <lotuseater> ohai kakuhen :)
[03:55:20] <lotuseater> where did it get leaked?
[03:55:42] *** Joins: derelict (~derelict@user/derelict)
[03:55:51] <gilberth> pjb: Well, the April '60 paper at least indents, hard to tell whether there is white space otherwise.
[03:55:53] <pjb> Well, OpenStep was a cooperation with Sun (and perhaps HP too), and Sun had their own implementation IIRC.
[03:55:59] <kakuhen> lotuseater: i first need to be careful with the rules of this channel
[03:56:14] <pjb> kakuhen: have a drink. What rules?
[03:56:17] <kakuhen> o-oh
[03:56:27] <lotuseater> yes what rules? ^^
[03:56:30] <moon-child> kakuhen: careful, pjb doesn't make the rules
[03:56:35] <moon-child> nor does lotuseater
[03:56:41] <pjb> no, /topic makes the rules!
[03:56:42] <moon-child> they're trying to trick you, lead you down a hard life of crime
[03:56:44] <lotuseater> being not offensive would be one these rules
[03:56:53] <kakuhen> ok im risking a ban over this gofile.io/d/a3AlsD
[03:57:09] <kakuhen> disclaimer: do not download ;)
[03:57:14] <lotuseater> moon-child: indeed. and I surely don't want to
[03:57:39] <gilberth> kakuhen: I shouldn't download? A pity.
[03:57:42] <kakuhen> anyway, this looks like it's from NeXT 2.5; it would've been more interesting to see OpenStep 4.x or whatever
[03:57:48] <kakuhen> nonetheless something cool for me
[03:58:12] <lotuseater> some years ago Windows NT kernel source got leaked, right?
[03:58:25] <moon-child> yea
[03:58:29] <kakuhen> yea, in particular most of windows xp and part of server 2003
[03:58:42] <lotuseater> nice
[03:58:46] <pl> wasn't it mostly so-called NT4.5, not 5.2?
[03:58:47] <moon-child> there are various versions of windows source code.  One corresponds to windows nt, and another was given to some research institutions
[03:58:55] <moon-child> there's also win2k source code
[03:59:01] <moon-child> also ms-dos was opensourced
[03:59:10] <pjb> kakuhen: nothing secret: there are binary copies of the ROM (this is licensed, but you're allowed to have a copy if you have a ROM in your possession); the rest are GPL or BSD sources.
[03:59:11] <lotuseater> they would argue: "so everything from linux got leaked from the beginning!" :D
[03:59:14] <pl> moon-child: most of the time, it all comes down to so-called NT4.5
[03:59:33] <pl> which leaked from a version provided to universities
[03:59:55] <pl> and is incomplete source snapshot from win2k development
[04:00:38] <pjb> kakuhen: but still an interesting collection.  Too bad I don't have my NeXTstation Turbo anymore.
[04:00:45] <moon-child> err, I said 'corresponds to windows nt', but I meant windows xp
[04:00:59] <kakuhen> pjb: yeah, i was mostly interested in DPS
[04:01:06] <kakuhen> I haven't come across this before
[04:01:09] <pjb> kakuhen: notice how there's no Objective-C sources of NeXTStep or OpenStep…
[04:01:29] <lotuseater> pjb: how much did you pay for it in the past?
[04:01:34] <pl> moon-child: I encountered many claims of XP, but never seen actual meat for the claims :)
[04:02:03] <pjb> Oh, sorry, I miswrote, there's: next/NeXTSrc/appkit-105.2
[04:02:06] <pl> though I just thought that due to the time I might be missing bits
[04:02:11] * pl is getting old
[04:02:12] <pjb> lotuseater: more than 1 year salary!
[04:02:22] <pjb> In 1992.
[04:02:35] <moon-child> pl: I have a copy.  But it's 3g, so take a while to send anywhere/demonstrate
[04:02:46] *** Joins: Alfr (~Alfr@user/alfr)
[04:02:53] <lotuseater> oha
[04:02:57] <pjb> Well, the original Macintosh was also that expensive.
[04:03:05] <pl> I have Solaris 11.something "ON" source grabbed some time ago
[04:03:49] <pjb> In any case, it's really archeology now. Apple has rewritten all that ten times already. I doubt they still have a single original line of code.
[04:04:47] <lotuseater> uff
[04:05:37] <pjb> It looks like the last change dates were about late 1990.
[04:06:07] <kakuhen> yeah, that's why i'm guessing it's some snapshot of next 2.5 or older version
[04:06:33] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 248 seconds)
[04:07:35] <kakuhen> also i found someone's emacs backup file in this tarball
[04:14:29] <gilberth> Heh. I still try to figure out what is in that tar ball.
[04:15:44] *** Joins: Qwnavery (~Qwnavery@user/qwnavery)
[04:18:24] <notzmv> gog damn it I hope it's fixed now 
[04:19:00] <notzmv> my irc client on mobile was reconnecting every time it switched from ipv6 to ipv4
[04:22:27] *** Joins: razzy (~razzy@user/razzy)
[04:25:28] *** Quits: Qwnavery (~Qwnavery@user/qwnavery) (Quit: WeeChat 3.2)
[04:26:56] *** Quits: razzy (~razzy@user/razzy) (Ping timeout: 250 seconds)
[04:31:40] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 240 seconds)
[04:34:49] *** Joins: Qwnavery (~Qwnavery@user/qwnavery)
[04:36:32] *** Joins: lisp123 (~lisp123@5.30.23.247)
[04:45:19] *** Alfr is now known as Guest2662
[04:45:24] *** Joins: Alfr (~Alfr@user/alfr)
[04:46:33] *** Quits: Alfr (~Alfr@user/alfr) (Read error: Connection reset by peer)
[04:47:44] *** Quits: Guest2662 (~Alfr@user/alfr) (Ping timeout: 250 seconds)
[04:47:44] *** Quits: random-nick (~random-ni@87.116.176.45) (Ping timeout: 250 seconds)
[04:47:53] *** Joins: Alfr (~Alfr@user/alfr)
[04:52:04] *** Joins: dave0 (~davezero@069.d.003.ncl.iprimus.net.au)
[04:52:13] *** Quits: Alfr (~Alfr@user/alfr) (Read error: Connection reset by peer)
[04:53:14] <dave0> maw
[04:53:23] *** Joins: Alfr (~Alfr@user/alfr)
[04:56:12] <lotuseater> maw to you back :)
[05:00:33] <dave0> hi lotuseater 
[05:01:24] <lotuseater> hi. unfortunately I'm still here
[05:04:07] *** Quits: Alfr (~Alfr@user/alfr) (Read error: Connection reset by peer)
[05:05:22] *** Joins: Alfr (~Alfr@user/alfr)
[05:05:30] *** Quits: Qwnavery (~Qwnavery@user/qwnavery) (Quit: WeeChat 3.2)
[05:15:30] *** Quits: Alfr (~Alfr@user/alfr) (Remote host closed the connection)
[05:15:53] *** Joins: Alfr (~Alfr@user/alfr)
[05:17:25] *** Quits: Alfr (~Alfr@user/alfr) (Read error: Connection reset by peer)
[05:18:53] *** Joins: Alfr (~Alfr@user/alfr)
[05:22:54] <gilberth> Everyone busy porting NeXT code?
[05:28:47] <lotuseater> no I'm not
[05:29:14] <lotuseater> and you?
[05:33:17] <gilberth> No, I am idly watching YT only to learn that my special friend Keith Packard believes Lisp is interpreted. Or "LISP" as he spells it.
[05:34:08] <gilberth> As if it is a properity of a language to be interpreted or not.
[05:34:12] <lotuseater> this week i saw one video (in German) where one said javascript is the most modern dialect
[05:34:30] <lotuseater> modern /= new /= good
[05:35:06] <gilberth> Scheme dialect?
[05:35:14] <lotuseater> no lisp dialect in general
[05:35:42] <lotuseater> of course, it's effectively a weird not well designed scheme with c-ish syntax
[05:36:00] <gilberth> Where are my macros then?
[05:36:16] <lotuseater> I don't know.
[05:36:35] <lotuseater> it was about why the whole thing is so minimal used
[05:36:59] <lotuseater> even Rust has some kind of macros, or Julia
[05:37:23] <lotuseater> https://www.youtube.com/watch?v=0cQ6Ne5SD40
[05:37:24] -ixelp- Warum verwendet niemand Lisp? // deutsch - YouTube
[05:37:32] <gilberth> Letting me work on the AST to return a new one.
[05:37:40] <gilberth> Bah! German. brrr
[05:38:12] <lotuseater> watch the some dumb video commentary
[05:38:20] <lotuseater> haha yes
[05:39:06] <gilberth> So unless I can extent the language with macros, it won't count in my book.
[05:39:45] <gilberth> I don't care whether Lisp is popular or not. Actually I believe it's good, that it isn't too popular.
[05:40:00] *** Quits: Alfr (~Alfr@user/alfr) (Remote host closed the connection)
[05:40:20] <edgar-rft> gilberth: I'll synchronize it in Badisch for you.
[05:40:22] *** Joins: Alfr (~Alfr@user/alfr)
[05:40:23] <lotuseater> best commentary "The bad downside is missing typing. Now Ruby and Python can even do that."
[05:40:40] <lotuseater> yes too popular is often bad
[05:41:38] <gilberth> edgar-rft: Go ahead! It might be fun.
[05:42:14] <lotuseater> edgar-rft: not Swabian?
[05:42:24] <edgar-rft> common knowledge from the media business: the three most popular things are food, drinks and porn
[05:42:41] <gilberth> Well for one thing it bars me from have to bear poorly written libraries. Though we have those for CL too, but less.
[05:43:00] <edgar-rft> lotuseater: gilberth loves Badisch much more than Swabian
[05:43:13] <gilberth> Indeed.
[05:43:47] <edgar-rft> I can see if I find someone from Bavaria :-)
[05:44:11] <gilberth> Hell, no!
[05:44:42] <gilberth> Anyhow, I am tired of all those language wars.
[05:46:07] <lotuseater> i like those swabian synchros by a famous youtuber
[05:46:48] <lotuseater> gilberth: 100.000 python libs, it must be fantastic!
[05:48:09] <gilberth> That are perhaps more than there are CL hackers.
[05:48:50] <edgar-rft> lotuseater: thank you! 1) I'm surprised that have listened to a programming language video in full length without clicking out in disgust after only a few seconds. 2) comparing lisp with javascript is ugh at best but the rest was really good.
[05:49:22] <lotuseater> edgar-rft: yes the rest was good :)
[05:53:26] <edgar-rft> okay, if I look at the channel's youtube page then the main focus is on web development what explains the javascript comments at the end. but nontheless, that guy can explain things really good.
[05:54:15] <lotuseater> or this one "oh no, Clojure and ClojureScript were not mentioned"
[05:58:10] <hayley> I went on a bike ride, and saw a sea lion and two idiotic parents with cardboard signs complaining about lockdowns.
[05:58:32] <hayley> The problem with the latter is they brought their kid a long, so it isn't fair to the kid to tell the parents to go fuck themselves.
[05:58:39] <lotuseater> but that with the sea lion sounds cool
[05:59:39] * hayley uploaded an image: (655KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/holMTdqdJhmFzNLZuAoSFxmT/IMG_20210822_112908.jpg >
[05:59:47] <lotuseater> cute
[06:00:03] <edgar-rft> hayley: I hope you considered shooting the parents, not the sea lions :-)
[06:00:23] <edgar-rft> lotuseater: the comment was more like "one of the reasons why you should try to learn lisp is that javascript only looks like C but most of its ideas are borrowed from lisp"
[06:00:27] <hayley> Hm, on a bike I could fathom pinching a sign and tossing it into the lake.
[06:00:32] <kakuhen> gilberth: I've seen worse claims than "LISP [sic] is interpreted" 
[06:00:43] * hayley uploaded an image: (67KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/eDxwlTAbCXzBlIYjhtwwmYEc/numan-cringe-department.jpg >
[06:00:53] <hayley> "Lisp is slow because there are only linked lists"
[06:00:54] <kakuhen> a few months ago i recall someone on #commonlisp trying to convince beach that repls that use a compiler could not exist
[06:01:10] <hayley> Yes, that happened.
[06:01:27] <hayley> Oh, and that a Lisp implementation required c code.
[06:01:30] <edgar-rft> Lisp is slow because I am slow :-)
[06:01:48] * hayley uploaded an image: (162KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/DyrebyuIKmDwSsuxyqHpPeEc/Screenshot_2021-07-11_18-12-44.png >
[06:02:22] <lotuseater> hayley: how do you even program without typing? :D
[06:04:10] *** Quits: Alfr (~Alfr@user/alfr) (Read error: Connection reset by peer)
[06:04:23] *** Joins: Alfr (~Alfr@user/alfr)
[06:04:24] <lotuseater> kakuhen: or some days ago when someone said C will always be required. beach's response "So do we still have 1958?"
[06:04:46] <lotuseater> ok C just is in existence since 1972
[06:05:14] <kakuhen> "Computers didn't actually exist before C" - some bell labs fanatic somewhere, maybe
[06:05:46] *** Quits: Alfr (~Alfr@user/alfr) (Read error: Connection reset by peer)
[06:05:57] *** Quits: White_Flame (~quassel@user/white-flame/x-6930243) (Remote host closed the connection)
[06:06:27] <gilberth> B?
[06:06:40] <lotuseater> i found a good metaphor myself again. when in your resume is "just" Linux and not Windows mentioned and they think you don't know what a computer is, it's like "You're not from the US or UK, so you can't speak English."
[06:06:48] <lotuseater> gilberth: And A :D
[06:06:53] *** Joins: Alfr (~Alfr@user/alfr)
[06:07:00] <gilberth> There is no A.
[06:07:10] *** Joins: White_Flame (~quassel@user/white-flame/x-6930243)
[06:07:12] <lotuseater> then I got something wrong
[06:07:25] <lotuseater> but I bet there is A+
[06:08:08] <gilberth> As they moved to the PDP-11, they added types to B and called it C.
[06:08:19] <lotuseater> haha ^^
[06:08:36] <lotuseater> as you said often it's just a PDP-11 assembler
[06:08:57] <gilberth> That's not funny, the PDP-11's idea of octet addresses sticks.
[06:08:58] <kakuhen> this is reminding me of a talk by Benno Rice
[06:09:12] <kakuhen> "What UNIX cost us" is the title iirc
[06:09:30] <hayley> Sure there is A, the A programming language.
[06:09:49] <kakuhen> one of the claims was that C (and the basics of Unix I/O) makes many assumptions that made sense on a PDP-11, but not modern computers
[06:10:01] <lotuseater> APL := A Programming Language
[06:10:10] <gilberth> Yes, the file extension is .a and you use 'as' to compile it.
[06:10:15] <kakuhen> Conseequently processors today, in some sense, try to pretend to be a PDP-11 so that C and UNIX is happy, and this leads to wacky designs and problems
[06:10:23] <lotuseater> not "ass"? :D
[06:11:10] *** Quits: Alfr (~Alfr@user/alfr) (Read error: Connection reset by peer)
[06:12:24] *** Joins: Alfr (~Alfr@user/alfr)
[06:12:37] <gilberth> I am not sure how much of UNIX was written in B. But the implementation was with threaded code and thus slow. IIRC the initial C compiler was the same. And: All sources of troff I found in the published UNIX sources are in assembler.
[06:13:27] <gilberth> It's also impossible to compile the C they used with any modern C compiler.
[06:14:06] <kakuhen> https://youtu.be/9-IWMbJXoLM?t=1171 here's the relevant part of the talk if anyone's interested; i probably paraphrased it wrong, hence posting
[06:14:06] -ixelp- "What UNIX Cost Us" - Benno Rice (LCA 2020) - YouTube
[06:14:36] <lotuseater> someone said to me yesterday it's a problem that SBCL compiles itself
[06:15:19] <hayley> https://www.youtube.com/watch?v=Nw1643T0RD0
[06:15:19] -ixelp- Pink Floyd - One Of These Days (Live At Pompeii) 1972 - YouTube
[06:15:33] <hayley> I don't care if it's "harder to bootstrap", I'm not writing a compiler in C
[06:15:43] <gilberth> It begins with, that field access to structures is not type checked by the compiler. It's fine to have "struct foo { int x, y; };" and "struct bar { <something entirely different> } *q;" and then say "q->x".
[06:16:30] * hayley uploaded an image: (27KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/jQVnDxVVUVHiuBtMJmpaxbXe/bootstrapping.jpg >
[06:16:43] <gilberth> And the UNIX source code does this a lot.
[06:17:16] <lotuseater> hayley: nice. and most people believe "real" compilers can only be written in C
[06:18:19] <gilberth> And haeh? SBCL started as a fork of CMUCL to make it possible boot-strapped it without needing a running CMUCL.
[06:18:34] <hayley> gilberth: https://www.youtube.com/watch?v=Q_B4oK4Mpzk
[06:18:35] -ixelp- [YTP] ElectroBOOM Clicks a Cliff - YouTube
[06:18:35] <lotuseater> indeed
[06:18:37] <kakuhen> sanely bootstrappable common lisp
[06:18:55] <gilberth> C is one of the worst choices to build a compiler in.
[06:19:09] <lotuseater> the argument was about "but if now all SBCL versions are lost"
[06:19:29] <hayley> C -> ECL -> SBCL
[06:19:31] <kakuhen> if i recall correctly, the FreeBSD ports people build SBCL by first compiling ECL and using it to bootstrap SBCL
[06:19:37] <gilberth> Then we have a dozen other CL implementations left.
[06:19:37] <kakuhen> hayley: there we go
[06:19:46] <hayley> IMO I would just start from CL rather than C.
[06:19:57] <hayley> CL -> CL
[06:20:18] <hayley> SICL -> SICL -> CLOSOS
[06:20:23] * gilberth build his first CMUCL by cross-compiling from FreeBSD, a multi-stage process.
[06:20:34] <lotuseater> backwards compatibility is important and CL itself provides this much better
[06:20:38] <kakuhen> i wonder if anyone's tried making a really obnoxious chain where you go through as many distinct languages as possible
[06:21:21] <kakuhen> i guess the important here is what I define as "distinct," and I don't have a good definition yet
[06:21:46] <hayley> C -> ECL -> Yale Haskell -> GHC -> Elm -> oh god oh fuck
[06:22:00] <gilberth> And CMUCL is pretty nasty in this respect as you really compile it within itself and then just dump.
[06:22:49] <lotuseater> And in GHC you have these stages with Core, C--, Spineless Tagless G-Machine
[06:23:20] <lotuseater> hayley: you mean this Elm -> JavaScript? :D
[06:23:25] <hayley> Don't worry, in SICL we only have CST, AST, HIR, MIR, platform-dependent LIR, real LIR, Cluster
[06:23:45] <lotuseater> oh sounds easy
[06:24:03] <hayley> "platform-dependent MIR" rather - but that only exists temporarily in MIR-to-LIR before we actually have registers, but after we tainted the IR to fit our dumb machine.
[06:25:26] <hayley> i.e. arithmetic has been rewritten for two-address instructions on x86-64, and arguments passed on registers are replaced with lexical locations for simplicity's sake.
[06:29:32] <lotuseater> good that you understand that stuff
[06:38:25] *** Quits: dave0 (~davezero@069.d.003.ncl.iprimus.net.au) (Quit: dave's not here)
[06:53:28] *** Quits: Alfr (~Alfr@user/alfr) (Read error: Connection reset by peer)
[06:54:24] *** Joins: Alfr (~Alfr@user/alfr)
[07:24:40] *** Joins: Qwnavery (~Qwnavery@user/qwnavery)
[07:35:59] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Read error: Connection reset by peer)
[07:36:53] *** Joins: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net)
[07:38:03] *** Quits: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net) (Read error: Connection reset by peer)
[07:38:23] *** Joins: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net)
[07:40:18] *** Quits: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net) (Read error: Connection reset by peer)
[07:40:38] *** Joins: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net)
[07:50:01] *** Quits: Qwnavery (~Qwnavery@user/qwnavery) (Ping timeout: 248 seconds)
[08:05:12] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[08:08:10] *** Quits: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 240 seconds)
[08:20:17] * gilberth spots another bug in McCarthy's eval.
[08:26:43] <lotuseater> oh noez
[08:27:05] <lotuseater> also genius make mistakes (or typos)
[08:32:20] <hayley> Jon Blow said everyone who writes a bug is an idiot, thus never hire idiots.
[08:32:23] <hayley> Ergo, JMC was unemployed?
[08:32:38] <gilberth> Well this must have been pen and pencil for the most part for him at that time. Try using a 704 these days.
[08:34:05] <gilberth> And said eval function was never thought to be compiled. It was a theoretical device.
[08:34:21] <lotuseater> so i will forever be
[08:35:00] <lotuseater> yes but that didn't confuse Stuart Russell to go on and do it anyway
[08:35:04] <gilberth> I once read that it was one of his students, who was bold enough actually hand-compiled said function.
[08:35:22] <lotuseater> the one i mentioned :)
[08:36:49] <gilberth> Well, it's obvious what it should do. I just stumpled upon that, as I try to use that definition as is. That is parse it into s-expr and having a compiler for that Lisp dialect to CL.
[08:37:40] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[08:40:14] *** Joins: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net)
[08:40:52] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 250 seconds)
[08:43:28] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 250 seconds)
[08:46:44] <hayley> Leslie Lamport once said that pseudocode tends to be wrong because there is no way to actually run it.
[08:48:07] <lotuseater> also often ill specified
[08:51:14] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.2)
[08:52:51] <lotuseater> and i don't see normal pseudocode being equivalent to a good description for an algorithm which can be implemented directly
[08:54:06] <hayley> Yes.
[08:59:03] <lotuseater> when you just have to decide certain things "oh do we now use a list or vector for this and why?" or such
[08:59:45] <lotuseater> or hash table vs alist when the associations number stays small
[09:03:17] <edgar-rft> I agree your opinions but have you ever tried to describe DSP algorithms without pseudocode?
[09:03:55] <lotuseater> I didn't say without pseudocode at all, but things should be precise.
[09:04:04] <hayley> https://www.youtube.com/watch?v=qOzpmyAbZPY
[09:04:05] -ixelp- KOB 2 - Tomarse & The Cocaine Conspiracy - YouTube
[09:04:10] <lotuseater> hm sry I'm tired, what is DSP?
[09:04:39] <hayley> Digital Signal Processing?
[09:04:48] <lotuseater> could be
[09:04:54] <edgar-rft> Digital Signal Processing a.k.a loops inside lopps in other loops nested in another loop
[09:05:03] <lotuseater> oha
[09:06:28] <lotuseater> hayley: The video is a little disturbing, but I like your taste. :)
[09:06:55] <lotuseater> okay nothing surprising disturbing I wouldn't have seen before on another imageboard
[09:08:11] <lotuseater> edgar-rft: so for this stuff a good symbolic description would also help much
[09:11:29] <lotuseater> I like the algorithm specification style Knuth does in TAoCP. with the steps, so one can open up a tagbody with those as the labels and use GO. surely, that as the first step to have it run correctly as specified
[09:11:42] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[09:14:55] *** Quits: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 252 seconds)
[09:15:19] <lotuseater> so I will GO now and try to sleep a bit
[09:17:57] <lotuseater> https://www.youtube.com/watch?v=Ozipf13jRr4
[09:17:58] -ixelp- John McCarthy (1927-2011): Artificial Intelligence (complete) - Thinking Allowed -Jeffrey Mishlove - YouTube
[09:21:57] <edgar-rft> lotuseater: now imagine several dozend arrays involved in several other dozends of nested loops, where you copy *this* region of *this* array into *that* region of *that* array, sometimes in forward, other times in reverse direction, other times with a custom function applied :-)
[09:22:53] <lotuseater> yes, so that's why this field profits from declarative descriptions
[09:23:06] <gilberth> Next bug. When applying a function arguments are evaluated twice. This can't be the intended behaviour.
[09:23:18] <edgar-rft> lotuseater: DSP is pretty much braindead code over and over again but unfortunately the details matter a lot
[09:23:33] <lotuseater> yes the details :)
[09:24:29] <lotuseater> edgar-rft: you mean like for sleeps and such?
[09:25:18] <lotuseater> and of course how long certain instructions take in real time
[09:26:08] <lotuseater> so you have even more reason to lay down this burden from yourself
[09:27:43] <lotuseater> but I'm interested talking about that in more depth maybe today via query if you like. I don't know much about it yet.
[09:28:30] <edgar-rft> gilberth: doppelt genäht hält besser (german saying, must look-up translation)
[09:28:51] <lotuseater> double nailed is stronger? :D
[09:29:09] <lotuseater> naja ok "genagelt" ...
[09:30:07] <edgar-rft> oh, surprisingly simple: double-stitched is better
[09:30:08] <lotuseater> edgar-rft: Last year I nearly have started training at a company who does SPS stuff.
[09:30:15] <lotuseater> ah nice
[09:31:01] <edgar-rft> SPS is luckily much easier, I already did that, too
[09:31:07] <lotuseater> cool
[09:32:16] <lotuseater> it could have fit my mind set and they mostly had problems every year finding a new trainee, the former one got kicked out, he didn't even checked how to do boolean operations
[09:32:35] <edgar-rft> yes, *easier* is the wrong word because DSP isn't really difficult, but SPS can be solved with "normal" logic as we are used from computer programming
[09:33:24] <lotuseater> i like to say "different" for things instead of better/worse or easier/harder when those don't fit well
[09:34:10] <lotuseater> so are there yet good solutions for doing DSP programming in a not so annoying and safe way?
[09:34:55] <lotuseater> maybe something like this SimuLink suite
[09:35:11] <edgar-rft> in this case it *is* indeed two totally different things, even if both have something to do with computer programming
[09:35:26] <lotuseater> haha ^^ okay
[09:35:55] <lotuseater> FPGA seems interesting to me.
[09:37:05] <lotuseater> so what kind of hardware does it take for DSP?
[09:37:27] <edgar-rft> the main problems with DSP are 1) speed, you usually have huge amounts of data and the program shold be finished with execution before I die, and 2) memory, the data are very often much larger than the available memory so you have to use a lot of buffer (array) trickery
[09:37:30] * gilberth calls the horny police to look after lotuseater.
[09:37:57] <lotuseater> gilberth: why? ._.
[09:38:13] <gilberth> You know why.
[09:38:18] <lotuseater> haha
[09:39:43] <lotuseater> when they visited me I'll send them to you
[09:40:58] <edgar-rft> I already did DSP with JED and S-Lang (https://www.jedsoft.org/jed/) and Emacs Lisp but both are horribly slow :-)
[09:41:10] <lotuseater> edgar-rft: okay so your suite has to be tricky and aware of technical things
[09:41:17] <lotuseater> JEDi
[09:41:19] <gilberth> Me is as innocent as one can get.
[09:41:52] <lotuseater> I'm innocent too.
[09:42:41] <lotuseater> edgar-rft: you're a bit longer in the business :)
[09:43:23] <edgar-rft> I used JED on the Amiga a lot because Emacs was a pain with only 2MB, but JED still looks great -> https://www.jedsoft.org/images/jed1.png :-)
[09:43:31] <gilberth> lotuseater: You dropped the "n" word. The other one.
[09:43:40] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[09:44:21] <lotuseater> so? Should just be funny. and I lacked another translation for "genäht" :D
[09:44:55] <gilberth> Anyhow, as jmc-lisp is dynamically scoped, the LABEL construct is not needed, you could have a recursive function like this: λ[[foo];foo[(A,B,C)]][quote[λ[[x];[atom[x]→NIL;T→((car[x])∙foo[cdr[x]])]]]] => ((A),(B),(C))
[09:45:10] <lotuseater> aaand it's not a secret I'm lonely
[09:45:18] <lotuseater> ah nice
[09:45:27] <lotuseater> clear to read :D
[09:46:14] <gilberth> That is no reason to display horny behaviour.
[09:46:44] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 250 seconds)
[09:47:06] <lotuseater> I didn't. *You* just interpreted it that way.
[09:48:13] <gilberth> lotuseater: That is ((LAMBDA (FOO) (FOO '(A B C))) (QUOTE (LAMBDA (X) (COND ((ATOM X) (QUOTE NIL)) ((QUOTE T) (CONS (CONS (CAR X) (QUOTE NIL)) (FOO (CDR X))))))))
[09:48:41] <lotuseater> ah okay so that looks like in the T. Hart paper about defmacro
[09:48:58] <lotuseater> it was hard to read by its scan quality
[09:49:30] <lotuseater> https://dspace.mit.edu/handle/1721.1/6111
[09:49:31] -ixelp- MACRO Definitions for LISP
[09:50:01] <gilberth> Point is: LABEL would only be needed, when the language would be lexically scoped and had proper closures. So I wonder if that was the intent, with a clue how to formulate that.
[09:52:06] <gilberth> FOO is defined as recursive function. In Scheme a ((lambda (foo) ...) (lambda (x) .. (foo ..) ..)) aka (let ((foo (lambda (x) ... (foo ..) ...))) ...) would not do, hence the letrec or LABEL, or LABELS in CL.
[09:52:10] <lotuseater> FLET vs LABELS was that the latter makes it possible, that the closure can call each other recursively, right?
[09:52:47] <lotuseater> ah right, no funcall in Scheme
[09:53:08] <gilberth> Yes, think of the new environment being active in the definition in LABELS, but not in FLET. Like with letrec versus let in Scheme.
[09:53:24] <gilberth> Scheme is a Lisp-1.
[09:53:59] <gilberth> So funcall is not needed. But don't name your arguments e.g. "list".
[09:55:00] <gilberth> My favorite: (defmethod port ((port port)) port)
[09:55:00] <lotuseater> after all FLET seems to be like a LET* for the closures
[09:55:49] <lotuseater> haha yes, in Scheme no distinction between function and value scope
[09:56:42] <gilberth> Nope. It's like LET.
[09:57:11] <lotuseater> no, the functions are aware of each other when you don't call things recursively
[09:57:45] <gilberth> Since when?
[09:57:56] <lotuseater> i tried (flet ((bar (x) (1+ x)) (baz (y) (* (bar y) (bar y)))) (baz 2)) => 16
[09:58:08] <lotuseater> what do i now?
[09:58:37] <hayley> https://www.youtube.com/watch?v=Ou4u4kOatck
[09:58:38] -ixelp- Summer '68 - YouTube
[09:59:06] <gilberth> Get a new Lisp.
[09:59:22] <aeth> not a big fan of newLISP
[09:59:24] <lotuseater> gilberth: you know why?
[09:59:35] <hayley> Been there, done that.
[09:59:38] <gilberth> aeth: lol
[09:59:44] <hayley> aeth: why not go on https://gitlab.com/Theemacsshibe/slacker-compiler
[09:59:45] -ixelp- theemacsshibe / slacker-compiler · GitLab
[09:59:55] <lotuseater> i defined some days ago a BAR function that fits in my running REPL
[10:00:19] <hayley> https://gitlab.com/Theemacsshibe/slacker-compiler/-/blob/master/Tests/jmc.scm
[10:00:20] -ixelp- Tests/jmc.scm · master · theemacsshibe / slacker-compiler · GitLab
[10:00:28] <hayley> Define Scheme macros in CL cause I'm too lazy
[10:01:37] <lotuseater> gilberth: good that we talked about that. it bothered me too, so was my fault as always
[10:02:06] <gilberth> hayley: The "else" looks strange. But very familiar, indeed.
[10:02:58] <hayley> Hm, the ELSE in EVAL-COMBINATION should not be in double-quotes. Oops.
[10:03:05] <gilberth> hayley: JMC's AND and OR short-circuit.
[10:03:42] <hayley> I also don't even use AND or NOT.
[10:03:58] *** Joins: retropikzel (~retropikz@2001:999:200:4ae7:b0ea:7db1:dd14:5ec6)
[10:04:12] <gilberth> hayley: null[x] = atom[x] ∧ eq[x; NIL], eq is only defined for atoms.
[10:05:00] *** Quits: aeth (~aeth@user/aeth) (Read error: Connection reset by peer)
[10:05:08] <hayley> In Slacker-Scheme NOT ≠ NULL? too. Though NULL? is defined much like CL NULL.
[10:05:19] *** Joins: aeth (~aeth@user/aeth)
[10:05:20] <hayley> (define-function-opcode 67 (boolean-wrap null 1)  1 :opcode-name null)
[10:06:34] *** Joins: abrantesasf (~abrantesa@2804:14d:b086:4b3c:2e56:dcff:fedb:62f)
[10:09:40] <gilberth> I defined not as: ¬x = [x → F; T → T]. Though JMC does not say what his not should do exactly. Should it be undefined for x being neither T or F? In AIM-8 COND is defined, so that everything not-T is false.
[10:12:15] <hayley> https://www.youtube.com/watch?v=DXs1xbMexeg
[10:12:15] -ixelp- Bitching (1996 Remaster) - YouTube
[10:12:50] <gilberth> And as cdr[NIL] is undefind, a COND with no matching clause, also is an error.
[10:18:55] <lotuseater> in Haskell taking the head of an empty list is also an error, but something like that could be made safer with Maybe, so "safeHead :: [a] -> Maybe a; safeHead [] = Nothing; safeHead (x:_) = Just x"
[10:19:43] *** Quits: abrantesasf (~abrantesa@2804:14d:b086:4b3c:2e56:dcff:fedb:62f) (Quit: Leaving)
[10:19:48] <hayley> https://www.youtube.com/watch?v=FwbNFRbqwfg
[10:19:48] -ixelp- Why Australia’s Crosswalk Buttons are the Best (ft. Billie Eilish) - YouTube
[10:20:53] *** Joins: abrantesasf (~abrantesa@2804:14d:b086:4b3c:2e56:dcff:fedb:62f)
[10:21:46] <moon-child> lotuseater: I though in haskell you always have to pattern match lists, so you can't unconditionally take the head of one?
[10:22:05] <moon-child> or--I guess you could trivially define a function that would destructure and error if a list were empty
[10:22:31] <hayley> head :: [a] -> a
[10:25:06] <lotuseater> yes this is the normal head function provided by the prelude
[10:25:59] <lotuseater> moon-child: wrapping into the maybe monad safes you from dealing with this possible error
[10:26:13] <kakuhen> speaking of empty list, one thing that messes with my head is how you can take CAR and CDR of the empty list, but empty list is not a cons cell
[10:26:20] *** Quits: abrantesasf (~abrantesa@2804:14d:b086:4b3c:2e56:dcff:fedb:62f) (Quit: Leaving)
[10:26:26] <lotuseater> or like when writing a safeDiv function which also can capture dividing by 0 safely
[10:27:21] <moon-child> kakuhen: why does that mess with your head?  It's just a matter of definition
[10:27:29] *** Joins: abrantesasf (~abrantesa@2804:14d:b086:4b3c:2e56:dcff:fedb:62f)
[10:27:54] <kakuhen> it's a counterintuitive definition for me
[10:28:01] <kakuhen> not that i disagree with it
[10:28:34] <moon-child> ah, so what messes with you is the motivation, not the mechanism.  Fair
[10:29:17] *** Quits: abrantesasf (~abrantesa@2804:14d:b086:4b3c:2e56:dcff:fedb:62f) (Client Quit)
[10:29:36] *** Joins: abrantesasf (~abrantesa@2804:14d:b086:4b3c:2e56:dcff:fedb:62f)
[10:29:54] <gilberth> I find (cdr nil) being nil quite intuitive. You remove the first element of an already empty list, still an empty list.
[10:30:04] <Alfr> kakuhen, list is the union of cons and null.
[10:30:25] <moon-child> (defparameter *nil* '#1=(#1# . #1#))
[10:30:46] <moon-child> ^ budget nil
[10:30:52] *** Quits: abrantesasf (~abrantesa@2804:14d:b086:4b3c:2e56:dcff:fedb:62f) (Client Quit)
[10:30:54] <kakuhen> gilberth: yeah i am fine with (cdr nil) being nil, though I dont like to think about "elements" of an empty list for obvious reasons
[10:30:59] <gilberth> It's like when you're at EOF, you keep being at EOF. Unless it's a tty or a tape. Sigh.
[10:31:15] *** Joins: abrantesasf (~abrantesa@2804:14d:b086:4b3c:2e56:dcff:fedb:62f)
[10:31:38] <Alfr> gilberth, hm ... what "the first element" are you referring to? Recall, the list is empty.
[10:32:05] <kakuhen> basically, the way i would implement CDR is why I am fine with (cdr nil) being nil; I never liked the idea of making it a type error
[10:32:39] <kakuhen> we have a linked list and there is a node with no contents and the pointer to next is NULL; taking this pointer gives us NULL, so there we go.
[10:32:48] <kakuhen> maybe my intuition is wrong but this is what i have in my head for now
[10:33:16] <moon-child> kakuhen: you need a special case for nil, though, because it is _not_ a cons cell; it's a symbol
[10:33:20] <gilberth> Alfr: Well, I was more thinking terms of "reading". Move to the list with the next [if any] element being the new first.
[10:34:28] <lotuseater> yeah so it could be seen, NIL is in this context a constant and then the pattern for (cdr NIL) => NIL
[10:34:43] <gilberth> moon-child: It could have been a cons cell, when things would have been defined differently.
[10:35:07] <moon-child> fair enough
[10:35:31] <gilberth> The strange part is, that it is a symbol! That I find odd at times.
[10:36:28] <Alfr> gilberth, so, an alternative description for car: Give me the list with at most one element chopped off its head; if there are elements, the first one must be removed.
[10:37:01] <moon-child> imo the only way destructuring (as in LOOP, not DESTRUCTURING-BIND) makes sense is if it's its own special object (a la scheme).  If it's a cons cell _or_ a symbol, behaviour is weird
[10:37:18] <gilberth> Alfr: Would do.
[10:37:55] <hayley> https://www.youtube.com/watch?v=TD1ODWNWXgY
[10:37:55] -ixelp- GARY NUMAN REMEMBER I WAS VAPOUR.1979 - YouTube
[10:38:04] <gilberth> Actually I like the baviour as it is in CL. It's very pragmatic. Also with regard to true-ness and false-ness.
[10:38:33] <moon-child> however if it's not to be a special object, I think a symbol makes more sense.  A symbol is an abstract data type which can be compared--that's it--so checking falsity by comparing to a cons cell would be superfluous
[10:38:35] <moon-child> gilberth: indeed
[10:39:06] <moon-child> (well, symbols do more in cl.  But the point stands)
[10:39:18] <gilberth> What bites me often is that (typep nil 'nil) is nil.
[10:40:01] <hayley> (typep (loop) 'nil)
[10:40:43] <lotuseater> funny
[10:41:00] *** Joins: dave0 (~davezero@069.d.003.ncl.iprimus.net.au)
[10:41:22] <gilberth> moon-child: Symbols are just atoms, tokens, if you which. Any interpretation of a symbol depends on the context. So, yes, that makes sense to use a symbol for what other languages call the null pointer.
[10:42:38] <gilberth> hayley: Would SICL optimize the LOOP there? For infinite speed up? What about (typep (loop) 't)?
[10:43:29] <moon-child> is nontermination not an observable side effect?
[10:44:15] <gilberth> Hmm, when you have enough time to observe that it'll never terminate.
[10:44:52] <gilberth> You can't be sure, it could terminate tomorrow, or the day after tomorrow. Who knows?
[10:45:11] <moon-child> heat death is inevitable.  All programs halt
[10:45:19] <moon-child> halting analysis has been DEBUNKED
[10:46:15] <gilberth> Yes, there is only is a finite amount of energy in the universe. And Turing machines also could not exist.
[10:46:47] <gilberth> Does that make irrational numbers being rational in the long run?
[10:47:49] <moon-child> no; only that the energy requirements needed to measure irrational quantities to infinite precision are not available
[10:48:33] <gilberth> How mean of the universe.
[10:49:04] <moon-child> indeed
[10:49:35] <moon-child> it also gave us an excrutiatingly slow speed of light
[10:50:33] <lotuseater> and likes to hide most of its secrets
[10:50:33] <dave0> maw
[10:50:34] <gilberth> And I firmly believe it uses lazy evaluation and level-of-detail rendering.
[10:50:51] <lotuseater> dave0: wam
[10:51:53] <gilberth> The Schrödinger cat is proof: Whether it's dead or alive is lazily evaluated.
[10:52:37] <dave0> hi lotuseater 
[10:53:16] <lotuseater> how's winter time on the southern hemisphere? our summer is rainy
[10:58:33] <dave0> it's been real nice.. only 1 week till spring
[11:05:14] <hayley> gilberth: No, this is not C.
[11:06:22] <dave0> https://www.bbc.co.uk/news/health-58270098
[11:06:22] -ixelp- Covid: Whatâs the best way to top up our immunity? - BBC News
[11:06:28] *** Joins: shka (~herr@109.231.62.239)
[11:06:31] <dave0> an interesting story on covid immunity
[11:08:50] <kakuhen> gilberth: nil being is a symbol gives me random catches, too
[11:08:53] <hayley> dave0: https://www.youtube.com/watch?v=HR7NivKqfzo
[11:08:53] -ixelp- Why Do Trucks Keep Smashing Into This Bridge? | Montague St Bridge - YouTube
[11:09:08] <kakuhen> so '(x . y) is cons but '() is just a symbol
[11:09:19] <kakuhen> i have no idea how lisp actually works 
[11:09:30] <kakuhen> err rather, common lisp
[11:09:42] <kakuhen> but the same applies for other lisps i have used (emacs lisp and clojure)
[11:11:32] <hayley> '() is a list of QUOTE and the empty list.
[11:12:36] <lotuseater> kakuhen: so that's why you're here :)
[11:13:03] <kakuhen> (typep (list) 'symbol) ;=> T
[11:13:08] <kakuhen> (typep (list nil) 'symbol) ;=> nil
[11:13:16] <kakuhen> i'm having too much fun with this
[11:13:53] <lotuseater> do you already know LIST* ?
[11:13:55] <gilberth> Well, (typep (list) 'list) makes sense.
[11:17:00] <lotuseater> or try (format nil "~a" nil)
[11:18:24] <gilberth> Of what relevance would that be?
[11:19:17] <lotuseater> oh we talk about relevance now?
[11:20:02] *** Quits: abrantesasf (~abrantesa@2804:14d:b086:4b3c:2e56:dcff:fedb:62f) (Quit: Leaving)
[11:20:08] <gilberth> What should (format nil "~a" nil) reveal, apart of it being princ'ed as NIL?
[11:20:39] <lotuseater> right, but the intention about that could be different first
[11:21:17] <lotuseater> so indeed the relevance of seeing by trying to not run into that by accident with different intention
[11:21:42] <lotuseater> okay of course when i just type NIL in the REPL it's be given back that way too
[11:24:50] <gilberth> What did you expect?
[11:25:03] <lotuseater> wasn't about me
[11:26:43] <kakuhen> what's the canonical cl library people use for hashes
[11:26:52] <kakuhen> or should i just make my own md5 implementation in cl
[11:27:01] <gilberth> ironclad
[11:27:13] <kakuhen> im already writing something that exists out there, so i guess it depends how much "not invented here" syndrome i want
[11:27:43] <lotuseater> and you can look up standard symbol SXHASH
[11:29:00] <gilberth> I assume kakuhen meant messages hashes. Ironclad has a host of standard hashes.
[11:29:08] <kakuhen> yeah, like md5 hash
[11:29:21] <kakuhen> I learned that FLAC files contain md5 checksum of the decoded audio data as a form of data integrity
[11:29:26] <kakuhen> quite a questionable one imo
[11:29:41] <kakuhen> all the FLACs I have probably bitrotted from being stored in an SD card that I didnt touch in 3-4 years
[11:29:54] <kakuhen> the md5 sum should give me a clue as to whether that really happened
[11:29:59] <kakuhen> but what if the bit rot happened in this region of the file heh
[11:30:24] <gilberth> A tree-hash would have been better, yes.
[11:30:31] <kakuhen> (for this reason, sane filesystems that highly depend on metadata make lots of duplicates of metadata)
[11:30:46] <kakuhen> ZFS sometimes makes triple duplicates of metadata; i forget the specific cases though
[11:30:49] <gilberth> Gnutella only got usable for large files by using on of those.
[11:33:21] <gilberth> kakuhen: Anyhow, look into ironclad. The list of supported hashes is impressive.
[11:33:27] <kakuhen> sure
[11:33:50] <kakuhen> that reminds me i was working on a ripemd-160 implementation in emacs lisp, but i stopped midway
[11:34:01] <kakuhen> this was back in june before i ever bothered learning how to use vectors in lisp
[11:34:17] <kakuhen> and i wondered how people could possibly translate pointers and stuff to lisp heh
[11:35:31] <gilberth> Brain washed by pointer arithmetic?
[11:38:19] <gilberth> kakuhen: Thanks for sharing the link, I shouldn't maneuver to.
[11:45:27] <hayley> Git uses SHA1, but only for "data integrity", which is fine. As you assume that any corruption is accidental and thus random.
[11:48:30] *** Joins: razzy (razzy@user/razzy)
[11:52:57] *** Quits: razzy (razzy@user/razzy) (Ping timeout: 245 seconds)
[11:53:59] <dave0> is a cryptographic hash the right tool for error detection?
[11:54:16] <moon-child> yeah, I was about to say
[11:54:27] <moon-child> it seems kinda like sour grapes to say that at this point, not having used e.g. crc all along
[12:11:02] *** Joins: razzy (razzy@user/razzy)
[12:14:39] <pjb> kakuhen: it's simple first '(x . y) is read. This produces a data structure https://termbin.com/e85l ; then this data structure is evaluated.  Since the first cons cell contains the symbol QUOTE, it just returns the car of the second cons cell: (x . y)
[12:16:53] <pjb> kakuhen: On the other hand, when '() is read, the reader macro #\' will do as above, and return a list containing CL:QUOTE as first element.  But the reader macro #\( will notice that there is no element in the list, and read immediately #\), and return the empty list, which is denoted by the symbol CL:NIL https://termbin.com/d3d0
[12:17:07] <pjb> kakuhen: then it's evaluated by the same rule for quote, and it returns the symbol NIL.
[12:17:41] <pjb> kakuhen: note that the printer may still print () or NIL or nil or CL:NIL or cl:nil depending on the setting of the varions *print-…* variables.
[12:18:22] <pjb> kakuhen: also, all what I said above depends on the reader macros, ie. on the *readtable*, which can be changed at will by the user.  I described the standard reader macros for #\' and #\( .
[12:18:37] <kakuhen> I see
[12:18:53] <kakuhen> Thanks for the explanation regarding quote
[12:19:21] <kakuhen> I was assuming the reader macros would stay as they normally are, but the readtable is indeed easy to overlook
[12:20:41] <shka> the downside of using ironclad
[12:20:48] <shka> is that it is rather large beast
[12:21:05] <shka> so my program, that happens to use postmodern
[12:21:14] <shka> which happens to need one hash from ironclad
[12:21:35] <shka> won't fit in 128mb of heap :P
[12:21:46] <kakuhen> oh, good point
[12:22:11] <kakuhen> I was thinking "the alternatives are probably larger, openssl digest functions would need you to link against openssl"
[12:22:33] <kakuhen> But the situation is a bit more nuanced regarding ironclad
[12:23:04] <kakuhen> oh and to be clear, my openssl example was mostly me thinking in other languages, not common lisp.
[12:36:22] <gilberth> Ironclad adds 4.1MB to my heap. Huge, but not that huge.
[12:54:12] *** Joins: Qwnavery (~Qwnavery@user/qwnavery)
[12:54:22] *** Quits: razzy (razzy@user/razzy) (Ping timeout: 250 seconds)
[12:56:10] *** Quits: retropikzel (~retropikz@2001:999:200:4ae7:b0ea:7db1:dd14:5ec6) (Ping timeout: 258 seconds)
[12:58:04] <hayley> https://www.reddit.com/r/programming/comments/p93vw3/getting_gplv2_compliance_from_a_chinese_company/
[12:58:05] -ixelp- Getting GPLv2 compliance from a Chinese company- in person : programming
[13:02:24] <kakuhen> thank you to whoever put LDB on the common lisp spec; without this function idk how i'd be dealing with flac right now 
[13:02:31] <kakuhen> now i have to learn how frames work orz
[13:03:03] <contrapunctus> LDB?
[13:03:17] <hayley> LoaD Byte?
[13:03:39] <contrapunctus> Huh.
[13:03:45] <kakuhen> yeah it's a really nice function
[13:03:59] <kakuhen> it even has a setter function which is super useful for e.g. pulling 24 bits out of a stream
[13:04:00] <gilberth> It's also SETF-able.
[13:04:02] <hayley> TLDR: length and offset for bits and integer go in, sub-integer comes out
[13:04:21] <shka> ldb IIRC has been taken from some ancient assembly language
[13:04:30] <hayley> PDP-10?
[13:04:42] * hayley contemplates using software transactional memory for the next Netfarm server.
[13:04:48] <shka> dunno details
[13:04:52] <kakuhen> nibbles has nice exponents of 2 (16, 32, 64), but flac has a lot of metadata that does not fit neatly into this
[13:05:01] * gilberth misses a signed version of LDB.
[13:05:05] <kakuhen> well it kinda does, but then you want to access like the first 3 bits of some word
[13:05:09] <hayley> > Historically, the name ``ldb'' comes from a DEC PDP-10 assembly language instruction meaning ``load byte.'' 
[13:05:20] <shka> lisp bitwise functions are actually really useful
[13:05:32] <shka> ldb, dpb, ldb-test
[13:05:43] <hayley> Yeah, (SETF LDB) was great while writing the SIMD-within-a-register version of the SICL linear probing hash table.
[13:05:57] <shka> there is even popcount
[13:06:04] <shka> called logcount
[13:06:46] <hayley> Though I am not exactly sure as to what I can't do with mere lock sharding. Also, note to self, add decentralise2 mixins that disable locking and version checking when you really just need a MODCHASH.
[13:08:49] <shka> i actually wonder why other languages don't have ldb
[13:09:04] <hayley> Well, a SQL database needs transactions to be safe. And I am sick of hurting my head on the much harder locking + state machine of object verification.
[13:09:16] <shka> it is not like this influences design of a language, you can bolt it on to an existing language no problem
[13:09:25] <gilberth> I wonder why other languages confuse REM with MOD or vice versa and don't have both.
[13:10:21] <gilberth> shka: And you could pass a byte specifier around.
[13:10:39] <shka> yeah
[13:11:32] <hayley> The other thing is, to be safe from livelock, would I just use a fallback world lock?
[13:13:06] <gilberth> Like in (make-pixel-format :red-byte (byte 8 16) :blue-byte (byte 8 8) :green-byte (byte 8 0)), which I borrowed from Closure and have it in Free-CLIM.
[13:14:22] <gilberth> This was initially used to cope with X11 pixels.
[13:19:14] <hayley> https://youtu.be/TwIvUbOhcKE?t=35 Pictured: hayley testing any concurrent code for the first time
[13:19:15] -ixelp- How NOT to Make an Electric Guitar (The Hazards of Electricity) - YouTube
[13:21:38] <hayley> Maybe I should use damned TLA+ for my state machine. God dammit.
[13:22:54] <contrapunctus> hayley: hilarious video
[13:23:40] <hayley> Also c.f. https://www.youtube.com/watch?v=Fi2jBE2i7Aw
[13:23:40] -ixelp- The Dangers of Fearing Music - YouTube
[13:26:39] *** Joins: retropikzel (~retropikz@83-245-241-179-nat-p.elisa-mobile.fi)
[13:31:44] * contrapunctus has been working on the Drei manual for two days.
[13:32:28] <contrapunctus> My first attempt at migrating a project's documentation to use the Diátaxis Framework.
[13:34:13] <contrapunctus> Already it is satisfying to look at - the Explanation (which was earlier scattered across the Reference) can easily be read like a book to gain a general idea of the how and why of Drei.
[13:36:09] <contrapunctus> * My first attempt (...) to come this close to completion.
[13:41:01] <hayley> Conceptually, I want to have a "GC" process which removes objects that we only used in some proof, but still retains the observation that they're valid. Also, it should function like a LRU cache and only remove infrequently used objects. Though I also would prefer to keep a read as a read without writing LRU times.
[13:43:38] <hayley> Idea: rather just store the last time we removed some object, and refuse to remove an object if it was loaded again after being removed not too long ago.
[13:45:12] *** Joins: razzy (razzy@user/razzy)
[13:52:08] <hayley> What is this then, least recently evicted?
[13:52:57] *** Quits: razzy (razzy@user/razzy) (Ping timeout: 245 seconds)
[13:59:15] <kakuhen> >This bit must remain reserved for 0 in order for a FLAC frame's initial 15 bits to be distinguishable from the start of an MPEG audio frame
[13:59:17] <kakuhen> ok this is epic
[13:59:41] <kakuhen> I really wish Apple didn't have such an obsession with mp4 container; that way I wouldn't pass on the idea of alac decoder
[14:00:34] <kakuhen> it is possible to use core audio format as a container for alac if i recall correctly, but it's rarely done in practice
[14:01:14] <kakuhen> instead they use it when they feel too hipster to use their own (arguably hipster) variant of WAV.
[14:02:29] *** Joins: razzy (razzy@user/razzy)
[14:03:34] <hayley> Now I wonder if just nuking everything will lead to an acceptable cache eviction "policy", given that the transitive closure of stuff reachable from stuff tends to be larger than the latter stuff. Probably not.
[14:05:38] <hayley> Oh, what would the SQL query look for that, too? Probably something beautiful.
[14:09:59] <hayley> Perhaps UPDATE objects SET text = NULL, use = 'evicted', last_evicted = now WHERE (SELECT count(*) FROM dependencies WHERE dependencies.dependency = objects.hash) = 0 AND use = 'cached' AND last_evicted < something
[14:11:21] *** Quits: razzy (razzy@user/razzy) (Ping timeout: 248 seconds)
[14:42:57] *** Joins: makomo (~makomo@user/makomo)
[14:45:04] *** Quits: Qwnavery (~Qwnavery@user/qwnavery) (Quit: WeeChat 3.2)
[14:45:37] *** Quits: retropikzel (~retropikz@83-245-241-179-nat-p.elisa-mobile.fi) (Read error: Connection reset by peer)
[14:45:54] *** Joins: retropikzel (~retropikz@83-245-241-179-nat-p.elisa-mobile.fi)
[14:49:35] <hayley> https://www.youtube.com/watch?v=mdZo_keUoEs
[14:49:36] -ixelp- Just Try and Make Your Own Coil-Gun (Accelerator) - YouTube
[14:53:27] <kakuhen> zzz
[14:53:33] *** Quits: kakuhen (~kakuhen@user/kakuhen) (Quit: Leaving...)
[15:08:13] <hayley> https://www.youtube.com/watch?v=HC2Lwn5Ybhg
[15:08:14] -ixelp- Emerson, Lake & Palmer - Take A Pebble (1970) - YouTube
[15:28:22] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[15:32:45] *** Joins: random-nick (~random-ni@87.116.179.117)
[16:25:36] *** Joins: selwyn (~selwyn@user/selwyn)
[16:28:57] <shka> and i wish they would use dylan instead of obj c 
[16:28:59] <shka> but here we are
[16:29:46] <hayley> https://www.youtube.com/watch?v=tw_-uQRfm8U
[16:29:47] -ixelp- Oh No - YouTube
[16:31:50] <dave0> nite all
[16:31:58] *** Quits: dave0 (~davezero@069.d.003.ncl.iprimus.net.au) (Quit: dave's not here)
[16:48:05] *** Quits: lisp123 (~lisp123@5.30.23.247) (Quit: Leaving...)
[17:14:07] *** Quits: retropikzel (~retropikz@83-245-241-179-nat-p.elisa-mobile.fi) (Quit: Leaving)
[17:36:14] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[17:37:39] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[18:03:05] *** Joins: nihaal (~nihaal@117.96.193.218)
[18:20:22] *** Alfr is now known as Guest9643
[18:20:26] *** Joins: Alfr (~Alfr@user/alfr)
[18:22:43] *** Quits: Guest9643 (~Alfr@user/alfr) (Ping timeout: 252 seconds)
[18:41:12] *** Joins: selwyn (~selwyn@user/selwyn)
[18:42:53] *** Joins: lisp123 (~lisp123@45.86.202.65)
[18:43:00] <lisp123> Enjoy: https://plaster.tymoon.eu/view/2605#2605
[18:43:29] <lisp123> Will it run, will it not :O
[18:44:10] *** Quits: Posterdati (~posterdat@host-82-49-175-12.retail.telecomitalia.it) (Ping timeout: 240 seconds)
[18:50:39] <lisp123> I get to 8992 before it *seems* like SBCL crashes out
[18:57:55] *** Joins: Posterdati (~posterdat@host-82-49-175-12.retail.telecomitalia.it)
[19:10:48] *** Joins: razzy (razzy@user/razzy)
[19:13:32] *** Quits: nihaal (~nihaal@117.96.193.218) (Ping timeout: 250 seconds)
[19:45:13] *** Quits: lisp123 (~lisp123@45.86.202.65) (Ping timeout: 248 seconds)
[19:46:28] *** Joins: ln43 (~ln43@user/ln43)
[19:46:40] <ln43> trying to download this book: Loving Common Lisp, or the Savvy Programmer’s Secret Weapon, because i liked Common LISP modules (by Mark Watson) ...
[19:47:11] <ln43> really good book and was printed in 91 with innovative concepts for that time
[19:47:33] <ln43> so really a good job ...
[20:50:29] *** Quits: contrapunctus (a75f5b1571@2a00:c70:1:178:170:40:189:1) (Read error: Connection reset by peer)
[21:06:38] *** Joins: nihaal (~nihaal@117.96.193.218)
[21:13:41] *** Quits: nihaal (~nihaal@117.96.193.218) (Quit: nihaal)
[21:19:47] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[21:35:38] *** Joins: selwyn (~selwyn@user/selwyn)
[21:36:36] *** Quits: ln43 (~ln43@user/ln43) (Quit: Connection closed)
[22:00:19] *** Joins: v3ga (~cyberocto@c-73-39-172-34.hsd1.md.comcast.net)
[22:01:07] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Ping timeout: 244 seconds)
[22:03:43] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[22:04:25] *** Quits: v3ga (~cyberocto@c-73-39-172-34.hsd1.md.comcast.net) (Ping timeout: 248 seconds)
[22:45:28] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Quit: bbl)
[22:54:16] * lotuseater is back in the New York Groove
[23:23:32] *** Joins: abrantesasf (~abrantesa@2804:14d:b086:4b3c:2e56:dcff:fedb:62f)
[23:33:11] <lotuseater> I found an interesting podcast interview with Rainer Joswig back from 2011 today.
[23:37:56] <selwyn> which podcast
[23:38:50] *** Quits: Alfr (~Alfr@user/alfr) (Killed (sodium.libera.chat (Nickname regained by services)))
[23:38:54] *** Joins: Alfr (~Alfr@user/alfr)
[23:41:20] <lotuseater> selwyn: one in a series by Heise, he was asked questions about Lisp by two other who also know this and that
[23:41:31] <lotuseater> but it's in German, about 1h
[23:42:26] <lotuseater> https://www.heise.de/developer/artikel/Episode-28-Bedeutung-Einsatzszenarien-und-Perspektive-von-Lisp-1194789.html
[23:42:27] -ixelp- Episode 28: Bedeutung, Einsatzszenarien und Perspektive von Lisp | heise Developer
[23:46:08] <gilberth> Good morning #lispcafe!
[23:46:16] <lotuseater> hi gilbert
[23:50:17] <selwyn> hi
[23:51:46] *** Quits: Alfr (~Alfr@user/alfr) (Read error: Connection reset by peer)
[23:53:00] * gilberth waits for coffee having any effect.
[23:53:23] *** Joins: Alfr (~Alfr@user/alfr)
[23:56:00] <gilberth> I wonder how much of DPS is still present in macOS as at times you find things like DPSNextEvent or such in a backtrace. A real pity that DPS always was proprietary, it would have made for a better X.
[23:57:06] <gilberth> Also a pity, that X11 never was updated for sth similar.
