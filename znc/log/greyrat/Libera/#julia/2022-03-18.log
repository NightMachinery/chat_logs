[00:04:39] *** Quits: jdarnold (~jdarnold@static-98-118-34-170.bstnma.fios.verizon.net) (Remote host closed the connection)
[00:08:53] *** Joins: anaveragehuman (~anaverage@user/anaveragehuman)
[00:21:55] *** Quits: anaveragehuman (~anaverage@user/anaveragehuman) (Ping timeout: 240 seconds)
[07:43:01] *** Quits: deadmarshal (deadmarsha@deadmarshal.nastycode.com) (Ping timeout: 250 seconds)
[08:04:48] *** Joins: Batzy (~quassel@user/batzy)
[08:05:02] <Batzy> Why is the julia reply for UInt128(2^65) returning 0?
[08:05:05] <Batzy> repl*
[08:32:16] *** Joins: deadmarshal (deadmarsha@deadmarshal.nastycode.com)
[08:32:28] <adigitoleo> looks like the repl is only printing out numbers up to typemax(Int)
[08:32:45] <adigitoleo> 2^63-1
[08:35:45] <adigitoleo> BigInt(typemax(UInt128)) works though, maybe this is a bug with show(::UInt128)
[08:35:54] <adigitoleo> or whatever the repl uses
[08:40:47] <adigitoleo> hmm, a bit worrying that e.g. UInt128(2^65) == UInt128(2^66)
[08:42:08] <adigitoleo> Oh wait, you'll need to use hex input I think
[08:42:43] <Batzy> hex input really
[08:42:48] <Batzy> ok i guess i can do that
[08:43:50] <adigitoleo> yeah because I guess the ^ operator is giving zero, then zero is getting put into UInt128 constructor
[08:44:05] <Batzy> i guess i have to externally
[08:44:12] <Batzy> figure out what my number is in hex
[08:44:15] <Batzy> and then type it into julia
[08:44:15] <Batzy> hm
[08:44:26] <Batzy> anyways, i really am liking the language
[08:44:34] <Batzy> im learning it, but my advisor wants to only use c++
[08:45:18] <adigitoleo> can't really comment, don't know C++ but probably both good options
[08:45:24] *** Quits: deadmarshal (deadmarsha@deadmarshal.nastycode.com) (Ping timeout: 252 seconds)
[08:46:45] <adigitoleo> nobody is really using julia from my supervisors/colleagues yet either tbh
[08:47:57] <adigitoleo> but if you're writing something from scratch then maybe? For me it's replacing Python/Matlab
[08:48:44] <Batzy> is julia pretty close speed wise
[08:48:45] <Batzy> ?
[08:48:57] <Batzy> i dont know how to get a global value = to 2^64 man
[08:51:20] <adigitoleo> UInt128(2^32) * UInt128(2^32) ?
[08:52:31] <Batzy> yeah i thought that too
[08:52:35] <Batzy> let me try it
[08:53:33] <Batzy> yeah that works
[08:53:51] <adigitoleo> might be a waay to do it with parse() as well, not sure
[08:54:25] <adigitoleo> but that seems the simplest
[08:55:52] <adigitoleo> haven't done a lot of speed comparisons for julia vs matlab, but it can be noticably faster than python for even random stuff
[08:57:31] <Batzy> well im currently doing the project in cython
[08:59:06] <Batzy> no one will tell me if the performance will be about similar
[09:02:01] <adigitoleo> haven't used it, am only starting to play with numba now. I'm probably not the best to ask about performance, though people have said that it's not always trivial to get julia to go super fast. There's usually quite a bit of talk on the forums though (Zulip etc.) so you could try there? I think with some care it should be able to beat Cython
[09:04:13] <adigitoleo> there's q few benchmarks out there as well, this one's a bit dated though https://gist.github.com/jfpuget/6f8c82b729677b0173d0
[09:05:37] <adigitoleo> also https://www.stochasticlifestyle.com/why-numba-and-cython-are-not-substitutes-for-julia/
[09:11:25] <adigitoleo> Batzy: btw I found a nicer way : UInt128(2)^64
[09:11:35] <Batzy> LOL yeah
[09:11:59] <adigitoleo> one of the operands just needs to be an UInt128 so the promotion happens
[09:12:10] <Batzy> yeah
[09:12:20] <Batzy> im slowly trying to rewrite this in julia
[09:12:57] *** Joins: deadmarshal (deadmarsha@deadmarshal.nastycode.com)
[09:35:55] *** Joins: Sofia (~sofia@user/sofia)
[09:36:26] <Sofia> Hello world.
[09:38:03] <adigitoleo> welcome
[09:55:20] <energizer> Batzy: julia> big"2"^64, big(2)^64
[09:56:13] <energizer> or UInt128 depending on what you want
[09:57:25] <mikko> yeah julia doesn't automatically expand types as results get big or small since that would require doing extra work on pretty much all arithmetic, use BigInt if you really need arbitrarily large numbers (as in python)
[09:58:55] <energizer> personally i think 2^65 should throw or something
[09:59:27] <energizer> not just return 0
[09:59:42] <adigitoleo> yeah at least a warning maybe
[10:04:30] <Batzy> does anyone know what error: attempt to access 3-element Vector{Int64} at index [0]
[10:04:34] <Batzy> means
[10:04:40] <adigitoleo> use 1
[10:04:42] <mikko> julia is 1-indexed
[10:04:44] <Batzy> why 1
[10:04:46] <Batzy> WHAT
[10:06:48] <mikko> apparently there's a package that enables you to use checked integer arithmetic: https://github.com/JeffreySarnoff/SaferIntegers.jl
[10:07:14] <mikko> but i do believe that will have an effect on performance even when nothing is overflowing
[10:13:33] <energizer> the way i think about it is that 0 is good for offsets, 1 is good for sizes. Fortran, R, Matlab, Mathematica use 1. 
[10:14:29] <energizer> but you can also index with `begin` and `end`
[10:14:35] <ninjin> Both 1 and 0 sucks for specific usecases.
[10:15:10] <mikko> personally i don't think 0 has any merit when you're not using raw pointers, besides "that's what i've always done" which is not a good argument
[10:15:41] <ninjin> Fortunately you can have it n-indexed with macros if you really want to. But my advice is to try to learn it before going to great lengths to avoid it.
[10:15:55] <energizer> 1st century is the one that starts in 0 AD
[10:16:26] <ninjin> Some index juggling can get a bit hairy at least in my experience mikko, but you can usually get around it with say mod1, etc.
[10:17:03] <energizer> i try to avoid indexing when i can
[10:17:20] <ninjin> Same, but sometimes you have to.
[10:17:30] <mikko> i guess that's fair point, you really need to be aware of mod1 if porting code that uses modulo on indices from a 0-indexed language
[10:18:07] <energizer> idk do you sometimes have to?
[10:18:48] <ninjin> At least I do. Just a few days ago I wanted to design an algorithm that had a very peculiar periodicity.
[10:19:22] <ninjin> Not sure how I can implement that optimally without juggling a few indices.
[10:19:25] <adigitoleo> haha I just found https://github.com/giordano/RandomBasedArrays.jl
[10:20:13] <energizer> got an example in mind?
[10:20:57] <ninjin> Sure, minimal length codes for a given alphabet to enumerate n targets.
[10:21:27] <ninjin> Think Huffman, but without frequencies.
[10:25:04] <ninjin> There is a closed form solution for it, which is far better than the mess I have seen elsewhere to achieve the same thing â€“ often poorly. *But*, it required me to do some index maths.
[10:25:59] * ninjin has to rush off to handle office hours
[10:26:54] <energizer> some languages usually do index free, i think futhark is one
[10:29:19] <mikko> how would you do binary search without indexing?
[10:31:45] <energizer> im not sure what counts since a search problem is defined to return an index
[10:38:44] <energizer> usually (always?) these things can be expressed by building up a tree and then unbuilding it into a result
[10:39:52] <Batzy> how do i make an array 0 indexed
[10:39:55] <Batzy> this is too bad
[10:40:34] <energizer> you can use OffsetArrays.jl but why do you need it
[10:41:04] <Batzy> I'm having some issues with initialzing something without values with an OffsetVector
[10:41:08] <Batzy> and because it groups up my for loops
[10:41:34] <energizer> you can use `begin` instead of 0
[10:41:39] <energizer> well instead of 1
[10:41:44] <energizer> but anyway it's the first one
[10:41:55] <energizer> and you can do xs[begin+1] etc
[10:42:16] <adigitoleo> hard to tell what the issue is, maybe post a snippet? You can use e.g. https://x0.at/
[10:42:50] <Batzy> i dont know
[10:43:36] <energizer> anyway yeah it took me a week or something to get used to it the first time
[10:44:43] <Batzy> yep.
[10:47:08] <Batzy> holy crap this isnt working
[10:49:07] <Batzy> energizer: you said to start my loops from 0 index but then add begin in all my indexes?
[10:49:19] <energizer> no
[10:50:04] <energizer> do loops like python, not C
[10:50:16] <Batzy> what
[10:50:28] <energizer> `for x in xs`, not `for i in 1:length(xs)`
[10:51:10] <Batzy> `for x in 7` works?
[10:51:20] <energizer> that doesnt do what you think
[10:51:34] <Batzy> well im jsut looping through 7 times or whatever
[10:51:40] <Batzy> so i need for i in i:7
[10:51:44] <Batzy> so i need for i in 1:7
[10:52:00] <energizer> `for x in 7` is like `for x in [7]` unfortunately
[10:52:09] <Batzy> then why are you telling me to do it
[10:52:58] <energizer> i thought you were looping through data
[10:53:08] <Batzy> no
[10:53:42] <energizer> in some languages it's common to do stuff like `for i in 1:length(xs): f(xs[i])` 
[10:53:54] <energizer> you see that in newbie python code from people who know C
[10:53:58] <Batzy> the issue is i have a double nested loop
[10:54:06] <Batzy> and im access index i+j
[10:54:11] <Batzy> accessing*
[10:54:20] <Batzy> there are other more complicated things too
[10:54:28] <Batzy> so i really would like to just pretend it's all 0-indexed
[10:55:05] <mikko> begin+i+j in julia is the equivalent of i+j in zero indexedd
[10:56:34] <Batzy> i did that and it didnt work
[10:56:36] <mikko> there might be a better way to accomplish what you're trying to do with built-in methods but it's hard to tell without seeing the code
[10:56:44] <Batzy> mikko: i and j both start at 0 right
[10:57:18] <mikko> i don't know, i and j are defined by you :p
[10:57:38] <mikko> but if they do, begin+0+0 is still the index of first element
[10:57:45] <Batzy> i see
[10:57:51] <Batzy> i wonder why this wont work then hm
[10:59:35] <Batzy> ok maybe it's working but i have to fix other stuff
[10:59:36] <Batzy> ty
[11:02:18] <Sofia> 1-indexed :O
[11:33:13] <Batzy> does julia have a matrix modular inverse?
[11:39:20] <adigitoleo> Batzy: maybe `invmod`?
[11:39:58] <adigitoleo> ah nevermind it isn't for matrices
[11:48:21] <Batzy> yeah
[11:48:22] <Batzy> :|
[11:51:49] <Batzy> I guess I could write my own
[13:02:55] *** Joins: MajorBiscuit (~MajorBisc@wlan-145-94-218-48.wlan.tudelft.nl)
[16:53:00] *** Joins: cocomo (~cocomo@111.119.178.184)
[17:42:29] *** Quits: lunik1 (~lunik1@37.205.14.203) (Quit: Ping timeout (120 seconds))
[17:42:42] *** Joins: lunik1 (~lunik1@37.205.14.203)
[17:44:43] *** Quits: ermo (~ermo@user/ermo) (Quit: ZNC 1.8.2 - https://znc.in)
[17:46:40] *** Joins: ermo (~ermo@user/ermo)
[17:55:33] *** Quits: kiwiroy (sid374179@2a03:5180:f:2::5:b5a3) (Ping timeout: 250 seconds)
[17:56:35] *** Joins: kiwiroy (sid374179@id-374179.lymington.irccloud.com)
[19:13:15] *** Quits: Sofia (~sofia@user/sofia) (Ping timeout: 240 seconds)
[19:26:09] *** Quits: kmh (~kmh@2a00:6020:5004:6800:d0dc:8c7:d95c:7c13) (Quit: Leaving)
[19:28:10] *** Joins: Sofia (~sofia@user/sofia)
[19:43:15] *** Quits: Sofia (~sofia@user/sofia) (Ping timeout: 240 seconds)
[19:56:18] *** Joins: Sofia (~sofia@user/sofia)
[20:02:14] *** Joins: kmh (~kmh@2a00:6020:5004:6800:4be6:856d:7108:d738)
[20:14:12] *** Quits: cocomo (~cocomo@111.119.178.184) (Ping timeout: 240 seconds)
[20:16:05] *** Joins: cocomo (~cocomo@111.119.188.27)
[20:18:57] *** Quits: MajorBiscuit (~MajorBisc@wlan-145-94-218-48.wlan.tudelft.nl) (Ping timeout: 240 seconds)
[22:21:38] *** Quits: furrymcgee (~devuan@cgn-213-196-210-225.nc.de) (Quit: leaving)
