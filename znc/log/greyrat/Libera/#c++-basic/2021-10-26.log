[00:00:05] <teut> ya that is the only problem which I face
[00:00:27] <teut> like here the clean_name  , abstracts my cleaning lofgic
[00:00:29] <teut> logic*
[00:00:31] <cbreak> that class is fully private. It's fairly useless.
[00:01:16] <teut> consider the  firstName , lastName as public
[00:01:44] <cbreak> that's not well encapsulated
[00:01:58] <teut> but the clean_name is
[00:02:15] <teut> if  I keep clean name private
[00:02:25] <cbreak> no
[00:02:33] <teut> the user of the class only will be interested in the first and last name
[00:03:12] <teut> ya , to run the cleaning logic again and again , I need getter and setter
[00:03:54] <cbreak> I think you need something more complex to see what encapsulation does
[00:04:14] <cbreak> try writing a resizable array. some type that acts like an array, but if it is not big enough, it will grow
[00:04:22] <teut> ya and problem is most of of code is in python
[00:04:24] <cbreak> (you don't actually have to write it)
[00:04:32] <cbreak> but think about what you would do for it
[00:04:35] <teut> c++, I have no oop code
[00:04:58] <teut> you mean like small string optimization?
[00:05:08] <teut> but instead of that an array?
[00:05:43] <cbreak> no
[00:05:48] <cbreak> that's something completely different
[00:05:55] <teut> or just the vector class
[00:06:01] <cbreak> you can think of std::vector, but much simpler
[00:06:06] <teut> yes
[00:06:11] <cbreak> or better: think of arrays
[00:06:18] <teut> understood, trying out
[00:06:27] <cbreak> teut::array x; x[5] = 2; // does this work?
[00:06:52] <teut> no it should
[00:06:54] <teut> nt
[00:06:58] <cbreak> why not?
[00:07:02] <teut> array x?
[00:07:10] <teut> array<int> x it should be
[00:07:31] <cbreak> if you want to make it generic, sure.
[00:07:48] <cbreak> but the key idea here is:
[00:07:48] <teut> oh ok everything uses templates now
[00:07:57] <cbreak> the notion of "array" is an abstraction here
[00:08:04] <cbreak> x is not really an array
[00:08:09] <cbreak> it just acts similar to one
[00:08:26] <cbreak> in this case, the abstract notion of array-ness is used at compile time
[00:08:28] <teut> that just runs the constructor
[00:08:39] <teut> what happens is abstracted out
[00:08:56] <cbreak> x[5] = 2; // this is the part that requires array-ness
[00:09:30] <cbreak> it would work with an array of suitable size, with a pointer pointing to the first element of an array of suitable size, with a map of suitable type
[00:09:38] <cbreak> or with a teut:array, if you implemented it correctly
[00:09:59] <cbreak> the idea, the abstract data type of "array", is an abstraction
[00:10:23] <cbreak> std::vector is a concrete implementation of that abstraction
[00:10:32] *** Joins: kylese (~kylese@p5dd8b9b1.dip0.t-ipconnect.de)
[00:10:52] <teut> let me try to make one first
[00:12:17] <teut> oh , I understand it now
[00:12:38] <teut> right its the   same  , shape  and  types of shapes
[00:12:44] <teut> type*
[00:13:13] <teut> the question is just why you need to write that abstract type?
[00:13:59] <teut> because this thing , writing an interface like java with all methods empty is called Meta Programming
[00:14:12] <teut> maybe some people might be called it oop only
[00:14:47] <teut> calling*
[00:15:25] <teut> it you use abstract class to just avoid code duplication in all of the children then its fine
[00:16:16] <cbreak> no
[00:16:22] <cbreak> meta programming is something entirely different
[00:16:35] <teut> template  is meta programming
[00:16:40] <cbreak> not always
[00:16:47] <teut> where compiler generates code for you
[00:16:57] <cbreak> using templates for generic code like in std::vector is just programming
[00:17:13] <cbreak> using templates to actually compute something is meta programming
[00:17:56] <cbreak> abstract classes don't avoid code duplication
[00:18:09] <teut> they prevent code duplication
[00:18:12] <cbreak> no.
[00:18:16] <cbreak> because they are abstract
[00:18:20] <cbreak> they do not contain implementations
[00:18:31] <teut> why not?
[00:18:34] <cbreak> a non-abstract base class can avoid code duplication.
[00:18:41] <cbreak> not containing code is what makes them abstract
[00:18:52] <teut> consider a class shape which just knows how to draw an implementation
[00:19:02] <cbreak> -> not abstract
[00:19:19] <cbreak> abstract base classes are like interfaces in java
[00:19:36] <cbreak> non-abstract base classes are like ... base classes in java
[00:19:45] <teut> hold on plz
[00:20:01] <teut> the definitions in my head are
[00:20:06] <cbreak> of course c++ allows half-assed abstract bases, which are only partially abstract, but still, the fact that they are abstract does NOT avoid code duplication
[00:20:22] <cbreak> struct I { void foo() = 0; }; // abstract
[00:20:23] <teut> interface : an abstract type 
[00:20:28] <cbreak> struct I { void foo(); }; // not abstract
[00:20:55] <teut> abstract class: allows you you have mehods with non-empty body   in parent
[00:21:26] <teut> cbreak thats the same in python
[00:21:34] <cbreak> no
[00:21:53] <cbreak> I don't think python has interfaces or abstract member functions
[00:21:59] <cbreak> unless they somehow hacked it in with @crap
[00:22:00] <teut> in python the abstract type is non - initializable
[00:22:23] <cbreak> that's just a side effect
[00:22:56] <cbreak> the what makes a class abstract in c++ is that it has at least one pure virtual member function
[00:23:03] <teut> https://refactoring.guru/design-patterns/strategy/python/example
[00:23:06] <teut> now see this
[00:23:10] <cbreak> and typically, interfaces only have pure virtual member functions
[00:23:19] <teut> this is obfuscated code
[00:23:24] <cbreak> so they do not avoid code duplication inside the derived classes
[00:24:04] <teut> so abstract classes cannot be initialised rule applies here?
[00:24:13] <cbreak> not on their own
[00:24:27] <teut> what does that mean?
[00:24:40] *** Quits: kariosfox (~kariosfox@176.221.124.50) (Remote host closed the connection)
[00:24:41] <cbreak> they can be initialized if they are a base class of some other class that is not itself abstract
[00:24:50] <teut> oh
[00:25:09] <teut> didnt know this, neither I know if that is the case with python too
[00:25:23] <cbreak> struct A { void foo() = 0; }; struct B : A { void foo() {} };
[00:25:39] <cbreak> A can be initialized if it is a base-class-subobject of B, in this example
[00:25:45] <cbreak> you can not create a stand-alone A object
[00:25:58] <cbreak> but every B object is-an A
[00:26:10] <cbreak> because polymoprhism / OOP
[00:26:45] <teut> struct A { virtual void foo() = 0; };  ?
[00:27:07] <cbreak> yes
[00:27:21] <teut> ya I was thinking something is wrong
[00:27:50] <cbreak> wonder if that'd work
[00:27:58] <teut> you can not create a stand-alone A object     yes I meant this
[00:28:00] <cbreak> { B b; } struct A { void foo() = 0; }; struct B : A { void foo() {} };
[00:28:00] <geordi> error: initializer specified for non-virtual method 'void A::foo()'
[00:28:16] <cbreak> { B b; } struct A { virtual void foo() = 0; }; struct B : A { void foo() {} };
[00:28:16] <geordi>  
[00:28:22] <cbreak> exactly.
[00:28:51] <cbreak> if you wanted to avoid code duplication, you'd implement the function in A
[00:28:56] <cbreak> then it is not abstract
[00:29:07] <cbreak> but derived types no longer have to implement it
[00:29:30] <cbreak> but really, if you want to avoid code duplication, just write a function. No need for inheritance.
[00:30:31] <teut> if you wanted to avoid code duplication, you'd implement the function in A      this I call an abstract clsss
[00:30:48] <teut> and this causes coupling
[00:31:33] <teut> so in java they write alll  methods as  virtual method()=0 
[00:32:39] <cbreak> it's not abstract if it is implemented
[00:32:41] <teut> so in java they write alll  methods as  virtual method()=0     and this I call an interce
[00:33:10] <teut> in java atleast its like that
[00:33:15] <cbreak> no
[00:33:23] <teut> software is full of bad naming
[00:33:24] <cbreak> java doesn't have abstract classes I think
[00:33:29] <cbreak> they have interfaces
[00:33:35] <teut> they ve both
[00:33:47] <cbreak> c++ emulates interfaces via abstract classes
[00:33:55] <teut> https://www.javatpoint.com/difference-between-abstract-class-and-interface
[00:34:00] <cbreak> did java finally add multi-inheritance?
[00:34:41] <teut> no idea
[00:35:47] <teut> https://en.wikipedia.org/wiki/C3_linearization  
[00:35:55] <teut> does c++ also use this?
[00:36:00] <teut> for MI
[00:36:40] <cbreak> no
[00:37:39] <teut> ok
[00:39:33] <teut> thanks for explaining OOP, few points I will ask again after writing that  array implement 
[00:39:38] <teut> ation
[00:40:58] *** Quits: teut (~teut@182.64.45.94) (Quit: Client closed)
[00:42:48] *** Joins: lumbermb (~lumbermb@191.114.114.152)
[00:49:25] *** Quits: kylese (~kylese@p5dd8b9b1.dip0.t-ipconnect.de) (Remote host closed the connection)
[00:49:51] <Alipha> cbreak: in java (since forever), you can abstract classes, which are classes that can't be instantiated because they don't fully implement an interface and/or declare one or more abstract methods (pure virtual functions). The catch is, you can only inherit from one class, which is why interfaces exist (which you can implement multiple interfaces)
[00:50:50] <cbreak> doesn't sound particularly useful
[01:07:17] <Alipha> Well, as teut tried to explain, it's used for code sharing among classes
[01:07:29] <Alipha> But I agree, it's not terribly useful
[01:40:58] *** Quits: unixpro1970 (~unixpro19@c-73-181-185-205.hsd1.wa.comcast.net) (Read error: Connection reset by peer)
[01:41:17] *** Joins: unixpro1970 (~unixpro19@c-73-181-185-205.hsd1.wa.comcast.net)
[01:45:50] *** Quits: spaceangel (~spaceange@ip-89-176-181-220.net.upcbroadband.cz) (Remote host closed the connection)
[02:46:23] *** Quits: The_Jag (~The_Jag@host-79-13-46-237.retail.telecomitalia.it) (Quit: The_Jag)
[03:15:24] *** Joins: The_Jag (~The_Jag@host-79-13-46-237.retail.telecomitalia.it)
[03:34:22] *** Joins: vdamewood (~vdamewood@fedora/vdamewood)
[03:51:47] *** Quits: PJBoy (~PJBoy@user/pjboy) (Ping timeout: 260 seconds)
[04:18:57] *** Quits: DSpider (DSpider@86.127.146.140) (Quit: Leaving)
[04:36:23] *** Quits: markb1 (~markb1@2600:1700:eb40:7ecf:def0:6996:2bb9:77) (Ping timeout: 264 seconds)
[04:44:23] *** Joins: ferdna (~ferdna@user/ferdna)
[04:46:24] *** Joins: markb1 (~markb1@2600:1700:eb40:7ecf:4def:4e95:4385:6486)
[04:58:53] *** Joins: The_Jag_ (~The_Jag@host-87-19-40-26.retail.telecomitalia.it)
[05:01:33] *** Quits: The_Jag (~The_Jag@host-79-13-46-237.retail.telecomitalia.it) (Ping timeout: 265 seconds)
[06:31:56] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[06:39:44] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Remote host closed the connection)
[06:40:56] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[06:58:30] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Remote host closed the connection)
[06:59:17] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[07:03:52] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Remote host closed the connection)
[07:05:30] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[07:11:09] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Remote host closed the connection)
[07:11:56] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[07:17:26] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Remote host closed the connection)
[07:18:27] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[07:26:14] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Remote host closed the connection)
[07:26:55] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[07:33:27] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Ping timeout: 260 seconds)
[07:34:58] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[07:44:35] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Ping timeout: 260 seconds)
[08:30:56] *** Joins: Guest3770 (~Guest3770@h67-217-13-182.ftcmco.broadband.dynamic.tds.net)
[08:51:23] *** Quits: Guest3770 (~Guest3770@h67-217-13-182.ftcmco.broadband.dynamic.tds.net) (Quit: Client closed)
[08:54:36] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[08:55:14] *** Quits: ferdna (~ferdna@user/ferdna) (Quit: Leaving)
[08:59:19] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Ping timeout: 260 seconds)
[09:27:02] *** Joins: meator (~meator@user/meator)
[09:27:23] *** Quits: lumbermb (~lumbermb@191.114.114.152) (Ping timeout: 265 seconds)
[09:32:19] *** Joins: smallvil_ (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au)
[10:09:41] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[10:11:37] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Client Quit)
[10:35:17] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[10:42:21] *** Quits: jellie (~luv_panda@user/jellie) (Ping timeout: 268 seconds)
[10:42:43] *** Joins: jellie (~luv_panda@user/jellie)
[10:54:11] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Remote host closed the connection)
[10:54:46] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[11:00:46] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[11:06:47] *** Joins: topfuel (~topfuel@91-158-202-22.elisa-laajakaista.fi)
[11:07:37] *** Quits: smallvil_ (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au) (Remote host closed the connection)
[11:08:13] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[11:11:13] *** Joins: smallvil_ (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au)
[11:14:59] *** Quits: smallvil_ (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au) (Remote host closed the connection)
[11:15:07] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[11:16:08] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[11:16:18] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Client Quit)
[11:17:48] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[11:18:00] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Client Quit)
[11:42:00] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[11:42:22] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Client Quit)
[11:45:48] *** Joins: DSpider (DSpider@86.127.146.135)
[11:48:48] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[11:57:05] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Remote host closed the connection)
[11:57:39] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[12:07:16] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Remote host closed the connection)
[12:07:47] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[12:09:07] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Client Quit)
[12:19:40] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[12:19:47] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Client Quit)
[12:21:47] *** Joins: PJBoy (~PJBoy@user/pjboy)
[12:40:47] *** Joins: smallvil_ (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au)
[12:59:53] *** Quits: smallvil_ (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au) (Remote host closed the connection)
[13:00:17] *** Joins: LangerJan (~jan@user/langerjan)
[13:05:13] *** Joins: smallvil_ (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au)
[14:04:39] *** Quits: The_Jag_ (~The_Jag@host-87-19-40-26.retail.telecomitalia.it) (Read error: Connection reset by peer)
[14:05:18] *** Joins: The_Jag (~The_Jag@host-87-19-40-26.retail.telecomitalia.it)
[14:20:51] *** Quits: smallvil_ (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au) (Ping timeout: 260 seconds)
[14:32:38] *** Joins: night_wulfe_ (~wulfe@cpe-174-103-156-213.cinci.res.rr.com)
[14:36:26] *** Joins: night_wulfe__ (~wulfe@cpe-174-103-156-213.cinci.res.rr.com)
[14:36:34] *** Quits: night_wulfe (~wulfe@cpe-174-103-156-213.cinci.res.rr.com) (Ping timeout: 260 seconds)
[14:40:35] *** Quits: night_wulfe_ (~wulfe@cpe-174-103-156-213.cinci.res.rr.com) (Ping timeout: 264 seconds)
[14:45:06] *** Joins: gggpkm (~gggpkm@li2015-124.members.linode.com)
[15:18:56] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[15:20:00] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Client Quit)
[15:31:53] *** Joins: Deneb (~johnch@86.111.189.80.dyn.plus.net)
[15:56:15] *** Joins: Guest82 (~Guest82@eth-west-pareq2-46-193-4-100.wb.wifirst.net)
[15:56:37] <Guest82> the first variant of https://en.cppreference.com/w/cpp/thread/async confuses me'
[15:56:58] <Guest82> I don't understand how or why `If both the std::launch::async and std::launch::deferred flags are set in policy, it is up to the implementation whether to perform asynchronous execution or lazy evaluation.`
[15:57:29] <Guest82> how are the implementations expected to decide this?
[15:58:35] <Guest82> In other words I don't see any reason for having the (1) variant of std::async, surely I'm missing something?
[16:12:51] *** Joins: NovumDXW (~NovumDXW@183.12.239.113)
[16:16:35] *** Joins: Firecatmon (~firecatmo@45.125.247.110)
[16:30:33] *** Joins: smallvil_ (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au)
[16:41:15] *** Quits: meator (~meator@user/meator) (Ping timeout: 260 seconds)
[16:44:34] *** Quits: NovumDXW (~NovumDXW@183.12.239.113) (Quit: Leaving)
[16:46:30] *** Joins: magla (~gelignite@55d4747b.access.ecotel.net)
[16:55:45] *** Quits: smallvil_ (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au) (Remote host closed the connection)
[16:57:13] *** Joins: smallvil_ (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au)
[17:02:08] *** Quits: smallvil_ (~smallvill@cpe-172-193-200-97.qld.foxtel.net.au) (Read error: Connection reset by peer)
[17:09:38] *** Quits: artok (~azo@mobile-access-bcee2b-18.dhcp.inet.fi) (Ping timeout: 260 seconds)
[17:18:17] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[17:18:28] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Client Quit)
[17:19:22] *** Joins: gggp (~gggp@li870-78.members.linode.com)
[17:27:58] *** Quits: gggp (~gggp@li870-78.members.linode.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[17:32:04] *** Quits: topfuel (~topfuel@91-158-202-22.elisa-laajakaista.fi) (Quit: Leaving)
[17:33:22] *** Quits: Firecatmon (~firecatmo@45.125.247.110) (Quit: Konversation terminated!)
[17:46:39] *** Joins: meator (~meator@user/meator)
[17:47:28] *** Joins: jessicara (~shirogits@user/jessicara)
[17:50:51] *** Quits: gggpkm (~gggpkm@li2015-124.members.linode.com) (Remote host closed the connection)
[17:52:55] *** Joins: lumbermb (~lumbermb@191.114.114.152)
[18:07:17] *** Quits: magla (~gelignite@55d4747b.access.ecotel.net) (Quit: Stay safe!)
[18:13:11] *** Joins: markong (~kvirc@213.146.188.203)
[18:13:34] *** Joins: argonautx (~argonautx@i5E86704F.versanet.de)
[18:20:34] *** Quits: meator (~meator@user/meator) (Quit: Leaving)
[18:25:19] *** Joins: riskoir (~karaixx@user/riskoir)
[18:27:47] *** Joins: CodeMouse92 (~CodeMouse@user/codemouse92)
[18:50:49] *** Joins: davidlowryduda (~davidlowr@73.61.9.42)
[18:53:37] *** davidlowryduda is now known as dld
[19:33:02] *** Joins: X-Scale` (~ARM@50.77.166.178.rev.vodafone.pt)
[19:34:27] *** Quits: X-Scale (~ARM@31.22.144.14) (Ping timeout: 260 seconds)
[19:35:05] *** X-Scale` is now known as X-Scale
[20:10:42] *** Quits: dld (~davidlowr@73.61.9.42) (Ping timeout: 265 seconds)
[20:12:35] *** Joins: dld (~dld@2601:197:600:1210:d10e:482c:eb89:99b9)
[20:19:23] *** Joins: artok (~azo@mobile-access-bcee2b-18.dhcp.inet.fi)
[20:59:26] *** Joins: magla (~gelignite@55d4747b.access.ecotel.net)
[21:08:27] *** Quits: riskoir (~karaixx@user/riskoir) (Quit: Leaving)
[21:30:41] *** Quits: Deneb (~johnch@86.111.189.80.dyn.plus.net) (Quit: Leaving)
[21:32:40] *** Quits: argonautx (~argonautx@i5E86704F.versanet.de) (Quit: Leaving)
[21:40:52] *** Joins: meator (~meator@user/meator)
[21:43:43] *** Quits: markong (~kvirc@213.146.188.203) (Ping timeout: 260 seconds)
[21:45:38] *** Joins: kariosfox (~kariosfox@176.221.124.50)
[21:59:56] *** Quits: wasd (~wasd@user/axis) (Ping timeout: 246 seconds)
[22:01:54] *** Joins: wasd (~wasd@100.101.7.51.dyn.plus.net)
[22:02:18] *** wasd is now known as Guest3655
[22:03:23] *** Quits: meator (~meator@user/meator) (Remote host closed the connection)
[22:25:52] *** Joins: wootehfoot (~wootehfoo@user/wootehfoot)
[22:58:17] *** Quits: garo (~garo@ptr-1pln5puxqxmejxq9kws.18120a2.ip6.access.telenet.be) (Ping timeout: 264 seconds)
[22:59:09] *** Joins: garo (~garo@ptr-1pln5puxqxmejxq9kws.18120a2.ip6.access.telenet.be)
[23:01:08] *** Quits: wootehfoot (~wootehfoo@user/wootehfoot) (Read error: Connection reset by peer)
[23:02:41] *** Quits: kariosfox (~kariosfox@176.221.124.50) (Quit: Leaving)
[23:08:45] *** Joins: X-Scale` (~ARM@31.22.167.71)
[23:09:16] *** Quits: X-Scale (~ARM@50.77.166.178.rev.vodafone.pt) (Ping timeout: 245 seconds)
[23:10:13] *** Joins: cow_2001 (~un@user/cow-2001/x-5712099)
[23:10:52] *** X-Scale` is now known as X-Scale
[23:11:32] <cow_2001> i am looking for example linked list code implemented with references rather than pointers
[23:11:44] <cow_2001> found some stack overflow stuff, but it won't compile
[23:15:50] *** Joins: spaceangel (~spaceange@ip-89-176-181-220.net.upcbroadband.cz)
[23:31:31] <CodeMouse92> cow_2001: Pardon the question, but why do you want it implemented with references instead of pointers? Best I can see it, it defeats a few key patterns critical to linked lists.
[23:32:25] <cow_2001> i don't know. i'm a total newbie in regard to references.
[23:32:43] <cow_2001> thinking it might be a good exercise <_<
[23:33:03] <CodeMouse92> cow_2001: It really isn't. :)
[23:33:34] <CodeMouse92> A reference isn't a "thing", it's like pointing out a building on a street instead of handing a person a piece of paper with an address.
[23:33:38] <cow_2001> to be honest i started with trying to implement quadtree as an exercise
[23:33:40] <CodeMouse92> The piece of paper is a pointer.
[23:34:39] <cow_2001> then realised references to children are hard, so went to a simpler linked list
[23:34:57] <CodeMouse92> References are hard outside of parameter passing.
[23:34:57] <cow_2001> so now i'm back to quadtree, but with pointers instead
[23:35:04] <CodeMouse92> Yeah. Keep it simple. :)
[23:35:17] <cow_2001> thank you codemouse92
[23:36:03] <CodeMouse92> cow_2001: There's nothing wrong with pointers. Mind you, if you're writing production-grade C++ code, you should look into smart pointers (std::shared_ptr and std::unique_ptr), which prevent a lot of common pointer mistakes.
[23:36:26] <cow_2001> maybe i should use those, then?
[23:36:27] <CodeMouse92> But if you just want a variable that tells you where to find another value, use a pointer.
[23:36:36] *** Joins: bobb_ (~bobb_@dslb-092-074-236-095.092.074.pools.vodafone-ip.de)
[23:36:43] <CodeMouse92> cow_2001: It depends on your use case.
[23:37:26] <CodeMouse92> "Raw" pointers (traditional pointers) give you more flexibility, but are easier to get wrong. Smart pointers protect you from yourself, but require more thought to use.
[23:38:37] <CodeMouse92> cow_2001: I strongly recommend you read https://stackoverflow.com/questions/33047452/definitive-list-of-common-reasons-for-segmentation-faults before going further.
[23:38:51] <cow_2001> i should really exercise the basics then
[23:39:21] <cow_2001> any suggestions on toy / kata problems dealing with this bit of the language?
[23:40:21] <FuzzyBottom> Hello. I am learning about singletons and thread safety. I see two schools of thought. One is mutex, and the other is meyers singleton. Is one better than the other?
[23:40:59] <CodeMouse92> cow_2001: Unfortunately, I never do toy/kata problems myself, so I don't have any recommendations. If I were in your place, I'd just implement a singly-linked list, and then a doubly-linked list, and then write tests to try and break both. :)
[23:41:20] <CodeMouse92> FuzzyBottom: Personally, I recommend mutex. A singleton will not save you from deadlocks.
[23:41:21] <cow_2001> ah, thank you again!
[23:41:27] <cow_2001> quadtree will have to wait
[23:41:31] <CodeMouse92> Or from race conditions
[23:41:47] <CodeMouse92> cow_2001: Yeah, work your way up. BUilding lists, followed by various trees, is very good practice with pointers.
[23:42:29] <FuzzyBottom> CodeMouse92: Oh, I was under the impression the meyers way solved that. Thank you for clarifying.
[23:42:32] <CodeMouse92> FuzzyBottom: The whole point is that, if you're going to share a mutable resource between two threads, you're going to need to control who is writing to it when.
[23:42:43] <CodeMouse92> I may be missing a distinction with *meyers*, tho
[23:43:16] *** Joins: RoKenn (~RoKenn@2001:a61:3505:d101:b4b5:1d8:302c:6e02)
[23:43:16] *** Quits: RoKenn (~RoKenn@2001:a61:3505:d101:b4b5:1d8:302c:6e02) (Changing host)
[23:43:16] *** Joins: RoKenn (~RoKenn@user/rokenn)
[23:43:28] <CodeMouse92> Yeah, Meyers Singleton is indeed thread-safe. My mistake. (Most of my concurrency work is in other languages.)
[23:44:34] <FuzzyBottom> To be fair, I have no idea how concurrency works yet, it's all new to me, and looking it up I came across those examples.
[23:45:18] <FuzzyBottom> So safe assumption either way would work fine?
[23:45:54] <CodeMouse92> FuzzyBottom: In practice, the safe assumption is that neither will work in your code at all. *laughs ruefully*
[23:46:08] <CodeMouse92> Concurrency is *very* hard to get right, even with the right tools.
[23:47:04] <CodeMouse92> You have to carefully design your processes, considering the problems of deadlock/livelock, race conditions, producer/consumer problem, and reentrancy...
[23:47:22] <CodeMouse92> There are many solutions because there are many subtleties to these problems.
[23:47:50] <FuzzyBottom> I probably bit off more than I can chew at this point :)
[23:47:58] <CodeMouse92> So...back up and start here: what are you wanting to achieve with threading? Do you want to make your code faster? Improve responsiveness of the UI? Something else?
[23:48:06] <FuzzyBottom> I do appreciate your input though.
[23:48:24] <CodeMouse92> FuzzyBottom: Just attack the problem from the right starting position.
[23:48:37] <CodeMouse92> (You're welcome to answer that question, I can probably help you get started.)
[23:48:46] <FuzzyBottom> Oh, I was actually learning about singletons, and then thread safety came up. It spun out of control from there ;)
[23:48:50] <CodeMouse92> HAHAH!
[23:48:58] <CodeMouse92> FuzzyBottom: Uni?
[23:49:16] <FuzzyBottom> No, I am old (50). Learning on my own.
[23:49:21] <CodeMouse92> It's about that time when the university design pattern classes would be hitting singletons, that's why I ask.
[23:49:27] <CodeMouse92> FuzzyBottom: Oh, awesomesauce!
[23:49:36] <FuzzyBottom> Tell that to my old brain :)
[23:49:48] <CodeMouse92> FuzzyBottom: Bah, you're never too old to learn.
[23:49:54] <FuzzyBottom> How old are you?
[23:50:04] <CodeMouse92> As a rule, I never reveal that. :)
[23:50:31] <Raziel> 28 it is
[23:50:42] <CodeMouse92> heheheh. Whatever age you like to assign, carry on!
[23:50:50] <FuzzyBottom> Good idea. I spent most of my life networking/hardware. After 25 years, I decided on something else. Coding seemed good.
[23:51:10] <CodeMouse92> FuzzyBottom: In general, singletons are usually a solution in search of a problem.
[23:51:13] <FuzzyBottom> Well no matter your age, I appreciate your help.
[23:51:21] <CodeMouse92> There's usually a better way to solve a problem than with a singleton.
[23:51:28] <CodeMouse92> (Not always...but often)
[23:51:29] <FuzzyBottom> Oh?
[23:51:44] <FuzzyBottom> I was under the impression that it was for things like logging/database calls etc.
[23:51:48] <Raziel> for example, my favorite one is to not have an instance at all. that class you just made? it should probably be a namespace instead.
[23:51:51] <Raziel> :p
[23:52:16] <CodeMouse92> Yeah. Singletons were dreamed up by the "Gang of Four", who wrote the watershed text on design patterns. They imagined the pattern would be very useful, but the general consensus is just that they solved the wrong problem with it.
[23:52:46] <CodeMouse92> Like Raziel says. Can you just make it a static class? (Most langs support that) Global variable? etc.
[23:53:26] <FuzzyBottom> Everything I ever read was "AVOID global <anything> at all costs"
[23:53:28] <Raziel> Also, since we're in #C++-basic, I'm assuming any implementation talk is gonna be C++ unless otherwise specified
[23:53:52] <CodeMouse92> FuzzyBottom: Bah. That's a nonsense edict.
[23:54:09] <FuzzyBottom> Raziel: Agreed. 
[23:54:13] <Raziel> Avoid global anything I think refers more to... dumping a shitload of stuff into the global namespace
[23:54:16] <CodeMouse92> What we don't want are a bunch of funny variables floating around in global space.
[23:54:18] <CodeMouse92> Yeah
[23:54:28] <Raziel> it doesn't mean making namespaces (which are globally accessible) is bad
[23:54:34] <CodeMouse92> But in, say, user interface design, you'd want some shared instances.
[23:55:14] <CodeMouse92> My other (often controversial) rule is "classes are defined by their constituent data". If you can't describe the class you're writing *entirely* by the data it contains, it shouldn't be a class, it should be a namespace.
[23:55:33] <FuzzyBottom> I understand the namespace idea being good. Makes things more organised. 
[23:56:09] <Raziel> CodeMouse92, that's one or two steps away from working in pure ECS
[23:56:15] <Raziel> which is not a bad idea :p
[23:56:19] <FuzzyBottom> ECS?
[23:56:37] <CodeMouse92> Raziel: Episcopal Children's Services?
[23:56:44] <FuzzyBottom> :)
[23:57:08] <Raziel> entity component system
[23:57:09] <Raziel> :p
[23:57:10] <CodeMouse92> Well, when you apply the aforesaid philosophy to OOP, you can merge it seamlessly with functional design patterns too.
[23:57:20] <CodeMouse92> I like to think of objects as units of state.
[23:57:27] <Raziel> https://en.wikipedia.org/wiki/Entity_component_system
[23:57:32] <CodeMouse92> Oh, right, yes
