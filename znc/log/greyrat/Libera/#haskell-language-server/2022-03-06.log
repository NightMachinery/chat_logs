[01:20:58] *** Quits: coot (~coot@213.134.190.95) (Ping timeout: 272 seconds)
[09:52:03] *** Joins: coot (~coot@213.134.190.95)
[13:02:10] <wz1000> pepeiborra: how safe is this UnliftIO instance for Action? I'm thinking we can use it to get rid of `NeedsCompiliation` and demand the Linkables we need directly in hscCompileCoreExprHook with a `uses`
[13:02:52] <wz1000> I assume it wouldn't work at all unless there is a hls-graph session running, but that shouldn't be a problem in this case?
[13:05:57] <pepeiborra> I have not thought about it, how can you use it to replace NeedsCompilation though?
[13:06:34] <pepeiborra> I thought the whole point of NeedsCompilation was to know whether you need to produce linkables at typecheck time
[13:06:50] <wz1000> I already have a patch that lets us serialize core
[13:07:33] <wz1000> so we can do that on each typecheck, and generate bytecode from the serialized core when we actually need the Linkable
[13:08:13] <pepeiborra> That does away with NeedsCompilation. Where does the UnliftIO instance get used?
[13:08:25] <pepeiborra> oh, in the hook
[13:08:54] <wz1000> inside hscCompileCoreExprHook, just before we load the expression to get the Linkables that it depends on and put them in the HPT
[13:09:41] <pepeiborra> everything in the environment is mutable except for the rules, so it should work?
[14:04:17] *** Quits: coot (~coot@213.134.190.95) (Quit: coot)
[14:31:30] *** Joins: coot (~coot@213.134.190.95)
[16:05:09] *** Quits: coot (~coot@213.134.190.95) (Quit: coot)
[17:25:35] <dpratt> supposing that I'd like to try to use nix-shell to setup a Haskell dev environment, would it be sensible to set the "Server Executable Path" setting to a wrapper script that enters nix-shell and runs the language server executable from there?
[17:31:27] *** Joins: coot (~coot@213.134.190.95)
[18:00:51] *** Quits: coot (~coot@213.134.190.95) (Remote host closed the connection)
[18:01:22] *** Joins: coot (~coot@2a02:a310:e241:1b00:ec1a:e9df:79ac:66ba)
[18:40:57] *** Quits: coot (~coot@2a02:a310:e241:1b00:ec1a:e9df:79ac:66ba) (Quit: coot)
[19:13:37] *** Joins: coot (~coot@213.134.190.95)
[19:18:20] <shapr> Are there docs for the query language of hiedb?
[20:05:18] <wz1000> shapr: not really
[20:22:59] *** Quits: coot (~coot@213.134.190.95) (Quit: coot)
[20:49:57] <fendor[m]> wz1000: did you happen to encounter the hie-bios issue again?
[20:58:24] <wz1000> fendor[m]: yes, I didn't get a chance to investigate, but I'm getting some very strange results
[20:58:47] <wz1000> Here are the contents of the ghc-pkg wrapper script for example:
[20:58:50] <wz1000> exec ./autogenerated_hoogle_database_path\ ::\ Data.String.IsString\ p\ =>\ p --global-package-db /home/zubin/.ghcup/ghc/8.10.7/lib/ghc-8.10.7/package.conf.d ${1+"$@"}
[20:59:23] <fendor[m]> oh well, that's interesting
[20:59:42] <fendor[m]> But gives me a good idea of what might be going wrong, thanks!
[21:03:47] <wz1000> fendor[m]: also, HIE_BIOS_GHC is being set to "/home/zubin/.ghcup/ghc/8.10.7/lib/ghc-8.10.7/bin/ghcit :: ()"
[21:03:59] <wz1000> probably because I have `:set +t` in my .ghci
[21:04:20] <wz1000> I think you need to ignore the .ghci file, there is a flag for that I think
[21:04:54] <maerwald> ah
[21:05:06] <fendor[m]> interesting
[21:06:08] <fendor[m]> can reproduce
[21:06:09] <fendor[m]> thanks!
[22:21:10] *** Joins: coot (~coot@213.134.190.95)
[22:39:55] <maerwald> that cabal exec line is already full of tricks
[22:41:00] <fendor[m]> yeah. The whole approach is really hacky
[22:41:13] <fendor[m]> one more reason to get `cabal status` merged ASAP
[22:44:11] <maerwald> fendor[m]: try: cabal exec ghc -- -ignore-dot-ghci -XRebindableSyntax -XNoImplicitPrelude -v0 -package-env=- -e "do e <- System.Environment.getExecutablePath ; System.IO.putStr e"
[22:44:19] <maerwald> error =)
[22:44:48] <fendor[m]> hilariously, I would have run into that error pretty soon since I am experimenting with Rebindable Syntax, right now ðŸ˜€
[22:45:14] <fendor[m]> I think I have mentioned that I think this impl adds so many bandaids on to of each other, that it is not even funny anymore
[22:48:27] <fendor[m]> but we don't have to fix that right? We control that particular invocation and at least for me, it doesn't crash when I add those language extensions to my cabal file
[22:51:38] <maerwald> I have a solution
[22:51:44] <maerwald> fendor[m]: 'Control.Monad.join (Control.Monad.fmap System.IO.putStr (System.Environment.getExecutablePath))'
[22:51:46] <maerwald> =)
[22:52:20] <fendor[m]> still, do we really have to fix that?
[22:52:36] <maerwald> I'd rather
[22:55:05] <maerwald> https://imgur.com/a/yj3k4Kx
[22:56:36] <maerwald> with a comment "DONT TOUCH THIS CODE"
[22:58:13] <fendor[m]> ðŸ˜€ this is really the best fitting image to describe my feelings
[22:58:48] <maerwald> Also, `-package-env=-` doesn't seem to work for ghc prior to 8.4.x
[23:06:19] <fendor[m]> we don't support that anyway
[23:06:23] <fendor[m]> so, lucky us
[23:08:37] <maerwald> https://github.com/haskell/haskell-language-server/pull/2757
[23:09:12] <maerwald> good we have this abomination in two places
[23:09:50] <fendor[m]> yeah... "good"
[23:10:16] <fendor[m]> We can not untangle this somehow and have this code only in hie-bios?
[23:10:55] <maerwald> well, this uses `runGhcCmd`... 
[23:14:51] <maerwald> also, why don't we need this for stack?
[23:16:29] <fendor[m]> what in particular? That we do not need to insert the correct ghc version into the wrapper?
[23:17:13] <maerwald> yeah
[23:18:15] <fendor[m]> They modify the PATH to point include the GHC version the respective resolver would use
[23:18:25] <maerwald> unless you set system-ghc
[23:18:25] <fendor[m]> thus, the correct `ghc` version is on the path
[23:20:08] *** Joins: fendor (~fendor@91.141.40.111.wireless.dyn.drei.com)
[23:21:21] <fendor[m]> and our wrapper defaults to `ghc` when compiling dependencies
[23:25:11] <fendor[m]> and stack just makes sure that `ghc` on the PATH is the correct `ghc`
[23:27:16] <maerwald> fendor[m]: there are several settings in stack that can change that behavior
[23:27:47] <fendor[m]> yeah it is far from a good solution
[23:28:26] <fendor[m]> and if people want to get good stack support, we sooner or later need to collaborate to bring show-build-info to stack, too
[23:28:37] <maerwald> good luck with that
[23:28:59] <fendor[m]> (also, stack needs some bugs fixed)
[23:29:09] <fendor[m]> it is not entirely my problem ðŸ˜€
[23:37:04] <fendor[m]> I can't remember why, but it is noted you should not use `runGhcCmd` directly ðŸ˜€ https://github.com/haskell/hie-bios/blob/master/src/HIE/Bios/Environment.hs#L66
[23:39:24] <fendor[m]> maybe it is just an API thingy, since the code was always roughly the same
[23:43:01] <fendor[m]> or even exactly
