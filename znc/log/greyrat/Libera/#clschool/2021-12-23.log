[00:06:26] <White_Flame> McCLIM probably has its own interface for intentionally removing stuff, it wouldn't be a generic CL thing
[00:07:14] <CodeBitCookie[m]> True, as pointed out by someone over at #clim:libera.chat 
[00:12:47] <rotateq> oki :)
[00:33:07] *** Joins: random-nick (~random-ni@87.116.180.98)
[00:34:09] <CodeBitCookie[m]> Thanks rotateq White_Flame . 
[00:39:40] <pjb> CodeBitCookie[m]: in general, no. In lisp you don't get to delete objects.  The only thing you can do, is to remove all references to that object, from your lisp image.  But for that, you need to know all those references.
[00:40:02] <pjb> CodeBitCookie[m]: in theory, there may be references that you cannot get access to, such as bindings inside closures.
[00:40:22] <CodeBitCookie[m]> pjb: hmmmm, I see.
[00:40:35] <pjb> CodeBitCookie[m]: in practice, there may be an implementation specific API to get access to such "private" and hidden references (eg. a debugger function).
[00:41:21] <CodeBitCookie[m]> That seems too unnessary though.
[00:41:27] <pjb> CodeBitCookie[m]: some implementations have a finalizer generic function that can be called on objects that are about to be garbage collected.  But it's not a good idea to rely on them to do something.
[00:42:30] <pjb> CodeBitCookie[m]: in general, we manage life-time of lisp objects using with-<something> macros. They're based on unwind-protect to execute cleanup forms at the end of their execution.
[00:43:01] <pjb> CodeBitCookie[m]: but of course, long-lived objects are referenced in graphs of objects, and have more complex live times.
[00:43:18] <pjb> CodeBitCookie[m]: so, you can implement your own generic function to "delete" or "close" an object.
[00:44:05] <CodeBitCookie[m]> Why would anyone do that?
[00:44:33] <pjb> Answer to that question! YOU asked for a way to delete an object.
[00:45:15] <pjb> For example, a stream object can be "deleted" using the CLOSE function (well not really deleted in general, a closed file-stream object can still be used as a pathname designator).
[00:45:51] <pjb> You would do that because it may be meaningful for the real-world object represented by the lisp object to have such a life-time transition.
[00:46:09] <pjb> (defclass person () ((name) (age))) (defmethod decede ((person person)) â€¦)
[01:40:07] *** Joins: Oladon (~olad@98.43.81.226)
[02:24:41] *** Quits: random-nick (~random-ni@87.116.180.98) (Ping timeout: 256 seconds)
[02:44:21] *** Joins: dra (~dra@2a04:4540:641b:5900:1015:93e1:eb49:c063)
[03:18:23] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[03:47:31] *** Joins: dra_ (~dra@2a04:4540:6409:ed00:1015:93e1:eb49:c063)
[03:50:25] *** Quits: dra (~dra@2a04:4540:641b:5900:1015:93e1:eb49:c063) (Ping timeout: 268 seconds)
[04:20:57] *** Joins: Oladon (~olad@98.43.81.226)
[04:42:25] *** Joins: dre (~dre@2001:8003:c932:c301:ee34:5349:cb14:8f8e)
[05:04:58] *** Quits: dra_ (~dra@2a04:4540:6409:ed00:1015:93e1:eb49:c063) (Remote host closed the connection)
[05:28:42] *** Joins: lisp123 (~lisp123@5.30.23.247)
[05:33:06] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 260 seconds)
[05:45:15] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[06:51:01] *** Quits: sts-q (~sts-q@91.200.108.177) (Ping timeout: 256 seconds)
[06:53:23] *** Joins: sts-q (~sts-q@212.53.219.153)
[07:00:13] *** Quits: dre (~dre@2001:8003:c932:c301:ee34:5349:cb14:8f8e) (Ping timeout: 240 seconds)
[07:15:15] *** Joins: dre (~dre@2001:8003:c932:c301:58d1:88a7:d83f:4266)
[07:30:34] <beach> Good morning everyone! 
[08:07:35] *** Joins: Oladon (~olad@98.43.81.226)
[08:11:32] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[08:52:28] *** Quits: makomo (~makomo@user/makomo) (Quit: WeeChat 3.3)
[09:04:30] <CodeBitCookie[m]> Good morning beach!
[09:43:33] *** Joins: lisp123 (~lisp123@5.30.23.247)
[09:56:13] *** Joins: treflip (~user@user/treflip)
[10:26:41] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[10:33:16] *** Quits: sjl (~sjl@cpe-66-66-5-59.rochester.res.rr.com) (Quit: WeeChat 2.2-dev)
[10:40:28] *** Quits: treflip (~user@user/treflip) (Quit: bye!)
[11:02:20] <CodeBitCookie[m]> <pjb> "You would do that because it may..." <- Ah, makes sense.
[11:54:22] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 260 seconds)
[11:55:48] <lisp123> So I have a bit of a naming conuldrum. Consider LIST -> (list 1 2 3 4) returns a list, so in a similar vein, generally I like to use class-names for functions that create instances of those classes
[11:56:00] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[11:56:01] <lisp123> E.g. for class RESULT, (result ...) -> (make-instance 'result ...)
[11:57:01] <lisp123> But when it comes to single slot classes, again say result, I have a conuldrum: (defclass result () ((result :initarg :result :accessor result))), would mean the generic function for result is now associated with the accessor of that slot
[11:58:04] <lisp123> So there's two solutions - change the class creator function to something like 'make-result' which is consistent with how structures are made but not consistent with LIST or other built-in objects
[11:58:37] <lisp123> Or change the slot name to something else. E.g. (defclass result () ((value :initarg :value :reader get-value)))
[11:59:31] <lisp123> It's hard to have the name of a slot in a single-slot class to be anything different than the class name IMO, so I am tempted to go down this generic "VALUE" name
[12:01:06] <lisp123> The issue doesn't arise for multi-slot classes, because they will naturally have their own names
[12:08:40] *** Joins: shka (~herr@109.231.0.226)
[12:28:27] <lisp123> I figured it out, I'll name the slot based on the type of objects they contain
[12:28:33] <lisp123> So if result is meant to contain a list
[12:29:05] <lisp123> Then it will be (defclass result () ((lists :initarg :lists :accessor lists)))
[12:33:14] <beach> If it contains a single list, you should not use the plural form for the slot.
[12:33:36] <beach> I have occasionally used the naming convention you are aiming for.
[12:33:53] <beach> I think in Cleavir, we use CONTEXT as the constructor for compilation contexts.
[12:34:16] <beach> But most of the time, we use the MAKE- prefix.  
[12:35:02] <beach> I wonder whether the LIST function was meant to be named after a verb, "to list" something, rather than the noun.
[12:35:52] <beach> I am asking because many functions have verbs in their names.
[12:38:24] <lisp123> Yes, I was typing list then realised my example wouldn't work (but agree with you of course). 
[12:38:41] <beach> Why would your example not work?
[12:39:01] <lisp123> The accessor function as 'list' would cause a conflict I think
[12:39:11] <beach> Not if you shadow it.
[12:39:34] <lisp123> I always thought CL went down the noun route due to Lisp 2
[12:40:29] <lisp123> So I always read (list 1 2 3 4) as "A list of 1 2 3 4" vs. "To List 1 2 3 4" (or easier to read (make-list 1 2 3 4))
[12:41:12] <beach> Possibly.  I haven't counted verbs vs nouns.
[12:42:15] <lisp123> Yes, both get used. Sometimes I try to name a function with a noun if it is relatively simple (e.g. list) or doesn't have any side effects
[12:42:46] <lisp123> And for "bigger" objects or where there is side-effects, I may resort to a verb version - "make-something" sounds like more "work" than just "something"
[12:43:47] <lisp123> So I would read (make-something 1 2 3 4) vs. (something 1 2 3 4) as the "something" object being bigger / more complex. But that's just some personal tendencies of mine, nothing that I have read from elsewhere
[12:48:38] <beach> Either way, shadowing is a better option than violating the singular/plural rule. 
[12:50:04] <lisp123> Agree
[12:57:41] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[13:08:35] *** Joins: treflip (~user@user/treflip)
[13:47:31] *** Joins: nexeq (~nexeq@94.25.176.105)
[13:48:50] *** Quits: nexeq (~nexeq@94.25.176.105) (Client Quit)
[13:49:06] *** Joins: nexeq (~nexeq@94.25.176.105)
[13:49:58] *** Quits: nexeq (~nexeq@94.25.176.105) (Client Quit)
[13:50:13] *** Joins: nexeq (~nexeq@94.25.176.105)
[13:57:42] *** Quits: nexeq (~nexeq@94.25.176.105) (Remote host closed the connection)
[13:58:09] *** Joins: lisp123 (~lisp123@5.30.23.247)
[13:58:52] *** Joins: nexeq (~nexeq@94.25.176.105)
[14:02:51] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 250 seconds)
[14:30:19] *** Quits: nexeq (~nexeq@94.25.176.105) (Quit: Quit)
[14:30:47] *** Joins: nexeq (~nexeq@94.25.176.105)
[14:31:02] *** Joins: winning-luser (~wl@2601:8c1:80:70d0::414b)
[14:38:55] *** Joins: neceve (~quassel@2.26.93.228)
[14:41:48] *** Joins: rain3 (~rain3___@2a02:2f09:d003:cb00:928d:3338:a339:f956)
[15:04:27] *** Quits: rain3 (~rain3___@2a02:2f09:d003:cb00:928d:3338:a339:f956) (Ping timeout: 268 seconds)
[15:12:48] *** Quits: derwolf (~DerWolf@2a01:4f8:c0c:554a::1) (Quit: Bye)
[15:13:07] *** Joins: derwolf (~DerWolf@static.143.125.47.78.clients.your-server.de)
[15:34:01] *** Joins: lisp123 (~lisp123@5.30.23.247)
[15:51:10] <lisp123> Is it a hard rule/suggestion for protocol classes to have no slots? Or is it okay to give them a slot that every 'concrete' class that inherits from it will define anyway?
[15:51:22] <lisp123> I'm just trying to get my head around that
[15:52:42] <lisp123> The only thing I can think of is that you don't want users to use the protocol class directly, hence no slots
[15:59:29] <lisp123> Looks like in CLIM they use the concept of "standard-[class-name]" which implements the protocol, that makes sense
[16:18:24] <beach> lisp123: It is fine to give them slots. 
[16:19:32] <beach> But yeah, it is perhaps more common to put the slots in the STANDARD- class. 
[16:57:32] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[17:09:37] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 240 seconds)
[17:10:49] <pjb> lisp123: you don't really need to define a class to define a protocol. in CLOS, a protocol is just a bunch of generic functions.
[17:11:06] <pjb> lisp123: but you can define a mixin, or an abstract class, with a bunch of generic functions, and some methods.
[17:11:13] <pjb> in the later case, you can have slots.
[17:11:46] *** Joins: aeth (~aeth@user/aeth)
[17:12:30] *** Quits: nexeq (~nexeq@94.25.176.105) (Read error: Connection reset by peer)
[17:12:37] *** Joins: nexeq (~nexeq@static.99.72.130.94.clients.your-server.de)
[17:17:01] *** Quits: nexeq (~nexeq@static.99.72.130.94.clients.your-server.de) (Ping timeout: 245 seconds)
[17:17:39] *** Joins: nexeq (~nexeq@94.25.176.105)
[17:28:02] *** Joins: random-nick (~random-ni@87.116.167.125)
[17:31:40] <lisp123> beach & pjb: Thanks!
[17:31:59] <lisp123> That makes sense
[18:30:13] *** Quits: kagevf (~jfh@ip68-108-33-76.lv.lv.cox.net) (Ping timeout: 240 seconds)
[18:30:26] *** Joins: kagevf (~jfh@ip68-108-33-76.lv.lv.cox.net)
[19:50:04] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[19:57:51] *** Quits: nexeq (~nexeq@94.25.176.105) (Read error: Connection reset by peer)
[19:58:15] *** Joins: nexeq (~nexeq@94.25.176.105)
[20:03:34] *** Joins: Oladon (~olad@98.43.81.226)
[20:09:49] *** Quits: nexeq (~nexeq@94.25.176.105) (Read error: Connection reset by peer)
[20:10:00] *** Joins: nexeq (~nexeq@94.25.176.105)
[20:32:39] *** Quits: nexeq (~nexeq@94.25.176.105) (Read error: Connection reset by peer)
[20:36:34] *** Joins: nexeq (~nexeq@94.25.176.105)
[20:56:34] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[21:03:21] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[21:06:58] *** Quits: nexeq (~nexeq@94.25.176.105) (Read error: Connection reset by peer)
[21:08:23] *** Joins: nexeq (~nexeq@94.25.176.105)
[21:14:33] *** Joins: rain3 (~rain3___@86.127.204.59)
[21:31:13] *** Joins: nexeq-pc (~nexeq-pc@94.25.176.105)
[21:39:16] *** Quits: nexeq-pc (~nexeq-pc@94.25.176.105) (Quit: leaving)
[21:41:55] *** Joins: nexeq-pc (~nexeq-pc@94.25.176.105)
[21:42:48] *** Quits: nexeq-pc (~nexeq-pc@94.25.176.105) (Client Quit)
[21:44:47] *** Joins: nexeq-pc (~nexeq-pc@94.25.176.105)
[21:46:28] *** Quits: nexeq-pc (~nexeq-pc@94.25.176.105) (Client Quit)
[21:49:16] *** Quits: treflip (~user@user/treflip) (Quit: good night!)
[21:55:32] *** Quits: nexeq (~nexeq@94.25.176.105) (Read error: Connection reset by peer)
[21:56:07] *** Joins: nexeq (~nexeq@94.25.176.105)
[22:01:12] *** Joins: nexeq-pc (~nexeq-pc@94.25.176.105)
[22:02:20] *** Quits: nexeq-pc (~nexeq-pc@94.25.176.105) (Client Quit)
[22:04:07] *** Joins: nexeq-pc (~nexeq-pc@94.25.176.105)
[22:05:07] *** Quits: nexeq (~nexeq@94.25.176.105) (Quit: Quit)
[22:05:24] *** Joins: nexeq (~nexeq@94.25.176.105)
[22:06:38] *** Quits: nexeq-pc (~nexeq-pc@94.25.176.105) (Client Quit)
[22:06:42] *** Quits: Jing (~hedgehog@115.207.51.59) (Read error: Connection reset by peer)
[22:07:30] *** Joins: Jing (~hedgehog@2604:a840:3::1061)
[22:24:13] *** Quits: nexeq (~nexeq@94.25.176.105) (Read error: Connection reset by peer)
[22:26:15] *** Joins: nexeq (~nexeq@94.25.176.105)
[22:33:01] *** Quits: rain3 (~rain3___@86.127.204.59) (Ping timeout: 240 seconds)
[22:59:04] *** Quits: pjb (~pjb@user/pjb) (Remote host closed the connection)
[23:12:59] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[23:15:27] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[23:26:36] *** Joins: pjb (~pjb@user/pjb)
[23:32:47] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 252 seconds)
[23:34:50] *** Joins: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se)
[23:36:09] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[23:45:53] *** Quits: nexeq (~nexeq@94.25.176.105) (Read error: Connection reset by peer)
[23:46:14] *** Joins: nexeq (~nexeq@94.25.176.105)
[23:49:57] *** Quits: nexeq (~nexeq@94.25.176.105) (Read error: Connection reset by peer)
[23:50:15] *** Joins: nexeq (~nexeq@94.25.176.105)
[23:53:17] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 240 seconds)
[23:53:27] *** Quits: nexeq (~nexeq@94.25.176.105) (Client Quit)
[23:53:40] *** Joins: nexeq (~nexeq@94.25.176.105)
[23:54:07] *** Quits: nexeq (~nexeq@94.25.176.105) (Client Quit)
[23:54:23] *** Joins: nexeq (~nexeq@94.25.176.105)
[23:54:35] *** Joins: aeth (~aeth@user/aeth)
