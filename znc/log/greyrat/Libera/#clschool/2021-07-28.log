[00:46:00] *** Quits: shka (~herr@109.231.62.239) (Ping timeout: 256 seconds)
[01:07:23] *** Quits: Josh_2 (~user@37.25.47.130) (Ping timeout: 255 seconds)
[01:12:26] *** Quits: neceve (~quassel@2a02:c7f:607e:d600:f762:20dd:304e:4b1f) (Ping timeout: 252 seconds)
[01:32:31] *** Quits: opfez (~opfez@user/opfez) (Quit: leaving)
[02:04:12] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[02:07:31] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 258 seconds)
[03:00:03] *** Quits: sjl (~sjl@cpe-66-66-5-59.rochester.res.rr.com) (Quit: WeeChat 2.2-dev)
[03:18:51] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[04:44:06] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-10-70-54-112-49.dsl.bell.ca)
[04:46:42] *** Quits: random-nick (~random-ni@87.116.182.181) (Ping timeout: 240 seconds)
[05:34:52] *** Joins: jmhimara (~jmhimara@170.39.139.5)
[05:47:52] *** Quits: jmhimara (~jmhimara@170.39.139.5) (Quit: Client closed)
[06:33:11] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 255 seconds)
[06:57:12] *** Quits: sts-q (~sts-q@91.200.108.137) (Ping timeout: 245 seconds)
[07:01:10] *** Joins: [itchyjunk] (~itchyjunk@user/itchyjunk/x-7353470)
[07:04:02] *** Joins: sts-q (~sts-q@91.200.108.177)
[07:07:38] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-10-70-54-112-49.dsl.bell.ca) (Remote host closed the connection)
[07:17:45] *** Quits: makomo (~makomo@user/makomo) (Ping timeout: 252 seconds)
[07:31:53] <beach> Good morning everyone! 
[07:32:47] <[itchyjunk]> Hello
[07:33:16] <beach> [itchyjunk]: '<some-expression> is turned by READ into (quote <come-expression>) and quote is a "special operator", not a function.  They differ in how they evaluate arguments.
[07:34:21] <[itchyjunk]> Hmm, operators and functions are different?
[07:34:54] <beach> For a function, the arguments are always evaluated before the function is applied to the values.
[07:35:16] <beach> Each special operator has its own rules for how the arguments are treated.
[07:35:35] <[itchyjunk]> hmm
[07:35:39] <beach> The situation is similar in other programming languages, but it is more messed up there because some functions don't look like functions in those languages, like + or *.
[07:36:22] <beach> Otherwise, you have special operators such as IF in most languages, including Common Lisp.  IF can not be written as a function. 
[07:36:25] <[itchyjunk]> + and * are binary operators in math which is just functions right?
[07:36:34] <[itchyjunk]> oh
[07:36:39] <[itchyjunk]> hmmmmmmmmmm
[07:36:51] <beach> Right, and in Common Lisp they are just functions.  You write (+ 3 4).
[07:37:48] <[itchyjunk]> hmmmm if cannot be written as a function? it take a boolean and does stuff based on the value no?
[07:38:04] <[itchyjunk]> oh i guess i would need some `if` concept to make sense of it in the first place
[07:38:19] <beach> Try (if (> *print-base* 3) (print 234) (print 345))
[07:38:41] <beach> What do you expect to happen if the print base is indeed > 3?
[07:39:31] <[itchyjunk]> hmm
[07:39:42] <[itchyjunk]> let me see if i can decypher the notations, i am a bit new at this
[07:39:44] <beach> No "hmm" is not the right answer. :)
[07:40:37] <[itchyjunk]> (function stuff) but we have (function (function 2) ) so in this case the output of function2 would be what function evaluated but i am confused about the notation here
[07:40:55] <beach> It would look like if(print_base > 3) print(234); else print(345); in some other language. 
[07:40:55] <[itchyjunk]> (function (func2) (func 3) (func 4)) ?
[07:41:18] <[itchyjunk]> ahh okay
[07:41:48] <beach> So you would expect 234 to get printed, but not 345. 
[07:43:12] <beach> However, if IF is a function, then it would look like if(print_base > 3, print(234), print(345)) in that other language. 
[07:43:27] <beach> And both 234 and 345 would be printed.
[07:43:47] <beach> It is exactly the same in Common Lisp and those other languages. and that's why IF is not a function. 
[07:44:30] <beach> [itchyjunk]: But you seem to be a newbie in programming in general and not just in Common Lisp. 
[07:44:39] <[itchyjunk]> if `if` was a function, it would be a function with 3 inputs and it would evaluate it all or somesuch?
[07:44:46] <[itchyjunk]> oh because you said it's pre evaluated?
[07:44:56] <[itchyjunk]> Right, newbie in general
[07:45:00] <beach> O.
[07:45:02] <beach> OK
[07:45:15] <[itchyjunk]> I made an irc bot in py recently
[07:45:18] <beach> I said, arguments to functions are evaluated before the function is applied.
[07:45:19] <[itchyjunk]> i can connect and ping
[07:45:44] <[itchyjunk]> right
[07:45:56] <beach> That's the same in Python and most other languages. 
[07:46:08] <[itchyjunk]> so all 3 would be argument and print statements would be evaluated before if was applied
[07:46:28] <beach> And since things like "if", "while", "for", do not behave like that, they can't be functions. 
[07:46:33] <beach> Yes.
[07:46:40] <[itchyjunk]> oh, evaluation of argument happens first in py too? interesting. never had to think about it this way in py
[07:46:54] <[itchyjunk]> This is a bit trippy
[07:47:03] <beach> Things like that are totally essential if you want to be a programmer.
[07:47:04] <[itchyjunk]> What are they if not functions then?
[07:47:22] <[itchyjunk]> like they are built differently
[07:47:24] <[itchyjunk]> into the language?
[07:47:27] <beach> In Common Lisp they look exactly like functions, but they are special operators. 
[07:47:52] <beach> In other languages, they may not call them that, but they have their own syntax, to distinguish them from functions. 
[07:48:12] <beach> Yes, they are handled specially by the compiler. 
[07:48:24] <[itchyjunk]> interesting
[07:48:27] <beach> So "built into the language" is a good characterization. 
[07:49:09] <[itchyjunk]> So this is the types of problem someone creating a language or a compiler thinks abobut, i suppose
[07:49:17] <beach> Totally.
[07:50:00] <beach> So in the case of QUOTE in Common Lisp, it is a special operator that has takes a single argument and it returns that argument unevaluated. 
[07:50:28] <[itchyjunk]> oh i see
[07:50:56] <beach> So if you type (print (+ 2 3)), since print is a function, (+ 2 3) gets evaluated before print is called, and 5 is printed.
[07:51:02] <[itchyjunk]> so (Quote (print "stuff")) would return (print "stuff") and if it were a function, it would return stuff
[07:51:16] <[itchyjunk]> this makes sense
[07:51:22] <beach> But if you type (quote (+ 2 3)) you get the list (+ 2 3) because it was not evaluated.
[07:51:30] <beach> Yes.
[07:52:16] <[itchyjunk]> list is an array like object or data structure right? so the list (+ 2 3) is a set with 3 elements? +, 2 and 3 ?
[07:52:16] <beach> It's really that simple in Common Lisp.  It is way more messed up in other languages. 
[07:52:42] <beach> Almost, but you need to work on your terminology.  
[07:52:58] <beach> An array is a data structure that allows random access at O(1) complexity.
[07:52:59] <[itchyjunk]> ordered set? :s
[07:53:17] <beach> A list is a linked data structure with O(n) access complexity.
[07:53:34] <beach> A set is totally different because it has no duplicate elements, and the elements are not ordered.
[07:53:44] <[itchyjunk]> hmmmm
[07:54:17] <[itchyjunk]> Ah, what about ordered multiset?
[07:54:18] <beach> Again, this is not Common Lisp specific.  Just general programming, algorithms, and data structures. 
[07:54:33] <beach> Still unordered, but allows duplicate elements.
[07:55:36] <beach> It doesn't make sense to ask for the i:th element of a multiset. 
[07:55:43] <beach> But it does for an array and a list.
[07:56:12] <[itchyjunk]> hmm a vector or a row matrix would have these properties?
[07:56:44] <beach> Yes, a vector is a special case of an array in that it has a single dimension. 
[07:57:50] <beach> I need to vanish for 20 minutes or so.  If you have more questions and you are in a rush, you need to hope that someone else can answer those questions. 
[08:00:12] <[itchyjunk]> I am not in a rush
[08:00:21] <[itchyjunk]> I doubt i can learn this stuff quickly anyways
[08:01:06] <White_Flame> an "ordered set" in datastructures often means that the elements within the set are always ordered with respect to each other
[08:01:23] <White_Flame> eg, add 2 to {1 3} and get {1 2 3}, retaining the ordering when you traverse the set
[08:02:05] <[itchyjunk]> that kinda seems consistent with ordering in math, right?
[08:02:08] <White_Flame> as opposed to remembering the initial insertion order of the elements
[08:02:28] <White_Flame> where {1 3}, add 2, and traversal would be specifically ordered as 1, 3, 2
[08:02:30] <[itchyjunk]> ah
[08:02:57] <[itchyjunk]> or {2,1,3} maybe?
[08:03:05] <[itchyjunk]> Are data structures mathematical objects?
[08:03:37] <White_Flame> so specifically speaking, the answer to  "so the list (+ 2 3) is a set with 3 elements?" is no
[08:04:22] <White_Flame> because sets are usually unordered/unsorted collections where each element is independdent
[08:04:52] <White_Flame> a list is a conceptual sequence of its items.  In Lisp, a "list" is specifically a bunch of cons cells which hold (<value> . <next cell)
[08:05:30] <[itchyjunk]> Ah okay, sequence i vaguely know
[08:05:59] <[itchyjunk]> so (+ 2 3) would be a finite sequence with 3 elements ?
[08:06:10] <White_Flame> "Data structures" are often used both for the conceptual notion of an arrangement, as well as engineering the concrete form in a specific programming language
[08:06:21] <White_Flame> yes
[08:06:39] <[itchyjunk]> Would then i also care what each element of that sequence is in terms of it's err "structure" ? like + would be a symbol and 2 and 3 numbers?
[08:06:54] <White_Flame> but in Lisp, it is always and concretely 3 cons cells.  (1 . (2 . (3 . NIL)))
[08:07:05] <White_Flame> (unless you redefined that part of the reader algorithm)
[08:07:06] <[itchyjunk]> hmm
[08:07:29] <White_Flame> erm, (+ . (2 . (3 . NIL)))
[08:07:52] <White_Flame> that list is the source code of that form which the compiler will turn into machine code or whatever
[08:08:14] <White_Flame> and is one of the very few "homoiconic" languages where the source code is in the language's literal data format
[08:09:07] <White_Flame> and that's where the macro, metaprogramming, and compiler/interpreter power comes from
[08:11:08] <White_Flame> oh, and as per your last question, the contents do not matter at all to the "listness" of that term
[08:12:03] <beach> Thanks White_Flame.  Nice description. 
[08:12:10] <White_Flame> a list could contain sublists, or internal artifacts, or whatever
[08:12:30] <White_Flame> thanks :)
[08:12:59] <[itchyjunk]> Ah, i might be remembering wrong but in haskell, list did care that things were consistent ?
[08:13:31] <beach> Yes, in statically typed languages, you can't mix things like that.
[08:15:04] <beach> In a statically typed language, the compiler needs to know the exact type of each object, simply because there is no type information available at run time.  So they need to put in various restrictions in order for the compiler to be able to do that.  
[08:16:25] <beach> So in a statically typed language, a list must be known at compile time to contain only elements of a particular type.
[08:17:18] <[itchyjunk]> so the compiler has to know ahead of time that a list will not be changed while the code runs?
[08:17:42] <beach> By the way, Haskell is the one exception to the general rule I mentioned.  In Haskell IF can indeed be a function, because in Haskell, arguments are not evaluated before the function is applied.  This is known as "lazy evaluation".
[08:17:59] <[itchyjunk]> :O
[08:18:01] <beach> The list can be altered, but it can not contain elements of any other type.
[08:19:03] <beach> So if you have a list of integers, you can't insert a floating-point number into it.  Any such attempt must be detectable by the compiler so that the program can be rejected. 
[08:20:41] <beach> In a dynamically typed language like Common Lisp, such checks are (conceptually at least) done at run time.  You may have a vector that can handle only integers, and if you try to insert a floating-point number, you will get a run-time error.
[08:27:18] <[itchyjunk]> ah
[08:28:58] <White_Flame> what languages are you familiar with?
[08:32:00] <[itchyjunk]> None, i've tried a few times to learn programming. I learned php a looong time ago.
[08:32:30] <[itchyjunk]> I've tried py and haskell, managed to get an irc bot kinda working in py.
[08:32:50] <[itchyjunk]> Tried C at some point in my life but pointers threw me off back then. 
[08:33:05] <beach> Then Common Lisp is a good choice because it is way less "magic" than most other languages.  The syntax is totally regular and the rules of evaluation are simple.
[08:33:09] <White_Flame> ok, I tend to try to come up with examples from other languages, but I guess not here then ;)
[08:33:25] <beach> Heh.
[08:33:26] <White_Flame> and yes, CL is harder to learn if you're ossified into other languages
[08:33:34] <[itchyjunk]> Yeah, i wouldn't say i have prior programming experience really
[08:33:44] <[itchyjunk]> i guess the first language i dabbled with was qbasic
[08:34:09] <White_Flame> qbasic/quickbasic were pretty good BASICs, all things considered
[08:34:47] <White_Flame> and I loved the function-oriented instead of file-oriented editor
[08:35:58] <[itchyjunk]> I remember writing a function on it took you to another screen
[08:36:03] <[itchyjunk]> it was not called functions either
[08:36:10] <[itchyjunk]> something else
[08:36:22] <White_Flame> SUBroutines
[08:36:34] <White_Flame> or PROCedures
[08:36:39] <White_Flame> I think it had both, depending on if there was a return value or not
[08:37:03] <[itchyjunk]> subroutines!
[08:37:06] <[itchyjunk]> that's the term
[08:37:07] <[itchyjunk]> ha
[08:37:44] <White_Flame> in some older terminology, each function was a "program"
[08:55:59] *** Quits: jeffrey (~jeffrey@80-115-60-193.cable.dynamic.v4.ziggo.nl) (Ping timeout: 265 seconds)
[09:02:38] *** Quits: [itchyjunk] (~itchyjunk@user/itchyjunk/x-7353470) (Quit: Leaving)
[09:05:03] *** Joins: derelict_ (~derelict@user/derelict)
[09:30:01] *** Joins: Oladon (~olad@98.43.81.226)
[10:14:23] *** Joins: selwyn (~selwyn@user/selwyn)
[10:28:17] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[10:41:11] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[10:50:29] *** Joins: neceve (~quassel@2a02:c7f:607e:d600:f762:20dd:304e:4b1f)
[10:51:21] *** Joins: lottaquestions (~nick@2607:fa49:5040:a300:d5df:d412:bed6:9ef6)
[10:51:42] *** Quits: lottaquestions_ (~nick@2607:fa49:5040:5c00:15ff:5298:25c8:dfb2) (Ping timeout: 252 seconds)
[10:55:37] *** Quits: lottaquestions (~nick@2607:fa49:5040:a300:d5df:d412:bed6:9ef6) (Client Quit)
[10:56:01] *** Joins: lottaquestions (~nick@2607:fa49:5040:a300:d5df:d412:bed6:9ef6)
[11:37:33] *** Joins: shka (~herr@109.231.62.239)
[12:20:15] *** Joins: st_iron (uid370243@id-370243.highgate.irccloud.com)
[12:28:48] *** Joins: treflip (~user@95.79.32.99)
[13:10:43] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 244 seconds)
[13:34:18] *** Joins: makomo (~makomo@user/makomo)
[13:45:11] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[13:48:54] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 276 seconds)
[14:39:17] *** Quits: derelict_ (~derelict@user/derelict) (Ping timeout: 252 seconds)
[14:58:51] *** Joins: random-nick (~random-ni@87.116.182.181)
[15:19:27] *** Joins: silasfox (~sbv@2001-4dd6-abca-0-de39-b264-6870-a7ee.ipv6dyn.netcologne.de)
[15:21:22] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-10-70-54-112-49.dsl.bell.ca)
[15:30:52] *** Joins: ahc (~ahc@121.98.229.241)
[15:42:38] *** Joins: [itchyjunk] (~itchyjunk@user/itchyjunk/x-7353470)
[15:50:10] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[15:53:06] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 240 seconds)
[16:03:54] *** Quits: silasfox (~sbv@2001-4dd6-abca-0-de39-b264-6870-a7ee.ipv6dyn.netcologne.de) (Ping timeout: 240 seconds)
[16:06:46] *** Joins: silasfox (~sbv@xdsl-87-78-183-74.nc.de)
[16:12:16] *** Joins: selwyn (~selwyn@user/selwyn)
[16:13:00] *** Quits: selwyn (~selwyn@user/selwyn) (Remote host closed the connection)
[16:13:26] *** Joins: selwyn (~selwyn@user/selwyn)
[17:03:30] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-10-70-54-112-49.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[17:22:45] *** Quits: silasfox (~sbv@xdsl-87-78-183-74.nc.de) (Ping timeout: 252 seconds)
[17:24:39] *** Joins: silasfox (~sbv@2001-4dd6-8e13-0-6f0d-fa0c-ffdd-c563.ipv6dyn.netcologne.de)
[17:56:33] *** Quits: silasfox (~sbv@2001-4dd6-8e13-0-6f0d-fa0c-ffdd-c563.ipv6dyn.netcologne.de) (Ping timeout: 276 seconds)
[17:57:50] *** Joins: silasfox (~sbv@2001-4dd6-abca-0-de39-b264-6870-a7ee.ipv6dyn.netcologne.de)
[18:14:48] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[18:15:59] *** Quits: silasfox (~sbv@2001-4dd6-abca-0-de39-b264-6870-a7ee.ipv6dyn.netcologne.de) (Ping timeout: 252 seconds)
[18:41:28] *** Quits: ahc (~ahc@121.98.229.241) (Ping timeout: 246 seconds)
[18:52:27] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 276 seconds)
[18:56:20] *** Joins: jeffrey (~jeffrey@80-115-60-193.cable.dynamic.v4.ziggo.nl)
[19:23:15] *** Quits: treflip (~user@95.79.32.99) (Remote host closed the connection)
[19:29:18] *** Joins: Josh_2 (~user@37.25.47.130)
[19:30:01] *** Joins: fef (~thedawn@user/thedawn)
[19:30:04] *** Quits: st_iron (uid370243@id-370243.highgate.irccloud.com) (Quit: Connection closed for inactivity)
[19:32:31] *** Joins: thrig (~thrig@65.113.153.50)
[19:57:54] *** Joins: hendursaga (~weechat@user/hendursaga)
[20:11:42] *** Joins: derelict_ (~derelict@user/derelict)
[20:15:28] *** Joins: zos (~zos@ool-457a8044.dyn.optonline.net)
[20:17:12] <beach> zos: Do you have experience in programming from any other languages? 
[20:21:52] *** Joins: rain3 (~rain3___@2a02:2f09:d30b:1300:a270:4060:876f:9f40)
[20:30:21] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[20:31:09] *** Quits: thrig (~thrig@65.113.153.50) (Remote host closed the connection)
[20:31:18] *** Joins: thrig (~thrig@65.113.153.50)
[20:33:34] *** Joins: silasfox (~sbv@2001-4dd6-abca-0-de39-b264-6870-a7ee.ipv6dyn.netcologne.de)
[20:41:34] <zos> beach: not a huge amount
[20:42:56] <beach> I see.  Let's hope PCL is OK then.  It kind of assumes prior experience. 
[20:43:58] <thrig> gentle intro to symbolic computation is good to work through
[20:44:40] <beach> I don't like it much, but some people do.  And it is more basic, for sure.
[20:48:22] <zos> well if I start running into problems I will keep that in mind. I recently started learning python (and am begining to be able to use it) by reading dive into python, and whenever I felt I was in over my head reading up on the topic in a more beginner friendly book
[20:52:08] <beach> Right.  It depends on your preferred technique for learning.  Some people never open a book and keep asking use until the presumably get it.
[20:53:38] *** Joins: sgithens (sid10659@id-10659.brockwell.irccloud.com)
[20:53:39] <[itchyjunk]> I would like to be in that group :s
[20:53:54] <[itchyjunk]> I generally end up procastinating and not getting anything done if i have to read books
[20:54:05] <[itchyjunk]> i find asking in irc to be so much more comfertable
[20:54:12] <zos> I tend to learn faster if I can sit down with the book/documentation and some sort of project or a bunch of exercises and puzzle it out myself. 
[20:54:30] <beach> [itchyjunk]: But you put a lot of burden on others that way.  They may very well get tired of your questions. 
[20:54:37] <[itchyjunk]> Sure
[20:54:58] <[itchyjunk]> I don't expect anyone to answer. whoever wants to can, though
[20:58:21] <zos> Though for things like my previous question - 'what should I learn?' it is better to ask people who have experience. In areas like tooling books can get outdated fairly fast
[20:59:41] <beach> zos: You are in luck, then.  I find that people who know Common Lisp are on the average more knowledgeable and more experienced with programming than other groups of programmers.
[21:00:21] <[itchyjunk]> People in FP circles say the same :P
[21:00:28] <beach> zos: This is not because Common Lisp makes people more experienced.  It's the other way around.  More knowledgeable and more experienced people are the ones who tend to want to look into Common Lisp.
[21:00:42] <beach> [itchyjunk]: Yes, that is probably the case.
[21:01:19] <beach> Anything that is a bit out of the ordinary is usually off limits for inexperienced people, so there is an automatic selection there.
[21:01:28] <[itchyjunk]> true
[21:04:06] <zos> well ssometimes obscure software can become trendy with a subset of people - while it is probably not a large group I have noticed on places like youtube that various window managers that are fairly obscure become the flavor of the week
[21:10:44] *** Quits: fef (~thedawn@user/thedawn) (Remote host closed the connection)
[21:11:24] *** Joins: fef (~thedawn@user/thedawn)
[21:16:23] *** Joins: dickbar__ (~dickbaren@86-90-132-28.fixed.kpn.net)
[21:19:27] *** Joins: DBa (~dickbaren@86-90-132-28.fixed.kpn.net)
[21:24:23] <zos> strangly enough it was the number of tutorials that I came accross as well as how readable I found Practical Common Lisp that drew me in. When I was looking up Lisp tutorials a few weeks ago my plan was to start by learning Scheme or E-Lisp as I thought that they would be the easiest to learn
[21:27:54] *** Joins: tyson2 (~user@toroon12-3096782677.sdsl.bell.ca)
[21:28:41] <zos> beach: You mentioned not liking Gentle Intro to ymbolic Computation, is there a book for inexperienced beginners you would recomend instead?
[21:30:45] <rain3> I liked On Lisp by Paul Graham even as a beginner   
[21:31:12] <tyson2> I am using Practical Common Lisp, which is not supposed to be a beginner's book
[21:31:19] <tyson2> I learned Scheme before though
[21:31:59] <tyson2> I also just found some recorded lectures from a Danish university, in English, which cover Common Lisp in thrree lectures, quite well I think
[21:33:12] <tyson2> going to do a deep dive on those lectures and PCL this weekend, I like doing things in big chunks. If it drags out too long that begins to drag
[21:34:25] <zos> I have started with Practical Common Lisp as well and am enjoying working through it
[21:34:43] <rain3> tyson2 can you please give a link to those lectures ?
[21:46:27] <pjb> zos: well, I have a different opinion than beach; learning CL does make people more experienced.  Ok, not exactly CL the language, but CL the ecosystem does.  If only because lisp has a longer history so you learn a lot about past systems and techniques; but also because lisp is used in a lot of domains that other languages can't really touch.  
[21:46:43] <pjb> zos: have a look at http://franz.com/success to see the diversity of applications.
[21:49:01] <pjb> zos: when you learn C or C++, you learn about pointers, memory management, OS interfaces, some data structures and algorithms, some unix history.  But when you learn CL and lisp, you learn about a lot of new concepts, and even more data structures and algorithms, different programming styles (OO, functional, declarative, DSL, etc).
[21:49:19] <pjb> zos: put sicl on your reading list, and your brain will explode when you study it.
[21:49:29] <rain3> haha
[21:50:42] <pjb> s/sicl/sicp/  sicp = Structure and Interpretation of Computer Programs  http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html  http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/
[21:52:45] *** Quits: rain3 (~rain3___@2a02:2f09:d30b:1300:a270:4060:876f:9f40) (Remote host closed the connection)
[21:53:00] <pjb> zos: as tutorial, I like the implementation provided tutorials mentionned on https://cliki.net/Online+Tutorial
[21:53:04] <thrig> probably because they put unsolved problems into the exercises for the first chapter
[21:53:33] *** Joins: rain3_ (~rain3___@2a02:2f09:d30b:1300:a270:4060:876f:9f40)
[21:53:52] <pjb> zos: also, PAIP as a nice introduction to CL (a whole part is consacred to CL, the rest re-implement in CL classical AI algorithms, a nice example of how you learn more and become more experienced by learning the CL ecosystem).
[21:54:15] <pjb> paip = Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp
[21:54:26] *** rain3_ is now known as rain3
[21:59:38] *** Quits: [itchyjunk] (~itchyjunk@user/itchyjunk/x-7353470) (Remote host closed the connection)
[21:59:56] <zos> Thank you, I now have a fairly long reading list
[21:59:58] <pjb> tyson2: would that be: https://www.youtube.com/watch?v=VWARj-nbxFM&list=PLDV0fv5m475a2OA-0ZWG4N8hVHeaAp3zI ?
[22:00:15] <pjb> rain3: ^
[22:01:08] <rain3> thank you
[22:05:23] <rain3> oh you're asking me "would that be?" 
[22:05:31] <rain3> would that be what 
[22:08:05] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[22:12:59] <pjb> rain3: the "danish university" video?
[22:13:06] <pjb> It's actually from Oslo University.
[22:13:42] <pjb> It's referenced in https://cliki.net/Lisp+Videos
[22:14:24] <rain3> oh , okay
[22:15:00] <rain3> then I am gonna share this http://faculty.chas.uni.edu/~wallingf/teaching/172/materials/session13/ 
[22:22:08] <pjb> rain3: perhaps you should link it from cliki?
[22:23:30] <rain3> good idea
[22:29:10] <rain3> I've registered an account on cliki , I don't seem to have permissions to edit https://www.cliki.net/Online%20tutorial   , so I can't link from cliki 
[22:29:42] *** Quits: zos (~zos@ool-457a8044.dyn.optonline.net) (Quit: Leaving)
[22:35:37] <tyson2> pjb: yes that's the one.  Very nicely done
[22:38:42] <pjb> rain3: I don't know how/if a registration process is needed to edit the clikiâ€¦
[22:38:59] <pjb> rain3: you can ask in #common-lisp.net
[22:39:37] *** Quits: thrig (~thrig@65.113.153.50) (Remote host closed the connection)
[23:05:01] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[23:25:10] *** Joins: selwyn (~selwyn@user/selwyn)
[23:30:52] *** Quits: tyson2 (~user@toroon12-3096782677.sdsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[23:37:52] *** Quits: fef (~thedawn@user/thedawn) (Quit: Leaving)
[23:41:30] *** Quits: rain3 (~rain3___@2a02:2f09:d30b:1300:a270:4060:876f:9f40) (Ping timeout: 240 seconds)
[23:54:54] *** Quits: neceve (~quassel@2a02:c7f:607e:d600:f762:20dd:304e:4b1f) (Ping timeout: 256 seconds)
[23:56:19] *** Quits: derelict_ (~derelict@user/derelict) (Quit: WeeChat 3.2)
