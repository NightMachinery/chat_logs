[00:12:01] *** Joins: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net)
[00:14:03] *** Quits: gproto23 (~gproto23@user/gproto23) (Remote host closed the connection)
[00:16:32] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 272 seconds)
[00:17:54] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[00:19:21] *** Joins: seninha (~seninha@user/seninha)
[00:30:22] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[00:30:50] *** Joins: badkins (~badkins@136.56.92.199)
[00:31:40] *** Quits: rx80 (~quassel@user/rx80) ()
[00:33:49] *** Joins: rx80 (~quassel@user/rx80)
[00:34:07] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[00:34:11] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 256 seconds)
[00:34:17] *** Joins: badkins (~badkins@136.56.92.199)
[00:34:21] <dpk> the difference between letrec and letrec* is just the order the expressions are evaluated, right? letrec* guarantees left-to-right, and letrec is implementation-specific?
[00:36:17] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[00:36:59] <dpk> (so an implementation where letrec is just an alias for letrec* is valid?)
[00:40:49] <Franciman> re r7rs-small amirite?
[00:41:12] <Franciman> then ye
[00:41:15] <Franciman> yes
[00:42:38] <Franciman> ah dpk wait
[00:43:24] <Franciman> there is some hard jargon i can't understand about some restrictions
[00:45:58] <Franciman> dpk: there is a subtlelty i can't quite understand
[00:46:15] <Franciman> One restriction on letrec is very important: if it is not
[00:46:18] <Franciman> possible to evaluate each 〈init〉 without assigning or refer-
[00:46:20] <Franciman> ring to the value of any 〈variable〉, it is an error. 
[00:46:21] <Franciman> while for letrec*
[00:47:29] <Franciman> it says that it is an error if it's not possible each (init) without assigning or referring to the value of each <variable> following it
[00:48:23] <Franciman> Another restriction is that it is an error to invoke the continuation of an (init) more than once
[00:48:28] <Franciman> so uhm....
[00:48:54] <Franciman> not super sure letrec* is compatible with letrec restrictions?
[00:49:42] <jrincayc> It might help if you look at 7.3 and see how they are defined.  In letrec* all the variables are initially defined as <undefined> so they at least can be referred to anywhere.
[00:53:00] <Franciman> ah ok the restriction on the invocation of continuation doesn't make sense in letrec
[00:53:12] <Franciman> i suppose
[00:56:02] <Zipheir> dpk: I believe that's accurate.
[00:56:27] *** Joins: alMalsamo (~alMalsamo@gateway/tor-sasl/almalsamo)
[00:57:06] *** alMalsamo is now known as littlebobeep
[00:57:14] *** Joins: wnklmnn (~wnklmnn@2a02:908:4e2:9740:d2a2:766d:5ff9:d663)
[00:57:59] <Zipheir> Assuming you don't care about enforcing letrec's restriction strictly.
[01:04:40] *** Quits: torbjornsd (~torbjorns@213.158.54.253) (Quit: Leaving)
[01:07:56] *** Joins: civodul (~user@guix/contributor/civodul)
[01:19:31] *** Quits: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net) (Ping timeout: 256 seconds)
[01:27:07] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 260 seconds)
[01:28:53] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[01:44:48] *** Joins: klovett (~klovett@107.116.92.147)
[01:48:35] *** Quits: klovett_ (~klovett@107.116.92.147) (Ping timeout: 260 seconds)
[01:53:15] *** Quits: poselyqualityles (~whirl@user/poselyqualityles) (Ping timeout: 260 seconds)
[01:53:16] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[02:00:55] *** Quits: m455 (~m455@user/m455) (Quit: WeeChat 3.0)
[02:13:35] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 240 seconds)
[02:15:36] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[02:16:21] *** Joins: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net)
[02:20:51] *** Joins: badkins (~badkins@136.56.92.199)
[02:25:25] *** Quits: jobol (~jobol@2a01:e34:ee5c:ee50:d6be:d9ff:fea3:db03) (Quit: Leaving)
[02:31:33] *** Joins: m455 (~m455@user/m455)
[02:31:48] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 240 seconds)
[02:37:30] <seninha> hello, do you know scheme-based languages (not scheme implementations, and not necessarily scheme-compatible) which are also minimalist?
[02:37:40] <seninha> I want to create a scheme-like language with currying and other ideas but I'd also like to see other people's work.
[02:39:19] <seninha> I found this one: https://github.com/ympbyc/Carrot
[02:40:10] *** Joins: wonko-the-sane (~wonk-the-@gateway/tor-sasl/wonko-the-sane)
[02:44:05] *** Joins: badkins (~badkins@136.56.92.199)
[02:44:12] <Zipheir> seninha: You may want to look at the extensions to the Scheme interpreter in Ch. 4 of SICP.
[02:45:47] <Zipheir> seninha: It depends on what you mean by "minimalist".  If you mean "small language", then start with a lambda calculus interpreter and experiment.
[02:48:22] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[02:48:31] *** Joins: badkins (~badkins@136.56.92.199)
[02:55:23] <seninha> I'm looking for small language experiments based/influenced on scheme 
[02:55:53] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[03:04:02] <wasamasa> how would you know they're based on scheme?
[03:04:03] *** Joins: poselyqualityles (~whirl@user/poselyqualityles)
[03:05:17] <Zipheir> seninha: What specific properties of Scheme?  First-class continuations?
[03:06:02] <Zipheir> seninha: It makes (more?) sense to talk about language features without talking about <language> which happens to have them.
[03:06:36] <wasamasa> there are plenty of tiny lisps, but they don't necessarily have to be rooted in scheme
[03:06:52] <wasamasa> maru is one of those and if you look into it, you realize it's more of a smalltalk
[03:07:18] <Zipheir> Just about anything can be fitted with S-exps...
[03:08:29] <Zipheir> All of the languages I've been writing for EoPL have an S-exp syntax.  Why?  Because I'm lazy and read-ing and pattern-matching are easier than generating a parser.
[03:08:57] <Zipheir> So they're Lisps, though they look like MLs in the book.
[03:09:54] <Zipheir> You realize that languages are really very fluid.
[03:10:15] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 240 seconds)
[03:10:34] *** Quits: atka (~atka@static-198-54-131-84.cust.tzulo.com) (Quit: WeeChat 3.4)
[03:18:24] <Zipheir> seninha: You might take a look at picoLisp.  It's very much anti-Scheme, though.
[03:19:33] *** Joins: klovett_ (~klovett@107.116.92.147)
[03:20:48] <Zipheir> No, it's not picoLisp I'm thinking of.  There was some minimal Lispy language written by someone wasamasa called "a crazy german".
[03:21:00] <wasamasa> picolisp, yes
[03:21:20] <wasamasa> the implementation is pretty bare
[03:21:33] <wasamasa> it has only three types
[03:21:38] <Zipheir> Ok, it was picolisp.
[03:21:55] <edgar-rft> tinylisp is based on scheme and it's only 1302 lines of code -> https://github.com/matp/tiny-lisp
[03:22:23] <wasamasa> segfaults are not considered a bug
[03:22:36] *** Quits: klovett (~klovett@107.116.92.147) (Ping timeout: 240 seconds)
[03:22:51] <wasamasa> you're expected to write careful programs to make the most of it
[03:23:03] <wasamasa> the assembler implementation is quite fast for an interpreter
[03:23:31] <edgar-rft> segfaults are the natural way how C programs work :-)
[03:24:32] <Zipheir> To paraphrase ken, the thinking programmer will usually know what's wrong. :)
[03:25:11] <mdhughes> I usually know exactly why my programs don't work, because I've written just a small part, or I'm running tests…
[03:25:20] *** Joins: atka (~atka@static-198-54-131-84.cust.tzulo.com)
[03:26:36] <mdhughes> But if I'm doing a long stretch of new, untested code, it's sure handy to have a debugger that can tell me where/context it happened.
[03:27:40] <edgar-rft> umm, the readme from my tinylisp link above uses setq and stuff what is definitely *not* scheme syntax, but I'm quite sure that I had a tinylisp with scheme syntax approx. ten yearsago :-(
[03:28:28] <mdhughes> tinyscheme, perhaps? I use it sometimes, it's not fancy but it's Schemey.
[03:29:05] <mdhughes> http://tinyscheme.sourceforge.net/home.html
[03:29:15] <Zipheir> TinyScheme is cool.
[03:29:57] <edgar-rft> mdhughes: yes, thanx, exactly that was I meant
[03:30:08] <Zipheir> It's still amazing to me that GIMP uses it, even if the embedding is rather nasty.
[03:31:17] * mdhughes is off to bed now
[03:31:29] <Zipheir> 'night.
[03:31:42] <edgar-rft> GIMP Script-Fu (using tinyscheme) is 99.99% GIMP FFI plus a tiny bit of scheme
[03:31:48] *** Joins: mnieper (~user@ipbcc1ad82.dynamic.kabel-deutschland.de)
[03:32:38] <Zipheir> Yeah, and, as I say, the GIMP interface isn't pretty.
[03:33:01] <Zipheir> But how many other big-but-useful programs like that use Scheme at all?
[03:33:15] <edgar-rft> lilypond uses guile
[03:33:26] <Zipheir> Yes, that's the other one.
[03:34:15] <Zipheir> I still don't really understand Lilypond's use of Scheme.
[03:34:37] <Zipheir> It's a compiler with an embedded scripting language?
[03:37:37] <edgar-rft> I'm not so sure the lilypond developers have understood that themselves. Lilypond is basically tools piled on tools piled on other tools and I assume they decided to use guile because it was promoted as "the standard GNU scripting language".
[03:38:41] *** Quits: civodul (~user@guix/contributor/civodul) (Ping timeout: 256 seconds)
[03:40:26] *** Quits: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net) (Ping timeout: 246 seconds)
[03:42:21] <Zipheir> edgar-rft: Probably so.  I started to study the source once and ... ran away.  It produces amazing-looking scores, though.
[03:44:59] *** Quits: poselyqualityles (~whirl@user/poselyqualityles) (Ping timeout: 246 seconds)
[03:57:34] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 272 seconds)
[03:57:36] *** Joins: badkins (~badkins@136.56.92.199)
[03:59:08] *** Joins: aeth (~aeth@user/aeth)
[03:59:12] *** Quits: wnklmnn (~wnklmnn@2a02:908:4e2:9740:d2a2:766d:5ff9:d663) (Quit: Leaving)
[04:02:08] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 246 seconds)
[04:03:55] *** Quits: wonko-the-sane (~wonk-the-@gateway/tor-sasl/wonko-the-sane) (Ping timeout: 240 seconds)
[04:27:03] *** Joins: wonko-the-sane (~wonk-the-@gateway/tor-sasl/wonko-the-sane)
[04:27:36] *** Joins: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net)
[04:37:15] *** Quits: wonko-the-sane (~wonk-the-@gateway/tor-sasl/wonko-the-sane) (Ping timeout: 240 seconds)
[04:45:08] *** Quits: mnieper (~user@ipbcc1ad82.dynamic.kabel-deutschland.de) (Remote host closed the connection)
[04:48:23] *** Quits: seninha (~seninha@user/seninha) (Quit: Leaving)
[05:04:29] *** Joins: wonko-the-sane (~wonk-the-@gateway/tor-sasl/wonko-the-sane)
[05:41:14] *** Joins: frost (~frost@user/frost)
[05:43:08] *** Quits: wonko-the-sane (~wonk-the-@gateway/tor-sasl/wonko-the-sane) (Remote host closed the connection)
[05:43:33] *** Joins: wonko-the-sane (~wonk-the-@gateway/tor-sasl/wonko-the-sane)
[05:44:53] *** Quits: wonko-the-sane (~wonk-the-@gateway/tor-sasl/wonko-the-sane) (Client Quit)
[05:45:07] *** Joins: wonko-the-sane (~wonk-the-@gateway/tor-sasl/wonko-the-sane)
[05:55:59] *** Quits: Zipheir (~wcm@98.4.178.27) (Quit: X reconfiguration, fun... brb.)
[06:12:35] *** Quits: wonko-the-sane (~wonk-the-@gateway/tor-sasl/wonko-the-sane) (Ping timeout: 240 seconds)
[06:13:13] *** Quits: m455 (~m455@user/m455) (Quit: WeeChat 3.0)
[06:14:17] *** Joins: m455 (~m455@user/m455)
[06:14:34] *** Joins: wonko-the-sane (~wonk-the-@gateway/tor-sasl/wonko-the-sane)
[06:16:30] *** Joins: Zipheir (~wcm@98.4.178.27)
[06:21:37] *** Quits: mala (~mala@user/malaclyps) (Read error: Connection reset by peer)
[06:22:53] *** Joins: mala (~mala@user/malaclyps)
[06:23:11] *** Quits: schulze (~schulze@dynamic-077-010-018-099.77.10.pool.telefonica.de) (Ping timeout: 246 seconds)
[06:31:35] *** Quits: wonko-the-sane (~wonk-the-@gateway/tor-sasl/wonko-the-sane) (Ping timeout: 240 seconds)
[06:32:03] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 260 seconds)
[06:33:33] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[06:33:50] *** Joins: wonko-the-sane (~wonk-the-@gateway/tor-sasl/wonko-the-sane)
[06:42:32] *** Quits: jrincayc (~Thunderbi@38.70.240.202.sumofiber.net) (Ping timeout: 260 seconds)
[06:47:51] *** Joins: badkins (~badkins@136.56.92.199)
[06:52:12] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 240 seconds)
[06:54:54] *** Joins: ahungry (~user@c-68-51-134-46.hsd1.mi.comcast.net)
[07:17:03] *** Joins: gproto23 (~gproto23@user/gproto23)
[07:34:35] *** Quits: wonko-the-sane (~wonk-the-@gateway/tor-sasl/wonko-the-sane) (Ping timeout: 240 seconds)
[07:37:17] *** Joins: wonko-the-sane (~wonk-the-@gateway/tor-sasl/wonko-the-sane)
[08:38:23] *** Quits: klovett_ (~klovett@107.116.92.147) (Quit: Textual IRC Client: www.textualapp.com)
[08:45:53] *** Quits: gproto23 (~gproto23@user/gproto23) (Remote host closed the connection)
[08:48:17] *** Joins: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb)
[09:04:55] *** Quits: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net) (Ping timeout: 260 seconds)
[09:38:58] *** Joins: hashfunce31 (~user@2601:5c0:c280:7090:4533:6252:8e32:243)
[09:56:56] *** Quits: ahungry (~user@c-68-51-134-46.hsd1.mi.comcast.net) (Remote host closed the connection)
[10:45:13] *** Quits: hashfunce31 (~user@2601:5c0:c280:7090:4533:6252:8e32:243) (Remote host closed the connection)
[10:49:47] *** Joins: badkins (~badkins@136.56.92.199)
[10:51:38] *** Quits: skapata (~Skapata@user/skapata) (Ping timeout: 260 seconds)
[10:54:12] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 240 seconds)
[11:02:37] *** Joins: gproto23 (~gproto23@user/gproto23)
[11:12:59] *** Quits: yagamisato (~SingSong@user/yagamisato) (Ping timeout: 252 seconds)
[11:14:35] *** Joins: yagamisato (~SingSong@221.179.69.238)
[11:14:35] *** Quits: yagamisato (~SingSong@221.179.69.238) (Changing host)
[11:14:35] *** Joins: yagamisato (~SingSong@user/yagamisato)
[11:20:11] *** Quits: Madsy (~madsy@223.239.164.82.customer.cdi.no) (Ping timeout: 256 seconds)
[11:20:41] *** Joins: Madsy (~madsy@223.239.164.82.customer.cdi.no)
[11:35:57] *** Quits: clacke (88d96f2df3@knopi.disroot.org) (Remote host closed the connection)
[11:58:53] <dpk> wondering how useful a Scheme xargs would be
[11:59:41] <dpk> sprich: the problem with (apply + ls) is that if ls is bigger than your Scheme allows for an argument list, it will fail
[12:00:10] <dpk> you can use (reduce + ls) instead, but that wastes cycles on only calling + on two elements from ls at once
[12:01:33] <dpk> so (xargs + ls) (needs a better name, maybe 'monoid-apply' or something) applies + to as many elements of ls at once as the Scheme system allows, then applies the result of that to the next maximum number of elements of ls at once, etc
[12:03:31] *** Quits: gproto23 (~gproto23@user/gproto23) (Remote host closed the connection)
[12:12:35] *** Quits: wonko-the-sane (~wonk-the-@gateway/tor-sasl/wonko-the-sane) (Ping timeout: 240 seconds)
[12:19:26] *** Joins: wonko-the-sane (~wonk-the-@gateway/tor-sasl/wonko-the-sane)
[12:37:43] *** Quits: Madsy (~madsy@223.239.164.82.customer.cdi.no) (Ping timeout: 260 seconds)
[12:41:53] *** Quits: zwr (~zwr@2804:d45:b966:fb00:218f:feb0:93c2:196c) (Ping timeout: 260 seconds)
[12:50:49] *** Joins: zwr (~zwr@2804:d45:b966:fb00:855e:197b:3580:2fd7)
[13:02:47] *** Joins: mange (~user@n114-78-12-98.bla3.nsw.optusnet.com.au)
[13:02:47] *** Quits: mange (~user@n114-78-12-98.bla3.nsw.optusnet.com.au) (Changing host)
[13:02:47] *** Joins: mange (~user@user/mange)
[13:10:52] *** Joins: s-liao (~s-liao@101.86.164.158)
[13:13:44] *** Quits: Perryman (~perryman@user/perryman) (Ping timeout: 246 seconds)
[13:17:02] *** Joins: skapata (~Skapata@2804:14c:87b0:9d2e:8be:80a5:9f91:16e)
[13:17:02] *** Quits: skapata (~Skapata@2804:14c:87b0:9d2e:8be:80a5:9f91:16e) (Changing host)
[13:17:02] *** Joins: skapata (~Skapata@user/skapata)
[13:21:34] *** Quits: s-liao (~s-liao@101.86.164.158) (Ping timeout: 250 seconds)
[13:23:21] *** Joins: Perryman (~perryman@user/perryman)
[13:27:40] *** Quits: skapata (~Skapata@user/skapata) (Remote host closed the connection)
[13:29:22] *** Joins: s-liao (~s-liao@101.86.164.158)
[13:43:15] *** Quits: atka (~atka@static-198-54-131-84.cust.tzulo.com) (Quit: zzz)
[14:02:34] *** Quits: kopiyka (~user@2001:983:fe8b:1:b26e:bfff:fe2b:503f) (Remote host closed the connection)
[14:02:54] *** Joins: kopiyka (~user@2001:983:fe8b:1:b26e:bfff:fe2b:503f)
[14:07:07] <amazigh> xargs is an optimization.
[14:08:07] <amazigh> never hit the *error* of passing to much args to apply, maybe guile and chez do pass args via register *and* memory
[14:08:53] <amazigh> also xargs will be difficult or too much trouble to explain.
[14:10:01] <amazigh> similar to how tail-calling, imo, is too much burden on the user.
[14:11:40] <amazigh> regarding limits, and documented limits, I know I have a narrow overall experience, at severa occasions, I noticed limits are not documented.
[14:14:59] <amazigh> I have two examples that come to mind
[14:15:06] <amazigh> 1) Until some version of python 3.x, json.loads was crashing when there is too much nested object, the new behavior is to raise an exception
[14:16:30] <amazigh> 2) On the topic of databases, the maximum size of a transaction was an unknown concept to me. IndexedDB, a new take on the topic, barely scratched the surface.
[14:18:12] <amazigh> My point is, yeah, they are limits, several implementations may have different limits, but that does not prohibit to port a program from on impl to another.
[14:18:56] <amazigh> another point is: whether are limits are documented, does not necessarly translate into industrial success (if that is the goal of documenting all limits)
[14:20:06] <amazigh> I think SQL standard is a good example, but other might know better, please chime in ;)
[14:23:37] <mdhughes> I don't think enough operations are transitive for xargs to be safe. Other than + and *, a lot of them will fail in xargs that don't fail in apply (other than too-long arg lists).
[14:25:32] <mdhughes> And as optimization, presumably a good Scheme impl will produce the same ASM loop for (apply + ls) with 10,000 items as (reduce + ls)
[14:29:10] <mdhughes> Actually, apply is far worse: https://paste.debian.net/1236528/
[14:30:35] <dpk> huh, interesting
[14:31:00] <mdhughes> Might be a quirk of Chez at non-optimizing REPL, but I guess it copies the arg list!
[14:31:17] <dpk> yeah, probably
[14:36:38] *** Joins: gproto23 (~gproto23@user/gproto23)
[14:36:50] *** Quits: gproto23 (~gproto23@user/gproto23) (Remote host closed the connection)
[14:37:29] *** Joins: gproto23 (~gproto23@user/gproto23)
[14:46:58] *** Joins: Madsy (~madsy@223.239.164.82.customer.cdi.no)
[14:51:34] *** Joins: badkins (~badkins@136.56.92.199)
[14:56:19] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 260 seconds)
[15:00:22] *** Quits: frost (~frost@user/frost) (Ping timeout: 250 seconds)
[15:05:43] *** Quits: turlando (~turlando@user/turlando) (Ping timeout: 256 seconds)
[15:06:01] *** Joins: turlando (~turlando@93-42-250-112.ip89.fastwebnet.it)
[15:06:01] *** Quits: turlando (~turlando@93-42-250-112.ip89.fastwebnet.it) (Changing host)
[15:06:01] *** Joins: turlando (~turlando@user/turlando)
[15:07:02] <amazigh> re limits, I can't find a mention of memory error in my html copy of r7rs-small.
[15:11:14] <amazigh> mdhughes: why a lot of operations will fail in xargs and not fail with apply?
[15:13:05] <mdhughes> The first non-transitive operator I can think of is xor. xoring each byte in a list is different from xoring half the list, then the second half, and xoring those results.
[15:13:45] *** Joins: jobol (~jobol@2a01:e34:ee5c:ee50:d6be:d9ff:fea3:db03)
[15:19:54] <amazigh> I missed the transitive part, that is (apply xor (list a b c d e f)) may not be the same as (apply xor (list a b c)) (apply xor (list d e f)), hence (xargs xor objs) is not necessarly the same as (apply values xor objs)\
[15:20:18] <amazigh> let's document that limit ;)
[15:20:37] <amazigh> s/document/specify/g
[15:25:25] <amazigh> changing subject, the world of software engineering came to the realisation that peer-to-peer applications are very complicated, because 1) the paper making popular the xor metric, also documented (or specified!) an optimizing datastructure for the routing table, 2) in other venues, documenting other problems such as 'hole punching'
[15:25:45] <amazigh> Leading to the SOTA that p2p is too difficult ™
[15:27:52] <amazigh> I investigated the topic, most p2p engineers have what I call the senior engineer curse: let's fix all the problem imaginable; instead of the sane: mvp / prototype / tracing bullet approach.
[15:29:07] <amazigh> based on my own experiements, the routing table optimization, only make sense with cpython, and uuid4 starting with more than 10^6 peers.
[15:30:00] <amazigh> another requirement is that udp replies take at most a couple of seconds, IIRC i used 5 seconds.
[15:31:09] <amazigh> and 5 seconds is not a lot since that operation FIND_PEER is rather rare operations compared to the application life, even in the case where you do not solve completly the hole punching problem.
[15:32:26] <amazigh> SOTA is wrong!
[15:44:23] *** Quits: gproto23 (~gproto23@user/gproto23) (Read error: Connection reset by peer)
[15:45:15] *** Joins: gproto23 (~gproto23@user/gproto23)
[16:31:14] *** Joins: Avichi (~Avichi@2a09:80c0:192:0:f8e5:213f:b5c3:abd1)
[16:40:15] *** Joins: badkins (~badkins@136.56.92.199)
[16:44:04] *** Quits: jobol (~jobol@2a01:e34:ee5c:ee50:d6be:d9ff:fea3:db03) (Quit: Leaving)
[16:44:47] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 246 seconds)
[17:16:59] *** Quits: mange (~user@user/mange) (Ping timeout: 246 seconds)
[17:37:32] <edgar-rft> rudybot: using neofarts is the modern way of life!
[17:37:34] <rudybot> edgar-rft: Personally I think modern hardware is fast enough, assuming reasonable algorithms, for anything outside supercomputing class jobs (e.g. weather simulation). Life is short, and you'll waste over a third of it sleeping, using the bathroom, and standing in line. Is it really worth it to waste even more being a slave to the machine, just to improve a number that your users may not care about?
[17:50:42] *** Joins: badkins (~badkins@136.56.92.199)
[17:51:05] *** Quits: gproto23 (~gproto23@user/gproto23) (Remote host closed the connection)
[18:00:12] *** Quits: s-liao (~s-liao@101.86.164.158) (Ping timeout: 250 seconds)
[18:02:45] *** Joins: s-liao (~s-liao@101.86.164.158)
[18:13:08] *** Joins: civodul (~user@guix/contributor/civodul)
[18:17:49] *** Quits: cedb (~ced@user/ouestbillie) (Ping timeout: 256 seconds)
[18:18:12] *** Quits: m455 (~m455@user/m455) (Remote host closed the connection)
[18:19:49] *** Joins: cedb (~ced@user/ouestbillie)
[18:23:36] *** Quits: s-liao (~s-liao@101.86.164.158) (Ping timeout: 250 seconds)
[18:28:46] *** Joins: s-liao (~s-liao@101.86.164.158)
[18:35:34] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[18:41:25] *** Joins: badkins (~badkins@136.56.92.199)
[18:41:26] *** Joins: jdevoo (~jdevoo@0.19.77.83.dynamic.wline.res.cust.swisscom.ch)
[18:52:53] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 246 seconds)
[18:59:36] *** Quits: s-liao (~s-liao@101.86.164.158) (Quit: Client closed)
[19:02:01] *** Quits: jdevoo (~jdevoo@0.19.77.83.dynamic.wline.res.cust.swisscom.ch) (Quit: leaving)
[19:06:48] *** Joins: badkins (~badkins@136.56.92.199)
[19:15:00] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 240 seconds)
[19:16:43] *** Quits: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb) (Quit: ZNC - https://znc.in)
[19:57:31] <Zipheir> dpk: It's fine, provided you're willing to require associativity of the function being applied.  Conventionally, Scheme doesn't talk about such things.
[19:58:22] <dpk> technically, not even Haskell can make sure that <> is associative ;-)
[19:58:27] <Zipheir> dpk: My thought is that it's too special-case, and an optimization that could be better handled by a compiler.
[19:58:47] <Zipheir> True.  The type system is inadequate to express that.
[19:58:50] <dpk> (or maybe it can, idk, seems Halting Problem-y though)
[19:59:17] <Zipheir> In Agda you can do it, I think.
[19:59:49] <dpk> oh, true
[19:59:57] <Zipheir> You pass a proof value along with the function which is evidence that the function is associative.
[20:00:04] <Zipheir> Yay dependent types.
[20:00:40] <Zipheir> But I guess SRFI 1 reduce assumes associativity, and a unit.
[20:00:45] <Zipheir> So there's prior art...
[20:12:48] *** Quits: Avichi (~Avichi@2a09:80c0:192:0:f8e5:213f:b5c3:abd1) (Ping timeout: 250 seconds)
[20:14:38] *** Joins: badkins (~badkins@136.56.92.199)
[20:15:28] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[20:26:58] *** Joins: badkins (~badkins@136.56.92.199)
[20:31:24] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 240 seconds)
[20:34:56] *** Joins: wonko-th1-sane (~wonk-the-@gateway/tor-sasl/wonko-the-sane)
[20:37:15] *** Quits: wonko-the-sane (~wonk-the-@gateway/tor-sasl/wonko-the-sane) (Ping timeout: 240 seconds)
[20:45:45] *** Joins: skapata (~Skapata@2804:14c:87b0:9d2e:90fc:42e8:e764:89e0)
[20:45:46] *** Quits: skapata (~Skapata@2804:14c:87b0:9d2e:90fc:42e8:e764:89e0) (Changing host)
[20:45:46] *** Joins: skapata (~Skapata@user/skapata)
[20:46:25] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[20:46:49] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Client Quit)
[20:53:02] *** Joins: badkins (~badkins@136.56.92.199)
[20:57:31] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 260 seconds)
[21:09:56] *** Joins: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net)
[21:14:00] <sm2n> amazigh: you're implementing kademlia?
[21:16:12] <johnjaye> some of the halting problem statements seem very strange to modern ears
[21:16:25] <johnjaye> like decidability or like godel type stuff
[21:16:33] *** Joins: hhhh92 (~hhhh92@2804:14d:78b1:54b6::1005)
[21:16:41] <johnjaye> it's like... we will prove that we cannot program a computer to mechanically prove our theorems for us.
[21:16:44] *** Joins: badkins (~badkins@136.56.92.199)
[21:23:02] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 246 seconds)
[21:30:54] <sham1> Thus are proofs by contradiction. Not constructive at all
[21:34:21] <Zipheir> Hah.
[21:34:52] <Zipheir> johnjaye: You know that Gödel's incompleteness theorems are essentially functional programs, right?
[21:35:05] <johnjaye> nope
[21:35:11] <johnjaye> explain plz
[21:35:11] <Zipheir> Programs producing statements about the language they're programmed in.
[21:36:14] <Zipheir> By numbering every expression in a simple programming language, Gödel can write a program that manipulates those numbers to "emit" statements in the language.
[21:36:15] <johnjaye> is there a direct correspondence between the halting problem and godel's theorem?
[21:36:24] <pinoaffe> mdhughes: I've never heard of transitive operators, only transitive relations - what do you mean by transitivity in this context?
[21:36:40] <Zipheir> johnjaye: Not direct, but they're related.
[21:36:58] <Zipheir> johnjaye: I have another good talk video for you. :)
[21:37:04] <johnjaye> so like if i set if = 1, else = 2, return = 3, etc and then wrote code in say go that manipulated C programs?
[21:37:24] <sham1> One can actually prove the Gödel result with halting problem
[21:37:39] <Zipheir> Wadler, "Propositions as Types", very entertaining and eye-opening: https://www.youtube.com/watch?v=IOiZatlZtGU
[21:37:46] <pinoaffe> dpk
[21:37:49] <pinoaffe> whoops
[21:38:01] <sham1> Iirc that was what Turing actually did
[21:38:32] <johnjaye> hah. i knew this would turn up on strangeloop
[21:38:33] <Zipheir> johnjaye: Much more extensive than that.  You need to be able to number the sentence that says "'1+1' is an expression in the C programming language".  This can be done.
[21:39:00] <mdhughes> pinoaffe: Transitive operators are covered in Algebra, probably age 12?
[21:39:23] <Zipheir> johnjaye: Then you produce something the sentence "___ is NOT an expression in the C programming language".  You probably can get an idea of where it goes from there.
[21:39:33] <Zipheir> *something like the
[21:40:04] <Zipheir> Transitive relations?
[21:40:55] <pinoaffe> mdhughes: english is not my first language, so that may be part of the reason why I'm not familiar with this usage of the term
[21:41:12] <mdhughes> OK, it's just a+b = b+a
[21:41:15] <Zipheir> It's new to me, too.
[21:41:23] <Zipheir> That's commutativity.
[21:41:34] <sham1> That's not transative, that's commutative, yeah
[21:41:40] <johnjaye> Zipheir: i recall it was something like saying "this sentence is not provable" but true
[21:42:24] <sham1> Anyway, XOR is just addition mod 2 element-wise of two vectors
[21:43:01] <pinoaffe> Zipheir: a relation ~ (a boolean function taking two arguments) is transitive iff (and (~ a b) (~ b c)) implies (~ a c)
[21:43:14] <Zipheir> johnjaye: Yeah.  You write a "program" that produces true theorems of a system using Gödel numbering, then use it to generate a paradoxical theorem.
[21:43:40] <Zipheir> pinoaffe: Oh, I know, I was just asking if that's what mdhughes meant.
[21:43:46] <johnjaye> what does that mean for a program though?
[21:43:54] <johnjaye> "this program is not a valid c program"?
[21:44:07] <Zipheir> johnjaye: The analogy with C is imperfect.
[21:44:23] <mdhughes> OK, I probably combined the terms since then (or my math classes did? I dunno, it's been too long.)
[21:44:28] <Zipheir> johnjaye: C doesn't theorems in its usual interpretation.
[21:44:34] <Zipheir> *doesn't have
[21:44:51] <Zipheir> johnjaye: But see Wadler's talk.  Programs are proofs of theorems.
[21:45:02] <Zipheir> (i.e. their types)
[21:45:05] <sham1> Curry-Howard correspondence, but yeah. Gödel numbers don't really apply for C stuff
[21:45:12] <pinoaffe> mdhughes: commutativity would probably not even be required for an "xargs", you need properties related to repeated / split application of a function
[21:45:18] <Zipheir> sham1: Bingo.
[21:46:04] <Zipheir> Yeah, xargs should only require associativity, and of course you're screwed if you start messing around with side effects...
[21:46:28] <sham1> Gödel numbers are for logical statements, like for example every axiom of Peano arithmetic and then one can calculate stuff like `succ 0 = 1` and whatnot
[21:47:15] <Zipheir> sham1: In the SICP lectures, Sussman tongue-in-cheekily suggests Gödel numbering as an alternative to garbage collection. :)
[21:47:38] <amazigh> sm2n: I did.
[21:48:05] <pinoaffe> dpk: I think that something along the lines of a map/fold/reduce that operates on tree structures (or that loops in a tree-like manner) would be very neat, but I'm not sure whether "xargs" is a useful abstraction
[21:48:18] <Zipheir> pinoaffe: Foldables.
[21:48:31] <Zipheir> Still a very nice thing to have in Scheme.
[21:49:15] <Zipheir> And traversables à la Haskell, but that leans on idioms.
[21:49:48] <pinoaffe> I recently watched Guy Steele Jr's talk "Four solutions to a trivial problem" ( https://www.youtube.com/watch?v=ftcIcn8AmSY ), very good talk and somewhat related to the matter at hands
[21:49:52] <sham1> So you want general catamorphisms
[21:50:11] <Zipheir> pinoaffe: That's the one where he talks about his 1-card FORTRAN program, right?
[21:51:05] <pinoaffe> Zipheir: he talks about fortran, I don't recall anything about a "1-card" program though
[21:51:41] <Zipheir> Oh, right, that's "How to think about parallelism--NOT!".
[21:52:48] <pinoaffe> sham1: I don't know enough category theory to know whether that is what I want :)
[21:53:44] <pinoaffe> I only ever followed a single course that touched on category theory, and I flunked that course
[21:53:45] <Zipheir> Catamorphisms can get *very* general.
[21:54:20] <sham1> Catamorphism from what I've underdstood is just the generalization of folding
[21:54:47] <Zipheir> What would be really cool is their application in "datatype generic" functions of inductive types that Gibbons talks about, I can't remember what the paper is called.
[21:55:25] <Zipheir> Datatype-Generic Programming, https://www.cs.ox.ac.uk/jeremy.gibbons/publications/dgp.pdf
[21:55:34] *** Joins: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb)
[21:56:04] <Zipheir> pinoaffe: Have you looked at 7 Sketches?
[21:57:32] <pinoaffe> Zipheir: I have not
[21:58:03] <Zipheir> pinoaffe: You might check it out.  It's a really pleasant hands-on category theory intro https://arxiv.org/abs/1803.05316
[21:58:23] <Zipheir> It is not super rigorous, as the title suggests, but it's fun.
[21:59:09] <Zipheir> It was absolutely good enough to want to buy the hardcopy from MIT press.
[22:00:37] <Zipheir> (Unfortunately, my partner spilled a beer on the physical copy shortly after I got it. :-/)
[22:02:09] <sham1> Ouch
[22:23:53] <lockywolf> is anybody here actually using any Scheme as a shell language instead of bash/zsh?
[22:29:22] <ChoHag> That would be crazy.
[22:31:10] <ChoHag> Scheme (proper, nor any implementation that I know of) hasn't got the operations needed for handling processes.
[22:33:00] <Zipheir> scsh, presumably.
[22:33:32] <Zipheir> ChoHag: scsh's process handling has made it into CHICKEN and possibly other implementations.
[22:34:36] <johnjaye> i don't see why not.
[22:35:26] <johnjaye> the only problems would be internal (duplicating some bash feature people rely on) or external (other programs expect a program named 'bash' in the ps(1) output)
[22:35:50] <ChoHag> johnjaye: How do you handle SIGCHLD in scheme?
[22:36:00] <ChoHag> In scheme, mind, not $random_implementation.
[22:38:12] <ChoHag> It's not an impossible task but such concerns have been far removed from scheme's development process so far.
[22:38:22] <ChoHag> Operating systems are seen as some sort of evil necessity.
[22:38:51] <Zipheir> Or just outside of the purview of the language standards.
[22:39:14] <ChoHag> Right. It'll get there eventually.
[22:41:12] <johnjaye> Zipheir: this is what i was referring to before. it's about the philosophy of your community
[22:41:35] <johnjaye> if your community believes processes are evil, ok fine. but then you shouldn't try to shoehorn them into caring about them.
[22:42:10] <johnjaye> someone linked somewhere before the idea of letting a community around a language grow and develop it. same idea
[22:42:49] <ChoHag> I don't like that idea.
[22:43:01] <ChoHag> I would prefer to say influence than grow.
[22:43:45] <Zipheir> Intelligent design vs. evolution, cathedral vs. bazaar, etc.
[22:44:16] <ChoHag> We are not forgiving enough of failure to allow evolution to be the driver.
[22:44:20] <amazigh> lockywolf: good question
[22:44:57] <ChoHag> Just look at the amount of crappy organisms nature lets live anyway. We don't do it that way.
[22:45:24] <johnjaye> it is kind of weird too in haskell as well. all the talk about monads. as if input or the network is some impure, lesser thing outside the scope of holy computation
[22:45:28] <Zipheir> It's not clear to me what "failure" is in the context of language design and dissemination.
[22:46:12] <Zipheir> johnjaye: "Purity" is a real canard, as Riastradh would remind us were he here.
[22:46:15] <ChoHag> Zipheir: Would you consider Latin or PIE a success or a failure?
[22:46:23] *** Quits: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb) (Quit: ZNC - https://znc.in)
[22:47:28] <Zipheir> ChoHag: Oh, I have no idea.  It's hard enough to come up with opinions about that in the programming language context.
[22:48:03] <Zipheir> I'll say that I don't consider Scheme's "family of dialects" situation to be a sign of failure.
[22:48:09] <ChoHag> I don't really know either.
[22:48:21] <ChoHag> Neither exists, but most of the world speaks something based on it.
[22:49:01] <johnjaye> latin is a "failure" in that only weird nerdy people with certain hobby inerests speak or write it
[22:49:26] <johnjaye> but i don't see how that is a failure
[22:49:47] <Zipheir> I guess hardcore Roman Catholicism counts as a nerdy hobby interest :)
[22:51:45] <amazigh> tamazight is still spoken after 3000 years according to imazighen calendar, is it a success?
[22:51:58] <johnjaye> i mean they dress in costumes. heh
[22:52:07] <dpk> the more i work on R7RS, the longer my list of things ‘if we could do Scheme again from scratch’ gets
[22:52:13] <johnjaye> but yeah i mean if your language is built on latin or is half latin that's a success it seems to me
[22:52:34] <johnjaye> dpk: then make a new language and call it something weird. like pragu
[22:52:39] <amazigh> ahah :)
[22:52:55] <dpk> the latest two are ‘adopt SRFI 72-style syntax objects instead of R4RS/R6RS-style’ and ‘procedural record types are always generative, syntactic ones are always nongenerative’
[22:52:55] <Zipheir> johnjaye: Clearly latin is the language of the Christian God since, er, the latin speakers, er, borrowed him from the Judeans? :)
[22:52:56] <johnjaye> or recoi. or some made up word. 
[22:53:00] <ChoHag> dpk: I figured I'd just do that.
[22:54:13] <amazigh> johnjaye: what is the topic of the convo?
[22:54:39] <ChoHag> People can write scheme interpreters in a weekend these days, so why care about backwards compatibility with implementations used by approximately 0.1% of the programming world, nearly of whom fit within that weekend-warrier caste?
[22:54:48] <dpk> Zipheir: the argument was that Latin was one of the languages, according to John, in which the accusation above Jesus's head was written on the cross, and therefore sanctified by his blood
[22:54:50] <johnjaye> it started when someone asked if you could use scheme as a real-world shell.
[22:54:53] <ChoHag> nearly all
[22:54:56] <johnjaye> as in, for your linux pc.
[22:54:59] <amazigh> I backlogged I do not understand how we came to 'they drey in customes [hence it is failure]' and 'built on latin [means success]'
[22:55:46] <amazigh> oh that is very curious OP did not reply
[22:55:49] <ChoHag> So I'm making my own scheme, from scratch, and it will have its own blackjack (random) and hookers (I'll think of something probably to do with bitcoin).
[22:55:50] <Zipheir> dpk: I have to admit that I first read 'John' to refer to jcowan...
[22:55:56] <dpk> the Eastern Church never bought this and celebrated in Slavic languages from their earliest christianization of the Slavs (but their versions of Slavic languages became just as anquitated to actual Slavic speakers as Latin is to modern Romance speakers)
[22:56:36] <johnjaye> amazigh: basically i'm suggesting the people making up the scheme community would prefer it stay as an educational language. which conflicts with the goal of making a shell you would actually use i guess.
[22:56:36] <ChoHag> The actual scheme is an extremely useful resource and will be an exported interface.
[22:57:51] <amazigh> johnjaye: I stopped reading at 'costumes', learn to be harsh like the greatest if you want to look successful.
[22:58:47] <amazigh> you have a good costume tho.
[22:59:07] <ChoHag> Perhaps I shouldn't have used the term 'success'. It's too polarising.
[22:59:23] <Zipheir> dpk: Interesting.
[22:59:27] <ChoHag> That's not the way evolution works, after all, which was the point I was getting at.
[22:59:55] <johnjaye> ChoHag: i didn't get what you meant by influence rather than grow.
[23:00:25] <ChoHag> johnjaye: Basically that if you let the users/customers/players have too much control, it all turns to shit.
[23:00:56] <johnjaye> oh sure. my point is the opposite. if you try to stear your community somewhere they don't want to go... they just don't go there. or it breaks up i guess.
[23:01:18] <ChoHag> Right. So somebody has to steer but the community can decide where to go.
[23:01:29] <Zipheir> No, you don't.
[23:01:43] <johnjaye> i'm thinking of the R6/R7 split when i say break up
[23:01:54] <ChoHag> Some thing, if you like.
[23:01:55] <Zipheir> I say get rid of the priests/laymen, devs/customers dichotomy.  Everyone contributes.
[23:02:21] <Zipheir> If things branch, they branch.  There is no One True Way, after all.
[23:02:22] <dpk> Zipheir: a developerhood of all users, so to say?
[23:02:23] <ChoHag> If everybody pushes in their own direction, there is still an overall direction which the "thing" moves in.
[23:02:31] <ChoHag> That direction can be blind or steered.
[23:02:38] <dpk> (i've been arguing for exactly that for years)
[23:02:56] <Zipheir> Yeah.
[23:03:00] <ChoHag> I've been contributing since the previous century.
[23:03:11] <ChoHag> Where is this inability to contribute coming from?
[23:03:21] <Zipheir> I persist in the hope that, if you expect useful contribution of people, they can rise to the occasion.
[23:03:44] <amazigh> ChoHag: are you aware of https://github.com/johnwcowan/r7rs-work/blob/master/ProcessesCowan.md (via https://r7rs.org)
[23:03:52] <ChoHag> s/contributing/participating/ I guess since I don't have much of an internet footprint these days.
[23:06:00] <amazigh> look at recent WG2 convo on google groups https://groups.google.com/g/scheme-reports-wg2
[23:06:05] <ChoHag> Zipheir: That's never going to happen.
[23:06:19] <ChoHag> If you expect greatness from people, you're going to get scammed.
[23:06:46] <ChoHag> If you *allow* greatness on the other hand, great things can happen.
[23:07:12] <amazigh> ah
[23:08:02] <Zipheir> ChoHag: Yes, better 'allow' than 'expect'.
[23:08:06] <amazigh> re allowing greatness, isn't that the same as "they can rise to the occasion"?
[23:08:17] <ChoHag> amazigh: Yes but can not must.
[23:08:35] <Zipheir> Don't assume they're idiots who need to be steered, at least.
[23:09:02] <ChoHag> Idiots and need are both the wrong term, but yes.
[23:09:28] <ChoHag> Personally I just can't be arsed to deal with geopolitics. That's what I have politicians and civil servants for.
[23:09:48] <ChoHag> Happy to put up with whatever crap they deal out, for the most part. They can steer away.
[23:10:21] <amazigh> purview of technical problems. Reminds of lelisp
[23:10:41] <amazigh> "sorry but timezones you know"
[23:10:56] <amazigh> and they dressed the same way.
[23:12:05] <mdhughes> You can absolutely use Scheme as a shell scripting language. Takes more work in some impls than others.
[23:13:55] <mdhughes> I mostly do shell code in zsh, but I've been migrating some of that over to Scheme and adding the tools I need to my os library.
[23:14:30] <mdhughes> People who say "Scheme ends at the spec" are just wrong.
[23:15:02] <ChoHag> It would be nice if it started there.
[23:15:20] <mdhughes> I don't know what you mean by that, but I think I don't like it.
[23:16:09] <ChoHag> I struggled to write the simplest programs portably while aiming tham at either r5 or r7-small.
[23:16:18] <mdhughes> You don't have to even be 100% compliant with any spec version to be a Scheme, and be useful. tinyscheme, as noted yesterday.
[23:16:29] <ChoHag> Everything was implementation-dependent caveats, left, right and centre.
[23:17:05] <mdhughes> OK, so? Are you harmed by this blasphemy against the Word of THE LORD GOD?
[23:17:33] <mdhughes> If the script works, it's good enough.
[23:19:36] <mdhughes> My reason for moving stuff out of zsh is I'll want to do some math or build lists of work to do, and it's *possible* but very hard in zsh. If all that code's mostly common Scheme, and I have to write a bit of custom or impl-specific code to interact with the system, awesome.
[23:21:03] <ChoHag> Well the problem is it didn't work.
[23:21:11] <ChoHag> Or rather it did in chicken then it didn't in chibi.
[23:21:55] <ChoHag> But then after fixing that GNU has an Opinion and their interpretation of the standard different so that needed its own customisation.
[23:22:29] <ChoHag> Hence, it would be nice if scheme started at the standard.
[23:23:24] <ChoHag> And that's before each implementation decides how opinionated it has to be about whether and how it loads whatever-it-calls-libraries and/or srfis.
[23:23:52] <mdhughes> Well, CHICKEN is R5RS+, Chibi is R7, I dunno what you mean by "GNU" except Guile? Which is R6? (I don't use GNU products unless absolutely needed).
[23:24:08] <ChoHag> I rest my case.
[23:24:30] <mdhughes> Those represent 25+ years of specs.
[23:25:59] <mdhughes> I mean, Common Lisp doesn't change or evolve, which is why it's obsolete. Ada and COBOL are pretty slow-moving, too, but beware, Fortran's had a new spec this century.
[23:26:28] <ChoHag> I'm not talking about those.
[23:26:53] <ChoHag> Evolution doesn't pit cats again dogs or mice. It pits them against cats.
[23:26:54] <mdhughes> But almost anything you can write in R5RS will run on any recently-updated Scheme.
[23:27:19] <mdhughes> And then you use whatever features your Scheme of choice gives you to go beyond that.
[23:27:37] <Zipheir> ChoHag: Sure it pits them against smarter/faster dogs and mice.
[23:27:46] <mdhughes> … programming languages don't evolve by competition, really. They're engineered things, like bananas.
[23:27:57] <ChoHag> Well we can forgive distributions which have been abandoned of course but I lament the "almost".
[23:28:32] <ChoHag> Implementations, sorry. Mixing my metaphors.
[23:28:52] <mdhughes> OOOH. But now I want to make an esolang where the spec & language features evolve by genetic algorithms. The fiercest, most efficient language wins and "reproduces", the weak ones and all programs written in them are deleted.
[23:29:03] <Zipheir> I had a similar thought.
[23:29:16] <mdhughes> I read a lot of Rudy Rucker's books, so this happens a lot.
[23:29:17] <johnjaye> ChoHag: what kinds of portable code did you want to write?
[23:29:31] <ChoHag> I can't remember. That was many yaks ago.
[23:29:50] <johnjaye> i'm learning bash and zsh somewhat and portability is my #1 concern.
[23:30:06] <johnjaye> honestly once you own multiple types of machines i think that happens.
[23:30:12] <ChoHag> For shell portability you really need to targer plain bourne sh.
[23:30:21] <johnjaye> you just stop caring about gnu extensions or bash special features. you just want something that works on multiple machines
[23:30:24] <johnjaye> yes^
[23:30:27] <mdhughes> johnjaye: If you stick to Bourne Shell features, they're both fine; zsh is a lot safer even when you don't use its specific features.
[23:30:44] <ChoHag> The extras bash et al add are nice for interactivity but a downright pain for scripting.
[23:31:01] <johnjaye> well it's just an example. so i can see whre ChoHag is coming from
[23:31:03] <ChoHag> And just look at bash's imporing of functions from the process environment.
[23:31:10] <johnjaye> having everything be implementation specific *and* subject to change are both bad
[23:31:30] <Zipheir> The whole Bourne family is a nightmare of weird quoting and everything-is-a-string ness.
[23:31:38] <ChoHag> It's really not.
[23:32:03] <Zipheir> Yet perfectly fine for basic scripts.
[23:32:09] <mdhughes> Zipheir: That's what zsh gets most right. `foo $a 2` will send foo 2 args, regardless of what's in a.
[23:32:16] <ChoHag> It's actually got a decent little language buried in there.
[23:32:43] <Zipheir> I'd vote for rc over most of 'em.
[23:33:04] <ChoHag> There are some obscure incompatibilities with proprietary implementations but the dust has mostly settled.
[23:33:19] <mdhughes> Well, and this is why I vote for doing Scheme for it, at least when the problem's hard enough shell's inadequate.
[23:33:38] <Zipheir> The big issue with shells is the programming language/command interface duality.  It makes syntactic slipperiness hard to avoid, IMO.
[23:33:38] <ChoHag> See http://zeus.jtan.com/~chohag/ksh/ksh.pdf (draft).
[23:34:23] <Zipheir> Oh, ksh is my favorite of the Bourne bunch.
[23:37:02] <johnjaye> i'm very disappointed weechat chose the same color for both of your nicks
[23:37:06] <johnjaye> making the scrollback very hard to read
[23:37:56] <johnjaye> but i will try scsh. first thing to do is figure out how to run it
[23:38:05] <Zipheir> That's the tricky part :)
[23:38:10] <mdhughes> And make sure to read the forward to the manual.
[23:38:20] <Zipheir> Hah, the famous acknowledgments.
[23:38:48] <ChoHag> The shell isn't helped much by being forced to be interactive *and* a script interpreter.
[23:38:54] <johnjaye> ah thanks to debian for the --install-suggests flag. otherwise i wouldnt' get the doc for scsh along with the package
[23:39:25] <johnjaye> ChoHag: well... that's kind of hard to avoid. but i get your meaning
[23:39:27] <Zipheir> ChoHag: Exactly.
[23:39:41] <ChoHag> I don't think any other language makes \n so special.
[23:45:44] <johnjaye> Welcome to scsh 0.6.7 (R6RS)
[23:45:53] <johnjaye> this is a beta-test version of scheme-48...
[23:46:26] *** Joins: x88x88x (~x88x88x@149.28.53.172)
[23:47:56] <johnjaye> those acknowledgements.... @_@
[23:48:05] <mdhughes> :)
[23:58:55] *** Joins: atka (~atka@static-198-54-131-84.cust.tzulo.com)
