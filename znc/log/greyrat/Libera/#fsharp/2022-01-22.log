[00:03:44] <xeno> hmm... interresting... a "tail recursion" that ends with x+1 |> recurse ends with a stack overflow, while if I end it with recurse (x+1) it actually performs TCO 
[00:03:59] <xeno> that's kinda useful to know
[00:04:24] <xeno> and incomprehensible at the same time - I thought those were essentially synonyms 
[00:13:58] <biberu> xeno: precedence
[00:14:16] <xeno> what? 
[00:14:24] <biberu> the first case is x + (1 |> recurse), which means it can't perform tco
[00:14:25] <xeno> you still need to call (x+1) before you call recurse 
[00:14:35] <xeno> ah fuck
[00:14:37] <xeno> sorry
[00:14:53] <biberu> don't be :)
[00:15:03] <xeno> I thought |> had the lowest presedence 
[00:15:11] <xeno> that's kinda the point with it 
[00:15:47] <xeno> I actually don't believe that you're right, gonna test it 
[00:16:37] <xeno> x + 1 |> printfn "%A"
[00:16:37] <xeno> 6
[00:16:47] <xeno> so no
[00:16:54] <biberu> hm
[00:17:28] <biberu> on, yeah, you're right
[00:17:34] <biberu> https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/symbol-and-operator-reference/#operator-precedence
[00:18:01] <biberu> "ah fuck // sorry"
[00:18:29] <biberu> what's the issue then though
[00:19:51] <xeno> yeah, that's what I'm wondering too 
[00:20:04] <biberu> got an example to share?
[00:20:32] <xeno> https://github.com/aoc-2021/aoc2015/blob/main/day4/Program.fs
[00:20:54] <xeno> the findFirst (n+1) was n+1 |> findFirst, but then it ended in stack overflow 
[00:21:40] <xeno> I'm not sure if the md5.Initialize() needs to be run every time btw, but the thing crashed with error code 139, so did it just to be sure 
[00:22:22] <xeno> probably some monadic magic tht I didn't think was there, but which is and screws with the optimizer 
[00:22:48] <biberu> hm, (n+1) |> findFirst  overflows too
[00:23:35] <xeno> only thing I can think of is to compile and disassemble it, but meh... how do you do that? 
[00:24:09] <biberu> https://sharplab.io
[00:25:10] <biberu> it'd be nice with a check to force a function to be tail recursive
[00:29:45] <biberu> hm
[00:30:04] <biberu> simplified it to let rec f (n: int) = if n = 1000_000 then n else f (n + 1)
[00:31:00] <biberu> sharplab shows the same il, in both debug and release
[00:32:06] <biberu> only getting it in debug in vs btw
[00:32:30] <xeno> hmm.. maybe that's the difference 
[00:32:41] <xeno> one leaves a possible debug point that it keeps on the stack or something
[00:32:54] <biberu> your code works in release mode too
[00:33:03] <biberu> i guess it's something like that
[00:33:14] <biberu> i think there were some new things about that in 6
[00:33:21] <xeno> this is 6 btw 
[00:33:26] <biberu> i'll try on 5
[00:34:11] <biberu> overflows there too
[00:41:05] <biberu> anyway i guess i won't mix up the precedence again, thanks xeno :D
[05:29:57] *** Joins: fmlatghor (~lcoogan@2601:5cd:8100:2890::6)
[05:30:04] *** Parts: fmlatghor (~lcoogan@2601:5cd:8100:2890::6) (WeeChat 3.2)
