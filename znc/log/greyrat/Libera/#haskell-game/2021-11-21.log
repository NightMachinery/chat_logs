[01:04:32] <EvanR> displaying 60fps random glyphs on 114 by 45
[01:04:57] <EvanR> as soon as I put a data structure for the console, the fps drops xD
[01:05:27] <f-a> can we see your blit code?
[01:10:54] <f-a> are you using `ansi-terminal`, curses?
[01:15:21] <EvanR> nope
[01:15:28] <EvanR> GL
[01:15:55] <f-a> ok I misread
[01:16:03] <f-a> what data structure have you chosen?
[01:16:17] <f-a> Do you do double buffering?
[01:16:36] <f-a> do you only update the cells which have changed?
[01:16:54] <EvanR> repainting everything every frame baby xD
[01:16:55] <f-a> (I am making the assumption this is a fixed-width terminal)
[01:17:13] <f-a> :P well then, that is one thing to work out
[01:17:38] <EvanR> well, it's not a graphics issue since I am displaying full random every frame fast
[01:18:04] <EvanR> it's about 5100 total cells at a time, glad to see that's not an issue
[01:18:12] <f-a> mhhh
[01:18:21] <f-a> then must be the data structure
[01:18:25] <EvanR> yeah
[01:18:39] <f-a> `toList` and similar culpirit
[01:19:04] <f-a> profile it and see who is shitting the proverbial bed
[01:19:05] <EvanR> first putting random glyphs everywhere then mapping over it all, doesn't seem to like it
[01:19:10] <EvanR> lol
[01:20:42] <EvanR> whats up with toList ?
[01:22:27] <f-a> getting an assocList each frame from ‚Äî say ‚Äî an Array is a bit pricey (at least here)
[01:23:57] <EvanR> that's annoying
[01:24:52] <EvanR> not well versed in getting lists to fuse 
[01:28:00] *** Quits: Guest17 (~Guest17@eth-west-pareq2-46-193-4-100.wb.wifirst.net) (Quit: Client closed)
[01:47:31] <EvanR> wait, what do you mean by double buffering
[01:48:40] <f-a> blitting everything to a surface which is then blitted to screen (in sdl2, you would use `flip`) and *not* blitting directly to screen
[01:51:03] <EvanR> oh ok... yeah that is handled by GLFW
[01:51:53] <f-a> https://hackage.haskell.org/package/ansi-terminal-game-1.8.0.0 1.8.0.0 out sm , small UX improvements
[01:52:56] <ManofLetters[m]> I just use AcceleratedVSyncRenderer in SDL2 and I see any tearing; but perhaps SDL2 does double-buffering under the hood, no idea
[01:53:04] <ManofLetters[m]> BTW, I can't find `flip` in https://hackage.haskell.org/package/sdl2-2.5.3.0/docs/doc-index-F.html
[01:55:24] <ManofLetters[m]> I do `copy` to a big texture representing the screen and then ask SDL2 to render the texture
[01:57:54] <ManofLetters[m]> I suppose that's kind of double-buffering, but in the sense of alternating between two buffers
[01:58:20] <ManofLetters[m]> but having a single buffer, drawing to it repeatedly, rendering it once
[01:58:30] <ManofLetters[m]> I think that's not called double-buffering
[01:59:04] <EvanR> it's called present
[01:59:29] <ManofLetters[m]> yes, that's the rendering of the texture representing the screen
[02:00:14] <ManofLetters[m]> but there may be some double-buffering under the hood, because to clear screen, I need to do `clear; present` twice
[02:00:48] <EvanR> yeah, you can observe the two buffers by not clearing
[02:00:54] <EvanR> present switches between them
[02:01:04] <ManofLetters[m]> oh, cool, so I guessed right
[02:01:10] <f-a> `present`, sorry
[02:01:45] <EvanR> in glfw is literally called swapBuffers heh
[02:02:03] <f-a> https://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlflip.html
[02:02:23] <ManofLetters[m]> haha, good old SDL1 with a non-mad API
[02:02:50] <f-a> yeah I talk sdl1 because I used it and maintain it
[02:03:26] <ManofLetters[m]> I'm quite miffed I have to use both surfaces and textures in SDL2
[02:03:28] <f-a> I call double buffering this thing https://www.loomsoft.net/resources/alltut/alltut_lesson5.htm
[02:03:40] <f-a> not sure if the nomenclature is correct
[02:03:43] <ManofLetters[m]> though probably there is a good reason, like surfaces in RAM, texture on GPU or something
[02:04:39] <f-a> I guess ¬´buffering¬ª is the correct term (w/o the ¬´double¬ª)?
[02:04:40] <f-a> not sure
[02:05:02] <f-a> but in any case, lazyfoo examples translated to haskell are not ok
[02:05:20] <f-a> threadDelay is not precise unfortunately
[02:06:04] <ManofLetters[m]> perhaps double-buffering is a way of implementing buffering so that you don't have to wait for rendering to finish before you start creating the next contents of the buffer
[02:07:31] <EvanR> I've gotten good results with threadDelay as long as the threaded runtime is used
[02:08:08] <EvanR> the thread can wake up fast enough to do audio, ime
[02:08:09] <ManofLetters[m]> I'm gettting > 25% slowdown with treaded runtime
[02:08:57] <ManofLetters[m]> 25% when not drawing anything at all
[02:09:04] <sm> oof
[02:10:12] <ManofLetters[m]> * double-buffering, but not in the
[02:11:31] <ManofLetters[m]> and this is all using just -N1
[02:12:24] <ManofLetters[m]> so overhead from migration between capabilities is not the culprit
[02:13:00] <ManofLetters[m]> that's probably a GHC bug, but nobody has time to touch it
[02:13:58] <ManofLetters[m]> f-a weren't you using some fancy timers instead?
[02:14:18] *** Quits: __monty__ (~toonn@user/toonn) (Quit: leaving)
[02:14:53] <ManofLetters[m]> f-a^^^
[02:15:32] <f-a> instead of threadDelay you mean? Yeah I do
[02:15:39] <ManofLetters[m]> +1
[02:15:46] <EvanR> like what fancy timer
[02:17:38] <f-a> in my case, very simple fancy timers: just an IORef/MVar where I dump a  \val -> (Tick : val) based on /time polling from epoch/.
[02:17:58] <f-a> This allows you to offset the time lost by each  threadDelay  call
[02:18:03] <f-a> and have precise ticks
[02:18:31] <f-a> to make it absolutely clear
[02:19:12] <f-a> CC.threadDelay oneSixtiethOfASecond     ‚Üê this will add delays up
[02:21:47] <f-a> not fine for simple games, but especially not fine if you are interacting with another part (it being a server or whatever)
[02:22:38] <ManofLetters[m]> do you mean, you get time with just `getPOSIXTime`?
[02:23:13] <ManofLetters[m]> I didn't understand the "polling" part
[02:23:47] <f-a> getTime = T.liftIO $ SC.toNanoSecs <$> SC.getTime SC.Monotonic
[02:25:35] <f-a> polling: simply  ‚Ä¢ getCurrent time  ‚Ä¢ calculate Ticks (fractions of a second) from START_OF_GAME  ‚Ä¢ check how many ticks there are in the MVar and top up if necessary
[02:26:18] <sm> ansi-terminal-game has Nanosecond Resolution üòé
[02:26:45] <f-a> this will get you smooth, predictable and precise timing at everty speed
[02:27:31] <f-a> and as a bonus, a game that runs at the same speed: ‚Ä¢ regardless of CPU ‚Ä¢ regardless of blitting performance
[02:28:11] <f-a> since when you enter logic you will have a  pollEvents :: IO [Event]  function, and if you get two Ticks you know you have to performe logic twice before blitting
[02:28:44] <ManofLetters[m]> nice; I get the polling now
[02:28:59] <ManofLetters[m]> which package/module is SC.getTime from?
[02:29:13] <f-a> import qualified System.Clock                 as SC
[02:29:13] <ManofLetters[m]> or, why not `getPOSIXTime`?
[02:29:24] <ManofLetters[m]> oh
[02:29:39] <f-a> I suppose there is no getPOSIXTime in Windows :P
[02:29:53] <ManofLetters[m]> `Data.Time.Clock.System`?
[02:30:25] <ManofLetters[m]> I can't find the one you mentioned at https://downloads.haskell.org/ghc/latest/docs/html/libraries/
[02:30:39] <f-a> sorry
[02:30:40] <f-a> from clock >= 0.7 && < 0.9,
[02:32:03] <ManofLetters[m]> BTW, `getPOSIXTime` works for me on WIndows
[02:32:57] <ManofLetters[m]> hah, I knew your timer if fance; the clock package is "high-resolution clock"
[02:33:03] <ManofLetters[m]> *fancy
[02:33:54] <f-a> I plan (in a future far far away) to have multiplayer via Tox protocol
[02:34:44] <f-a> so this will come handy
[02:35:24] <f-a> I also can give a truthful answer to ¬´how many hours has the player wasted on this game¬ª?
[02:35:36] <f-a> *?¬ª
[02:37:02] <ManofLetters[m]> BTW, I have a comment in my code to use https://hackage.haskell.org/package/chronos "for speed and resolution"
[02:37:18] <ManofLetters[m]> I wonder it if accesses the same low-lever timers as 'clock'
[02:37:33] <ManofLetters[m]> and if you prefer the 'clock' API for any reason
[02:37:43] <f-a> ohhh, haven‚Äôt checked it
[02:37:51] <f-a> haskell package discovery is lacking
[02:39:29] <ManofLetters[m]> the TODO comment is from a couple months ago, so the package is probably not abandoned yet ;) but I haven't actually used it, so that's based only on API comparison
[02:39:57] <ManofLetters[m]> and it's not unthinkable that I didn't find `clock` in turn :)
[03:05:12] <EvanR> I knew about System.Clock to get the monotonic clock, but that doesn't explain how you would sleep with better precision than threadDelay xD
[03:07:09] <f-a> the system is very simple: given a start time t‚ÇÄ ad a granularity ùëî, fork a thread and let it do this:
[03:07:49] <f-a> 1. calculate Œît/ùëî, these are your current ticks
[03:08:31] <f-a> 2. (not necessary, but this is what I do), top up the Ticks in the MVar
[03:08:48] <EvanR> ehm this doesn't sound related to sleeping
[03:08:54] <f-a> 3. sleep for Œµ, where Œµ is granularity/10 or another low value
[03:09:15] <EvanR> it sounds related to simulation speed
[03:09:22] <f-a> notice how 3. will not add unwanted delays to threadDelay
[03:09:44] <f-a> 3 is there sleeping happens
[03:09:47] <EvanR> sleep using what API call?
[03:09:55] <f-a> threadDelay itself
[03:10:09] <EvanR> ok I think we were never on the same page xd
[03:10:59] <EvanR> I thought the original problem was threadDelay would sleep sometimes for egregiously long, which is bad for interactivity
[03:11:13] <EvanR> which I encountered in the non-threaded runtime
[03:11:54] <f-a> it does sleep long enough to add up
[03:13:02] <f-a> with my way, given a small Œµ, you will never have unresponsive input or misaligning time (with, say, your desktop clock)
[03:13:28] <f-a> oh, you are polling *after* a threadDelay?
[03:13:56] <f-a> Now I understand, I just open a thread and fill chars in the [Event] MVar
[03:14:11] <EvanR> I'm not doing anything
[03:14:15] <f-a> this way, when you invoke pollEvents you get, say, [Tick, KeyPress 'p', Tick]
[03:14:54] <EvanR> in previous tests threadDelays minimum sleep time would sometimes be too large, regardless of how small the argument is
[03:15:05] <EvanR> but that was much improved by using threaded runtime
[03:15:31] <EvanR> as far as getting your simulation to go at a steady speed, yeah that's another topic not even related to threadDelay, which could never accomplish that
[03:15:59] <f-a> with my method (which is not mine, I suppose, but I did not find it implemented in any hackage library) you would just getting [Tick, Tick] at the next pollEvents
[03:16:52] <f-a> hence skipping a blit but keeping things in running fine 
[03:17:51] <ManofLetters[m]> was this too long threadDelay observed with all threads idle? and are we talking about times in the order of 1/60s or much smaller?
[03:18:49] <f-a> sometimes even larger than 1/60s
[03:18:50] <ManofLetters[m]> because if all is idle and the interval is not too small, this sounds like a bug
[03:19:08] <EvanR> yeah nothing really going on
[03:19:17] <ManofLetters[m]> no GC?
[03:19:25] <ManofLetters[m]> idle GC turned off?
[03:19:34] <EvanR> i have no idea
[03:19:44] <EvanR> it was the nonthreaded runtime
[03:20:02] <f-a> ManofLetters[m]: per docs, it does not specify *how much* the ¬´extra delay¬ª is 
[03:20:07] <f-a> which is uncanny in itself
[03:20:16] <ManofLetters[m]>  ghc-options:        "-with-rtsopts=-I0"
[03:20:18] <EvanR> the chunkiness was on the order of 1/8 of a second or so
[03:20:57] <EvanR> normally you expect responsiveness around 1/60
[03:21:15] <ManofLetters[m]> if that's not idle GC, that's crazy, because threads are guaranteed to be given control as soon as no other thread does anythinng
[03:21:27] <ManofLetters[m]> try with idle GC turned off ^^^
[03:21:54] <EvanR> I won't be able to put my hands on that test I did like 5 years ago xD
[03:22:10] <EvanR> it may very well be irrelevant
[03:22:31] <ManofLetters[m]> and there may be some other RTS flags for that, let me check...
[03:22:41] <EvanR> the SDL audio callback was involved too, that's what needed responsiveness
[03:22:56] <EvanR> it couldn't run soon enough for audio
[03:23:49] <EvanR> the RTS option that solved it was --threaded xD
[03:24:09] <ManofLetters[m]> -C is the other option
[03:24:23] <ManofLetters[m]> -C0 for overkill
[03:24:43] <EvanR> anyway yeah I'm thinking I may want to render to 1 or more textures and display those, rather than repainting everything regardless
[03:25:06] <sm> IIRC threadDelay performed differently depending on platform
[03:25:12] <f-a> ‚Üë
[03:25:42] <f-a> you are not running an ARM laptop by any chance, are you?
[03:25:50] <EvanR> lol no
[03:25:54] <ManofLetters[m]> hehe
[03:27:28] <ManofLetters[m]> but, with large enough heap, idle GC has to break threadDelay consistently by as much as you want, so I wouldn't worry without experimenting with -I0 first
[03:27:46] <ManofLetters[m]> it has to trawl through the whole heap, so this can tak arbitrarily long
[03:28:02] <ManofLetters[m]> and the world is stopped then (with the normal GC)
[03:28:41] <ManofLetters[m]> of course, then you also have problems elsewhere, even when you invoke GC manually when you detect the player is idle
[03:28:53] <ManofLetters[m]> I mean, if you have a really large heap
[03:28:59] <EvanR> I'm pretty sure that program didn't have much live data
[03:29:28] <ManofLetters[m]> in that case 1/8 of a second sounds excessive
[03:29:33] <EvanR> no shit xD
[03:29:36] <ManofLetters[m]> but I'd try with -I and -C anyway
[03:29:38] <ManofLetters[m]> haha
[03:29:56] <ManofLetters[m]> GHC defaults are for batch processing
[03:30:01] <ManofLetters[m]> not for UI
[03:30:12] <EvanR> it was consistently bad so I think it was just a granularity setting
[03:30:15] <ManofLetters[m]> and non-moving GHC, definitel
[03:30:17] <ManofLetters[m]> y
[03:30:27] <ManofLetters[m]> *GC
[03:30:34] <ManofLetters[m]> it
[03:30:36] <ManofLetters[m]> 's
[03:30:38] <ManofLetters[m]> getting late
[03:30:40] <ManofLetters[m]> see you!
[03:30:50] <EvanR> 18:00 on the clock
[03:31:08] <ManofLetters[m]> I'm from the old continent
[03:31:41] <f-a> from the +1 zone
[03:31:45] <f-a> notte, ManofLetters[m] 
[03:31:58] <f-a> may you dream roguelikes
[03:32:44] <ManofLetters[m]> :D
[10:45:31] *** Joins: joes (~joes@2a02:8109:1b3f:b214:fc5c:a83c:7052:2a9a)
[11:25:06] *** Quits: joes (~joes@2a02:8109:1b3f:b214:fc5c:a83c:7052:2a9a) (Ping timeout: 268 seconds)
[11:39:51] *** Quits: tzh (~tzh@c-24-21-73-154.hsd1.or.comcast.net) (Quit: zzz)
[12:00:34] *** Joins: chomwitt (~chomwitt@2a02:587:dc2d:ec00:12c3:7bff:fe6d:d374)
[14:31:15] *** Joins: __monty__ (~toonn@user/toonn)
[14:48:29] <icrbow[m]> sounds like a curse tbh. one of those recursive nightmares
[14:59:11] *** Quits: chomwitt (~chomwitt@2a02:587:dc2d:ec00:12c3:7bff:fe6d:d374) (Ping timeout: 250 seconds)
[16:54:12] *** Joins: Guest17 (~Guest17@eth-west-pareq2-46-193-4-100.wb.wifirst.net)
[19:48:23] <EvanR> f-a, this is cool, I fixed my slowdown that was apparently caused by my data structure
[19:49:18] <EvanR> the issue was the way I looped through it. It was basically a left fold. Switching to right fold (more lazier) made my "bogo fps" measure go from 11/100 to 100/100 xD
[19:50:18] <EvanR> bogo fps is a bogus measure of how many of the last 100 frames were rendered in time (vsync)
[19:52:09] <EvanR> so to put 5000 glyphs on the screen each frame, I think it was building up a 5000 deep thunk before doing anything
[20:01:35] <f-a> that is pretty good
[20:02:07] <f-a> which structure did you choose to represent ¬´chars on screen¬ª? a Vector?
[20:03:08] <EvanR> it's an "infinite 2d buffer" of chars, which are manipulated or not, a rendered each frame
[20:03:16] <EvanR> and rendered*
[20:03:39] <EvanR> implementation? IntMap (IntMap C)
[20:04:10] <EvanR> missing entries default to e.g. 0
[20:05:45] <f-a> I see
[20:06:09] <f-a> do you eventually plan to have a merge function for buffers?
[20:06:15] <f-a> akin to  buf1 <> buf2?
[20:09:50] <f-a> don‚Äôt mind my pokey questions, this is for sure a moment to feel happy about. Not having skips at 60FPS basically mean everything is fine
[20:10:10] <f-a> and further optimisations are not necessary at present
[20:21:52] <sm> EvanR: nice!
[20:38:02] <EvanR> merge? I guess that could work
[20:38:38] <EvanR> i don't really have a usage api other than put glyph at position
[20:39:13] <f-a> show us something!
[20:39:30] <f-a> an exe, a small video, a screenshot
[20:39:52] <EvanR> i guess i need to figure out how to do that
[20:41:31] <f-a> install `obs`, (optional) grab a microphone, start recording
[20:44:50] <EvanR> https://i.imgur.com/CHuSeUM.png
[20:45:44] <ManofLetters[m]> +1
[20:46:07] <f-a> wtf I am seeing a stereogram in that
[20:46:08] <EvanR> it also lets you change the fg and bg color of each cell
[20:48:16] <f-a> very good
[20:48:44] *** Quits: carter (sid14827@helmsley.irccloud.com) (Ping timeout: 246 seconds)
[20:51:28] <EvanR> honestly... this is as far as I wanted to get xD
[20:51:39] <EvanR> i really wanted to see a grid of random glyphs on the screen
[20:51:54] <EvanR> now I'm at the top of the mountain with nowhere to go lol
[20:53:05] <f-a> think of games you like, and make the simplest incarnation of that idea
[20:53:27] <f-a> then paste it here, get feedback, add more features, refactor, paste it here, get feedback‚Ä¶
[20:53:32] *** Quits: awpr (uid446117@lymington.irccloud.com) (Ping timeout: 260 seconds)
[20:53:50] *** Quits: hamishmack (sid389057@hampstead.irccloud.com) (Ping timeout: 260 seconds)
[20:57:55] <EvanR> are you using a basic ascii character set
[20:58:21] <sm> HANGMAN!
[20:58:42] <ManofLetters[m]> I am
[20:58:50] <f-a> I am not on Linux
[20:59:12] <ManofLetters[m]> (lying a bit, I use a couple of exotic Unicode characters, too, but otherwise 7-bit ASCII)
[20:59:54] <f-a> on windows I am using unidecode, and as soon as this is fixed https://github.com/UnkindPartition/ansi-terminal/issues/114 I will use unicode on Win too
[21:00:33] <EvanR> interesting
[21:06:15] *** Joins: tzh (~tzh@c-24-21-73-154.hsd1.or.comcast.net)
[22:15:30] *** Quits: Guest17 (~Guest17@eth-west-pareq2-46-193-4-100.wb.wifirst.net) (Quit: Client closed)
[22:27:12] *** Joins: carter (sid14827@id-14827.helmsley.irccloud.com)
[22:38:51] *** Joins: hamishmack (sid389057@id-389057.hampstead.irccloud.com)
[22:45:43] *** Joins: awpr (uid446117@id-446117.lymington.irccloud.com)
