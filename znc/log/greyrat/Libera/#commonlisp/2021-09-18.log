[00:02:08] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[00:05:08] *** Joins: akoana (~ah@user/akoana)
[00:14:28] *** Joins: radio (~radio@2804:431:e7c9:a46a:6027:31f4:cfe1:efa2)
[00:14:46] <radio> 4
[00:15:18] *** Quits: radio (~radio@2804:431:e7c9:a46a:6027:31f4:cfe1:efa2) (Client Quit)
[00:18:11] *** Joins: lisp123 (~lisp123@5.30.23.247)
[00:26:36] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Remote host closed the connection)
[00:26:42] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 260 seconds)
[00:27:40] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[00:31:57] *** Joins: clone_of_saturn (~visitant@user/clone-of-saturn/x-1551297)
[00:32:16] *** clone_of_saturn is now known as saturn2
[00:34:40] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Ping timeout: 252 seconds)
[00:35:12] *** Joins: amb007 (~a_bakic@70.15.23.93.rev.sfr.net)
[00:37:17] *** Quits: amb007 (~a_bakic@70.15.23.93.rev.sfr.net) (Read error: Connection reset by peer)
[00:37:51] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[00:39:07] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 268 seconds)
[00:41:01] *** Joins: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se)
[00:41:01] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Read error: Connection reset by peer)
[00:42:00] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[00:48:59] *** Quits: scymtym (~user@2001:638:504:20e6:6ac3:87e0:e782:f3fc) (Ping timeout: 268 seconds)
[00:57:32] *** Parts: pranavats (3fba1d1b34@jabberfr.org) (Disconnected: Replaced by new connection)
[00:57:53] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[01:03:13] *** Quits: eddof13 (~textual@static-201-163-9-58.alestra.net.mx) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[01:05:26] *** Quits: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca) (Ping timeout: 260 seconds)
[01:05:45] *** Quits: cage (~cage@dynamic-adsl-84-220-251-50.clienti.tiscali.it) (Quit: rcirc on GNU Emacs 27.1)
[01:06:54] *** Joins: eddof13 (~textual@static-201-163-9-58.alestra.net.mx)
[01:07:07] *** Quits: shka (~herr@109.231.62.239) (Ping timeout: 265 seconds)
[01:07:44] <pjb> recordgroovy: this is indeed an error: (define-condition sec(stream-error) ()) (subtypep 'sec 'stream-error) --> T, T
[01:08:26] <recordgroovy> I've heard (but haven't experienced) that ABCL has a strange relationship with CL streams, as well
[01:14:25] *** Joins: scymtym (~user@ip-94-114-248-79.unity-media.net)
[01:18:43] *** Quits: taiju (~taiju@240b:253:ec40:2400:a8af:540:19a2:818b) (Ping timeout: 252 seconds)
[01:21:18] *** Quits: theBlackDragon (~dragon@fvwm/admin) (Ping timeout: 260 seconds)
[01:24:05] <pjb> recordgroovy: that's a serious bug I'd say, I define a lot of condition subclasses expecting to be able to use the accessor of the superclass (condition) slots…
[01:24:40] <recordgroovy> Wonder if that bug's ticketed yet, I'll go check
[01:25:38] <recordgroovy> Doesn't look like it, I'll file an issue on GitHub
[01:26:08] *** Quits: fengshaun (~fengshaun@S010680615f0c2c0a.cg.shawcable.net) (Quit: bibi!)
[01:27:31] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Ping timeout: 252 seconds)
[01:29:34] <pjb> recordgroovy: Note this is a problem only with stream-error it seems:  (define-condition tec (type-error) ()) (type-error-datum (make-condition 'tec :datum 42 :expected-type 'character)) -> 42
[01:29:51] <recordgroovy> hmm, interesting
[01:30:17] <pjb> it seems to be restricted to stream-error-stream.
[01:32:54] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[01:33:54] *** Joins: theBlackDragon (~dragon@fvwm/admin)
[01:34:00] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 268 seconds)
[01:34:01] <recordgroovy> pjb: Do you have a GH account that I can tag in the bug report?
[01:34:24] *** Joins: lisp123 (~lisp123@5.30.23.247)
[01:34:32] *** Joins: Lord_of_Life (~Lord@user/lord-of-life/x-2819915)
[01:34:50] *** Quits: eddof13 (~textual@static-201-163-9-58.alestra.net.mx) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[01:35:15] *** Joins: notzmv (~zmv@user/notzmv)
[01:35:37] <recordgroovy> Is it @informatimago?
[01:39:52] *** Quits: pve (~pve@37-136-88-109.rev.dnainternet.fi) (Quit: leaving)
[01:43:05] *** Joins: fengshaun (~fengshaun@S010680615f0c2c0a.cg.shawcable.net)
[01:47:21] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 268 seconds)
[01:48:59] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[01:52:27] *** Quits: lad (~lad@user/lad) (Read error: Connection reset by peer)
[01:52:42] *** Joins: lad (~lad@user/lad)
[01:53:28] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Excess Flood)
[01:53:46] *** Joins: Lord_of_Life (~Lord@user/lord-of-life/x-2819915)
[01:55:32] *** Quits: fiddlerwoaroof (~fiddlerwo@user/fiddlerwoaroof) (Ping timeout: 245 seconds)
[01:57:02] *** Joins: fiddlerwoaroof (~fiddlerwo@user/fiddlerwoaroof)
[01:58:02] *** Quits: recordgroovy (~recordgro@50.35.20.8) (Quit: leaving)
[01:59:04] *** Joins: recordgroovy (~recordgro@50.35.20.8)
[02:01:51] <pjb> recordgroovy: Yes.
[02:02:04] <pjb> both
[02:02:10] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[02:02:46] *** Joins: pillton (~user@2405:b000:703:2::35:28)
[02:03:01] <recordgroovy> https://github.com/armedbear/abcl/issues/388
[02:07:26] *** Joins: taiju (~taiju@240b:253:ec40:2400:a8af:540:19a2:818b)
[02:20:17] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
[02:26:52] *** Quits: gaqwas (~john@dynamic-095-117-036-184.95.117.pool.telefonica.de) (Ping timeout: 252 seconds)
[02:27:39] <recordgroovy> Figured out why it's local to stream-error
[02:42:58] *** Joins: Skyfire (~pyon@user/pyon)
[02:44:38] *** Joins: lad_ (~lad@user/lad)
[02:45:29] *** Quits: lad (~lad@user/lad) (Read error: Connection reset by peer)
[02:46:44] *** Joins: lad__ (~lad@user/lad)
[02:47:49] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[02:49:30] *** Quits: lad_ (~lad@user/lad) (Ping timeout: 260 seconds)
[02:54:05] <recordgroovy> Made a patch: https://github.com/armedbear/abcl/pull/389
[03:11:26] *** Quits: lad__ (~lad@user/lad) (Ping timeout: 260 seconds)
[03:14:52] *** Quits: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Quit: WeeChat 2.8)
[03:15:07] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
[03:16:31] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Ping timeout: 252 seconds)
[03:18:48] *** Quits: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Client Quit)
[03:19:05] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
[03:21:24] *** Quits: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Client Quit)
[03:21:41] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
[03:23:42] *** Parts: pranavats (3fba1d1b34@jabberfr.org) ()
[03:24:47] *** Quits: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Client Quit)
[03:25:09] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
[03:28:25] *** Joins: cuz (~user@2601:182:cc02:8b0:e50a:ab1e:19b4:1aaf)
[03:29:03] *** Quits: frgo (~frgo@p200300deef0cee005d8a5b6e8d5a763f.dip0.t-ipconnect.de) (Remote host closed the connection)
[03:29:34] *** Joins: frgo (~frgo@p200300deef0cee00f16a3c11b9326e8f.dip0.t-ipconnect.de)
[03:41:45] <CptKirk> is there a way to get stringify the value of a symbol maintaining its original casing?
[03:44:29] *** Joins: lisp123 (~lisp123@5.30.23.247)
[03:44:51] <hayley> symbol-name gives you the original case.
[03:45:35] <hayley> (Note that, if the read case is set to :upcase, then a symbol which was read was originally all uppercase.)
[03:46:43] *** Joins: lad (~lad@user/lad)
[03:46:54] <CptKirk> (format nil "~(~a~)" sym) works for some reason
[03:49:55] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[03:50:36] <CptKirk> (symbol-name x)
[03:50:38] <CptKirk> "Y"
[03:50:47] <CptKirk> symbol-name doesn't give me the original case, as the original case was "y"
[03:52:55] <mfiano> I sense a lot of confusion.
[03:52:57] *** Quits: attila_lendvai (~alendvai@217.65.124.57) (Ping timeout: 245 seconds)
[03:53:43] <CptJimKirk> https://codeberg.org/CptJimKirk/adventofcode/src/commit/2ba73ad0e5799b9bd0f63299787beb01496b51b8/cl/aoc-15.lisp#L36
[03:54:20] <CptJimKirk> This macro, I'm trying to define a name that is basically `defun`'d
[03:54:38] <CptJimKirk> but neither `setf` nor `defun` do what I want
[03:54:42] <saturn2> CptJimKirk: you can't get back the original casing, it is not saved
[03:54:58] <CptJimKirk> um... the thing I just linked, it works just fine
[03:55:15] <mfiano> That thing you are doing is downcasing it
[03:55:26] <CptKirk> ...oh
[03:55:54] <CptKirk> great
[03:55:56] <mfiano> (format nil "~(~a~)" 'foo) == (string-downcase 'foo)
[03:56:01] <saturn2> you can set the reader to preserve case, if you wish
[03:56:05] <hayley> "Note that, if the read case is set to :upcase [oh, and it is by default], then a symbol which was read was originally all uppercase."
[03:56:06] <CptKirk> looks like i need to be more complicated
[03:58:57] <saturn2> http://www.lispworks.com/documentation/HyperSpec/Body/23_ab.htm
[03:59:16] *** Quits: rgherdt (~rgherdt@ip5f5af456.dynamic.kabel-deutschland.de) (Ping timeout: 252 seconds)
[04:00:54] <saturn2> you can also write lowercase symbols |like| |this|
[04:01:03] <mfiano> If you ignore the value of read case, all symbols are read into uppercase strings unless character-quoted with |..|
[04:01:18] <mfiano> Note that character quoting does not need to surround the whole symbol
[04:02:15] <mfiano> '|foo|bar|baz|
[04:02:19] <mfiano> |fooBARbaz|
[04:02:22] <mfiano> for example
[04:16:02] <CptJimKirk> is it possible to evaluate "nothing"? as in somewhere in a macro ...
[04:16:16] <CptJimKirk> (some form ,maybe-nothing other stuff)
[04:16:32] <CptJimKirk> so that if its something then it would expand to (some form something other stuff)
[04:16:33] *** Quits: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net) (Quit: Leaving)
[04:16:41] <CptJimKirk> but if not it would expand to (some form other stuff)
[04:16:46] *** Joins: Oladon (~olad@98.43.81.226)
[04:18:02] <saturn2> there's no problem with evaluating nil
[04:18:32] <CptJimKirk> but I have (some form NIL other stuff)
[04:18:39] <CptJimKirk> I don't want NIL I want nothing
[04:19:15] <saturn2> (progn (something) nil (otherthing)) will have the same effect as (progn (something) (otherthing))
[04:20:26] <CptJimKirk> but if `(some` is a function, then there is a `nil` being passed as the second argument...
[04:21:00] <CptJimKirk> I want instead the 3 argument form, not the 4 argument form with a nil
[04:21:15] <CptJimKirk> (some form other stuff) is calling `some` with 3 arguments
[04:21:26] <CptJimKirk> (some form something other stuff) is calling `some` with 4 arguments
[04:21:38] <saturn2> in that case you need ,@(if maybe-nothing (list maybe-nothing))
[04:21:39] <CptJimKirk> (some form NIL other stuff) is calling `some` with 4 arguments where 1 is nil
[04:21:49] <CptJimKirk> ok
[04:22:13] <CptJimKirk> yes that did it
[04:35:02] *** Joins: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net)
[04:48:02] *** Quits: taiju (~taiju@240b:253:ec40:2400:a8af:540:19a2:818b) (Ping timeout: 260 seconds)
[05:02:29] <pjb> CptJimKirk: in a macro you can build a sexp with nothing.
[05:03:18] <pjb> CptJimKirk: (mapcar (lambda (maybe-nothing) (append '(some form) maybe-nothing '(other stuff))) '( (#|nothing|#)  (some thing))) #| --> ((some form other stuff) (some form some thing other stuff)) |#
[05:03:42] *** Quits: recordgroovy (~recordgro@50.35.20.8) (Quit: leaving)
[05:23:03] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[05:36:18] *** Quits: lottaquestions_ (~nick@2607:fa49:503f:6400:7dd7:d517:44dd:3f44) (Quit: Konversation terminated!)
[05:39:14] *** Quits: random-nick (~random-ni@87.116.183.203) (Ping timeout: 265 seconds)
[05:47:27] *** Quits: nature (~nature@mail.blazebone.com) (Ping timeout: 268 seconds)
[05:47:30] <CptJimKirk> https://codeberg.org/CptJimKirk/adventofcode/src/commit/47e343b966c319b166c9fda34b56a7783749e590/cl/aoc-15.lisp#L44
[05:47:34] *** Joins: lisp123 (~lisp123@5.30.23.247)
[05:47:58] <CptJimKirk> saturn2 how is the lisp readtable to work at all when you are expected to set the read table before the invocation of the macro?
[05:48:04] <CptJimKirk> oh wait, this is where that let trick comes into play doens't it
[05:48:23] *** Joins: nature (~nature@mail.blazebone.com)
[05:49:25] *** Joins: selwyn (~selwyn@user/selwyn)
[05:50:02] <CptJimKirk> no that didn't work
[05:50:36] <CptJimKirk> https://codeberg.org/CptJimKirk/adventofcode/src/commit/1a7491c2636c2fd9e49c039a01ceb3311492a7f2/cl/aoc-15.lisp#L36
[05:50:55] <pjb> CptJimKirk: of course, since no reading is done in the dynamic scope!
[05:51:12] <CptJimKirk> so then what is it?
[05:51:37] <pjb> It is useless to bind dynamic variables if you don't use them while they're bound.
[05:52:29] <CptJimKirk> so your'e saying that I would have to define everything that uses this and needs case insensitive symbosl would need to be done inside that let block
[05:52:35] <pjb> Also, if you don't mutate the readtable there's no point in copying it.
[05:52:48] <CptJimKirk>   (setf (readtable-case *readtable*) :preserve)
[05:52:49] <CptJimKirk> ?
[05:52:58] <pjb> I'm saying that you need to call READ or READ-FROM-STRING.
[05:53:09] <pjb> The inner copy-readtable.
[05:53:32] <pjb> Your eval is totally bonker too.
[05:54:13] <CptJimKirk> is there any way that on the other side of the macro, I can get case insensitivity?
[05:54:15] <CptJimKirk> (defmacro defapl (|name| args &rest body)
[05:54:36] <CptJimKirk> something like that, or some other thing... that would achieve the case sensitivity I need?
[05:54:54] <CptJimKirk> s/insensitive/sensitive/
[05:56:32] <pjb> CptJimKirk: april-load is a function-like macro: it has no compilation-time side effect.  Therefore there's no point in using it in the topleve of  your source file.
[05:56:47] <CptJimKirk> I don't want the user to need to know that they should (defapl |fnName| (args) ...)
[05:56:59] <pjb> Use (coerce list 'vector)  instead of (to-array list).
[05:57:21] <CptJimKirk> are "vectors" the same thing as arrays?
[05:57:31] <pjb> vector is a subclass of array.
[05:57:41] <pjb> (subtypep 'vector 'array) #| --> t ; t |#
[05:57:49] <CptJimKirk> but the APL library requires an array argument
[05:57:57] <CptJimKirk> if its fully compatible, then ok
[05:58:07] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[05:58:54] <CptJimKirk> but the main thing I'm struggling with the case insensitivy of symbols. Is there any way to achieve the behavior of (defmymacro |caseSensitive| (arg) (etc))
[05:59:02] <CptJimKirk> but on the macro side
[05:59:39] <CptJimKirk> I basically want exactly a `defun` form but case sensitive and to wrap around April calls
[06:00:44] <pjb> of course. Write: (defmymacro |caseSensitive| (arg) (etc))
[06:01:15] <CptJimKirk> ... I'm asking for an alternative, not a restatement of the only solution I've found so far
[06:01:55] <pjb> You can put this on the first line of your source file: (EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE) (SETF *READTABLE* (COPY-READTABLE NIL) (READTABLE-CASE *READTABLE*) :PRESERVE))
[06:02:03] *** Quits: yitzi (~yitzi@173-27-106-188.client.mchsi.com) (Quit: Leaving)
[06:02:05] <pjb> Then your source file becomes  case sensitive.
[06:02:26] *** Quits: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se) (Ping timeout: 265 seconds)
[06:02:31] <pjb> An alternative, but which is less pretty IMO, is to put this: (eval-when (:compile-toplevel :load-toplevel :execute) (setf *readtable* (copy-readtable nil) (readtable-case *readtable*) :invert))
[06:03:05] <pjb> In the first case you could write: (DEFMACRO caseSensitive (arg) (IF arg (etc) (whatever)))
[06:03:19] <pjb> In the second case, you would write: (defmacro caseSensitive (arg) (if arg (etc) (whatever)))
[06:04:16] <CptJimKirk> so the readtable is source-file scoped?
[06:04:27] <pjb> But in the second case, (defmacro notlower (arg) (if arg (etc) (whatever)))  would define a macro named NOTLOWER, while in the first case,  (DEFMACRO yeslower (arg) (IF arg (etc) (whatever)))  would define a macro named |yeslower|.
[06:05:32] <pjb> CptJimKirk: it is a dynamic binding = it is during some time that it will have its effect. And the time the *readtable* is used, is WHEN you READ stuff.  Eg. when you load a file, or when you compile a file.  (or when you explicitely call READ or READ-FROM-STRING).
[06:05:54] <lotuseater> CptJimKirk: you can extend the reader itself
[06:06:31] <CptJimKirk> Well, this is where I'm confused, because I want to be able to define these things interactively in the REPL as you would normally but without breaking the language
[06:06:56] <pjb> There's no breaking involved.
[06:07:30] <CptJimKirk> if I use preserve case, but I type in lowercased expressions, it can't find normal symbols
[06:07:32] <pjb> You can define a function (activate-apl-readtable) that the user can call at the REPL to start typing with APL conventions.
[06:07:56] <pjb> CptJimKirk:  indeed, You'd have to use uppercase for lisp symbols, since they ARE in uppercase!
[06:08:00] <CptJimKirk> no that's not the behavior I'm looking for
[06:08:11] <pjb> CptJimKirk: or you can use :invert but it's not pretty.
[06:08:39] <CptJimKirk> yuck
[06:09:04] <CptJimKirk> So there are some pretty harsh design considerations when messing with symbols
[06:09:17] <pjb> (let ((*readtable* (copy-readtable nil))) (setf (readtable-case *readtable*) :invert)  (read-from-string "(hello HELLO Hello)")) #| --> (hello |hello| |Hello|) ; 19 |#
[06:09:50] <CptJimKirk> but I wouldn't want to write (defun |f| (x) (* x x)) and I don't want to write (defapl |f| (lst) (coerce lst 'vector))
[06:10:28] <CptJimKirk> as a famous keyboard enthusiast once said "HHHHHHHHHHHHIDEOUS"
[06:10:37] <pjb> CptJimKirk: now, you can define a new symbol with the case changed, but this is not pretty either. But you may like it.
[06:11:14] <pjb> (defmacro defapl (name …) (let ((apl-name (intern (string-downcase name) (symbol-package name)))) … `( … ,apl-name) …))
[06:11:36] <CptJimKirk> but I can't guarantee that its all lowercase
[06:11:37] <pjb> Or you could use the same algorithm as invert.
[06:12:09] <lotuseater> when people tell me ridicolous things about "all these parentheses" i like to confuse them that those aren't really there ^^
[06:12:56] <pjb> (cond ((not-any (function lower-case-p) (symbol-name name))   (intern (string-downcase name) (symbol-package name)))  ((not-any (function upper-case-p) (symbol-name name))   (intern (string-upcase name) (symbol-package name))) (t name))
[06:13:58] <CptJimKirk> I'll have to see what that does
[06:14:02] *** Quits: nature (~nature@mail.blazebone.com) (Ping timeout: 265 seconds)
[06:14:18] <pjb> (mapcar (lambda (name) (cond ((notany (function lower-case-p) (symbol-name name))   (intern (string-downcase name) (symbol-package name)))  ((notany (function upper-case-p) (symbol-name name))   (intern (string-upcase name) (symbol-package name))) (t name))) '(foobar |FooBar| |foobar|)) #| --> (|foobar| |FooBar| foobar) |#
[06:14:52] <pjb> (mapcar (lambda (name) (cond ((notany (function lower-case-p) (symbol-name name))   (intern (string-downcase name) (symbol-package name)))  ((notany (function upper-case-p) (symbol-name name))   (intern (string-upcase name) (symbol-package name))) (t name))) '(foo-bar |Foo-Bar| |foo-bar|)) #| --> (|foo-bar| |Foo-Bar| foo-bar) |#
[06:15:27] <pjb> Notice how I have *print-case* #| --> :downcase |#
[06:17:24] <pjb> and nothing prevents you to define your macro in lowercase!
[06:17:43] <lotuseater> deep dark magic
[06:17:48] <saturn2> CptJimKirk: what is the purpose of defapl?
[06:18:02] <pjb> (defmacro |defapl| …) so that when you switch to (SETF (READTABLE-CASE *READTABLE*) :PRESERVE), you can write (defapl FooBar …)
[06:20:55] <pjb> Why would it be bad if functions defined in lisp were named with uppercase?  you could have both f and F in your apl programs, and it would be obvious that F is written in lisp.
[06:21:37] <pjb> This racism against uppercase is ridiculous!
[06:22:26] <lotuseater> oh noez racism isn't good :/
[06:29:47] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[06:29:47] *** Quits: cuz (~user@2601:182:cc02:8b0:e50a:ab1e:19b4:1aaf) (Ping timeout: 268 seconds)
[06:31:31] *** Quits: brettgilio (~brettgili@x-node.gq) (Quit: The Lounge - https://thelounge.chat)
[06:31:57] *** Joins: brettgilio (~brettgili@x-node.gq)
[06:38:49] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[06:41:41] <CptJimKirk> @saturn the purpose of defapl is that I want CL to be the driver of APL programs, or a means to compose APL programs, so I would like to define LISP funcitons that are able to call into APL functions as needed, by feeding the "return value" of the "function body" to be passed as valid April input
[06:47:31] <CptJimKirk> So conceptually, I'm passing input to a lisp function, but actually its calling the APL function of the same name
[06:47:38] <CptJimKirk> But the issue is APL functions are case sensitive
[06:48:15] <mfiano> So are lisp functions
[06:49:00] <CptJimKirk> so how do defuns intern their symbols so that they are permitted to be case sensitive?
[06:49:08] <mfiano> They already are
[06:49:12] <mfiano> You just have some learning to do on how symbols are read by the Lisp reader.
[06:49:38] <CptJimKirk> where do you suggest I turn for such knowledge
[06:50:26] <mfiano> Common Lisp Recipes book has good information on symbols. Practical Common Lisp probably touches on it.
[06:50:57] <CptJimKirk> hmm. I read that one a long time ago, but must be forgetting more than I imagine
[06:51:34] <mfiano> Understanding the Lisp reader in detail is critical to effective programming. I suggest going back to it if you didn't retain it.
[06:53:43] <CptJimKirk> I mean, I've spent so much time in the lisp liturgy that I've never actually built anything, but now that I have a project worth building I can't get it done without more bookiness?
[06:54:19] <mfiano> I don't know how you learn.
[06:55:06] <CptJimKirk> I'm not offended at the suggestion to turn to a great book for wisdom. I'm more offended at my inability to move past dwelling on reading books instead of building anything
[06:55:18] <Alfr> CptJimKirk, does your defapl really define something (like a function etc.) in lisp, from your description it sounds to me that it simply should return something that hopefully is valid input for april. You could opt for mapping lispy-names-like-this to not that lispNamesLikeThis.
[06:55:19] <CptJimKirk> I don't know many peopel who have spent so long with a language to have written so little
[06:56:20] <CptJimKirk> @alfr if I understand what you're saying, I'm trying to infer the APL name from the name of the (defapl name ...
[06:57:05] <CptJimKirk> so `(defapl myAplFn (args) (process (to-array (something-else input))))` or some such would pass the result of that body to a function from April called `myAplFn`
[06:57:21] <mfiano> It is pointless to type myAplFn
[06:57:26] <Alfr> CptJimKirk, yes.
[06:57:37] <CptJimKirk> inside the macro, it expands somewhere `(defmacro defapl name .... (april-c "myApl"fn" results)... )`
[06:57:44] <mfiano> Use |myAplFn|
[06:57:45] <lotuseater> maybe better providing a readmacro for it
[06:57:48] <CptJimKirk> that's awful
[06:57:53] <lotuseater> to avoid the pipes
[06:57:57] <mfiano> Then use a string
[06:58:04] <CptJimKirk> I've thought about both of those
[06:58:05] <mfiano> Or change the reader
[06:58:06] <lotuseater> or that
[06:58:11] <CptJimKirk> that's what I was trying to do
[06:58:15] <CptJimKirk> but I don't know how to scope that
[06:58:37] <mfiano> Well, one can't progress very far with being hung up on the fundamentals
[06:58:42] <CptJimKirk> I thought something like this would work (let ((count 0)) (defun incrmentr () (setf count (1 + count))))`
[06:58:50] <mfiano> If you have been learning Lisp for a long time, I suggest spending time on the important parts
[06:58:58] <CptJimKirk> by wrapping the `defmacro` in redefining the reader case, but that def doens't work
[06:59:17] <mfiano> Umm
[06:59:19] <lotuseater> mfiano: well said :) or first learning how to swing the wand before using
[06:59:20] <CptJimKirk> @mfiano I don't think reader macro definition is "fundamentals"
[06:59:33] <mfiano> The reader itself. No macros involved
[06:59:39] <CptJimKirk> I would say that's pretty "advanced usage"
[06:59:45] <mfiano> Umm, ok
[06:59:59] <CptJimKirk> tell me what other language allows you to manipulate the way its parsed at runtime?
[07:00:15] <CptJimKirk> I would say that alone makes it not "fundamentals"
[07:00:37] <Alfr> CptJimKirk, the function is 1+, you called the function 1.
[07:00:46] <mfiano> I would argue if you don't like the power of Lisp, which requires knowledge to use the power effectively, go back to writing APL in APL
[07:00:55] <lotuseater> CptJimKirk: but it's good to be aware that '(#\( #\) #\; #\" ...) are readmacros
[07:00:57] <CptJimKirk> @alfr sorry, I'm not accustomed to developing in an irc chat
[07:01:19] <CptJimKirk> @mfiano that is not a concluion that can be drawn from what I'm trying to do here
[07:01:31] <CptJimKirk> I'm asking how
[07:01:32] <lotuseater> Alfr: with |1| it could be indeed used as a function symbol ^^
[07:01:36] <CptJimKirk> I'm asking for how I can find out
[07:01:47] <CptJimKirk> becaues I would like to know, not because "I don't like ..."
[07:01:49] <mfiano> I gave several solutions.
[07:02:00] <CptJimKirk> you gave alternatives, but not solutions
[07:02:12] <CptJimKirk> (defapl |caseSensitive| (args) body) is an alternative
[07:02:15] <CptJimKirk> not a solution
[07:02:16] <Alfr> lotuseater, just don't.
[07:02:22] <mfiano> If you're going to argue semantics, I have no more desire to help. This is not #clschool after all.
[07:02:31] <lotuseater> Alfr: of course not :P
[07:02:36] <CptJimKirk> I don't know how I wound up in an argument
[07:02:40] <CptJimKirk> I'm trying to do something specific
[07:02:42] <CptJimKirk> and I want to know how
[07:02:48] <CptJimKirk> changing the reader I don't understand
[07:02:58] <CptJimKirk> I was trying to direct my line of questioning there before we wound up down this tangent
[07:03:26] <CptJimKirk> I did change the reader, but it didn't work the way I expected for obvious reasons, the language is read outside of the context of the re defined readtable
[07:03:38] <CptJimKirk> but also, I don't want the user to have to know to update the read table every time they want to use (defapl
[07:03:50] <CptJimKirk> I'd like it to be as immediately useful as (defun or (defvar or (defparameter
[07:04:12] <CptJimKirk> and I don't have to toggle a statemachine updating the readtable every time I want to use those
[07:04:58] <mfiano> Reading happens before everything in the Lisp compiler. I don't know how you plan to accomplish that if you don't want to use a string name.
[07:05:00] <CptJimKirk> so I'm not playing semantical games, I'm being specific, I want to be able to define in terms of a normal lisp binding form like `defun`, without having to use || or a string
[07:05:05] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[07:05:14] <Alfr> lotuseater, and I guess the number 1 also won't denote a function.
[07:05:25] <mfiano> Either use the reader, which forces a burden on users, or require them to use strings and do the work at macroexpansion time
[07:05:33] <lotuseater> no the number alone not
[07:06:06] <Alfr> lotuseater, that's what would've been read.
[07:06:34] <CptJimKirk> is there a way to define a special form that isn't a macro?
[07:06:47] <mfiano> You cannot define a special form
[07:06:55] <mfiano> Macros are not special forms
[07:07:09] <lotuseater> CptJimKirk: you could have it with brackets, [define camelCaseFunction ...] so that just the second symbol will be case preserved
[07:07:20] <Alfr> CptJimKirk, there are only that many special operators, and you can't define more.
[07:07:41] <CptJimKirk> lotuseater how does that work?
[07:08:39] *** Quits: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 265 seconds)
[07:08:43] <lotuseater> Alfr: but i can do (defun |1| (x) (1+ x)) and call it normally as a function
[07:10:03] <CptJimKirk> can you explain how [define caseSensitive ...] works?
[07:10:07] <CptJimKirk> I've never heard of that
[07:10:09] <mfiano> By defining a reader macro dispatching on #\[.
[07:10:19] <lotuseater> CptJimKirk: *you* define that :)
[07:10:32] <Alfr> lotuseater, you'd still have to write |1|, \1 or some such when calling your |1|-function.
[07:10:39] <lotuseater> or with { and } or whatever you like
[07:10:45] <lotuseater> yes
[07:10:48] <mfiano> Which requires the user to switch to your custom readtable, since that is a toplevel form
[07:10:56] <mfiano> He expressed his disinterest with doing that
[07:11:06] <CptJimKirk> yes I dont want MORE work than there is already
[07:11:15] <Alfr> lotuseater, and |1| should return something constant imo.
[07:11:15] <mfiano> Then use strings\
[07:11:20] <mfiano> or pipes
[07:11:21] <lotuseater> ah okay, it's late (or now again early) for me
[07:11:23] <mfiano> No other way
[07:11:44] <lotuseater> Alfr: your opinion?
[07:11:55] <CptJimKirk> I just think this is the first time I've encounered "nope can't do that" in CL
[07:12:02] <mfiano> By the time a macro sees its input, the Lisp reader has already read the input
[07:12:18] <CptJimKirk> right
[07:12:23] <mfiano> If you do not want to leverage the Lisp reader, you must use what is already available at read time
[07:12:25] <CptJimKirk> that's what I didn't account for with the let block
[07:12:30] <lotuseater> of course it's doable?
[07:13:04] <CptJimKirk> no it isn't doable. The specific conditions I laid out have to this point I've been told that what I specified is not possible
[07:13:19] <mfiano> You can, you just placed a lot of constraints that only open up 2 paths to a solution.
[07:13:33] <CptJimKirk> right, I was working with strings earlier
[07:13:39] <CptJimKirk> but it no longer read like a binding form
[07:13:45] <CptJimKirk> it looked instead like a function
[07:13:50] <lotuseater> so your specific conditions are well unspecific?
[07:13:51] <CptJimKirk> function *invocation
[07:14:00] <CptJimKirk> I don't know what that means?
[07:15:04] <mfiano> Another option would be to require the user to define their def forms in a file that is not loaded, and manually call #'load in some function, installing a read table around it
[07:15:11] <Alfr> lotuseater, maybe? (defun \1 () '(()))
[07:15:11] <mfiano> Or something
[07:16:06] <CptJimKirk> The user wants to be able to "call apl functions" in their lisp code, appearing like any other lisp function, but which ultimately binds to the April function by the same name, which should be definable ad-hoc without the need to manually update some global state machine for defining, either that or it would need to be defined within a block that
[07:16:07] <CptJimKirk> shadows the *readtable* which means that not only can I not bind the lisp macro to the april funciton ad-hoc, but its scope specific, and would require a recompilation of the entire reader macro block every time I make any change
[07:16:11] <CptJimKirk> That is well SPECIFIC
[07:16:21] <lotuseater> ahja
[07:16:45] <CptJimKirk> I can (defun my-fn (args) body) I want to (defapl myAplFn (args) body) just the same
[07:17:06] <CptJimKirk> without the user needing to know a bunch of tricks for using it
[07:17:29] <CptJimKirk> like, using - to mark the next character as upercase, while assuming lower case
[07:17:42] <CptJimKirk> or (defapl "myAplFn" ...) because that doesn't look like binding
[07:18:01] <CptJimKirk> I wouldn't assume looking at this expression that there is a lisp function now defined called "myAplFn"
[07:18:34] <mfiano> As mentioned, you are out of luck with all those restrictions.
[07:18:42] <CptJimKirk> and (defapl |caseSensitive| ...) is just a gotcha that you'll have to remember any time there is a apl fn with multiple case
[07:18:59] <CptJimKirk> well its good to know that I don't have any other options at least
[07:19:37] <CptJimKirk> I don't understand... Are you suggesting that any time a reader macro is used, that the user of the reader macro has to define all of their code from within the scope of that reader macro?
[07:20:15] <mfiano> Yes, reader macros are global. There is named-readtables that helps with that a little bit.
[07:20:17] <lotuseater> you use readmacros all the time
[07:20:25] <mfiano> Or rather there is only 1 read table
[07:21:55] <CptJimKirk> which ones?
[07:22:12] <mfiano> ( is a reader macro
[07:22:39] <lotuseater> (, ), ", ', ;, ... and the ones with dispatch
[07:22:42] <Alfr> clhs 2.4
[07:22:42] <specbot> Standard Macro Characters: http://www.lispworks.com/reference/HyperSpec/Body/02_d.htm
[07:22:49] <Alfr> CptJimKirk, ^
[07:24:27] <lotuseater> or when you use backquote, then in its context it activates , and ,@
[07:24:47] <CptJimKirk> but those are global
[07:25:10] <lotuseater> and?
[07:25:38] <CptJimKirk> and if I set the readtable to :preserve global defined symbols will be undefined
[07:26:07] <mfiano> The reader is a parser that operates on string data.
[07:26:10] <lotuseater> hm no, but i know what you mean
[07:26:13] <mfiano> There is no scopes
[07:26:55] <CptJimKirk> ok, they'll be defined but I'm not going to go aroun (IF (CONS-P (CADADR...
[07:27:18] <lotuseater> CONSP :)
[07:27:22] <CptJimKirk> w/e
[07:27:36] <CptJimKirk> I would find out right quick if I were in my repl :C
[07:27:51] <mfiano> You mean (null atom)
[07:28:01] <mfiano> :)
[07:28:07] <CptJimKirk> i was jut thinking of things to type :C
[07:28:20] <mfiano> Err
[07:28:29] <mfiano> (null (atom x))
[07:29:47] <CptJimKirk> why was there never any consideration for a (defreader which would pass the remaining expression to the body of the reader, which would then read the body?
[07:29:55] <CptJimKirk> that seems like a glaring oversight/misstep?
[07:30:18] <saturn2> if you want your system to be usable by lisp programmers the way they expect, without learning anything new or doing anything unusual, the only way is to explicitly map ordinary all-uppercase symbols to apl function names
[07:30:53] <CptJimKirk> which would mean I need to define all my APL names in all upcase
[07:30:58] <CptJimKirk> which is VERY retro ;)
[07:30:59] <hayley> That makes no sense. I mean, if you have "the remaining expression", you already read it.
[07:31:51] <CptJimKirk> @hayley (defreader (............)) the (...) could be a string completely unevaluated
[07:31:52] <mfiano> Yeah there seems to be a big misunderstanding of the Lisp reader still.
[07:31:56] <saturn2> i would suggest something like (defapl my-apl-fun "myAplFun" (args) body)
[07:32:08] <CptJimKirk> that is not a valid APL function name
[07:32:15] <CptJimKirk> oh
[07:32:25] <CptJimKirk> hmm, that might be a thing to do
[07:32:26] <saturn2> then you have a lisp name, and an apl name
[07:32:37] <CptJimKirk> yeah
[07:32:41] <CptJimKirk> just specify both
[07:33:15] <beach> Good morning everyone!
[07:33:16] <CptJimKirk> clumsy, but the most "makes sense" form so far
[07:33:25] <lotuseater> Hi there beach :)
[07:33:30] <CptJimKirk> hello
[07:33:47] <mfiano> Look at how cffi, burgled-batteries, and other foreign interfaces
[07:34:12] <mfiano> ...do it.
[07:34:13] <Alfr> CptJimKirk, the problem with what you expect is, that you think that the call to (defreader .............) sees the dots, it doesn't.
[07:34:15] <CptJimKirk> might do (defaple (lisp-fn apl-fn) (args) body)
[07:34:35] <hayley> CptJimKirk: The reader always leaves things unevaluated. But it still has to do some "parsing" in order to find the matching ) eventually.
[07:34:37] <CptJimKirk> s/defaple/defapl
[07:35:19] <CptJimKirk> does it have to parse, or just match the count of open an closing parens until the stack is 0?
[07:35:28] <CptJimKirk> regardless
[07:35:29] * Alfr donates some #. to hayley.
[07:36:12] <CptJimKirk> (defreader (....)) could be defined as just "reading a text string" until the matching closing paren, no parsing, then pass the string to the custom reader "macro/function" thing
[07:36:35] <Alfr> clhs 2.2
[07:36:35] <specbot> Reader Algorithm: http://www.lispworks.com/reference/HyperSpec/Body/02_b.htm
[07:36:37] <Alfr> CptJimKirk, ^
[07:36:56] <CptJimKirk> i'm not arguing about how it IS, I'm asking why this wouldn't work in a special-case special-form type thing
[07:37:11] <CptJimKirk> as in why is this kind of design not feasible to implement, since it is not
[07:37:14] <beach> Because things are read before they are evaluated.
[07:37:19] *** Joins: andrei-n (~andrei-n@109.130.156.104)
[07:37:29] <lotuseater> sounds a bit like going back to primitive C-ish macros that just set in text ...
[07:37:33] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[07:37:52] <CptJimKirk> but IF in this hypothetical form that doesn't actually exist, if it didn't EVALUATE, and only read the contents as a string?
[07:37:58] <CptJimKirk> why would that be so inconceivable?
[07:38:29] <beach> The reader would have to parse the name of the "special form" which is not what the reader does or is designed to do.
[07:38:41] <CptJimKirk> oh
[07:38:45] <beach> The reader turns characters into syntax trees.
[07:38:47] <CptJimKirk> right, back to my first mistake of the evening
[07:38:48] <Alfr> CptJimKirk, once you identify the special form symbol, the reader already has parsed and returned the list (you-new-and-shiny-special-form-symbol-name maybe some args).
[07:39:01] <Alfr> Tough usually upcased.
[07:40:24] <CptJimKirk> what about ##'#'*D->(readermacro ...) as some kind of prefix annotation to tell the reader "hey this thing is something else"?
[07:40:36] <Alfr> Good morning, beach.
[07:40:51] <CptJimKirk> that could trigger something in the readers statemachine, oh this is something else
[07:45:35] <Alfr> CptJimKirk, you can then quite freely determine how you proceed reading; maybe #@, as #a is already used for denoting arrays.
[07:46:06] <mfiano> ?
[07:46:11] <Alfr> clhs 2.4.8
[07:46:11] <specbot> Sharpsign: http://www.lispworks.com/reference/HyperSpec/Body/02_dh.htm
[07:46:14] <mfiano> @ is unavailable to use by the user
[07:47:54] <Alfr> mfiano, what? It's undefined, and I assumed he'd start modifying the standard readtable.
[07:48:31] <mfiano> Just because it is undefined in ANSI doesn't mean a conforming implementation is not allowed to define it
[07:48:44] <Alfr> mfiano, in the initial read table.
[07:51:58] <CptJimKirk> I think what I'm learning is I need to stop trying to treat CL as having a pure subset
[07:52:14] <CptJimKirk> Because that isn't a thing, setting global state is just a part of life in CL
[07:52:24] <CptJimKirk> s/setting/mutating/
[07:53:01] *** Quits: jealousmonk (~user@2804:431:e7c4:a9fe:237b:ad37:48fd:1566) (Read error: Connection reset by peer)
[07:53:05] <CptJimKirk> https://gist.github.com/chaitanyagupta/9324402#file-_reader-macros-md
[07:53:07] <CptJimKirk> this was helpful
[07:54:48] <lotuseater> oh yes that's good
[07:56:44] <beach> CptJimKirk: The other thing I recommend you do is avoid phrases such as "a glaring oversight/misstep" about how Common Lisp was designed.
[07:57:48] *** Joins: lisp123 (~lisp123@5.30.23.247)
[07:58:14] *** Quits: CptJimKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Quit: Client closed)
[07:59:03] *** Joins: CptKirk92 (~CptKirk@97-118-72-33.hlrn.qwest.net)
[07:59:54] <CptKirk92> how else should I say that having a globally specified hook into the reader macro that doesn't mutate global state would be better than mutating global state?
[08:00:07] *** CptKirk92 is now known as CptJimKirk
[08:00:30] <CptJimKirk> not sure why I was disconnected... odd
[08:01:51] <beach> Well, phrases like that seem to suggest that you know how Common Lisp was designed and that the people who designed it made a mistake.  But in fact, the design is very consistent and the people who designed it were (are?) very smart and very knowledgeable.
[08:03:06] <CptJimKirk> Clearly, I have tried and failed at implementing my own languages. To create such a universal grammar for a programming language required keen insight. I probably know more about the history of CL and APL than I do about writing quality applications with them... :/
[08:03:27] <CptJimKirk> I just meant that this seems like an obvious thing to include in the spec is all
[08:03:45] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[08:04:53] <CptJimKirk> but looking at other reader macro examples, it seems clear that mutating global state is the norm in CL, and I should just get acclimated to that.
[08:06:01] <Alfr> CptJimKirk, why does it have to modify global state? (let ((*readtable* my-readtable)) (read some-input-stream)) can cover may things.
[08:06:26] <CptJimKirk> only if all of your definitions using that reader macro are defined within that let block
[08:07:17] <CptJimKirk> but that json reader macro example showed an enable/disable function which overwrote the reader, copying the original to some stack of read-table history
[08:07:27] <Bike> as already mentioned, named-readtables lets you do things in a more declarative way
[08:07:57] <CptJimKirk> but then he corrected himself about named-readtables and said there is only 1 read-table
[08:08:55] <Bike> well, there's only one current readtable, yeah. i don't know what having more than one simultaneously would mean. there's only one syntax.
[08:08:55] <Alfr> clhs copy-readtable
[08:08:55] <specbot> http://www.lispworks.com/reference/HyperSpec/Body/f_cp_rdt.htm
[08:08:59] <Alfr> CptJimKirk, ^
[08:09:05] <Bike> but you can keep readtables around as objects and stuff.
[08:09:20] <Alfr> CptJimKirk, you can have as may as your memory holds.
[08:10:08] <CptJimKirk> My current position is basically that a custom reader macro for this particular case is way nuclear of an option for just trying to maintain case
[08:10:12] <Bike> *readtable* kind of is the globally specified hook into the reader. there are lots of ways to mutate readtables, though.
[08:10:25] <Alfr> CptJimKirk, but in a program (let's not consider special variables and threads right now) you can only have one effective readtable at any moment.
[08:10:33] <CptJimKirk> I'll probbaly roll with saturns suggestion from earlier about (defapl (lisp-fn "AplFn") (args) (body))
[08:12:52] *** Quits: Skyfire (~pyon@user/pyon) (Quit: brb)
[08:13:17] *** Joins: Skyfire (~pyon@user/pyon)
[08:14:37] *** Quits: semz (~none@user/semz) (Ping timeout: 252 seconds)
[08:24:34] *** Quits: lotuseater (~user@p200300e7870566004b01295534bb48e2.dip0.t-ipconnect.de) (Ping timeout: 260 seconds)
[08:26:55] *** Joins: semz (~none@user/semz)
[08:41:31] *** Quits: Bike (~Glossina@71.69.170.70) (Quit: Lost terminal)
[08:47:06] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[08:56:33] *** Joins: dre (~dre@2001:8003:c932:c301:4db3:5aed:63c6:cc67)
[09:00:19] *** Joins: shka (~herr@109.231.62.239)
[09:04:45] *** Parts: akoana (~ah@user/akoana) ()
[09:11:18] *** Quits: andrei-n (~andrei-n@109.130.156.104) (Quit: Leaving)
[09:17:53] *** Quits: pieguy128 (~pieguy128@bras-base-mtrlpq5031w-grc-57-65-92-163-194.dsl.bell.ca) (Quit: ZNC 1.8.2 - https://znc.in)
[09:21:04] *** Joins: pieguy128 (~pieguy128@bras-base-mtrlpq5031w-grc-57-65-92-163-194.dsl.bell.ca)
[09:38:33] *** Joins: asarch (~asarch@2806:10ae:7:34f1:7390:deaf:1a8f:32c4)
[09:57:48] *** Quits: srhm (~srhm@user/srhm) (Read error: Connection reset by peer)
[09:58:24] *** Joins: srhm (~srhm@user/srhm)
[10:13:18] *** Quits: shka (~herr@109.231.62.239) (Quit: Konversation terminated!)
[10:15:41] *** Joins: lisp123 (~lisp123@5.30.23.247)
[10:34:43] *** Quits: doyougnu (~user@c-73-25-202-122.hsd1.or.comcast.net) (Ping timeout: 252 seconds)
[10:36:40] *** Quits: scymtym (~user@ip-94-114-248-79.unity-media.net) (Ping timeout: 268 seconds)
[10:53:42] *** Joins: Nilby (~Nilby@c-67-160-81-88.hsd1.wa.comcast.net)
[10:54:07] *** Quits: Nilby (~Nilby@c-67-160-81-88.hsd1.wa.comcast.net) (Remote host closed the connection)
[10:54:59] *** Joins: Nilby (~Nilby@c-67-160-81-88.hsd1.wa.comcast.net)
[10:59:17] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[10:59:30] *** Joins: lisp123 (~lisp123@5.30.23.247)
[11:04:39] <lisp123> Does anybody know which implementations are unable to successfully extract a function expression from a function symbol via function-lambda-expression?
[11:06:05] <beach> I am willing to bet that the commercial implementations will not let you get the source code of their compiler that way.
[11:07:17] <beach> Also, for the generic functions in any implementation, I don't think there is anything reasonable to return.
[11:08:14] <lisp123> Thanks on both counts, that's useful to know. I hope the commercial implementations will allow it for user functions..
[11:09:00] <lisp123> I think its a very useful tool, if I want to create a macro that takes a function as an input and does a transformation, it makes it much easier to just use that
[11:09:14] <lisp123> vs. asking the user to type in the expression
[11:09:34] *** Joins: selwyn (~selwyn@user/selwyn)
[11:10:37] *** Quits: jemoka (~jemoka@user/jemoka) (Remote host closed the connection)
[11:11:01] *** Joins: jemoka (~jemoka@user/jemoka)
[11:11:54] *** Quits: jemoka (~jemoka@user/jemoka) (Remote host closed the connection)
[11:12:14] *** Joins: jemoka (~jemoka@user/jemoka)
[11:12:33] <moon-child> 'for the generic functions...' (typecase...)? ;)
[11:13:01] *** Quits: jemoka (~jemoka@user/jemoka) (Remote host closed the connection)
[11:13:17] <beach> Interesting idea.
[11:15:01] *** Quits: asarch (~asarch@2806:10ae:7:34f1:7390:deaf:1a8f:32c4) (Quit: Leaving)
[11:15:17] *** Joins: Qwnavery (~Qwnavery@user/qwnavery)
[11:16:28] *** Joins: jemoka (~jemoka@user/jemoka)
[11:18:22] *** Quits: jemoka (~jemoka@user/jemoka) (Remote host closed the connection)
[11:19:13] *** Joins: jemoka (~jemoka@user/jemoka)
[11:19:29] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[11:20:08] *** Joins: lisp123 (~lisp123@5.30.23.247)
[11:20:22] *** Quits: jemoka (~jemoka@user/jemoka) (Remote host closed the connection)
[11:20:42] *** Joins: jemoka (~jemoka@user/jemoka)
[11:20:52] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[11:21:04] *** Quits: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Ping timeout: 268 seconds)
[11:21:04] *** Joins: lisp123 (~lisp123@5.30.23.247)
[11:21:06] *** Quits: CptJimKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Ping timeout: 256 seconds)
[11:21:15] <lisp123> moon-child: How would that work?
[11:23:59] <beach> lisp123: The TYPECASE would emulate the discriminating function, and each case would be the method function of one method.
[11:25:15] <lisp123> And the method function would be a standard function (and not a DEFMETHOD one) yes?
[11:25:42] <beach> Method functions are ordinary functions.
[11:25:50] <beach> mop method-function
[11:25:50] <specbot> http://metamodular.com/CLOS-MOP/method-function.html
[11:27:08] <lisp123> Oh nice! Thanks - learnt something new!
[11:39:39] *** Joins: heisig (~heisig@p508b531b.dip0.t-ipconnect.de)
[11:45:24] *** Quits: pillton (~user@2405:b000:703:2::35:28) (Ping timeout: 260 seconds)
[11:46:55] <beach> lisp123: The only thing they really had to add to pre-ANSI Common Lisp to get CLOS was the STANDARD-OBJECT and the FUNCALLABLE-STANDARD-OBJECT.
[11:48:37] <lisp123> I see
[11:49:08] <beach> lisp123: Classes are just STANDARD-OBJECTs, and generic functions are just FUNCALLABLE-STANDARD-OBJECTs.
[11:49:25] *** Joins: gaqwas (~john@dynamic-077-007-103-245.77.7.pool.telefonica.de)
[11:51:15] <lisp123> I see - its a bit over my head but parts of it make sense
[11:52:09] <beach> Sure.
[12:01:35] *** Joins: igemnace (~ian@user/igemnace)
[12:07:27] *** Joins: pve (~pve@37-136-24-22.rev.dnainternet.fi)
[12:24:08] *** Joins: rain3 (~rain3___@86.127.200.187)
[12:30:26] *** Joins: rgherdt (~rgherdt@2a02:8109:86c0:d8d:2cb3:8945:1c5c:6ee2)
[12:35:30] *** Joins: hendursa1 (~weechat@user/hendursaga)
[12:38:24] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[12:39:22] *** Quits: heisig (~heisig@p508b531b.dip0.t-ipconnect.de) (Quit: Leaving)
[12:39:54] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[12:41:17] *** Joins: selwyn (~selwyn@user/selwyn)
[12:41:18] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[12:41:20] *** Joins: cage (~cage@dynamic-adsl-84-220-251-50.clienti.tiscali.it)
[12:50:48] *** Quits: kakuhen (~kakuhen@user/kakuhen) (Quit: Leaving...)
[12:56:11] <pve> Good morning! I was listening to the Lex Fridman podcast where he discusses "Cyc" with Douglas Lenat, and there's a part that may be of interest to lispers.
[12:56:19] <pve> https://www.youtube.com/watch?v=3wMKoSRbGVs&t=7623s
[12:56:45] <pve> They only talk about "Lisp", but I wonder if it's really Common Lisp under the hood?
[12:57:25] <moon-child> I believe cyc was implemented in common lisp but itself used only an s-expression syntax
[12:58:47] <pve> moon-child: yes, they also mention a "subset of lisp" called "subl", maybe that's it?
[12:59:34] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Remote host closed the connection)
[12:59:52] <moon-child> hmm, opencyc seems to be mostly java!
[12:59:59] <moon-child> so I was wrong about that
[13:00:50] <pve> moon-child: Douglas says they translate "subl" into java or c
[13:01:04] <moon-child> see also logicmoo, which is an oss continuation of cyc.  It includes this gem https://github.com/logicmoo/wam_common_lisp, which  '[Allows] Lisp programs to stop implementing an ad-hoc, informally-specified, bug-ridden, slow implementation of less than half of ISO-Prolog' :D
[13:01:20] <pve> haha
[13:01:43] <moon-child> pve: just from scanning filenames, it seems the actual inference engine is in java.  See https://github.com/asanchez75/opencyc/blob/master/KB%2Binference_engine/opencyc-0.7.0b.zip
[13:08:55] *** Joins: selwyn (~selwyn@user/selwyn)
[13:10:42] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[13:11:20] <moon-child> oh, huh, the inference engine is apparently translated to java too
[13:21:49] <White_Flame> there's also this: https://github.com/white-flame/clyc
[13:22:22] <White_Flame> yeah, the engine is written in subl, which is a cut-down lisp intended to be translated to C/Java/etc for execution
[13:23:08] <White_Flame> I'm going through as much as I can get my hands on in terms of figuring out how it works.  Especially interesting to me are how its pluggable inference modules work
[13:23:21] <pve> White_Flame: I did stumble upon clyc when searching around :)
[13:23:51] <White_Flame> I'm rewriting it, starting from data imports.  The dependency ordered file porting approach was way too unwieldy
[13:24:23] <White_Flame> at least starting from data import, I can get a better sense of what data is actually there, instead of just a bunch of opaquely named datastructures interconnecting strangely
[13:24:46] <pve> White_Flame: I assume they did not release the subl "translator"?
[13:25:12] <White_Flame> hmm, I haven't looked for that.  Subl itself is documented, so it wouldn't surprise me if that's actually public
[13:25:17] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Read error: Connection reset by peer)
[13:25:17] <pve> oh
[13:25:54] <White_Flame> well, by "public" I mean "published its java conversion in larkc" ;)
[13:26:32] <pve> White_Flame: he briefly explains in the podcast how the inference modules work, it sounds a lot like a blackboard system
[13:26:48] <White_Flame> ok, I'll give it a listen
[13:27:08] <pve> let me see if I can find the relevant part
[13:27:14] <White_Flame> I think lenat himself has gotten away from the actual technical details and mostly gives marketing descriptions nowadays
[13:28:01] <White_Flame> but with snippets from people who actually work at cycorp, it really sounds like it's a ton of manual labor to hardcode various modules to keep it from spinning to death & focus on specific problems, not that it magically finds its own way
[13:28:33] <White_Flame> ah, this is an interview with lenat
[13:28:44] <pjb> Yes, it's a big mess.
[13:29:06] <pjb> The only thing it has for it, is that it brings money to work on an AI project…
[13:29:09] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[13:29:17] <pjb> But that means a lot of overhead.
[13:29:30] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[13:29:51] *** Joins: lisp123 (~lisp123@5.30.23.247)
[13:34:50] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[13:36:36] <pve> White_Flame: it's here: https://www.youtube.com/watch?v=3wMKoSRbGVs&t=7173s
[13:37:02] * White_Flame is listening to the whole thing at 2x
[13:37:07] <White_Flame> speed
[13:38:16] *** Quits: leo_song (~leo_song@1.156.52.78) (Quit: ZNC 1.7.2+deb3 - https://znc.in)
[13:39:28] *** Joins: leo_song (~leo_song@1.156.52.78)
[13:40:57] <pve> He does paint a pretty picture. It's sad if it's a big mess in reality.
[13:43:21] <White_Flame> at the very least, the code has excessive legacy & massive technical debt built up, which makes it hard to work on
[13:43:56] <White_Flame> the design of subl was basically oriented around memory & speed efficiency for much older execution environments
[13:44:01] *** Joins: aleamb (~aleamb@81.61.187.171.dyn.user.ono.com)
[13:44:38] <White_Flame> from a knowledge engineering perspective, I hope they've kept everything cleaner, but much of that isn't public
[13:44:59] <White_Flame> there's been various releases of opencyc, and if they're all unioned together, might cover most of their actual core knowledge
[13:45:14] <White_Flame> (those KBs are apache licensed, but in a fasl-like binary form)
[13:46:51] <White_Flame> but the inference models are subl, not cycl (the knowledge language)
[13:49:06] <pve> oh, I was wondering what cycl was
[13:52:56] *** Joins: lisp123 (~lisp123@5.30.23.247)
[14:27:10] *** Joins: lotuseater (~user@p200300e7870566004b01295534bb48e2.dip0.t-ipconnect.de)
[14:28:08] *** Joins: scymtym (~user@ip-94-114-248-79.unity-media.net)
[14:59:25] <White_Flame> that's a pretty good interview, but yeah the technical details aren't beyond what's described in publicly findable documentation.  A good intro, though
[15:04:24] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[15:05:46] *** Joins: xsperry (~as@user/xsperry)
[15:09:38] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Ping timeout: 260 seconds)
[15:09:49] *** Joins: amb007 (~a_bakic@64.38.22.93.rev.sfr.net)
[15:14:06] *** Quits: amb007 (~a_bakic@64.38.22.93.rev.sfr.net) (Read error: Connection reset by peer)
[15:15:55] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[15:18:54] *** Parts: contrapunctus (a75f5b1571@2a00:c70:1:178:170:40:189:1) ()
[15:19:05] *** Joins: contrapunctus (a75f5b1571@2a00:c70:1:178:170:40:189:1)
[15:19:20] *** Joins: random-nick (~random-ni@87.116.180.139)
[15:22:56] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Read error: Connection reset by peer)
[15:24:02] *** Joins: amb007 (~a_bakic@64.38.22.93.rev.sfr.net)
[15:27:28] *** Quits: amb007 (~a_bakic@64.38.22.93.rev.sfr.net) (Read error: Connection reset by peer)
[15:28:34] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[15:29:03] *** Quits: frgo (~frgo@p200300deef0cee00f16a3c11b9326e8f.dip0.t-ipconnect.de) (Remote host closed the connection)
[15:29:30] *** Joins: frgo (~frgo@p200300deef0cee00f16a3c11b9326e8f.dip0.t-ipconnect.de)
[15:34:24] *** Parts: pranavats (3fba1d1b34@jabberfr.org) (Disconnected: Replaced by new connection)
[15:35:59] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[15:46:57] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Read error: Connection reset by peer)
[15:47:38] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[15:54:31] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Ping timeout: 265 seconds)
[15:55:04] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[16:02:16] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Ping timeout: 268 seconds)
[16:02:31] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[16:14:32] *** Joins: Everything (~Everythin@37.115.210.35)
[16:32:16] *** Joins: X-Scale` (~ARM@50.77.166.178.rev.vodafone.pt)
[16:33:55] *** Quits: X-Scale (~ARM@31.22.160.28) (Ping timeout: 252 seconds)
[16:34:08] *** X-Scale` is now known as X-Scale
[16:34:21] *** Joins: sm2n_ (~sm2n@user/sm2n)
[16:34:57] *** Quits: sm2n (~sm2n@user/sm2n) (Ping timeout: 268 seconds)
[16:39:57] *** Quits: rain3 (~rain3___@86.127.200.187) (Ping timeout: 265 seconds)
[16:42:08] *** Quits: dre (~dre@2001:8003:c932:c301:4db3:5aed:63c6:cc67) (Ping timeout: 268 seconds)
[16:50:20] *** Quits: Qwnavery (~Qwnavery@user/qwnavery) (Quit: WeeChat 3.2.1)
[16:53:33] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[16:57:09] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 268 seconds)
[17:03:47] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[17:04:23] *** Joins: lisp123 (~lisp123@5.30.23.247)
[17:09:13] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[17:17:11] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[17:20:50] *** Quits: srhm (~srhm@user/srhm) (Read error: Connection reset by peer)
[17:21:29] *** Joins: srhm (~srhm@user/srhm)
[17:28:40] *** Joins: lisp123 (~lisp123@5.30.23.247)
[17:31:30] *** Joins: rain3 (~rain3___@86.127.200.187)
[17:38:12] *** Joins: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3)
[17:38:54] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[17:39:28] *** Joins: lisp123 (~lisp123@5.30.23.247)
[17:43:18] *** Joins: Lycurgus (~juan@98.4.112.204)
[17:44:19] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[17:46:24] *** Joins: cosimone` (~user@93-47-230-5.ip115.fastwebnet.it)
[17:48:20] *** Quits: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3) (Ping timeout: 268 seconds)
[18:00:49] *** Quits: hendursa1 (~weechat@user/hendursaga) (Quit: hendursa1)
[18:01:47] *** Joins: yitzi (~yitzi@173-27-106-188.client.mchsi.com)
[18:03:45] *** Joins: X-Scale` (~ARM@83.223.227.181)
[18:04:10] *** Quits: X-Scale (~ARM@50.77.166.178.rev.vodafone.pt) (Ping timeout: 260 seconds)
[18:05:16] *** X-Scale` is now known as X-Scale
[18:08:03] *** Joins: hendursaga (~weechat@user/hendursaga)
[18:18:36] *** Joins: lisp123 (~lisp123@5.30.23.247)
[18:23:40] *** Quits: xsperry (~as@user/xsperry) (Remote host closed the connection)
[18:23:52] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Ping timeout: 265 seconds)
[18:27:45] *** Quits: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431) (Quit: Leaving)
[18:31:00] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.2)
[18:31:01] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[18:31:21] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[18:34:59] *** Quits: lotuseater (~user@p200300e7870566004b01295534bb48e2.dip0.t-ipconnect.de) (Ping timeout: 268 seconds)
[18:41:49] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[18:46:11] *** Joins: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431)
[18:48:36] *** Quits: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431) (Client Quit)
[18:49:18] *** Joins: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431)
[18:54:20] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.2.1)
[19:04:41] *** Joins: xsperry (~as@user/xsperry)
[19:04:59] *** Joins: lisp123 (~lisp123@5.30.23.247)
[19:06:14] *** Joins: ln43 (~ln43@user/ln43)
[19:07:15] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[19:09:47] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[19:10:02] *** Joins: lisp123 (~lisp123@5.30.23.247)
[19:14:39] *** Quits: ln43 (~ln43@user/ln43) (Quit: Connection closed)
[19:19:57] *** Quits: Lycurgus (~juan@98.4.112.204) (Quit: Exeunt)
[19:32:16] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[19:41:24] *** Quits: igemnace (~ian@user/igemnace) (Remote host closed the connection)
[19:54:07] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Ping timeout: 252 seconds)
[19:54:31] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[20:11:29] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Read error: Connection reset by peer)
[20:16:12] *** Quits: fitzsim (~user@69-165-165-189.dsl.teksavvy.com) (Remote host closed the connection)
[20:17:18] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[20:18:28] *** Joins: hendursaga (~weechat@user/hendursaga)
[20:21:19] *** Joins: amb007 (~a_bakic@190.135.22.93.rev.sfr.net)
[20:23:31] *** Quits: amb007 (~a_bakic@190.135.22.93.rev.sfr.net) (Read error: Connection reset by peer)
[20:26:04] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[20:34:07] *** Quits: jemoka (~jemoka@user/jemoka) (Remote host closed the connection)
[20:34:32] *** Joins: jemoka (~jemoka@user/jemoka)
[20:39:10] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Ping timeout: 240 seconds)
[20:41:19] *** Parts: contrapunctus (a75f5b1571@2a00:c70:1:178:170:40:189:1) ()
[20:42:01] *** Joins: amb007 (~a_bakic@190.135.22.93.rev.sfr.net)
[20:45:09] *** Joins: contrapunctus (a75f5b1571@2a00:c70:1:178:170:40:189:1)
[20:45:55] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 252 seconds)
[20:47:38] *** Joins: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se)
[20:51:31] *** Parts: contrapunctus (a75f5b1571@2a00:c70:1:178:170:40:189:1) ()
[20:58:28] *** Joins: contrapunctus (a75f5b1571@2a00:c70:1:178:170:40:189:1)
[21:00:55] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.2.1)
[21:02:52] *** Quits: rgherdt (~rgherdt@2a02:8109:86c0:d8d:2cb3:8945:1c5c:6ee2) (Ping timeout: 252 seconds)
[21:03:40] *** Joins: selwyn (~selwyn@user/selwyn)
[21:04:16] *** Parts: contrapunctus (a75f5b1571@2a00:c70:1:178:170:40:189:1) ()
[21:04:24] *** Quits: selwyn (~selwyn@user/selwyn) (Remote host closed the connection)
[21:04:49] *** Joins: selwyn (~selwyn@user/selwyn)
[21:08:32] *** Joins: lisp123_ (~lisp123@45.130.83.212)
[21:11:55] *** Joins: lisp123__ (~lisp123@5.30.23.247)
[21:12:19] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[21:13:32] *** Quits: yitzi (~yitzi@173-27-106-188.client.mchsi.com) (Quit: Leaving)
[21:14:58] *** Quits: lisp123_ (~lisp123@45.130.83.212) (Ping timeout: 252 seconds)
[21:14:59] *** Joins: nature (~nature@mail.blazebone.com)
[21:15:58] *** Joins: rgherdt (~rgherdt@95.90.244.86)
[21:18:17] *** Joins: rotateq (~user@p200300e787056600859d17a8b44a5685.dip0.t-ipconnect.de)
[21:21:29] *** Quits: amb007 (~a_bakic@190.135.22.93.rev.sfr.net) (Ping timeout: 268 seconds)
[21:27:22] *** Joins: amb007 (~a_bakic@202.104.204.77.rev.sfr.net)
[21:30:38] *** Joins: contrapunctus (a75f5b1571@2a00:c70:1:178:170:40:189:1)
[21:32:32] *** Quits: nature (~nature@mail.blazebone.com) (Ping timeout: 252 seconds)
[21:37:45] *** Parts: contrapunctus (a75f5b1571@2a00:c70:1:178:170:40:189:1) ()
[21:38:26] *** Joins: yitzi (~yitzi@2001:470:69fc:105::fafd)
[21:52:30] *** Joins: selwyn_ (~selwyn@user/selwyn)
[21:52:55] *** Quits: selwyn (~selwyn@user/selwyn) (Ping timeout: 252 seconds)
[22:03:27] <nick3000> Does anyone know if there is a simple way to create a 'bivalent' (I think I'm using that word right) in-memory stream with flexi streams or some other library? I was thinking some kind of class that just writes to one stream and reads from another. I want that because I am unit-testing some TCP-socket code that reads and writes to a socket. I was thinking if that was super hard I would just pass my server code two different streams,
[22:03:27] <nick3000> for writing and another for reading, rather than build my own stream.
[22:09:33] *** Joins: molson_ (~molson@2001-48F8-704A-CA1-0-0-75F-1036-static.midco.net)
[22:12:53] *** Quits: molson__ (~molson@2001-48F8-704A-CA1-0-0-75F-1030-static.midco.net) (Ping timeout: 268 seconds)
[22:17:22] <rotateq> you mean bidirectional?
[22:17:32] <nick3000> Yeah
[22:18:18] *** Parts: dstein64 (~dstein64@dannyadam.com) ()
[22:18:19] <nick3000> THe flexistream manual does use the word 'bivalent' but when I click the link to find a definition it does not point to anything with the word 'bivalent'.
[22:18:38] <Nilby> bivalent means it can write both characters and bytes
[22:18:40] <rotateq> okay I don't know it, you may have a link?
[22:18:51] <rotateq> ah good to know
[22:19:37] <rotateq> clhs bidirectional
[22:19:37] <specbot> Couldn't find anything for bidirectional.
[22:19:54] <rotateq> args :)
[22:20:39] <Nilby> a bidirectional stream just can be both read from and written to
[22:21:20] <nick3000> Okay so that is what I was looking for, if there was a library that allowed me to take an input and output stream and wrap them into a single bidirectional stream.
[22:21:46] <nick3000> Since in-memory flexi-streams are unidirectional.
[22:22:20] <nick3000> as far as I can tell...
[22:22:21] <Nilby> nick3000: maybe you could use a two-way-stream
[22:22:51] <nick3000> Ah yes exactly what I'm looking for
[22:22:56] <nick3000> Thanks
[22:23:03] <Nilby> a little chart: https://plaster.tymoon.eu/view/2638#2638
[22:23:13] <rotateq> i also like make-broadcast-stream
[22:23:32] <rotateq> oh this is a cool graphic
[22:24:28] *** Joins: contrapunctus (a75f5b1571@2a00:c70:1:178:170:40:189:1)
[22:24:39] <lisp123__> Nilby: cool chart, did you create it with a program?
[22:25:41] <Nilby> yes
[22:27:25] <Nilby> but unfortunately I haven't published my text drawing program because it's not an emacs yet
[22:27:35] <rotateq> for what is a synonym stream? i see it now in the CLHS symbol list with make-*
[22:29:42] <Nilby> synonym stream is like an alias to another stream, e.g. so you can have a stream that is actually writes to whatever *standard-output* is set to
[22:29:48] <pjb> nick3000: for a bidirectional stream, you need two streams, (four ends) and connect their ends with make-two-way-stream.
[22:30:03] <pjb> nick3000: you may also want to use pipes.
[22:30:18] <lisp123__> Nilby: Nicely done, looking forward to seeing it one day
[22:30:23] <pjb> cf. com.informatimago.clext.pipe
[22:31:11] <pjb> https://github.com/informatimago/lisp/blob/master/clext/pipe-article-en.txt
[22:32:17] <nick3000> Thanks Nilby and pjb. make-two-way-stream was exactly what I was looking for.
[22:35:51] <Nilby> nick3000: glad to help.
[22:36:31] <Nilby> It always seemed strange that the simple pipe stream not included in CL.
[22:37:26] <Nilby> I guess maybe since they didn't actually get gray streams in
[22:38:39] <loke[m]> Nilby: Because pipe streams doesn't really work in a single threaded API
[22:38:50] <loke[m]> Java also don't have them.
[22:39:10] <Nilby> loke[m]: Ah. That makes sense.
[22:40:45] <Nilby> excluding the java part ;]
[22:42:02] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[22:43:42] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[22:44:13] *** Quits: cognemo (~cognemo@cpe-46-164-31-76.dynamic.amis.net) (Ping timeout: 250 seconds)
[22:45:31] *** Quits: azimut_ (~azimut@gateway/tor-sasl/azimut) (Ping timeout: 276 seconds)
[22:48:14] <pjb> pipes are an IPC synchronization mechanism.
[22:48:32] <pjb> They're based on a semaphore (buffer size).
[22:49:02] *** Parts: contrapunctus (a75f5b1571@2a00:c70:1:178:170:40:189:1) ()
[22:50:42] *** Joins: contrapunctus (a75f5b1571@2a00:c70:1:178:170:40:189:1)
[22:59:51] *** Quits: sander (~sander@user/sander) (Ping timeout: 265 seconds)
[23:00:50] *** Joins: VincentVega (~user@212.241.25.220)
[23:03:50] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
[23:04:22] *** Quits: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Client Quit)
[23:09:35] *** Joins: Lycurgus (~juan@98.4.112.204)
[23:10:12] *** Joins: igemnace (~ian@user/igemnace)
[23:16:06] <jcowan> Also, CL was meant to work on non-Posix operating systems  that didn't have pipes.
[23:16:12] <jcowan> (except VM/CMS)
[23:16:26] <jcowan> likewise Java
[23:18:39] *** Quits: rain3 (~rain3___@86.127.200.187) (Ping timeout: 268 seconds)
[23:32:59] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
[23:33:15] <CptKirk> I'm searching for a loop form that cycles over a list
[23:33:57] <CptKirk> I have a list of "0 1" and I want to repeatedly cycle over that list say, 10 times, collecting items from the list. say 0 1 0 1 0 1 0 1 0 1
[23:34:23] *** Joins: sander (~sander@user/sander)
[23:34:55] <CptKirk> I can of course write this in raw lisp, but I'm looking for a loop macro that does this if there is one
[23:35:24] <lisp123__> (dotimes 10 (loop for item in list append item))
[23:35:26] <lisp123__> Does that work?
[23:35:43] *** Quits: amb007 (~a_bakic@202.104.204.77.rev.sfr.net) (Ping timeout: 252 seconds)
[23:36:29] <yitzi> Your dotimes is malformed.
[23:36:39] <lisp123__> yitzi: Yeah noticed that
[23:36:43] <lisp123__> Fixing it now
[23:38:05] <Nilby> (loop for i in' #1=(0 1 . #1#) do (print i))
[23:38:07] *** Parts: contrapunctus (a75f5b1571@2a00:c70:1:178:170:40:189:1) ()
[23:38:23] <CptKirk> (setf ns (loop for i from 1 to 100 for j in '(1 2) collecting j))
[23:38:27] <CptKirk> I would have thought this would do it
[23:38:35] *** Joins: contrapunctus (a75f5b1571@2a00:c70:1:178:170:40:189:1)
[23:38:37] <CptKirk> but I guess it only goes for the min length of either list
[23:38:52] <lisp123__> CPtKirk - look into (look for item in list append ...)
[23:39:00] <lisp123__> some combination of that will get you what you want
[23:39:02] <Nilby> er, um, (loop for i in' #1=(0 1 . #1#) repeat 10 collect i)
[23:39:55] <CptKirk> I don' kow what that #1= #1# stuff is
[23:40:00] <lisp123__> Nicely done
[23:40:32] <Nilby> reader macros to make a circular list
[23:41:04] <CptKirk> ah, clever
[23:41:20] <Nilby> splice itself in itself
[23:41:28] <Nilby> you can do it without macros too
[23:41:30] <lisp123__>  (loop for x from 1 to 10 append (loop for item in '(0 1) append (list item)))
[23:42:20] <lisp123__> But append is highly inefficient, just wanted to show that its a useful keyword in the loop macro
[23:43:35] *** Joins: amb007 (~a_bakic@6.104.204.77.rev.sfr.net)
[23:45:08] <yitzi> If you are not trying to do processing along the way (apply #'append (make-list 10 :initial-element '(0 1)))
[23:46:42] <rotateq> CptKirk: in general the #n= is for labeling a form and with #n# you can recall it so that the reader sets the form in at that place too
[23:47:36] <CptKirk> wow
[23:48:57] <Alfr> CptKirk, for a non-circular list L which you are allowed to modify: (setf (cdr (last L)) L)
[23:49:10] <rotateq> sometimes very useful but shouldn't be used in real source files
[23:49:30] <CptKirk> how does the interpreter handle the circular list?
[23:49:42] <CptKirk> it only reads when reading the value of that slot? or....
[23:54:21] <Nilby> It's just a copy and paste. The reader just copies #1 where it sees #1#. The cons cell is already created before it's contents are put in.
[23:54:44] <Alfr> CptKirk, it's not clear what you're asking. But as CALL-ARGUMENTS-LIMIT is an integer, it's finite, thus a circular list can't be a function call form.
[23:55:44] *** Joins: newlispurr (~newlispur@2804:14d:baa2:4491:28e2:db2d:5eb3:deb2)
[23:56:29] <CptKirk> @nilby but when does it do that, clearly it can't do that infinitely?
[23:56:46] <CptKirk> @alfr I'm asking at what time does it expand the #1# reference because clearly it can't do that infinitely
[23:58:19] <rotateq> you can view it as a kind of lazy list i would say (when handled correctly)
[23:58:37] <CptKirk> how would you handle it incorrectly so I know what to avoid?
[23:58:56] <rotateq> try out :)
