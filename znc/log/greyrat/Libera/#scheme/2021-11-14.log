[00:27:26] *** Quits: X-Scale (~ARM@46.50.4.208) (Ping timeout: 260 seconds)
[00:27:34] *** Joins: X-Scale` (~ARM@165.201.137.78.rev.vodafone.pt)
[00:28:36] *** Joins: klovett (~klovett@166.205.90.177)
[00:28:38] *** X-Scale` is now known as X-Scale
[00:47:40] *** Joins: badkins (~badkins@136.56.92.199)
[00:52:10] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 260 seconds)
[01:01:07] *** Joins: badkins (~badkins@136.56.92.199)
[01:03:22] *** Quits: X-Scale (~ARM@165.201.137.78.rev.vodafone.pt) (Ping timeout: 260 seconds)
[01:05:47] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 264 seconds)
[01:06:45] *** Joins: badkins (~badkins@136.56.92.199)
[01:08:10] *** Joins: X-Scale (~ARM@83.223.243.66)
[01:12:42] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 260 seconds)
[01:27:08] *** Joins: oxum (~oxum@122.172.47.114)
[01:28:01] *** Joins: logc (~logc@customer-46-39-97-220.stosn.net)
[01:28:49] *** Parts: logc (~logc@customer-46-39-97-220.stosn.net) ()
[01:30:43] *** Joins: poselyqualityles (~poselyqua@user/poselyqualityles)
[01:31:06] *** Quits: torbjornsd (~torbjorns@213.158.42.177) (Read error: No route to host)
[01:32:11] *** Quits: oxum (~oxum@122.172.47.114) (Ping timeout: 264 seconds)
[01:32:51] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[01:36:39] *** Joins: badkins (~badkins@136.56.92.199)
[01:38:50] *** Quits: deltab (~deltab@user/deltab) (Ping timeout: 260 seconds)
[01:39:09] <mdhughes> The Chez extensions seem to cover most of my needs, and the path-splitting code works. https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:h16
[01:40:15] *** Quits: poselyqualityles (~poselyqua@user/poselyqualityles) (Ping timeout: 256 seconds)
[01:40:16] <mdhughes> (chmod) is poorly named for Scheme, tho. I expect path-permission-set! or some such.
[01:42:16] <sham1> set-path-permissions!
[01:42:39] *** Joins: Guest3920 (~Guest39@customer-46-39-97-220.stosn.net)
[01:46:29] *** Quits: Guest3920 (~Guest39@customer-46-39-97-220.stosn.net) (Quit: Client closed)
[01:49:34] *** Quits: mononote (~mononote@user/mononote) (Read error: Connection reset by peer)
[01:49:55] *** Joins: deltab (~deltab@user/deltab)
[01:50:33] *** Quits: theruran (uid11305@hampstead.irccloud.com) (Quit: Connection closed for inactivity)
[02:01:06] <mdhughes> noun-verb(-set!|\?)? pls
[02:02:32] <mdhughes> One of the reasons I like Scheme is 15 years of Objective-C trained me that long names explicitly stating types and actions are good.
[02:08:39] *** Joins: tfeb (~tfb@88.98.95.237)
[02:09:39] *** tfeb is now known as tfb
[02:15:35] *** Quits: tfb (~tfb@88.98.95.237) (Quit: died)
[02:17:51] *** Joins: logc (~logc@customer-46-39-97-220.stosn.net)
[02:23:07] *** Joins: klovett_ (~klovett@166.205.90.177)
[02:24:43] *** Quits: logc (~logc@customer-46-39-97-220.stosn.net) (Remote host closed the connection)
[02:25:58] *** Quits: klovett (~klovett@166.205.90.177) (Ping timeout: 260 seconds)
[02:26:43] *** Joins: xgqt_ (~user@static62133140007.ostnet.pl)
[02:27:01] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[02:31:02] *** Quits: xgqt (~user@static62133140007.ostnet.pl) (Ping timeout: 268 seconds)
[02:51:10] *** Joins: badkins (~badkins@136.56.92.199)
[03:44:11] *** Quits: civodul (~user@guix/contributor/civodul) (Ping timeout: 264 seconds)
[03:45:28] *** Joins: oxum (~oxum@122.172.47.114)
[03:48:51] *** Joins: mononote (~mononote@user/mononote)
[03:51:12] *** Quits: oxum (~oxum@122.172.47.114) (Ping timeout: 268 seconds)
[03:58:15] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[04:29:21] *** xgqt_ is now known as xgqtd
[04:29:31] *** xgqtd is now known as xgqt
[04:30:31] *** Quits: taiju (~taiju@240b:253:ec40:2400:2cdc:1f32:d88a:fa10) (Ping timeout: 245 seconds)
[04:36:21] *** Quits: rgherdt (~rgherdt@2a02:8109:86c0:d8d:f999:7dbf:ab48:5803) (Ping timeout: 245 seconds)
[04:36:32] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[04:44:35] *** Joins: rgherdt (~rgherdt@2a02:8109:86c0:d8d:f999:7dbf:ab48:5803)
[04:46:54] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Ping timeout: 260 seconds)
[04:58:51] *** Quits: rgherdt (~rgherdt@2a02:8109:86c0:d8d:f999:7dbf:ab48:5803) (Ping timeout: 245 seconds)
[05:01:46] *** Quits: klovett_ (~klovett@166.205.90.177) (Ping timeout: 245 seconds)
[05:15:27] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[05:22:24] *** Joins: badkins (~badkins@136.56.92.199)
[05:27:02] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 260 seconds)
[05:30:21] *** Quits: cornett_ (~ben@149.28.239.26) (Quit: WeeChat 2.9)
[05:33:31] *** Quits: seninha (~seninha@user/seninha) (Quit: Leaving)
[05:38:28] *** Joins: oxum (~oxum@122.172.47.114)
[05:42:06] *** Joins: notzmv (~zmv@user/notzmv)
[05:44:14] *** Quits: oxum (~oxum@122.172.47.114) (Remote host closed the connection)
[05:45:16] *** Joins: oxum (~oxum@122.172.47.114)
[05:47:16] *** Quits: oxum (~oxum@122.172.47.114) (Remote host closed the connection)
[05:48:33] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[05:50:32] *** Joins: oxum (~oxum@122.172.47.114)
[05:59:59] *** Quits: oxum (~oxum@122.172.47.114) (Remote host closed the connection)
[06:01:04] *** Joins: oxum (~oxum@122.172.47.114)
[06:11:50] *** Joins: badkins (~badkins@136.56.92.199)
[06:16:30] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 260 seconds)
[06:26:03] *** Quits: oxum (~oxum@122.172.47.114) (Remote host closed the connection)
[06:28:27] *** Joins: oxum (~oxum@122.172.47.114)
[06:38:31] *** Quits: oxum (~oxum@122.172.47.114) (Remote host closed the connection)
[06:39:33] *** Joins: oxum (~oxum@122.172.47.114)
[06:44:58] *** Quits: oxum (~oxum@122.172.47.114) (Ping timeout: 260 seconds)
[06:54:59] *** Quits: Inline (~Inline@2a02:908:1252:7a80:22ee:92f9:2a07:2e7) (Ping timeout: 264 seconds)
[07:16:20] *** Joins: badkins (~badkins@136.56.92.199)
[07:20:49] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 256 seconds)
[07:52:23] *** Joins: oxum (~oxum@122.172.47.114)
[07:54:19] *** Quits: cognemo (~cognemo@cpe-46-164-24-121.dynamic.amis.net) (Quit: ZNC 1.8.2 - https://znc.in)
[07:54:35] *** Joins: cognemo (~cognemo@cpe-46-164-24-121.dynamic.amis.net)
[07:57:18] *** Quits: oxum (~oxum@122.172.47.114) (Ping timeout: 260 seconds)
[08:03:09] *** Joins: s-liao (~s-liao@101.86.101.64)
[08:39:39] *** Joins: oxum (~oxum@122.172.47.114)
[08:41:47] *** Quits: oxum (~oxum@122.172.47.114) (Remote host closed the connection)
[09:00:04] *** Parts: pranavats (3fba1d1b34@jabberfr.org) ()
[09:04:20] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[09:07:15] *** Quits: s-liao (~s-liao@101.86.101.64) (Quit: Client closed)
[09:43:20] *** Joins: badkins (~badkins@136.56.92.199)
[09:43:43] *** Joins: poselyqualityles (~poselyqua@user/poselyqualityles)
[09:48:01] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 245 seconds)
[09:58:55] *** Quits: skapata (~Skapata@user/skapata) (Remote host closed the connection)
[10:15:50] *** Joins: badkins (~badkins@136.56.92.199)
[10:22:11] *** Quits: zwr (~zwr@2804:d45:b966:fb00:ea42:8fa9:6c11:b414) (Ping timeout: 245 seconds)
[10:22:53] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[10:23:10] *** Joins: zwr (~zwr@2804:d45:b966:fb00:f670:f79d:3e7d:a052)
[10:31:13] *** Quits: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net) (Ping timeout: 256 seconds)
[10:31:49] *** Quits: daviid`` (~user@179.210.52.91) (Read error: Connection reset by peer)
[10:32:04] *** Joins: s-liao (~s-liao@101.86.101.64)
[10:34:11] *** Joins: daviid`` (~user@179.210.52.91)
[10:41:34] *** Quits: mononote (~mononote@user/mononote) (Ping timeout: 260 seconds)
[10:52:11] *** Quits: poselyqualityles (~poselyqua@user/poselyqualityles) (Ping timeout: 256 seconds)
[10:55:57] *** Quits: sdu (~doo@185.44.146.165) (Remote host closed the connection)
[11:09:59] *** Joins: oxum (~oxum@122.172.47.114)
[11:14:31] *** Quits: oxum (~oxum@122.172.47.114) (Remote host closed the connection)
[11:17:54] *** Joins: oxum (~oxum@122.172.47.114)
[11:20:08] *** Quits: oxum (~oxum@122.172.47.114) (Remote host closed the connection)
[11:23:03] *** Joins: oxum (~oxum@136.185.170.109)
[11:28:08] *** Joins: Inline (~Inline@2a02:908:1252:7a80:9763:cc0b:5eaf:ee4)
[11:28:09] *** Quits: oxum (~oxum@136.185.170.109) (Ping timeout: 268 seconds)
[11:28:40] *** Quits: Inline (~Inline@2a02:908:1252:7a80:9763:cc0b:5eaf:ee4) (Remote host closed the connection)
[11:30:14] *** Joins: Inline (~Inline@2a02:908:1252:7a80:9763:cc0b:5eaf:ee4)
[11:35:13] *** Joins: oxum (~oxum@136.185.170.109)
[11:39:33] *** Quits: oxum (~oxum@136.185.170.109) (Remote host closed the connection)
[11:44:20] *** Joins: oxum (~oxum@136.185.170.109)
[11:47:14] *** Quits: oxum (~oxum@136.185.170.109) (Remote host closed the connection)
[12:04:08] *** Quits: s-liao (~s-liao@101.86.101.64) (Quit: Client closed)
[12:07:35] *** Quits: amk (~amk@109.255.169.126) (Ping timeout: 264 seconds)
[12:09:59] *** Joins: amk (~amk@109.255.169.126)
[12:18:44] *** Joins: oxum (~oxum@136.185.170.109)
[12:23:44] *** Quits: oxum (~oxum@136.185.170.109) (Remote host closed the connection)
[12:29:00] *** Joins: oxum (~oxum@136.185.170.109)
[12:33:51] *** Quits: oxum (~oxum@136.185.170.109) (Ping timeout: 245 seconds)
[12:48:25] *** Joins: mononote (~mononote@user/mononote)
[12:58:38] *** Joins: rgherdt (~rgherdt@2a02:8109:86c0:d8d:f999:7dbf:ab48:5803)
[13:10:51] *** Joins: oxum (~oxum@136.185.170.109)
[13:11:54] *** Quits: Inline (~Inline@2a02:908:1252:7a80:9763:cc0b:5eaf:ee4) (Quit: Leaving)
[13:15:30] *** Joins: s-liao (~s-liao@101.86.101.64)
[13:15:43] *** Quits: s-liao (~s-liao@101.86.101.64) (Client Quit)
[13:20:01] *** Quits: oxum (~oxum@136.185.170.109) (Remote host closed the connection)
[13:20:13] *** Joins: oxum (~oxum@136.185.170.109)
[13:20:35] <amazigh> I read the semantics of R7RS, I do not see call/cc in that pdf p. 65+
[13:22:05] <amazigh> I will re-boot my scheme-to-javascript compiler, this time with the goal to make a release
[13:23:19] <amazigh> It will not be compliant with RnRS; string will be javascript strings (hence immutable and buggy), numbers will be javascript numbers;
[13:24:16] <amazigh> previous iteration had two goals: a) explore wasm b) replace nanopass with match
[13:24:55] <amazigh> wasm is not ready for prime time, and the performance are not much better than javascript (at least with the compilation strategy I use)
[13:26:01] <amazigh> In fact, targeting javascript with the same strategy, yields better wall-clock time both on v8 and spider monkey.
[13:26:25] <amazigh> v8 tested with nodejs, and spidermonkey with jsshell
[13:27:57] <amazigh> This time I aim for TCO with a trampoline, call/cc also with cps and trampoline, and js ffi.
[13:28:27] <amazigh> (that is the plan until I have a better idea :D)
[13:30:07] <rgherdt> page 68: cwcc
[13:30:56] <amazigh> dpk: regarding binary search, did you consider binary search with cursor? so that further operation on the "sequence" does not require to traverse the "sequence" again. It seems very appealing in the case of trees.
[13:31:24] <dpk> trees are rarely numerically indexed
[13:31:26] *** Joins: s-liao (~s-liao@101.86.101.64)
[13:31:37] <dpk> or is that what you meant?
[13:31:45] <dpk> cursors instead of indexes?
[13:32:57] <amazigh> dpk: yes
[13:33:55] <amazigh> in the case of "string buffers" they are numerically indexed.
[13:34:26] <dpk> my instinctive feeling is that trees' logarithmic access time is intrinsic in their design, meaning implementations can handle cases like that internally more effectively than they could be coerced to a standard interface. vectors are not intrinsically logarithmically accessed
[13:35:50] <amazigh> I am not sure what to make of your last message.
[13:35:53] <amazigh> with in interface such as cursor-next, cursor-prev, cursor-current, it is possible to traverse any kind of sequence
[13:36:14] <dpk> that said, when i was implementing B-trees recently (implementation unfinished, will probably be done again from scratch) i did consider that implementing range queries would need something to keep track of the path to the current leaf node when traversing
[13:36:23] <dpk> well, then we're back at iteration and generators ;-)
[13:36:31] <amazigh> and it can implement the current spec too.
[13:37:00] <amazigh> re b-trees, I did a similar work; I keep track of the path to the current leaft.
[13:37:18] <amazigh> re generators: how so?
[13:37:21] <dpk> i should finish working on my optionally-purely-functional iteration API
[13:39:07] <dpk> although i'm somewhat discouraged by jcowan's insistence that each individual R7RS docket is final once voted on, and things won't be removed. so anything i (or anyone else) might make to replace (scheme generator) couldn't *replace* the flawed design we already have, only 'complement' it
[13:40:25] <dpk> won't make progress today alas as i'm at a conference (and should be preparing to take official minutes for the next session, rather than nattering on IRC)
[13:42:24] <amazigh> no worries obv, thanks for the heads up!
[13:42:55] <amazigh> removing libraries is backward incompatible.
[13:43:04] <dpk> see srfi-discuss
[13:43:07] <amazigh> ref: the mutable binary tree https://git.sr.ht/~amirouche/ruse-scheme/tree/main/item/src/arew/data/bbtree.scm
[13:43:29] <dpk> we have no charter obligation to be backward compatible with previous R7RS 'editions' until R7RS Large is finalized
[13:43:49] <dpk> we only have to be backward compatible with R7RS small
[13:45:19] <amazigh> ref: functional iteration https://srfi-email.schemers.org/srfi-discuss/msg/17997906/
[13:46:03] *** Joins: Inline (~Inline@2a02:908:1252:7a80:b442:91f8:4666:206e)
[13:46:31] <amazigh> fwiw, I need to see more code to +1 functional iteration, my current arguments in favor of generators is performance, and ease of use.
[13:46:49] <amazigh> also having one more lazy-machinery, seems odd at this time.
[13:47:00] <amazigh> but that does not mean it is not a good srfi.
[13:47:23] <amazigh> ease of use and simplicity
[13:47:34] <amazigh> at least it looks simple.
[13:48:12] <amazigh> re generator, in okvs, I also would need to close the underlying cursor (or just use an ad-hoc cursor, instead of generators)
[13:50:13] <amazigh> rgherdt: ty.
[13:59:37] <dpk> right, my proposal is to have an iteration protocol where the consumer can decide whether to consume pure-functionally for [insert usual benefits of functional programming here] or imperatively for performance
[14:12:52] *** Quits: s-liao (~s-liao@101.86.101.64) (Quit: Client closed)
[14:13:04] *** Joins: s-liao (~s-liao@101.86.101.64)
[14:29:07] *** Quits: s-liao (~s-liao@101.86.101.64) (Quit: Client closed)
[14:29:25] *** Joins: s-liao (~s-liao@101.86.101.64)
[14:29:37] *** Joins: Guest2 (~Guest2@2001:ce8:131:5f61:10dc:1015:53d0:c1b3)
[14:42:18] *** Quits: Guest2 (~Guest2@2001:ce8:131:5f61:10dc:1015:53d0:c1b3) (Ping timeout: 256 seconds)
[15:17:26] *** Quits: s-liao (~s-liao@101.86.101.64) (Ping timeout: 256 seconds)
[15:42:58] *** Quits: retropikzel (~retropikz@dsl-trebng22-54f932-93.dhcp.inet.fi) (Remote host closed the connection)
[15:43:24] *** Joins: retropikzel (~retropikz@dsl-trebng22-54f932-93.dhcp.inet.fi)
[15:52:09] *** Joins: s-liao (~s-liao@101.86.101.64)
[15:53:05] *** Joins: zap (~zap@gateway/tor-sasl/zap)
[15:53:34] *** Quits: zap (~zap@gateway/tor-sasl/zap) (Client Quit)
[16:02:12] *** Quits: s-liao (~s-liao@101.86.101.64) (Ping timeout: 256 seconds)
[16:20:50] *** Joins: seninha (~seninha@user/seninha)
[16:22:44] *** Quits: madage (~madage@user/madage) (Remote host closed the connection)
[16:28:38] *** Quits: retropikzel (~retropikz@dsl-trebng22-54f932-93.dhcp.inet.fi) (Read error: Connection reset by peer)
[16:28:59] *** Joins: retropikzel (~retropikz@dsl-trebng22-54f932-93.dhcp.inet.fi)
[16:30:56] *** Quits: retropikzel (~retropikz@dsl-trebng22-54f932-93.dhcp.inet.fi) (Remote host closed the connection)
[16:31:08] *** Joins: retropikzel_ (~retropikz@dsl-trebng22-54f932-93.dhcp.inet.fi)
[16:31:13] *** Joins: madage (~madage@user/madage)
[16:34:08] *** Joins: poselyqualityles (~poselyqua@user/poselyqualityles)
[16:46:06] *** Joins: s-liao (~s-liao@101.86.101.64)
[16:47:27] *** Joins: retropikzel__ (~retropikz@dsl-trebng22-54f932-93.dhcp.inet.fi)
[16:47:37] *** Quits: retropikzel_ (~retropikz@dsl-trebng22-54f932-93.dhcp.inet.fi) (Remote host closed the connection)
[16:51:40] *** Joins: Guest2 (~Guest2@2001:ce8:131:5f61:10dc:1015:53d0:c1b3)
[16:56:05] *** Quits: Guest2 (~Guest2@2001:ce8:131:5f61:10dc:1015:53d0:c1b3) (Client Quit)
[17:03:36] *** Quits: retropikzel__ (~retropikz@dsl-trebng22-54f932-93.dhcp.inet.fi) (Read error: Connection reset by peer)
[17:05:49] *** Joins: Everything (~Everythin@37.115.210.35)
[17:49:47] *** Joins: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net)
[17:51:10] *** Quits: s-liao (~s-liao@101.86.101.64) (Quit: Client closed)
[17:52:39] *** Joins: s-liao (~s-liao@101.86.101.64)
[17:58:21] *** Joins: klovett (~klovett@70.39.110.107)
[18:10:04] *** Quits: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net) (Ping timeout: 265 seconds)
[18:27:46] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Ping timeout: 260 seconds)
[18:28:05] *** Joins: badkins (~badkins@136.56.92.199)
[18:29:31] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[18:32:36] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 245 seconds)
[18:34:06] *** Quits: oxum (~oxum@136.185.170.109) (Remote host closed the connection)
[18:35:50] *** Quits: s-liao (~s-liao@101.86.101.64) (Quit: Client closed)
[18:36:37] *** Joins: Guest2 (~Guest2@2001:ce8:131:5f61:10dc:1015:53d0:c1b3)
[18:38:37] *** Joins: oxum (~oxum@136.185.170.109)
[18:43:10] *** Quits: oxum (~oxum@136.185.170.109) (Ping timeout: 260 seconds)
[18:46:23] *** Joins: gproto23 (~gproto23@user/gproto23)
[18:52:04] *** Quits: Guest2 (~Guest2@2001:ce8:131:5f61:10dc:1015:53d0:c1b3) (Quit: Client closed)
[18:59:49] *** Joins: badkins (~badkins@136.56.92.199)
[19:05:34] *** Quits: johnjay (~pi@192.142.100.50) (Ping timeout: 260 seconds)
[19:07:01] *** Joins: johnjay (~pi@192.142.100.50)
[19:10:19] *** Quits: poselyqualityles (~poselyqua@user/poselyqualityles) (Read error: Connection reset by peer)
[19:17:43] *** Joins: sp1ff (~user@c-73-189-25-64.hsd1.ca.comcast.net)
[19:26:44] *** Quits: johnjay (~pi@192.142.100.50) (Ping timeout: 256 seconds)
[19:30:29] *** Joins: johnjay (~pi@192.142.100.50)
[19:41:38] <Zipheir> amazigh: It's called `cwcc`
[19:45:24] *** Joins: robin__ (~robin@user/terpri)
[19:45:25] <Zipheir> "Nattering on IRC", AKA the official minutes of #scheme. :)
[19:46:35] *** Quits: robin (~robin@user/terpri) (Ping timeout: 264 seconds)
[19:49:10] *** Quits: robin__ (~robin@user/terpri) (Client Quit)
[19:49:27] *** Joins: robin (~robin@user/terpri)
[19:58:01] *** Quits: johnjay (~pi@192.142.100.50) (Ping timeout: 245 seconds)
[19:58:03] *** Quits: seninha (~seninha@user/seninha) (Remote host closed the connection)
[20:00:13] *** Joins: johnjay (~pi@192.142.100.50)
[20:02:29] *** Joins: seninha (~seninha@user/seninha)
[20:04:20] <amazigh> Yes, rgherdt helped me find. I still do not understand how cwcc works, but I did not spend too much time trying either.
[20:04:37] <amazigh> s/too much time/a lot of time/
[20:04:46] <amazigh> Actually, I read it twice :)
[20:05:11] *** Quits: johnjay (~pi@192.142.100.50) (Ping timeout: 264 seconds)
[20:06:09] <amazigh> I am one or two steps away to be able to run a make-coroutine-benchmark
[20:06:14] <Zipheir> The operational semantics (published with R6) are easier to make sense of https://users.cs.northwestern.edu/~robby/pubs/papers/jfp2008-mf.pdf
[20:06:28] *** Joins: johnjay (~pi@192.142.100.50)
[20:41:24] *** Joins: aportnoy (~aportnoy@mobile-166-172-123-171.mycingular.net)
[20:41:50] *** Quits: aportnoy (~aportnoy@mobile-166-172-123-171.mycingular.net) (Changing host)
[20:41:50] *** Joins: aportnoy (~aportnoy@user/aportnoy)
[20:42:10] *** Joins: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net)
[20:43:07] <aportnoy> is there a Scheme implementation that has a disassemble function like SBCL?
[20:43:49] <sham1> Well the (disassemble) is part of the Common Lisp standard so if there is, it's going to be different. Although I don't see why an implementation couldn't have such a thing
[20:46:01] <sham1> Guile has the ,x command in the REPL, although it's not a function like (disassemble) is
[20:47:57] <sham1> Maybe there is a function equivalent for it, but I don't know it
[20:48:26] <aportnoy> hmm yeah seems like ,x disassembles to some VM bytecode
[20:49:13] <aportnoy> yeah I'm looking for a Scheme implementation that supports compilation/decompilation in the interpreter
[20:49:19] <amazigh> you can do that with Chez, but I do not recall how
[20:49:28] <amazigh> oh then no
[20:49:30] <amazigh> not chez
[20:49:53] <sham1> And by compilation you mean compiling to machine code?
[20:50:50] <aportnoy> doesn't really matter if there's an intermediate step like compiling to C.
[20:51:26] <aportnoy> does SBCL compile to C? does it use any existing compiler infra like GCC/LLVM?
[20:51:34] <sham1> I don't think SBCL does
[20:51:45] *** Joins: civodul (~user@guix/contributor/civodul)
[20:52:00] <aportnoy> I know Chicken can compile to C but not interactively I don't think
[20:52:39] <Zipheir> Reflection is not as big in the Scheme world as it is in CL.
[20:53:47] <rgherdt> aportnoy: in chicken you can use the egg compile-file to compile from the interpreter. But that doesn't give you the disassemble functionality you are looking for
[20:54:13] <Zipheir> Wow, the CLHS specification of DISASSEMBLE is extremely unspecific.
[20:55:03] <sham1> Well it's all implementation defined. From what I've understood, some implementations show a bytecode there
[20:55:21] <Zipheir> I wonder if it would be compliant to return an English paraphrase of what the supplied function does...
[20:55:41] <aportnoy> rgherdt, I guess I could make a function to shell out and run objdump on the object file
[20:55:55] <sham1> What is it you're trying to do, like really
[20:56:04] <sham1> Why do you need the disassembly
[20:56:22] <rgherdt> aportnoy: sure, a simple workaround indeed
[20:56:28] <Zipheir> "simple"
[20:56:50] <aportnoy> sham1: I'm trying to have even more fun with a Scheme interpreter :)
[20:56:52] <Zipheir> Easy to do, perhaps, but semantically very complicated.
[20:56:55] <sham1> Fair enough
[20:57:49] <aportnoy> It's just so cool how you can modify a function and watch the machine code change.
[20:58:18] <Zipheir> aportnoy: If that's your goal, you might want to write your own (metacircular?) reflective interpreter/compiler.
[20:58:37] <sham1> Make your own Scheme to experiment with JITs!
[20:58:43] <Zipheir> I also highly recommend Nada Amin's work on reflective towers of interpreters.
[20:59:30] <aportnoy> Zipheir: thank you, I'm working through SICP right now, and building a Scheme is one of my goals
[20:59:36] <Zipheir> Yes, excellent.
[21:00:15] <Zipheir> I recommend *that* rather than, say, object dumping, because the goal of most Scheme compilers is to provide performant programs, not interesting targets for reflection.
[21:00:55] <amazigh> Zipheir @_@ that paper is ~2 month old.. https://namin.seas.harvard.edu/publications/reflective-towers-interpreters
[21:01:36] <Zipheir> e.g. there is virtually no Scheme impl. that keeps the source code of a procedure around for introspection.  That's something you can remedy in your own compiler/interpreter.
[21:01:48] <Zipheir> amazigh: That must be her most recent one, then.
[21:01:58] <Zipheir> She's been working on that idea for like 5 years, at least.
[21:02:04] <aportnoy> Zipheir: not sure I'm familiar with the terminology, what do you mean by reflection here?
[21:02:57] <Zipheir> aportnoy: I mean a whole range of behaviors which have in common the fact that language is "talking about itself".
[21:03:04] <Zipheir> language/program
[21:03:26] <Zipheir> Without the use of an explicit higher-order language.
[21:04:09] <amazigh> here is a link to the (short) paper: https://blog.sigplan.org/2021/08/12/reflective-towers-of-interpreters/ it rely on black scheme
[21:04:29] <Zipheir> Amin has the idea of languages which provide first-class means of altering their own semantics, which is a very strange-loopy bit of reflection.
[21:05:11] <aportnoy> Zipheir: wow, that seems to imply that you can program yourself into a dead end with such a language
[21:05:17] <Zipheir> Allegedly, this is one idea that Dan Friedman refuses to talk about (or write a Little book about), since it "melted his brain".
[21:05:56] <sham1> Of course, the reason why CL has more reflection than most Schemes do is because reflection is baked into the CL specification, with disassembly, docstrings and the like
[21:06:05] <Zipheir> amazigh: ty
[21:06:20] <Zipheir> Also cf. "Programming Should Eat Itself", her Strange Loop lecture https://www.youtube.com/watch?v=SrKj4hYic5A
[21:07:00] <amazigh> I already whatched this, I will watch it again.
[21:07:10] <Zipheir> aportnoy: Sure.  It's a fascinating area for exploration, though.
[21:07:32] <amazigh>  => it is difficult.
[21:07:48] <Zipheir> Yes, good example; we were just talking about what "reflection" means. "Broadly construed, reflection is the ability to reason and act upon oneself. For a programming language, this entails being able to reason about and change the semantics from within a program."
[21:08:28] <amazigh> that is somewhat the result of my investigation in 
[21:08:29] <amazigh> https://hyper.dev/blog/2021/codex-dubito-ergo-cogito-ergo-sum/
[21:08:43] <amazigh> It is poor writing, and missing some references
[21:09:09] <amazigh> e.g. https://p-cos.blogspot.com/2008/09/reflection-for-masses.html
[21:09:41] <Zipheir> Interesting.
[21:09:50] <sham1> Strange Loop is such good content
[21:10:10] <aportnoy> Human language supports that, right?
[21:10:38] <sham1> Well you can talk about human language in human language. It's called linguistics. Therefore, yes
[21:11:03] <aportnoy> no, I mean changing semantics on the fly
[21:11:24] <aportnoy> not just describing the language in itself
[21:11:29] <aportnoy> A. <say x> B. I'm going to tell a lie now. <say x>
[21:11:32] <Zipheir> "Hmm, we need to redefine 'semantics' to continue this debate."
[21:11:48] <aportnoy> the first sentence in B. changes the semantics of what follows
[21:12:01] <amazigh> Sure.
[21:13:53] <amazigh> "We can go up by calling exit. Which basically going down the turtle level"
[21:14:00] <amazigh> ahah
[21:14:03] <sham1> Semantic shifts do happen in human language, both intentionality and unintentionally
[21:14:05] <amazigh> https://www.youtube.com/watch?v=SrKj4hYic5A
[21:14:12] <Zipheir> amazigh: Is that from GEB?
[21:14:22] <amazigh> Zipheir: it looks like it
[21:14:29] <amazigh> it is quote from the above video
[21:15:13] <Zipheir> It's Strange Loop, after all, which owes its name to GEB.
[21:15:48] *** Joins: sonny (~sonny@bras-base-london1483w-grc-27-70-51-121-200.dsl.bell.ca)
[21:15:58] <amazigh> GEB = Godel Esher Bach
[21:16:12] <Zipheir> Yup.
[21:18:25] <sonny> I am parsing integers; I thought I could use recursion to handle the loop to consume digits, except that I am unsure how to make the integer function return true. It only returns false. <https://bpa.st/U7OQ>
[21:18:49] <amazigh> re nada amin, so far that is doable with my fork of SINK.
[21:18:56] *** Quits: aportnoy (~aportnoy@user/aportnoy) (Ping timeout: 256 seconds)
[21:18:59] <sonny> Is it best to use a do-while loop here or is it possible with recursion?
[21:19:39] <Zipheir> They're equivalent.
[21:19:50] <Zipheir> The only do-while loop in Scheme is a recursion.
[21:20:30] <sonny> hmm
[21:20:51] <Franciman> Hi, does any scheme have a visual inspector? i.e. a program that allows me to inspect a program that is running? like a debugger but visual
[21:20:58] <amazigh> you mean to replace do-while with a named-let?
[21:21:01] <sonny> I suspect my true condition is on eof
[21:21:08] <amazigh> Franciman: drracket
[21:21:15] <Zipheir> sonny: Clearly you want another parsing procedure which handles integer + {integer}*.
[21:21:18] <sonny> but it is confusing, since I handle eof in digit
[21:21:27] <Franciman> amazigh: is it the only one? it.s a bit too heavy for my system :P
[21:22:04] *** Joins: oxum (~oxum@136.185.170.109)
[21:22:04] <sonny> Zipheir you mean integer {integer} ?
[21:22:22] <sham1> \d+
[21:22:28] <sonny> "{}" is zero or more
[21:22:32] <Zipheir> sonny: i.e. if you are trying to consume an integer and you immediately get EOF or a non-digit, then #f.  But once you've read a digit, you want to return #t on the first non-digit.
[21:22:46] <sonny> sham1: well then I'd never learn how to program state machines ;)
[21:22:55] <Zipheir> I meant zero or more.
[21:22:58] *** Quits: oxum (~oxum@136.185.170.109) (Client Quit)
[21:23:31] <sham1> You can still do the state machine, that just gives a compact description of what you're aiming at ;)
[21:23:49] <sonny> lol
[21:24:29] <Zipheir> It is worth writing out the transition diagram.
[21:24:33] <sham1> It's actually really helpful, since you can have it be in a comment and then see what you're doing
[21:24:48] <sonny> Zipheir: ty
[21:25:04] <sham1> Similar to having BNF in the comments
[21:26:33] <sham1> I actually used that when I implemented (read) in scheme. Makes it super easy to see what each production is supposed to do
[21:27:23] <Zipheir> One has to make sure that the BNF stays correct. :)  "Comments are not checked by the compiler." --Rob Pike
[21:27:40] <amazigh> sadly ;)
[21:28:13] * amazigh climb on the soapbox and says "make BNF executable"
[21:28:36] <sham1> Any errors can be blamed on the procedure of copying them from r7rs.pdf
[21:29:13] <sonny> Zipheir: the diagram <https://bpa.st/PDMQ>
[21:29:20] <sham1> Of course one could write a macro or so to generate the proper state machine from a BNF string, but where's the fun in that 
[21:29:31] <amazigh> sham1: ^^
[21:29:50] <Zipheir> sonny: Good.
[21:30:33] <Zipheir> sham1: Maybe there could be some kind of program which took BNF-like input to some kind of state machine that accepts the same language...?
[21:30:45] <Zipheir> I kid.
[21:31:15] <sham1> Sadly lex lacks unicode awareness
[21:31:31] <Zipheir> Boo.
[21:32:53] <sonny> ah got it, so I change when to and if and add the else body of #t
[21:32:59] <sonny> s/and/an/
[21:33:48] <sonny> https://bpa.st/7G4Q
[21:34:27] <sham1> That's actually one thing I need to work on at some point in the future, reading the unicode database fuff and make a semi-portable scheme thing where one could query things like character properties and such. It's just that the unicode files, as well as Unihan, terrify me
[21:34:44] <Zipheir> sonny: I'd say you're almost there.  There is a problem with calling `integer` after reading two digits.
[21:35:39] <Zipheir> sham1: I've found that AWK can be a great help with extracting data from the Unicode data files.
[21:35:46] *** Joins: wnklmnn (~wnklmnn@2a02:908:4e2:9740:e82a:7854:91ef:1ae0)
[21:36:12] <Zipheir> sonny: e.g. (integer) with input "12x" ==> #f
[21:36:27] <sham1> Well it probably could be done with five lines of perl, but  that feels like cheating
[21:36:58] *** Joins: skapata (~Skapata@2804:14c:87b0:a6f9:b1d7:e14b:5957:fa7f)
[21:36:58] *** Quits: skapata (~Skapata@2804:14c:87b0:a6f9:b1d7:e14b:5957:fa7f) (Changing host)
[21:36:58] *** Joins: skapata (~Skapata@user/skapata)
[21:42:00] <sonny> Zipheir: I didn't handle the empty transition right?
[21:42:49] <sonny> no, that's not it
[21:43:20] <Zipheir> It's that you still return false after consuming a valid integer.
[21:44:28] <Zipheir> It factors out as procedures `digit` and `maybe-more-digits`, basically.
[21:44:39] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[21:45:11] <Zipheir> And maybe-more-digits never fails.
[21:45:14] *** Joins: badkins (~badkins@136.56.92.199)
[21:45:33] <sonny> I could read another char before I call integer
[21:45:58] <sonny> but it's more what you are saying, let me see
[21:48:08] <Zipheir> What I called maybe-more-digits is the automaton described by DIGIT*.
[21:48:27] <Zipheir> [0-9]* in POSIX notation.
[21:49:45] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 268 seconds)
[21:49:48] <sham1> That's just regular expression notation. POSIX would probably be [:digit:]*
[21:49:52] <sonny> https://bpa.st/J2XA
[21:50:30] <amazigh> ty Zipheir for the reference to Programming Should Eat Itself. Great talk and great topic.
[21:50:42] <Zipheir> amazigh: I'm glad you liked it!
[21:51:34] <Zipheir> sonny: That's got a bigger problem, since it attempts to keep reading after EOF.
[21:51:34] <sham1> Another fun strange loop talk is "let's build a hygienic macro expander". First time I at least could understand just what the heck syntax objects are
[21:52:02] <Zipheir> sham1: Interesting, got a link?  One doesn't hear much about *implementing* hygienic macro systems.
[21:52:11] <sham1> Hold on
[21:53:21] <sham1> https://youtu.be/Or_yKiI3Ha4
[21:53:22] <Zipheir> sonny: I suggest trying to write another parser which accepts the empty string or any number of digits.
[21:53:46] <amazigh> mflatt!
[21:53:51] <Zipheir> Oh, cool.
[21:53:54] <Zipheir> sham1: ty
[21:54:06] <sonny> ok, good idea
[21:54:45] <sham1> I stumbled across it when I was trying to find resources on just how one might implement macros
[21:55:43] *** Quits: Everything (~Everythin@37.115.210.35) (Quit: leaving)
[21:56:11] <sham1> Since it's like, traditional lisp macros are relatively simple machines, but hygienic macros make it something where one has to start reading things like research papers to know what is going on. So it's nice to have a more intuitive explanation
[21:56:41] <Zipheir> Indeed.
[21:58:58] <sham1> And it seems to me that one could then just turn the identifier syntax objects into basically gensym'd symbols automagickally
[21:59:28] <sham1> So the name would depend on the scope
[22:00:26] <Zipheir> I'm not sure there's ever been an attempt to formally verify the "hygiene condition" that such systems are supposed to provide, either.
[22:00:56] <Zipheir> Which is very slightly concerning to me, given e.g. Oleg's attempts to poke holes in it.
[22:18:34] *** Joins: badkins (~badkins@136.56.92.199)
[22:19:02] *** Quits: sonny (~sonny@bras-base-london1483w-grc-27-70-51-121-200.dsl.bell.ca) (Ping timeout: 256 seconds)
[22:29:28] *** Quits: clacke (88d96f2df3@knopi.disroot.org) (Read error: Connection reset by peer)
[22:37:11] *** Quits: Inline (~Inline@2a02:908:1252:7a80:b442:91f8:4666:206e) (Ping timeout: 245 seconds)
[22:38:31] <dpk> hygienic macros are really very simple, but they're sort of so simple that it can seem like the compiler is doing more magic for you than it actually is
[22:38:57] <dpk> i think that's maybe 20% of why Common Lispers still turn their noses up at hygienic macros
[22:39:58] <dpk> (the other 80% is that 'hygiene' for too long meant 'syntax-rules', which really is an underpowered system in which doing all but the most basic macros is made unnecessarily complex)
[22:41:13] *** Quits: mononote (~mononote@user/mononote) (Ping timeout: 265 seconds)
[22:44:46] *** Quits: skapata (~Skapata@user/skapata) (Remote host closed the connection)
[22:45:04] *** Joins: skapata (~Skapata@2804:14c:87b0:a6f9:b1d7:e14b:5957:fa7f)
[22:45:04] *** Quits: skapata (~Skapata@2804:14c:87b0:a6f9:b1d7:e14b:5957:fa7f) (Changing host)
[22:45:05] *** Joins: skapata (~Skapata@user/skapata)
[22:46:19] <sham1> Speaking of syntax-rules, would there happen to be any kind of a test suite for them. Like some kind of a library of syntax-rules and s-expressions they'd expand into
[22:48:09] <Oxyd> That would be quite difficult because what they expand to is going to be very implementation-specific.
[22:50:11] <sham1> hm
[22:52:04] <Zipheir> A more extensional test approach would be better.
[22:56:00] <sham1> WDYM
[22:58:21] <Zipheir> Compare the value of expressions, not the expressions themselves.
[22:58:30] <sham1> Hmm
[23:00:50] <Oxyd> Usual unit tests, in other words.
[23:02:17] <amazigh> sham1: did you look at https://unsyntax.org's code?
[23:02:31] <sham1> I did
[23:03:11] <amazigh> you can't *automagically* turn syntax into a gensym that depends on scope
[23:03:22] <amazigh> I am not expert tho
[23:03:48] <amazigh> maybe there is simpler algorithm..
[23:04:36] *** Quits: gproto23 (~gproto23@user/gproto23) (Remote host closed the connection)
[23:27:03] *** Joins: sdu (~doo@185.44.146.165)
[23:39:43] *** Joins: sonny (~sonny@bras-base-london1483w-grc-27-70-51-121-200.dsl.bell.ca)
[23:40:15] <dpk> jcowan: how do you intend to count the votes on the yellow docket? anything with more explicit yeses than explicit noes gets in? or are we using Bundesrat rules, where an abstention is an effective vote against?
[23:40:46] <dpk> (my preference would be the latter, but this is influenced mainly by the current results of the first two questions)
[23:40:51] <jcowan> Abstentions are completely ignored
[23:41:27] <jcowan> A majority of the legal votes cast is required to pass
[23:41:45] <dpk> (not only that i prefer syntax-case, but that i share M N-W's serious concerns about the effect of including both systems)
[23:42:17] <jcowan> We'll see.  I hope to get about 30 votes altogether
[23:45:56] <jcowan> If both pass we'll vote on native/naive ER vs. MN-W style compatible ER.
[23:54:04] *** Joins: Oshawott (~archenoth@2604:3d09:681:f00:987d:f829:9742:5ed4)
[23:57:11] *** Quits: archenoth (~archenoth@2604:3d09:681:f00:383d:caef:6750:9914) (Ping timeout: 245 seconds)
