[00:17:01] *** Joins: matty_matt (~matt@135.129.244.71)
[00:17:50] *** Quits: cmiles74 (~miles@068-184-030-013.res.spectrum.com) (Ping timeout: 265 seconds)
[00:29:51] *** Quits: shiranaihito_ (~textual@123-192-192-149.dynamic.kbronet.com.tw) (Quit: My MacBook Air has gone to sleep. ZZZzzz…)
[00:37:33] *** Quits: matty_matt (~matt@135.129.244.71) (Ping timeout: 268 seconds)
[00:48:03] *** Joins: AlaskanEmily (~AlaskanEm@user/alaskanemily)
[00:49:47] *** Joins: peterhil (~peterhil@dsl-hkibng32-54fb56-2.dhcp.inet.fi)
[00:50:29] *** Quits: peterhil_ (~peterhil@dsl-hkibng32-54fb56-2.dhcp.inet.fi) (Remote host closed the connection)
[00:51:18] *** Joins: peterhil_ (~peterhil@dsl-hkibng32-54fb56-2.dhcp.inet.fi)
[00:55:27] *** Quits: peterhil (~peterhil@dsl-hkibng32-54fb56-2.dhcp.inet.fi) (Read error: Connection reset by peer)
[00:56:18] <shem> zach's and maciej's putdowns are delicious and to the point. it seems that money doesn't heed eloquence and good argument though
[01:07:06] *** Quits: wnh (~user@user/wnh) (Quit: ERC (IRC client for Emacs 27.2))
[01:15:38] *** Joins: wnh (~user@user/wnh)
[01:20:26] *** Quits: tatsumaru (~tatsumaru@78.83.244.47) (Quit: Leaving.)
[01:30:51] *** Joins: cmiles74 (~miles@068-184-030-013.res.spectrum.com)
[01:42:11] *** Joins: azimut_ (~azimut@gateway/tor-sasl/azimut)
[01:43:21] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Ping timeout: 276 seconds)
[01:46:09] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[01:48:27] *** Quits: schmudde (~schmudde@192.80.110.15) (Ping timeout: 268 seconds)
[02:03:45] *** Quits: dadinn (~dadinn@host81-155-234-224.range81-155.btcentralplus.com) (Ping timeout: 252 seconds)
[02:07:18] <sobel> i understand HN is written in Arc
[02:09:17] <technomancy> yes, which is actually directly related to why pagination links break if you leave them too long.
[02:09:42] <goodger> I
[02:09:54] <goodger> I'm sure HN could have been written competently in arc
[02:10:15] <goodger> it could also have been mangled in a very similar way in many other programming languages
[02:10:58] <technomancy> it's more like the desire to demo "cool" arc features led them to use continuations for something that you shouldn't use continuations for
[02:11:21] <goodger> my friend says ‘COBOL will almost certainly still exist in thirty years, so [arc as a centenary language] isn't that implausible’
[02:11:30] <goodger> I said simply ‘COBOL was once successful’
[02:13:32] <sobel> that is quite fair
[02:14:48] <sobel> seconded: What did we do to deserve Zach Tellman
[02:25:22] *** Joins: schmudde (~schmudde@216.169.6.249)
[02:28:48] *** Quits: seschwar (~seschwar@user/seschwar) (Quit: :wq)
[03:01:02] *** Joins: libertyprime (~libertypr@125-239-52-43-fibre.sparkbb.co.nz)
[03:10:29] *** Quits: pflanze (~pflanze@5-168-208-80-pool.fiber.fcom.ch) (Ping timeout: 252 seconds)
[03:11:42] *** Quits: cmiles74 (~miles@068-184-030-013.res.spectrum.com) (Ping timeout: 268 seconds)
[03:16:08] *** Joins: pflanze (~pflanze@5-168-208-80-pool.fiber.fcom.ch)
[03:20:09] *** Joins: pflanze_ (~pflanze@5-168-208-80-pool.fiber.fcom.ch)
[03:22:48] *** Quits: pflanze (~pflanze@5-168-208-80-pool.fiber.fcom.ch) (Ping timeout: 268 seconds)
[03:22:51] *** pflanze_ is now known as pflanze
[03:48:15] *** Quits: cranium (~cranium@user/cranium) (Ping timeout: 250 seconds)
[03:49:29] <perro> the hundred year language stuff, jfc
[03:49:42] <perro> what cracks me up the msot about arc is it's not even properly maintained like a regular language
[03:50:06] <perro> paul talked it up so much
[03:51:28] <technomancy> maybe his third language will be good
[03:56:12] *** Quits: libertyprime (~libertypr@125-239-52-43-fibre.sparkbb.co.nz) (Ping timeout: 256 seconds)
[04:12:09] *** Joins: libertyprime (~libertypr@222-154-245-111.adsl.xtra.co.nz)
[04:13:04] *** Joins: meinside (uid24933@id-24933.helmsley.irccloud.com)
[04:16:18] *** Joins: matty_matt (~matt@135.129.244.71)
[04:58:53] *** Quits: op2 (~op2@user/op2) (Ping timeout: 250 seconds)
[05:03:47] *** Quits: dim (~dimlibera@2a02:2178:2:4:1658:d0ff:fe49:408c) (Quit: ZNC 1.7.2+deb3 - https://znc.in)
[05:04:30] *** Joins: dim (~dimlibera@212.85.154.83)
[05:10:34] *** Quits: libertyprime (~libertypr@222-154-245-111.adsl.xtra.co.nz) (Quit: leaving)
[05:21:04] *** Quits: xulfer (uid452788@id-452788.ilkley.irccloud.com) (Quit: Connection closed for inactivity)
[05:22:29] *** Quits: matty_matt (~matt@135.129.244.71) (Ping timeout: 252 seconds)
[06:49:02] *** Quits: pflanze (~pflanze@5-168-208-80-pool.fiber.fcom.ch) (Ping timeout: 256 seconds)
[06:51:53] *** Joins: pflanze (~pflanze@2001:1a88:19e:4500:b247:dfc0:cca:1a0e)
[06:58:24] *** Joins: mbuf (~Shakthi@122.178.176.47)
[07:59:25] *** Joins: matty_matt (~matt@135.129.244.71)
[08:15:44] *** Quits: schmudde (~schmudde@216.169.6.249) (Ping timeout: 256 seconds)
[09:12:14] *** Joins: shiranaihito (~textual@123-192-192-149.dynamic.kbronet.com.tw)
[09:34:06] *** Quits: matty_matt (~matt@135.129.244.71) (Ping timeout: 260 seconds)
[10:38:04] *** Joins: struchu (~struchu@staticline-31-183-182-252.toya.net.pl)
[11:22:51] *** Joins: cranium (~cranium@user/cranium)
[12:05:13] *** Quits: AlaskanEmily (~AlaskanEm@user/alaskanemily) (Remote host closed the connection)
[12:11:51] *** Joins: op2 (~op2@user/op2)
[12:17:45] *** Joins: gooodger (~goodger@static.218.44.203.116.clients.your-server.de)
[12:17:54] *** Quits: goodger (~goodger@2a01:4f8:c2c:33db::1) (Read error: Connection reset by peer)
[12:17:55] *** gooodger is now known as goodger
[12:49:06] *** Joins: kipz (~kipz@home.kipz.org)
[13:08:35] *** Quits: greyrat_ (~greyrat@ip202.ip-51-178-215.eu) (Bye)
[13:08:55] *** Joins: greyrat (~greyrat@ip202.ip-51-178-215.eu)
[13:09:05] *** Joins: snits_ (~quassel@ip98-179-76-75.ph.ph.cox.net)
[13:09:56] *** Joins: yason_ (yason@kapsi.fi)
[13:10:19] *** Joins: sobel_ (~matt@66.219.34.76)
[13:10:20] *** Joins: Techcable_ (~Techcable@168.235.93.147)
[13:10:23] *** Server sets mode: +nt 
[13:10:59] *** Joins: lockdown_ (~lockdown@ec2-3-236-147-4.compute-1.amazonaws.com)
[13:11:07] *** Joins: jjhoo_ (~jahakala@user/jjhoo)
[13:11:10] *** Joins: spirit- (~spirit@233.ip-144-217-92.net)
[13:11:40] *** Joins: OMGOMG_ (~bobrobert@poppy.ifi.uio.no)
[13:16:44] *** Quits: peterhil_ (~peterhil@dsl-hkibng32-54fb56-2.dhcp.inet.fi) (*.net *.split)
[13:16:44] *** Quits: paddymahoney (~paddymaho@cpe9050ca207f83-cm9050ca207f80.cpe.net.cable.rogers.com) (*.net *.split)
[13:16:44] *** Quits: nighcoder (~ciumbi@206.176.143.59) (*.net *.split)
[13:16:44] *** Quits: Techcable (~Techcable@168.235.93.147) (*.net *.split)
[13:16:44] *** Quits: darkstardevx (~darkstard@50.39.115.145) (*.net *.split)
[13:16:44] *** Quits: turbofail (~user@157-131-95-100.fiber.dynamic.sonic.net) (*.net *.split)
[13:16:45] *** Quits: markmarkmark (~mark@user/markmarkmark) (*.net *.split)
[13:16:45] *** Quits: wht (~wht@havoc.proulx.com) (*.net *.split)
[13:16:45] *** Quits: yason (yason@kapsi.fi) (*.net *.split)
[13:16:45] *** Quits: lockdown (~lockdown@ec2-3-236-147-4.compute-1.amazonaws.com) (*.net *.split)
[13:16:45] *** Quits: greyrat_ (~greyrat@ip202.ip-51-178-215.eu) (*.net *.split)
[13:16:45] *** Quits: rufo (~rufo@ct.rufoa.com) (*.net *.split)
[13:16:45] *** Quits: jjhoo (~jahakala@user/jjhoo) (*.net *.split)
[13:16:45] *** Quits: OMGOMG (~bobrobert@poppy.ifi.uio.no) (*.net *.split)
[13:16:45] *** Quits: spirit (~spirit@233.ip-144-217-92.net) (*.net *.split)
[13:16:46] *** Quits: sobel (~matt@66.219.34.76) (*.net *.split)
[13:16:46] *** Quits: snits (~quassel@ip98-179-76-75.ph.ph.cox.net) (*.net *.split)
[13:21:51] *** Joins: markmarkmark (~mark@user/markmarkmark)
[13:21:51] *** Joins: wht (~wht@havoc.proulx.com)
[13:22:30] *** Quits: Colt (~Colt@user/colt) (Remote host closed the connection)
[13:22:57] *** Joins: Colt (~Colt@user/colt)
[13:24:30] *** Joins: paddymahoney (~paddymaho@cpe9050ca207f83-cm9050ca207f80.cpe.net.cable.rogers.com)
[13:24:42] *** Quits: drbobbeaty (~drbob@c-24-14-127-107.hsd1.il.comcast.net) (Quit: Textual IRC Client: www.textualapp.com)
[13:30:29] *** Joins: matty_matt (~matt@135.129.244.71)
[13:34:54] *** Quits: matty_matt (~matt@135.129.244.71) (Ping timeout: 260 seconds)
[13:53:08] *** Joins: drbobbeaty (~drbob@c-24-14-127-107.hsd1.il.comcast.net)
[13:58:01] *** jjhoo_ is now known as jjhoo
[14:13:24] *** yason_ is now known as yason
[14:15:55] <yeik-the-spik[m]> you mean clojure?
[14:17:10] *** Joins: tatsumaru (~tatsumaru@78.83.244.47)
[14:17:40] <tatsumaru> hey guys, what does it mean that there is no order of precedence of math operators in clojure?
[14:18:39] <tatsumaru> oh never mind, that's a stupid question 
[14:26:01] *** sobel_ is now known as sobel
[15:15:00] <teddyc> tatsumaru: no questions are stupid!
[15:19:50] <tatsumaru> teddyc: i think the ones you can answer by yourself if you simply stop and think about what you are asking are somewhat stupid
[15:20:17] <yeik-the-spik[m]> "it's better to ask the question and look stupid for 5 minutes, than not to ask the question and remain ignorant all your life." some old eastern wise-person
[15:22:39] <tatsumaru> yeik-the-spik[m]: isn't 'spik' a derogatory racial slur?
[15:22:52] <yeik-the-spik[m]> Asking the question and stopping and thinking are similar. I am just lucky I do not type that fast, so I don't spam this channel as often as I am willing to.
[15:25:06] <yeik-the-spik[m]> tatsumaru: no idea. I like that it ends in K, just like yeik, which my friends call me.
[15:25:28] <yeik-the-spik[m]> i think that is offtopic anyways
[15:28:37] <yeik-the-spik[m]> And I am a native spanish speaker. not that anyone should care about that anyways, because that one is really offtopic.
[15:29:43] <tatsumaru> no worries, i was just curious
[15:31:42] <yeik-the-spik[m]> not worried whatsoever <3
[15:39:36] *** Quits: cranium (~cranium@user/cranium) (Quit: Leaving)
[15:43:40] <Para> Verbalisation of the problem is a very effective way to get into the core of it.
[15:43:59] <Para> The verbalisation may or rather will sound stupid at some level, but that's great! Stupid problems are usually easy to solve :)
[15:45:25] *** Quits: struchu (~struchu@staticline-31-183-182-252.toya.net.pl) (Ping timeout: 250 seconds)
[15:56:40] *** Joins: dadinn (~dadinn@host81-155-234-224.range81-155.btcentralplus.com)
[15:58:14] <yeik-the-spik[m]> In my previous company I convinced management to include a rubber duck in the welcome pack for new hires. You got branded cup, pen, notebook and a rubber duck (unbranded unfortunately).
[16:00:26] <sobel> <3
[16:01:33] <sobel> last time i got called to duty as a rubber duck, all i did was rename variables until my client could see the error just verbalizing the code
[16:03:43] *** Joins: struchu (~struchu@staticline-31-183-182-252.toya.net.pl)
[16:14:19] <tatsumaru> what is the symbolism of a rubber duck
[16:15:07] <Para> https://en.wikipedia.org/wiki/Rubber_duck_debugging
[16:17:34] <tatsumaru> So me discussing business problems with an imaginary clone isn't necessarily a sign of losing it then?
[16:17:51] <Para> Nah.
[16:18:00] <Para> Of course blaming the clone might not be fruitful.
[16:21:59] *** Quits: struchu (~struchu@staticline-31-183-182-252.toya.net.pl) (Quit: WeeChat 3.3)
[16:23:27] <tatsumaru> I've actually noticed that if I write down the problem on a piece of paper or a write document solutions start coming much faster. It's like the RAM that was taken by the question asking becomes available for solution providing after I offload the question to another medium.
[16:27:27] *** Quits: dadinn (~dadinn@host81-155-234-224.range81-155.btcentralplus.com) (Ping timeout: 250 seconds)
[16:27:48] *** Joins: matty_matt (~matt@135.129.244.71)
[16:28:11] *** Joins: dadinn (~dadinn@host81-155-234-224.range81-155.btcentralplus.com)
[16:32:23] *** Quits: matty_matt (~matt@135.129.244.71) (Ping timeout: 252 seconds)
[16:38:49] <sobel> tatsumaru: i'm fairly certain the process of talking it out with a rubber duck is comparable to writing/journaling, which is well known to be an effective way to improve comprehension
[16:39:16] <sobel> but even short of that mechanism, just formulating your problem for words can help
[16:40:27] <sobel> like my guy with the bad variable names, he had lost the ability to verbalize his code because the variables names were so useless
[16:43:40] <tatsumaru> in that case what determines which problems we can solve by ourselves and which problems we genuinely need help with
[16:43:41] *** Quits: chujev (~chujev@198.20.115.180) (Ping timeout: 245 seconds)
[16:45:01] *** Joins: struchu (~struchu@staticline-31-183-182-252.toya.net.pl)
[16:45:16] *** Joins: chujev (~chujev@198.20.115.180)
[16:45:36] <tatsumaru> on a side note, isn't it a bad design decision to reserve 'map' for something other than creating maps?
[16:46:10] <opqdonut> it's a bit unfortunate map means two things
[16:46:31] <opqdonut> I'd argue the bad decision was to call clojure maps maps, since `map` was already reserved by the functional idiom
[16:46:43] <opqdonut> but in practice this hasn't been a problem for me in clojure
[16:46:55] <tatsumaru> opqdonut: how would you call maps in clojure?
[16:47:02] *** Quits: struchu (~struchu@staticline-31-183-182-252.toya.net.pl) (Client Quit)
[16:47:27] <opqdonut> dicts? associations? hashmaps?
[16:47:48] <tatsumaru> are clojure maps the same like dictionaries in other langs?
[16:48:05] <opqdonut> pretty much yes (except they're persistent/immutable)
[16:48:47] <tatsumaru> maybe we should raise a clojure improvement proposal by Mr. Hickey
[16:49:04] <opqdonut> nah, it won't be changed
[16:49:09] <opqdonut> and it doesn't matter that much
[16:52:57] <yeik-the-spik[m]> <tatsumaru> "in that case what determines..." <- I usually type my problem where I am typing right now. Leave it there 15 minutes. If the fates decide not to illuminate me.
[16:52:57] <yeik-the-spik[m]> Previous to that I  write a small code example I can share, I have talked to my rubber duck a bit or written down on my notepad a couple of options / thoughts on potential solutions.
[16:53:55] <tatsumaru> I have a little Buddha figurine on my desk, I am going to try to ask it next time.
[16:54:43] *** Joins: struchu (~struchu@staticline-31-183-182-252.toya.net.pl)
[16:55:01] <tatsumaru> (3 hours later some guy not getting the point comparing the answers from different action figures and items and such)
[16:56:11] *** Quits: son0p (~ff@2800:484:1d81:b700::4) (Ping timeout: 268 seconds)
[17:06:38] *** Joins: matty_matt (~matt@135.129.244.71)
[17:07:34] <sobel> i would not be surprised if clojure calls them maps because java does
[17:08:24] <sobel> but map not being a factory method for maps doesn't bother me at all. i don't expect clojure functions to work like that most of the time.
[17:10:47] <opqdonut> yeah the java connection is a good explanation
[17:11:23] <opqdonut> looks like e.g. kotlin also has map (the function) and Map (the data structure)
[17:12:25] <Solid> I think every functional language calls maps maps
[17:15:10] *** Quits: matty_matt (~matt@135.129.244.71) (Ping timeout: 260 seconds)
[17:18:48] *** Joins: cmiles74 (~miles@068-184-030-013.res.spectrum.com)
[17:19:58] <tatsumaru> are macros just syntactic sugar?
[17:27:34] *** Joins: matty_matt (~matt@135.129.244.71)
[17:27:43] <aphyr> tatsumaru: I think that's a reasonable interpretation
[17:27:52] *** Quits: neirac (~neirac@pc-122-191-45-190.cm.vtr.net) (Read error: No route to host)
[17:54:53] *** Quits: dadinn (~dadinn@host81-155-234-224.range81-155.btcentralplus.com) (Ping timeout: 252 seconds)
[17:54:54] *** Joins: schmudde (~schmudde@216.169.6.249)
[17:59:38] <wink> I think there can be real repercussions though. iirc in common lisp? the macros are only done at compile time, so you can't rejigger them at runtime
[17:59:50] <wink> so while still being syntactic sugar, it's different.
[17:59:58] *** Quits: matty_matt (~matt@135.129.244.71) (Ping timeout: 260 seconds)
[18:00:04] <wink> (I know, I know, not clojure)
[18:00:34] *** Joins: harry_otter (~harry_ott@2601:483:4101:2350::d66d)
[18:01:39] <ToxicFrog> Same in clojure -- macros are executed at compile time, and while they look like functions you often cannot treat them like one (in particular, you cannot take the value of a macro)
[18:01:54] <Para> I wouldn't call macros syntactic sugar as that implies it'd be a sweet idea to solve your issues with them :)
[18:02:14] <ToxicFrog> I think thinking of them as user-defined syntactic sugar is not necessarily wrong, in that anything you can do with macros you can also do without them, although it may end up being a lot more verbose
[18:02:16] <Para> Two rules of macros are 1) don't 2) if you can solve your problem with a function, use a function
[18:02:52] <tatsumaru> ToxicFrog: can't you take the value of a macro through macroexpand?
[18:03:22] <Para> Macros emit code, not values.
[18:03:56] <Para> macroexpand allows you to see what the resulting code-to-be-emitted is
[18:04:29] <ToxicFrog> ^
[18:04:34] <Para> If you want to learn more, do check out https://learnxinyminutes.com/docs/clojure-macros/
[18:04:43] <Para> Surprisingly good how-to article about macros in general.
[18:04:46] <Solid> I don't know a lot about lisp communities, but my impression so far is that the Clojure community in particular is very "anti macro" (much more than others, that is); why is that?
[18:05:10] <Para> Solid: Because people tend to abuse metaprogramming in every language, thinking their clever solutions are better than practical solutions.
[18:05:10] <ToxicFrog> Macroexpand tells you what code a macro evaluates to. It doesn't let you, e.g., pass the macro to map the way you can pass a function to it.
[18:05:35] <tatsumaru> Para: is this similar to Python's "simple is better than complex, complex is better than complicated"?
[18:05:55] <Para> Solid: Macros aren't bad but they are the lightsabers/shotguns of this particular arsenal, and all people tend to be full body feet :)
[18:05:58] *** Joins: matty_matt (~matt@135.129.244.71)
[18:06:27] <Para> There's practical reasons as well, debugging macros can be a PITA, they don't necessarily compose, they don't work with eg. `apply`...
[18:06:49] <Para> tatsumaru:yep, something like that
[18:06:55] <ToxicFrog> Solid: if I'm in a cynical mode, I'll say that it's because Clojure's error reporting is already shockingly bad, especially at compile time, and macros (a) make it worse and (b) push more errors to compile-time rather than run-time
[18:06:57] <ToxicFrog> More realistically, though, I suspect it's just because macros are a very powerful tool and like any very powerful too (a) they're overkill for a lot of circumstances in which you could use them and (b) they're often hard to debug in proportion to their power
[18:06:59] <ToxicFrog> So there are a lot of situations where it's like, yes, you could use a macro, but is it really worth creating that headache for future you when you can do it without macros at the cost of like 1 extra line of code?
[18:08:06] <Solid> Para, ToxicFrog: mh makes sense I suppose; thanks!
[18:08:52] *** Joins: shiranaihito_ (~textual@2001-b011-4000-389e-1d6a-61b8-750e-d21d.dynamic-ip6.hinet.net)
[18:08:57] <ToxicFrog> (in the limit, overuse of macros results in each program being written in a DSL specific to that program, which I actually find kind of conceptually appealing but also which I 100% do not want to be responsible for debugging when the wheels fall off)
[18:10:56] <Solid> well, presumably debugging a DSL would even be nicer because you can sort of guess where the problem might lie if you know the problem domain well
[18:11:32] <Solid> (I guess it'd also be an EDSL, but what's the difference, reall ;)
[18:12:03] *** Quits: shiranaihito (~textual@123-192-192-149.dynamic.kbronet.com.tw) (Ping timeout: 268 seconds)
[18:12:05] <ToxicFrog> Yeah but like
[18:12:07] <ToxicFrog> even if I'm the only person maintaining this code, the me six months from now is not going to remember most of this unless she's been working on it continuously for those six months, which basically never happens
[18:12:08] <Para> Good example of wheels falling off is clojure.test's very own core macros :)
[18:12:52] <ToxicFrog> This conversation made me curious and I did a grep over my ~/devel directory.
[18:12:54] <ToxicFrog> defn: 932. defmacro: 22.
[18:13:17] <Solid> You're probably right (not like I have any expertise in this anyways; I'm neither a professional programmer nor have I used clojure for more than a month :)
[18:13:42] <Para> `(testing "this is broken in two ways" (is (keyword? "no")))`
[18:14:53] <Para> 1) no deftest 2) won't necessarily error on missing third argument because `is` is not a function but a custom symbol and the `testing` macro unrolls the expect triplet of predicate + expected + actual into something that may pass even when arguments are missing... :D
[18:15:08] <Para> In that particular case it actually might error, but point is that it varies.
[18:17:47] <tatsumaru> what's the difference between 'macroexpand' and 'macroexpand-1'
[18:20:08] <Para> Resolve fully or step by step; macros might be recursive, or call other macros :)
[18:45:27] *** Joins: mwnaylor (~user@2601:5ce:4300:5560::68b3)
[18:59:25] *** Quits: matty_matt (~matt@135.129.244.71) (Ping timeout: 252 seconds)
[19:00:36] *** Joins: matty_matt (~matt@135.129.244.71)
[19:02:35] <tatsumaru> Para: does -1 mean 1 step depth?
[19:03:34] <mwnaylor> CIDER gives me a stack trace on a NullPointerException. Is there a way to see the values that are in scope at the time of the exception?
[19:04:15] <ToxicFrog> tatsumaru: yes; you might read it as "macroexpand once", i.e. it does one round of macro expansion on whatever you passed it and then stops
[19:04:16] <ToxicFrog> so if there are more macros in whatever it expanded to it leaves them in place, while plain `macroexpand` will keep going until you get to the actual emitted code
[19:09:09] <tatsumaru> ToxicFrog: thanks
[19:13:25] *** Joins: son0p (~ff@2800:484:1d81:b700:d40b:900:b387:320)
[19:17:40] *** Joins: shiranaihito (~textual@123-192-192-149.dynamic.kbronet.com.tw)
[19:20:02] *** Quits: shiranaihito_ (~textual@2001-b011-4000-389e-1d6a-61b8-750e-d21d.dynamic-ip6.hinet.net) (Ping timeout: 240 seconds)
[19:21:47] *** Quits: matty_matt (~matt@135.129.244.71) (Ping timeout: 252 seconds)
[19:23:33] *** Joins: matty_matt (~matt@135.129.244.71)
[19:27:57] *** Quits: matty_matt (~matt@135.129.244.71) (Ping timeout: 250 seconds)
[19:31:15] *** Quits: struchu (~struchu@staticline-31-183-182-252.toya.net.pl) (Quit: WeeChat 3.3)
[19:32:26] <tatsumaru> hey guys why does '(= [:a :b :c] (list :a :b :c))' return true? aren't vectors and lists different?
[19:35:17] <ToxicFrog> tatsumaru: https://clojuredocs.org/clojure.core/%3D
[19:36:15] <tatsumaru> ToxicFrog: is this the answer: " and compares numbers and collections in a type-independent manner"
[19:37:06] <ToxicFrog> Yes. [:a :b :c] and (list :a :b :c) are = because they are both ordered collections containing the same elements in the same order.
[19:37:49] <tatsumaru> i see, thanks
[19:41:46] <ToxicFrog> (clojure doesn't have the distinction between eq? and eqv? that some other languages do)
[19:42:26] <mwnaylor> This comparison behaviour is a feature. Anyone reading the documentation will see that many of the core Clojure function return sequences. This allows us to do things like (= [0 1 4 9] (map #(* % %) (range 4))) without having to force the results of the map function into a vector.
[19:45:11] *** Joins: neirac (~neirac@pc-122-191-45-190.cm.vtr.net)
[19:47:46] <mwnaylor> Has anyone gotten conditional breakpoints to work in CIDER? I have put the metadata into my code that I have found in online examples, but CIDER executes to the end without stopping. Version: CIDER 1.0.0snapshot (package: 20201216.1330)
[19:48:21] <mwnaylor> Do I need to upgrade to the latest version?
[19:51:49] *** Joins: dadinn (~dadinn@cpc87065-finc18-2-0-cust67.4-2.cable.virginm.net)
[19:52:23] <yeik-the-spik[m]> you mean #break?
[19:52:59] <yeik-the-spik[m]> are you calling the function directly or are you calling a function that down the line calls the function that is getting debugged?
[19:53:24] <yeik-the-spik[m]> Does the regular debugger work as expected?
[19:53:28] *** Quits: tatsumaru (~tatsumaru@78.83.244.47) (Quit: Leaving.)
[19:53:38] <mwnaylor> ^{:break/when (> i 1000)}
[19:53:57] <yeik-the-spik[m]> oh, never used that one
[19:54:05] <mwnaylor> This was a direct function call.
[19:54:47] <mwnaylor> Debugger activated when I used C-u C-M-x on the function.
[19:56:27] <mwnaylor> #break did not work either. Function ran to completion without stopping in the debugger.
[19:57:21] <yeik-the-spik[m]> ok. #break usually works for me, but sometimes does not
[19:57:50] <yeik-the-spik[m]> but that is as much as i can share
[19:58:28] <mwnaylor> What version of CIDER do you have installed?
[19:58:31] <yeik-the-spik[m]> if you happen to have a minimal example, I am happy to run it in my set up, see what happens
[19:58:52] <yeik-the-spik[m]> CIDER 1.2.0snapshot (package: 20210508.948)
[19:58:57] <yeik-the-spik[m]> that one is my version
[19:59:31] <yeik-the-spik[m]> yeik-the-spik[m]: but i will be leaving in about an hour
[20:00:16] <mwnaylor> See (defn buggy-function [] …) at this link: http://endlessparentheses.com/conditional-breakpoints-in-the-cider-debugger.html
[20:06:58] <yeik-the-spik[m]> yeah, that code does not work for me
[20:07:15] <yeik-the-spik[m]> but if I place the #dbg acording to the cider docs, it does
[20:07:26] <yeik-the-spik[m]> https://docs.cider.mx/cider/debugging/debugger.html#conditional-breakpoints
[20:07:56] <yeik-the-spik[m]> (defn buggy-function []
[20:07:56] <yeik-the-spik[m]>     (for [i (range 3000)]
[20:07:56] <yeik-the-spik[m]>         **#dbg** ^{:break/when (> i 1000)}
[20:07:56] <yeik-the-spik[m]>       (* i i)))
[20:08:07] <yeik-the-spik[m]>  * ```... (full message at https://libera.ems.host/_matrix/media/r0/download/libera.chat/bf83a87d48dd7365fff8ab95400da0d0c0a4465d)
[20:10:01] *** Joins: matty_matt (~matt@135.129.244.71)
[20:11:14] <technomancy> if seqs and vectors couldn't be = to each other then laziness would be very annoying
[20:12:37] <yeik-the-spik[m]> <yeik-the-spik[m]> "yeah, that code does not work..." <- well, it kinda works, but rather unexpectedly. it runs the whole function through the debugger, and then the loop only under the condition
[20:16:10] *** Quits: harry_otter (~harry_ott@2601:483:4101:2350::d66d) (Quit: Client closed)
[20:20:54] <mwnaylor> yeik-the-spik[m]: Thanks for documentation link. Now it works when I put in the 𝘤𝘰𝘳𝘳𝘦𝘤𝘵 metadata and instument w/ cider-debug-defun-at-point.
[20:22:13] *** Quits: matty_matt (~matt@135.129.244.71) (Ping timeout: 256 seconds)
[20:26:40] <mwnaylor> Is there a version of the cider documentation that can be downloaded? I don't always have internet access with my laptop and want to have a local copy.
[20:28:07] <yeik-the-spik[m]> i dont know. download the html maybe? 
[20:28:32] <yeik-the-spik[m]> <mwnaylor> "yeik-the-spik: Thanks for..." <- most welcome! happy debugging!
[20:31:24] *** Joins: peterhil_ (~peterhil@dsl-hkibng32-54fb56-2.dhcp.inet.fi)
[20:31:35] *** Quits: peterhil__ (~peterhil@dsl-hkibng32-54fb56-2.dhcp.inet.fi) (Remote host closed the connection)
[20:32:34] *** Quits: peterhil_ (~peterhil@dsl-hkibng32-54fb56-2.dhcp.inet.fi) (Remote host closed the connection)
[20:32:47] *** Joins: peterhil_ (~peterhil@dsl-hkibng32-54fb56-2.dhcp.inet.fi)
[20:38:07] <mwnaylor> Silly me, I just discovered cider-debug-defun-at-point for subforms within the larger defn form. My debugging has just taken a huge leap forward. Now if I can find a simple way to have the debugger triggered on an exception…
[20:43:16] *** Joins: seschwar (~seschwar@user/seschwar)
[21:03:37] *** Joins: matty_matt (~matt@135.129.244.71)
[21:09:37] *** Joins: tatsumaru (~tatsumaru@78.83.244.47)
[21:10:48] *** Quits: tatsumaru (~tatsumaru@78.83.244.47) (Client Quit)
[21:12:05] *** Quits: matty_matt (~matt@135.129.244.71) (Ping timeout: 256 seconds)
[21:18:04] <mwnaylor> I guess the one way to debug exceptions is to temporarily wrap the offending line in a try form and cider-debug-defun-at-point on the catch form. Is there a better way?
[21:23:13] *** Joins: AlaskanEmily (~AlaskanEm@user/alaskanemily)
[21:25:25] <mwnaylor> I should use sets more often in my Clojure code. They make excellent filter predicates for both inclusion and exclsion. If #{…} is the inclusion predicate, then (complement #{…}) is the exclusion predicate.
[21:26:27] <mwnaylor> I'm also starting to appreciate the power of for comprehensions.
[21:27:18] <ridcully> if you filter with complement you can also use remove
[21:28:14] <Solid> I'm stil a bit sad `for` is defined "the wrong way around"
[21:28:22] <Solid> (at least to my mind)
[21:29:03] <technomancy> which part of `for`?
[21:30:15] <ridcully> result first, then how to build up to it i assume?  like haskells list comprehension?
[21:30:48] * technomancy ponders the nature of causality
[21:31:01] <Para> I'd imagine they wanted it to have similarity to let. Or let and for are meant to be similar to something else.
[21:31:02] <ridcully> maybe that would keep for out of the top three beginner traps... because it would look unfamiliar
[21:31:19] <technomancy> seems like ... causes precede their effects normally?
[21:32:40] <Solid> Yes I think of list comprehensions much like "set comprehensions" in mathematics; there'd we'd write something like { x | x ∈ A } instead of `(for [x (blah)] x)`
[21:32:40] <ridcully> Para: also doseq
[21:32:59] <Para> oh yeah, that's also a thing
[21:33:00] <Solid> (and yes Haskell thankfully gets this right)
[21:33:19] <technomancy> Solid: so you want it to be backwards in terms of causality?
[21:33:28] <technomancy> like the results before the thing they come from?
[21:33:51] <Solid> yes
[21:34:24] <Solid> my brain gets stuck on very small things sometimes :)
[21:34:40] <technomancy> huh, I wonder if mathematical notation works that way because Algebra was invented by people who spoke Arabic
[21:35:13] <Solid> this kind of set notation is definitely much younger than that
[21:35:20] <Solid> so I doubt that there is any relation
[21:35:46] <technomancy> hm; maybe they were Hebrew speakers then?
[21:38:11] <Solid> AFAIR the set theory that we know as set theory today was developed like 200 years ago mostly in central europe
[21:38:31] <Para> hah, there's `destructure` in core
[21:38:42] <Para> went looking for everything which uses bindings
[21:38:43] <Solid> starting with Cantor and the like (actually, that would make it less than 200 years old.  oh well)
[21:38:59] <Solid> so maybe some people just do find that way around more intuitive :)
[21:39:15] <TMA> the English language does it too: "grab foo thingy, where foo means ..."
[21:41:36] <Para> Java and python also has the x in xs form.
[21:41:41] <Para> Now that I think of it.
[21:41:46] <Solid> it seems like less cognitive load somehow "first give me a high-level understanding what you want to do and then tell me how the individual parts work"
[21:41:50] <technomancy> mathematical notation is obscure and confusing and I'm glad for places where we can improve on it and make clearer ways to communicate.
[21:42:06] <Solid> (which is why I prefer "where clauses" to "let clauses" whenever they are available)
[21:42:16] <Solid> technomancy: Agree to disagree, I suppose :)
[21:42:47] <technomancy> that said I am guilty of sometimes naming variables ϴ
[21:42:57] <Para> One should always remember when programming that majority of programmes have no idea what set theory is :-)
[21:42:57] <technomancy> I should cut that shit out probably
[21:43:15] <Para> (and equally curiously most haven't heard of trees)
[21:45:34] <TMA> arguably most programming is genetic programming... the programmer mutates the code until it does something that looks like it works somewhat
[21:46:17] <Para> Programming is kind of abstract data structure abuse, indeed :D
[21:46:34] <Para> Hmm, maybe I should call myself Data Pugilist!
[22:09:37] *** Quits: neirac (~neirac@pc-122-191-45-190.cm.vtr.net) (Quit: ZNC 1.8.2 - https://znc.in)
[22:16:34] *** Joins: neirac (~neirac@pc-122-191-45-190.cm.vtr.net)
[22:23:38] *** Quits: mbuf (~Shakthi@122.178.176.47) (Quit: Leaving)
[22:28:10] *** Joins: tatsumaru (~tatsumaru@78.83.244.47)
[22:30:06] <mwnaylor> The Unicode θ, or the word theta?
[22:30:41] <tatsumaru> I'm trying out random things in the repl and found out that (set '(a b c d e f g)) returns #{a e c g b d f} at first I thought this was random, but then I tried this many time using numbers as well and  realized these seven letters are always returned in this seemingly random order so I was wondering how was that order determined.
[22:31:31] <ridcully> tatsumaru: sets are unordered
[22:31:49] <ridcully> there is sorted-set in core and there is an ordered-set in clj-common
[22:31:49] <tatsumaru> ridcully: yeah, but if I always get the same result isn't that an order?
[22:32:04] <aphyr> Ordered by hash :)
[22:32:23] <ridcully> yes, it is to expect, that immutable data structures would "order" the same
[22:33:11] <technomancy> it's impossible to print an unordered data structure in an ordered display without applying some ordering but that doesn't mean the ordering is inherent in the data.
[22:33:48] <tatsumaru> technomancy: I was just asking what made it generate the same result every time
[22:34:16] <ToxicFrog> Some implementation detail of how the set data type works intersecting with the way sets are printed out.
[22:34:20] <ridcully> the hash of the value (like aphyr mentioned)
[22:34:31] <mwnaylor>       ^^^^^^^
[22:35:16] <tatsumaru> but shouldn't the hash change if I added a number in like this (set ' (a b c d e f g 1))
[22:35:21] <aphyr> I suspect there's something else at play with how the set structure internally arranges records too, cuz it's not just ordered by clojure or java hash
[22:35:24] <aphyr> user=> (set '(a b c d e f g))
[22:35:27] <aphyr> #{a e c g b d f}
[22:35:29] <aphyr> user=> (sort-by #(.hashCode %) '(a b c d e f g))
[22:35:32] <aphyr> (b a d c f e g)
[22:35:34] <aphyr> user=> (sort-by hash '(a b c d e f g))
[22:35:37] <aphyr> (e b g d a c f)
[22:36:28] <aphyr> tatsumaru: at least on my machine, adding numbers doesn't disrupt the order of other set members
[22:36:41] <tatsumaru> user=> (set '(a b c d e f g))
[22:36:42] <mwnaylor> sets, if iirc, are basically hash-maps that have only keys and no values.
[22:37:20] <tatsumaru> aphyr: yeah, same here
[22:37:42] <tatsumaru> everyone gets the same output on those values
[22:37:48] <aphyr> tatsumaru: Is that surprising?
[22:38:23] <tatsumaru> aphyr: well not sure if it's surprising because I am still a nob, I just thought that sets being unordered, they'd output the letters randomly
[22:38:28] <tatsumaru> noob*
[22:39:02] <aphyr> Yeah, it might be more correct to refer to them as "ordered, but it's at the discretion of the runtime"
[22:39:23] <aphyr> You can't rely on that order between two different machines, or different versions of Clojure or the JVM, necessarily.
[22:40:24] <tatsumaru> aphyr: i see
[22:40:49] <ridcully> or rather some implementation detail.  adding small amounts could appear to keep an order but adding more could randomly change the order of the whole container (due to some internal storage change/optimization/...)
[22:41:37] <ToxicFrog> Yeah -- "unordered" (in most languages, not just this one) usually means in practice "there is some sort of order, but it is an emergent property of the way that data type works on some specific combination of language version, runtime version, host system, and the actual data you're storing; you can't rely on it being predictable, or being consistent across machines, across executions, or even
[22:41:39] <ToxicFrog> across subsequent inspections of the same object"
[22:42:15] <tatsumaru> it's relatively ordered lol
[22:42:21] <ToxicFrog> (and at least some languages have deliberately introduced nondeterminism into their unordered data structures to discourage people who were relying on the fact the order was under some circumstances predictable)
[22:42:53] <ridcully> the point here is, there is no order guarantee and you must not rely on whatever you whitnes.  you have to pick a container, that fullfill your needs.
[22:42:59] <technomancy> ToxicFrog: Clojure is a lot more comfortable saying "oh, you got the wrong results because you depended upon an implementation detail? too bad for you"
[22:43:06] * technomancy glances at clojure.core/contains?
[22:44:07] <tatsumaru> I wonder if there's some detail making sure the output will never match the original order of the input in order to remind developers that sets are unordered
[22:44:24] *** Quits: mwnaylor (~user@2601:5ce:4300:5560::68b3) (Ping timeout: 265 seconds)
[22:44:35] <ridcully> there is not
[22:44:48] *** Joins: turbofail (~user@157-131-95-100.fiber.dynamic.sonic.net)
[22:45:27] <technomancy> Clojure doesn't care if you didn't read the docstring; this is a pretty consistent theme in its design. they only changed contains? after like a decade of people complaining.
[22:45:44] <technomancy> despite a catastrophically poor naming choice
[22:45:58] <tatsumaru> technomancy: what's the issue with contains?
[22:46:25] <ridcully> tatsumaru: try this in your repl: (take 10 (reductions conj #{} (range)))
[22:46:49] <technomancy> it used to be that (contains? '(:a :b :c) :a) would return false
[22:46:56] <technomancy> now it throws an exception
[22:47:16] <Para> I'm still angry about contains?
[22:47:28] <Solid> (contains? [:a] :a) ;; => false
[22:47:32] <Solid> this still seems to work, however
[22:47:44] <technomancy> Solid: and also (contains? [9 10 11] 1) still returns true so yeah
[22:47:53] <Solid> amazing
[22:48:06] <technomancy> it's still incredibly misleading; just in a way that's slightly less bad than before
[22:48:19] <Para> It's more like "contains index?"
[22:48:27] <ridcully> contains? is for key lookup
[22:48:40] <ridcully> so contains? on a vector will tell you if the index is available
[22:48:51] <tatsumaru> (contains? [:a :b :c] :a) still returns false for me
[22:48:54] <ToxicFrog> Yeah, I think if it were named contains-key? or similar no-one would complain
[22:49:11] <ridcully> i'd assume, this is the reason, why *-in works for vectors
[22:49:15] <technomancy> larger point is that Clojure doesn't care if you assumed that the name reflects the behavior of what it does and neglected to read the docstring
[22:52:15] <tatsumaru> so clojure isn't too user-friendly then
[22:52:51] <Para> In the group of lisps it is, majorly.
[22:52:54] <technomancy> that's one way to put it. wouldn't necessarily disagree.
[22:53:08] <Para> But I guess YMMV. :)
[22:54:56] <aphyr> Yeah, with respect to contains? you have to think of vectors as "dense maps"
[22:55:41] <ToxicFrog> tbh I don't think clojure is noticeably more unfriendly than most languages here; for example, using # on a table in Lua has similar "this is a legal operation but it almost certainly does not do what you actually wanted" issue
[22:55:41] <Solid> I'm left to wonder why they didn't just... rename it to contains-key?
[22:55:43] <aphyr> it's absolutely a missing stair but I think we're stuck with it now
[22:55:43] <ToxicFrog> it does have a few very unfortunately named functions in the stdlib that have not been changed (presumably for backwards-compatibility reasons), though
[22:56:08] <aphyr> Also the n different meanings of "some" in the stdlib
[22:56:29] <ToxicFrog> Yeah, some/some? is the other one I was thinking of
[22:56:44] <technomancy> Solid: removing the existing name is a bad idea but keeping it as an alias for the better-named version? you'll have to ask Rich.
[22:56:50] <aphyr> Every language has some of these... I think Clojure generally has fewer than most
[22:56:50] <ToxicFrog> It looks like some? should go with every? and whatnot (and like it should probably be called any? instead, for symmetry with not-any?)
[22:57:06] <Solid> technomancy: nono, I mean quite literally just renaming it
[22:57:07] <ToxicFrog> But instead you want some (without the ?), and some? is (not (nil? _))
[22:57:27] <ridcully> any? got burned by spec
[22:57:56] <technomancy> Solid: removing existing functions is just a terrible idea. never going to happen, and for good reasons.
[22:57:56] <ToxicFrog> (also the fact that some returns (p x) rather than x gets me every time, because usually what I want is "the first x in the collection satisfying p")
[22:58:10] <ToxicFrog> (so I end up doing (first (filter p xs)) or so)
[22:58:17] <aphyr> Yeah, first+filter has taken over for me too
[22:58:33] <technomancy> but what should happen is that contains? becomes an alias for contains-key? and it emits a compile-time warning that you should stop using it, or at least linter-level warnings.
[22:58:44] <Solid> technomancy: why?  any code base that uses `contains?` could be updated by a sed one-liner
[22:58:45] <aphyr> technomancy: agreed
[22:59:14] <technomancy> Solid: dosen't matter
[22:59:29] <technomancy> you can't use sed on jar files in clojars
[22:59:36] <aphyr> Solid: Also depends on if contains? is ever used as a variable or defined as a different function
[22:59:41] <technomancy> or, I guess you could maybe? but it would be awful
[22:59:43] <tatsumaru> Solid: a lot of people will not know they need to replace that I guess
[22:59:59] <technomancy> also sed doesn't know about namespace aliasing
[23:00:10] <Solid> tatsumaru: seems just like something that should be put into the release notes
[23:00:11] <technomancy> you can do (:refer-clojure :exclude [contains?]) and have your own
[23:00:35] <Solid> but then you'd know not to call sed on those files, right? :D  
[23:00:44] <technomancy> anyway I'm glad that Clojure doesn't do things like that but I wish it would actually care enough to do *something*
[23:00:48] <Solid> In either case it seems like the easiest breaking change to upgrade to
[23:01:02] <ridcully> technomancy: can we expect, that this is either an 8 year old jira ticket or got closed without comment 8 years ago?
[23:01:13] <tatsumaru> technomancy: is clojure stagnating?
[23:01:14] <aphyr> ridcully: ooooof
[23:01:18] <technomancy> ridcully: might predate jira tbh
[23:01:33] <technomancy> tatsumaru: I don't follow Clojure development any more; you should ask someone else =)
[23:02:15] <ToxicFrog> I am somewhat spoiled by Lua here which is very, very willing to make breaking changes between major (and even sometimes minor) releases in the name of correctness
[23:02:17] <ToxicFrog> But one of the reasons lua can get away with that is the intended use case for it as a language is situations where bundling the entire runtime with your program is trivial and inexpensive, so if a new version breaks compatibility with your code you just go "ok whatever" and keep using your current version
[23:02:23] <tatsumaru> technomancy: oh so you meant *something* in that context per se, I thought you meant *something* in general
[23:02:31] <ToxicFrog> Most languages can't afford to do that without making a lot of people very sad
[23:02:42] <technomancy> tatsumaru: ah right; yeah I mean for contains? and other missing stairs.
[23:03:36] <tatsumaru> ToxicFrog: I feel most technologies overinvest in backwards compatibility 
[23:03:57] <aphyr> This is something I really *really* like about Clojure: it rots very slowly
[23:04:19] <tatsumaru> aphyr: what is rot in that context?
[23:04:22] <aphyr> code generally runs unchanged across decades; lots of stable mature code.
[23:04:32] <technomancy> ToxicFrog: Clojure is much closer to that than any other language I've used tho; just change a line in project.clj to get a different version
[23:04:37] <aphyr> In the ruby world, your code just... breaks, or silently develops bugs, because APIs are constantly in flux
[23:05:13] <tatsumaru> oh I see, so code breaking due to external circumstances
[23:05:30] <aphyr> Yeah.
[23:06:02] <technomancy> ToxicFrog: but Lua is the only place I know where that logic applies to the entire *runtime* not just the compiler.
[23:06:18] <tatsumaru> isn't it better to adopt a culture where code is rewritten more often rather than use old code for long periods of time
[23:06:56] <Solid> "code generally runs unchanged across decades" sounds like code for "old mistakes will never get fixed because it could inconvenience people expecting their 10 year old patchwork projects to still work with the newest compiler" :/
[23:07:44] <Para> Solid: That's the expectation a lot of other ecosystems have caused.
[23:08:12] <technomancy> yes definitely, but that sounds worse than it is when you come from a language run by frequent makers of mistakes rather than people who move slowly and thoughtfully.
[23:08:21] <Para> ...hmm, one could write a lein plugin which prints out the histogram of dependency ages. Call it lein grandpa or something.
[23:08:34] <technomancy> contains? is a drop in the bucket compared to the mistakes in the Ruby standard library
[23:09:45] <technomancy> I just gave a talk about this last week for how we address design mistakes in Fennel; it's not by removing the bad forms but by deprecating them and providing better alternatives.
[23:09:58] <technomancy> but also by moving very slowly and limiting scope drastically
[23:11:05] *** Quits: cmiles74 (~miles@068-184-030-013.res.spectrum.com) (Ping timeout: 256 seconds)
[23:11:13] <ToxicFrog> technomancy: "just change a line in project.clj to get a different version" is, IMO, a strong argument in favour of making breaking changes (like turning contains? into contains-key?), but for some reason the clojure devs remain very reluctant to do that
[23:11:15] <ToxicFrog> I've always assumed it's because leiningen users are in a minority of clojure users and they don't want to break everyone else, or something
[23:11:46] <tatsumaru> technomancy: curious whether a company adopting Fennel as a standard could result in their rate of innovation increasing
[23:12:55] <technomancy> the idea that a company could have a measurable "rate of innovation" is very suspect in my mind
[23:13:45] <ridcully> for jira has a graph for that.  have you checked the manager dashboard?
[23:14:11] <technomancy> fennel is designed to be as uninteresting as possible to tech companies; it's been mostly successful so far
[23:14:42] <technomancy> I only know of one person using it at a tech company and they definitely don't have their boss's approval
[23:15:43] <tatsumaru> did you write fennel?
[23:16:04] <technomancy> I've been the primary developer for the past 3 years but am not the creator
[23:16:16] <tatsumaru> do you also work on janet?
[23:16:28] <technomancy> no, janet is led by the original creator of fennel
[23:16:58] <technomancy> I'm more interested in compilers and language design than creating a runtime
[23:17:55] <aphyr> Solid: I strongly disagree--code which is rewritten often is a great candidate for introducing subtle safety violations when callers interact with that code.
[23:18:24] <tatsumaru> what is a caller?
[23:18:29] <aphyr> function caller
[23:18:36] <tatsumaru> ah right
[23:19:17] <aphyr> I've got some ruby projects I've maintained for... gosh, almost two decades, and this happens *constantly*
[23:19:35] *** Quits: schmudde (~schmudde@216.169.6.249) (Ping timeout: 256 seconds)
[23:19:45] <tatsumaru> aphyr: could be a trade-off that's worth it?
[23:19:54] <aphyr> If you're lucky, you get an obvious error when you run/test the project. If you're unlucky, it silently corrupts data.
[23:20:59] <Solid> aphyr: I'm completely unqualified to have an opinion on this but I appreciate it when languages make breaking changes in order to actually fix things, even if it means some churn in the ecosystem
[23:21:06] <aphyr> Like oh, surprise, we changed the way that we access option maps in a database client; where you previously asked for {"consistency" "all"}, we now expect {:consistency :all}.
[23:21:31] <aphyr> Now the client doesn't find the consistency key, and silently defaults back to weaker behavior, allowing data loss.
[23:22:00] <tatsumaru> that sounds like an useless change at first glance
[23:22:18] <technomancy> it happens all the time
[23:22:27] <aphyr> From the caller's perspective, yes! But from the database client author's perspective, they're improving internal consistency of the project
[23:23:03] <aphyr> The thing is that software is maintained by people who have no idea of each other's existence; whenever you alter code, you have basically no idea how it's been used or how you'll alter their semantics.
[23:23:55] <aphyr> That's why it's so important to make API changes *obvious* to callers--ideally by preventing compilation, or at least logging runtime messages, so they're aware of the semantic shift. There's no way I'm reading the changelogs for the 60+ dependencies in my web app. ;-)
[23:24:37] <tatsumaru> sometimes I feel like companies that use their own programming language have a significant advantage in these situations as they only have to care what's optimal for their usecase
[23:25:03] <tatsumaru> just deleting all that complexity
[23:26:58] <aphyr> Oh.... that varies, haha. Once you get large enough, the maintainers of different software components in the same company have no idea of each other's existence. Or they're actively fighting each other.
[23:28:47] <technomancy> anyway most of the complexity is from the libraries and runtime, not the language itself
[23:28:59] *** Joins: Ilyu (~quassel@166.215.82.79.rev.sfr.net)
[23:32:40] *** Joins: cmiles74 (~miles@068-184-030-013.res.spectrum.com)
[23:34:43] <technomancy> but if a big company wanted to hire me specifically to build them a lisp, I'd probably take them up on it
[23:34:58] <tatsumaru> *just sayin*
[23:36:33] <tatsumaru> can someone please explain why Hy isn't to Python what Clojure is to Java? Someone said Hy is just useless syntaxis without added value or something like that and that Clojure analogy wasn't good.
[23:37:46] <technomancy> I think a big part of it is that hy's compiler outputs python ASTs so it's much more limited in how it can change the semantics of the language
[23:37:58] <technomancy> like there's certain broken things about python's scoping that they just cannot fix
[23:38:30] <technomancy> this is especially ironic in context of this discussion since python is famous for breaking things and causing headaches, but they still haven't fixed their awful scoping rules or default-value behavior
[23:39:08] <technomancy> so for one, Java has way better basic semantics than Python, but even if it didn't it's not that relevant since Clojure emits JVM bytecode which you could never even produce from Java if you tried
[23:39:08] <tatsumaru> so hy is just lispy python?
[23:39:23] <technomancy> like if you decompile Clojure's output back into Java source, it gives you invalid results
[23:40:37] <technomancy> it's like ... the compiler pipeline just has to go thru a "narrower pipe" before it gets executed, and that pipe is dictated by the semantics of the python language rather than that of the python VM
[23:41:12] <technomancy> if they output python bytecode instead they could design a much better language, but AFAIK python does not guarantee bytecode compatibility across versions of their VM the same way Java does
[23:41:42] <tatsumaru> ahhh, I see, what's happening here... very interesting
[23:42:09] <technomancy> (Fennel has roughly the same problem, except that Lua semantics are much better than Python's; it starts out shockingly close to Scheme)
[23:42:34] <tatsumaru> is fennel hosted on the lua vm?
[23:42:42] <technomancy> yeah
[23:43:26] <technomancy> same situation where we have to emit source code because bytecode cross-compatibility is not guaranteed, but it just causes a lot fewer problems. (not *zero*, but a lot fewer than hy has)
[23:43:56] <tatsumaru> who is responsible of guaranteeing bytecode compatibility?
[23:44:08] <tatsumaru> for*
[23:44:53] <technomancy> are you asking who develops the JVM? it's a team at Oracle.
[23:45:09] <tatsumaru> i mean in general who could make a decision like that for a language
[23:45:46] <tatsumaru> i guess it's a case-by-case thing
[23:46:15] <tatsumaru> is there any benefit to not guaranteeing bytecode compatibility?
[23:49:45] <Para> Not really.
[23:50:02] <Para> Unless you want to reduce the amount of available libraries and frameworks for some odd reason.
[23:50:42] <Para> Scala famously does not have bytecode/serialization compatability guarantee, and they have to compile everything to multiple major versions because of that.
