[18:05:49] <dminuoso> Mmm in optics, is there a way to filter by a predicate? Specifically I have a coproduct type, and I want to do something like `foo % rejectedBy (foo % _Just % _Bar)` 
[18:59:20] <amesgen[m]> dminuoso: Are you looking for `filteredBy`?
[19:01:16] <amesgen[m]> i.e. > [Just 1, Nothing, Nothing, Just 2] ^.. each % filteredBy _Just
[19:01:16] <amesgen[m]> [Just 1,Just 2]
[19:06:18] <dminuoso> amesgen[m]: No, I guess I was looking for `filtered`, such that I could do `filtered (hasn't _Bar)`
[19:09:14] <amesgen[m]> Ah, so `filteredBy` with a negative predicate. BTW, there is `isn't` to ensure that the argument is/stays affine.
[19:09:41] <dminuoso> Ah neat, did not know
[19:10:18] <dminuoso> For my use case its fairly irrelevant because I get a non-affine out at the end anyway, but Ill try to remember that one
[19:34:32] <dminuoso> Somewhat relatedly, do lens or optics have version of `filtered` that gives me a non-index traversal instead?
[19:35:14] <dminuoso> Not withering, but a version that simply leaves non-matching targets as they were 
[19:36:51] <dminuoso> I'd really like to be able to say `foo & traversedBy (field11 . _Just . _Bar) % field2 %~ f`
[19:50:19] <amesgen[m]> dminuoso: Isn't this exactly what `filtered` (or `unsafeFiltered` in optics) does? Like you have 
[19:50:19] <amesgen[m]> > [(Just 1,2),(Nothing,5),(Just 2,0),(Nothing,7)] & each . filteredBy (_1 . _Just) . _2 +~ 3
[19:50:19] <amesgen[m]> [(Just 1,5),(Nothing,5),(Just 2,3),(Nothing,7)] 
[19:50:21] <lambdabot>  [(Just 1,5),(Nothing,5),(Just 2,3),(Nothing,7)]
[19:50:52] <dminuoso> amesgen[m]: Ah, that's the difficulty of navigating both lens and optics.
[19:51:04] <dminuoso> I kept looking at filtered and imagined this could only be an (Ix)Fold.
[19:51:25] <amesgen[m]> You mean Traversal?
[19:51:56] <dminuoso> Im primarily an optics user, so no, IxFold
[19:52:15] <dminuoso> filtered :: (Choice p, Applicative f) => (a -> Bool) -> Optic' p f a a
[19:52:26] <dminuoso> To me its not clear that this is a traversal, my lens-fu is not strong enough
[19:52:30] <amesgen[m]> Yes, but `filtered` is a Fold, and you were apparently looking for the traversal variant
[19:52:34] <amesgen[m]> (in optics)
[19:52:42] <dminuoso> Yeah
[19:53:33] <amesgen[m]> `filtered` is only a lawful traversal when you don't invalidate the predicate
[19:53:55] <dminuoso> Yeah couldnt happen for wrhat I want
[19:54:00] <dminuoso> I want a predicate on one field but update another.
[19:54:14] <amesgen[m]> Yes, in this case it is safe
[19:54:49] <amesgen[m]> optics just is a little pickier in explicitly putting "unsafe" prefixes in front of possibly unlawful optics
[23:00:15] *** Joins: selfsymmetric-mu (~matt@c-73-29-248-41.hsd1.nj.comcast.net)
[23:01:33] <selfsymmetric-mu> I saw a trick once where someone reversed the parts of a list that met a predicate, leaving the other elements in place. But I can't seem to find itâ€¦
[23:32:36] <jackdk> % [1..10] & traverse . partsOf (filtered even) %~ reverse
[23:33:10] <jackdk> > [1..10] & traverse . partsOf (filtered even) %~ reverse
[23:33:12] <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
[23:34:30] <jackdk> > [1..10] & traverse . partsOf (filtered even) .~ [42..]
[23:34:31] <jackdk> odd
[23:34:31] <lambdabot>  [1,42,3,42,5,42,7,42,9,42]
[23:46:30] <xplat> > [1..10] & partsOf (traverse . filtered even) %~ reverse
[23:46:31] <lambdabot>  [1,10,3,8,5,6,7,4,9,2]
[23:47:47] <xplat> > [1..10] & partsOf (traverse . filtered even) .~ [42..]
[23:47:49] <lambdabot>  [1,42,3,43,5,44,7,45,9,46]
[23:49:08] <xplat> > [1..10] & partsOf (traverse . filtered even) .~ [42,44..]
[23:49:10] <lambdabot>  [1,42,3,44,5,46,7,48,9,50]
