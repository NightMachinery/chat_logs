[03:32:07] <headius> Hey there
[03:33:02] <headius> You could check the branch on enebo's fork, I don't think he has landed anything yet
[03:44:12] <puritylake[m]> Will do
[03:53:00] <puritylake[m]> Not noticing anything pertaining to it on his fork, guess I can assume I can pick up from the branch in the main repo
[04:03:33] <headius> Ah ok maybe he did the branch on the main repo
[10:13:10] *** Quits: satyanash (~satyanash@143.110.247.92) (Ping timeout: 260 seconds)
[10:13:44] *** Joins: satyanash (~satyanash@143.110.247.92)
[10:19:33] *** Quits: satyanash (~satyanash@143.110.247.92) (Quit: kthnxbai)
[10:20:51] *** Joins: satyanash (~satyanash@143.110.247.92)
[18:06:04] <enebo[m]> puritylake: yeah it is still in-progress
[18:11:43] <puritylake[m]> <enebo[m]> "puritylake: yeah it is still in..." <- Awesome I'll get back to work on it so, I'll mention here if I put up a PR for testing
[18:14:37] <enebo[m]> puritylake: great!
[19:30:06] *** Quits: nowherefast[m] (~nowherefa@2001:470:69fc:105::1:52b0) (Quit: You have been kicked for being idle)
[19:53:47] *** Joins: lucerne (~lucerne@ip202.ip-51-178-215.eu)
[22:14:41] <headius> enebo: https://github.com/jruby/jruby/pull/7004
[22:16:02] <headius> I believe this is the proper fix for https://github.com/jruby/jruby/pull/6789
[22:20:02] <enebo[m]> headius: looks ok to me.  In my mind () runs in a subshell but I don't recall
[22:20:29] <enebo[m]> Or I should say it doesn't matter regardless
[22:20:59] <headius> ahh that's true, perhaps there's a better way to group boolean expressions
[22:22:12] <enebo[m]> headius: even if broken apart there are processes getting started and this will exploit laziness
[22:22:34] <headius> yeah docs are difficult to grok on these operators
[22:22:55] <enebo[m]> ship it!
[22:23:01] <headius> Expressions may be combined using the following operators, listed in decreasing order of precedence:
[22:23:01] <headius> ( expression )
[22:23:01] <headius> Returns the value of expression. This may be used to override the normal precedence of operators.
[22:23:18] <enebo[m]> ah maybe it is not a subshell
[22:23:25] <headius> this is from bash docs
[22:23:28] <enebo[m]> I don't know what I am thinking of
[22:23:39] <headius> I will have mrnoname take a look as well
[22:23:46] <enebo[m]> Something does that and maybe it is csh/tcsh
[22:24:19] <enebo[m]> I used to use tcsh for decades before just accepting bash is the lowest flow path and you have to somewhat understand it
[22:24:43] <enebo[m]> headius: I was thinking about the listen issue
[22:24:55] <headius> ok
[22:24:59] <enebo[m]> your last update was that logging somehow fixed it
[22:25:35] <headius> turning on logging does seem to enable the listening... I confirmed that with it off the listen hook never fires
[22:25:36] <enebo[m]> Is it possible logging loads some native exec thing or fails to load it and thus making listen work
[22:26:04] <enebo[m]> I know our logger is just java native code with some Ruby so I don't quite get that
[22:26:19] <enebo[m]> just was thinking conditionally what sort of scenario would make something work
[22:26:19] <headius> I don't think this library has a fast listen impl for JRuby... the one that is there is for CRuby using inotify or whatever
[22:26:30] <headius> oh you mean ours maybe
[22:26:32] <headius> I don't know
[22:26:33] <enebo[m]> another thought was a global var or IO option somehow changed something
[22:26:51] <enebo[m]> and this is only happening on macos
[22:28:02] <headius> woah, something is very wrong in CI
[22:28:08] <headius> look at the fails on that PR
[22:28:33] <headius> that looks like the fails I was getting with my M1 work, many F and E in specs we know should be green
[22:28:38] <headius> and which are green locally
[22:28:49] <headius> all spec:ji jobs also failed
[22:28:53] <enebo[m]> you targeted master
[22:29:10] <headius> oh that could be it?
[22:29:21] <headius> I will fix that and rerun but shouldn't it just use my branch as is
[22:29:43] <enebo[m]> headius wants to merge 1 commit into jruby:master from headius:fix_modules_condition
[22:29:47] <enebo[m]> So I think this is running on 9.4
[22:29:54] <enebo[m]> which has lots of failures
[22:30:08] <enebo[m]> although it could still be something weird with CI
[22:30:08] <headius> ok I will fix that and see
[22:30:11] <enebo[m]> just saying it is not green
[22:30:29] <headius> I don't know why it would run against master though because the branch is still based on 9.3
[22:30:32] <headius> but I am not sure how exactly it handles PR testing
[22:30:47] <enebo[m]> I am going to try the repro on listne bug to see if perhaps I get lucky and it does not work
[22:35:51] <enebo[m]> This listen thing seems broken locally for me too
[22:36:12] <enebo[m]> I have to wonder about the Gdx bit here
[22:37:48] <enebo[m]> like signals or some process level gunk
[22:38:07] <enebo[m]> I want to see this run properly on 9.2 though
[22:39:49] <headius> ok I figured out two screw-ups from bad PR target
[22:39:54] <headius> my M1 fixes to run on GHA went to master too
[22:40:19] <headius> so it must be running CI against the merge and not just against the test branch
[22:40:43] <headius> I have retargeted that PR to 9.3, merged it there, and then my new PR looks right and only has the one new fix for jruby.bash
[22:41:15] <headius> I wish github did a better job of detecting the base branch for a PR
[22:41:41] <headius> it really is not well designed for multiple active development branches
[22:42:04] <enebo[m]> https://gist.github.com/enebo/fbe91bb1dbe8151b7b270cb02b252ed1
[22:42:08] <enebo[m]> This is 9.2
[22:42:35] <enebo[m]> Ah but I did not bundle install so maybe paint or pry are making something go wrong here
[22:47:40] <headius> yeah not sure what that is
[22:48:19] <enebo[m]> ok so 9.3 does nothing and 9.2 tries to figure something but dies trying to start a thread in listener
[22:58:14] <headius> enebo: so everything I fixed, you might want to check my work
[22:58:27] <headius> This one was merged incorrectly to master: https://github.com/jruby/jruby/pull/6823
[22:58:40] <headius> I reverted it here: https://github.com/jruby/jruby/pull/7005
[22:59:00] <headius> This is the new PR for M1 fixes, merged to 9.3: https://github.com/jruby/jruby/pull/7006
[22:59:23] <headius> jruby.bash PR rebased on top of that and now looks green: https://github.com/jruby/jruby/pull/7004
[22:59:36] <headius> when this all lands I'll merge 9.3 to master and we should be back to normal
[22:59:43] <enebo[m]> if that passes on stadium I am happy.  There is not much really to review.
[22:59:59] <headius> GHA must be running PR CI against the merged result because I don't know how else this could pick up master changes from a branch based on 9.3
[23:00:10] <headius> perhaps I should know that already
[23:00:59] <headius> this may mean I can reenable spec:ruby:fast for 9.3 on M1 since it should be green
[23:01:13] <enebo[m]> The listen gem example does have maybe an interesting wrinkle
[23:01:26] <enebo[m]> both listen and gdx both essentially run event loops
[23:01:27] <headius> 7004 looking good in CI
[23:03:13] <headius> once I merge this I can help with listen thing
[23:03:18] <enebo[m]> I think I solved this problem
[23:03:24] <headius> bravo
[23:03:26] <headius> what is it
[23:03:38] <enebo[m]> I added a gets at the bottom of the file and it works fine
[23:03:51] <enebo[m]> so it was probably trying to finalize or something but it couldbn't because gdx was still running
[23:04:48] <enebo[m]> It does not explain why it works for him for 9.2 but then again it crashes on me on 9.2
[23:05:29] <enebo[m]> ok it works on 9.2 with the gets as well
[23:06:03] <enebo[m]> So it runs off the script and thinks it maybe can shutdown but because we have some daemon threads JRuby stays up but listen tries to cleanup
[23:06:47] <enebo[m]> That explains on 9.2 why I get a conc thread pool error...it decided to try and deliver a change event but listen was already partially torn down
[23:08:08] <headius> aha that makes sense
[23:08:29] <headius> 9.3 has different teardown logic that allows more shutdown hooks to run
[23:08:45] <headius> so it might end up swallowing that error in the executor
[23:08:47] <enebo[m]> yeah 9.3 cleanly turns it off
[23:08:59] <enebo[m]> but there is only one unanswered thing 
[23:09:05] <enebo[m]> how did you add logging?
[23:09:19] <enebo[m]> Is it possible you created a loop in the main thread?
[23:09:19] <headius> the listen gem has an env var, I mention it in one comment
[23:09:29] <headius> I just set that env
[23:09:38] <enebo[m]> ok perhaps the result of that keeps it alive somehow
[23:10:19] <enebo[m]> I am satisfied this is not our bug but I may see how Lwjgl is supposed to work.  I used this a long time ago with jmonkeyengine
[23:10:21] <headius> yeah I could see it changing the sequence of shutdown or doing something to keep it up
[23:10:59] <headius> I agree this is the simplest and most plausible explanation
[23:11:14] <headius> which would mean we have no further work to do other than following up with the reporter
[23:12:23] <enebo[m]> yeah I will write something up and spend a few seeing how you are supposed to do this in Java
[23:12:35] <enebo[m]> It would seem this is missing some loop or something
[23:12:59] <enebo[m]> I guess Java would just exit the thread and others would be running
[23:13:20] <enebo[m]> So maybe that is just a difference here since us leaving this first script makes us think things are done
[23:13:34] <enebo[m]> unless we can mark the thread in such a way we think it is still up
[23:14:57] <enebo[m]> lol sparse docs
[23:19:33] <headius> yeah I have never been happy with this behavior of JRuby but I'm not sure what else we can do
[23:19:54] <headius> all we have to delineate the begin and end of the program is the main script
[23:20:17] <headius> yay, 7004 bash fix on top of GHA M1 fixes is green, merging
[23:20:54] <headius> oh nice k77ch7 has some 3.0 PRs
[23:22:32] <headius> enebo: only thing remaining marked for 9.3.3 is the super NPE thing
[23:22:38] <headius> I will try to repro
[23:22:49] <enebo[m]> ok cool yeah
[23:22:59] <enebo[m]> Does ruby have a Thread.wait?
[23:23:06] <enebo[m]> I think this would be the right workaround here
[23:24:50] <headius> you could sleep
[23:25:06] <headius> not sure what thread you would wait for otherwise
[23:27:31] <enebo[m]> ah yeah sleep with no args is the proper workaround
[23:29:12] <headius>  Java::JavaLang::NullPointerException:
[23:29:12] <headius>    Cannot invoke "org.jruby.javasupport.proxy.JavaProxyClass.getMethod(String, java.lang.Class[])" because "jpc" is null
[23:29:14] <headius> gotta love helpful NPEs
[23:36:38] <headius> this one may not be too hard to fix
[23:36:51] <headius> it is interpreting a super from within a reopened Java class as though it's a Ruby subclass, but it isn't
[23:37:03] <headius> so it tries to find the Ruby java proxy class and none is there and it NPEs
[23:42:08] <headius> so this is a case we did not cover I guess... adding a method with super to a reopened Java class (without extending from Ruby)
[23:49:56] <headius> enebo: I have a fix that passes spec:ji but it would be good for byteit101 to have a look
[23:50:23] <enebo[m]> great yeah hopefully he is arond
[23:50:24] <headius> not sure if that can happen before we want to release
[23:50:43] <enebo[m]> Could we just use jl.Reflect?
[23:51:32] *** Joins: subbu (~subbu@user/subbu)
[23:58:54] <headius> for what
[23:59:17] <headius> the logic here is checking for a reified Ruby subclass so it can use the super stubs for dispatching properly to the superclass
[23:59:38] <headius> but it is also running for a Ruby method added to a normal Java subclass, which should just use normal Java dispatch to call super
