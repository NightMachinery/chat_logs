[00:00:11] <EvanR> which seems like a lot just to have an extra argument
[00:00:25] <EvanR> there's also reflection
[00:02:21] <ManofLetters[m]> dare I say "content"? for modders or just people making games using your engine? :P
[00:02:47] <f-a> reflection how
[00:02:51] <ManofLetters[m]> which translates to a reader, or yet another record field in game state, if you already have the record
[00:03:01] <f-a> yeah
[00:03:22] * ManofLetters[m] shudders at reflection
[00:03:49] <EvanR> before I consider what you're saying, I was thinking this data is separate from state
[00:03:58] <EvanR> since it's constant
[00:04:02] <f-a> then
[00:04:03] <f-a> uh
[00:04:04] <f-a> reader
[00:04:15] <f-a> or just pass it araound as first parameter
[00:04:20] <f-a> who has ever been bothered by it?
[00:04:30] <EvanR> that's what I'm wondering
[00:04:49] <EvanR> guess I'm not quite at a point where the extra parameter sucks
[00:05:04] <EvanR> ok so what about "content" ?
[00:05:14] <EvanR> never thought of modding xD
[00:06:47] <ManofLetters[m]> you are right it won't be modified during a game
[00:07:01] <ManofLetters[m]> so you just have to remember not to change it, if you put it in the state, for convenience
[00:07:24] <EvanR> urg....
[00:07:26] <ManofLetters[m]> it's "content" in the sense that it defines the rules, the look, the assets of the game
[00:07:50] <ManofLetters[m]> so if you have 4 games based on your engine (or 4 modes) they only differ in that one thing
[00:08:11] <f-a> ManofLetters[m]: I am not sure I understand, why put it in the state if I do not mod it?
[00:08:14] <f-a> seems unhaskelly
[00:08:22] <EvanR> it seems unorganized xD
[00:08:34] <f-a> s -> (a, s)   tells me “stuff will be modified under your porky feet”
[00:08:44] <EvanR> hopefully the amount of constants dwarfs the amount of state
[00:08:53] <f-a> state will grow big 
[00:09:00] <ManofLetters[m]> it's a compromise, less hassle than creating an enviroment just for that
[00:09:17] <f-a> is ManofLetters[m] the minimalist we need but do not deserve?
[00:09:40] <f-a> he made a game sans lens/microlens…
[00:10:14] <EvanR> yeah reflection seems powerful but for some reason scary
[00:11:09] <ManofLetters[m]> I have a few monads, with a few states and a few kinds of content applying to only some of the monads --- if I added readers into the mix, I'd go crazy, while adding one more field to a fiew states that already have  dozen or two dozens fields each is minimal noise
[00:11:28] <ManofLetters[m]> also, they actually do get modified --- at inintialization
[00:11:31] <ManofLetters[m]> which takes many steps
[00:11:44] <EvanR> yes that's why they're not just literal constants in the file
[00:11:50] <ManofLetters[m]> so it's easier to create a state with dummy content and update it in a later step
[00:11:54] <f-a> I might have lost you two: where does reflection happens?
[00:12:13] <EvanR> reflection is a possible way to "just pass another parameter"
[00:12:13] <f-a> am I mistaking it for reification?
[00:12:28] <f-a> isn’t the concretisation of a type?
[00:12:33] <f-a> and vice versa?
[00:12:38] * f-a checks his notes
[00:12:44] <ManofLetters[m]> nope, not that
[00:13:00] <EvanR> reflection in haskell is backwards
[00:13:00] <ManofLetters[m]> I mean, correct, but we don't mean this one
[00:13:09] <f-a> which one is it then :P
[00:13:21] <EvanR> reflection is a package name, that's mainly what I'm talking about
[00:13:26] <f-a> oh
[00:13:26] <EvanR> there's no reification package
[00:14:01] <f-a> «Reifies arbitrary terms into types that can be reflected back into terms»
[00:14:32] <EvanR> it lets you abuse the typeclass system to pass values
[00:15:01] <EvanR> like implicit parameters but not gross
[00:15:03] <f-a> mhhhh
[00:15:05] <EvanR> but then it's gross in another way
[00:19:05] *** Quits: coot_ (~coot@2a02:a310:e03f:8500:5cc8:47c:8ec0:b827) (Quit: coot_)
[00:24:32] * sm hasn't yet regretted passing extra argument(s)
[00:55:50] <EvanR> is it because the alternatives are that much worse? xD
[00:58:31] <sm> I guess so. If I'm using a framework with a Reader, that's fine. Should I add one myself ? I haven't seen much the advantage. Either way, there's a change in type signature. And I'd guess code navigation in IDEs works better with simple arguments (but I might be wrong on that)
[00:59:07] <EvanR> interesting angle
[00:59:51] <sm> ImplicitParams I'm even less sure about. Again, there's a change in type signature
[01:00:08] <EvanR> those look very intrusive, defeating the purpose
[01:00:21] <f-a> just unsafeperformio read them
[01:00:25] <EvanR> lol
[01:00:34] <f-a> then open a reddit thread with this new contravariant trick
[01:00:39] <f-a> 1k upvotes, 6 awards
[01:00:40] <sm> right! I actually do that sometimes :)
[01:00:59] <EvanR> unsafePerformIO (readFile "magic-file-dont-touch")
[01:01:00] <sm> hledger checks for color support and --debug flag that way
[01:07:47] <EvanR> I'm curious about the idea of "modding" and whether that interacts with functional programming in an amazing or horrible way
[01:08:05] <EvanR> like, every game is expected to be moddable, part of that is some sort of design decision from Unity
[01:08:34] <EvanR> but like no game naturally ends up moddable without forethought
[01:09:40] <sm> Defect Process author says he specifically chose to keep the scripting in haskell, and that worked for his case
[01:09:59] <sm> I don't see why functional programming would hurt it
[01:10:32] <f-a> you need to think about it before hand
[01:10:35] <f-a> I mean
[01:10:43] <f-a> I don’t see how that is not true in *any* language
[01:10:53] <EvanR> the part that is moddable at least has to be based on data and not code?
[01:10:58] <sm> slow compilation does, alright
[01:11:00] <sm> and whole-program compilation
[01:11:24] <EvanR> the "hardcoded" parts probably can't be modded
[01:11:35] <EvanR> in hasklel
[01:11:44] <f-a> hasklel, apt :P
[01:11:45] <EvanR> unlike java lol
[01:29:41] <ManofLetters[m]> the way I do it, I do forethought and put as much as possible into data, not code
[01:29:53] <ManofLetters[m]> and then put almost everything else into a library
[01:30:03] <ManofLetters[m]> with lots of small functions, all exposed
[01:30:16] <ManofLetters[m]> the modder uses as much of the library as he wants
[01:30:36] <ManofLetters[m]> in this way, everything is modable, with no tricks needed
[01:31:17] <ManofLetters[m]> and whole-program compilation is obtained via `-fexpose-all-unfoldings -fspecialise-aggressively -fsimpl-tick-factor=200`
[01:31:36] <ManofLetters[m]> and the fact that source is open
[01:32:47] <ManofLetters[m]> though I could ship all giantinc .hi files to the same effect, without opening the source
[01:34:24] <ManofLetters[m]> they are basically huge balls of all the Core, when using `-fexpose-all-unfoldings`
[01:38:49] <EvanR> ah modding by modifying the code and recompiling
[01:39:55] <ManofLetters[m]> almost, but in my case no, they don't modify the code of the library
[01:40:14] <ManofLetters[m]> they just assembled its functions a bit differently, substituting one or two
[01:40:23] <EvanR> interesting
[01:40:46] <ManofLetters[m]> and the assembling is done in a glue code, which is the only part that is not in the library, but in the exe, in the cabal package
[01:41:03] <ManofLetters[m]> and that's the only part that always needs to be copy-pasted by the modder (unless he changes only the content)
[01:41:15] <ManofLetters[m]> that's, like 1% of the whole codebase
[01:41:44] <EvanR> engine as a library
[01:41:57] <ManofLetters[m]> of course, once you change one function at the bottom in a big way, you need to change 20 others that call it ;)
[01:43:26] <ManofLetters[m]> and even if you change it in a tiny way, tweaking one constant, you still need to trivially tweak the 20 functions, to call the new function from the bottom, albeit in a completely the same way the old function was called
[01:43:53] <ManofLetters[m]> so it's not a convenient as modding through explicit hooks prepared for adding extra code
[01:44:24] <ManofLetters[m]> ECS usually does the hooks, because it's natural to add stuff to entities, etc.
[01:45:34] <ManofLetters[m]> it basically means you don't have 20 functions on top, but all the hooks are on top, so you only change the `main` function by adding the extrs hooks (or they can be read file in `main`)
[01:45:46] <ManofLetters[m]> *read from a file
[01:46:27] <ManofLetters[m]> but unless your game is simple (such as ECS stuff), it's realy hard to outguess the modder and knkow where the hooks are needed
[01:47:25] <ManofLetters[m]> and even in ECS, it may turn out the modder wants to change some internal details of visuals, not just add some particles to each blue orc, and the hooks don't suffice
[01:48:58] <ManofLetters[m]> and you are back to the hex editor
[01:49:25] <EvanR> which sounds hard to do with haskell
[01:49:58] <ManofLetters[m]> indeed :)
[01:50:13] <ManofLetters[m]> security guys have a really bad time cracking Haskell programs
[01:50:25] <ManofLetters[m]> and even on top of them not having buffer overflows
[01:50:29] <ManofLetters[m]> etc.
[01:50:35] <EvanR> some games have two levels of modding, one provides data to append or override the defaults, and the other is a DLL file that overrides code
[01:50:40] <ManofLetters[m]> but just due to the exotic memory layouts, GC moving stuff around, etc.
[01:51:07] <ManofLetters[m]> oh, yes, such DLL are cool
[01:51:17] <ManofLetters[m]> I wonder if we could hack this in Haskell
[01:51:24] <ManofLetters[m]> somewhere before the linking phase
[01:51:42] <ManofLetters[m]> then when you change a function (but not its type), you don't have to change those that call it
[01:51:43] <ManofLetters[m]> but
[01:51:44] <EvanR> haven't heard much about dynamic loading in haskell in a while but it used to be topic
[01:51:53] <ManofLetters[m]> in it inlines, it's impossible
[01:52:08] <ManofLetters[m]> even if it specializes, it's impossible
[01:52:26] <ManofLetters[m]> and good code is often polymorphic, so everything inlines
[01:52:33] <ManofLetters[m]> *specializes
[01:52:41] <ManofLetters[m]> but often inlines, too
[01:53:51] <EvanR> https://hackage.haskell.org/package/plugins
[01:54:46] <ManofLetters[m]> oh, nice, so if your code is monomorphic, that could work
[01:55:14] <ManofLetters[m]> e.g., if you need to work in the IO monad due to some tools that force that
[01:56:27] <EvanR> you think it couldn't work for polymorphic types?
[02:00:27] *** Joins: coot (~coot@89-64-85-93.dynamic.chello.pl)
[02:02:47] <ManofLetters[m]> it could, but it would be complex, because it would replace each specialization separately (and the non-specialized version, if still used, also separately)
[02:03:17] <ManofLetters[m]> but I may be wrong
[02:03:23] <EvanR> oof... I haven't though much about the API for such a thing
[02:03:35] <EvanR> whether it needs polymorphic types or not
[02:12:38] *** Quits: coot (~coot@89-64-85-93.dynamic.chello.pl) (Quit: coot)
[02:37:37] <sm> lua is the usual easy compromise for scripting
[02:37:43] <sm> alas :)
[02:38:08] <sm>  * alas
[02:38:53] <EvanR> would lua be easy in a haskell game?
[02:39:08] <f-a> 9> arrays start at 1
[02:39:18] <EvanR> I feel like that opens a whole nother can of worms xD
[02:39:48] <EvanR> (starting at 1 is not the end of the world)
[02:39:53] <sm> yes, it's the easiest to embed, pandoc uses it for this reason
[02:41:37] <f-a> use forth for nerd sniping
[02:41:48] <f-a> (for real lua is a great little language)
[02:42:03] <EvanR> lol
[02:42:19] <EvanR> forth, what could go wrong
[02:48:17] *** Quits: chomwitt (~chomwitt@2a02:587:dc1e:c100:12c3:7bff:fe6d:d374) (Remote host closed the connection)
[03:23:48] <EvanR> well I'm done
[03:24:43] <EvanR> ball bounces around, the magic numbers are now not magic, you can attempt to keep the ball from going "down the hole" for as long as you can stand it
[03:25:09] <EvanR> the blocks stay whatever they are as written in the level file
[03:25:48] <EvanR> events / occurrences / ads, such as "hit block i j" are generated by the game and no one doesn't anything with them
[03:26:48] <f-a> do $ cloc src/
[03:28:08] <EvanR> Haskell 26295
[03:28:59] <f-a> quite a lot
[03:29:04] <f-a> an enormous lot
[03:29:13] <f-a> are you very prolific or are those file duplicated?
[03:29:14] <EvanR> no idea where it gets that
[03:30:11] <sm> dang EvanR 
[03:30:21] <sm> you must have some libs checked out or something ?
[03:31:10] <f-a> ↑
[03:31:17] <f-a> or he writes really fast
[03:31:21] <f-a> 2,2and has a coke habit
[03:31:23] <EvanR> it says 134 files
[03:31:32] <f-a> !!
[03:31:33] <EvanR> thats... not a thing
[03:31:50] <EvanR> I do have to tidy up this source but 
[03:32:51] <EvanR> maybe the git repo
[03:38:55] <EvanR> 18 files, 2193 lines of code, this sounds more reasonable
[03:39:40] <EvanR> which includes not just arkanoid, but a basic command line screen, a memory "game" where you click to reveal tiles, and the audio mixer
[03:41:25] <EvanR> 5 simple shaders
[03:42:30] <f-a> nice
[04:07:06] <EvanR> in factorio everyone has internalized this idea that the game updates at a nominal rate of 60 'ticks' per second, for some reason. Everything is based on that
[04:07:38] <EvanR> but if you ask someone from VR about that, they will be like 60 FPS is nowhere near enough for VR
[04:07:50] <EvanR> maybe it's two different things
[04:08:03] <f-a> what is the standard for vr
[04:08:10] <EvanR> as high of FPS as you can get
[04:08:26] <EvanR> 60 would cause motion sickness, I'm told
[04:09:23] <f-a> there has to be an upper limit
[04:09:38] <EvanR> yes whatever the refresh rate of the video display
[04:09:58] <f-a> how about the refresh rate of our eyes
[04:09:59] <EvanR> in VR is higher than 60, maybe 120 or 240
[04:12:09] <EvanR> and a time resolution finer than that is necessary in audio
[04:12:36] <EvanR> if you're trying to arrange sythnesizers
[04:13:06] <EvanR> so I'm like, if 60 is not god, what is
[04:14:08] <EvanR> part of me wants to react like, obviously we want conal's continuous time or something xD
[04:19:45] <EvanR> I disabled vsync and the action is much smoother
[04:20:52] <EvanR> but causes the program to be 100% cpu and for some reason systemd to be 90% as well
[04:21:09] <EvanR> and most of those frames are useless and never seen
[04:30:03] <EvanR> I'm wrong I get some annoying frame jumps sometimes regardless
[05:29:23] <EvanR> dang with no vsync the gc runs *a lot* and only copies like a few 100 bytes each time
[05:30:30] <EvanR> until what I'm guessing is a major gc and live data bottoms out
[05:30:33] <ManofLetters[m]> which gc?
[05:40:19] <EvanR> default
[07:18:12] *** Quits: terrorjack (~terrorjac@2a01:4f8:1c1e:509a::1) (Quit: The Lounge - https://thelounge.chat)
[07:19:33] *** Joins: terrorjack (~terrorjac@2a01:4f8:1c1e:509a::1)
[08:17:37] *** Quits: curiousgay (~curiousga@77-120-141-90.kha.volia.net) (Ping timeout: 240 seconds)
[10:54:46] <ManofLetters[m]> I wonder how the non-copying one would behave (or even the compacting one); you'd want 9.2.1 for best effects
[10:54:56] <ManofLetters[m]> also, there are some parameters to tweak
[11:03:22] <EvanR> which parameters
[11:19:43] <ManofLetters[m]> +RTS ones
[11:20:29] <ManofLetters[m]> e.g., I have `ghc-options:        "-with-rtsopts=-A99m -I5"` in my .cabal file
[11:21:02] <ManofLetters[m]> (the latter not useful for a not turn-based game)
[11:21:15] <ManofLetters[m]> (the former possibly not so, either, but there are others)
[11:21:39] <ManofLetters[m]> and you need `ghc-options:        -rtsopts` for that to work
[11:23:23] <EvanR> got it, saw a bunch of gc tweaks in the rts docs but didn't know what would help
[11:24:31] <ManofLetters[m]> that's a dark art and depend on which gc you choose
[11:29:15] <EvanR> to make it semi-science I guess you'd need like 10,000 gamer's PCs to see what happens
[11:46:25] <EvanR> -B         Sound the bell at the start of each garbage collection
[11:54:35] <ManofLetters[m]> that's how one does sound effects cheaply
[12:43:38] *** Joins: coot (~coot@89-64-85-93.dynamic.chello.pl)
[12:44:01] <icrbow[m]> <EvanR> "-B         Sound the bell at the..." <- Jingle bells jingle bells
[12:44:01] <icrbow[m]> Garbage all the way
[12:44:01] <icrbow[m]> Ah what fun it is to stop
[12:44:01] <icrbow[m]> The world and compact
[12:44:41] *** Quits: coot (~coot@89-64-85-93.dynamic.chello.pl) (Client Quit)
[12:44:56] *** Joins: coot (~coot@89-64-85-93.dynamic.chello.pl)
[12:45:44] <ManofLetters[m]> ;D
[13:02:28] *** Quits: coot (~coot@89-64-85-93.dynamic.chello.pl) (Quit: coot)
[13:32:46] *** Quits: tzh (~tzh@c-24-21-73-154.hsd1.or.comcast.net) (Quit: zzz)
[14:32:43] *** Joins: __monty__ (~toonn@user/toonn)
[17:08:06] *** Joins: curiousgay (~curiousga@77-120-141-90.kha.volia.net)
[17:14:17] *** Joins: coot (~coot@89-64-85-93.dynamic.chello.pl)
[18:20:16] *** Quits: coot (~coot@89-64-85-93.dynamic.chello.pl) (Quit: coot)
[19:00:34] *** Quits: curiousgay (~curiousga@77-120-141-90.kha.volia.net) (Ping timeout: 260 seconds)
[19:28:56] *** Quits: szkl (uid110435@id-110435.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[22:03:04] *** Joins: tzh (~tzh@c-24-21-73-154.hsd1.or.comcast.net)
