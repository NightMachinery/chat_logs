[00:18:11] *** Joins: lisp123 (~lisp123@5.30.23.247)
[00:26:42] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 260 seconds)
[00:39:07] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 268 seconds)
[00:41:01] *** Joins: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se)
[01:05:26] *** Quits: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca) (Ping timeout: 260 seconds)
[01:07:07] *** Quits: shka (~herr@109.231.62.239) (Ping timeout: 265 seconds)
[01:26:08] *** Quits: fengshaun (~fengshaun@S010680615f0c2c0a.cg.shawcable.net) (Quit: bibi!)
[01:32:54] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[01:34:24] *** Joins: lisp123 (~lisp123@5.30.23.247)
[01:43:05] *** Joins: fengshaun (~fengshaun@S010680615f0c2c0a.cg.shawcable.net)
[01:47:21] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 268 seconds)
[01:55:32] *** Quits: fiddlerwoaroof (~fiddlerwo@user/fiddlerwoaroof) (Ping timeout: 245 seconds)
[01:57:02] *** Joins: fiddlerwoaroof (~fiddlerwo@user/fiddlerwoaroof)
[02:02:10] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[02:20:17] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
[02:47:49] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[03:14:52] *** Quits: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Quit: WeeChat 2.8)
[03:15:07] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
[03:18:48] *** Quits: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Client Quit)
[03:19:05] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
[03:21:24] *** Quits: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Client Quit)
[03:21:41] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
[03:24:47] *** Quits: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Client Quit)
[03:25:09] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
[03:44:29] *** Joins: lisp123 (~lisp123@5.30.23.247)
[03:49:55] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[04:16:33] *** Quits: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net) (Quit: Leaving)
[04:16:46] *** Joins: Oladon (~olad@98.43.81.226)
[04:35:02] *** Joins: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net)
[05:23:03] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[05:36:18] *** Quits: lottaquestions_ (~nick@2607:fa49:503f:6400:7dd7:d517:44dd:3f44) (Quit: Konversation terminated!)
[05:39:14] *** Quits: random-nick (~random-ni@87.116.183.203) (Ping timeout: 265 seconds)
[05:47:34] *** Joins: lisp123 (~lisp123@5.30.23.247)
[05:49:25] *** Joins: selwyn (~selwyn@user/selwyn)
[05:58:07] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[06:02:26] *** Quits: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se) (Ping timeout: 265 seconds)
[06:29:47] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[06:38:49] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[06:45:56] *** Quits: sts-q (~sts-q@212.53.219.241) (Ping timeout: 265 seconds)
[06:56:40] *** Joins: sts-q (~sts-q@212.53.219.235)
[07:05:05] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[07:08:39] *** Quits: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 265 seconds)
[07:57:48] *** Joins: lisp123 (~lisp123@5.30.23.247)
[07:58:14] *** Quits: CptJimKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Quit: Client closed)
[07:59:03] *** Joins: CptKirk92 (~CptKirk@97-118-72-33.hlrn.qwest.net)
[08:00:07] *** CptKirk92 is now known as CptJimKirk
[08:03:45] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[08:24:34] *** Quits: lotuseater (~user@p200300e7870566004b01295534bb48e2.dip0.t-ipconnect.de) (Ping timeout: 260 seconds)
[09:00:19] *** Joins: shka (~herr@109.231.62.239)
[10:13:18] *** Quits: shka (~herr@109.231.62.239) (Quit: Konversation terminated!)
[10:15:41] *** Joins: lisp123 (~lisp123@5.30.23.247)
[10:59:17] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[10:59:30] *** Joins: lisp123 (~lisp123@5.30.23.247)
[11:09:34] *** Joins: selwyn (~selwyn@user/selwyn)
[11:19:29] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[11:20:08] *** Joins: lisp123 (~lisp123@5.30.23.247)
[11:20:52] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[11:21:04] *** Quits: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Ping timeout: 268 seconds)
[11:21:04] *** Joins: lisp123 (~lisp123@5.30.23.247)
[11:21:06] *** Quits: CptJimKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Ping timeout: 256 seconds)
[12:24:08] *** Joins: rain3 (~rain3___@86.127.200.187)
[12:27:22] <lisp123> Hi, a question for today
[12:28:20] <lisp123> I am trying to call a macro (my-defun name ...) by doing something like this (my-defun (make-symbol (symbol-name function-obj)) ...) but I get an error
[12:30:25] <lisp123> Actually never mind, I know my issue :)
[12:35:30] *** Joins: hendursa1 (~weechat@user/hendursaga)
[12:37:32] <White_Flame> in any case "but I get an error" is always a useless problem description unless you actually say what the error is ;)
[12:38:17] <lisp123> White_Flame: lol :)
[12:38:24] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[12:39:54] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[12:40:59] <beach> Yes, and "but it doesn't work" is another common one.
[12:41:17] *** Joins: selwyn (~selwyn@user/selwyn)
[12:41:18] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[12:49:04] <lisp123> It is an error to use function on a function name that does not denote a function in the lexical environment in which the function form appears. Specifically, it is an error to use function on a symbol that denotes a macro or special form. An implementation may choose not to signal this error for performance reasons, but implementations are forbidden from defining the failure to signal an error as a useful behavior.
[12:49:33] <lisp123> Was there a reason for the above? It seems like it prevents me from doing (defun test (a) (function a))
[12:50:37] <White_Flame> what would you want that to do?  A is not found from the function namespace there
[12:51:11] <lisp123> I wanted to be able to do (test +) and get #<FUNCTION +>
[12:51:27] <White_Flame> maybe you mean (defun test (a) (declare (function a)) ...) declaring that the A variable contains a function object?
[12:51:46] <White_Flame> that would be (symbol-function +), but only for toplevel functions, not lexical ones
[12:51:55] <White_Flame> (symbol-function '+)
[12:52:35] <White_Flame> eg if you have (labels ((foo ...)) ...) you can't do anything with the symbol FOO and track back to that labels function.  It has to be rooted from #'FOO from within that lexical scope
[12:53:29] <White_Flame> at compile time
[12:54:14] <lisp123> (defun test (a)  (declare (function a))  (function a))
[12:54:16] <lisp123> White_Flame: Hmm, I tried the following but got undefined function a: 
[12:54:32] <White_Flame> right, (function a) won't find anything there
[12:54:46] <White_Flame> there's no A in the function namespace to point at
[12:54:52] <White_Flame> only an A in the variable namespace
[12:55:35] <beach> lisp123: To obtain the function that is the value of the variable A, you just say A.
[12:55:39] <White_Flame> but if you expect the value of A to be a symbol, then you need to declare that, and then do symbol-function to extract the function object that a DEFUN or so has defined for it
[12:56:08] <beach> Right.
[12:58:47] <lisp123> Thanks! That worked --> (defun test (a) (declare (symbol a)) (symbol-function a))
[12:58:48] <White_Flame> the point is to turn a symbol into a DEFUN-given function object behind it, right?
[12:59:08] <White_Flame> of course, you don't need that declaration; symbol-function will typecheck it for you
[12:59:17] <White_Flame> I just didn't know what you were trying to do
[12:59:31] <lisp123> I am experimenting with different ideas, basically I want to recreate a function via function-lambda-expression, which does not store the function name
[12:59:40] <lisp123> (it just calls it 'lambda')
[13:01:24] <lisp123> So there is a lot of problems with my code, so I am a bit all over the place :) But I'm nearly there..
[13:08:55] *** Joins: selwyn (~selwyn@user/selwyn)
[13:22:47] <mfiano> lisp123: I would use fdefinition
[13:29:09] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[13:29:51] *** Joins: lisp123 (~lisp123@5.30.23.247)
[13:33:30] <pjb> lisp123: (defun test (fname) (case fname ((+) (function +)) ((-) (function -)) (otherwise (error "unknown function name"))))
[13:33:49] <pjb> lisp123: (defun test (fname) (fdefinition fname))  but then, why not use just (fdefinition fname)?
[13:34:23] <pjb> lisp123: note, the case version is recommended, when fname comes from "outside", and you want to restrict the functions that can be used.
[13:34:50] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[13:35:18] <pjb> lisp123: also note: (defun foo () 'outer) (mapcar 'funcall (flet ((foo () 'inner)) (list (function foo) (fdefinition 'foo)))) #| --> (inner outer) |# 
[13:36:25] <pjb> lisp123: (defun test (a) (declare (symbol a)) (symbol-function a)) is really bad, because if you do (test 42), then you might get a crash, like in C.
[13:36:41] <pjb> lisp123: instead write:   (defun test (a) (check-type a symbol) (symbol-function a))
[13:37:38] <pjb> lisp123: function-lambda-expression may return nil any or all the time.
[13:37:51] <pjb> lisp123: have a look at Image Based Development http://www.informatimago.com/develop/lisp/com/informatimago/small-cl-pgms/ibcl/index.html
[13:38:10] <pjb> you just cannot rely on function-lambda-expression.
[13:52:56] *** Joins: lisp123 (~lisp123@5.30.23.247)
[13:54:21] <lisp123> mfiano: Thanks
[13:55:50] <beach> pjb: I doubt that lisp123 saw what you wrote.
[13:56:01] <beach> And the channel is not logged.
[13:56:10] <pjb> Oh, he was disconnected.
[13:56:11] <lisp123> beach: No I didn't, thanks for bringing it up
[13:56:29] <pjb> lisp123: https://termbin.com/arnu
[13:56:31] <lisp123> Yes, sorry, my connection keeps going :(
[14:00:28] <lisp123> pjb: IBCL is great! Going to use it
[14:00:42] <lisp123> Is it portable across implementations?
[14:00:56] <pjb> It should be.
[14:01:09] <pjb> But it's just a proof of concept, it would need more work.
[14:01:25] <lisp123> Was a bit annoyed that function-lambda-expression is unreliable, like it seems like a pretty useful thing to have..
[14:01:43] <pjb> lisp123: also, it may be preferable to provide a patch to the various implementations to implement it inside each implementations.
[14:01:44] <lisp123> I will add into my package, will let you know if I find any edge cases
[14:02:03] <pjb> as an extension. 
[14:03:04] <lisp123> That would be good. I think its a pretty core function - how else to simply read functions and then modify them with macros!
[14:03:39] <pjb> Most implementations already implement half the functionality, for example, to be able to report compiler errors, and just to source position (M-. in slime).  So it could as well be implemented entirely with a common API.
[14:04:00] <pjb> s/just/jump/
[14:04:36] <lisp123> That would be good
[14:09:35] <lisp123> pjb: We use :function for both functions and macros yes?
[14:09:51] <lisp123> Seems to be the case
[14:27:00] *** Joins: lotuseater (~user@p200300e7870566004b01295534bb48e2.dip0.t-ipconnect.de)
[14:29:54] <pjb> Indeed, they're bound in the same namespace.
[14:37:37] <lotuseater> hello :) what's the current topic?
[14:44:50] <lisp123> Hey lotuseater :)
[14:44:52] <lisp123> http://www.informatimago.com/develop/lisp/com/informatimago/small-cl-pgms/ibcl/index.html
[14:45:33] <lisp123> For greater access to function / macro definitions. Now I'm in the process of implementing it (initially we were discussing function-lambda-expression & associated items)
[14:49:56] <lotuseater> ok
[15:02:01] <pjb> lisp123: you may also want to explore Interlisp Medley. cf #interlisp
[15:02:18] <pjb> lisp123: https://interlisp.org
[15:04:25] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[15:07:54] <lisp123> pjb: Thanks, looks interesting
[15:12:35] <edgar-rft> CL has bit-vectors for people who are more than a bit annoyed :-)
[15:19:20] *** Joins: random-nick (~random-ni@87.116.180.139)
[15:23:06] <pjb> And even better than bit-vectors: bit arrays!  (make-array '(4 4) :element-type 'bit :initial-contents #(#*1111 #*1001 #*1001 #*1111)) #| --> #2A(#*1111 #*1001 #*1001 #*1111) |# 
[15:55:06] <lisp123> Another question for today :)
[15:55:07] <lisp123> https://plaster.tymoon.eu/view/2636#2636
[15:55:49] <lisp123> I am trying to wrap macros stored within a list within lambda expressions to be able to funcall them
[15:56:05] <lisp123> But it seems like lexical scope does not extend to lambda expressions?
[15:56:28] <beach> This code won't work because (fn a b) will refer to a FN in the function namespace, but your FN is in the variable namespace.
[15:56:54] <beach> Scoping is not related to expressions, only to names.
[15:57:14] <beach> In you code you could do (funcall fn 3 3)
[15:57:28] <lisp123> beach: Thanks
[15:57:37] <lisp123> Issue is that fn is a macro in the real code
[15:57:55] <lisp123> So I am wrapping it within a lambda expression to be able to funcall it
[15:57:59] <beach> Macros are not first-class objects, so you can't put them in a list.
[15:58:14] <beach> You can put macro functions in a list, but not macros.
[15:58:58] <lisp123> Is it possible to funcall a macro-function?
[15:59:04] <beach> Sure.
[15:59:10] <lisp123> Great, let me try it out
[15:59:15] <beach> It takes two arguments, a form and an environment.
[15:59:21] <beach> The environment can be NIL.
[15:59:50] <beach> Try, say (funcall (macro-function 'when) '(when x y) nil).
[16:01:46] <lisp123> That returns (IF X Y), is there a way to evaluate it?
[16:02:30] <lisp123> Simple eval seems to do the trick?
[16:02:57] <beach> EVAL, but that works only in the null lexical environment.  Usually, the compiler replaces the macro call by the value returned by the macro function and compiles it again, so that's not a problem.  That's how macros are supposed to be used.
[16:03:43] <beach> So if the arguments (X and Y in my example) refer to lexical variables, you are out of luck.
[16:04:06] <lisp123> :(
[16:04:09] <beach> Macro functions take forms and return forms. 
[16:06:21] <beach> I am not sure what you are trying to do.
[16:06:22] <lisp123> What if I did (eval `(',macro-name ,parameters)) instead of funcall? Would that be a suitable alternative to being able to "funcall" macros?
[16:06:45] <lisp123> I wrote an automatic logging tool that redefines all functions as macros to then log results
[16:07:07] <beach> Why not redefine them as functions?
[16:08:19] <beach> Let me see if I can come up with an example...
[16:08:32] <lisp123> Potentially..can the default value of optional values be evaluated at each function call?
[16:08:50] <lisp123> e.g. (defun my-fn (&optional (counter *counter*))
[16:08:55] <pjb> lisp123: this most probably wouldn't work because the macro would not be expanded in the lexical environment!
[16:09:25] <pjb> lisp123: (let ((x 0)) (when (zerop x) (incf x))) #| --> 1 |#   (let ((x 0)) (eval '(when (zerop x) (incf x)))) #| ERROR: Unbound variable: x |# 
[16:10:13] <pjb> lisp123: write you library so that it exports a set of functions, and a set of macro that call those functions. Then you can have both.
[16:10:52] <pjb> lisp123: (and 1 2 3) is a macro. (every 'identity '(1 2 3)) is a function  (values  (and 1 2 3) (every 'identity '(1 2 3))  (funcall 'every 'identity '(1 2 3))) #| --> 3 ; t ; t |# 
[16:11:13] <pjb> lisp123: it is.
[16:11:27] <beach> (defun wrap (name) (let ((existing (fdefinition name))) (setf (fdefinition name) (lambda (&rest arguments) (let ((results (multiple-value-list (apply existing arguments)))) (log arguments results)) (apply #'values results)))))
[16:11:31] <beach> Something like that.
[16:11:49] <pjb> (defvar *counter* 0) (defun my-fn (&optional (counter (incf *counter*))) counter) (list (my-fn) (my-fn) (my-fn) (my-fn)) #| --> (1 2 3 4) |# 
[16:14:02] <lisp123> Thanks beach & pjb, will work through these examples now
[16:18:42] <beach> http://metamodular.com/to-delete.lisp
[16:19:28] <beach> lisp123: LOG-IT is the function for logging.  WRAP is the function for wrapping a function in logging code.  
[16:19:40] <beach> Evaluate each form separately.
[16:20:37] <beach> You might also want an UNWRAP function, though.  For that, you need to keep the existing definition in a hash table rather than in a lexical variable. 
[16:21:42] <lisp123> Beach: Thanks, that's a very nice way of doing it
[16:21:59] <beach> Thanks!  And no macros!
[16:22:17] <beach> This technique can be used for other things like memoization. 
[16:22:53] <beach> Oops, typo: (wrap 'foo) not (wrap 'oo)
[16:23:25] <lisp123> Its very helpful, until now I was narrow-minded into thinking I had to use a macro if I wanted to transform a function
[16:24:02] <beach> I see.  Now you know! :)
[16:25:19] <pjb> lisp123 you can write all kind of function making functions from functions. https://dl.acm.org/doi/pdf/10.1145/359576.359579
[16:25:35] <lisp123> Okay, back to the drawing board :) I got 90% of the way with my autologger, hopefully if I can transform it into this form, then I'm done!
[16:25:57] <pjb> lisp123: eg. (defun swap-args (binary-fun) (lambda (a b) (funcall binary-fun b a)))   (funcall (swap-args #'-) 1 3) #| --> 2 |# 
[16:26:20] <lisp123> (a sneak-peak: https://plaster.tymoon.eu/view/2637#2637)
[16:26:58] <pjb> lisp123: with a collection of such function, you can write whole programs in *functional* style, ie. by writing expressions at the level of functions, instead of dealing with mere variables holding data elements.
[16:27:07] <pjb> see the Backus' paper.
[16:28:01] <lisp123> pjb: Thanks for the link, will read today
[16:28:21] <lisp123> Very happy to have learnt a new trick, this one is going to prove very handy in many places :) Thanks!
[16:30:49] <pjb> lisp123: in general, you NEVER want to use eval.
[16:31:01] <pjb> lisp123: EVAL is made to write REPL. That's all.
[16:31:44] <pjb> lisp123: there's one case where eval can be used, is with defclass, to redefine a class at run-time.  You will admit this is a very rare occurence (and it's similar to a REPL, since you're changing the program at run-time).
[16:32:09] <pjb> lisp123: and even, you could use the MOP instead.
[16:32:19] <pjb> lisp123: so for now, just forget about EVAL.
[16:32:25] <lisp123> pjb: What about this: (ibcl:defun log (name) (let ((fn-list (ibcl:source name :function))) (eval `(defun ,(second fn-list) ,(third fn-list) ,@(nthcdr 3 fn-list)))))
[16:32:57] <pjb> this makes your function log return (second fn-list) !
[16:34:03] <lisp123> So here I created a logging function (defun) through a macro, but now I will try to re-do this as a function per beach's example
[16:34:41] <pjb> what's the purpose of this log function?
[16:35:00] <lisp123> You define a function somewhere else
[16:35:14] <lisp123> And then pass it into 'log' to generate an autologging version
[16:35:29] <pjb> So you just want to do (trace foo).
[16:35:33] <lisp123> Which I will re-do using beach's 'wrap' function, which achieves the same version
[16:35:59] <pjb> What's wrong with (trace foo)?
[16:36:01] <lisp123> I save quite a bit of information (https://plaster.tymoon.eu/view/2637#2637))
[16:36:05] <pjb> Ok.
[16:36:30] <lisp123> But my question is, should I avoid eval and use similar function transformations every time I am faced with suhc a situation?
[16:36:36] <lisp123> I will link you to an SO post
[16:37:25] <lisp123> https://stackoverflow.com/a/4052618
[16:37:55] <lisp123> Here they say to use eval for macros that will be evaluated after compilation --> Is it better to rethink the problem in those cases?
[16:39:57] *** Quits: rain3 (~rain3___@86.127.200.187) (Ping timeout: 265 seconds)
[16:43:40] <pjb> lisp123: you can do something like: https://termbin.com/f34o
[16:44:43] <pjb> Yes, for after compilation, provide functions.
[16:47:33] <lisp123> Great thanks, I will avoid eval now completely!
[16:47:42] <lisp123> (for the next year at least)
[16:53:33] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[16:57:09] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 268 seconds)
[17:03:47] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[17:04:23] *** Joins: lisp123 (~lisp123@5.30.23.247)
[17:09:13] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[17:17:11] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[17:28:40] *** Joins: lisp123 (~lisp123@5.30.23.247)
[17:31:30] *** Joins: rain3 (~rain3___@86.127.200.187)
[17:38:54] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[17:39:28] *** Joins: lisp123 (~lisp123@5.30.23.247)
[17:44:19] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[18:00:49] *** Quits: hendursa1 (~weechat@user/hendursaga) (Quit: hendursa1)
[18:08:03] *** Joins: hendursaga (~weechat@user/hendursaga)
[18:18:36] *** Joins: lisp123 (~lisp123@5.30.23.247)
[18:31:01] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[18:34:59] *** Quits: lotuseater (~user@p200300e7870566004b01295534bb48e2.dip0.t-ipconnect.de) (Ping timeout: 268 seconds)
[18:48:04] <mfiano> eval is very useful in compiler macros.
[18:48:19] <mfiano> It is a code smell in other places in my opinion.
[19:04:59] *** Joins: lisp123 (~lisp123@5.30.23.247)
[19:06:14] *** Joins: ln43 (~ln43@user/ln43)
[19:07:15] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[19:09:47] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[19:10:02] *** Joins: lisp123 (~lisp123@5.30.23.247)
[19:14:39] *** Quits: ln43 (~ln43@user/ln43) (Quit: Connection closed)
[19:31:18] *** Joins: thrig (~thrig@70.97.65.251)
[20:17:18] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[20:18:28] *** Joins: hendursaga (~weechat@user/hendursaga)
[20:29:41] *** Quits: thrig (~thrig@70.97.65.251) (Remote host closed the connection)
[20:36:43] *** Joins: thrig (~thrig@65.113.153.50)
[20:45:55] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 252 seconds)
[20:47:38] *** Joins: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se)
[21:03:40] *** Joins: selwyn (~selwyn@user/selwyn)
[21:04:24] *** Quits: selwyn (~selwyn@user/selwyn) (Remote host closed the connection)
[21:04:49] *** Joins: selwyn (~selwyn@user/selwyn)
[21:08:32] *** Joins: lisp123_ (~lisp123@45.130.83.212)
[21:11:55] *** Joins: lisp123__ (~lisp123@5.30.23.247)
[21:12:19] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[21:14:58] *** Quits: lisp123_ (~lisp123@45.130.83.212) (Ping timeout: 252 seconds)
[21:18:25] *** Joins: rotateq (~user@p200300e787056600859d17a8b44a5685.dip0.t-ipconnect.de)
[21:52:30] *** Joins: selwyn_ (~selwyn@user/selwyn)
[21:52:55] *** Quits: selwyn (~selwyn@user/selwyn) (Ping timeout: 252 seconds)
[23:03:50] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
[23:04:22] *** Quits: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Client Quit)
[23:18:39] *** Quits: rain3 (~rain3___@86.127.200.187) (Ping timeout: 268 seconds)
[23:21:57] *** Quits: Partmedia (~kevinz@172-221-159-029.res.spectrum.com) (Quit: Partmedia)
[23:22:18] *** Joins: Partmedia (~kevinz@172-221-159-029.res.spectrum.com)
[23:30:40] *** Quits: thrig (~thrig@65.113.153.50) (Remote host closed the connection)
[23:32:59] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
