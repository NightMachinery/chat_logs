[00:04:48] *** Joins: ublx (~ublx@user/ublx)
[00:13:38] <zilti[m]> Bunny351: Well in Clojure, not only are there multiple implementations for hashmaps behind the scenes, records also are explicitly not hashtables. They just happen to implement the same interface for accessing them.
[00:33:16] <jcowan> Bunny351: We simply aren't speaking the same language (which is unsurprising).
[00:42:23] *** Joins: crumpo (~crumpo@user/crumpo)
[00:45:29] <Bunny351> zilti: I was refering to "records" as abstract, what I mean is that maps are used as a generalized meta-type, in place of where record types (like structs in scheme or lisp) could normally be used.
[00:51:27] <Bunny351> I guess clojure has these kinds of data types, but it seems to me idiomatic code appears to prefer maps plus some elaborate meta typing machinery (specs)
[01:08:25] <siiky> sjamaan: yeah, giving (open-input-string "") instead of a path works! now I have the primitives all set!
[01:52:57] *** Quits: crumpo (~crumpo@user/crumpo) (Quit: Buh bye)
[02:14:56] <zilti[m]> Bunny351: but isn't that basically the same in scheme? At least I use quite a lot of alists
[02:16:47] <Zipheir> I hope big alists are idiomatic for most Schemers...
[02:16:53] <Zipheir> *aren't!
[02:26:32] <zilti[m]> https://gitea.lyrion.ch/zilti/edn/src/branch/master/edn-impl.scm#L163 Fight me.
[02:28:21] <jcroisant> Depends what you call "big". alists can be faster than hash tables, up to a certain size. Like, a few hundred entries.
[02:30:22] <jcroisant> It varies with the use case, hashing function, etc., of course
[02:31:01] <Zipheir> Trees!  There are only a zillion varieties of them, well explored in the literature.
[02:31:29] <Zipheir> Also, https://wiki.call-cc.org/eggref/5/srfi-101
[02:32:25] <Zipheir> zilti[m]: Sure.  O(12) (or whatever) = O(1), provided that bound is known.
[02:35:18] <jcroisant> Sure, I could implement one of the zillion tree structures, or add a dependency for another library. Or I could just use an alist and move on with my life because it's plenty fast enough :)
[02:35:50] <Zipheir> This is why I would like better data structure libraries.
[02:36:25] <Zipheir> Or, at least see the ones we do have used more often.
[02:38:40] <Zipheir> e.g. the srfi-146 and llrb-tree eggs provide R-B trees, my integer-map egg provides radix trees, and I'm sure there are many others.
[02:39:58] <Zipheir> Most things in R5RS Scheme entail library dependencies, in any case.
[02:40:18] *** Quits: rgherdt (~rgherdt@83.236.18.121) (Remote host closed the connection)
[02:41:00] <jcroisant> Also, most tree structures (that I'm aware of, anyway) wouldn't be good for keys that are, say, symbols. Or procedures, like in zilti[m]'s case.
[02:45:01] <Zipheir> In what way?
[02:53:33] <jcroisant> They are not orderable, so a binary search tree is not helpful. And they can't be broken down into prefixes, so a radix tree is not helpful.
[02:55:36] <Zipheir> Hmm, procedures, certainly.  Symbols have an ordering, though.
[02:56:28] <Zipheir> I do seem to remember jcowan opining that symbols in data structures were not wonderful for GC-related reasons.
[02:59:33] <jcroisant> Strings have an ordering, symbols don't. Unless you want to convert the symbol to a string every time you compare them, in which case you're probably not going to see any performance benefit from using a tree instead of something else.
[03:01:34] <jcowan> I don't remember what I had in mind, but I agree with jcroisant.  Symbols *do* have an ordering in CL, though.
[03:03:37] <Zipheir> True.  symbol->string is usually a pretty cheap conversion, but yes--why not just use strings, if you need an ordering.
[03:04:17] <jcowan> There is nothing wrong with symbols as values, of course
[03:05:17] <jcroisant> Anyway, the point is that alists *are* idiomatic Scheme, and also often quite performant in practice. Not for very large data sets, but there are many cases where they are a good choice.
[03:07:50] <jcroisant> Of course, there are also times where a tree or a hash table or a vector or <insert data structure> is a better choice
[03:09:11] <Zipheir> Yes, for small, constant maps I'd use them.
[03:20:11] *** Joins: s-liao (~s-liao@101.86.96.21)
[03:47:31] *** Joins: klovett (~klovett@107.127.17.177)
[03:48:17] *** Quits: klovett_ (~klovett@107.127.17.177) (Ping timeout: 240 seconds)
[03:54:42] <ASau> Bunny351: that type is attribute of expression and not value, is the very hard to explain. Especially to people spoiled by Perl.
[03:57:16] <ASau> The original point of type system is to provide a way to catch mistakes like taking logarithm of string or indexing a number well before running program.
[03:58:58] <ASau> If you are fine with analogies to XML, it is similar to distinction between "well-formed" and "valid".
[04:01:10] <ASau> That data are correct is yet another story, but validation step lets you catch somewhat less than obvious mistakes without feeding input to interpreting program.
[04:18:13] *** Quits: ublx (~ublx@user/ublx) (Quit: ublx)
[04:36:33] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[04:39:47] *** Joins: s-liao (~s-liao@101.86.96.21)
[04:40:44] <Zipheir> "Types are to computation what fiber is to food: they make the topic digestable." (Simon Thompson?)
[04:58:35] <ASau> Zipheir: I have understood what this style of conversation reminds me.
[04:59:01] <ASau> That Cole Porter's musical... (What's it name, dammit?)
[05:00:18] <ASau> We need some help of old-timer from USA, since its their culture.
[05:00:47] <ASau> jcowan: do you remember the title of that musical revolving around "Taming of Shrew"?
[05:01:43] <ASau> Alright, not that relevant.
[05:05:52] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[05:06:53] *** Joins: s-liao (~s-liao@101.86.96.21)
[05:18:09] <Zipheir> Kiss Me Kate?
[05:19:09] <Zipheir> IRC debates usually remind me of the Who's On First skit.
[05:25:31] <ASau> Yeah, that's it!
[05:28:56] <ASau> To a person coming from a culture not built on Shakespeare a lot of punch lines sound somewhat strange, since it is unclear if it is yet another sudden reference to some nearly unknown piece or "own invention".
[05:31:30] <ASau> (Reminds me, that I wanted to tell my German colleagues the joke about that waltz with "something about a bar".)
[05:49:52] <ASau> Zipheir: the search result on youtube suggests that it is not universal even across English.
[06:55:25] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[07:15:46] *** Joins: s-liao (~s-liao@101.86.96.21)
[07:15:47] *** Quits: sts-q (~sts-q@212.53.219.200) (Ping timeout: 256 seconds)
[07:16:41] *** Joins: sts-q (~sts-q@212.53.219.183)
[08:10:51] *** Quits: keyehzh (~keyehzh@user/keyehzh) (Remote host closed the connection)
[08:23:04] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[08:40:08] *** Quits: Rue (~rue@2001-b011-1000-17d9-d616-1cce-b758-6ab8.dynamic-ip6.hinet.net) (Quit: WeeChat 3.4)
[08:41:52] *** Quits: skapata (~Skapata@user/skapata) (Read error: Connection reset by peer)
[08:53:19] *** Joins: Rue (~rue@2001-b011-1000-17d9-d616-1cce-b758-6ab8.dynamic-ip6.hinet.net)
[10:02:12] <zilti[m]> jcroisant: sure, but my point was not necessarily alist vs other data structures, but using informal mixed-type collections instead of defining records.
[10:02:12] <zilti[m]> In Scheme, at least unless using that SRFI that provides universal accessors, using records can be somewhat enforced at least, but in the end it is still a matter of discipline if you use records vs e.g. hashmaps.
[10:02:12] <zilti[m]> In Clojure, since it  the principle of "it is better to have 100 functions operate on one data structure than 10 functions on 10 data structures", it unifies the interfaces, and people tend to rather use validation libraries to check if it is well-formed and valid over using records.
[10:34:39] <sjamaan> zilti[m]: It makes everything look like uniform soup and makes it very hard to get your bearings when trying to read some unfamiliar code
[10:44:22] *** Quits: klovett (~klovett@107.127.17.177) (Quit: ZZZzzzâ€¦)
[10:56:56] <zilti[m]> sjamaan: Yes, there I have to agree with you, it is sometimes a bit of a chore to track down what variable x actually contains and what it is.
[11:01:03] *** Joins: rgherdt (~rgherdt@83.236.18.121)
[11:01:07] <jcroisant> Hooray, I've finally implemented enough libcurl bindings to fetch the CHICKEN homepage and stream the data through a callback procedure. Progress! \o/
[11:02:08] <sjamaan> zilti[m]: The validation library stuff is also a huge kludge. We're using Malli in a big project at bevuta, but it's causing some headaches with cljs. Because the schema is rather big, startup time goes into dozens of seconds just to register the schema
[11:02:23] <sjamaan> And validation itself is quite slow too
[11:03:38] <zilti[m]> I'm still waiting for spec2 to be released... not sure if it ever will... But I suppose at least the performance of that woul be better. Malli also is just alpha. That is indeed an issue of Clojure
[11:03:57] <sjamaan> We had to basically rewrite malli to make it perform properly
[11:05:20] <sjamaan> jcroisant: ah, libcurl. Cool!  Did you check the original ones? ISTR we had libcurl bindings in CHICKEN 2 or 3
[11:05:50] <sjamaan> yeah, there's one for chicken 3
[11:05:50] <zilti[m]> Is there btw a validation library somewhat like it in chicken?
[11:07:55] <sjamaan> I think you could use comparse to validate a datastructure
[11:08:08] <sjamaan> But you typically wouldn't need such a thing in CHICKEN if you're using records and such
[11:08:25] <sjamaan> Possibly the setters and constructors for records could do some sanity checking
[11:09:52] *** Quits: Zipheir (~wcm@98.4.178.27) (Quit: Eadem mutata resurgo.)
[11:09:53] <zilti[m]> I mean validation goes beyond a simple "does the general type match". Although I guess you can fill these gaps with pre/postconditions mostly
[11:09:58] <zilti[m]> Yes
[11:12:09] <jcroisant> sjamaan: No, I just started from scratch. I just wanted more C libraries to try with Jiffi, and someone suggested libcurl. Apparently I am a masochist because I actually started working on it lol
[11:14:27] <sjamaan> :)
[11:14:30] <sjamaan> What's Jiffi?
[11:14:48] <jcroisant> https://wiki.call-cc.org/eggref/5/jiffi
[11:16:32] <jcroisant> So far I have converted sdl2, implemented most of Chipmunk2D physics engine, and now part of libcurl. Next I am going to try libtickit.
[11:16:40] <sjamaan> hey this is pretty neat!
[11:16:58] <sjamaan> Cool name, too
[11:17:19] <sjamaan> You should announce the egg on chicken-announce when you're happy with the API
[11:17:27] <sjamaan> (unless you already did and I totally missed it?)
[11:17:43] <jcroisant> Thanks!
[11:18:19] <jcroisant> I did several months ago, but I'll do again when it's ready :)
[11:20:35] <sjamaan> The documentation is also very extensive. Nice!
[11:20:53] <ecraven> jcroisant: did you look at the way chez's foreign-procedure works? it seems to do mostly the same thing yours does, but with a different syntax ;) just to see how others did it
[11:21:12] <zilti[m]> Oh, jiffi looks interesting. I'm reading the docs right now
[11:21:32] <jcroisant> ecraven: I'll have a look, thanks!
[11:28:38] <sjamaan> jcroisant: Perhaps you can extend https://wiki.call-cc.org/Wrapping%20simple%20c%20structs with an example using Jiffi
[11:28:59] <sjamaan> Or add something to https://wiki.call-cc.org/tutorials
[11:31:15] <zilti[m]> Heh, looks like I could've saved the effort of implementing what jiffi calls "make/af" for qml, lol
[11:32:20] <zilti[m]> on the other hand, that library would have made the development also a bit less of a learning exercise
[11:35:13] <sjamaan> hehe, this really is an industrial strength FFI
[11:48:45] *** Joins: s-liao (~s-liao@101.86.96.21)
[12:16:41] *** Quits: ecloud (~quassel@192.89.120.58) (Ping timeout: 256 seconds)
[12:21:19] <vandusen> SPAM! SPAM! SPAM! by freeee
[12:24:53] *** Joins: ecloud (~quassel@192.89.120.58)
[12:25:40] *** Joins: rgherdt_ (~rgherdt@port-92-193-217-5.dynamic.as20676.net)
[12:27:02] *** Joins: crumpo (~crumpo@user/crumpo)
[12:28:28] *** Quits: rgherdt (~rgherdt@83.236.18.121) (Ping timeout: 272 seconds)
[12:44:23] <Bunny351> ASau: expressions have types onl y in statically typed languages! in dyn.typed languages the same expression can have values of different type, it's not that hard to understand.
[12:47:46] <Bunny351> whether a type is a latent property of a value or a compile-time property of a syntactic element, it is still the same concept of type.
[12:49:30] <Bunny351> you can take a statically typed language and drop the static type system, replacing it with a dynamic run-time system, the language is still the same, the type system is still strong, and well-typed code will execute with the same behaviour (with the exception of performance, perhaps)
[12:50:00] *** Quits: rgherdt_ (~rgherdt@port-92-193-217-5.dynamic.as20676.net) (Quit: Leaving)
[12:50:12] *** Joins: rgherdt (~rgherdt@port-92-193-217-5.dynamic.as20676.net)
[12:50:36] <s-liao> The statically typed language the expression is s-expression, they have not been binded yet.
[12:52:15] <Bunny351> (side note: trying it the other way round will not work, which says sth about the difference in expressivity of the two concepts)
[12:52:30] <Bunny351> vandusen: BLASPHEMY!
[12:52:32] <vandusen> Bunny351: "To date, that's definitely the best baby I'VE ever seen!"
[13:04:14] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[13:04:31] *** Joins: s-liao (~s-liao@101.86.96.21)
[13:09:45] <s-liao> Assume that we can consider about the performance, dynamic running system has the statically type inside the system.And those statically type should be like s-expression, then can be easy transformed into the different data module.
[13:10:13] <s-liao> Assume that we do not need to consider about the performance, dynamic running system has the statically type inside the system.And those statically type should be like s-expression, then can be easy transformed into the different data module.
[13:16:00] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[13:16:24] *** Joins: s-liao (~s-liao@101.86.96.21)
[13:18:58] <s-liao> the different data model
[13:28:26] *** Joins: ublx (~ublx@user/ublx)
[13:32:03] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[13:38:30] *** Joins: s-liao (~s-liao@101.86.96.21)
[13:43:25] *** Quits: DeeEff_ (~deeeff@user/deeeff) (Quit: Bridge terminating on SIGTERM)
[13:43:26] *** Quits: blackbeard (~barbanegr@2001:470:69fc:105::38c4) (Quit: Bridge terminating on SIGTERM)
[13:43:26] *** Quits: zilti[m] (~ziltimatr@2001:470:69fc:105::16d0) (Quit: Bridge terminating on SIGTERM)
[13:43:26] *** Quits: Helios (~dwaglemat@2001:470:69fc:105::5f8) (Quit: Bridge terminating on SIGTERM)
[13:43:26] *** Quits: dieggsy (~dieggsy@2001:470:69fc:105::91f) (Quit: Bridge terminating on SIGTERM)
[13:43:26] *** Quits: Irvise (~irvise@2001:470:69fc:105::84c) (Quit: Bridge terminating on SIGTERM)
[13:43:26] *** Quits: evhan[m] (~evhanfold@2001:470:69fc:105::33e3) (Quit: Bridge terminating on SIGTERM)
[13:43:26] *** Quits: dlozeve[m] (~dlozevema@2001:470:69fc:105::1:1c58) (Quit: Bridge terminating on SIGTERM)
[13:43:29] *** Quits: siraben (~siraben@user/siraben) (Quit: Bridge terminating on SIGTERM)
[13:44:45] <vandusen> SPAM! SPAM! SPAM! by freee
[13:46:17] *** Joins: DeeEff_ (~deeeff@user/deeeff)
[13:47:55] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[13:49:00] *** Joins: zilti[m] (~ziltimatr@2001:470:69fc:105::16d0)
[13:49:00] *** Joins: Helios (~dwaglemat@2001:470:69fc:105::5f8)
[13:49:00] *** Joins: dieggsy (~dieggsy@2001:470:69fc:105::91f)
[13:49:00] *** Joins: blackbeard (~barbanegr@2001:470:69fc:105::38c4)
[13:49:00] *** Joins: siraben (~siraben@user/siraben)
[13:49:12] *** Joins: Irvise (~irvise@2001:470:69fc:105::84c)
[13:49:12] *** Joins: dlozeve[m] (~dlozevema@2001:470:69fc:105::1:1c58)
[13:49:12] *** Joins: evhan[m] (~evhanfold@2001:470:69fc:105::33e3)
[13:50:30] *** Joins: ublix (~ublx@user/ublx)
[13:52:03] *** Joins: s-liao (~s-liao@101.86.96.21)
[13:53:24] *** Quits: ublx (~ublx@user/ublx) (Ping timeout: 240 seconds)
[14:11:09] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[14:19:24] *** Joins: s-liao (~s-liao@101.86.96.21)
[14:19:32] *** Quits: s-liao (~s-liao@101.86.96.21) (Client Quit)
[14:19:57] *** Joins: s-liao (~s-liao@101.86.96.21)
[14:24:40] *** Quits: s-liao (~s-liao@101.86.96.21) (Client Quit)
[14:25:00] *** Quits: fantazo (~fantazo@192-164-154-92.hdsl.highway.telekom.at) (Ping timeout: 272 seconds)
[14:54:09] *** Quits: ublix (~ublx@user/ublx) (Quit: ublix)
[16:06:14] *** Joins: Guest22 (~Guest22@2001:6b0:1:1041:2a6d:a48d:707d:37df)
[16:22:24] *** Joins: s-liao (~s-liao@101.86.96.21)
[16:33:48] *** Quits: Guest22 (~Guest22@2001:6b0:1:1041:2a6d:a48d:707d:37df) (Quit: Client closed)
[16:54:59] *** Joins: ublx (~ublx@user/ublx)
[17:09:00] *** Joins: skapata (~Skapata@2804:14c:87b0:9d2e:e029:79e4:6493:91cc)
[17:09:00] *** Quits: skapata (~Skapata@2804:14c:87b0:9d2e:e029:79e4:6493:91cc) (Changing host)
[17:09:00] *** Joins: skapata (~Skapata@user/skapata)
[17:17:25] *** Joins: keyehzh (~keyehzh@user/keyehzh)
[17:45:47] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[17:58:37] *** Joins: klovett (~klovett@107.127.17.177)
[18:26:11] *** Quits: ublx (~ublx@user/ublx) (Quit: ublx)
[18:29:20] *** Joins: xaltsc (~xaltsc@user/xaltsc)
[20:54:09] *** Joins: fantazo (~fantazo@192-164-154-92.hdsl.highway.telekom.at)
[21:01:55] *** Quits: keyehzh (~keyehzh@user/keyehzh) (Remote host closed the connection)
[21:04:59] *** form_feed is now known as \f
[23:14:35] *** Quits: crumpo (~crumpo@user/crumpo) (Quit: Buh bye)
