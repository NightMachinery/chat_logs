[00:04:06] *** Quits: brw (~bas@haring.bas.sh) (Quit: The Lounge - https://thelounge.chat)
[00:04:35] *** Joins: brw (~bas@haring.bas.sh)
[00:11:55] *** Quits: shbot (~shbot@37.139.2.101) (Remote host closed the connection)
[00:12:47] *** Joins: shbot (~shbot@37.139.2.101)
[00:26:45] *** Joins: wuseman (~wuseman@81-234-125-157-no68.tbcn.telia.com)
[00:26:45] *** Quits: wuseman (~wuseman@81-234-125-157-no68.tbcn.telia.com) (Changing host)
[00:26:45] *** Joins: wuseman (~wuseman@user/wuseman)
[00:29:11] *** Joins: roarde (~roarde@user/roarde)
[00:35:44] *** Quits: Torr (~Torr@user/torr) (Ping timeout: 252 seconds)
[00:45:19] *** Joins: [RMS] (~rs@genoce.org)
[00:46:16] *** Quits: [R] (~rs@genoce.org) (Ping timeout: 260 seconds)
[00:49:54] <yeti> # awk 'BEGIN {v = "1gsdkja"; print (v+0 == 1); print v}'
[00:49:55] <shbot> yeti: 1
[00:49:55] <shbot> yeti: 1gsdkja
[00:56:27] <emanuele6> yes, but that was not what i was trying to show
[00:59:09] *** Quits: AJ_Z0 (~AJ_Z0@user/aj-z0/x-3780512) (Read error: Connection reset by peer)
[01:00:50] *** Joins: AJ_Z0 (~AJ_Z0@user/aj-z0/x-3780512)
[01:09:26] *** Quits: user51 (~user51@176.228.151.30) (Quit: leaving)
[01:12:25] *** Quits: node1 (~node1@user/node1) (Quit: Client closed)
[01:36:42] *** [RMS] is now known as [R]
[01:37:03] *** Quits: wuseman (~wuseman@user/wuseman) (Ping timeout: 256 seconds)
[01:37:51] *** Quits: lavaball (felix@31.204.155.215) (Remote host closed the connection)
[01:42:53] *** Joins: wuseman (~wuseman@81-234-125-157-no68.tbcn.telia.com)
[01:42:53] *** Quits: wuseman (~wuseman@81-234-125-157-no68.tbcn.telia.com) (Changing host)
[01:42:53] *** Joins: wuseman (~wuseman@user/wuseman)
[01:54:37] *** Quits: wuseman (~wuseman@user/wuseman) (Ping timeout: 256 seconds)
[01:54:54] *** Joins: wuseman (~wuseman@81-234-125-157-no68.tbcn.telia.com)
[01:54:55] *** Quits: wuseman (~wuseman@81-234-125-157-no68.tbcn.telia.com) (Changing host)
[01:54:55] *** Joins: wuseman (~wuseman@user/wuseman)
[02:06:07] *** Quits: wuseman (~wuseman@user/wuseman) (Ping timeout: 252 seconds)
[02:06:33] <e36freak> yeti: fyi +v is shorter than v+0 and works
[02:10:12] *** Joins: Torr (~Torr@user/torr)
[02:10:24] *** Joins: wuseman (~wuseman@81-234-125-157-no68.tbcn.telia.com)
[02:10:24] *** Quits: wuseman (~wuseman@81-234-125-157-no68.tbcn.telia.com) (Changing host)
[02:10:24] *** Joins: wuseman (~wuseman@user/wuseman)
[02:15:41] *** Quits: wuseman (~wuseman@user/wuseman) (Read error: Connection reset by peer)
[02:16:53] *** Joins: wuseman (~wuseman@81-234-125-157-no68.tbcn.telia.com)
[02:16:53] *** Quits: wuseman (~wuseman@81-234-125-157-no68.tbcn.telia.com) (Changing host)
[02:16:53] *** Joins: wuseman (~wuseman@user/wuseman)
[02:37:27] <earnest> More esoteric, more
[02:40:06] <e36freak> more awesome
[02:41:11] <earnest> Yes
[02:44:52] <yeti> o.O
[02:46:05] *** Quits: wuseman (~wuseman@user/wuseman) (Ping timeout: 252 seconds)
[02:46:06] <earnest> unary +
[02:49:35] <yeti> a+"" matches a+0 nicely, so sometimes this representation of the same trick adds clarity
[02:50:04] <yeti> use what fits...
[02:51:37] *** Joins: junebug (~junebug@104-0-169-217.lightspeed.miamfl.sbcglobal.net)
[02:52:51] <earnest> yeti: The loss of clarity is the point
[02:53:28] <yeti> sometimes
[02:53:57] <earnest> Doesn't let you relax, lure you into false sense of security.  Then you hit it with jump scare, bam
[02:54:37] <earnest> The goal is to have the most 'wtf' talks at programming conferences
[02:56:30] <yeti> awk '{for(n=2;l<$1;){if(n in L)p=L[n];else{print p=n;l++}for(N=p+n++;N in L;)N+=p;L[N]=p}}'
[02:56:31] <earnest> Imagine a language which looks normal but you end up spending 70% of your time googling syntax references
[02:56:46] <yeti> feed integers to it
[02:57:21] <yeti> eratosthenes torn thru a kein's bottle
[02:57:34] <earnest> If this had a heatmap, all the red would be on N=p+n++, but the rest is readable
[02:58:35] <yeti> a meanie in bash:
[02:58:37] <yeti> eval g={-4096..4096..199}'
[02:58:39] <yeti> 'h={-8192..4096..99}'
[02:58:41] <yeti> x=;y=;for((i=0;i<30&&x*x+y*y<1<<26;i++)){((v=(x*x-y*y>>12)+h,y=(x*y>>11)+g,x=v));}
[02:58:43] <yeti> printf $[i%10]
[02:58:51] <earnest> yeti: For bash, ormaaj
[02:59:46] <earnest> yeti: See, the point isn't to write code that's obscured by spacing, or single letter variables.  It's to make a normal language uncanny
[02:59:56] <earnest> print p=n is nice though
[03:00:21] <yeti> eval g={-4096..4096..199}' and the next line gives a 2D loop 
[03:01:42] <yeti> one of my meanest mandelbrot progs so far
[03:03:21] <yeti> sure DC looks even better
[03:04:55] *** Quits: concrete-houses (~g@209.6.150.53) (Remote host closed the connection)
[03:17:21] *** Quits: Torr (~Torr@user/torr) (Ping timeout: 256 seconds)
[03:19:19] *** Joins: seninha (~seninha@user/seninha)
[03:20:40] *** Joins: wuseman (wuseman@213-67-240-49-no68.tbcn.telia.com)
[03:20:41] *** Quits: wuseman (wuseman@213-67-240-49-no68.tbcn.telia.com) (Changing host)
[03:20:41] *** Joins: wuseman (wuseman@user/wuseman)
[03:37:38] *** Joins: maroloccio (~marolocci@151.53.155.184)
[04:14:07] *** Quits: wuseman (wuseman@user/wuseman) (Ping timeout: 268 seconds)
[04:24:56] *** Joins: treble (~treble@75.76.29.142)
[04:25:08] *** Quits: treble (~treble@75.76.29.142) (Changing host)
[04:25:08] *** Joins: treble (~treble@user/treble)
[04:33:47] *** Joins: kapu (~kapu@user/egm)
[04:37:23] *** Quits: [R] (~rs@genoce.org) (Read error: Connection reset by peer)
[04:37:30] *** Joins: [R] (~rs@genoce.org)
[04:46:54] *** Quits: maroloccio (~marolocci@151.53.155.184) (Quit: WeeChat 3.0)
[04:49:36] *** Joins: maroloccio (~marolocci@151.53.155.184)
[04:49:47] *** Quits: maroloccio (~marolocci@151.53.155.184) (Client Quit)
[04:50:15] *** Joins: maroloccio (~marolocci@151.53.155.184)
[05:40:25] <seninha> solutions for aoc in awk by a 9front developer (runs in Plan 9 awk(1)): https://git.sr.ht/~ft/aoc/tree/front/item/2021
[05:44:02] *** Quits: junebug (~junebug@104-0-169-217.lightspeed.miamfl.sbcglobal.net) (Quit: Leaving)
[05:46:14] <e36freak> nifty
[05:47:13] *** Quits: kapu (~kapu@user/egm) (Ping timeout: 252 seconds)
[06:05:07] *** Quits: seninha (~seninha@user/seninha) (Quit: Leaving)
[06:06:18] *** Joins: seninha (~seninha@user/seninha)
[06:44:32] *** Joins: wuseman (wuseman@213-67-240-49-no68.tbcn.telia.com)
[06:45:18] *** Quits: maroloccio (~marolocci@151.53.155.184) (Quit: WeeChat 3.0)
[07:04:50] <aetnaeus> did anyone ever come up with a solution for my input buffering conundrum?
[07:04:57] <aetnaeus> or at least verify that it is indeed a bug?
[07:05:00] <aetnaeus> namely
[07:05:06] <aetnaeus> (printf 'testa\';read)|awk -vRS='a\' '{print}'
[07:05:22] <aetnaeus> won't print anything
[07:05:29] *** Quits: AJ_Z0 (~AJ_Z0@user/aj-z0/x-3780512) (Read error: Connection reset by peer)
[07:05:33] <aetnaeus> curiously (printf 'testa,';read)|awk -vRS='a,' '{print}'
[07:05:36] <aetnaeus> works
[07:06:03] <aetnaeus> as does  (printf 'test\';read)|awk -vRS='\' '{print}'
[07:08:12] *** Quits: e36freak (~e36freak@user/e36freak) (Remote host closed the connection)
[07:10:01] *** Quits: wuseman (wuseman@213-67-240-49-no68.tbcn.telia.com) (Changing host)
[07:10:01] *** Joins: wuseman (wuseman@user/wuseman)
[07:10:13] *** Joins: e36freak (~e36freak@user/e36freak)
[07:11:05] *** Joins: AJ_Z0 (~AJ_Z0@user/aj-z0/x-3780512)
[07:26:56] *** Quits: seninha (~seninha@user/seninha) (Remote host closed the connection)
[07:27:49] *** Quits: earnest (~earnest@user/earnestly) (Ping timeout: 256 seconds)
[07:28:09] <aetnaeus> so in other words, if the last character of RS is a backslash and it is preceded by at least one other character then awk seems to do input buffering :/
[08:35:05] *** Quits: [R] (~rs@genoce.org) (Remote host closed the connection)
[08:35:12] *** Joins: [R] (~rs@genoce.org)
[08:54:16] *** Joins: junebug (~junebug@104-0-169-217.lightspeed.miamfl.sbcglobal.net)
[09:27:35] *** Quits: junebug (~junebug@104-0-169-217.lightspeed.miamfl.sbcglobal.net) (Ping timeout: 252 seconds)
[09:50:33] <emanuele6> aetnaeus: what awk are you using?
[09:51:51] <emanuele6> also, are you aware that the behaviour of RS with 2 or more character is implementation-dependant?
[09:53:49] *** Joins: user51 (~user51@176.228.151.30)
[09:54:24] <emanuele6> for example, nawk will only use the first character of RS (though i think this is undocumented), and gawk will treat RS as a ERE if it is 2+ characters long (like FS)
[09:55:29] <emanuele6> # printf testa, | nawk -vRS='a,' 1
[09:55:29] <shbot> emanuele6: test
[09:55:33] <emanuele6> # printf testa, | gawk -vRS='a,' 1
[09:55:34] <shbot> emanuele6: test
[09:56:10] <emanuele6> # printf testa, | nawk -vRS='a,' 1     ; echo t
[09:56:11] <shbot> emanuele6: test
[09:56:12] <shbot> emanuele6: t
[09:56:17] <emanuele6> huh?
[09:56:28] <emanuele6> # nawk --version
[09:56:29] <shbot> emanuele6: awk version 20210215
[09:57:04] <emanuele6> i have nawk 20180827 and it prints 'test' and ','
[09:57:15] <emanuele6> # printf testa,a | nawk -vRS='a,' 1
[09:57:16] <shbot> emanuele6: test
[09:57:17] <shbot> emanuele6: a
[09:58:47] <emanuele6> hmm
[09:59:16] <emanuele6> then also tell us the version of the awk implementation that you are using i guess
[10:07:04] <aetnaeus> emanuele6: It happens on gawk and busybox awk
[10:07:12] <aetnaeus> I am expecting it to treat RS as an ERE
[10:07:14] <aetnaeus> which it does
[10:07:20] <aetnaeus> that isn't the issue
[10:07:35] <aetnaeus> the problem is that it selectively does input buffering depending on whether or not the final character is a \
[10:07:57] <emanuele6> you didn't say the version
[10:08:10] <emanuele6> anyway, if you expect it to be treated as a regex
[10:08:15] <emanuele6> a\ is not a valid regex
[10:08:29] <emanuele6> # gawk 'BEGIN {RS="a\\"}'
[10:08:30] <shbot> emanuele6: gawk: cmd. line:1: fatal: invalid regexp: Trailing backslash: /a\/
[10:09:23] *** Joins: TenochSLB (~Tenochyy@108-216-74-215.lightspeed.wchtks.sbcglobal.net)
[10:11:21] <aetnaeus> emanuele6: version 4.2.1
[10:11:25] <aetnaeus> mine doesn't produce an error :/
[10:11:34] <aetnaeus> gawk 'BEGIN {RS="a\\"}' runs fine on my machine
[10:12:06] <emanuele6> i have 5.1.1 on my machine and i can't reproduce your buffering problem either
[10:12:16] <emanuele6> # gawk --version |& head -1
[10:12:17] <shbot> emanuele6: GNU Awk 5.1.0, API: 3.0 (GNU MPFR 4.0.1, GNU MP 6.1.2)
[10:12:23] <emanuele6> shbot has 5.1.0
[10:13:15] <aetnaeus> presumably you can't reproduce it because gawk chokes on the RS
[10:13:21] <aetnaeus> in my case it doesn't
[10:14:01] <emanuele6> it does not choke on the RS
[10:14:19] <emanuele6> when using -vRS='invalid regex' it only uses the first character of RS
[10:14:31] <emanuele6> so it prints 'test' and '\'
[10:15:04] <aetnaeus> what about this?
[10:15:05] <aetnaeus> (printf 'testa\';read)|gawk -vRS='a\\\\' '{print}'
[10:15:07] <aetnaeus> on my machine this works
[10:15:14] <aetnaeus> but only after the pipe is closed
[10:15:51] <aetnaeus> while (printf 'testa,';read)|gawk -vRS='a,' '{print}'
[10:15:54] <aetnaeus> prints immediately
[10:16:06] <emanuele6> i can reproduce that, yes
[10:16:25] <emanuele6> but that is to be expected
[10:16:36] <emanuele6> a\\\\ is a regex that matches a\\
[10:16:48] <emanuele6> try   (printf 'testa\\';read)|gawk -vRS='a\\\\' '{print}' 
[10:16:57] <emanuele6> and you will see it works as expected
[10:17:12] <aetnaeus> No, it doesn't
[10:17:20] <aetnaeus> the reason that works is because you are adding an additional char
[10:17:31] <aetnaeus> (printf 'testa\x';read)|gawk -vRS='a\\\\' '{print}'
[10:17:32] <emanuele6> well, it does for me, and that is the expected result
[10:17:32] <aetnaeus> also works
[10:17:37] <aetnaeus> \]\\\\
[10:17:42] <aetnaeus> \\\\ is actually a single slash
[10:17:51] <aetnaeus> the additional slashes are needed
[10:17:55] <emanuele6> i would never expect a\\\\ to match a\  so your example was flawed to begin with
[10:18:04] <aetnaeus> then why does (printf 'testa\x';read)|gawk -vRS='a\\\\' '{print}' produce test?
[10:18:24] <aetnaeus> or rather (printf 'testa\\x';read)|gawk -vRS='a\\\\' '{print}'
[10:18:44] <emanuele6> because a\\\\ matches a\\ :/
[10:18:54] <aetnaeus> yes, but there is no a\\
[10:18:57] <aetnaeus> in test\\x
[10:19:07] <aetnaeus> but it still prints test
[10:19:11] <emanuele6> i see testa\\x, not test\\x
[10:19:26] <aetnaeus> :/
[10:19:37] <emanuele6> <aetnaeus > or rather (printf 'testa\\x';read)|gawk -vRS='a\\\\' '{print}'
[10:19:50] <emanuele6> <aetnaeus > then why does (printf 'testa\x';read)|gawk -vRS='a\\\\' '{print}' produce test?
[10:19:59] <emanuele6> testa
[10:20:01] <emanuele6> \\x
[10:20:15] <emanuele6> # printf 'testa\\x'
[10:20:16] <shbot> emanuele6: testa\x
[10:20:34] <emanuele6> that prints only one backslash actually
[10:20:40] <aetnaeus> # (printf 'testa\\x';read)|gawk -vRS='a\\\\' '{print}'
[10:20:46] <shbot> aetnaeus: test
[10:22:20] <aetnaeus> lets for a moment assume that a\\\\ is indeed an a\ regex as I claim 
[10:22:32] <aetnaeus> (printf 'testa\\x';read)|gawk -vRS='a\\\\' '{print}' produces the correct result
[10:22:34] <emanuele6> actually
[10:22:35] <aetnaeus> but only after eof
[10:22:55] <emanuele6> # gawk -vRS='a\\' 1
[10:22:56] <shbot> emanuele6: gawk: fatal: invalid regexp: Trailing backslash: /a\/
[10:23:11] <aetnaeus> yes, because it interprets that as /\/
[10:23:12] <emanuele6> it seems that -v assignments remove backslashes
[10:23:15] <aetnaeus> instead of /\\/
[10:23:18] <aetnaeus> yes
[10:23:33] <aetnaeus> /\\/ == one backslash
[10:23:47] <emanuele6> -vRS='a\\' sets RS to a\ which is an invalid regex
[10:24:02] <emanuele6> and i think a\ just sets RS to a
[10:24:11] <aetnaeus> in any event (printf 'testa\\x';read)|gawk -vRS='a\\\\' '{print}' does work
[10:24:15] <aetnaeus> the output is not the issue
[10:24:21] <aetnaeus> the problem is when the output is produced
[10:24:37] <emanuele6> that would print testa\x,  and split on a\
[10:24:51] <emanuele6> and it prints test immediately
[10:25:15] <aetnaeus> correct
[10:25:17] <emanuele6> and x after the pipe is closed
[10:25:23] <emanuele6> that is expected, no?
[10:25:23] *** Quits: Norkle (~norkle@admin.nasa-g0v.com) (Quit: Changing server)
[10:25:24] <aetnaeus> but if you remove the x it waits for the pipe to close
[10:25:29] *** Joins: norkle (~norkle@admin.nasa-g0v.com)
[10:25:30] <aetnaeus> e.g
[10:25:35] <aetnaeus> (printf 'testa\\';read)|gawk -vRS='a\\\\' '{print}'
[10:25:37] <aetnaeus> waits for pipe closure
[10:25:53] <aetnaeus> but if you change the backslash to some other character like ,
[10:25:56] <aetnaeus> it prints immediately
[10:25:58] <aetnaeus> e.g
[10:26:06] <aetnaeus> (printf 'testa,';read)|gawk -vRS='a,' '{print}'
[10:28:07] <emanuele6> yes, i can reproduce that in Gawk 5.1.1
[10:28:26] <aetnaeus> it also happens on busybox and macos awk
[10:28:31] <aetnaeus> not sure about the versions
[10:28:48] <aetnaeus> mawk does input buffering anyway, so it doesn't matter
[10:28:58] <emanuele6> they might treat -vRS='a\\\\' differently
[10:29:17] <aetnaeus> possibly, I can't remember the result of my experiments
[10:29:29] <aetnaeus> but I do no that I got all of them to produce the correct outputs at one point
[10:29:37] <aetnaeus> and they only did input buffering if the last char was \
[10:29:43] <emanuele6> maybe as a literal string instead of an ERE, maybe they don't expand the backslashes on assignment, maybe they only use the first character, etc 
[10:29:58] <aetnaeus> no, those werent issues
[10:30:01] <aetnaeus> the output was *correct*
[10:30:08] <aetnaeus> the only problem was that it needed eof
[10:30:18] <aetnaeus> which was not the case for other chars
[10:30:42] <emanuele6> anyway, this is unspecified behaviour so it is strictly implementation dependant
[10:30:51] *** norkle is now known as Norkle
[10:31:05] <aetnaeus> perhaps, but it seems to be a common bug
[10:31:13] <aetnaeus> and people gripe about the fact that mawk does input buffering
[10:31:22] <aetnaeus> it seems that this is a subtle but serious bug
[10:32:04] <aetnaeus> it probably has something to do with the way they handle escape sequences
[10:33:02] *** Joins: node1 (~node1@user/node1)
[10:35:30] <aetnaeus> # print 'test\n';sleep 1s;printf 'test2\n'
[10:35:36] <shbot> aetnaeus: test
[10:35:36] <shbot> aetnaeus: 
[10:35:36] <shbot> aetnaeus: etc... ( http://ix.io/3H3O )
[10:36:24] <aetnaeus> it looks like shbot waits for termination, so I can't reproduce it here
[10:36:25] <aetnaeus> but 
[10:36:29] <aetnaeus> (printf 'testa\\';read)|busybox awk -vRS='a\\\\' '{print}'
[10:36:32] <aetnaeus> does the same thing
[10:37:30] *** Quits: node1 (~node1@user/node1) (Client Quit)
[10:37:42] *** Joins: node1 (~node1@user/node1)
[10:38:15] <aetnaeus> actually busybox does it even when the last character isn't \, so it might just be gawk
[10:38:38] <aetnaeus> in which case it would seem all awks do some input buffering and gawk just happens not to do it in certain cases
[11:02:44] <emanuele6> also note that grep's ERE compiler (that gawk uses) is does not have that problem:  (printf '%s\n' 'testa\'; read) | grep -E 'a\\'
[11:02:58] <emanuele6> s/grep/GNU &/
[11:06:21] *** Joins: }8] (~}8]@107.173.83.81)
[11:06:49] *** Quits: roarde (~roarde@user/roarde) (Quit: Leaving)
[11:08:56] <}8]> hi. how do you do a regex match, and then test if a field contains a var? for a broken example: awk -v VAR="abc" '/match-(this|that)/ $2 ~ VAR {print}'
[11:10:13] <}8]> so i'd want to check all lines that contain "match-this" and "match-that", and then test the 2nd field of those if it contains "abc" 
[11:10:42] <Patsie> awk -v VAR="abc" '/match-(this|that)/ && ($2 ~ VAR) {print}'
[11:11:02] <Patsie> although in true awk fasshion the print action is default, so that's not needed in this case
[11:11:18] <Patsie> awk -v VAR="abc" '/match-(this|that)/ && ($2 ~ VAR)'
[11:11:21] <Patsie> this would do the same
[11:11:54] <}8]> ahh i see, so the regex match && the condition inside () both have to be true
[11:12:20] <Patsie> yes, that's what the && (and) operator is for
[11:12:26] <emanuele6> if VAR should be a literal string, you don't need to inject a regex to check if $2 contains VAR, you can use index($2, VAR)
[11:12:47] <emanuele6> e.g. awk -v VAR="abc" '/match-(this|that)/ && index($2, VAR)'
[11:13:13] <Patsie> I think the ($2 ~ VAR) is more awk'y (pattern matching)
[11:13:23] <Patsie> although index() would work too
[11:13:39] <emanuele6> if VAR is a pattern, then ~ should be used
[11:14:03] <}8]> im not familiar with index(), will have to look that one up. thanks for the help guys!
[11:14:24] <emanuele6> but if VAR is just a literal string, it is more appropriate to use index so that it will actually work every time 
[11:15:15] <Patsie> emanuele6: can you give an example where a litteral string would not work with ($2 ~ VAR) ?
[11:17:20] *** Quits: node1 (~node1@user/node1) (Ping timeout: 256 seconds)
[11:18:05] <emanuele6> # printf '%s\n' 1+ 12 | awk -v var='1+' '$0 ~ var'
[11:18:06] <shbot> emanuele6: 1+
[11:18:06] <shbot> emanuele6: 12
[11:18:15] <emanuele6> # printf '%s\n' 1+ 12 | awk -v var='1+' 'index($0,var)'
[11:18:16] <shbot> emanuele6: 1+
[11:18:34] <emanuele6> as i said, if var is supposed to be a regex, then ~ should be used
[11:18:51] <emanuele6> but if it is only used for a substring match, you should use index
[11:19:12] <emanuele6> # printf '%s\n' 1+3 12 | awk -v var='1+' 'index($0,var)'
[11:19:13] <shbot> emanuele6: 1+3
[11:20:00] <emanuele6> also passing arbitrary regexes may cause compilation errors
[11:32:38] *** Joins: node1 (~node1@user/node1)
[12:05:38] <Patsie> ah, right
[12:06:05] <Patsie> lets see if I can find some time for AOC day05
[12:49:57] *** Quits: TenochSLB (~Tenochyy@108-216-74-215.lightspeed.wchtks.sbcglobal.net) (Remote host closed the connection)
[12:51:50] *** Joins: earnest (~earnest@user/earnestly)
[12:56:33] *** Joins: lavaball (felix@31.204.155.215)
[15:13:40] *** Joins: ClanLord (~weechat@141.226.73.109)
[15:13:51] <ClanLord> hi
[15:14:02] <ClanLord> how does tell awk to treat all lines like if there were arguments like:
[15:14:08] <ClanLord> file1
[15:14:10] <ClanLord> file2
[15:14:13] <ClanLord> to: file1 file2
[15:14:28] <ClanLord> s/does/to
[15:14:57] <user51> http://sprunge.us/W1KkRl
[15:15:12] <user51> yet another 4-function calc parser
[15:15:37] <ClanLord> thank
[15:15:43] <ClanLord> Patsie: 
[15:17:47] <user51> actually i think it kind of hits an awk limit
[15:18:19] <user51> kind of feels like manipulating the call stack should be done for errors
[15:20:36] <Patsie> finally found some time to finish AOC day05 (spoiler -> https://github.com/patsie75/aoc/tree/main/2021)
[15:20:39] <Patsie> was another fun one
[15:23:37] <user51> i kind of gave up on aoc because of the wall of text
[15:23:52] <user51> it just don't have enough textosterone for that.
[15:23:57] <user51> s/it/i/
[15:24:39] <ClanLord> nvm i got it
[15:24:41] <ClanLord> thanks for the help !
[15:26:37] <heiner> ClanLord: what did you do? "prevline = $0; getline();  print prevline, $0"?
[15:26:41] <ClanLord> however there must be something more efficient than mv `find .... | awk '{printf "%s ", $0}'
[15:26:57] <ClanLord> just printf
[15:27:00] <ClanLord> lol :D
[15:27:24] <heiner> ClanLord: you could use the following: find ... | xargs echo
[15:27:56] <Patsie> heiner: that will/cpuld still split up if you have 'enough' arguments
[15:28:02] <Patsie> could*
[15:28:19] <ClanLord> Patsie: so i got it right ? 
[15:28:26] <Patsie> sure, it works
[15:28:33] <ClanLord> yay
[15:28:40] <ClanLord> thumbs up from Patsie
[15:28:57] <Patsie> not sure what for, or if it's going to be usable for the end goal, but it will paste all lines on a single line, space separated
[15:29:24] <Patsie> probably not usefull if you encounter files with spaces, or files with newlines
[15:29:26] <ClanLord> thumbs up from Patsie !!!!!!!!!!!!!
[15:29:28] *** Parts: ClanLord (~weechat@141.226.73.109) (WeeChat 3.2)
[15:31:03] <Patsie> e36freak: where's your day05 implementation?
[15:39:08] <emanuele6> Patsie: https://0x0.st/-h6O.txt these are my solutions
[15:39:42] <emanuele6> this one was quite simple
[15:44:41] <Patsie> I'm always amazed at all the different approaces I see :)
[15:45:14] <Patsie> (and usually how 'long' my sollutions are, compared to others)
[15:46:30] <emanuele6> how is yours?
[15:46:50] <emanuele6> oh, you have sent a link
[15:47:33] <emanuele6> oh, yeah, your is way longer
[15:48:40] <emanuele6> you did not do *the thing i do in the first line of second solution*
[15:53:03] <emanuele6> s/sec/my &/
[15:53:30] * emanuele6 hates typing on smartphone keyboards.
[16:14:57] <emanuele6> i just read ClanLord's message
[16:15:13] <emanuele6> sounds like they wanted:   paste -sd' '
[16:20:49] <emanuele6> though obviously awk can do the same thing ;)
[16:20:56] <emanuele6>  awk -F'\n' -vRS= -vOFS=' ' '$NF="";1'
[16:21:44] <emanuele6> hmm, not quite
[16:21:50] <emanuele6> that removes the last line
[16:27:27] <emanuele6>  awk -F'\n|$' -vRS= -vOFS=' ' '$NF="";1'
[16:27:30] <emanuele6> now it works :)
[16:28:01] <emanuele6> nevermind
[16:33:16] <emanuele6> oh, for some reason i thought that the final newline would have caused problems but it actually does not
[16:36:29] <emanuele6> oh, also -vRS= makes awk treat "paragraphs" as records
[16:36:32] <emanuele6> nevermind then
[16:40:03] *** Joins: Torr (~Torr@user/torr)
[16:43:49] <emanuele6> i finally figured it out
[16:44:02] <emanuele6> awk -F'\n' -vRS=' ' -vOFS=' ' -vORS=' ' '$1=$1; END{printf "\n"}'
[16:45:20] <emanuele6> this is almost actually even better than   paste -sd' '   because it will print an extra space if there is an empty line at the end unlike the paste command
[16:46:05] <emanuele6> s/actually //
[16:47:08] <emanuele6> # printf '%s\n' 'a' '' 'b' 'c' 'd e' 'f' '' | awk -F'\n' -vRS=' ' -vOFS=' ' -vORS=' ' '$1=$1; END{printf "\n"}' | od -w50 -An -tc
[16:47:09] <shbot> emanuele6:    a           b       c       d       e       f              \n
[16:47:23] <emanuele6> # printf '%s\n' 'a' '' 'b' 'c' 'd e' 'f' '' | paste -sd' ' | od -w50 -An -tc
[16:47:24] <shbot> emanuele6:    a           b       c       d       e       f      \n
[16:48:52] <emanuele6> oh, wait, it should not print an extra space there
[16:49:07] <emanuele6> it is printing "f  \n", not just "f \n"
[16:54:13] <emanuele6> oh, yeah, it's printing an extra space because of ORS=" "
[16:54:39] <emanuele6> ORS should just be empty
[16:54:52] <emanuele6> # printf '%s\n' 'a' '' 'b' 'c' 'd e' 'f' '' | awk -F'\n' -vRS=' ' -vOFS=' ' -vORS= '$1=$1; END{printf "\n"}' | od -w50 -An -tc
[16:54:53] <shbot> emanuele6:    a           b       c       d   e       f          \n
[16:54:59] <emanuele6> # printf '%s\n' 'a' '' 'b' 'c' 'd e' 'f' '' | paste -sd' ' | od -w50 -An -tc
[16:55:00] <shbot> emanuele6:    a           b       c       d       e       f      \n
[16:55:22] <emanuele6> and that is because of $1=$1 being i condition
[16:55:40] <emanuele6> i was confused about the fact it was working, now it is clear why it was
[16:55:50] <emanuele6> # printf '%s\n' 'a' '' 'b' 'c' 'd e' 'f' '' | awk -F'\n' -vRS=' ' -vOFS=' ' -vORS= '{$1=$1}1;END{printf "\n"}' | od -w50 -An -tc
[16:55:51] <shbot> emanuele6:    a           b       c       d   e       f          \n
[16:57:16] <emanuele6> :/
[16:57:18] <emanuele6> whatever
[16:57:20] <emanuele6> too complex
[16:57:22] <Patsie> quite a monologue you are having there. ever thought of becoming an evil, world dominating bad guy?
[16:57:32] <Patsie> they like to monologue as well :P
[16:57:49] <emanuele6> i just thought it would be simpler
[16:57:57] <Patsie> especially when they have the good guy in a nasty position
[16:58:07] <emanuele6> hehe
[17:00:11] <emanuele6> if only RS="" didn't have a special meaning
[17:02:20] <emanuele6> as far as i can tell, the closest you can get to  paste -sd' '  without writing an actual awk script is   FS="\n" OFS=RS=ORS=" " that does prints an extra space at the end
[17:02:37] <emanuele6> s/does //
[17:02:39] <emanuele6> welp
[17:03:40] *** Quits: lopid (~lopid@user/lopid) (Quit: WeeChat 3.2)
[17:07:01] *** Quits: m4n (~emacs@ip5f5bd1ff.dynamic.kabel-deutschland.de) (Ping timeout: 256 seconds)
[17:38:41] *** Joins: lopid (~lopid@user/lopid)
[17:50:31] *** Joins: seninha (~seninha@user/seninha)
[18:01:25] *** Quits: node1 (~node1@user/node1) (Quit: Client closed)
[18:25:16] *** Quits: treble (~treble@user/treble) (Quit: WeeChat 3.3)
[18:29:18] *** Joins: treble (~treble@user/treble)
[18:37:07] *** Quits: treble (~treble@user/treble) (Quit: WeeChat 3.3)
[18:41:23] *** Joins: treble (~treble@user/treble)
[18:43:57] *** Quits: lockywolf (~lockywolf@vultr-seoul-openbsd.lockywolf.net) (Excess Flood)
[18:44:42] *** Joins: lockywolf (~lockywolf@vultr-seoul-openbsd.lockywolf.net)
[19:12:26] *** Joins: gaussianblue (~gaussianb@78-61-246-87.static.zebra.lt)
[19:15:01] *** Quits: Torr (~Torr@user/torr) (Ping timeout: 256 seconds)
[19:27:01] *** Parts: }8] (~}8]@107.173.83.81) ()
[19:56:10] *** Joins: junebug (~junebug@104-0-169-217.lightspeed.miamfl.sbcglobal.net)
[20:00:41] *** Quits: junebug (~junebug@104-0-169-217.lightspeed.miamfl.sbcglobal.net) (Max SendQ exceeded)
[20:01:01] *** Quits: gaussianblue (~gaussianb@78-61-246-87.static.zebra.lt) (Quit: leaving)
[20:01:09] *** Joins: junebug (~junebug@104-0-169-217.lightspeed.miamfl.sbcglobal.net)
[20:12:53] *** Joins: euandreh (~euandreh@2804:14c:33:9fe5:f767:b15a:e5b1:96f0)
[20:26:03] *** Joins: Torr (~Torr@user/torr)
[20:33:05] <seninha> Today's puzzle was pretty easy to do in awk: https://github.com/phillbush/aoc/blob/master/2021/day05a
[20:41:11] *** Quits: treble (~treble@user/treble) (Quit: WeeChat 3.3)
[20:44:01] <Patsie> phwa! you guys all have such simple solutions!
[20:44:21] <Patsie> I guess I just overcomplicated it :P
[20:44:57] *** Joins: node1 (~node1@user/node1)
[20:45:06] <OMGOMG> seninha: i look forward to seeing part 2
[20:45:11] *** Quits: Torr (~Torr@user/torr) (Ping timeout: 252 seconds)
[20:45:25] <OMGOMG> oh you did it already
[20:45:41] <emanuele6> these are mine https://0x0.st/-h6O.txt
[20:45:46] <emanuele6> i sent them earlier
[20:46:49] *** Quits: junebug (~junebug@104-0-169-217.lightspeed.miamfl.sbcglobal.net) (Ping timeout: 256 seconds)
[20:48:01] *** Joins: treble (~treble@user/treble)
[20:48:17] <seninha> emanuele6: damn, that's really simple and clever!
[20:49:28] <emanuele6> hehe :)
[21:09:47] *** Quits: yitz (~yitz@exercism/yitz) (Remote host closed the connection)
[21:11:37] *** Joins: yitz (~yitz@exercism/yitz)
[21:18:18] <aetnaeus> emanuele6: Grep can't have that problem by definition since it is line oriented
[21:18:34] <aetnaeus> (printf '%s\n' 'testa\'; read) includes a newline
[21:18:56] <emanuele6> ah, right
[21:20:47] <emanuele6> by the way, i built gawk with debugging symbols this morning to analyse the issue, but then i had to leave and i forgot to do it when i came back :P
[21:21:32] <aetnaeus> you are a braver man than I :P
[21:21:54] <emanuele6> i read the source code a bit before, but i couldn't figure out the part that was causing the issue
[21:22:29] <aetnaeus> I imagine the awk source is not for mere mortals
[21:22:41] <aetnaeus> and the GNU source even more
[21:22:44] <emanuele6> it does not look that bad to be honest
[21:22:57] <emanuele6> the code is surprisingly clean
[21:23:31] <emanuele6> at least the files i was reading
[21:24:12] <aetnaeus> maybe I will be bold enough to try it one day
[21:24:28] <aetnaeus> but mawk has already crushed my input bufferless dreams
[21:44:05] *** Quits: node1 (~node1@user/node1) (Quit: Client closed)
[21:47:58] <e36freak> Patsie: http://ix.io/3H7e
[21:48:55] *** Joins: junebug (~junebug@104-0-169-217.lightspeed.miamfl.sbcglobal.net)
[21:55:23] *** Quits: junebug (~junebug@104-0-169-217.lightspeed.miamfl.sbcglobal.net) (Ping timeout: 256 seconds)
[21:56:45] *** Joins: node1 (~node1@user/node1)
[22:01:14] *** Quits: seninha (~seninha@user/seninha) (Quit: Leaving)
[22:06:13] *** Quits: earnest (~earnest@user/earnestly) (Ping timeout: 256 seconds)
[22:08:15] *** Joins: seninha (~seninha@user/seninha)
[22:08:30] *** Joins: earnest (~earnest@user/earnestly)
[22:13:35] *** Quits: node1 (~node1@user/node1) (Quit: Client closed)
[22:42:59] *** Quits: lavaball (felix@31.204.155.215) (Ping timeout: 256 seconds)
[22:47:19] <Patsie> nice
