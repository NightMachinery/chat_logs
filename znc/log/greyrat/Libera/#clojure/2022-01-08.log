[00:02:55] *** Joins: matty_ma1 (~matt@129.222.239.110)
[00:03:17] *** Joins: AdmiralBumbleBee (~AdmiralBu@47.203.174.105)
[00:13:10] *** Quits: struchu (~struchu@staticline-31-183-169-189.toya.net.pl) (Quit: WeeChat 3.3)
[00:14:04] *** Joins: joe_colben (~joe____co@185.190.112.211)
[00:14:38] *** Joins: struchu (~struchu@staticline-31-183-169-189.toya.net.pl)
[00:15:04] *** Quits: struchu (~struchu@staticline-31-183-169-189.toya.net.pl) (Client Quit)
[00:20:10] *** Quits: shiranaihito_ (~textual@123-192-192-149.dynamic.kbronet.com.tw) (Quit: My MacBook Air has gone to sleep. ZZZzzzâ€¦)
[00:44:39] *** Joins: lxsameer (~lxsameer@user/lxsameer)
[00:46:37] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[00:54:23] *** Quits: joe_colben (~joe____co@185.190.112.211) (Remote host closed the connection)
[00:55:07] *** Joins: joe_colben (~joe____co@185.190.112.211)
[01:17:53] *** Joins: matty_ma1 (~matt@129.222.239.110)
[01:20:48] *** Quits: cranium (~cranium@user/cranium) (Quit: Leaving)
[01:26:16] *** Joins: OscarZ_ (~oscarz@95.175.104.170)
[01:33:27] *** Joins: sub0 (~bc8147f2@cerf.good1.com)
[01:42:08] *** jackhill is now known as KM4MBG
[01:42:35] *** KM4MBG is now known as jackhill
[01:50:57] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[02:00:45] *** Joins: matty_ma1 (~matt@129.222.239.110)
[02:00:47] *** Joins: evocatus (~evocatus@62.182.77.224)
[02:01:24] *** Quits: evocatus (~evocatus@62.182.77.224) (Remote host closed the connection)
[02:05:57] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[02:17:37] *** Quits: uncleyear (~ian@pppoe.178-66-158-61.dynamic.avangarddsl.ru) (Ping timeout: 240 seconds)
[02:19:16] *** Joins: matty_ma1 (~matt@129.222.239.110)
[02:20:57] *** Quits: cmiles74 (~miles@068-184-030-013.res.spectrum.com) (Ping timeout: 240 seconds)
[02:22:06] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Quit: leaving)
[02:23:37] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[02:26:55] *** Joins: OscarZ- (~oscarz@95.175.104.170)
[02:30:19] *** Quits: OscarZ_ (~oscarz@95.175.104.170) (Ping timeout: 256 seconds)
[02:35:28] *** Joins: matty_ma1 (~matt@129.222.239.110)
[02:40:39] *** Joins: AlaskanEmily (~AlaskanEm@user/alaskanemily)
[02:46:54] *** Quits: OscarZ- (~oscarz@95.175.104.170) (Quit: Leaving)
[02:47:22] *** Joins: atw (~user@2601:5c2:c500:76b0::1b94)
[02:57:26] *** Quits: joe_colben (~joe____co@185.190.112.211) (Remote host closed the connection)
[03:09:25] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[03:10:07] *** Joins: matty_ma1 (~matt@129.222.239.110)
[03:22:27] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[03:31:54] *** Joins: matty_ma1 (~matt@129.222.239.110)
[03:37:11] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[03:37:57] *** Quits: AdmiralBumbleBee (~AdmiralBu@47.203.174.105) (Read error: Connection reset by peer)
[03:37:57] *** Quits: atw (~user@2601:5c2:c500:76b0::1b94) (Ping timeout: 240 seconds)
[03:38:24] *** Joins: AdmiralBumbleBee (~AdmiralBu@47.203.174.105)
[03:38:33] *** Joins: matty_ma1 (~matt@129.222.239.110)
[03:44:08] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[03:57:23] *** Joins: atw (~user@2601:5c2:c500:76b0::cfa)
[04:00:32] *** Quits: AlaskanEmily (~AlaskanEm@user/alaskanemily) (Read error: Connection reset by peer)
[04:21:02] *** Joins: matty_ma1 (~matt@129.222.239.110)
[04:21:17] *** Quits: atw (~user@2601:5c2:c500:76b0::cfa) (Ping timeout: 240 seconds)
[04:54:12] *** Quits: sub0 (~bc8147f2@cerf.good1.com) (Quit: CGI:IRC (Error))
[05:15:15] *** Quits: seschwar (~seschwar@user/seschwar) (Quit: :wq)
[05:54:53] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[05:56:52] *** Joins: matty_ma1 (~matt@129.222.239.110)
[05:59:45] *** Joins: atw (~user@2601:5c2:c500:76b0::3e64)
[06:01:55] *** Quits: perro_ (~perro@072-191-245-069.res.spectrum.com) (Read error: Connection reset by peer)
[06:18:37] *** Quits: lxsameer (~lxsameer@user/lxsameer) (Ping timeout: 240 seconds)
[06:30:35] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[06:37:38] *** Joins: matty_ma1 (~matt@129.222.239.110)
[06:44:56] *** Quits: tuborgman (~tuborgman@pool-108-16-29-206.phlapa.fios.verizon.net) (Quit: WeeChat 2.8)
[06:45:13] *** Joins: tuborgman (~tuborgman@pool-108-16-29-206.phlapa.fios.verizon.net)
[07:15:15] *** Quits: tuborgman (~tuborgman@pool-108-16-29-206.phlapa.fios.verizon.net) (Quit: WeeChat 2.8)
[07:42:19] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[08:01:04] *** Joins: shiranaihito (~textual@123-192-192-149.dynamic.kbronet.com.tw)
[08:13:03] *** Joins: sss777sss (~ss@181.99.198.195)
[08:13:11] *** Parts: sss777sss (~ss@181.99.198.195) ()
[08:22:48] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Quit: leaving)
[08:23:03] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[08:24:40] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Client Quit)
[08:27:59] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[08:59:17] *** Quits: op2 (~op2@user/op2) (Ping timeout: 240 seconds)
[09:28:40] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[10:17:57] *** Quits: atw (~user@2601:5c2:c500:76b0::3e64) (Ping timeout: 240 seconds)
[10:22:54] *** Joins: matty_ma1 (~matt@129.222.239.110)
[10:29:57] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[11:39:57] *** Quits: zmt00 (~zmt00@user/zmt00) (Ping timeout: 240 seconds)
[11:45:21] *** Quits: ToxicFrog (~ToxicFrog@198-200-100-178.cpe.distributel.net) (Ping timeout: 245 seconds)
[11:52:14] *** Joins: op2 (~op2@user/op2)
[12:24:58] *** Joins: matty_ma1 (~matt@129.222.239.110)
[12:29:26] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[12:29:53] *** Joins: ToxicFrog (~ToxicFrog@198-200-100-178.cpe.distributel.net)
[12:41:16] *** Joins: libertyprime (~libertypr@118-92-72-229.dsl.dyn.ihug.co.nz)
[12:41:52] *** Joins: matty_ma1 (~matt@129.222.239.110)
[12:47:01] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[12:48:43] *** Joins: uncleyear (~ian@pppoe.178-66-158-61.dynamic.avangarddsl.ru)
[12:54:47] *** Quits: uncleyear (~ian@pppoe.178-66-158-61.dynamic.avangarddsl.ru) (Ping timeout: 256 seconds)
[13:14:01] *** Joins: matty_ma1 (~matt@129.222.239.110)
[13:14:01] *** Quits: libertyprime (~libertypr@118-92-72-229.dsl.dyn.ihug.co.nz) (Quit: leaving)
[13:18:44] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[13:24:11] *** Joins: dalek-caan (~Thunderbi@109.252.124.86)
[13:47:36] *** Joins: matty_ma1 (~matt@129.222.239.110)
[13:52:01] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[13:55:47] *** Joins: Kyuvi (~Kyuvi@dsl-hkibng31-58c38d-219.dhcp.inet.fi)
[14:20:27] *** Joins: lxsameer (~lxsameer@user/lxsameer)
[14:20:56] *** Quits: Kyuvi (~Kyuvi@dsl-hkibng31-58c38d-219.dhcp.inet.fi) (Ping timeout: 256 seconds)
[14:28:19] *** Joins: seschwar (~seschwar@user/seschwar)
[15:15:53] *** Quits: lunik1 (~lunik1@37.205.14.203) (Ping timeout: 256 seconds)
[15:39:27] *** Joins: joe_colben (~joe____co@185.190.112.211)
[15:40:58] *** Quits: lxsameer (~lxsameer@user/lxsameer) (Ping timeout: 256 seconds)
[15:55:45] *** Quits: joe_colben (~joe____co@185.190.112.211) (Remote host closed the connection)
[15:57:00] *** Joins: lunik1 (~lunik1@37.205.14.203)
[16:00:23] *** Joins: matty_ma1 (~matt@129.222.239.110)
[16:02:21] *** Quits: lunik1 (~lunik1@37.205.14.203) (Ping timeout: 256 seconds)
[16:03:16] *** Joins: lunik1 (~lunik1@37.205.14.203)
[16:08:35] *** Quits: lunik1 (~lunik1@37.205.14.203) (Ping timeout: 256 seconds)
[16:09:28] *** Joins: lunik1 (~lunik1@37.205.14.203)
[16:15:01] *** Quits: lunik1 (~lunik1@37.205.14.203) (Quit: :x)
[16:20:06] *** Joins: lunik1 (~lunik1@37.205.14.203)
[16:21:43] *** Quits: lunik1 (~lunik1@37.205.14.203) (Client Quit)
[16:29:21] *** Joins: lunik1 (~lunik1@37.205.14.203)
[16:58:41] *** Joins: cmiles74 (~miles@068-184-030-013.res.spectrum.com)
[17:04:50] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[17:07:49] *** Quits: cmiles74 (~miles@068-184-030-013.res.spectrum.com) (Ping timeout: 240 seconds)
[17:18:42] *** Joins: uncleyear (~ian@pppoe.178-66-158-61.dynamic.avangarddsl.ru)
[17:30:14] *** Joins: matty_ma1 (~matt@129.222.239.110)
[17:33:34] *** Joins: Kyuvi (~Kyuvi@dsl-hkibng31-58c38d-219.dhcp.inet.fi)
[17:34:13] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[17:35:50] *** Joins: nij- (~jin@2001-48F8-9021-806-0-0-0-619B-dynamic.midco.net)
[17:37:11] <nij-> Hello #clojure! I've heard that data are immutable in clojure. That's nice but the complexity analysis of algorithms would be different. How did you get around this when you first learn clojure?
[17:42:19] *** Joins: cmiles74 (~miles@068-184-030-013.res.spectrum.com)
[17:49:36] *** Joins: snystrom1 (~snystrom@cpe-98-26-26-26.nc.res.rr.com)
[17:50:50] *** Joins: matrox (~bc8147f2@cerf.good1.com)
[17:51:16] *** Quits: xsperry (~xs@user/xsperry) (Killed (NickServ (GHOST command used by aldkjsfasdf!~xs@cpe-188-129-71-242.dynamic.amis.hr)))
[17:51:42] *** Joins: xsperry (~xs@user/xsperry)
[17:53:58] <lunik1> The table at https://www.innoq.com/blog/st/2010/04/clojure-performance-guarantees/ shows the complexity of common operations on built-in strictures. It is mostly what you expect from mutable counterparts.
[17:59:10] <nij-> Thanks for the table. What I'm concerned could be a simpler one. For example, when updating an entry in an array, immutably we need to make a new copy of the whole array, right? Wouldn't that be slow, and how do we deal with the slowness?
[18:01:13] <wink> TFW you start to patch your db dependencies with println statements and only then notrice that the postgres json syntax WHERE field ? 'value' is interpreted as a prepared-statement placeholder m(
[18:02:31] <ToxicFrog> nij-: clojure data structures generally use structural sharing; when you "update" something it only copies the parts that are changed and re-uses the rest
[18:02:43] <lunik1> nij-: conceptually yes however clojure data structures are optimised for cases like this and the "new" array will share structure with the original
[18:02:46] <ToxicFrog> And since they're immutable it knows the shared parts won't be modified under it
[18:02:54] <ToxicFrog> This dramatically improves performance
[18:05:26] <nij-> That's kinda new to me. How do we achieve immutability and "sharing" at the same time? Suppose I have an old array A, and a new array B with one element updated from A. Now A and B shares most but one entry. If I mutate another entry of A, would that affect the corresponding entry in B?
[18:05:49] <nij-> Oh, the point is that it's *impossible* to mutate entries of A?
[18:08:35] <Para> nij-: What kind of software do you generally create? Complexity analysis rarely matters in Web. Also https://en.wikipedia.org/wiki/Persistent_data_structure
[18:10:34] <ridcully> in one of the talks RH said, that the goal was to have the main data structures only as much as 2x-4x slower IIRC
[18:11:01] <ridcully> and if you need the "mutable" performance, there are transients for that.  some functions, like into, use them under the hood
[18:12:16] <ridcully> also you can take from the java pool if you need certain characteristics
[18:12:30] <ToxicFrog> > Oh, the point is that it's *impossible* to mutate entries of A?
[18:12:32] <ToxicFrog> Yes. It doesn't matter that B and A share most of their data under the hood because that data cannot be changed in-place.
[18:12:52] <ToxicFrog> Conceptually you could think of it as copy-on-write applied to data structures rather than memory pages
[18:13:03] <nij-> Para: Thanks for sharing. I'm not a working man yet, but I'm trying to expand my horizon. 
[18:13:37] <Para> Facebook is/was built on PHP :) Speed rarely matters.
[18:14:03] <Para> (haven't kept up on what Facebook uses these days)
[18:14:18] <nij-> Nice wiki page. I guess my biggest doubt now is that - is the theory of complexity relating persistent data structure well-understood yet? Or people are still exploring it?
[18:14:53] <Para> Clojure doesn't feel very theoretical to me :)
[18:16:31] <aphyr> In practice, I've found vectors and hashmaps wind up being about 10x slower than their singlethreaded mutable java analogues ArrayList and HashMap
[18:16:48] *** Quits: cmiles74 (~miles@068-184-030-013.res.spectrum.com) (Ping timeout: 256 seconds)
[18:17:35] <Para> aphyr: Have you tried Java's ConcurrentHashMap in your stuff, btw? There's at least strong claims it's supposedly faster than java.util.HashMap since 1) it doesn't have to support broken use cases that juHM has to 2) for the aforementioned reason, it has been tweaked multiple times over the time.
[18:18:31] <aphyr> but as someone who does a lot of profiling/optimization work, these are generally not the dominating cost in my programs. There's usally one or two data structures with *super* intensive access patterns, and I swap those out for arrays, high-scale-lib's hashmap, or Bifurcan maps/sets/graphs/lists
[18:20:22] <aphyr> there's definitely an argument that In General Clojure programs tend to have a sort of diffuse slowness caused by tons of individually-inexpensive but in-aggregate slow map access/primitive-boxing, and I think that's a valid concern, but the safety/understandability improvements of the Clojure structures are usually worth it for me.
[18:21:22] <aphyr> Para: I'm almost a decade out of date on this, but I wound up moving to high-scale-lib for that--just saw too much contention in stock juc chms
[18:21:30] <Para> That's the general gist of why we work in more high level languages in general, isn't it? If performance was the only thing that mattered, we'd all be doing assembly.
[18:23:47] <Para> Heh, scales to 768 CPUs...reminds me of similar guarantee from Linux kernel from years ago, had a promise of having the most performant scheduler up to x cores, and when some Enterprise asked why not more, the answer was simply "no one would give us a server with more cores than that"
[18:23:56] <aphyr> hahaha
[18:24:02] <aphyr> Ah, the Azul hardware days
[18:24:43] <Para> Sort of related, the Zen4 CPUs announced this week look weird.
[18:24:54] <Para> They're literal post stamps, with serrated edges.
[18:34:30] *** Quits: snystrom1 (~snystrom@cpe-98-26-26-26.nc.res.rr.com) (Quit: leaving)
[18:34:40] *** Quits: dalek-caan (~Thunderbi@109.252.124.86) (Quit: dalek-caan)
[18:38:00] *** Joins: ns12 (~ns12@user/ns12)
[18:39:56] *** Joins: cmiles74 (~miles@068-184-030-013.res.spectrum.com)
[18:40:12] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 276 seconds)
[18:51:40] *** Joins: lxsameer (~lxsameer@user/lxsameer)
[19:03:45] *** Quits: Nahra (~user@static.161.95.99.88.clients.your-server.de) (Remote host closed the connection)
[19:05:50] <Solid> nij-: complexity analysis for persistent data structures is something that's pretty well understood (it's a concept that's been around for a while, independent of Clojure)
[19:06:52] <nij-> Solid: To get started with writing efficient programs in Clojure, is there any thing I should go through to understand the complexity analysis for persistent data structures?
[19:07:47] <Solid> (the real killer for complexity analysis is usually lazyness, but since Clojure is not actually very lazy it should mostly be fine)
[19:08:22] *** Quits: cmiles74 (~miles@068-184-030-013.res.spectrum.com) (Ping timeout: 256 seconds)
[19:08:56] <Solid> I guess the gold standard reference work is still Okasaki
[19:10:51] <Solid> how much these things matter in Clojure I can't really say (I'm quite the beginner too) but if my experience with Haskell translates at all then the best advice I can give is "don't worry about it; it won't matter (and if it does the profiler (and the intuition you develop along the way) is your friend)"
[19:25:26] <aphyr> nij-: In practice, you can assume vector, set, and map ops are O(1).
[19:26:38] <aphyr> They're technically, what, log32(n), plus GC overhead; you'll see a sort of tiered performance shift as the tree expands into new cachelines
[19:26:58] <aphyr> but generally this washes out compared to any other algorithmic stuff at play
[19:28:28] <aphyr> In general, I write the simplest/most idiomatic thing I can, and then profile with yourkit (or your fav jvm profiler); once I start seeing hotspots I go back and speed things up.
[19:28:38] <Para> that --^
[19:29:06] <Para> Idiomatic code matters way more than whether the solution is actually efficient or otherwise "perfect"
[19:29:41] <Para> The cost of any piece of written code comes from how hard it is to maintain; the less code you have and the more idiomatic and generally understandable by others without guidance it is, the better.
[19:30:11] <Para> Cost, of course, is a metric reserved for us working peons :)
[19:30:19] *** Quits: lxsameer (~lxsameer@user/lxsameer) (Ping timeout: 256 seconds)
[19:30:51] <aphyr> Yeah. I mean, I think a lot about cost; I'm often CPU/memory bound in my day to day job, and often saturate a 48-core box
[19:31:34] <aphyr> but 95% of that code is idiomatic Clojure, and 5% is Weird Because Of Performance
[19:32:00] *** Joins: lxsameer (lxsameer@user/lxsameer)
[19:32:02] <nij-> Got it. Thanks folks. 
[19:32:29] <nij-> Solid: Okasaki's work is one of that's concerning.. it seems very complicated, and my impression told me that it was "incomplete"
[19:32:39] <nij-> But it is also old.
[19:32:51] <aphyr> I've implemented some of the Okasaki structures and found them quite nice
[19:33:19] <aphyr> But like, unless you're doing PL research work, you really don't have to think about this stuff much.
[19:33:52] <aphyr> The profiler will generally make it Very Obvious which part of your program is slow, and that's when you can start caring
[19:34:40] <aphyr> I think I've had to care about the big-O complexity of Clojure structures... possibly zero times in roughly a decade of professional clojuring
[19:35:31] <Para> Usually when a data structure becomes too slow to me, it becomes too slow because of a magnitude explosion which requires heavy logic refactoring anyway.
[19:35:40] <aphyr> It's the constant factors that really kill pure datastructure perf, in my experience. Hash computation for key comparison on hashmap access, for instance.
[19:35:43] <Para> So it's not really the data structure that should be improved but the whole shebang :)
[19:36:13] *** Quits: lxsameer (lxsameer@user/lxsameer) (Ping timeout: 240 seconds)
[19:37:11] <aphyr> Agreed, Para 
[19:38:19] *** Joins: lxsameer (lxsameer@user/lxsameer)
[19:38:34] <aphyr> https://github.com/lacuna/bifurcan/blob/master/doc/comparison.md might be useful if you're shopping around JVM data structures, BTW
[19:39:44] <aphyr> I really like the bifurcan collections--their linear variants are usually pretty close to unsynchronized java.util collections, and they offer persistence & mergeability that works well with Clojure semantics
[19:40:06] <aphyr> in some cases they're significantly faster than the stock java collections
[19:41:54] <Para> Oh, Zachary Tellman :)
[19:42:10] <Para> Had a bit of a pause on where do I know that name from.
[19:42:20] <aphyr> Former coworker of mine!
[19:42:51] <Para> I'm a happy user of aleph and non-understander of manifold :)
[19:43:06] <Para> (manifold isn't that bad really, just never got into it)
[19:43:27] *** Joins: zmt00 (~zmt00@user/zmt00)
[20:06:04] <nij-> A good practice to get started with Clojure :)? I'm on emacs for 2 years (doom user) and had played with common lisp every now and then for a year.
[20:06:38] <nij-> For common lisp, there's a nice introductory text "Practical Common Lisp". Hoping to have something similar with Clojure.
[20:07:39] <Para> Clojure for the Brave and True (available for free online), Clojure the Essential Reference, Web Development with Clojure
[20:08:19] <Para> clojuredocs.org/ https://www.clojure-toolbox.com/ http://clojure-doc.org/ 
[20:09:54] <Para> https://guide.clojure.style/ 
[20:10:05] <Para> I suppose that's most of what we always recommend.
[20:24:44] <nij-> Thanks, Para. I might be shooting many noob questions. Is #clojure supposed to be a place for that?
[20:29:20] <ToxicFrog> I think this channel is fine for that
[20:31:20] *** Quits: kawpuh (~kawpuh@66.42.81.80) (Ping timeout: 252 seconds)
[20:31:30] *** Joins: kawpuh (~kawpuh@66.42.81.80)
[20:31:53] *** Quits: nuorzi (nuorzi@hilla.kapsi.fi) (Ping timeout: 250 seconds)
[20:32:00] *** Joins: nuorzi (nuorzi@hilla.kapsi.fi)
[20:34:29] *** Quits: lazr (~lazr@45.76.248.123) (Ping timeout: 250 seconds)
[20:35:45] *** Joins: lazr (~lazr@45.76.248.123)
[20:36:40] *** Joins: matty_ma1 (~matt@129.222.239.110)
[20:36:54] <nij-> In clojure, can I call the value of a global variable in a function (thus making it impure)?
[20:38:16] *** Quits: xerox (~edi@user/edi) (Ping timeout: 245 seconds)
[20:38:25] *** Joins: xerox (~edi@user/edi)
[20:40:07] *** Quits: lobotomy (~lobotomy@static.213.19.216.95.clients.your-server.de) (Ping timeout: 250 seconds)
[20:40:14] *** Joins: lobotomy (~lobotomy@static.213.19.216.95.clients.your-server.de)
[20:40:59] *** Quits: dim (~dimlibera@212.85.154.83) (Ping timeout: 250 seconds)
[20:41:11] *** Joins: dim (~dimlibera@2a02:2178:2:4:1658:d0ff:fe49:408c)
[20:43:41] *** Quits: fluxit (~fluxit@techsmix.net) (Ping timeout: 245 seconds)
[20:43:45] <Para> Of course.
[20:46:15] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[20:46:44] *** Joins: fluxit (~fluxit@techsmix.net)
[20:53:17] <nij-> Nice.
[20:54:08] <nij-> Common Lisp never upgraded itself since the ANSI standard. Clojure is different from this. What usually changes in an update? Does it often break the old codes?
[20:54:27] <aphyr> Almost never.
[20:55:16] <aphyr> I think there've been... maybe two times where I've seen something outright broken by a release, and it was a pretty straightforward fix to a library that defined some things which later got folded into clojure's internals.
[20:56:02] *** Quits: uncleyear (~ian@pppoe.178-66-158-61.dynamic.avangarddsl.ru) (Ping timeout: 256 seconds)
[21:00:07] *** Joins: dalek-caan (~Thunderbi@109.252.124.86)
[21:01:09] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[21:01:40] <nij-> So what did they upgrade?
[21:02:41] <nij-> Para: I'm reading the Brave and True.. such a great book. Having had experience with CL it doesn't seem too hard to go through the first chapters quickly.
[21:05:49] <ridcully> i think the biggest disturbance where the use of spec for macros so some libraries no longer compiled because they used "bad forms"
[21:06:26] <ridcully> and before that something like boolean? was added to core so it gave warnings with some libs, that defined that themself?
[21:07:56] *** Quits: lxsameer (lxsameer@user/lxsameer) (Ping timeout: 256 seconds)
[21:09:38] *** Joins: lxsameer (~lxsameer@user/lxsameer)
[21:14:53] <aphyr> nij-: The biggest breaking issue I found was when a library wrote a custom pair java type, in the clojure.core namespace, which was part of a patch that later got merged into Clojure itself, and that caused a name collision.
[21:15:21] <aphyr> adding `update` to clojure.core caused a bunch of warnings for people who defined their own update, but no breakage.
[21:24:45] *** Joins: schmudde (~schmudde@2001:b07:ae6:7d19:d0e4:1b5c:f3d0:b5fa)
[21:39:43] *** Joins: matty_ma1 (~matt@129.222.239.110)
[21:44:13] *** Quits: matty_ma1 (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[22:08:10] *** Joins: dadinn (~dadinn@cpc87065-finc18-2-0-cust67.4-2.cable.virginm.net)
[22:15:59] <nij-> ridcully aphyr: Thanks for sharing.
[22:16:27] <nij-> I'm not sure I understand how Clojure's atom solved the mutable-nature issue of OOP slots.
[22:16:57] <nij-> I can still updates the values of an atom (using swap!), so things can still change. Why is it better than mutable objects in the traditional sense?
[22:18:27] <Para> Explicit intent, plus atoms are thread safe.
[22:19:52] <nij-> What is "thread safe"?
[22:21:26] <Para> I'll point to https://en.wikipedia.org/wiki/Thread_safety :) Something I've noticed in the past few years is that Wikipedia's programming related articles have leaped in quality.
[22:22:52] <Para> This is the first time I've heard about "OOP slots", btw. Not that it probably matters much, ideas are more common than specific names for them.
[22:25:36] <nij-> Para thanks. Sorry if this is something standard. I taught myself programming by bothering nice people on IRC. (I'm also willing to stop and take no offense if asked so.)
[22:28:04] <sobel> nij-: you're still on IRC among self-teachers :)
[22:28:43] <sobel> please feel free to bother all the nice people on #postgresql as well when you want to level up on sql/postgresql
[22:29:30] <nij-> sobel :)
[22:29:46] *** Quits: dalek-caan (~Thunderbi@109.252.124.86) (Quit: dalek-caan)
[22:34:48] <nij-> Daniel Higginbotham is such a great writer, with lots of humor. Thanks again Para :)
[22:37:57] <nij-> Does the fact that clojure programs run on JVMs makes them slow?
[22:38:50] <nij-> My impressions about VMs in general are that they are (1) portable, but are (2) slower and less efficient.
[22:41:03] <sobel> you should benchmark it
[22:41:32] <sobel> the simple answer to your question is no
[22:42:29] <nij-> with caveats?
[22:42:35] <sobel> also no
[22:46:23] *** Quits: Kyuvi (~Kyuvi@dsl-hkibng31-58c38d-219.dhcp.inet.fi) (Ping timeout: 256 seconds)
[22:47:15] <technomancy> nij-: the fact that clojure programs run on the JVM affects memory usage and startup time more than overall performance
[22:48:13] <technomancy> the JVM has the best GC in the world by a pretty significant margin, so doing clojure-like coding on another runtime would be unlikely to be faster, unless you're specifically writing imperative programs
[22:50:48] <Para> JVM is the result of thousands of people years put into a single runtime. And these are not average people, but PhDs and other Genuinely Smart People.
[22:51:44] <technomancy> it's really good at what it's designed to do (long running processes on big servers) and hilariously bad at things it's not, like CLI toolinng
[22:52:24] <Para> Remember when they were still optimistic about that and -server flag wasn't on by default? :)
[22:52:34] <technomancy> lol
[22:52:55] <Para> But yeah, JVM does the long runs really well.
[22:53:11] <Para> I've met a few 1000+ day processes.
[22:53:35] <Para> Not that I'd recommend that, usually that sort of runtime means everything in it is outdated.
[22:54:02] *** Quits: gaustin (sid356092@id-356092.helmsley.irccloud.com) ()
[22:54:49] <technomancy> dang; my emacs irc instance is only up to 883 days
[22:57:14] <nij-> That clears my doubt. Thanks :)
[23:01:57] *** Quits: schmudde (~schmudde@2001:b07:ae6:7d19:d0e4:1b5c:f3d0:b5fa) (Ping timeout: 240 seconds)
[23:05:45] *** Quits: matrox (~bc8147f2@cerf.good1.com) (Quit: CGI:IRC (Session timeout))
[23:15:19] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Quit: leaving)
[23:24:04] *** Joins: matty_ma1 (~matt@129.222.239.110)
[23:31:42] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[23:36:12] <TimMc> nij-: I don't know if this has been mentioned yet, but another perfectly valid strategy is to use mutable data structures within some compute-heavy local context and then export immutable versions from the API.
[23:36:27] <TimMc> Just hide the mutation where no one else can see it. :-)
[23:38:52] *** Joins: struchu (~struchu@staticline-31-183-169-189.toya.net.pl)
[23:43:25] *** Joins: AlaskanEmily (~AlaskanEm@user/alaskanemily)
[23:55:42] *** Quits: shiranaihito (~textual@123-192-192-149.dynamic.kbronet.com.tw) (Quit: My MacBook Air has gone to sleep. ZZZzzzâ€¦)
