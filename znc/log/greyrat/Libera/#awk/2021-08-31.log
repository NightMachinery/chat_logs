[00:03:52] *** Quits: besnn (~besnn@user/besnn) (Ping timeout: 245 seconds)
[00:10:18] *** Joins: emanuele6 (~emanuele6@user/emanuele6)
[00:11:48] *** Joins: besnn (~besnn@user/besnn)
[00:43:37] *** Quits: nmz (~nmz@adsl-64-237-236-189.prtc.net) (Ping timeout: 252 seconds)
[00:51:49] *** Quits: besnn (~besnn@user/besnn) (Read error: Connection reset by peer)
[01:40:10] *** Quits: Torr (~Torr@user/torr) (Ping timeout: 240 seconds)
[01:44:41] *** Joins: wwilliam (~afernande@user/wwilliam)
[01:44:51] <wwilliam> awk '/Average:/{printf("Memory Average: %.2f%\n"),(($3-$5-$6)/($2+$3)) * 100 }'
[01:45:12] <wwilliam> can someone explain verbose what the above line does please?
[01:47:27] <emanuele6> the parentheses are misleading
[01:48:07] <emanuele6> awk '/Average:/ { printf "Memory Average: %.2f%\n", (($3-$5-$6)/($2+$3)) * 100 }'
[01:48:30] <wwilliam> Misleading?
[01:48:36] <^[> Should the second '% be %%?
[01:48:58] <emanuele6> for correctness it should
[01:49:03] <emanuele6> awk '/Average:/ { printf "Memory Average: %.2f%%\n", (($3-$5-$6)/($2+$3)) * 100 }'
[01:50:11] <emanuele6> wwilliam: it is quite simple; if the line contains "Average:", it (allegedly) computes the Memory Average using the following formula: (($3-$5-$6)/($2+$3)) * 100
[01:50:35] <wwilliam> Memory usage or free memory?
[01:51:02] <emanuele6> awk does not decide that
[01:51:16] <emanuele6> it just elaborates the input text
[01:51:29] <emanuele6> were do you get the input from?
[01:52:00] <wwilliam> sar -r -f /var/log/sa/sa$day
[01:52:17] <emanuele6> how does that look like?
[01:52:23] <wwilliam> 08:40:01 PM kbmemfree   kbavail kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty
[01:52:25] <wwilliam> 08:50:01 PM   2153152 378202828  11655828      2.94      3204 372870260  11229172      2.82 171396212 206820612      5048
[01:52:31] <wwilliam> !paste
[01:53:03] <emanuele6> send the line that says Average
[01:53:17] <wwilliam> https://paste.debian.net/1209702/
[01:53:33] <wwilliam> That line does not exist.
[01:53:41] <emanuele6> i can see it
[01:53:47] <emanuele6> it is the last line of the paste
[01:54:06] <wwilliam> Oh yes sorry
[01:54:34] <emanuele6> ok, so it is doing /kbavail-%memused-kbbuffers)/(kbmemfree+kbavail) * 100
[01:54:46] <emanuele6> (kbavail-%memused-kbbuffers)/(kbmemfree+kbavail) * 100
[01:55:05] <emanuele6> so it should be the free memory i think
[01:55:16] <emanuele6> not sure
[01:55:24] <emanuele6> but it says "Memory Average"
[01:55:27] <wwilliam> OK, Thank you for your time.
[01:55:58] <wwilliam> what %.2f%\n" that means?
[01:56:50] <emanuele6> two fractional digits
[01:57:18] <emanuele6> # awk '{printf "%.2f%%\n" $0}' <<< '2.103'
[01:57:24] <shbot> emanuele6: awk: not enough args in printf(%.2f%%
[01:57:25] <shbot> emanuele6: 2.103)
[01:57:25] <shbot> emanuele6: etc... ( http://ix.io/3xuc )
[01:57:31] <emanuele6> oh oops
[01:57:33] <emanuele6> missed a comma
[01:57:36] <emanuele6> # awk '{printf "%.2f%%\n", $0}' <<< '2.103'
[01:57:37] <shbot> emanuele6: 2.10%
[01:57:47] <emanuele6> # awk '{printf "%.2f%%\n", $0}' <<< '2.3'
[01:57:48] <shbot> emanuele6: 2.30%
[01:57:58] <emanuele6> # awk '{printf "%.2f%%\n", $0}' <<< '3'
[01:57:59] <shbot> emanuele6: 3.00%
[01:58:12] <wwilliam> Thank you.
[01:58:41] <emanuele6> oh, i guess it means "Average Free Memory"
[01:59:16] <wwilliam> How did you come to that conclusion?
[01:59:39] <emanuele6> because the formula looks like the formula for Free Memory 
[01:59:49] *** Quits: lgc (~lgc@user/lgc) (Quit: WeeChat 3.2-dev)
[01:59:50] <emanuele6> and it is only using the data from the "Average" line
[02:00:08] <wwilliam> Excellent Thank you.
[02:33:58] *** Quits: lavaball (felix@31.204.155.215) (Remote host closed the connection)
[03:18:36] *** Joins: ttmrichter (~ttmrichte@user/ttmrichter)
[03:24:37] *** Quits: ttmrichter (~ttmrichte@user/ttmrichter) (Quit: Client closed)
[03:34:35] *** Joins: src (~src@user/src)
[05:15:33] *** Quits: earnestly (~earnest@user/earnestly) (Ping timeout: 244 seconds)
[05:18:45] *** Joins: nmz (~nmz@adsl-72-50-7-12.prtc.net)
[05:18:47] *** Joins: downunder (~downunder@110.151.43.81)
[05:30:25] *** Quits: vlm (~vlm@user/vlm) (Quit: "")
[05:34:11] *** Joins: vlm (~vlm@user/vlm)
[05:34:58] *** Quits: neshpion (~neshpion@gateway/tor-sasl/neshpion) (Quit: neshpion)
[06:36:46] *** Quits: src (~src@user/src) (Ping timeout: 252 seconds)
[07:08:01] *** Quits: seninha (~seninha@user/seninha) (Remote host closed the connection)
[07:12:49] *** Joins: samir (~azureuser@user/samir)
[07:51:04] *** Parts: samir (~azureuser@user/samir) (WeeChat 2.8)
[08:20:31] *** Quits: roarde (~roarde@user/roarde) (Quit: Leaving)
[09:54:34] *** Quits: int (~int@0x4.cx) (Quit: see you :))
[09:54:48] *** Joins: int (~int@0x4.cx)
[10:59:14] *** Joins: lgc (~lgc@user/lgc)
[12:03:50] *** Joins: lavaball (felix@31.204.155.215)
[12:51:31] *** Joins: adip (~adip@aeje201.neoplus.adsl.tpnet.pl)
[12:58:05] *** Quits: mingdao (~mingdao@wireguard/tunneler/mingdao) (Ping timeout: 250 seconds)
[12:58:29] <adip> hi. I'm a newbie. I've found something like this online: /pattern/ {for(i=1;i<=2;i++) {getline;print}}   I want to modify it but I'm not sure how to do it. 
[12:59:44] <adip> can I insert pattern matchine between getline and print? I wanted to do some further processing but can't figure out how to do it without piping to another file. (mby a function? idk)
[13:00:12] <Patsie> tell us what you _actually_ want to do
[13:00:29] <Patsie> with _actual_ data and _actual_ examples
[13:00:49] <adip> I want to print X lines after the pattern. (I have that)
[13:01:28] <adip> from that I want to print only lines with another /pattern/
[13:01:48] <adip> can I do it without piping to second awk?
[13:03:19] <geirha> definitely, but there are still some vague parts. Some example input and wanted output would help
[13:04:19] <adip> one sec
[13:05:25] *** Joins: earnestly (~earnest@user/earnestly)
[13:06:56] <adip> ok, here's my example  https://dpaste.com/GNKATBW9E
[13:08:24] <Patsie> awk '($2 == "hdd")'
[13:09:32] <geirha> yeah, the /host/ match doesn't seem to make any difference
[13:10:24] <geirha> If it did, maybe something like this   awk '/host/{ n = 3 } --n > 0 && $2 == "hdd"'
[13:12:16] <adip> geirha: why does your example use n = 3 ?
[13:14:17] <adip> It works, but I don't get it why value is so high. n = 4 prings 2 lines after /host/
[13:14:24] <Patsie> because he doe a pre-decrement (--n) and compares it to greater than zero
[13:14:45] <Patsie> so technically n=3 would check 2 lines after the 'host' match
[13:15:23] <Patsie> n=3; then 2>0 (true), 1>0 (true again) 0>0 (false)
[13:15:42] <Patsie> n=4 would check the 3 lines after the host match
[13:16:03] <Patsie> but why cehck the host line at all?
[13:16:09] <Patsie> why not just get all 'hdd' lines ?
[13:17:16] <adip> ah, ok
[13:18:18] <Patsie> so simple and elegant: awk '($2 == "hdd")'
[13:18:31] <adip> "why not just get all 'hdd' lines" because I _need_ 2 first lines in each host. 
[13:18:57] <Patsie> there's pleny of hosts that don't have any lines
[13:20:20] <adip> well, this is the data I'm working with. 
[13:20:27] <adip> thanks for help :)
[13:21:17] <Patsie> but yeah: ($3 == "host") { n = 2 } (n-- > 0) && ($2 == "hdd")
[13:21:51] <Patsie> similar to geirha's (except it checks an exact match of 'host' in field 3
[13:22:00] <Patsie> and not just anywhere on the line
[13:22:56] <adip> can I check specific field for a pattern?
[13:24:33] <Patsie> $3 ~ /pattern/
[13:25:18] <Patsie> so: awk '$3 ~ /^host$/' would also work
[13:50:07] *** Joins: MysteriousSilver (silver@user/mysterioussilver)
[14:02:02] *** Joins: mingdao (~mingdao@wireguard/tunneler/mingdao)
[14:41:58] *** Quits: downunder (~downunder@110.151.43.81) (Quit: WeeChat 3.2)
[14:57:37] *** Joins: seninha (~seninha@user/seninha)
[15:24:55] *** wwilliam is now known as Guest7127
[15:24:56] *** Quits: Guest7127 (~afernande@user/wwilliam) (Killed (calcium.libera.chat (Nickname regained by services)))
[15:37:37] *** Joins: besnn (~besnn@user/besnn)
[16:15:28] *** Joins: Arauto (~Arauto@168.195.101.249)
[16:48:55] *** Quits: besnn (~besnn@user/besnn) (Ping timeout: 244 seconds)
[17:01:38] *** Joins: besnn (~besnn@user/besnn)
[17:12:04] *** Quits: siraben (~siraben@user/siraben) (Quit: Bridge terminating on SIGTERM)
[17:12:04] *** Quits: psydroid (~psydroid@user/psydroid) (Quit: Bridge terminating on SIGTERM)
[17:12:11] *** Quits: jmcantrell (~jmcantrel@user/jmcantrell) (Quit: Bridge terminating on SIGTERM)
[17:14:42] *** Joins: psydroid (~psydroid@user/psydroid)
[17:18:37] *** Joins: Torr (~Torr@user/torr)
[17:19:26] *** Joins: siraben (~siraben@user/siraben)
[17:19:26] *** Joins: jmcantrell (~jmcantrel@user/jmcantrell)
[18:07:12] *** Joins: samir (~azureuser@user/samir)
[18:38:26] <adip> Patsie: why does your awk command use -- operator instead of ++ ? I've tried to rework it to ++ and I'm getting wrong results
[18:57:21] *** Joins: src (~src@user/src)
[19:05:51] *** Quits: Arauto (~Arauto@168.195.101.249) (Ping timeout: 256 seconds)
[19:26:06] *** Joins: cloud (~cloud@user/ansible)
[19:29:31] *** Quits: besnn (~besnn@user/besnn) (Ping timeout: 252 seconds)
[19:32:18] *** Joins: besnn (~besnn@user/besnn)
[19:45:04] *** Quits: cloud (~cloud@user/ansible) (Quit: Client closed)
[19:46:41] <yitz> Rework it how? 
[19:47:00] <yitz> "See pattern, set 'we want 2 lines'. Want lines? Print and reduce"
[20:13:24] <Patsie> adip: because it should count down
[20:13:27] <Patsie> and not up
[20:13:34] <Patsie> it counts down the number of lines you want
[20:14:00] <Patsie> like yitz said: when you find your pattern, set an X-amount of lines and count down until you reach zero
[20:14:33] <Patsie> otherwise it would be a whole lot more complicated
[20:17:33] <Patsie> awk 'BEGIN { n = 999 } ($3 == "host") { n = 0 } (n++ < 2) && ($2 == "hdd")'
[20:18:21] <Patsie> not a _whole_ lot more complicated, but have to take into account that n starts with 0, so have to set it to something bigger than 2 at the start (BEGIN) of your script
[20:48:57] *** Joins: roarde (~roarde@user/roarde)
[20:54:20] *** Quits: besnn (~besnn@user/besnn) (Ping timeout: 244 seconds)
[21:37:09] *** Joins: besnn (~besnn@user/besnn)
[22:10:47] *** Quits: crabbedhaloablut (~crabbedha@user/crabbedhaloablut) (Quit: No Ping reply in 180 seconds.)
[22:11:29] *** Joins: crabbedhaloablut (~crabbedha@user/crabbedhaloablut)
[22:15:07] *** Quits: odc (sid197788@id-197788.helmsley.irccloud.com) (Ping timeout: 240 seconds)
[22:16:17] *** Joins: odc (sid197788@id-197788.helmsley.irccloud.com)
[22:48:56] <adip> I changed it to {0=0
[22:49:26] <adip> {n=0} n++ <= 7
[22:50:18] <adip> example with data https://dpaste.com/3KNH8CX67 
[22:51:01] <geirha> that will treat it as if zeroth line matched
[22:51:12] <geirha> because n will initially be 0
[22:53:11] <geirha> in other words, the first four results are false positives
[22:55:04] <adip> the lines with ssd in $2 are the wrong ones. they shouldn't be printed 
[22:55:50] <adip> this error doesn't happen with smaller limit. for example {n=0} n++ <= 4 doesn't have false positives
[22:56:09] <geirha> awk '$3 == "host" { f = 0 } /host (k02r11nvm05|k02r12nvm01)$/ { f = 1 } f && $5 == "up"'
[22:57:44] <geirha> different approach, printing all "up"s until the next host line is encountered
[22:58:41] <adip> interesting, how does it detect next host line?
[22:59:01] <geirha> $3 == "host" { f = 0 }
[22:59:36] <geirha> Whenever it encounters a host line, it lowers the flag, whether it was raised or not. Next it is only raised if the "right" host line is encountered
[22:59:49] <geirha> finally, print all "up" lines if flag is raised (1)
[23:03:25] <adip> nice
[23:19:17] *** Quits: lgc (~lgc@user/lgc) (Quit: WeeChat 3.2-dev)
[23:31:07] *** acidsys is now known as cranberry
[23:31:26] *** cranberry is now known as Lysergsaeure
