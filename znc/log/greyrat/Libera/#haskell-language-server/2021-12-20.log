[01:08:09] <anton-latukha[m]> <michaelpj[m]> "Is there some other tool that we..." <- Yes. We can.
[01:08:42] <anton-latukha[m]> But we would need to host enough of the fast cache storage somewhere nearby GitHub.
[01:12:48] <anton-latukha[m]> Thou, DHall for me seems inevitable good solution in HLS case. It would allow to manage all `{*.cabal,*.project,stack*,*.yml}` at once (or as different subdomains of configuration) & give strong type-checking & guarantees.
[01:14:41] <anton-latukha[m]> * & guarantees. It is a Haskell-host language, with a strong Haskell influence (semantic also).
[02:04:58] *** Joins: coot (~coot@89-64-85-93.dynamic.chello.pl)
[02:09:57] <anton-latukha[m]> Creator was actually surprised how fast the language was adopted in the DevOps'es. & the initial Kubernetes support get out of hands pretty fast - community driven it home to full support.
[02:13:19] <anton-latukha[m]> No wonder. Kubernetes YAML files are 10 kilometres long.
[02:14:02] <anton-latukha[m]> Then DHall got great success in DevOps at all.
[02:41:04] *** Joins: yoshitsugu (uid529929@id-529929.hampstead.irccloud.com)
[02:47:29] *** Quits: coot (~coot@89-64-85-93.dynamic.chello.pl) (Quit: coot)
[03:01:09] <anton-latukha[m]> +====
[03:01:10] <anton-latukha[m]> Ok.
[03:01:26] <anton-latukha[m]> Seems like https://github.com/haskell/haskell-language-server/pull/1508 was pretty important.
[03:01:57] <anton-latukha[m]> Would try to rebase it.
[04:01:14] <anton-latukha[m]> Rebase seems successful: https://github.com/haskell/haskell-language-server/pull/2512 (so far idk if test would pass).
[06:11:43] <anton-latukha[m]> +====
[06:14:41] <anton-latukha[m]> I recently converted a number of not able to be merged PRs to draft. So we see what can be actively worked & engaged to be merged. & for contributors to signal that they consider that the PR code is ready to be checked by converting back into green.
[06:42:00] <sm> > stack cradle without source paths will not work
[06:42:00] <sm> Confirmed, jneira. If you have any hie.yaml in a multi-package stack project, it must list the components/paths
[07:12:57] *** Quits: terrorjack (~terrorjac@2a01:4f8:1c1e:509a::1) (Quit: The Lounge - https://thelounge.chat)
[07:14:23] *** Joins: terrorjack (~terrorjac@2a01:4f8:1c1e:509a::1)
[07:17:48] *** Quits: Morrow (~quassel@bzq-110-168-31-106.red.bezeqint.net) (Remote host closed the connection)
[11:21:47] *** Joins: coot (~coot@89-64-85-93.dynamic.chello.pl)
[15:45:58] *** Joins: arrowd (~arr@2.94.236.140)
[16:04:35] *** Quits: coot (~coot@89-64-85-93.dynamic.chello.pl) (Quit: coot)
[16:44:51] *** Quits: yoshitsugu (uid529929@id-529929.hampstead.irccloud.com) (Quit: Connection closed for inactivity)
[17:15:46] *** Joins: ttylec (~ttylec@89-64-103-195.dynamic.chello.pl)
[17:17:36] <ttylec> hi! I've encountered issue with hls on vscode, similar to this one: https://github.com/haskell/haskell-language-server/issues/2118 It was however crash due to empty list for foldl'.
[17:17:59] <ttylec> I identified that the issue is caused by module name plugin.
[17:18:44] <ttylec> I think that it may take me less time to make a patch than to make an issue, as the code repo where I experience that issue is closed, so I would need to distil it...
[17:20:20] <ttylec> but I would appreiciate if someone could guide me a bit where to start looking; there is no foldl1 in the source code module name plugin (ofc, it was empty list for foldl1, not foldl' as I wrote above, typo).
[17:21:21] <ttylec> so I guess it is level up; any hints?
[17:36:19] <michaelpj[m]> ttylec: sounds annoying to debug :( maybe have a look at the source of the Foldable module and see if any other partial functions in there are defined in terms of foldl1? and then look for those?
[17:36:32] <michaelpj[m]> we have embarrassingly many partial functions in HLS...
[17:43:00] *** Quits: ttylec (~ttylec@89-64-103-195.dynamic.chello.pl) (Ping timeout: 240 seconds)
[17:54:47] *** Joins: ttylec (~ttylec@89-64-103-195.dynamic.chello.pl)
[17:54:56] <ttylec> so you think that it should be somewhere in the plugin?
[17:55:34] <ttylec> not that something level up gathers something from different plugins and then calls foldl1 on that?
[17:59:50] <michaelpj[m]> ttylec: no, I meant `Foldable` in base
[17:59:57] <michaelpj[m]> something from there that calls foldl1, maybe
[18:00:14] <michaelpj[m]> it does seem like there are a few occurrences in HLS, but I don't know if they're responsible
[18:00:58] <michaelpj[m]> hmm, doesn't look like anything obviously calls that
[18:11:52] <ttylec> ok, got it; thanks
[18:15:20] <anton-latukha[m]> +====
[18:15:38] <anton-latukha[m]> Public announcement:
[18:16:10] <anton-latukha[m]> Caching builds are made fault-tolerant. This means they cache & reuse the results produced as-is.
[18:17:18] <anton-latukha[m]> Please do not abort `Caching` workflows, as that aborting would lead to +1h of build waits for everybody per CI cycle.
[18:18:57] <anton-latukha[m]> * Please, do
[18:20:03] <anton-latukha[m]> * Please, do, * everybody per every CI cycle, * CI cycle until that aborting would be manually triaged/resolved by maintainers.
[18:20:27] <anton-latukha[m]> * Please, do, * everybody per every CI cycle, * CI cycle until that aborting would be manually fixed/triaged/resolved by maintainers.
[18:26:36] *** Quits: ttylec (~ttylec@89-64-103-195.dynamic.chello.pl) (Ping timeout: 256 seconds)
[18:33:27] *** Joins: ttylec (~ttylec@89-64-103-195.dynamic.chello.pl)
[18:40:47] *** Quits: ttylec (~ttylec@89-64-103-195.dynamic.chello.pl) (Quit: leaving)
[19:15:03] <jneira[m]> anton-latukha: I have another hypothesis about windows, I think it has been related with the cabal_dir changes
[19:15:30] <jneira[m]> (as I suspected after checking store paths)
[19:15:59] <jneira[m]> cache has been invalidated by changes in the global cabal config file
[19:16:19] <jneira[m]> and we don't have that file included in the cache key
[19:16:34] <jneira[m]> (and maybe it does not worth)
[19:18:38] <anton-latukha[m]> jneira[m]: That may be. Because we were talking about, the current way of doing this is `cabal v2-freeze`, but it was decided that `index-state` is enough & so it was designed such.
[19:18:42] *** Joins: coot (~coot@2a02:a310:e03f:8500:7248:52ac:817b:7fb4)
[19:18:55] <anton-latukha[m]> * decided that since having `index-state` is, * `index-state` is should be enough &
[19:19:50] <anton-latukha[m]> Indeed, `cabal` needs to be included into the hash.
[19:20:05] <jneira[m]> hmm yeah a freeze file could have avoid it
[19:20:19] <anton-latukha[m]> As I remeber, GitHub expressions already allow to just supply the list of files to form a hash.
[19:21:03] <jneira[m]> as the fields invalidating the cache are 3 afair, extra-lib-dirs is on of them
[19:26:21] <anton-latukha[m]> Looked into the `cabal v2-freeze` file.
[19:26:53] <anton-latukha[m]> Seems every field there for hash is worth to depend on.
[19:28:26] <anton-latukha[m]> Does `*.project` files get accounted in `cabal v2-freeze`?
[19:28:48] <anton-latukha[m]> * (question to everyone in the chat room) Does `*.project`
[19:33:49] <anton-latukha[m]> s/Does `*.project` files get accounted in `cabal v2-freeze`?/(question to everyone in the chat room) Do `*.project` files get accounted in `cabal v2-freeze`?/
[19:35:30] <jneira[m]> if you use cabal-x.project cabal will look for cabal-x.project.local and cabal-x.project.freeze
[19:36:48] <jneira[m]> (try `cabal freeze --project-file cabal-x.project`
[19:37:12] <jneira[m]> jneira[m]: I would check though
[19:37:24] <jneira[m]> * --project-file cabal-x.project`)
[19:37:49] <anton-latukha[m]> Ok. Then in CI we can use `cabal freeze --project-file cabal.project`, since workflows set the proper project file there.
[19:38:51] <anton-latukha[m]> It is an important question, because `.freeze` overrides over the `.project`. I simply do not know/sure if `.project` gets accounted in `.freeze`.
[19:38:54] <jneira[m]> does it take global config field values?
[19:39:23] <jneira[m]> cause it does not it would not make the work
[19:40:07] <anton-latukha[m]> jneira[m]: I know that `.freeze` is directly influenced by `.cabal`.
[19:41:12] <jneira[m]> in this case the source of cache invalidation has been $CABAL_DIR/config
[19:42:18] <jneira[m]> and most of other changes (deps and flags) are covered by hackage index and .cabal files
[19:42:34] <anton-latukha[m]> I am asking to merge the cache refresh nevertheless. As refreshing the cache now would allow a faster further CI development.
[19:42:57] <jneira[m]> ok
[19:43:50] <anton-latukha[m]> I think that using `freeze` properly would improve the situation. As as we noted - key does not account for changes in `.cabal` file, which should be fixed.
[19:43:53] <jneira[m]> re bumping hackage2 index by 1, the unique caveat is the annoying warning cabal shows when the index timestamp does not exist
[19:44:31] <jneira[m]> anton-latukha[m]: oh yeah, I think we had (maybe in another repo?) */*.cabal
[19:44:34] <anton-latukha[m]> In the work the `project` & `/config` going to be checked also
[19:45:10] <jneira[m]> * oh yeah, I think we had at some point (maybe in another repo?) `**/*.cabal`
[19:45:44] <jneira[m]> but it worths to give a try to freeze files, yeah
[19:47:42] *** Quits: coot (~coot@2a02:a310:e03f:8500:7248:52ac:817b:7fb4) (Quit: coot)
[19:48:01] <anton-latukha[m]> In the process we would look through practice does `/config` entries & `.project` entries change the `.freeze` (because they should).
[19:49:13] <anton-latukha[m]> Or we can just smush them into the hash & forget about that.
[19:49:54] <anton-latukha[m]> * about that & cabal changes influence there totally.
[19:51:38] <anton-latukha[m]> s/does/do/
[19:52:01] <anton-latukha[m]> s/does/do/, s/` (because they should)./`./
[19:53:10] <anton-latukha[m]> I think we should go the latter.
[19:53:30] <anton-latukha[m]> * the latter (probably).
[19:53:44] <jneira[m]> well actually there are only some concrete fields in the hash, but hardcore them is not a good idea imo
[19:55:03] <anton-latukha[m]> The `cabal v2-freeze` is to be run inside CI, it is done just to fingerprint the configuration for the cache keys.
[19:58:36] <anton-latukha[m]> * cache keys, it is not saved into the project & does not require anything in the project.
[20:11:51] <wz1000> alanz: I made some more progress with the 9.2 branch, but now its failing on ExactPrint related things. I feel like I need an actual expert
[20:14:26] <anton-latukha[m]> But well, also - just caching everything would mean that all changes that do not influence the build results, as even adding additional customizations & unused options, a introducing any lower bound restriction, layout changes & changes in `.cabal` comments would produce a cache update.
[20:19:16] <anton-latukha[m]> Also, considering that `caching` only save a dependencies. `.project` + `cabal v2-freeze` seems enough, as all important `.cabal` cachanges for dependencies end-up in `.freeze`.
[20:31:13] *** Joins: Morrow (~quassel@bzq-110-168-31-106.red.bezeqint.net)
[20:37:42] <anton-latukha[m]> As agreed in: https://matrix.to/#/!oOjZFsoNYPAbTEgSOA:libera.chat/$-Wv69VWdRDLGm-KNPvn5HkCGdRAwd1Ygk1601yE8db0?via=libera.chat&via=matrix.org&via=monoid.al
[20:39:49] <anton-latukha[m]> Can somebody review it, so fix the current cache for the project.
[20:46:49] <anton-latukha[m]> (oh, it is about: https://github.com/haskell/haskell-language-server/pull/2515)
[21:20:38] <michaelpj[m]> opinions: is it acceptable to use "HLS" as an abbreviation for `haskell-language-server` in our docs? I think yet
[21:20:40] <michaelpj[m]> *yes
[21:33:53] *** Quits: Morrow (~quassel@bzq-110-168-31-106.red.bezeqint.net) (Remote host closed the connection)
[21:35:14] *** Joins: Morrow (~quassel@bzq-110-168-31-106.red.bezeqint.net)
[21:36:34] <anton-latukha[m]> I think that HLS is a common use abbreviation.
[21:39:09] <anton-latukha[m]> Also CI `hls` uses `hls` as an executable name: https://github.com/haskell/haskell-language-server/blob/e1949dd5e37db2b0a3b5490bc52976fd154d794d/.github/workflows/test.yml#L108. & there are 78 HLS mentions just in that file.
[21:39:50] <anton-latukha[m]> s/`hls`//
[21:40:11] <anton-latukha[m]> s/Also CI `hls` uses `hls` as an executable name: https://github.com/haskell/haskell-language-server/blob/e1949dd5e37db2b0a3b5490bc52976fd154d794d/.github/workflows/test.yml#L108. & there are 78 HLS mentions just in that file./Also CI uses `hls` as an executable name: https://github.com/haskell/haskell-language-server/blob/e1949dd5e37db2b0a3b5490bc52976fd154d794d/.github/workflows/test.yml#L108. & there are 78 HLS
[21:40:11] <anton-latukha[m]> mentions in that file alone./
[21:55:27] *** Quits: arrowd (~arr@2.94.236.140) ()
[22:10:55] <michaelpj[m]> But that's the CI definition, which has a very different audience to the user documentation
[22:14:23] <anton-latukha[m]> I just mentioned the file I am currently working with as an example of common use of HLS abbreviation.
[22:42:24] <michaelpj[m]> yep, we use it a lot for sure!
[22:42:36] *** Joins: coot (~coot@89-64-85-93.dynamic.chello.pl)
[22:50:19] <alanz> wz1000, I thought you might. I already started looking, will continue
[23:35:01] *** Quits: juhp (~juhp@128.106.188.82) (Ping timeout: 240 seconds)
[23:38:12] *** Joins: juhp (~juhp@128.106.188.82)
[23:40:07] *** Quits: coot (~coot@89-64-85-93.dynamic.chello.pl) (Quit: coot)
[23:40:45] *** Joins: coot (~coot@89-64-85-93.dynamic.chello.pl)
