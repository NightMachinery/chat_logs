[00:00:02] *** Quits: MajorBiscuit (~MajorBisc@62-52-102.netrun.cytanet.com.cy) (Ping timeout: 240 seconds)
[00:00:31] <MacGyver> yawkat: Re: grover's algorithm, they're not.
[00:01:14] *** Joins: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani)
[00:06:11] <Alipha> from what i'm understanding of https://eprint.iacr.org/2019/1146.pdf (specifically the table on page 29), you can't even get that close to 2^(key/2) "cost" because it's not feasible to exceed this "MAXDEPTH" number?
[00:08:30] *** Quits: Guyver2 (Guyver@guyver2.xs4all.nl) (Quit: Going offline, see ya! (www.adiirc.com))
[00:15:17] *** Quits: semisimple (~semisimpl@user/semisimple) (Ping timeout: 240 seconds)
[00:16:17] *** Quits: gproto23 (~gproto23@user/gproto23) (Ping timeout: 240 seconds)
[00:17:34] *** Joins: semisimple (~semisimpl@user/semisimple)
[00:17:47] <dostoyevsky2> https://github.com/openbsd/src/blob/master/sys/dev/softraid.c#L5149 <- the official way to encrypt disks on OpenBSD is via softraid -- interesting is that they don't let you choose the encryption algo.  It's AES-XTS ... and iv is, again, block number...
[00:25:31] *** Joins: lord| (~lordpipe@user/lordpipe)
[00:39:25] *** Quits: inlight (~inlight@user/inlight) (Ping timeout: 268 seconds)
[00:39:50] *** Joins: inlight (~inlight@157.35.8.6)
[00:39:50] *** Quits: inlight (~inlight@157.35.8.6) (Changing host)
[00:39:50] *** Joins: inlight (~inlight@user/inlight)
[00:51:16] <yawkat> Alipha: my understanding is that naive grover is a sequential algo with intermediate quantum states, which makes it very awkward for large search spaces
[00:52:28] <yawkat> You basically have a bunch of refinement steps running over and over again on a single quantum states, which is just ugly for parallelism. 
[00:53:08] <MacGyver> Practicality of actually *running* Grover's aside, I'm not aware of any claims that you can shortcut your job by focusing on the block space instead of the key space.
[01:00:06] <yawkat> Yea I'm not sure how it would work, maybe you could search for a block collision in the cipher, but that would require running the encryption oracle in the quantum algo, which is asking a bit much
[01:10:12] *** Quits: Gallomimia (~Gallomimi@node-1w7jra2a2gqpzcm2rr3tqbxht.ipv6.telus.net) (Remote host closed the connection)
[01:11:10] *** Joins: Gallomimia (~Gallomimi@node-1w7jra2a2gqpyv8bcmil1mb1v.ipv6.telus.net)
[01:16:30] *** Quits: peterhil_ (~peterhil@dsl-hkibng32-54fb56-2.dhcp.inet.fi) (Remote host closed the connection)
[01:17:06] *** Joins: MajorBiscuit (~MajorBisc@62-52-102.netrun.cytanet.com.cy)
[01:38:21] *** Quits: kish` (~sid742412@user/aqua) (Ping timeout: 276 seconds)
[01:41:57] *** Joins: sdfgsdfg (~sdfgsdfg@user/sdfgsdfg)
[02:05:05] *** Joins: kish` (~sid742412@user/aqua)
[02:07:04] *** Quits: byteskeptical (~amnesia@user/byteskeptical) (Quit: Lost terminal)
[02:22:02] *** Quits: madagest (~madage@user/madage) (Remote host closed the connection)
[02:22:07] *** Quits: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani) (Remote host closed the connection)
[02:22:15] *** Joins: madage (~madage@user/madage)
[02:22:29] *** Joins: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani)
[02:45:57] *** Quits: zer0bitz (~zer0bitz@2001:2003:f444:a000:81c1:fdbc:2b2:4c4a) (Read error: Connection reset by peer)
[02:51:45] *** Quits: inlight (~inlight@user/inlight) (Remote host closed the connection)
[03:03:48] *** Quits: smach (~savio@177.12.49.3) (Read error: Connection reset by peer)
[03:21:17] *** Quits: MajorBiscuit (~MajorBisc@62-52-102.netrun.cytanet.com.cy) (Ping timeout: 240 seconds)
[03:34:34] *** Quits: machinedgod (~machinedg@24.105.81.50) (Ping timeout: 256 seconds)
[03:37:51] *** Joins: cwebber` (~user@147-219-168-070.res.spectrum.com)
[03:40:06] *** Quits: cwebber (~user@user/cwebber) (Ping timeout: 268 seconds)
[03:41:02] *** Quits: Wulf (~Wulf@user/wulf) (Ping timeout: 240 seconds)
[03:42:50] *** Joins: Wulf (~Wulf@user/wulf)
[03:45:10] *** Quits: System_Error (~SystemErr@user/systemerror) (Remote host closed the connection)
[03:53:20] *** Quits: ses (uid38151@id-38151.hampstead.irccloud.com) (Quit: Connection closed for inactivity)
[04:02:54] *** Quits: rardiol (~quassel@user/rardiol) (Ping timeout: 256 seconds)
[04:08:41] *** Joins: blyat-73 (~hjgkjhgkj@46.235.96.249)
[04:14:57] *** Quits: blyat-73 (~hjgkjhgkj@46.235.96.249) (Ping timeout: 240 seconds)
[04:30:37] *** Quits: PJBoy (~PJBoy@user/pjboy) (Ping timeout: 240 seconds)
[04:39:30] *** Joins: machinedgod (~machinedg@24.105.81.50)
[04:41:50] *** Quits: OneWheelGeek (~OneWheelG@alpha.straybits.org) (Remote host closed the connection)
[04:42:27] *** Joins: OneWheelGeek (~OneWheelG@alpha.straybits.org)
[04:45:39] *** Quits: defjam (~eb0t@90.210.94.161) (Ping timeout: 250 seconds)
[04:51:18] *** Joins: defjam (~eb0t@90.198.61.46)
[04:52:26] *** Quits: chomwitt (~chomwitt@2a02:587:dc19:a500:12c3:7bff:fe6d:d374) (Ping timeout: 245 seconds)
[04:55:39] <ericonr> dostoyevsky2: arguably not allowing people to choose the encryption algo is the best design 
[04:55:50] <ericonr> Strong defaults are the best 
[04:56:04] *** Joins: rardiol (~quassel@user/rardiol)
[04:56:10] *** Quits: CryptoClub (~fafs@88.red-83-34-81.dynamicip.rima-tde.net) (Ping timeout: 256 seconds)
[05:01:41] *** Quits: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani) (Remote host closed the connection)
[05:02:07] *** Joins: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani)
[05:02:45] *** Quits: dude12312414 (~test@gateway/tor-sasl/dude12312414) (Remote host closed the connection)
[05:03:54] *** Joins: dude12312414 (~test@gateway/tor-sasl/dude12312414)
[05:21:29] *** Joins: xenoterracide (~xenoterra@2600:1700:71d4:810:7809:8396:63f0:6697)
[05:36:18] *** Joins: smach (~savio@177.12.49.3)
[05:36:41] *** Quits: smach (~savio@177.12.49.3) (Remote host closed the connection)
[05:37:07] *** Joins: smach (~savio@177.12.49.3)
[05:38:26] *** Quits: smach (~savio@177.12.49.3) (Client Quit)
[05:40:17] *** Quits: xenoterracide (~xenoterra@2600:1700:71d4:810:7809:8396:63f0:6697) (Ping timeout: 240 seconds)
[05:41:40] *** Joins: igemnace (~ian@user/igemnace)
[06:05:06] *** Joins: xenoterracide (~xenoterra@2600:1700:71d4:810:7809:8396:63f0:6697)
[06:05:25] *** Quits: Gallomimia (~Gallomimi@node-1w7jra2a2gqpyv8bcmil1mb1v.ipv6.telus.net) (Quit: Leaving)
[06:05:36] *** Quits: sdfgsdfg (~sdfgsdfg@user/sdfgsdfg) (Quit: ZzzZ)
[06:22:52] *** Quits: machinedgod (~machinedg@24.105.81.50) (Ping timeout: 256 seconds)
[06:36:20] *** Joins: llorllale (~llorllale@2607:9880:3a18:69:a1e1:617f:5617:eda3)
[06:40:10] *** Quits: Hash (~Hash@hashsecurity.org) (Ping timeout: 268 seconds)
[06:40:24] *** Joins: Hash_ (~Hash@hashsecurity.org)
[06:42:57] *** Joins: mikail (~mikail@2a02:c7f:bc1f:4a00:fc9:3da5:3e1e:8303)
[06:43:28] *** Joins: Gallomimia (~Gallomimi@node-1w7jra2a2gqpz2pl0fn2jvwdp.ipv6.telus.net)
[06:48:05] *** Quits: stiell (~stiell@gateway/tor-sasl/stiell) (Remote host closed the connection)
[06:48:27] *** Joins: stiell (~stiell@gateway/tor-sasl/stiell)
[06:49:17] *** Quits: mikail (~mikail@2a02:c7f:bc1f:4a00:fc9:3da5:3e1e:8303) (Ping timeout: 240 seconds)
[06:54:58] *** Quits: rardiol (~quassel@user/rardiol) (Ping timeout: 268 seconds)
[07:06:15] *** Quits: igemnace (~ian@user/igemnace) (Remote host closed the connection)
[07:27:47] *** Joins: mikail (~mikail@2a02:c7f:bc1f:4a00:fc9:3da5:3e1e:8303)
[07:28:13] *** Quits: mikail (~mikail@2a02:c7f:bc1f:4a00:fc9:3da5:3e1e:8303) (Client Quit)
[07:29:13] *** Quits: dez (uid92154@user/dez) (Quit: Connection closed for inactivity)
[07:42:29] *** Quits: dude12312414 (~test@gateway/tor-sasl/dude12312414) (Quit: THE RAM IS TOO DAMN HIGH)
[07:45:57] *** Quits: xenoterracide (~xenoterra@2600:1700:71d4:810:7809:8396:63f0:6697) (Ping timeout: 240 seconds)
[07:47:19] *** Joins: xenoterracide (~xenoterra@2600:1700:71d4:810:7809:8396:63f0:6697)
[07:57:52] *** Joins: sdfgsdfg (~sdfgsdfg@user/sdfgsdfg)
[08:04:35] *** Quits: xenoterracide (~xenoterra@2600:1700:71d4:810:7809:8396:63f0:6697) (Remote host closed the connection)
[08:16:32] *** Joins: ravan (~ravan@user/ravan)
[08:29:05] *** Joins: blyat-73 (~hjgkjhgkj@46.235.96.249)
[08:40:35] *** Joins: eruditass (uid248673@id-248673.uxbridge.irccloud.com)
[09:01:37] *** Quits: cwebber` (~user@147-219-168-070.res.spectrum.com) (Ping timeout: 240 seconds)
[09:19:12] *** Quits: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani) (Ping timeout: 276 seconds)
[09:25:14] *** Joins: BOKALDO (~BOKALDO@user/bokaldo)
[09:26:56] *** Joins: node1 (~node1@user/node1)
[09:33:30] *** Quits: EmmyNoether (~EmmyNoeth@193.29.56.54) (Remote host closed the connection)
[09:33:40] *** Joins: EmmyNoether (~EmmyNoeth@yoke.ch0wn.org)
[09:33:58] *** Quits: node1 (~node1@user/node1) (Quit: Client closed)
[09:58:11] *** Joins: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani)
[10:04:03] *** Quits: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani) (Ping timeout: 276 seconds)
[10:16:48] <rk4> qtrrp
[10:17:25] * rk4 nods
[10:17:32] <rk4> i said hello
[10:18:12] *** Joins: node1 (~node1@user/node1)
[10:18:18] *** Joins: bdd (5841cbed9d@2604:bf00:561:2000::1b7)
[10:20:38] <rk4> we were talking about TOTP yesterday, https://news.ycombinator.com/item?id=29633414 reminded me, specifically " I have a script I can run on any of my machines to generate the OTP code (so I don't need a phone/app). "
[10:21:39] <rk4> feels like quite a lot of devs in my country do some variation on this, sometimes it's a script, most times it's integrated into their password manager
[10:22:12] <int-e> And sometimes it's a webcam pointed at an RSA token?
[10:23:11] <rk4> oh i wish i'd seen an RSA token!
[10:23:30] *** Quits: blyat-73 (~hjgkjhgkj@46.235.96.249) (Remote host closed the connection)
[10:23:53] *** Joins: blyat-73 (~hjgkjhgkj@46.235.96.249)
[10:27:21] <bdd> for high stakes accounts that don't (yet) offer u2f/webauthn, yubikeys' OATH applet is an option if you have a threat model that somehow need to tolerate compromise of password manager.  neither the desktop nor the mobile apps are particularly easy on the eyes, but hey.
[10:27:22] *** Quits: blyat-73 (~hjgkjhgkj@46.235.96.249) (Remote host closed the connection)
[10:27:44] *** Joins: blyat-73 (~hjgkjhgkj@46.235.96.249)
[10:31:17] *** Quits: blyat-73 (~hjgkjhgkj@46.235.96.249) (Remote host closed the connection)
[10:31:40] *** Joins: blyat-73 (~hjgkjhgkj@46.235.96.249)
[10:32:34] *** Joins: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani)
[11:11:55] *** Joins: betelgeuse9 (~betelgeus@94-225-47-8.access.telenet.be)
[11:15:55] *** Quits: betelgeuse9 (~betelgeus@94-225-47-8.access.telenet.be) (Read error: Connection reset by peer)
[11:17:02] *** Joins: betelgeuse9 (~betelgeus@94-225-47-8.access.telenet.be)
[11:17:23] *** Quits: betelgeuse9 (~betelgeus@94-225-47-8.access.telenet.be) (Read error: Connection reset by peer)
[11:21:59] *** Quits: node1 (~node1@user/node1) (Quit: Client closed)
[11:31:20] *** Quits: curium (~curium@mail.clouded.monster) (Remote host closed the connection)
[11:37:06] *** Joins: MajorBiscuit (~MajorBisc@62-52-102.netrun.cytanet.com.cy)
[11:38:56] <Sofia> Hello world. I'm not promoting this but can someone confirm this strategy is generally safe or elaborate why not. If I understand correctly the concerns with timing-based side channels are relevant only when then operations over a secret key leak timing relative to public information and the secret key itself; for a secret key which is reused many times such that statistical analysis can
[11:38:59] <Sofia> reconstruct the key from the fractional-bit leaks. Does this imply it is safe to use a variable-time handshake if your keys are single-use / ephemeral? Does this safety also follow if you scalar mult your **static secret** first with a random secret blinding factor, then the public key of your peer, then the inverse of your blinding factor? Lets say we're compiling to WebAssembly (without the
[11:39:01] <Sofia> constant time extension), so we cannot have any assurances that our code is constant-time.
[11:41:39] *** Joins: gproto23 (~gproto23@user/gproto23)
[11:42:10] *** Joins: cvmn (~caveman@gateway/tor-sasl/caveman)
[11:42:28] *** Quits: MajorBiscuit (~MajorBisc@62-52-102.netrun.cytanet.com.cy) (Ping timeout: 256 seconds)
[11:44:23] *** Joins: MajorBiscuit (~MajorBisc@c-001-015-014.client.tudelft.eduvpn.nl)
[11:49:43] <ericonr> For what it's worth, I believe most constant time impls assume underlying primitives (add, mul) are constant time. Unless the wasm VM does some wild stuff, I don't think a constant time extension is a requirement. You should still use code that does the cryptographic operations in a constant number of operations, and that should mostly translate to wasm, I think
[11:50:41] <ericonr> Sofia: Note, I know very little about wasm, so this is mostly conjecture. Can you point me towards some reference for the constant time extension, whatever it is?
[11:52:43] <Sofia> I should have better stated. I'm not thinking in the wasm context myself, that was merely an example where we cannot control it. I'm asking if going variable time under these specific conditions is safe?
[11:53:00] <Sofia> ericonr: https://cseweb.ucsd.edu/~dstefan/pubs/watt:2019:ct-wasm.pdf
[11:53:02] <Sofia> https://github.com/PLSysSec/ct-wasm
[11:53:15] <Sofia> Or. https://arxiv.org/abs/1808.01348
[11:53:32] *** Joins: Haohmaru (~Haohmaru@195.24.53.110)
[11:54:15] *** Joins: chomwitt (~chomwitt@94.66.63.187)
[11:55:27] <ericonr> Got it. In that case, ct-wasm is *not* a requirement for constant time crypto on wasm, which I think is important to have clear; it is, however, probably a good way to implement constant time crypto that's optimized for wasm
[11:55:37] <Sofia> By variable-time I don't just mean "unable to verify constant-time" I mean "able to actively go faster by specializing"
[11:55:51] <ericonr> Re. your actual question, no idea, you'll have to wait for the knowledgeable folk :p
[11:57:09] *** Quits: cvmn (~caveman@gateway/tor-sasl/caveman) (Ping timeout: 276 seconds)
[11:57:17] * Sofia shall wait :)
[12:03:57] *** Joins: curium (~curium@mail.clouded.monster)
[12:04:00] <Sofia> Ex vartime. https://docs.rs/curve25519-dalek/latest/src/curve25519_dalek/edwards.rs.html#721-753
[12:05:30] *** Joins: igemnace (~ian@user/igemnace)
[12:07:20] <Sofia> Another. https://docs.rs/curve25519-dalek/latest/src/curve25519_dalek/backend/serial/scalar_mul/vartime_double_base.rs.html#20-62
[12:08:31] <Sofia> Don't think either of these apply to the example I presented. However, my question is more general.
[12:10:18] <riv> > Does this imply it is safe to use a variable-time handshake if your keys are single-use
[12:10:48] *** Quits: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani) (Ping timeout: 276 seconds)
[12:11:58] <riv> It may not be possible to infer even 1 bit of the secret from the timing side channel if it is only used once
[12:12:43] <riv> It is still considered a weakness if you have a timining side channel, so just ensure that all secrets are processed in constant time.
[12:13:44] *** Joins: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani)
[12:16:38] <Sofia> FWIW I expect the blinding method to be slower than the constant time. Maybe different if we batch many handshakes. As that'd be a context where we might warrant looking closer at the threat model while trying to go faster.
[12:20:43] *** Joins: PJBoy (~PJBoy@user/pjboy)
[12:20:48] *** Joins: CryptoClub (~fafs@88.red-83-34-81.dynamicip.rima-tde.net)
[12:26:10] *** Joins: Guyver2 (~Guyver@guyver2.xs4all.nl)
[12:31:00] *** Quits: blyat-73 (~hjgkjhgkj@46.235.96.249) (Remote host closed the connection)
[12:31:25] *** Joins: blyat-73 (~hjgkjhgkj@46.235.96.249)
[12:36:24] <Sofia> Sometimes you must accept a side channel exists. Constant time computation and secret independent memory accesses only go so far. The most important detail is that **whatever leakage** does occur, is either irrelevant (indistinguishable from noise) or unobservable (a threat model might allow the adversary to see the network, but not run a local thread on the same core; where packets are batched an
[12:36:26] <Sofia> relatively coarse timers independent to the cryptography).
[12:37:28] <riv> I disagree
[12:40:06] <Sofia> riv: Mind elaborating?
[12:41:09] <Sofia> In the blinding case; the blinding step would need to be constant time still (scalar-scalar mult). There would exist leakage, but the leakage would be irrelevant to the secret.
[12:42:27] <riv> if you have a timing side channel, you are likely to have a vulnerability - so you need to address it. You can address it correctly in a simple way that's known to solve the problem or you can do stuff that tries to add statistical noise or whatever, a much less valid approach.
[12:47:13] <Sofia> riv: That blinding approach does not "add statistical noise" it decouples the noise from the secret, such that the observable time reveals nothing about the secret itself..
[12:48:28] <Sofia> Assuming we can do scalar-scalar multiply in constant time (and cheap). Without assuming we can do scalar-point multiply in constant time. IIUC that is safe.
[12:53:30] <Sofia> Either way, I do not intend to do variable-time handshakes. I was just asking if any leakage concerns remain when the key is only used once, or when the key is blinded.
[12:54:34] <Sofia> IIUC either property suffices to permit vartime implementations.
[12:56:36] *** Quits: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani) (Remote host closed the connection)
[12:56:41] <riv> the time depends on the secret - since it is only used once it's unlikely that the weakness can be used on its own to exploit anything/infer any bits of the secret
[12:57:02] <riv> still needs fixed though
[13:07:29] <Sofia> For the single-use key, yes. That is different to the blinding case, with a many-use key.
[13:08:11] <Sofia> You could apply the same blinding hardening technique to the single use key, if it made any difference for the threat model or security proofs.
[13:08:25] *** Joins: powftw (uid448161@id-448161.lymington.irccloud.com)
[13:08:53] <riv> that's known threats
[13:09:02] <riv> you should make it constant time for unknown threats
[13:10:20] *** Quits: aleck1 (~aleck@user/aleck) (Quit: Leaving)
[13:10:43] <Sofia> If you can. I do agree. Either way, even with constant time computations and secret independent memory accesses, there are still side channel leakages, you must determine are either irrelevant or unobservable by the adversaries defended against by the threat model
[13:11:34] <Sofia> er, adversaries considered under the threat model*
[13:13:12] <Sofia> You don't have "known threats" and "unknown threats" you have "an adversary with more than practical power to be conservative". Ex. Full instruction timings in the worst case. Where some vartime schemes certainly break even with the blinding, while others would not.
[13:14:05] <riv> known threat: adversary can re-run this 100 times and use averaging to estimate the time over a noisy channel very accurately to infer the bits of the key
[13:14:22] <Sofia> Ex. A branch per bit would read out the entire key into that trace. But any reasonable optimization which would actually go fast, couldn't be so revealing anyway.
[13:14:26] <riv> unknown threat: we leak information through this side channel, but as far as we know there is no exploit on that
[13:16:40] <Sofia> You cannot defend against an unknown threat. You can only define a more powerful adversary that you're able to defend against, to rule out variations with less power.
[13:17:35] *** Joins: aleck (~aleck@user/aleck)
[13:17:39] <riv> I think that what I have said is clear even if you don't like the label I used for it
[13:20:04] <Sofia> For context. I'm in the research phase for an optimizing compiler I'm designing for the domains of cryptography and graphics. Cryptography is very sensitive to dataflow and we need to measure all side channels we consider under a formally specified threat model, along with assumptions. Some assumptions we can verify by testing the specific target processor. I.e. Verifying all instructions are
[13:20:07] <Sofia> correctly implemented and all relevant instructions are constant time. If we detect any instruction-argument combination is not constant time, then we can add a rule in the optimizer to specialize to defend against the leakage on the specific processor.
[13:21:36] <Sofia> riv: Actually, I'm not sure how to interpret your statement because your label is not sufficiently defined. Are you saying that "constant time" is sufficient against arbitrary unknown threats? That doesn't sound right. The constant time property exactly defends against a class of adversaries, which fall under the known / covered adversaries of the threat model. 
[13:22:25] <riv> I'm trying to distinguish between a weakness and an exploitable vulnerability
[13:23:13] <riv> things like timing side channels are weaknesses, if they can be used (possibly in combination) for an exploit that is upgraded to a vulnerability
[13:23:26] <riv> I'm saying that weaknesses should be fixed even if they are not vulnerabilities
[13:23:59] <riv> because someone might come up with a new smarter way to exploit it that isn't currently known
[13:33:27] <Sofia> I have a few relevant details to track in my compiler. (1) how many times a value is used (largely for memory optimizations, but also to enforce mostly linear usage properties; ex. a key-nonce is never reused after committing to send a ciphertext (despite using an MRAE where that isn't catastrophic)). (2) causal dataflow constraints (Ex. multiple users under a shared service cannot interfere with
[13:33:30] <Sofia> the other's data or communicate via the service through explicit dataflow; but might leak information through the load of the shared service). (3) classified values are not allowed to leak through any side channel. If you do not declassify a message before processing it, the message will be processed in constant time.
[13:34:14] *** Quits: gproto23 (~gproto23@user/gproto23) (Read error: Connection reset by peer)
[13:35:04] <Sofia> For graphics; (4) how much precision do we require? Allowing the optimizer to introduce error towards reducing computation time and memory consumption.
[13:35:54] *** Joins: gproto23 (~gproto23@user/gproto23)
[13:40:22] <Sofia> riv: Okay. Then you may rest assured that I want to close all the side channels I can, and make it explicitly clear where side channels are not covered by the threat model. Not all of this applies to cryptography. Notably covert channels are especially harder to eliminate. Ex. Run a loop to heat up the processor to trigger thermal throttling, to observably slow down the receiver. Perhaps on a
[13:40:24] <Sofia> separate core.
[13:42:45] *** Joins: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani)
[13:42:49] <Sofia> If that is in your threat model, then you'll need seL4 level scheduling controls to define a reasonable policy which prevents spending so much power.
[13:46:23] <Sofia> That example might not be so hard to defend against, but covert channels in general are much worse due to the cooperation between the sender and receiver.
[13:48:17] *** Hash_ is now known as Hash
[13:48:31] *** Joins: machinedgod (~machinedg@24.105.81.50)
[13:48:58] *** Quits: sdfgsdfg (~sdfgsdfg@user/sdfgsdfg) (Quit: ZzzZ)
[13:49:34] *** Joins: Lord_of_Life_ (~Lord@user/lord-of-life/x-2819915)
[13:49:58] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 256 seconds)
[13:52:20] *** Lord_of_Life_ is now known as Lord_of_Life
[13:52:51] *** Quits: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani) (Ping timeout: 276 seconds)
[14:09:06] *** Joins: r-g (~r-g@51.159.55.86)
[14:25:29] *** Joins: toastloop (toastloop@user/toastloop)
[14:31:55] *** Quits: Sofia (~sofia@gateway/tor-sasl/sofia) (Remote host closed the connection)
[14:32:44] *** Joins: Sofia (~sofia@gateway/tor-sasl/sofia)
[14:33:07] *** Quits: igemnace (~ian@user/igemnace) (Remote host closed the connection)
[14:33:11] *** Joins: rardiol (~quassel@user/rardiol)
[14:34:30] *** Quits: yousser (~yousser@92.249.170.58) (Quit: Leaving)
[14:38:13] *** Quits: eck (~root@user/eck) (Quit: PIRCH98:WIN 95/98/WIN NT:1.0 (build 1.0.1.1190))
[14:38:43] *** Joins: eck (~root@user/eck)
[14:42:58] *** Joins: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani)
[14:45:57] *** Quits: ravan (~ravan@user/ravan) (Remote host closed the connection)
[14:46:05] *** Joins: ravan (~ravan@user/ravan)
[14:47:36] *** Quits: trebuh (~trebuh@2001:41d0:a:15c7::1) (Remote host closed the connection)
[14:48:09] *** Joins: trebuh (~trebuh@2001:41d0:a:15c7::1)
[14:49:09] *** Quits: trebuh (~trebuh@2001:41d0:a:15c7::1) (Client Quit)
[14:49:17] *** Joins: trebuh (~trebuh@2001:41d0:a:15c7::1)
[14:57:31] *** Joins: toastloopex (toastloop@user/toastloop)
[15:00:45] *** Quits: deusexbeer (~hedeo@37-146-236-2.broadband.corbina.ru) (Quit: Konversation terminated!)
[15:00:50] *** Quits: toastloopex (toastloop@user/toastloop) (Remote host closed the connection)
[15:00:54] *** Quits: toastloop (toastloop@user/toastloop) (Ping timeout: 268 seconds)
[15:12:09] *** Quits: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani) (Ping timeout: 276 seconds)
[15:27:43] *** Joins: menace (~someone@ppp-93-104-175-20.dynamic.mnet-online.de)
[15:27:43] *** Quits: menace (~someone@ppp-93-104-175-20.dynamic.mnet-online.de) (Changing host)
[15:27:43] *** Joins: menace (~someone@user/menace)
[15:27:52] *** menace is now known as Deknos
[15:39:43] *** Joins: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani)
[15:43:14] *** Joins: inlight (~inlight@157.35.64.71)
[15:43:14] *** Quits: inlight (~inlight@157.35.64.71) (Changing host)
[15:43:14] *** Joins: inlight (~inlight@user/inlight)
[15:49:46] *** Quits: inlight (~inlight@user/inlight) (Ping timeout: 260 seconds)
[15:50:08] *** Joins: inlight (~inlight@157.35.15.142)
[15:50:08] *** Quits: inlight (~inlight@157.35.15.142) (Changing host)
[15:50:08] *** Joins: inlight (~inlight@user/inlight)
[15:57:28] *** Joins: dez (uid92154@user/dez)
[16:21:37] *** Quits: inlight (~inlight@user/inlight) (Ping timeout: 240 seconds)
[16:22:24] *** Joins: inlight (~inlight@157.35.59.16)
[16:22:24] *** Quits: inlight (~inlight@157.35.59.16) (Changing host)
[16:22:24] *** Joins: inlight (~inlight@user/inlight)
[16:33:37] *** Quits: Choco (~Choco@host150.200-71-232.telecom.net.ar) (Ping timeout: 256 seconds)
[16:52:54] *** Quits: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani) (Ping timeout: 276 seconds)
[17:26:42] *** Quits: rustycl0ck (~ircuser@gateway/tor-sasl/rustycl0ck) (Ping timeout: 276 seconds)
[17:27:14] *** Joins: son0p (~ff@181.136.122.143)
[17:29:41] *** Joins: yanmaani (~yanmaani@gateway/tor-sasl/yanmaani)
[17:30:13] *** Joins: Choco (~Choco@host150.200-71-232.telecom.net.ar)
[17:37:46] *** Joins: dude12312414 (~test@gateway/tor-sasl/dude12312414)
[17:38:10] *** Quits: powftw (uid448161@id-448161.lymington.irccloud.com) (Quit: Connection closed for inactivity)
[17:41:01] *** Joins: byteskeptical (~amnesia@user/byteskeptical)
[17:42:15] <Alipha> Sofia: indeed, a non-local timing attack shouldn't be possible against a single-use key. But for a local attacker who's able to get detailed timing information, power consumption over time, memory access patterns, etc, then the key might be recoverable from a single use
[18:05:39] *** Quits: gproto23 (~gproto23@user/gproto23) (Read error: Connection reset by peer)
[18:09:25] *** Quits: inlight (~inlight@user/inlight) (Remote host closed the connection)
[18:19:32] *** Quits: llorllale (~llorllale@2607:9880:3a18:69:a1e1:617f:5617:eda3) (Ping timeout: 240 seconds)
[18:27:39] *** Joins: kulak (~kulak@user/kulak)
[18:29:55] <Sofia> Alipha: The plan is to measure leakage in terms of tracing the timings of each instruction and every branch decision. Considering only the registers and memory safe. This should model the worst-case information leakage plausible, without the need for any statistical analysis. Then define adversaries as having a subset of this information, such as N statistical samples (clean of noise introduced by
[18:29:57] <Sofia> the rest of the system). If the subset suffices to recover any secrets, then we mark that program as unsuitable under the assumptions and specification of the threat model.
[18:30:58] <Sofia> should / if not, then I'd be very interested in filling in the blanks here.
[18:32:02] <Sofia> The context is an optimizing compiler, constrained by a formally specified threat model.
[18:33:12] <Sofia> On one extreme, the program doesn't touch sensitive information at all. On the other, the entire program must run in constant time, not just to protect secret keys, but to protect all computations. 
[18:33:39] <Sofia> Practical threat models fit in the middle. 
[18:39:21] <Sofia> Alipha: Returning to the example. The objective here involves considering the local attacker's limited resolution such that we can accept sufficiently negligible leakage. Not that I want to leak data. I mostly want to free the optimizer to optimize the rest of the non-sensitive details.
[18:42:43] <Sofia> Less so accept sufficiently negligible leakage. More really just measure it.
[19:11:44] *** Joins: neiluj (~neiluj@2a01:e0a:1f2:d960:9896:8f35:c866:192e)
[19:12:46] *** Quits: blyat-73 (~hjgkjhgkj@46.235.96.249) (Quit: Leaving)
[20:18:14] *** Joins: zer0bitz (~zer0bitz@2001:2003:f444:a000:499c:186d:f10d:6a24)
[20:20:49] *** Joins: igemnace (~ian@user/igemnace)
[20:31:10] *** Quits: byteskeptical (~amnesia@user/byteskeptical) (Ping timeout: 256 seconds)
[20:33:00] *** Joins: byteskeptical (~amnesia@user/byteskeptical)
[20:42:25] *** Quits: Haohmaru (~Haohmaru@195.24.53.110) ()
[21:11:57] *** Quits: dude12312414 (~test@gateway/tor-sasl/dude12312414) (Remote host closed the connection)
[21:13:01] *** Joins: dude12312414 (~test@gateway/tor-sasl/dude12312414)
[21:25:49] *** Quits: dude12312414 (~test@gateway/tor-sasl/dude12312414) (Quit: THE RAM IS TOO DAMN HIGH)
[21:27:46] *** Quits: Gallomimia (~Gallomimi@node-1w7jra2a2gqpz2pl0fn2jvwdp.ipv6.telus.net) (Remote host closed the connection)
[21:28:17] *** Joins: tuskkk____ (uid18470@id-18470.tinside.irccloud.com)
[21:29:55] *** Joins: Gallomimia (~Gallomimi@node-1w7jra2a2gqpxmcicaoapn3zn.ipv6.telus.net)
[21:29:58] *** Quits: yawkat (~yawkat@cats.coffee) (Ping timeout: 260 seconds)
[21:30:23] *** Joins: yawkat (~yawkat@cats.coffee)
[21:35:34] *** Quits: MajorBiscuit (~MajorBisc@c-001-015-014.client.tudelft.eduvpn.nl) (Ping timeout: 268 seconds)
[21:44:42] *** Quits: semisimple (~semisimpl@user/semisimple) (Quit: WeeChat 3.3)
[22:00:53] *** Joins: deusexbeer (~hedeo@37-146-236-2.broadband.corbina.ru)
[22:28:52] *** Joins: aleck1 (~aleck@user/aleck)
[22:30:48] *** Joins: MajorBiscuit (~MajorBisc@62-52-102.netrun.cytanet.com.cy)
[22:31:17] *** Quits: aleck (~aleck@user/aleck) (Ping timeout: 240 seconds)
[22:40:48] *** Quits: dusk (~quassel@suki.ds7s.nl) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
[22:48:22] *** Joins: semisimple (~semisimpl@user/semisimple)
[22:49:29] *** Joins: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net)
[22:49:42] *** Quits: BOKALDO (~BOKALDO@user/bokaldo) (Quit: Leaving)
[22:54:17] *** Quits: PJBoy (~PJBoy@user/pjboy) (Ping timeout: 240 seconds)
[23:00:18] *** Joins: andreasbuhr (~quassel@p549db7a9.dip0.t-ipconnect.de)
[23:00:30] *** Quits: andreasbuhr (~quassel@p549db7a9.dip0.t-ipconnect.de) (Client Quit)
[23:03:20] *** Joins: hqdruxn08 (~hqdruxn08@cpe-66-68-166-214.austin.res.rr.com)
[23:07:17] *** Quits: hqdruxn08_ (~hqdruxn08@cpe-66-68-166-214.austin.res.rr.com) (Ping timeout: 240 seconds)
[23:18:08] *** Joins: CryptoDavid (uid14990@id-14990.uxbridge.irccloud.com)
[23:33:40] *** Quits: kristijonas (~kristijon@78-56-32-39.static.zebra.lt) (Quit: Client closed)
[23:56:40] *** Joins: dusk (~quassel@suki.ds7s.nl)
[23:59:06] *** Quits: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
