[00:03:32] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 252 seconds)
[00:04:38] *** Quits: rgrinberg (~textual@187.223.75.25) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[00:05:37] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[00:35:02] *** Quits: gravicappa (~gravicapp@178.214.248.83) (Ping timeout: 240 seconds)
[00:42:35] *** Quits: bartholin (~bartholin@2a01:cb11:1ef:d800:4fc6:aec1:8fb8:a2e1) (Quit: Leaving)
[00:58:01] *** Joins: mro (~mro@port-92-195-194-146.dynamic.as20676.net)
[01:05:47] *** Quits: reynir (root@user/reynir) (Ping timeout: 256 seconds)
[01:38:12] *** Quits: dalek-caan (~Thunderbi@109-252-124-86.nat.spd-mgts.ru) (Quit: dalek-caan)
[01:40:06] *** Joins: rgrinberg (~textual@2806:265:5401:9431:d03e:a2ca:3d77:ef5f)
[01:52:02] *** Joins: hackinghorn (~hackingho@user/hackinghorn)
[02:20:25] *** Quits: rgrinberg (~textual@2806:265:5401:9431:d03e:a2ca:3d77:ef5f) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[02:25:35] <hackinghorn> how do I filter a list with 2 functions
[02:25:58] <d_bot> <NULL> What do you mean "with 2 functions" ?
[02:26:12] <hackinghorn> I want to write this let filtered = List.filter (List.filter l ~f:f1) ~f:f2 but that looks clunky
[02:26:25] <hackinghorn> or is it alright?
[02:26:32] <d_bot> <NULL> You can filter on the conjunction
[02:26:50] <d_bot> <NULL> manually expanding the function
[02:28:36] <hackinghorn> arg, any other way?
[02:28:52] <d_bot> <NULL> The way you do it also works
[02:29:06] *** Joins: rgrinberg (~textual@2806:101e:7:def:8ca4:21b9:b555:2338)
[02:29:20] <d_bot> <NULL> You can write it as `l |> List.filter ~f:f1 |> List.filter ~f:f2` if it looks nicer
[02:30:27] *** Quits: rgrinberg (~textual@2806:101e:7:def:8ca4:21b9:b555:2338) (Client Quit)
[02:32:46] <hackinghorn> oh thats nice, thanks
[02:48:47] *** Quits: mro (~mro@port-92-195-194-146.dynamic.as20676.net) (Quit: Leaving...)
[02:50:02] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 268 seconds)
[02:51:03] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[02:54:16] <d_bot> <let Butanium = raise Not_found;;> Why not filter with f1 && F2?
[02:55:01] <d_bot> <NULL> `(&&)` isn't defined on functions, so you have to expand and it takes more space
[03:01:20] <d_bot> <Et7f3> hackinghorn: Why other way ? If you create a named predicate `let filter_this_and_this elt = f1 elt && f2 elt` then use in List.filter it has a name so more readable and you do one pass so it is also faster.
[03:02:40] <hackinghorn> hey, good idea
[03:02:43] <hackinghorn> thanks,
[03:02:56] <d_bot> <NULL> Cons: you have to make up a name
[03:18:43] *** Joins: rgrinberg (~textual@2806:101e:7:def:8ca4:21b9:b555:2338)
[03:20:48] *** Quits: rgrinberg (~textual@2806:101e:7:def:8ca4:21b9:b555:2338) (Client Quit)
[03:24:33] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Ping timeout: 268 seconds)
[03:35:56] *** Joins: rgrinberg (~textual@2806:101e:7:def:8ca4:21b9:b555:2338)
[03:44:17] *** Quits: rgrinberg (~textual@2806:101e:7:def:8ca4:21b9:b555:2338) (Ping timeout: 268 seconds)
[04:05:15] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 268 seconds)
[04:06:39] *** Joins: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se)
[04:25:27] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[04:33:33] *** Joins: rgrinberg (~textual@2806:101e:7:def:f99c:f095:57cb:e173)
[04:44:34] *** Quits: infinity0 (~infinity0@occupy.ecodis.net) (Ping timeout: 260 seconds)
[04:44:46] *** Joins: infinity0 (~infinity0@occupy.ecodis.net)
[04:50:11] *** Quits: rgrinberg (~textual@2806:101e:7:def:f99c:f095:57cb:e173) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[05:24:45] *** Quits: Haudegen (~quassel@178.115.237.87.static.drei.at) (Ping timeout: 256 seconds)
[05:44:31] *** Quits: Tuplanolla (~Tuplanoll@91-159-69-90.elisa-laajakaista.fi) (Quit: Leaving.)
[06:03:01] *** Quits: infinity0 (~infinity0@occupy.ecodis.net) (Ping timeout: 240 seconds)
[06:04:27] *** Joins: infinity0 (~infinity0@occupy.ecodis.net)
[06:07:15] *** Quits: waleee (~waleee@h-98-128-229-110.NA.cust.bahnhof.se) (Ping timeout: 256 seconds)
[06:13:54] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[06:37:42] *** Quits: infinity0 (~infinity0@occupy.ecodis.net) (Remote host closed the connection)
[06:42:12] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[06:42:30] *** Joins: infinity0 (~infinity0@occupy.ecodis.net)
[06:53:07] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[07:13:06] *** Joins: rgrinberg (~textual@2806:265:5401:9431:e42d:e292:4d35:3f96)
[07:17:49] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 240 seconds)
[07:48:18] *** Quits: hackinghorn (~hackingho@user/hackinghorn) (Quit: Leaving)
[07:55:02] *** Joins: gravicappa (~gravicapp@178.214.248.83)
[07:59:23] *** Joins: mbuf (~Shakthi@122.162.67.169)
[08:30:26] *** Quits: zebrag (~chris@user/zebrag) (Quit: Konversation terminated!)
[09:25:23] *** Joins: hackinghorn (~hornhacki@137.132.212.138)
[09:25:33] *** Quits: hackinghorn (~hornhacki@137.132.212.138) (Changing host)
[09:25:33] *** Joins: hackinghorn (~hornhacki@user/hackinghorn)
[09:33:34] *** Joins: hackhorn (~hornhacki@137.132.216.140)
[09:35:57] *** Quits: hackinghorn (~hornhacki@user/hackinghorn) (Ping timeout: 240 seconds)
[09:37:31] *** hackhorn is now known as hackinghorn
[09:37:36] *** Quits: hackinghorn (~hornhacki@137.132.216.140) (Changing host)
[09:37:36] *** Joins: hackinghorn (~hornhacki@user/hackinghorn)
[09:37:48] <hackinghorn> hi
[09:38:04] <dmbaturin> Hi hackinghorn!
[09:38:08] <hackinghorn> is "begin..end" the same as "(..)"
[09:38:28] <hackinghorn> hello friend dmbaturin !
[09:43:34] <dmbaturin> In most cases, yes. But there are edge cases... `let begin end = ...` causes a syntax error.
[09:43:57] <dmbaturin> But where it can be parsed, it's the same as `( )`.
[09:45:50] <dmbaturin> `print_newline begin end`
[09:57:20] <d_bot> <leaf> i'd like to write a program which spawns a subprocess and regularly communicates with it by writing to its stdin/reading from its stdout. what would be the best way to do that in ocaml? is Unix enough or do i have to use libraries like Lwt/Async
[09:59:37] <rgrinberg> Unix is enough if your communication is synchronous
[10:03:34] *** Joins: hackhorn (~hornhacki@137.132.219.138)
[10:05:57] *** Quits: hackinghorn (~hornhacki@user/hackinghorn) (Ping timeout: 240 seconds)
[10:09:03] <dmbaturin> If there are multiple subprocesses and you want to poll them, there's Unix.select
[10:09:05] *** Joins: hornhack (~hornhacki@137.132.217.139)
[10:09:55] *** Quits: rgrinberg (~textual@2806:265:5401:9431:e42d:e292:4d35:3f96) (Read error: Connection reset by peer)
[10:10:09] <dmbaturin> But if it's just one subprocess, then you can just do Unix.open_process_full and read/write to the descriptors it gives you.
[10:10:39] *** Joins: rgrinberg (~textual@2806:265:5401:9431:e42d:e292:4d35:3f96)
[10:11:17] *** Quits: hackhorn (~hornhacki@137.132.219.138) (Ping timeout: 240 seconds)
[10:11:40] <dmbaturin> leaf: Feel free to steal my helpers: https://github.com/dmbaturin/soupault/blob/master/src/process_utils.ml
[10:13:32] *** Quits: spip (~bobo@37.171.38.231) (Ping timeout: 240 seconds)
[10:13:45] *** Joins: spip (~bobo@37.164.162.215)
[10:37:58] *** Joins: shawnw (~shawn_w@c-73-225-121-73.hsd1.wa.comcast.net)
[10:40:22] *** hornhack is now known as hackinghorn
[10:40:26] *** Quits: hackinghorn (~hornhacki@137.132.217.139) (Changing host)
[10:40:26] *** Joins: hackinghorn (~hornhacki@user/hackinghorn)
[10:42:01] <hackinghorn> what is better/preferred? "List.iter ~f:(fun [long ......]) listl" or "List.iter listl ~f:(fun [long ......])"
[10:43:46] <d_bot> <leaf> nice, thanks
[10:46:17] <hackinghorn> dmbaturin, wow I'm gonna steal that
[10:49:05] *** Joins: hackhorn (~hornhacki@137.132.214.140)
[10:51:17] *** Quits: hackinghorn (~hornhacki@user/hackinghorn) (Ping timeout: 240 seconds)
[10:58:08] *** hackhorn is now known as hackinghorn
[10:58:12] *** Quits: hackinghorn (~hornhacki@137.132.214.140) (Changing host)
[10:58:12] *** Joins: hackinghorn (~hornhacki@user/hackinghorn)
[10:58:43] <hackinghorn> dmbaturin, I'm back to steal your code
[11:09:17] *** Joins: xd1le (~xd1le@user/xd1le)
[11:27:16] *** Quits: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb) (Remote host closed the connection)
[11:28:01] *** Joins: x88x88x (~x88x88x@149.28.53.172)
[11:52:51] *** Joins: bartholin (~bartholin@2a01:cb11:1ef:d800:4fc6:aec1:8fb8:a2e1)
[12:03:13] *** Joins: mro (~mro@port-92-195-249-42.dynamic.as20676.net)
[12:17:49] *** Joins: Haudegen (~quassel@178.115.237.87.static.drei.at)
[12:22:57] <hackinghorn> if I have function definition inside a loop like "List.iter ~f:(let func a b c = ... in ...) listl", is it very bad? How bad is it?
[12:26:33] <zozozo> hackinghorn: what do you mean by "bad" ? Personally, I'd say it's mainly not a great style for code, but apart from that..
[12:28:05] <hackinghorn> like, will it increase runtime? increase exe file size? will it affect things negatively? by a lot?
[12:28:12] <hackinghorn> also, is it frowned upon?
[12:28:40] <hackinghorn> I can guess its frowned upon
[12:44:21] *** Quits: mro (~mro@port-92-195-249-42.dynamic.as20676.net) (Remote host closed the connection)
[12:57:20] *** Joins: mro (~mro@port-92-195-249-42.dynamic.as20676.net)
[13:00:51] *** Joins: szkl (uid110435@id-110435.uxbridge.irccloud.com)
[13:03:33] *** Quits: mro (~mro@port-92-195-249-42.dynamic.as20676.net) (Remote host closed the connection)
[13:04:47] *** Joins: mro (~mro@port-92-195-249-42.dynamic.as20676.net)
[13:11:11] *** Joins: reynir (root@user/reynir)
[13:18:22] *** Quits: spip (~bobo@37.164.162.215) (Quit: Konversation terminated!)
[13:21:22] *** Joins: spip (~bobo@37.164.162.215)
[13:35:41] *** Joins: mro_ (~mro@2002:5cc3:f6cf:0:95de:843c:584f:bdb8)
[13:37:11] *** Quits: mro (~mro@port-92-195-249-42.dynamic.as20676.net) (Ping timeout: 256 seconds)
[13:37:41] *** Quits: mro_ (~mro@2002:5cc3:f6cf:0:95de:843c:584f:bdb8) (Remote host closed the connection)
[13:40:07] *** Joins: mro (~mro@port-92-195-246-207.dynamic.as20676.net)
[13:51:28] *** Joins: Tuplanolla (~Tuplanoll@91-159-69-90.elisa-laajakaista.fi)
[13:54:32] *** Quits: rgrinberg (~textual@2806:265:5401:9431:e42d:e292:4d35:3f96) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[13:59:22] *** Quits: hackinghorn (~hornhacki@user/hackinghorn) (Quit: Leaving)
[14:03:17] *** Quits: spip (~bobo@37.164.162.215) (Ping timeout: 240 seconds)
[14:03:25] *** Joins: bobo_ (~bobo@37.166.129.32)
[14:04:28] <d_bot> <zakkor> i don't think it matters too much
[14:07:13] *** Joins: cedric (~cedric@2a01:cb11:821:7c00:47c5:424:7f27:e91c)
[14:11:38] <zozozo> it shouldn't be too bad; however, if the function you use to filter elements (i.e. the `let func a b c = ... in ...`) can be defined outside the loop it would improve performance at runtime, since that way the closure will not need to be reallocated at each loop
[14:22:37] *** Quits: gravicappa (~gravicapp@178.214.248.83) (Ping timeout: 240 seconds)
[14:40:20] *** Joins: gravicappa (~gravicapp@178.214.248.83)
[14:51:49] *** Quits: kurfen (~kurfen@176.119.195.10) (Ping timeout: 250 seconds)
[14:53:51] *** Joins: kurfen (~kurfen@176.119.195.10)
[14:54:25] *** Quits: mro (~mro@port-92-195-246-207.dynamic.as20676.net) (Remote host closed the connection)
[15:45:34] <hannes> with dune and ocamllex & ocamlyacc, how do I figure out which rule caused issues? I see the error "1 rule never reduced ; 1 shift/reduce conflict". any ideas?
[15:52:16] <dmbaturin> hannes: I usually just run menhir by hand with debug options.
[15:52:24] <dmbaturin> Well, ocamlyacc in your case.
[15:53:54] *** Joins: hackinghorn (~hackingho@user/hackinghorn)
[15:59:14] <hannes> dmbaturin: thanks, indeed that worked nicely
[16:18:10] *** Quits: hackinghorn (~hackingho@user/hackinghorn) (Remote host closed the connection)
[16:18:34] *** Joins: hackinghorn (~hackingho@user/hackinghorn)
[16:26:01] *** Joins: mro (~mro@2002:5cc3:f6cf:0:95de:843c:584f:bdb8)
[16:29:01] *** Quits: hackinghorn (~hackingho@user/hackinghorn) (Read error: Connection reset by peer)
[16:29:26] *** Joins: hackinghorn (~hackingho@user/hackinghorn)
[16:51:01] <d_bot> <leviroth> One problem with writing `List.iter ~f:(let func a b c = ... in ...)` is that `f` will be subject to the value restriction
[16:53:32] <d_bot> <leviroth> zozozo: I don't see why there would be any difference in allocation.
[16:55:23] *** Quits: mro (~mro@2002:5cc3:f6cf:0:95de:843c:584f:bdb8) (Remote host closed the connection)
[16:57:07] *** Joins: mro (~mro@port-92-195-246-207.dynamic.as20676.net)
[17:05:13] *** Quits: mro (~mro@port-92-195-246-207.dynamic.as20676.net) (Remote host closed the connection)
[17:11:15] *** Quits: cedric (~cedric@2a01:cb11:821:7c00:47c5:424:7f27:e91c) (Quit: Konversation terminated!)
[17:18:12] <d_bot> <leviroth> (of course re: value restriction I'm not sure where in practice you would need this particular line of code to be polymorphic)
[17:34:57] *** Quits: gravicappa (~gravicapp@178.214.248.83) (Ping timeout: 240 seconds)
[17:57:19] *** Quits: xd1le (~xd1le@user/xd1le) (Quit: xd1le)
[17:57:55] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[18:06:19] *** Joins: zebrag (~chris@user/zebrag)
[18:15:15] *** Parts: ymherklotz (~ymherklot@139.59.166.119) (Killed buffer)
[18:34:24] <d_bot> <VPhantom> Is <https://github.com/ocaml/RFCs/pull/10> the best way to keep myself informed about the progress of <https://github.com/ocaml/RFCs/blob/unboxed-types/rfcs/unboxed-types.md> the RFC for unboxed types? I guess an RFC is still pretty far away from a pull request in the compiler itself?
[18:40:56] *** Joins: humasect (~humasect@2001:1970:57e0:4100::9e43)
[18:41:17] *** Quits: shawnw (~shawn_w@c-73-225-121-73.hsd1.wa.comcast.net) (Ping timeout: 240 seconds)
[19:08:40] <d_bot> <Bluddy> yeah nobody's touching that until multicore is integrated
[19:18:19] *** Quits: hackinghorn (~hackingho@user/hackinghorn) (Ping timeout: 256 seconds)
[19:21:54] *** Joins: gravicappa (~gravicapp@178.214.248.83)
[19:28:02] <d_bot> <VPhantom> Speaking of multicore, I notice it reimplements `Lazy`, but the new documentation still warns of possible issues when forcing across domains. I still don't fully understand what "thread-safety" means for this purpose. Is it risky to use lazy with OCaml 4.x and `Lwt` cooperative threading? Will servers made with Lwt benefit from domains, and if so, still pose risks for using lazy? (Basically: should I continue to avoid using lazy
[19:28:55] <d_bot> <VPhantom> (I might've asked in #lwt but I think what I fail to understand is fundamental to `Lazy`.🤔)
[19:31:51] <d_bot> <VPhantom> As far as I know, I'd want for the concurrent domains to wait for the resolution instead of raising `RacyLazy`…
[19:40:59] <d_bot> <octachron> OCaml 5.0 will not include `RacyLazy` and it will be the responsibility of the user to lock the lazy value during forcing.
[19:42:37] <d_bot> <VPhantom> I guess I should read up on `Thread` vs `Lwt`. It's confusing as `Thread` is defined as a "lightweight thread" and that's pretty much how `Lwt` also describes itself. I think these days POSIX threads are managed by the kernel instead of being faked in-process like the good old days of MIT pthreads (`setjmp()` and `longjmp()`). AFAIK Lwt is a single thread in a single process, which runs various continuations in a loop, whereas `
[19:43:14] <d_bot> <VPhantom> I wouldn't have a clue how to do that…
[19:44:54] <dmbaturin> Lwt switched its "thread" terminology to "promise" to avoid confusion a while ago.
[19:45:00] <d_bot> <octachron> The warning refers to domain (which are a group of OS threads + some metadata) which are the unit of parallelism in OCaml 5.
[19:46:07] <d_bot> <VPhantom> And `Thread` refers to OS threads, distinct stacks in a single process but managed by the kernel?
[19:47:05] <d_bot> <VPhantom> My main goal is just to make sure that what I'm writing now will still work as expected if/when used in a web service which, presumably, will end up using multiple cores later (albeit always serve a single request on a single core).
[19:47:36] <companion_cube> Don't share lazy values between cores, probably
[19:47:41] <companion_cube> That's my takeaway
[19:47:53] <d_bot> <VPhantom> Ah ha, so I shouldn't shy away from using them inside a Lwt process then.
[19:55:48] <d_bot> <octachron> `Thread.t`  are OS threads but only a single thread by domain runs in parallel. Normally, you can mostly assume that any code that works with current OCaml will still work in OCaml 5 (but without any implicit benefits)
[20:00:31] *** Joins: seeg (0bf4efab5c@2604:bf00:561:2000::2c7)
[20:01:59] <d_bot> <VPhantom> Makes sense. I never had a need for actual threads (just Lwt which I guess is even simpler). I just want to make sure that when Lwt (or other) spreads over multiple processors, I'll still have the same behavior I have now with fully independent processes. Looks like yes.
[20:02:13] *** Quits: humasect (~humasect@2001:1970:57e0:4100::9e43) (Quit: Leaving...)
[20:06:09] <d_bot> <VPhantom> (I should also read up on why web services like cohttp and httpaf use cooperative threads like Lwt/Async instead of full-blown `Thread.t`. I assume it's because I/O bound switching is cheaper inside a single actual thread.)
[20:19:09] *** Joins: dalek-caan (~Thunderbi@109.252.124.86)
[20:20:44] <Leonidas> I also assume that you just need fewer syscalls
[20:25:22] *** Joins: mro (~mro@port-92-195-246-207.dynamic.as20676.net)
[20:29:43] *** Quits: mro (~mro@port-92-195-246-207.dynamic.as20676.net) (Ping timeout: 256 seconds)
[20:31:08] <d_bot> <leviroth> I assume at least some of it is a preference for the monadic style and not just performance
[20:48:45] *** Quits: kakadu (~kakadu@195.19.236.234) (Remote host closed the connection)
[20:53:05] *** Quits: mbuf (~Shakthi@122.162.67.169) (Quit: Leaving)
[21:01:59] <dmbaturin> Is there a way to make opam set up shell configs without doing a full `opam init`?
[21:04:13] <d_bot> <NULL> It's adding a hook to a file in .opam, so how could it do it if the file doesn't exist
[21:05:20] <dmbaturin> Oh, I mean just add the line to the shell config.
[21:05:38] *** Quits: Haudegen (~quassel@178.115.237.87.static.drei.at) (Quit: No Ping reply in 180 seconds.)
[21:05:40] <dmbaturin> I found it already, `opam init --shell-setup`.
[21:06:44] *** Joins: romildo (~Romildo@ip-191-5-85-134.isp.valenet.com.br)
[21:07:01] *** Joins: Haudegen (~quassel@178.115.237.87.static.drei.at)
[21:07:13] <d_bot> <NULL> Doesn't this just automatically answer yes to the question ? I'm not sure this skips anything
[21:07:52] <dmbaturin> It may. I only wanted to restore the shell config, the opam setup itself is fine.
[21:08:42] <d_bot> <NULL> In any case, you can re-execute opam init fine if you already did, it will re-ask for the hooks but won't redo the initialization
[21:09:31] <dmbaturin> Ah, I see.
[21:10:13] *** Joins: rgrinberg (~textual@187.223.75.25)
[21:35:30] <d_bot> <VPhantom> Depends what you're benchmarking, i.e. <https://discuss.ocaml.org/t/lwt-vs-system-threads/5007/14>
[21:36:30] <d_bot> <VPhantom> From what I can tell, promises vs systhreads avoids some pitfalls of actual threads and is at least as performant for I/O bound applications. So it's an easy choice for me, especially now that we have let bindings which make the overhead of `Lwt_result.t` disappear cleanly.
[21:37:34] <companion_cube> You can use lwt_domain to dispatch cpu tasks to the background, too
[21:40:13] <d_bot> <VPhantom> I wouldn't dare. 😛
[21:46:11] <companion_cube> It's pretty safe afaict?
[21:49:24] <d_bot> <VPhantom> One has to become acutely aware of who owns what bits of memory, there's mentions of locking and what not, and I'm not sure how the multicore GC handles that in practice. It's not something I'd attempt without some serious prior RTFM.
[21:57:42] *** Quits: tomku (~tomku@user/tomku) (Read error: Connection reset by peer)
[22:03:52] *** Joins: tomku (~tomku@user/tomku)
[22:13:40] <companion_cube> Well it's going to be useful with multicore, for stuff like decoding json on the thread pool
[22:13:49] <companion_cube> No locking needed if you work with values
[22:14:18] *** Quits: romildo (~Romildo@ip-191-5-85-134.isp.valenet.com.br) (Quit: Leaving)
[22:30:13] <d_bot> <VPhantom> You mean a domain pool?
[22:31:47] <d_bot> <VPhantom> You highlight a good point in favor of pre-emptive threading though: one thread per request, no need to extract computations.
[22:36:11] <rgrinberg> companion_cube how much json does one need to decode to justify that overhead?
[22:36:55] <d_bot> <VPhantom> I know in a single thread on my laptop Yojson can pump through something like half a gig per second, so I'm not worried about that for what we do. 😉
[22:38:07] <rgrinberg> i meant that it wouldn't even necessarily speed anything up unless the json packets are pretty big. synchronization across cores isn't free
[22:38:52] <d_bot> <VPhantom> (Sorry I guess it's 133MB/sec on my laptop; just double-checked.)
[22:41:43] <rgrinberg> That could probably be sped up quite a bit if you write bindings for one of the C json libraries out there
[22:42:48] <d_bot> <VPhantom> It's already well beyond the minimum performance requirement I have for our next-gen web site to handle 10x the traffic we have right now.
[22:43:22] <d_bot> <VPhantom> (Ours is an Apache/mod_perl site. OCaml is 20x faster without even trying…)
[22:43:22] <rgrinberg> i'm sure. i've yet to see a webapp bottle necked by json parsing speed
[22:44:01] <companion_cube> rgrinberg: idk
[22:44:36] <d_bot> <VPhantom> That said we'll use Protobuf in binary mode for our internal I/O; that's 6x faster for the same payload in my benchmarks.
[22:44:54] <d_bot> <VPhantom> (That's ocaml-protoc; I have yet to add the newer ocaml-protoc-plugin to my benchmarks.)
[22:44:56] <rgrinberg> lol mod_perl
[22:45:28] <d_bot> <VPhantom> Yeah well, we started writing it in 2003, from existing CGIs from the year before, so "legacy"…
[22:45:42] <d_bot> <VPhantom> That's when we thought the likes of Amazon would propel mod_perl to the forefront.
[22:46:46] <rgrinberg> there's ocaml-pb, which is very cleanly written and plays well with async
[22:47:05] <rgrinberg> if I wanted perf, I'd write bindings to upb though
[22:47:07] <d_bot> <VPhantom> Java "JSP" probably would've been the safest long-term bet, but the HotSpot JIT was still pretty lackluster back then.
[22:47:42] <companion_cube> What's upb?
[22:47:58] <d_bot> <VPhantom> Hm, why haven't I considered `ocaml-pb`? (or perhaps eliminated it) 🤔
[22:48:01] <companion_cube> Also you could write a decoder in C and bind it
[22:48:03] <rgrinberg> companion_cube really fast pb implementation in C
[22:48:17] <companion_cube> Protobuf isn't that complicated
[22:48:21] <companion_cube> Heh ok
[22:49:03] <d_bot> <VPhantom> Hm ocaml-pb seems to be lower-level vs the two others, and it doesn't implement the JSON side.
[22:49:20] <companion_cube> Cool, upb looks nice
[22:50:11] <companion_cube> ... But builds with bazel
[22:50:25] <rgrinberg> companion_cube they did some cool hacks to make it fly https://blog.reverberate.org/2021/04/21/musttail-efficient-interpreters.html
[22:50:38] <d_bot> <VPhantom> Bindings to `upb` could be nice. I always shied away from any FFI but that could be worthwhile.
[22:50:56] <rgrinberg> companion_cube they have cmake as well don't they?
[22:51:23] *** Joins: travv0 (sid293381@user/travv0)
[22:51:29] <companion_cube> "experimental"
[22:51:35] <companion_cube> Well, anyway. Good to know.
[22:51:47] <companion_cube> There's also a rust implementation somewhere
[22:51:48] <rgrinberg> i mean, if i was serious about using it, I would write a dune port anyway :)
[22:52:31] <d_bot> <VPhantom> Using upb is more than FFI though, there'd need to be a runtime on the OCaml side, a conversion to useful types, etc.
[22:53:27] <d_bot> <VPhantom> "While upb offers a C API, the C API & ABI are not stable. For this reason, upb is not generally offered as a C library for direct consumption, and there are no releases." — Doesn't look like something to rely on just yet.
[22:56:20] *** Quits: rgrinberg (~textual@187.223.75.25) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[23:32:44] *** Joins: hackinghorn (~hackingho@user/hackinghorn)
[23:47:32] *** Quits: dalek-caan (~Thunderbi@109.252.124.86) (Quit: dalek-caan)
