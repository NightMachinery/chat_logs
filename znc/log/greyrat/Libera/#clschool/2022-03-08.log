[00:21:19] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[00:47:30] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[00:48:40] *** Joins: epony (epony@user/epony)
[01:09:52] *** Joins: Oladon (~olad@98.43.81.226)
[01:32:58] *** Quits: shka (~herr@109.231.3.55) (Ping timeout: 260 seconds)
[02:09:19] *** Quits: mns_ (~mns@c-73-119-178-157.hsd1.ma.comcast.net) (Quit: Quit)
[02:09:41] *** Joins: mns (~mns@c-73-119-178-157.hsd1.ma.comcast.net)
[02:11:10] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[02:13:47] *** Joins: hashfuncadb (~user@2601:5c0:c280:7090:29ba:fcc0:8f3a:efac)
[03:42:13] *** Joins: Oladon (~olad@98.43.81.226)
[04:03:24] *** rdrg109_ is now known as rdrg109
[04:43:47] *** Joins: jealousmonk (~user@user/jealousmonk)
[04:45:30] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[05:17:40] *** Joins: plexi_ (~orcabot@digital.sanctuary.org)
[05:18:09] *** Quits: pjb (~pjb@user/pjb) (Ping timeout: 256 seconds)
[05:19:04] *** Quits: plexi (~orcabot@digital.sanctuary.org) (Quit: Don't panic!)
[05:19:04] *** plexi_ is now known as plexi
[05:34:04] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 272 seconds)
[05:35:39] *** Joins: aeth (~aeth@user/aeth)
[05:38:30] *** Quits: Harag (~user@105.243.9.173) (Ping timeout: 272 seconds)
[05:41:37] *** Quits: Bike (~Glossina@71.69.170.70) (Quit: Lost terminal)
[05:46:50] *** Joins: Bike (~Bike@71.69.170.70)
[06:31:15] *** Quits: random-nick (~random-ni@87.116.176.196) (Ping timeout: 256 seconds)
[07:11:37] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 240 seconds)
[07:18:37] *** Quits: hashfuncadb (~user@2601:5c0:c280:7090:29ba:fcc0:8f3a:efac) (Ping timeout: 240 seconds)
[07:20:06] *** Quits: jgart (16dd2205e4@irc.cheogram.com) (Quit: Gateway shutdown)
[07:30:53] <beach> Good morning everyone! 
[07:38:05] *** Joins: jgart (16dd2205e4@irc.cheogram.com)
[07:58:47] *** Quits: jealousmonk (~user@user/jealousmonk) (Quit: ERC 5.4.1 (IRC client for GNU Emacs 27.1))
[08:01:03] *** Quits: Bike (~Bike@71.69.170.70) (Quit: Connection closed)
[08:07:46] *** Joins: whereiseveryone (206ba86c98@2604:bf00:561:2000::2e4)
[08:08:08] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Remote host closed the connection)
[08:17:49] *** Joins: Oladon (~olad@98.43.81.226)
[09:17:54] *** Joins: lisp123 (~lisp123@120.154.103.52)
[09:20:31] *** Parts: contrapunctus (a75f5b1571@2a00:c70:1:178:170:40:189:1) ()
[09:26:36] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[09:26:38] *** Quits: lisp123 (~lisp123@120.154.103.52) (Remote host closed the connection)
[09:26:54] *** Joins: lisp123 (~lisp123@120.154.103.52)
[09:34:52] *** Joins: dre (~dre@2001:8003:c932:c301:171a:f969:49b7:a76a)
[09:37:09] *** Quits: lisp123 (~lisp123@120.154.103.52) (Remote host closed the connection)
[10:00:54] *** Joins: lisp123 (~lisp123@120.154.103.52)
[10:15:23] *** Quits: lisp123 (~lisp123@120.154.103.52) (Remote host closed the connection)
[10:36:21] *** Joins: aeth_ (~aeth@user/aeth)
[10:36:21] *** Quits: aeth (~aeth@user/aeth) (Killed (NickServ (GHOST command used by aeth_)))
[10:36:26] *** aeth_ is now known as aeth
[10:56:24] *** Joins: lisp123 (~lisp123@120.154.103.52)
[11:01:17] *** Quits: lisp123 (~lisp123@120.154.103.52) (Ping timeout: 240 seconds)
[11:07:27] *** Quits: dre (~dre@2001:8003:c932:c301:171a:f969:49b7:a76a) (Quit: Leaving)
[11:29:02] *** Joins: pjb (~pjb@user/pjb)
[11:43:50] *** Joins: shka (~herr@109.231.3.55)
[12:08:59] *** Joins: lisp123 (~lisp123@120.154.103.52)
[12:16:32] <ilmu[m]1> mornin'
[12:19:25] <beach> Hello ilmu[m]1.
[12:49:40] <CodeBitCookie[m]> Hello Everyone!
[12:50:21] <beach> Hello CodeBitCookie[m].
[12:51:25] <CodeBitCookie[m]> I was wanting to separate my code into different files. I am a little new to the packages concept still. That is why I found it interesting that I had to export so much from a file. Am I doing something wrong?
[12:51:39] <CodeBitCookie[m]> Or should I just use :: instead of :
[12:51:57] <CodeBitCookie[m]> I mean, what even is the point of exporting when you can easily use ::
[12:52:28] <CodeBitCookie[m]> Also, I have a quite a few more questions.
[12:52:42] <CodeBitCookie[m]> beach: Hello beach.
[12:54:49] <beach> Normally, if your code for a single project is in several files, you should have a single package for all of them.
[12:55:25] <beach> So then there is no need to export or import or use any package prefix to refer to code in the same project.
[12:56:16] <beach> Each file (except the ASDF file and the file containing the package definition) should then start with (cl:in-package #:mumble), where MUMBLE is the name of the package defined in the file for that purpose.
[13:03:30] <beach> Does that make sense?
[13:04:39] <beach> Anyway, I can't stick around.  See you later.
[13:37:01] *** Quits: lisp123 (~lisp123@120.154.103.52) (Remote host closed the connection)
[13:42:20] *** Joins: Josh_2 (~user@197.184.168.216)
[13:43:00] *** Quits: shka (~herr@109.231.3.55) (Ping timeout: 272 seconds)
[14:25:14] *** Joins: lisp123 (~lisp123@120.154.103.52)
[14:35:00] <pjb> CodeBitCookie[m]: packages and files are independent.
[14:36:24] <pjb> CodeBitCookie[m]: you can have code that is read in the same package stored in different files. You just put a (in-package "YOUR-PACKAGE") at the beginning of each file.
[14:37:07] <pjb> CodeBitCookie[m]: you can also have code read in different packages stored in a single file. You just put in-package forms in the middle of the file.
[14:38:29] <pjb> CodeBitCookie[m]: spreading code over files would be motivated on physical or tooling constraints, or also, for ease of dependency specification (asdf systems define dependencies between _files_ to be compiled and loaded).
[14:39:05] <pjb> CodeBitCookie[m]: so for example, you could want to put all defpackage forms in a single file, since it would have to be compiled and loaded before the other files (that contain in-package forms) can be loaded.
[14:39:42] <pjb> CodeBitCookie[m]: similarly, you could want to put your macros and the functions they use in a separate file, that would have to be compiled and loaded before you can compile the files that use those macros.
[14:40:22] <pjb> (there are ways to put everything is a single file still, using EVAL-WHEN forms (or implicit EVAL-WHEN forms such as in the IN-PACKAGE macro)). 
[14:41:49] <pjb> Now, concerning packages. 1- they are namespaces.  You can use packages to define separate namespaces, in which you can have homonym symbols that are different.  For example, you can have a VEHICULE package in which the symbol CAR doesn't denote a slot in a cons cell, but a kind of vehicule.
[14:43:29] <pjb> 2- they can be used to represent software "components", with a defined (small) API and an implementation.  The API of the component is represented by the export list of the package, and the implementation by the code read in the package.  The dependencies between package (use lists or imports) can represent the dependencies between the components.
[14:44:17] <pjb> So if you have to export too much from a package, it may be a sign that you are not defining your components properly. Components must be cohesive and have a small API (small export list).
[14:45:05] <pjb> Sometimes the export list can be long, but conceptually simple. Eg. you may have large enumerations, but conceptually, it's a single thing that is exported.
[14:45:39] <pjb> In CL, enumerations can often be represented using keywords.  But you may still want to use specific symbols to avoid collisions between homonyms.
[14:47:51] <pjb> Now, beach advocates for avoiding :use or use-package, and instead, use short package names, and use qualified symbols to refer symbols from another package: foo:bar ;  one problem I see with this way of doing, is that there's no declaration of the dependency between the current package and the package FOO: you have to scan the whole sources to detect those dependencies.  If you use a package in a defpackage form, then you only have to
[14:47:51] <pjb> scan the defpackage forms to see the dependencies between the package.  
[14:49:24] <pjb> I used to add:  (declare (declaration also-use)) (declare (also-use foo)) (defpackage "BAR" (:use "QUUX"))  (in-package "BAR") (foo:zoom) to declare that the file has references to symbols in the package foo in addition to the use list. (and I have tools to scan files for those also-use declarations and build asdf files or other).
[14:50:39] <pjb> CodeBitCookie[m]: you could read some generic software engineering book that would explain how to structure projects in to components, subcompoenents, objects, functions, etc, to learn how to structure your projects. Mapping components to packages (or systems, libraries or executables) would then become clear.
[14:50:42] <lisp123> (declare (declaration also-use))  -> creates a new declaration?
[14:50:47] <pjb> Exactly.
[14:50:50] <lisp123> nice
[14:51:14] <pjb> You can create all the declarations you want. Only be careful the package where the declaration name is interned ;-)
[14:51:46] <lisp123> Got it :)
[14:52:21] <pjb> (declare (declaration pre post invariant))  (defun foo (x) (declare (pre (and (integerp x) (< x 10))) (post (= (* 2 x) (foo x)))) (+ x x))
[14:52:57] <pjb> Then you can write tools to process those declarations. You could turn them into ASSERTs, or into unit tests, or documentation or whatever.
[14:53:55] <lisp123> Seems very useful
[14:55:22] <pjb> Then the difficult is to write tools. But toolboxes such as sicl, code walkers, lisp readers (eg. com.informatimago.common-lisp.lisp-reader.reader or others) can help.
[14:56:37] <lisp123> Indeed
[14:57:24] <lisp123> I wrote some of my own tools a while ago (automatically get package dependencies in a file // auto create ASDF definitions)
[14:57:59] <lisp123> I find ASDF overly convoluted, but I'll keep quiet otherwise
[15:08:57] <beach> To use?  Its implementation is convoluted, but it is pretty simple to use.  No?
[15:09:46] <lisp123> Implementation
[15:09:56] <beach> Ah, yes.
[15:13:41] <bremner> is there a portable way to set environment variables for an external process (e.g. created by run-program). I guess I can exec env, but it's a bit ick
[15:14:23] <bremner> I guess I can use osicat:environment-variable
[15:15:00] *** Quits: Josh_2 (~user@197.184.168.216) (Ping timeout: 240 seconds)
[15:29:10] *** Quits: lisp123 (~lisp123@120.154.103.52) (Remote host closed the connection)
[15:29:41] <edgar-rft> bremner: haven't tried myself but according to the UIOP manual (setf (uiop:getenv <varname>) <new-alue-as-string>) should work -> https://asdf.common-lisp.dev/uiop.html#Setf_002dExpander-uiop_002fos_003agetenv
[15:30:44] <bremner> oic. that's a bit confusing. 
[15:31:09] <bremner> I guess I'm just not used to setf
[15:32:45] <edgar-rft> setf-expanders are normal part of Common Lisp :-)
[15:35:57] <bremner> yeah. It's just that I don't expect getenv to be writing
[15:38:37] <edgar-rft> I agree that GETENV is a bad name in that case because it creates confusion
[15:40:29] <edgar-rft> on the other hand (setf (gethash <hashtable> <key>) new-alue) is the same nonsense an the regular way to add new key/alue pairs to existing hashtables
[15:40:30] *** Joins: random-nick (~random-ni@87.116.176.196)
[15:41:12] <edgar-rft> Common Lisp is not soooo well-thought as many people like to claim :-)
[15:42:29] <edgar-rft> ...and somehow my v key seems to be broken :-(
[15:43:08] <edgar-rft> it's new-value, not new-alue
[15:49:49] *** Joins: lisp123 (~lisp123@120.154.103.52)
[15:51:11] *** Quits: lisp123 (~lisp123@120.154.103.52) (Remote host closed the connection)
[16:02:13] *** Joins: jeffrey (~jeffrey@2001:1c04:398f:5a00:42f7:1e1c:b84:ae35)
[16:05:21] *** Joins: st_iron (uid370243@id-370243.uxbridge.irccloud.com)
[16:05:38] <st_iron> hello
[16:07:23] <CodeBitCookie[m]> beach: Oh sorry guys
[16:07:30] <CodeBitCookie[m]> I had to go
[16:07:57] <CodeBitCookie[m]> Although,
[16:08:42] <CodeBitCookie[m]> Some people recommend having One project for each file
[16:09:18] <CodeBitCookie[m]> like common-lisp.org
[16:09:54] <CodeBitCookie[m]>  * like https://lisp-lang.org/
[16:10:13] <CodeBitCookie[m]> s/project/package/
[16:11:17] <CodeBitCookie[m]> For example, I have a group of classes which I feel I should seperate since they are used like a sub library and are referenced in very different parts of my program.
[16:11:42] <CodeBitCookie[m]> In that case, I made a main project for e.g. "program"
[16:11:56] <CodeBitCookie[m]> and the sub-library thing, called "program.editor"
[16:12:08] <CodeBitCookie[m]> which handles all the stuff for editors in that program.
[16:12:14] <CodeBitCookie[m]> I found cl-annot
[16:13:05] <CodeBitCookie[m]> which would be much more handy to export. It has a annotation called @export and another, @export-accessors. The former works, but the latter is "undefined" according to the errors I get.
[16:13:49] <CodeBitCookie[m]> I would rather not share the code, since this is for a closed source application.
[16:17:52] <beach> I really don't like the structure of a single file for a project.
[16:19:48] <beach> I often do what I think it is you are suggesting, namely I split my code into "modules" where each module lives in a separate directory, has a separate ASDF file and a separate package definition in its own file. 
[16:20:12] <beach> But that doesn't prevent me from having several files in a single module, each with the same IN-PACKAGE in the beginning.
[16:20:55] <beach> I don't think you should bother with such annotations.  Just stick the exported symbols in the package definition, and stick the package definition in its own file.
[16:22:12] <CodeBitCookie[m]> So, if I do want to separate it, how do I if not for packages?
[16:22:27] <CodeBitCookie[m]> Or, are you saying I should just not care to separate it?
[16:22:37] <beach> "it"?
[16:23:31] <White_Flame> each .asd is a separately loadable thing, for that sense of "separate"
[16:23:36] <beach> I am saying, a module consists of an ASDF system definition in its own file, a package definition in its own file, and 1 or more (usually more) Common Lisp source files, each starting with (IN-PACKAGE <the-package-definition-in-the-file-I-just-mentioned>)
[16:24:02] <beach> Yes, and then the main ASDF system definition will :DEPENDS-ON the others.
[16:24:28] <beach> And I often do that because if the code base is large, it makes sense to split it up into such "modules".
[16:28:24] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[16:37:34] <CodeBitCookie[m]> Oh beach, thanks a lot. I have done as you told me to, and defined my package in a package.lisp.
[16:37:45] <CodeBitCookie[m]> The rest of the files have the in-package thing at the start.
[16:37:50] <beach> Great!
[16:38:08] <CodeBitCookie[m]> This works great and I see that I don't have to separate it too much.
[16:38:33] <beach> Good.  It works well for what I do, and I am usually not unique. :)
[16:44:02] *** Joins: lisp123 (~lisp123@120.154.103.52)
[16:49:12] *** Quits: lisp123 (~lisp123@120.154.103.52) (Ping timeout: 268 seconds)
[16:59:12] <CodeBitCookie[m]> Okay, so now I want a clamp like function, I could easily make it, but just asking if it already exists:
[17:01:23] <CodeBitCookie[m]> This function will be like 1-;
[17:01:23] <CodeBitCookie[m]> If VAL is <= MIN, return MIN
[17:01:23] <CodeBitCookie[m]> ELSE IF VAL is >= MAX, return MAX
[17:01:23] <CodeBitCookie[m]> ELSE return VAL
[17:01:33] <CodeBitCookie[m]> a same copy for a 1+ too
[17:01:57] <CodeBitCookie[m]> as you could probably tell, this function would need 3 Args, VAL, MIN and MAX
[17:04:21] *** Joins: seok (~Seok@n114-73-75-18.bla3.nsw.optusnet.com.au)
[17:04:49] <seok> I want to define characters for a numeric system with different bases
[17:05:00] <seok> like base 32 etc
[17:05:13] <seok> Is there a resource I can look at to accomplish this ?
[17:06:04] <seok> Is it possible to define a format directive for this newly defined numeric characters ?
[17:14:56] <White_Flame> CodeBitCookie[m]: not lisp specific, but (max low-bound (min high-bound x))
[17:15:09] <White_Flame> and yeah, I don't believe there's a builtin
[17:17:44] <White_Flame> seok: *print-base* and *read-base* exist, though I don't know what the spec limits are.  My SBCL supports up to base 36
[17:18:54] <White_Flame> the general standard is that >9, you start using a-z
[17:19:39] <White_Flame> if you want to define your own digit characters, I'm not sure that's exposed in terms of modifying existing print/read functionality
[17:20:35] <edgar-rft> CL has support for base 0..35 but then you have to use 0..9 and A..F, if you want different characters you need to bake your own thing
[17:21:22] <edgar-rft> error: base 35 uses 0..9 and A..Z, not A..F
[17:21:25] *** Quits: jeffrey (~jeffrey@2001:1c04:398f:5a00:42f7:1e1c:b84:ae35) (Ping timeout: 250 seconds)
[17:52:33] <CodeBitCookie[m]> <White_Flame> "CodeBitCookie: not lisp specific..." <- Thanks a lot!
[18:24:53] <seok> hm, ok got it
[18:25:37] *** Joins: jeffrey (~jeffrey@84-107-61-248.cable.dynamic.v4.ziggo.nl)
[18:32:49] *** Joins: lisp123 (~lisp123@120.154.103.52)
[18:37:30] *** Quits: lisp123 (~lisp123@120.154.103.52) (Ping timeout: 272 seconds)
[19:18:17] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Quit: ec_)
[19:33:38] *** Joins: Oladon (~olad@98.43.81.226)
[19:46:15] *** Joins: silasfox (~sbv@p200300cec71b49000fb32acff10041ab.dip0.t-ipconnect.de)
[19:56:19] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[19:59:57] *** Joins: shka (~herr@109.231.3.55)
[20:01:14] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 252 seconds)
[20:05:00] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[20:07:07] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[20:11:27] *** Quits: jeffrey (~jeffrey@84-107-61-248.cable.dynamic.v4.ziggo.nl) (Quit: Client quit)
[20:20:35] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 240 seconds)
[20:22:04] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[20:26:00] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 252 seconds)
[20:37:49] *** Joins: Bike (~Glossina@71.69.170.70)
[20:47:55] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[20:50:20] *** Quits: empwilli (~empwilli@faui48e.informatik.uni-erlangen.de) (Quit: WeeChat 3.0)
[21:06:47] *** Joins: Oladon (~olad@98.43.81.226)
[21:28:02] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[21:35:09] *** Quits: st_iron (uid370243@id-370243.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[21:46:53] *** Joins: jealousmonk (~user@user/jealousmonk)
[22:03:10] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Remote host closed the connection)
[22:07:22] *** Quits: opfez (~opfez@ti0013a400-3552.bb.online.no) (Ping timeout: 256 seconds)
[22:19:53] *** Joins: opfez (~opfez@ti0013a400-3699.bb.online.no)
[22:27:15] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 240 seconds)
[22:27:34] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[22:47:02] *** Quits: johnjaye (~pi@173.209.64.74) (Ping timeout: 272 seconds)
[22:48:39] *** Joins: johnjaye (~pi@173.209.64.74)
[22:49:42] <CodeBitCookie[m]> Okay, is there anything that could NCONC Strings?
[22:50:13] <CodeBitCookie[m]> Or should I just use (setf X (concatenate 'string Y Z C V))
[22:50:33] <CodeBitCookie[m]> * (concatenate 'string X Y Z
[22:52:28] *** Joins: cyberbanjo (~user@2607:fb90:42b7:213f:732e:306d:a6f3:7f1)
[22:52:43] *** Quits: cyberbanjo (~user@2607:fb90:42b7:213f:732e:306d:a6f3:7f1) (Remote host closed the connection)
[22:56:00] *** Joins: cyberbanjo (~user@2607:fb90:42b7:213f:732e:306d:a6f3:7f1)
[23:06:57] *** Joins: empwilli (~empwilli@faui48e.informatik.uni-erlangen.de)
[23:37:34] <pjb> CodeBitCookie[m]: to nconc a string, it would have to be adjustable.
[23:37:39] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[23:39:02] <CodeBitCookie[m]> Oh, whoops, totally forgot about that ðŸ¤¦!
[23:39:05] <CodeBitCookie[m]>  * pjb: Oh, whoops, totally forgot about that! ðŸ¤¦
[23:39:06] <pjb> CodeBitCookie[m]: (let ((s (make-array 3 :adjustable t :fill-pointer 3 :initial-contents "ABC"))) (values s (vector-push-extend #\D s))) #| --> #(#\A #\B #\C #\D) ; 3 |# 
[23:39:38] <pjb> Oops
[23:39:45] <CodeBitCookie[m]> Oh, yeah, no thanks, I know what that does but seems much easier to return the new string.
[23:39:48] <pjb> CodeBitCookie[m]: (let ((s (make-array 3 :element-type 'character :adjustable t :fill-pointer 3 :initial-contents "ABC"))) (values s (vector-push-extend #\D s))) #| --> "ABCD" ; 3 |# 
[23:39:56] <CodeBitCookie[m]> with concatenate
[23:40:34] <CodeBitCookie[m]> This would be for super duper optimization or something.
[23:40:38] <pjb> Depends. If your string is 1 M character, and you're adding only a few characters, it would be better if it had some space pre-allocated, and you would just have to increment the fill-pointer.
[23:41:13] <CodeBitCookie[m]> Also true.
[23:41:31] <CodeBitCookie[m]> so for a text editor, basic optimizations.
[23:43:46] <CodeBitCookie[m]> pjb: Okay, so now, how do I remove a character from the middle of a string (I can return a new string)
[23:44:27] <CodeBitCookie[m]> I can use cl-str
[23:44:45] <CodeBitCookie[m]> I already have something like (setf X (concatenate 'string (subseq x y z) (subseq c v b))
[23:45:02] <CodeBitCookie[m]> s/c/x/
