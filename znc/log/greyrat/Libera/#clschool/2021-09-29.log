[00:05:18] *** Quits: tyson2 (~user@198.98.115.227) (Quit: ERC (IRC client for Emacs 27.2))
[00:09:33] *** Joins: tyson2 (~user@198.98.115.227)
[00:14:51] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[00:26:46] *** Quits: tyson2 (~user@198.98.115.227) (Quit: ERC (IRC client for Emacs 27.2))
[00:47:58] <Alex[m]> typeclasses/ad-hoc polymorphism are really nice but I keep coming back to one situation that seems built for subtype polymorphism which is overriding an implementation for performance reasons if you know more about a specific substructure.
[01:10:12] *** Joins: lisp123 (~lisp123@5.30.23.247)
[01:15:12] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[01:24:04] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[01:28:56] <copec> Could you explain a little more Alex[m]?
[01:30:47] <copec> So basically sort of the natural flow with CL's generic functions?
[01:31:31] <Alex[m]> If you have a set interface that has a single method `contains` that determines whether an element is in the set. Then you define a function/method `isSubset` that determines if one set is a subset of another and uses the contains method. That works fine but you might have a certain implementation of set that has a more performant implementation of subset but I don't have a good answer on how to make `subset` use that with ad hoc polymorphism.
[01:34:02] <Alex[m]> With multiple dispatch you can just dispatch to the right implementation based on the types.
[01:34:38] <Alex[m]> I don't know that much about multi-methods/multiple dispatch though.
[01:34:50] <mfiano> For one, they dispatch on classes or instances, not types.
[01:36:55] <Alex[m]> üëç
[01:55:09] <pjb> They're still classes.
[01:55:44] <mfiano> What is they?
[01:55:53] <pjb> The arguments to the method.
[01:56:16] <mfiano> parameters or arguments?
[01:56:20] <mfiano> I am not following you.
[01:56:45] <pjb> for example,  abstract-set with subclasses bit-vector-set and list-set.
[01:57:05] <pjb> contains is defined on abstract-set and  implemented in the subclasses.
[01:58:08] <pjb> subset is defined and implemented on abstract set, but it can be overriden (subset bit-vector-set bit-vector-set) will use bit-and  (subset list-set list-set)  will use cl:subsetp
[01:58:25] <pjb> note that you still have to optimize (subset bit-vector-set list-set) and vice-versa‚Ä¶
[01:59:31] <pjb> This can be done by providing a (as-bit-vector list-set) --> bit-vector and use that with bit-and.  
[01:59:59] <pjb> There's no gain to be found dispatching on types: you can dispatch on classes.
[02:00:46] <pjb> In any case, types are a very badly defined concept, of dubious usefulness.
[02:06:36] *** Joins: CptKirk23 (~CptKirk@70-57-27-195.hlrn.qwest.net)
[02:07:48] <Alex[m]> I was referencing Haskell types where I wanted to dispatch but couldn't.
[02:08:47] <pjb> Yeah, Haskell‚Ä¶
[02:09:01] <pjb> The more I learn Haskell, the less I like it.
[02:09:57] <Alex[m]> ü§∑‚Äç‚ôÇÔ∏è
[02:10:29] <Alex[m]> I'm not evangelizing
[02:10:49] <mfiano> The more I learn Haskell, the more it seems like they went to great lengths to make it less like Lisp, starting with the precedence operator.
[02:11:37] <mfiano> I've been banned in a couple Haskell communities before for asking why it isn't done like <insert Lisp method>
[02:12:24] <mfiano> It's very strange and troubling to think about why a language cares that much about hiding its Lisp roots.
[02:12:26] <copec> I look at every other language as a DSL, just some more overarching than others
[02:13:14] <White_Flame> I actually like how prolog did precedence.  It is always prefix, but with an optional infix form
[02:16:56] <mfiano> The thing I dislike about Haskell the most, is it seems even more "research-y" than Lisp, and with most libraries being incomprehensible type system abuses.
[02:17:15] <White_Flame> literally "I have a hammer, everything is a nail"
[02:17:20] <White_Flame> regarding the type system
[02:17:46] <White_Flame> it is a very academic thing to attempt to reduce an entire field to a singular composable model
[02:18:06] <mfiano> Eric Normand gave a good talk about his experience using Haskell professionally.
[02:18:14] <copec> I think well known problems being established in Haskell is great, it seems a very readable/maintainable system for encoding a problem
[02:18:42] <copec> But it is an overarching enforced philosophy, and it implies you know exactly what you are doing before you do it
[02:18:51] <mfiano> I think I am contributing to offtopicness so I'll go afk
[02:19:11] <White_Flame> (oh, this isn't lispcafe)
[02:19:29] <copec> mfiano, we aren't competing with anything on topic right now, or I would go afk too
[02:22:31] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[02:47:05] *** Quits: Josh_2 (~user@37.25.47.130) (Remote host closed the connection)
[03:00:51] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[03:06:02] <edgar-rft> (defun dubious-p (x) (declare (ignore x)) (zerop (random 2)))
[03:06:02] <edgar-rft> (deftype dubious () '(satisfies dubious-p))
[03:06:02] <edgar-rft> now you can test yourself: (typep 'usefulness 'dubious) => ...
[03:12:37] *** Joins: lisp123 (~lisp123@5.30.23.247)
[03:18:01] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 245 seconds)
[03:21:46] *** Quits: random-nick (~random-ni@87.116.178.45) (Ping timeout: 245 seconds)
[03:44:09] <mfiano> tsk, tsk. it's dubious-p is dubious; it's dubiousp
[04:16:12] *** Quits: CptKirk23 (~CptKirk@70-57-27-195.hlrn.qwest.net) (Ping timeout: 256 seconds)
[04:19:20] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 246 seconds)
[04:21:00] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Read error: Connection reset by peer)
[04:22:25] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[04:37:51] <seok-> could someone teach me what semaphores are please ?
[05:17:38] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[05:20:31] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 245 seconds)
[05:20:31] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 245 seconds)
[05:31:25] *** Joins: lottaquestions (~nick@2607:fa49:503e:3000:d480:3919:61b7:3376)
[05:54:02] *** Joins: lisp123 (~lisp123@5.30.23.247)
[05:58:38] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 250 seconds)
[05:59:41] *** Quits: sts-q (~sts-q@91.200.108.159) (Ping timeout: 245 seconds)
[06:00:31] <White_Flame> seok-: it's an atomically-accessed number, listing how many available "things" can be taken
[06:00:52] <White_Flame> a semaphore that only goes from 0 to 1 is generally called a mutex, with a simplified api
[06:01:35] *** Joins: sts-q (~sts-q@212.53.219.132)
[06:02:00] <White_Flame> for managing exclusionary access to one thing
[06:03:08] *** Joins: gko (~user@user/gko)
[06:03:32] <White_Flame> the OS lets you efficiently wait until the semaphore value changes, or increments, or whatever, so you're not polling
[06:05:01] <White_Flame> things like barriers, where one process blocks until N separate (and probably parallel) tasks are completed, are an example of where a non-mutex semaphore is useful
[07:38:10] *** Joins: phossil (tophullyte@gateway/vpn/protonvpn/tophullyte)
[07:40:59] *** Quits: tophullyte (tophullyte@gateway/vpn/protonvpn/tophullyte) (Ping timeout: 252 seconds)
[08:15:13] *** Quits: phossil (tophullyte@gateway/vpn/protonvpn/tophullyte) (Quit: Leaving)
[08:36:15] *** Joins: lisp123 (~lisp123@5.30.23.247)
[08:51:47] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[08:52:12] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Read error: Connection reset by peer)
[08:52:31] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[08:54:16] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 245 seconds)
[09:39:45] *** Joins: shka (~herr@109.231.6.176)
[10:30:13] *** Joins: tophullyte (tophullyte@gateway/vpn/protonvpn/tophullyte)
[11:21:58] *** Joins: lotuseater (~user@b2b-78-94-235-194.unitymedia.biz)
[11:35:55] *** Joins: hendursa1 (~weechat@user/hendursaga)
[11:37:34] *** Joins: selwyn (~selwyn@user/selwyn)
[11:38:54] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[11:52:24] *** Quits: Alex[m] (~thekkidda@2001:470:69fc:105::feaf) (Quit: Bridge terminating on SIGTERM)
[11:52:28] *** Quits: Gnuxie (~gnuxie@user/gnuxie) (Quit: Bridge terminating on SIGTERM)
[11:52:34] *** Quits: CodeBitCookie[m] (~code-bit-@2001:470:69fc:105::a2f) (Quit: Bridge terminating on SIGTERM)
[11:56:17] *** Joins: Gnuxie (~gnuxie@user/gnuxie)
[12:09:27] *** Quits: lotuseater (~user@b2b-78-94-235-194.unitymedia.biz) (Remote host closed the connection)
[12:18:00] *** Joins: CodeBitCookie[m] (~code-bit-@2001:470:69fc:105::a2f)
[12:25:19] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[12:54:34] <lisp123> I am trying to get my head around APPLY --> (apply #'+ '(1 2 3 4 5)) --> 15
[12:55:44] <lisp123> Is the above 'splicing' of '(1 2 3 4 5) into the &rest argument of #'+ due to: When the function receives its arguments via &rest, it is permissible (but not required) for the implementation to bind the rest parameter to an object that shares structure with the last argument to apply.
[12:56:56] <lisp123> And if so, are you aware of any implementations that do not do the following -->  "it is permissible (but not required) for the implementation ..."
[12:58:18] <beach> The simplest thing an implementation can do is to not share.
[12:58:58] <beach> Then, apply would just unpack its last argument, and pass its elements as additional arguments to the function in the first argument.
[12:59:35] <beach> The function being called would then parse the sequence of arguments given to it, according to its lambda list, and cons up a list for the &rest parameter.
[13:00:49] <beach> Sharing takes additional trickery on the part of the implementation.  Apply would then need to know whether the function being call has a &rest parameter and how many required and optional parameters precede it.
[13:01:58] <lisp123> Oh I see
[13:02:45] <lisp123> Thanks
[13:02:53] <beach> Sure.
[13:02:55] <beach> Some very inefficient implementation might pass all argument in a list, say BOCL would typically do that.
[13:03:49] <beach> Then, in stead of unpacking its last argument, APPLY would cons the preceding ones to the last one and call the function like that.
[13:04:05] <beach> In such an implementation, there would always be sharing.
[13:04:30] <lisp123> Is there ever a chance the end outcome is different between implementations?
[13:04:57] <beach> Sure, if you destructively modify the &REST parameter, you are on your own.
[13:05:22] <lisp123> I see
[13:06:08] <beach> What that phrase in the standard means is "Whatever you do, don't destructively modify the list in the &REST parameter".
[13:07:20] <lisp123> Thanks - so I will keep that in mind when writing functions that use &rest (since you never know who will use APPLY against it)
[13:07:39] <beach> Exactly.  But that would be normal programming practice anyway.
[13:08:30] <lisp123> Very true
[13:09:50] <beach> By the way, you do know that APPLY can take more than two arguments, right?
[13:10:06] <beach> (apply #'+ 1 2 3 '(4 5 6))
[13:10:08] <beach> stuff like that.
[13:10:37] <lisp123> Yes, I know it in theory but it's not second nature just yet. I had to force myself to use it just now on something and then looked up the definition again
[13:11:04] <beach> It is very useful for "intermediate" functions that take keyword parameters, and that want to modify a small subset of them without knowing all.
[13:12:01] <beach> Like (defun f (a b &rest keys &key c d &allow-other-keys) (apply #'g :c 234  :d 345 keys))
[13:12:47] <beach> There might then be multiple occurrences of :c and :d in the arguments that g receives, but that's allowed and well defined.
[13:13:41] <lisp123> Sorry, I didn't fully understand
[13:14:02] <lisp123> Let me try with an example on my end
[13:14:19] <beach> OK.
[13:15:32] <beach> The "intermediate" function is often an :AROUND method by the way.
[13:17:07] <lisp123> Seems very useful, I will read through it carefully today and experiment and try and figure how it works. I'm not that good with APPLY so I wouldn't want to take up any of your time just yet
[13:17:27] <lisp123> Thanks for this - :around methods are very useful IMO
[13:17:34] <beach> Indeed.
[13:18:38] <lisp123> Are you coding today as well?
[13:21:50] <beach> Every day, yes.
[13:22:39] <lisp123> Nice
[13:23:03] <beach> As you can see from this: https://github.com/robert-strandh
[13:27:02] <lisp123> So many lines of code --> Amazing to be able to keep track of it all (even in parts)
[13:27:24] <lisp123> Have you ever checked how much the total LoC is?
[13:27:31] <beach> I can't keep track of it.  Instead I document it and write lots of comments.
[13:28:01] <beach> Not very many, and I try my best to remove lines every day by extracting things to separate repositories, and refactoring existing code.
[13:28:03] <lisp123> But even documentation & comments take time to read and remember
[13:29:13] <lisp123> I feel like there is a non-linear scale where the larger the program gets, the harder it is --> Each extra bit adds so much more to remember and keep track of
[13:29:32] <beach> I don't see that.  I use comments and documentation to re-learn what I did in the past and forgot.
[13:30:02] <lisp123> I see
[13:35:23] <beach> Right now, SICL has around 127kLOC, because we have extracted several things as libraries: Eclector, Trucler, Clostrum, ctype, etc.  And there will be more.
[13:36:30] <beach> FORMAT and LOOP should be extracted.
[13:36:39] <lisp123> Amazing (such a large number)
[13:37:19] <beach> 3900 and 9800 LOC respectively.
[13:37:32] <beach> No, that's very small for a Common Lisp implementation. 
[13:37:43] <lisp123> My understanding was that everything was meant to be modular, in which case how do you separate between library & module?
[13:38:31] <beach> A library is usable to other implementations.  A module is not.
[13:38:49] <lisp123> Understood
[13:46:01] <beach> Or, rather, a module *might* be usable to other implementations, but it is less likely since it might depend on some overall design decisions for the implementation as a whole.  
[13:46:46] <lisp123> Makes sense
[13:50:28] <beach> For example, the exact slots in the class STANDARD-CLASS is likely to vary according to the implementation.  Similarly, SICL defines ARRAY as a standard class and most implementations might not do that.
[14:02:46] <lisp123> Oh, that's interesting
[14:03:16] <lisp123> I was thinking about that earlier this morning, whether it would be possible to extend the FUNCTION class to have a new slot :super-detailed-documentation (bad name choice)
[14:03:42] <lisp123> But I assumed the core classes for each main type would be the same
[14:18:43] *** Joins: random-nick (~random-ni@87.116.183.117)
[14:29:17] *** Joins: selwyn (~selwyn@user/selwyn)
[14:54:28] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[14:54:43] <beach> lisp123: You can't do that in a standard way because FUNCTION may be a built-in class.
[14:56:32] <beach> But in SICL, simple functions are instances of the class SICL-CLOS:SIMPLE-FUNCTION which is a subclass of FUNCALLABLE-STANDARD-OBJECT, so in SICL you can add slots to ordinary functions.
[14:57:00] <beach> On the other hand, you can do what you want with a hash table.  It doesn't ahve to be a slot.
[14:57:06] <lisp123> beach: Understood
[14:57:23] <lisp123> Yes, my current plan is simply to do it separately via a hash table (specifically utilising IBCL)
[14:57:35] <lisp123> (which stores the source code)
[15:29:21] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[15:32:36] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 245 seconds)
[16:00:49] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[16:22:47] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 246 seconds)
[16:24:48] *** Joins: aeth (~aeth@user/aeth)
[16:26:26] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[16:46:31] *** Joins: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca)
[16:51:07] *** Joins: CptKirk (~CptKirk@71-211-254-90.hlrn.qwest.net)
[17:37:41] *** Quits: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[17:41:05] *** Joins: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca)
[17:44:27] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Quit: WeeChat 3.3)
[17:45:30] *** Quits: hendursa1 (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[17:47:20] *** Joins: hendursa1 (~weechat@user/hendursaga)
[17:57:29] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[18:00:16] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[18:00:51] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Remote host closed the connection)
[18:01:15] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[18:21:54] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Remote host closed the connection)
[18:40:41] *** Joins: thrig (~thrig@65.113.153.50)
[18:54:05] *** Quits: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[18:54:46] <pjb> lisp123: do you have a repo with your code that stores the sources?
[19:01:37] <lisp123> pjb: Nothing fancy just yet. I'm currently (partially) using https://github.com/ashok-khanna/autologger/blob/main/cl-autologger.lisp
[19:02:47] <lisp123> My goal is to create a full documentation system --> Source Code from IBCL, a separate hash table (with same keys as the IBCL Hash for documentation) for documentation, e.g. (add-doc 'my-fn "ASDF") and then
[19:02:57] <lisp123> linking up to unit tests as working examples
[19:03:48] <lisp123> The final piece would be a code walker that translate a function into english, based on the doc strings of the individual functions in it plus the constructs it uses, but that's far down the road
[19:04:32] *** Quits: hendursa1 (~weechat@user/hendursaga) (Quit: hendursa1)
[19:04:33] <lisp123> One issue is the pretty-printing of either Elisp or SBCL (and I assume other implementations) is not great, so the source code doesn't look great
[19:04:58] *** Joins: hendursaga (~weechat@user/hendursaga)
[19:05:08] <White_Flame> documenting the "why" is usually more important than documenting the  "what"
[19:06:19] <lisp123> [Example of Code Walker Comment -- (let* ((x (complex-calc ....)  ((y ...>) (body) ---> Becomes "First calculate .... and then ...., If .... then return ....., otherwise ....)]
[19:07:58] <lisp123> White_Flame: Yes, I read that a lot. So the WHY should go into a separate docstring IMO, not the main one --> The main one IMO should be a plain english description of the what
[19:09:02] <White_Flame> yeah, "why" for the function docstrings, "what" for inline comments, if they're not too obvious
[19:09:24] <lisp123> I was doing it the other way
[19:10:15] <lisp123> pjb: I haven't started any work on my doc system, its probably something to look at in 3-6 months
[19:10:25] <lisp123> (so the code I linked isn't really relevant)
[19:31:48] *** Joins: rotateq (~user@p200300e78715be00fdfeed040e17b750.dip0.t-ipconnect.de)
[19:44:05] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Quit: Leaving)
[19:44:30] *** Joins: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net)
[19:48:06] *** Joins: lisp123_ (~lisp123@45.86.202.96)
[19:48:48] *** Quits: lisp123_ (~lisp123@45.86.202.96) (Client Quit)
[19:51:41] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 264 seconds)
[20:12:10] *** Quits: CptKirk (~CptKirk@71-211-254-90.hlrn.qwest.net) (Ping timeout: 256 seconds)
[20:34:35] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 265 seconds)
[20:34:51] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[20:36:05] *** Joins: aeth (~aeth@user/aeth)
[20:39:00] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[21:11:13] *** Joins: CptKirk (~CptKirk@70-57-27-195.hlrn.qwest.net)
[21:45:53] *** Joins: lisp123 (~lisp123@45.86.202.96)
[21:48:30] *** Quits: CptKirk (~CptKirk@70-57-27-195.hlrn.qwest.net) (Ping timeout: 256 seconds)
[21:52:43] <mfiano> lisp123: re: would the end result differ across any implementations: Possibly, if the list plus all preceding arguments to the function sums up to more than 50.
[21:53:29] <lisp123> mfiano: Thanks for the color --- looks like one has to be very careful when using &rest
[21:53:35] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[21:53:50] <mfiano> If you don't understand why, let me make a gist
[21:54:19] <thrig> "can we give this argument a rest?" "sure, but not too long"
[21:54:34] <mfiano> https://gist.github.com/mfiano/1a31ef23cdde03e17843e02ffbffa46f
[21:54:55] <mfiano> Note that ABCL uses the minimum. Other implementations may follow
[21:55:49] <lisp123> mfiano: How did you do that so far?
[21:55:52] <lisp123> fast*
[21:56:02] <mfiano> It turns out I had the gist already
[21:56:04] <lisp123> Do you have all the implementations loaded on your computer?
[21:56:46] *** Quits: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 245 seconds)
[21:56:54] <lisp123> Ah cool
[21:57:53] <mfiano> The standard mandates call-arguments-limit be at least 50, (and other minimums for the other constant limits)
[21:58:36] <mfiano> 50 is a lot of arguments, but maybe not enough for APPLYing an &rest list, depending on the problem domain.
[21:59:06] <lisp123> mfiano: Yup, it depends on the problem - some sort of recursive application may get caught up in that
[21:59:55] *** Joins: yehowshua (~yehowshua@192.24.14.195)
[22:02:37] *** Quits: thrig (~thrig@65.113.153.50) (Remote host closed the connection)
[22:02:46] *** Joins: thrig (~thrig@65.113.153.50)
[22:08:01] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Ping timeout: 245 seconds)
[22:24:32] *** Quits: thrig (~thrig@65.113.153.50) (Remote host closed the connection)
[22:31:29] *** Joins: CptKirk (~CptKirk@70-57-27-195.hlrn.qwest.net)
[22:40:04] *** Quits: yehowshua (~yehowshua@192.24.14.195) (Ping timeout: 256 seconds)
[22:56:06] *** Quits: lottaquestions (~nick@2607:fa49:503e:3000:d480:3919:61b7:3376) (Ping timeout: 250 seconds)
[23:00:22] *** Joins: yehowshua (~yehowshua@192.24.14.195)
[23:02:56] *** Quits: CptKirk (~CptKirk@70-57-27-195.hlrn.qwest.net) (Quit: Client closed)
[23:07:13] *** Joins: CptKirk (~CptKirk@70-57-27-195.hlrn.qwest.net)
[23:17:02] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[23:19:12] *** Quits: yehowshua (~yehowshua@192.24.14.195) (Quit: Client closed)
[23:39:12] *** Joins: tyson2 (~user@cpe44d9e795a64f-cm688f2e2dfaa0.sdns.net.rogers.com)
[23:51:08] *** Quits: shka (~herr@109.231.6.176) (Ping timeout: 250 seconds)
[23:52:33] <pjb> lisp123: it's nice to have several implementations loaded; you can use a script such as clall to run expressions thru each of them.
[23:53:36] <pjb> lisp123: sometimes, when a compiler gives you an obscure error message, or a debugger doesn't help you debug a strange bug, just compiling the code with another compiler or running it in another implementation provides you with a different error message or debugging tools to illuminate the problem.
[23:57:32] <lisp123> pjb: Thanks, that's a good idea. I was thinking of simply testing on more implementations to be "conformant", but didn't realise it could also benefit development directly
