[00:21:11] <FromDiscord> <RattleyCooper> I was going to post on nim lang forum but it says I have to confirm my email.  I never got a confirmation email and I don't have an option to resend it.  Anybody know how to fix that?  Should I try making a new account?
[00:23:45] <FromDiscord> <zidsal> whatever you do don't delete the account or you're boned
[00:27:10] <FromDiscord> <RattleyCooper> Lol, ok
[00:27:50] <FromDiscord> <treeform> Its very touchy
[00:32:02] <FromDiscord> <RattleyCooper> I'll try making a new account tomorrow
[00:58:40] *** Quits: vsantana (~Thunderbi@fttx-17713614973.usr.predialnet.com.br) (Ping timeout: 252 seconds)
[01:06:22] *** Quits: beshr (~beshr@user/beshr) (Ping timeout: 252 seconds)
[01:08:59] *** Joins: beshr (~beshr@78-72-246-187-no2006.tbcn.telia.com)
[01:08:59] *** Quits: beshr (~beshr@78-72-246-187-no2006.tbcn.telia.com) (Changing host)
[01:08:59] *** Joins: beshr (~beshr@user/beshr)
[01:09:46] *** Joins: xet7 (~xet7@user/xet7)
[01:12:06] *** Quits: max22- (~maxime@2a01cb0883359800c0516f45dc40d698.ipv6.abo.wanadoo.fr) (Remote host closed the connection)
[01:42:22] <FromDiscord> <checkersai> sent a code paste, see https://play.nim-lang.org/#ix=3tyi
[01:44:28] <FromDiscord> <dom96> In reply to @RattleyCooper "I was going to": I can confirm your account
[01:44:33] <FromDiscord> <dom96> just tell me what the nickname is 🙂
[01:49:18] <FromDiscord> <InventorMatt> sent a code paste, see https://play.nim-lang.org/#ix=3tyj
[01:52:24] <FromDiscord> <checkersai> In reply to @InventorMatt "you can do this": I don't want to change the variable outside the scope, I just want a local mutable variable
[01:53:47] <FromDiscord> <InventorMatt> in that case I don't think there is a better way to do that
[01:53:47] <FromDiscord> <RattleyCooper> In reply to @dom96 "just tell me what": It's RattleyCooper 😛
[01:54:16] <FromDiscord> <RattleyCooper> In reply to @dom96 "I can confirm your": And thank you!!!
[01:56:00] <FromDiscord> <dom96> done
[02:10:20] <FromDiscord> <theangryepicbanana> In reply to @InventorMatt "in that case I": wait, parameters in nim are immutable?
[02:10:33] <FromDiscord> <theangryepicbanana> I don't recall the docs ever mentioning that
[02:11:46] <FromDiscord> <dom96> depends on the parameter's type
[02:12:10] <FromDiscord> <theangryepicbanana> In reply to @dom96 "depends on the parameter's": besides var types
[02:12:18] <FromDiscord> <theangryepicbanana> just like regular types
[02:14:08] <FromDiscord> <dom96> and ref types
[02:15:06] <FromDiscord> <theangryepicbanana> sent a code paste, see https://play.nim-lang.org/#ix=3tyr
[02:19:18] <FromDiscord> <checkersai> sent a code paste, see https://play.nim-lang.org/#ix=3tys
[02:20:14] <FromDiscord> <theangryepicbanana> In reply to @checkersai "yeah you can't do": why though? not even a pragma for it?
[02:20:26] <FromDiscord> <theangryepicbanana> (edit) "In reply to @checkersai "yeah you can't do": why though? not even a pragma for it? ... " 03added "(without macros!)"
[02:21:15] <FromDiscord> <Hi02Hi> In reply to @theangryepicbanana "wait, parameters in nim": ^
[02:21:35] <FromDiscord> <carmysilna> Because just like Rust, mutability is explicit. if you don't say something is `var` or `ref`, you can't mutate it
[02:21:44] <FromDiscord> <theangryepicbanana> not in the slightest
[02:22:04] <FromDiscord> <theangryepicbanana> nim has explicit keywords for both mutable and immutable variables
[02:22:28] <FromDiscord> <theangryepicbanana> in that case, I don't see why something like `proc thing(var a: int): int` couldn't be allowed
[02:22:42] <FromDiscord> <carmysilna> It is allowed
[02:22:51] <FromDiscord> <carmysilna> but written `a: var int`
[02:22:59] <FromDiscord> <theangryepicbanana> that's still a different thing
[02:23:13] <FromDiscord> <carmysilna> it returns an immutable int, though.
[02:23:37] <FromDiscord> <theangryepicbanana> `var a: int` would allow `a` to be mutated locally, and not mutate its argument
[02:24:19] <FromDiscord> <carmysilna> sent a code paste, see https://play.nim-lang.org/#ix=3tyt
[02:24:26] <FromDiscord> <carmysilna> In reply to @theangryepicbanana "`var a: int` would": I'd assume the idiom for this is a local var shadow, like Rust
[02:24:27] <FromDiscord> <theangryepicbanana> that's not what I'm wanting bruh
[02:25:09] <FromDiscord> <theangryepicbanana> sent a code paste, see https://play.nim-lang.org/#ix=3tyu
[02:26:02] <FromDiscord> <carmysilna> sent a code paste, see https://play.nim-lang.org/#ix=3tyv
[02:26:09] <FromDiscord> <theangryepicbanana> did you not see the first thing I said about how that's dumb
[02:26:40] <FromDiscord> <theangryepicbanana> I don't even understand why parameters would be immutable by default in the first place if nothing else behaves like that
[02:27:47] <FromDiscord> <ElegantBeef> "if nothing else behaves like that"?
[02:30:33] <FromDiscord> <ElegantBeef> If you can mutate parameters dont you have to pass them by copy every time regardless of size?
[02:30:41] <FromDiscord> <theangryepicbanana> In reply to @ElegantBeef ""if nothing else behaves": last time I checked, fields on objects(/tuples?) aren't immutable by default, with no way to specify otherwise
[02:31:20] <FromDiscord> <theangryepicbanana> In reply to @ElegantBeef "If you can mutate": by mutable parameters, I mean parameters that can be modified locally without affecting the original argument
[02:31:29] <FromDiscord> <ElegantBeef> Exactly, which means you have to copy it
[02:31:57] <FromDiscord> <theangryepicbanana> I'm again saying that there should be a default syntax for it rather than a workaround
[02:33:47] <FromDiscord> <ElegantBeef> The issue is going to be this is super easy to do in a macro so there isnt going to much reason to support it in compiler
[02:34:54] <FromDiscord> <theangryepicbanana> In reply to @ElegantBeef "The issue is going": I don't see how that's possible if you'd have to redefine the semantics of proc, func, iterator, method, and converter
[02:35:08] <FromDiscord> <theangryepicbanana> or rather, I don't see how it's convenient
[02:35:12] <FromDiscord> <ElegantBeef> To do what?
[02:35:27] <FromDiscord> <theangryepicbanana> In reply to @ElegantBeef "The issue is going": to do this
[02:35:42] <FromDiscord> <ElegantBeef> It's really not that hard
[02:37:19] <FromDiscord> <theangryepicbanana> In reply to @ElegantBeef "It's really not that": last time I checked, `var` sections don't stop after a semicolon. even if they didn't that wouldn't match nim's parameter syntax because parameters can also be delimited on commas
[02:37:31] <FromDiscord> <theangryepicbanana> (edit) "on" => "by"
[02:38:11] <FromDiscord> <theangryepicbanana> so something like `proc thing(var a: int, b: string)`  either wouldn't do what you'd expect, or `proc thing(var a: int; b: string)` wouldn't work at all
[02:38:36] <FromDiscord> <theangryepicbanana> (edit) "so something like `proc thing(var a: int, b: string)`  either wouldn't do what you'd expect, or `proc thing(var a: int; b: string)` wouldn't work at all ... " 03added "(or it'd just make the impl a lot harder)"
[02:39:10] <FromDiscord> <konsumlamm> propose it then, if you really think it's important
[02:39:26] <FromDiscord> <ElegantBeef> There we did it we shadowed it https://play.nim-lang.org/#ix=3tyA
[02:39:36] <FromDiscord> <theangryepicbanana> not that I think it's super important, I just don't see why a workaround is accepted as a solution
[02:40:34] <FromDiscord> <konsumlamm> a situation where you need something like that rarely ever happens in the first place
[02:40:35] <FromDiscord> <ElegantBeef> removed the wrong code
[02:40:36] <FromDiscord> <ElegantBeef> https://play.nim-lang.org/#ix=3tyB
[02:41:04] <FromDiscord> <ElegantBeef> And you could support the code your propsed with a macro
[02:41:17] <FromDiscord> <leorize> parameters are immutable by default because that's what people want 90% of the time
[02:41:20] <FromDiscord> <theangryepicbanana> In reply to @konsumlamm "a situation where you": I've seen it happen in langs with similar macro capabilities as nim (e.g haxe, ocaml, crystal) and they all end up never getting QoL features because it's either not important (sometimes understandable) or "it can be done with a macro"
[02:41:45] <FromDiscord> <theangryepicbanana> In reply to @leorize "parameters are immutable by": what about the other 10% of the time lol
[02:41:55] <FromDiscord> <ElegantBeef> you shadow the specific variable you want
[02:42:08] <FromDiscord> <leorize> you either create a local variable or you just use the built-in result
[02:42:20] <FromDiscord> <konsumlamm> OCaml doesn't even have (normal) mutable variables lol
[02:42:26] <FromDiscord> <theangryepicbanana> like I can see why they're immutable by default and that's fine, but not having a builtin keyword or pragma to change that is a bit annoying
[02:42:29] <FromDiscord> <ElegantBeef> Exactly in this example result is what you' want
[02:42:33] *** Quits: sagax (~sagax@213.138.71.146) (Ping timeout: 245 seconds)
[02:42:36] <FromDiscord> <ElegantBeef> (edit) "you'" => "you'd"
[02:42:50] <FromDiscord> <ElegantBeef> `result = a  3` is a proper solution
[02:42:55] <FromDiscord> <theangryepicbanana> (edit) "like I can see why they're immutable by default and that's fine, but not having a builtin keyword or pragma to change that ... is" 03added "for a variable"
[02:43:00] <FromDiscord> <theangryepicbanana> but that doesn't always work
[02:43:08] <FromDiscord> <ElegantBeef> My shadow macro does
[02:43:09] <FromDiscord> <theangryepicbanana> what if you want to change a parameter and then keep using it
[02:43:16] <FromDiscord> <konsumlamm> In reply to @theangryepicbanana "like I can see": again, make an RFC if you think that matters
[02:43:28] <FromDiscord> <theangryepicbanana> like sure macros yay, but it's just a bit irritating is all
[02:43:48] <FromDiscord> <leorize> well sink is there but the mutability is kind of a side-effect...
[02:44:10] <FromDiscord> <ElegantBeef> You could always implement the syntax you want but yes you'd have to annotate it with some pragma
[02:44:29] <FromDiscord> <theangryepicbanana> In reply to @leorize "well sink is there": lol isn't mutability supposed to be a side effect though?
[02:44:46] <FromDiscord> <theangryepicbanana> (anyways sink seems dangerous, staying away from it for now)
[02:44:47] <FromDiscord> <dom96> writing `var a = a` isn't a workaround
[02:44:55] <FromDiscord> <dom96> it works very well
[02:45:01] <FromDiscord> <dom96> there is no need for the syntax sugar here
[02:45:03] <FromDiscord> <leorize> sink is perfectly safe btw↵(@theangryepicbanana)
[02:45:12] <FromDiscord> <ElegantBeef> Sink will copy if it cannot move
[02:45:17] <FromDiscord> <theangryepicbanana> isn't it still in the experimental docs though
[02:45:22] <FromDiscord> <ElegantBeef> Nope
[02:45:27] <FromDiscord> <ElegantBeef> It's in the destructor docs
[02:45:31] <FromDiscord> <theangryepicbanana> huh
[02:45:44] <FromDiscord> <ElegantBeef>  https://media.discordapp.net/attachments/371759389889003532/867167938863955978/unknown.png
[02:45:49] <FromDiscord> <leorize> side effect is that it's not to express that you want the parameter to be proc-mutable-only
[02:46:00] <FromDiscord> <theangryepicbanana> well anyways I suppose a pragma could be fine
[02:46:32] <FromDiscord> <theangryepicbanana> @ElegantBeef in your example, would there be a way to just annotate the parameter to shadow with the pragma?
[02:46:40] <FromDiscord> <leorize> the mutability comes from the ownership transfer
[02:47:10] <FromDiscord> <ElegantBeef> Ah shame you cannot write `var a: t`
[02:47:33] <FromDiscord> <theangryepicbanana> oh are var sections not considered expressions
[02:47:36] <FromDiscord> <leorize> you can attach a pragma to the parameter though
[02:47:51] <FromDiscord> <ElegantBeef> or do `i: mut int` like a sadist
[02:47:52] <FromDiscord> <theangryepicbanana> well sure, but I'm not sure if that'd give me access to the proc as well
[02:48:01] <FromDiscord> <ElegantBeef> well the pragma on the proc would
[02:48:09] <FromDiscord> <theangryepicbanana> yes but what if it's on the param instead
[02:48:17] <FromDiscord> <ElegantBeef> You'd also need one on the proc
[02:48:22] <FromDiscord> <theangryepicbanana> :/
[02:48:32] <FromDiscord> <leorize> `i: copy int` or `i {.copy.}: int`
[02:48:50] <FromDiscord> <leorize> both of which can be transformed by the macro
[02:49:12] <FromDiscord> <theangryepicbanana> yeah but I don't really want a pragma attached to the proc as well
[02:49:21] <FromDiscord> <ElegantBeef> Well then you cannot do this
[02:49:32] <FromDiscord> <ElegantBeef> You need a pragma attached to the proc to insert the shadow calls
[02:49:50] <FromDiscord> <ElegantBeef> Only a macro operating on the procdef can change it's contents
[02:50:16] <FromDiscord> <ElegantBeef> So then you need to make an RFC detailing what you want and why a macro doesnt suffice
[02:50:48] <FromDiscord> <theangryepicbanana> yeah that makes sense ig. it's definitely nitpick-y, but I'm not a fan of using macros where stuff could easily be builtin
[02:51:20] <FromDiscord> <konsumlamm> most uses of macros could be replaced by something builtin
[02:51:25] <FromDiscord> <ElegantBeef> all
[02:51:34] <FromDiscord> <konsumlamm> but that doesn't necessarily make it s good idea to do so
[02:51:37] <FromDiscord> <theangryepicbanana> well yes but that's not the point
[02:51:39] <FromDiscord> <konsumlamm> (edit) "s" => "a"
[02:52:15] <FromDiscord> <leorize> the rfc process is always there for adding new features to the language
[02:52:15] <FromDiscord> <dom96> Nim's philosophy is explicitly to implement a small core language that's extensible via macros
[02:52:29] <FromDiscord> <dom96> and in fact we've got too much implemented in the compiler
[02:52:38] <FromDiscord> <leorize> not all can be done like that tbf
[02:53:56] <FromDiscord> <theangryepicbanana> again I don't really need to propose it because I don't think it matters all too much, but allowing var sections as an expression (for use in macros) might actually be a decent idea
[02:54:36] <FromDiscord> <leorize> it's not about expression, unfortunately
[02:54:57] <FromDiscord> <theangryepicbanana> why else wouldn't it be able to work?
[02:55:18] <FromDiscord> <leorize> it's about what the compiler considers well-formed ast
[02:55:28] <FromDiscord> <ElegantBeef> The semantic pass on the keyword var has an explicit path to valid code
[02:55:37] <FromDiscord> <theangryepicbanana> oh that makes sense
[02:56:04] <FromDiscord> <ElegantBeef> not to say you cannot use macros with var statements they're just pragmas on the ident like so `var a {.byaddr.} = c`
[02:56:20] <FromDiscord> <theangryepicbanana> so `var` will otherwise be an actual invalid token, and not just parsed a function call or something?
[02:57:10] <FromDiscord> <ElegantBeef> Interestingly there is an explict error for that syntax you proposed 😄 `Error: the syntax is 'parameter: var T', not 'var parameter: T'`
[02:57:15] <FromDiscord> <theangryepicbanana> In reply to @ElegantBeef "not to say you": yeah I mean the other way around, like `myMacro(var thing = 1)`
[02:57:25] <FromDiscord> <theangryepicbanana> lmao that's what I was thinking
[02:57:41] <FromDiscord> <ElegantBeef> That's valid since the entire statement is inside the macro, and is a valid statement
[02:58:13] <FromDiscord> <theangryepicbanana> would `myMacro(a: int, var b: string)` also be valid or no?
[02:58:17] <FromDiscord> <ElegantBeef> For these experiments i highly suggest playing around with dumptree to see what chooches like so https://play.nim-lang.org/#ix=3tyC
[02:58:25] <FromDiscord> <theangryepicbanana> 👍
[02:58:45] <FromDiscord> <leorize> the ast goes more or less like this\: ProcDef(..., FormalParams(Sym, IdentDefs...), ...)
[02:58:45] <FromDiscord> <theangryepicbanana> thanks for the help
[02:58:51] <FromDiscord> <theangryepicbanana> hmm
[02:59:14] <FromDiscord> <theangryepicbanana> that reminds me (completely different topic ik), will nim support pattern matching on ast nodes/syntax?
[02:59:19] <FromDiscord> <leorize> the params is the FormalParams part and VarSection is not a valid child for it
[02:59:56] <FromDiscord> <leorize> see fusion/matching↵(@theangryepicbanana)
[03:00:11] <FromDiscord> <theangryepicbanana> haxe has this really cool thing where you can do something like `case macro thing($a + $b):` to match the expr `thing(<anything> + <anything>)`
[03:00:47] <FromDiscord> <ElegantBeef> Nim already does
[03:00:48] <FromDiscord> <dom96> !eval import macros; const s = parseStmt("myMacro(var x=1)").treeRepr; echo s
[03:00:50] <NimBot> StmtList↵  Call↵    Ident "myMacro"↵    ExprEqExpr↵      VarTy↵        Ident "x"↵      IntLit 1
[03:01:11] <FromDiscord> <ElegantBeef> https://nim-lang.org/docs/manual_experimental.html#term-rewriting-macros-pattern-operators
[03:01:13] <FromDiscord> <theangryepicbanana> In reply to @ElegantBeef "Nim already does": oh? like, actual pattern matching?
[03:01:15] <FromDiscord> <dom96> heh, best do it in play.nim-lang.org
[03:01:20] <FromDiscord> <theangryepicbanana> oh yeah that thing
[03:01:35] <FromDiscord> <theangryepicbanana> I meant like inside a macro as a statement or something (like in case...of)
[03:01:45] <FromDiscord> <ElegantBeef> Ah there is a matching macro package in `fusion`
[03:01:51] <FromDiscord> <ElegantBeef> https://nim-lang.github.io/fusion/src/fusion/matching.html
[03:02:24] <FromDiscord> <theangryepicbanana> yeah I've seen that, but I'm not sure if it supports direct matching on syntax like I described
[03:02:36] <FromDiscord> <theangryepicbanana> like on NimNode, etc
[03:02:57] *** Quits: lain (~lain@172.16.254.xxx) (Quit: brb!)
[03:02:58] <FromDiscord> <ElegantBeef> Nah it'd have to be on the `infix(ident"+", a, b)` if that's even possible
[03:03:09] <FromDiscord> <theangryepicbanana> oof
[03:03:11] <FromDiscord> <hugogranstrom> The `quote do` of pattern matching would be lit
[03:03:28] <FromDiscord> <ElegantBeef> I generally dont follow pattern matching, so i dont actually know
[03:04:13] <FromDiscord> <theangryepicbanana> here's an example of where I've actually used it btw <https://github.com/ALANVF/star/blob/master/src/Util.hx#L59-L76>
[03:04:22] <FromDiscord> <theangryepicbanana> (in haxe)
[03:05:00] <FromDiscord> <ElegantBeef> It could be done by parsingExpr the given nimnode and doing string compare i guess, though might be dangerous to do that way
[03:05:48] <FromDiscord> <theangryepicbanana> that sounds kinda hacky
[03:05:58] <FromDiscord> <ElegantBeef> Well reading pattern matching seems hacky to me 😛
[03:06:49] *** Quits: Vladar (~Vladar@46.162.2.53) (Quit: Leaving)
[03:07:01] <FromDiscord> <theangryepicbanana> eh
[03:07:05] <FromDiscord> <theangryepicbanana> I quite like it
[03:07:06] *** Joins: lain (~lain@172.16.254.xxx)
[03:07:13] <FromDiscord> <theangryepicbanana> it tunes down the verbosity of the rest of the code
[03:08:17] <FromDiscord> <ElegantBeef> Hey i'm a numpty no one needs to defend their views to me
[03:10:41] <FromDiscord> <theangryepicbanana> In reply to @ElegantBeef "Hey i'm a numpty": no I'm just saying it makes the code a lot cleaner is all
[03:30:29] *** Quits: xet7 (~xet7@user/xet7) (Remote host closed the connection)
[03:35:19] <FromDiscord> <Ayy Lmao> I'm making an extension .dll for a program, and when I do something bad like try to call a function that is nil, it crashes my program silently. Is there a way to stop that and somehow display an error message? I know about `globalRaiseHook` but I'm not sure what to do there.
[03:43:38] <FromDiscord> <demotomohiro> try statement doesn't catch such err?
[03:47:16] <FromDiscord> <Ayy Lmao> I will test that out
[03:50:25] <FromDiscord> <Ayy Lmao> Yeah it's still crashing my program inside the try statement
[03:51:16] <FromDiscord> <Ayy Lmao> It's because it involves window messages I guess.
[03:59:27] <FromDiscord> <theangryepicbanana> In reply to @Ayy Lmao "I'm making an extension": try checking it for nil manually?
[04:04:05] <FromDiscord> <Ayy Lmao> @theangryepicbanana My problem isn't that I can't get the code to run. If I check for nil manually the code runs. My problem is that I forgot to check for nil and it took me a long time to figure out what was wrong because the program crashes silently. I'm wondering if there is a way to get the program to give some feedback if I forget to check for nil.
[04:04:28] <FromDiscord> <theangryepicbanana> In reply to @Ayy Lmao "<@!356108561232953344> My problem isn't": the `notNil` pragma might help
[04:04:37] <FromDiscord> <theangryepicbanana> (edit) "In reply to @Ayy Lmao "<@!356108561232953344> My problem isn't": the `notNil` ... pragma" 03added "experimental"
[04:05:57] <FromDiscord> <Ayy Lmao> In reply to @theangryepicbanana "the `notNil` experimental pragma": I'll look into it, thanks for the tip
[04:20:47] *** Quits: krux02 (~krux02@p200300ca8f251700e49676b6281f09e9.dip0.t-ipconnect.de) (Remote host closed the connection)
[04:40:02] <FromDiscord> <dan> In reply to @impbox "(best to ask your": hi! sorry, i went to sleep an hour after i tagged you yesterday, but my question was concerning the build process of nim stuff, when using just the generated c files
[04:42:02] <FromDiscord> <dan> i looked through nico a bit and saw something that looked like it could work for me. you use a dump command there and read the second to last element. im guessing thats the path to the nim standard library. is it guaranteed to be the second to last always? and how did you arrive at that solution?
[04:43:42] <FromDiscord> <impbox [ftsf]> pretty sure i just copied someone else's solution
[04:43:52] <FromDiscord> <dan> 😂
[04:44:02] <FromDiscord> <dan> do you remember who so i can annoy him?
[04:44:22] <FromDiscord> <dan> (edit) "him?" => "them?"
[04:44:34] <FromDiscord> <impbox [ftsf]> i don't know where i got it from sorry
[04:51:07] <FromDiscord> <dan> alright thank you anyways
[04:51:38] <FromDiscord> <dan> taking a look at nico has brought me a bit close to actually integrating nim into my work project
[04:51:46] <FromDiscord> <dan> (edit) "close" => "closer"
[06:19:05] <FromDiscord> <@bracketmaster-5a708063d73408ce4> I'm currently fighting macros
[06:19:05] <FromDiscord> <@bracketmaster-5a708063d73408ce4> https://play.nim-lang.org/#ix=3tzc
[06:19:23] <FromDiscord> <@bracketmaster-5a708063d73408ce4> How can I make line 11 work? ↵↵var instance = sometype(str.len).uint64
[06:23:47] <FromDiscord> <ElegantBeef> Is the macro supposed to emit this or use it internally?
[06:23:59] <FromDiscord> <@bracketmaster-5a708063d73408ce4> use it internally
[06:25:30] *** Joins: stkrdknmibalz (~test@rrcs-75-87-43-226.sw.biz.rr.com)
[06:26:16] <FromDiscord> <@bracketmaster-5a708063d73408ce4> that's a dummy example - but essentially the same problem I'm having in a larger codebase
[06:27:46] <FromDiscord> <ElegantBeef> I dont know if this is possible
[06:27:55] <FromDiscord> <@bracketmaster-5a708063d73408ce4> is this impossible?
[06:27:56] <FromDiscord> <@bracketmaster-5a708063d73408ce4> basically, I've got my own internal bigint library that uses arrays instead of seqs
[06:27:56] <FromDiscord> <@bracketmaster-5a708063d73408ce4> so the max value of a bigint is fixed after compilation
[06:28:04] <FromDiscord> <@bracketmaster-5a708063d73408ce4> I use macros to do computation to consume a string value and determine the needed array size for a big int
[06:28:25] <FromDiscord> <@bracketmaster-5a708063d73408ce4> but the macro need to start with a smaller bigint and keep making larger ones
[06:28:37] <FromDiscord> <@bracketmaster-5a708063d73408ce4> until it finds a sufficiently sized one
[06:29:25] <FromDiscord> <@bracketmaster-5a708063d73408ce4> because you don't know how many binary digits a large number such as "1234567898765432345678765" might need before you convert it to binary
[06:33:53] <FromDiscord> <ElegantBeef> I might be able to help with you more elaborate example
[06:33:58] <FromDiscord> <ElegantBeef> (edit) "you" => "your"
[06:34:23] <FromDiscord> <@bracketmaster-5a708063d73408ce4> My codebase is private - I guess I could push it public
[06:36:07] <FromDiscord> <ElegantBeef> Well a small practical example to see what could be worked around would be nice 😄
[06:36:56] <FromDiscord> <@bracketmaster-5a708063d73408ce4> shouldn't this work?
[06:36:57] <FromDiscord> <@bracketmaster-5a708063d73408ce4> https://paste.debian.net/1205079/
[06:38:47] <FromDiscord> <ElegantBeef> Not ideal but this "works" https://play.nim-lang.org/#ix=3tzg
[06:40:23] <FromDiscord> <@bracketmaster-5a708063d73408ce4> ok - that might help me solve my other problem
[06:40:29] <FromDiscord> <@bracketmaster-5a708063d73408ce4> but "why" does that work?
[06:40:34] <FromDiscord> <@bracketmaster-5a708063d73408ce4> what's going on there?
[06:42:14] <FromDiscord> <ElegantBeef> I think due to the type being derived from a parameter it's considered a runtime value on not compile time
[06:42:28] <FromDiscord> <ElegantBeef> It may possibly be a bug
[06:44:10] <FromDiscord> <@bracketmaster-5a708063d73408ce4> is your solution exploiting a bug?
[06:44:31] <FromDiscord> <ElegantBeef> No it may be working around one
[07:01:08] <FromDiscord> <ElegantBeef> Though the issue with the work around is it may require import macros in the submodule
[07:01:13] <FromDiscord> <ElegantBeef> (edit) "submodule" => "importing module"
[07:02:16] <FromDiscord> <@bracketmaster-5a708063d73408ce4> oof
[07:55:50] *** Quits: arkurious (~arkurious@user/arkurious) (Quit: Leaving)
[07:59:46] *** Joins: tiorock (~rc@192.12.113.223)
[07:59:46] *** Quits: tiorock (~rc@192.12.113.223) (Changing host)
[07:59:46] *** Joins: tiorock (~rc@user/rockcavera)
[07:59:46] *** Quits: rockcavera (~rc@user/rockcavera) (Killed (lithium.libera.chat (Nickname regained by services)))
[07:59:46] *** tiorock is now known as rockcavera
[08:35:42] <FromDiscord> <Jakraes> Is it not possible to assign a var to a parameter and then assign a new value to said parameter?
[08:35:44] <FromDiscord> <Jakraes> Like this
[08:36:02] *** Quits: supakeen (~user@python/site-packages/supakeen) (Quit: WeeChat 3.2)
[08:36:36] *** Joins: supakeen (~user@python/site-packages/supakeen)
[08:37:11] <FromDiscord> <Jakraes> sent a code paste, see https://play.nim-lang.org/#ix=3tzG
[08:37:48] *** Quits: springb0k (~springb0k@96.77.120.198) (Ping timeout: 252 seconds)
[08:40:11] <FromDiscord> <Jakraes> Oooh nvm
[08:40:21] <FromDiscord> <Jakraes> Just found out I can do test(p: var int)
[08:45:07] <FromDiscord> <Bung> is it possible create a code placeholder, when user call some function, inject code there?
[08:45:07] *** Joins: springb0k (~springb0k@96.77.120.193)
[08:46:19] <FromDiscord> <Rika> I'm sorry I don't understand well, but isn't that just a template?
[08:46:58] <FromDiscord> <Bung> but template inject code where it called
[08:49:15] <FromDiscord> <Rika> You can have a macro or template that acts as a pragma to a function which then could change the function body if that's what you're looking for
[08:49:25] <FromDiscord> <Rika> It's how the async pragma works
[08:49:57] <FromDiscord> <Bung> like aExpr;bTemplateExpand;cExpr this is template and macros works
[08:50:42] <FromDiscord> <Bung> what I want I call aFunc somewhere the body will inject to aExpr;
[08:53:08] <FromDiscord> <Bung> in other words, like declare a nim node, when user call func assign body to nim node, I detect it's not nil , I execute it somewhere.
[08:54:07] <FromDiscord> <ElegantBeef> As in recent fashion i think macrocache might help but uncertain the desire, want to show a "desired impl" so i could understand
[08:58:14] <FromDiscord> <Bung> sent a code paste, see https://play.nim-lang.org/#ix=3tzK
[08:58:36] <FromDiscord> <Bung> it's  like this, I just dont want store procs in runtime
[08:58:55] <FromDiscord> <ElegantBeef> Ah then yes macrocache to the rescue, will quickly make an example
[09:01:09] <FromDiscord> <Bung> oh, that save me, so I just add nimnode to a macrocache storage.
[09:01:50] <FromDiscord> <ElegantBeef> https://play.nim-lang.org/#ix=3tzN yep
[09:02:03] <FromDiscord> <ElegantBeef> `impl` in the first should be typed
[09:02:18] <FromDiscord> <ElegantBeef> that way it gets `sym` not `untyped`
[09:02:35] <FromDiscord> <ElegantBeef> (edit) "`untyped`" => "`ident`"
[09:04:01] <FromDiscord> <ElegantBeef> Proper version that will work across modules https://play.nim-lang.org/#ix=3tzQ
[09:06:19] <FromDiscord> <Bung> hmm how they work differently ?
[09:06:20] <FromDiscord> <Jakraes> Uuuh quick question, what's up with this? I'm not sure what the error might be https://media.discordapp.net/attachments/371759389889003532/867263699961905162/Screenshot_3.png
[09:06:41] <FromDiscord> <ElegantBeef> typed is semantically checked so you arent emitting untyped code
[09:07:07] <FromDiscord> <Jakraes> How so? Sorry I don't really understand what you mean
[09:07:18] <FromDiscord> <ElegantBeef> Not in response to you
[09:07:34] <FromDiscord> <Jakraes> Oh gotcha
[09:07:36] <FromDiscord> <ElegantBeef> What's `vector.startX`?
[09:07:47] <FromDiscord> <Jakraes> Oh nvm, I can just include everything inside the float64
[09:07:51] <FromDiscord> <Bung> oh , it's just safer I think
[09:08:01] *** Quits: springb0k (~springb0k@96.77.120.193) (Ping timeout: 268 seconds)
[09:08:06] <FromDiscord> <Jakraes> It's the starting position of a vector
[09:08:43] <FromDiscord> <ElegantBeef> In reply to @Bung "oh , it's just": No it just works, cause without `typed` you get identifiers which means unless that symbol exists in the scope of `callImpl` it will not function
[09:10:50] <FromDiscord> <Bung> okay, I'll use typed version as the Impl may coming from nimble package I think
[09:11:11] <FromDiscord> <ElegantBeef> well with out it just wont work when imported
[09:15:16] *** Joins: springb0k (~springb0k@96.77.120.193)
[09:20:43] *** Quits: springb0k (~springb0k@96.77.120.193) (Ping timeout: 265 seconds)
[09:25:02] <FromDiscord> <Bung> the impl part is proc , how can call it with args ?
[09:27:14] <FromDiscord> <Bung> oh, get it , get proc name node
[09:29:13] <FromDiscord> <ElegantBeef> Yea remember you can also change `typed` to any type so it's semantically checked
[09:31:23] <FromDiscord> <Bung> yeah , like proc(req:Request)
[09:51:23] <FromDiscord> <Bung> I get `postProcessMiddlewares.len` == 0 in macro
[09:52:20] <FromDiscord> <ElegantBeef> Without code to look at that doesnt mean much
[09:55:12] <FromDiscord> <Bung> pls check https://github.com/bung87/scorper/commit/a534d9b6281b3612a442a77b349c743a534cd932
[09:56:53] <FromDiscord> <ElegantBeef> Yea this is somewhat dependant on import order so you need to have the use site in a different file that's imported after subscription, or have an `implStuff` somewhere
[09:58:51] <FromDiscord> <ElegantBeef> You could make `processClient` a macro which inserts the calls where they need to
[10:01:56] <FromDiscord> <ElegantBeef> The issue being that it gets the macros, then finalizes the `processClient` so then embeds nothing since it hasnt had any calls to `implPreProcessMiddleware`
[10:01:58] <FromDiscord> <Bung> hmm , guess I'll seperate Request to other file, but it has many private fields.
[10:02:47] <FromDiscord> <ElegantBeef> I do wonder if you couldnt just put it in a template
[10:03:44] <FromDiscord> <Bung> processClient ? that's a proc pass to a proc as callback
[10:05:48] <FromDiscord> <ElegantBeef> Sure but i mean something like this https://play.nim-lang.org/#ix=3tA6 not idea though
[10:06:02] <FromDiscord> <ElegantBeef> No clue if it even compiles truthfully 😄
[10:06:43] <FromDiscord> <ElegantBeef> You need something to late bind that procedure to a callsite 😄
[10:09:29] <FromDiscord> <Bung> hmm , that does not compiled
[10:10:19] <FromDiscord> <Bung> in the end I'll seperate Request type to other file
[10:11:34] <FromDiscord> <Bung> import scoper/middlewaremacro ; imp it; import scorper make this works I think.
[10:13:57] <FromDiscord> <ElegantBeef> Ah yes i see why it didnt solve the issue, didnt realize you called this later in this file
[10:15:22] <FromDiscord> <Bung> yeah, just some kind not friendly to user, that import order are imortant.
[10:15:59] <FromDiscord> <ElegantBeef> Yea it's why i did the whole `implNimScriptModule` in the nimscripter rewrite, it means that import order doesnt matter just calling that after all subscriptions does
[10:16:45] <FromDiscord> <Bung> oh, I did not aware it handle this case.
[10:16:50] <FromDiscord> <ElegantBeef> So it kinda sucks, but if you can make it so the user just has an `init` like call it'd make it easier
[10:17:06] <FromDiscord> <Bung> that's cool
[10:18:08] <FromDiscord> <ElegantBeef> Yea the macrocache is quite awesome
[10:19:07] <FromDiscord> <Bung> it's cool I face use cases in two projects just in few days.
[10:22:47] *** Quits: rockcavera (~rc@user/rockcavera) (Remote host closed the connection)
[10:34:00] <fn> <11ForumUpdaterBot99> New Nimble package! harpoon - HTTP Client, see https://github.com/juancarlospaco/harpoon
[10:34:01] <fn> <12R2D299> 4GitHub: 7"HTTP Harpoon, HTTP Client"
[11:05:10] *** Joins: Vladar (~Vladar@46.162.2.53)
[11:09:00] <FromDiscord> <haxscramper> In reply to @theangryepicbanana "yeah I've seen that,": `Infix[Ident(strVal: "+"), @lhs, @rhs]`
[11:22:57] *** Joins: sagax (~sagax@213.138.71.146)
[11:39:08] *** Joins: max22- (~maxime@2a01cb0883359800dcf4f62622314b6d.ipv6.abo.wanadoo.fr)
[11:39:24] *** Quits: max22- (~maxime@2a01cb0883359800dcf4f62622314b6d.ipv6.abo.wanadoo.fr) (Remote host closed the connection)
[11:39:47] *** Joins: max22- (~maxime@2a01cb0883359800dcf4f62622314b6d.ipv6.abo.wanadoo.fr)
[12:08:07] <FromDiscord> <Bung> how you declare two type that reference each other in fields?
[12:08:17] <FromDiscord> <Rika> in the same type block
[12:08:42] <FromDiscord> <Bung> how about seperated files ?
[12:09:14] <FromDiscord> <Rika> impossible w/o experimental package type i believe
[12:11:27] <FromDiscord> <Bung> oh , I stuck in old problem.
[12:14:38] <FromDiscord> <Bung> hmm , I dont need to do this.
[12:23:23] *** Joins: fredrikhr (~fredrikhr@89-162-57-126.fiber.signal.no)
[12:29:28] <FromDiscord> <Bung> can I give param a cast by default ? I dont want write cast in every interfaces body
[14:30:50] <FromDiscord> <haxscramper> What is the correct way to convert `.nimcall.` procvar into `.closure.`? Right now I have `proc toClosure(arg: proc() {.nimcall.}): proc() {.closure.} = arg`, which does not seem like a good solution (is it safe to just take nimcall and return closure?)↵\`
[14:31:05] <FromDiscord> <haxscramper> On top of that - this would require writing 2xN overloads for any number of arguments (for procvar with return value and without)
[14:31:26] <FromDiscord> <haxscramper> Last part it the most troublesome one
[14:50:19] *** Joins: krux02 (~krux02@p200300ca8f251700e49676b6281f09e9.dip0.t-ipconnect.de)
[15:04:14] *** Quits: fredrikhr (~fredrikhr@89-162-57-126.fiber.signal.no) (Read error: Connection reset by peer)
[15:31:52] *** Quits: max22- (~maxime@2a01cb0883359800dcf4f62622314b6d.ipv6.abo.wanadoo.fr) (Ping timeout: 268 seconds)
[15:51:33] *** Joins: fredrikhr (~fredrikhr@89-162-57-126.fiber.signal.no)
[15:57:35] *** Quits: fredrikhr (~fredrikhr@89-162-57-126.fiber.signal.no) (Read error: Connection reset by peer)
[16:00:59] *** Joins: fredrikhr (~fredrikhr@89-162-57-126.fiber.signal.no)
[16:07:41] *** Joins: arkurious (~arkurious@user/arkurious)
[16:28:18] *** Quits: krux02 (~krux02@p200300ca8f251700e49676b6281f09e9.dip0.t-ipconnect.de) (Remote host closed the connection)
[16:35:36] <FromDiscord> <theangryepicbanana> In reply to @haxscramper "`Infix[Ident(strVal: "+"), @lhs, @rhs]`": still not direct pattern matching, but I suppose it's the best I'll get in nim
[16:35:37] <fn> <11ForumUpdaterBot99> New post on r/nim by thprogramador: Nim baazar, see https://reddit.com/r/nim/comments/ooohy8/nim_baazar/
[16:36:02] *** Quits: supakeen (~user@python/site-packages/supakeen) (Quit: WeeChat 3.2)
[16:36:08] <FromDiscord> <haxscramper> In reply to @theangryepicbanana "still not direct pattern": What do you mean by "direct pattern matching" then
[16:36:37] *** Joins: supakeen (~user@python/site-packages/supakeen)
[16:37:01] <FromDiscord> <theangryepicbanana> In reply to @haxscramper "What do you mean": like syntax-based pattern match, could look something like `@lhs + @rhs`
[16:46:26] <FromDiscord> <haxscramper> In reply to @theangryepicbanana "like syntax-based pattern match,": https://play.nim-lang.org/#ix=3tBo
[16:46:46] <FromDiscord> <haxscramper> sent a code paste, see https://play.nim-lang.org/#ix=3tBp
[16:51:27] <FromDiscord> <haxscramper> https://play.nim-lang.org/#ix=3tBr
[16:51:44] <FromDiscord> <haxscramper> sent a code paste, see https://play.nim-lang.org/#ix=3tBs
[16:52:17] <FromDiscord> <haxscramper> Retains all properties of pattern matching (like automatically declaring `@head` as `Option` if it participates only in one variant of the arm)
[16:52:46] <FromDiscord> <haxscramper> ~27 lines total, most likely it has some bugs but not too much as it is dead-simple transform
[17:00:50] <FromDiscord> <haxscramper> I think this is a good example why implicitly overloading `case` is not a good idea
[17:48:03] *** Joins: rockcavera (~rc@192.12.113.223)
[17:48:03] *** Quits: rockcavera (~rc@192.12.113.223) (Changing host)
[17:48:03] *** Joins: rockcavera (~rc@user/rockcavera)
[17:51:13] <arkanoid> When I have long function and I want to split it, I'm not sure if the best nim approach is to create more root level functions, or more inner closures, or create inner "block" s
[17:51:34] <FromDiscord> <haxscramper> Create more functions
[17:52:49] *** Quits: Vladar (~Vladar@46.162.2.53) (Quit: Leaving)
[17:53:33] <arkanoid> I'm unsure about creating more root level functions as it may fracture the sequential logic into pieces that really are sequential
[17:54:39] <arkanoid> Closures seems somehow better fit. They really say: those procs are just for this outer proc
[17:54:52] <FromDiscord> <haxscramper> I don't understand the problem. If you have a block of code that can has some "inputs" and some "outputs" then you can put it in function
[17:55:06] <FromDiscord> <haxscramper> Making it a closure is just looks like fancy indentation to me
[17:55:25] <FromDiscord> <haxscramper> Same with `block`
[17:55:36] <FromDiscord> <haxscramper> You want to create a closure and immediately call it?
[17:55:53] <arkanoid> It is fancy indentation. The target here is to make it more readable/maintenable, non to reuse code.
[17:55:56] <FromDiscord> <haxscramper> we have templates for that
[17:56:24] <FromDiscord> <haxscramper> cheaper than closure, no need for to pay for indentation
[17:56:56] <arkanoid> I don't see how templates joins the party
[17:57:22] <FromDiscord> <haxscramper> Put code in the template and use it the same way as function
[17:59:52] <arkanoid> Arent block: blocks scopes handled at compile time too?
[18:00:16] <FromDiscord> <haxscramper> They are handled at compile-time too, yes
[18:00:50] <FromDiscord> <haxscramper> If you are looking to just add more scopes use block
[18:01:41] <arkanoid> I mean, while I do see disadvantaged for calling unnecessary non-inlined procs just for splitting, templates for the cause seems like improper usage of them
[18:01:49] <arkanoid> Like "why a template here"
[18:02:14] <FromDiscord> <haxscramper> You have large proc you want to split into parts, correct?
[18:02:22] <FromDiscord> <haxscramper> somehow
[18:02:51] <arkanoid> Yes, but parts are not really reusable. They would become private parts of the module. Maximum level of encapsulation
[18:03:27] <FromDiscord> <haxscramper> So what is wrong with putting the parts in the procedure and not exporting it?
[18:03:56] <FromDiscord> <haxscramper> Or adding `# section that does <thing>` comments
[18:04:37] <FromDiscord> <haxscramper> If parts are not reusable it does not mean you are forbidden from putting them to other procs
[18:04:58] <arkanoid> # comment is what I have now. It works, but future me can't assume that variables of one part are not used further down
[18:05:26] <FromDiscord> <haxscramper> Then simply add `block`
[18:05:56] <FromDiscord> <haxscramper> Still ton of code in one place, and I would not classify it as "splitting" proc, but if that's what you are after it should be the best option
[18:06:19] <FromDiscord> <haxscramper> Also `block` can be named, so you can do `block collectEntries`
[18:06:28] <FromDiscord> <haxscramper> Doesn't add anything, but might look nice
[18:06:32] <arkanoid> Adding more procs would add calls to the stack, and the the global function is in an endless loop and is running as fast as possible, so yeah optimization is also good
[18:07:56] <arkanoid> So yeah I'm in doubt blocks vs inlined inner closures (are these a thing? Can I inline closure?)
[18:08:04] <FromDiscord> <konsumlamm> you can mark the procs as `{.inline.}`
[18:08:15] <FromDiscord> <haxscramper> that does not guarantee inlining
[18:08:33] <FromDiscord> <haxscramper> And it is almost useless for inner closures
[18:09:06] <FromDiscord> <haxscramper> IIRC `.inline.` copies generated C code into each file where function was used so `C` compiler could inline it better
[18:10:11] <arkanoid> If an inline closure works like a template doing the same thing, it may work
[18:10:42] <FromDiscord> <haxscramper> Why not use template then?
[18:11:59] <FromDiscord> <haxscramper> Because inline closure looks just as weird in that case
[18:14:29] *** Quits: stkrdknmibalz (~test@rrcs-75-87-43-226.sw.biz.rr.com) (Quit: WeeChat 3.0.1)
[18:16:06] <arkanoid> I do agree. Well. Thanks, at least I have a better idea of the pros and cons
[18:16:32] <arkanoid> blocks and templates are zero cost and improves encapsulation
[18:27:22] <FromDiscord> <Clonkk> Does anyone know how to investigate the code gen error \:`ror: invalid initialization of reference of type ‘tySequence9apztJSmgERYU8fZOjI4pOg&’ from expression of type ‘tySequence48JTohSgTy339bRxHzUD8KA’ newSeq_OOZOOZOOZlocalwsZnimfftw51Zfftw51_548(result, len); `  ?
[18:28:21] <FromDiscord> <Clonkk> It's on  rather big code base (can't seem to isolate for now). I've seen something similar that is supposedly fixed, so I wonder if anyone has encoutered this error ?
[18:34:37] <FromDiscord> <konsumlamm> are you on devel?
[18:35:58] <FromDiscord> <Clonkk> Yep
[18:44:36] <FromDiscord> <rishavs (Rishav Sharan)> sent a code paste, see https://play.nim-lang.org/#ix=3tBY
[19:03:39] <FromDiscord> <haxscramper> That should work with fusion/matching
[19:06:16] <FromDiscord> <haxscramper> sent a code paste, see https://paste.rs/bPn
[19:10:45] <FromDiscord> <hamidb80> hey
[19:10:59] <FromDiscord> <hamidb80>  https://media.discordapp.net/attachments/371759389889003532/867415865376768040/unknown.png
[19:11:13] <FromDiscord> <hamidb80>  https://media.discordapp.net/attachments/371759389889003532/867415924693008434/unknown.png
[19:12:15] <FromDiscord> <hamidb80> why do my document comments are not in generated docummentation?
[19:12:19] <FromDiscord> <hamidb80> (edit) "docummentation?" => "documentation?"
[19:12:42] <FromDiscord> <hamidb80> (edit) 04removed "do" | "are not" => "dont exist"
[19:16:04] <FromDiscord> <Rika> addtestcov probably clobbering it
[19:16:29] <FromDiscord> <Rika> do you have the code for the macro so i can see
[19:18:31] <FromDiscord> <hamidb80> i expanded them using `expandMacros` and the comments exist
[19:18:58] <FromDiscord> <hamidb80> oh my god
[19:19:05] <arkanoid> I've another question linked to my previous one. Is there any automatic inlining system in nim?
[19:19:15] <FromDiscord> <hamidb80>  https://media.discordapp.net/attachments/371759389889003532/867417946623442964/unknown.png
[19:20:24] <FromDiscord> <hamidb80> they are under `result=`
[19:20:48] <FromDiscord> <hamidb80> sent a code paste, see https://play.nim-lang.org/#ix=3tC8
[19:23:04] <FromDiscord> <Rika> wdym? templates are literally inlined code
[19:28:23] <fn> <11ForumUpdaterBot99> New thread by Miran: Nim online meetup - Friday July 23rd, see https://forum.nim-lang.org/t/8254
[19:46:55] <FromDiscord> <Kermithos> sent a code paste, see https://play.nim-lang.org/#ix=3tCx
[19:48:11] <ozzz> How to specify option to parsexml - allowEmptyAttribs using open(...)?
[19:48:42] <ozzz> It won't eat for some reason, or I misunderstand smth
[19:51:06] <ozzz> also what I want to ask, how to identify xml special char? I have to do x.next() on each occasion of xml_special_char, othervise x.charData points only on data before spec. char
[20:18:58] <FromDiscord> <Kermithos> In reply to @Kermithos "how can I get": okay, figured it out, getTempDir() work perfectly
[20:22:29] <fn> <11ForumUpdaterBot99> New thread by Tsojtsoj: Expensive copy when compiling with --gc:arc, see https://forum.nim-lang.org/t/8255
[20:29:11] <FromDiscord> <carmysilna> I'm going through Project euler in Nim and its ridiculously easy. An import from sequtils or math and then 20 lines of functions and you've got the answer
[20:30:55] <FromDiscord> <hamidb80> In reply to @Rika "wdym? templates are literally": nim doc doesnt detect doc comments for some procs
[20:31:04] <FromDiscord> <hamidb80> (edit) "nim doc" => "`nim doc`"
[20:31:30] <FromDiscord> <Rika> might be the same issue as hamid got above then
[20:32:36] <FromDiscord> <hamidb80> oh it's because of another macro😄
[20:33:16] *** Joins: stkrdknmibalz (~test@rrcs-75-87-43-226.sw.biz.rr.com)
[20:33:26] <FromDiscord> <Rika> oh
[20:33:30] <FromDiscord> <Rika> you're hamid
[20:33:39] <FromDiscord> <Rika> i didnt notice, avatar tripped me up
[20:33:51] <FromDiscord> <Rika> misread
[20:34:02] <FromDiscord> <Rika> In reply to @Rika "wdym? templates are literally": i was talking to arkanoid here...
[20:34:30] <fn> <11ForumUpdaterBot99> New thread by Clonk: Investigating C++ codegen error, see https://forum.nim-lang.org/t/8256
[20:53:47] <FromDiscord> <Hi02Hi> In reply to @carmysilna "I'm going through Project": There are hundreds of puzzles, they get much much harder as you continue. (I'm not the expert, I've solved like 30 puzzles, I was just looking through the later puzzles)
[20:54:32] <FromDiscord> <carmysilna> I can see that, it was just amazing to me how easy it was in Nim compared to when I tried them earlier in Erlang and Rust
[20:59:49] *** Joins: max22- (~maxime@2a01cb08833598008dd4ba17b27ebdc1.ipv6.abo.wanadoo.fr)
[21:04:17] *** Quits: max22- (~maxime@2a01cb08833598008dd4ba17b27ebdc1.ipv6.abo.wanadoo.fr) (Ping timeout: 245 seconds)
[21:08:56] *** Joins: max22- (~maxime@2a01cb0883359800410620ca7eec8c5b.ipv6.abo.wanadoo.fr)
[21:09:00] <FromDiscord> <hamidb80> In reply to @carmysilna "I can see that,": yeah, i think nims standard library is very powerful
[21:09:07] <FromDiscord> <hamidb80> (edit) "i" => "I" | "nims" => "the"
[21:26:55] *** Quits: max22- (~maxime@2a01cb0883359800410620ca7eec8c5b.ipv6.abo.wanadoo.fr) (Ping timeout: 250 seconds)
[21:41:33] *** Joins: max22- (~maxime@2a01cb0883359800bf64697c3c9455b7.ipv6.abo.wanadoo.fr)
[21:55:44] <FromDiscord> <haxscramper> public `const array[Kind, <X>]` in documentation↵https://haxscramper.github.io/htsparse/src/htsparse/systemVerilog/systemVerilog.html#verilogNodeKindMap
[21:56:25] <FromDiscord> <haxscramper> sent a code paste, see https://paste.rs/ead
[21:57:56] <FromDiscord> <haxscramper> Also I had to make java -\> nim transpiler - not a finished project by any means (some manual editing is needed after, and it fails on some constructs), https://github.com/haxscramper/htsparse/blob/master/tests/tJavaTranspiler.nim
[21:58:13] <FromDiscord> <haxscramper> Based on tree-sitter wrappers
[21:59:36] <FromDiscord> <haxscramper> And there are total of \~30+ languages with tree-sitter wrappers generated for them as well, I made them for some dirty X-\>nim transpilers
[22:39:13] *** Quits: max22- (~maxime@2a01cb0883359800bf64697c3c9455b7.ipv6.abo.wanadoo.fr) (Ping timeout: 268 seconds)
[22:42:04] *** Joins: SebastianM (~seba@user/sebastianm)
[22:43:20] <fn> <06Prestige99> Treesitter for Nim would be cool - it seems difficult to pull off though
[22:45:53] <FromDiscord> <haxscramper> I did some work on that as well, but nim has very "free-form" grammar and I'm not very skilled at writing LR parsers
[22:46:42] <fn> <06Prestige99> I came to the conclusion that the compiler would be the best way to generate the grammar
[22:46:47] <FromDiscord> <haxscramper> Most of the mechanical work is done, but I need to either spend more time and finish this
[22:46:52] <fn> <06Prestige99> But would need to be modified ofc
[22:47:17] <FromDiscord> <haxscramper> what do you mean by "generate grammar"?
[22:47:46] <FromDiscord> <haxscramper> https://github.com/haxscramper/tree-sitter-nim/blob/master/grammar.js
[22:48:03] <FromDiscord> <haxscramper> I took what was in manual
[22:48:42] <fn> <06Prestige99> Sorry, meant AST
[22:49:20] <FromDiscord> <haxscramper> I need this for pretty-printer
[22:49:24] <FromDiscord> <haxscramper> nim compiler AST is not enough for that
[22:49:54] <FromDiscord> <haxscramper> it simplifies a lot of information and does not track node ranges, only start poitns
[22:49:54] <FromDiscord> <haxscramper> points\
[22:50:05] <fn> <06Prestige99> Yeah I'm talking about generating the treesitter AST for Nim
[22:50:25] <fn> <06Prestige99> Would be nice if the compiler could handle it since it has all the context
[22:50:34] <fn> <06Prestige99> But it's a pipe dream
[22:51:15] <FromDiscord> <haxscramper> well, it is not a hard technical problem to write tree-sitter grammar
[22:51:44] <FromDiscord> <haxscramper> Maybe at some point I will be annoyed enough with having to manually format code and I finish this thing
[22:52:55] <fn> <06Prestige99> I couldn't figure out a way to do it without having a custom parser
[22:53:52] <FromDiscord> <haxscramper> nimpretty is hacked into nim parser, so I assume that is the only way
[22:54:00] <FromDiscord> <haxscramper> the only other way without having to write custom parser\
[22:54:02] <FromDiscord> <haxscramper> and this is not a good solution regardless
[22:54:31] <FromDiscord> <haxscramper> I have code layout optimizer, and it takes in AST, converts them into text blocks and then chooses optimal placement
[22:54:53] <FromDiscord> <haxscramper> nimpretty, on the other hand, takes in code and almost immediately outputs it, from what I can see
[22:55:17] <federico3> yes - nimfmt uses it
[22:56:54] <FromDiscord> <haxscramper> compiler parser?
[22:56:58] <fn> <06Prestige99> That's why I want the compiler to be able to support it (probably via some sort of plugin) 
[22:58:13] <FromDiscord> <haxscramper> we just need more detailed AST
[22:58:13] <FromDiscord> <haxscramper> CST\
[22:58:22] <fn> <06Prestige99> Yep
[22:58:44] <FromDiscord> <haxscramper> so I'm pretty fine with `{.define(concreteAst).}` that
[22:58:50] <FromDiscord> <haxscramper> 1. Stores end position
[22:58:56] <FromDiscord> <haxscramper> 2. Stores code comments
[22:59:14] <FromDiscord> <haxscramper> And that's basically it - maybe I've missed something, but I can go on with that much
[22:59:45] <FromDiscord> <haxscramper> Maybe some additional heuristics that parser used could also be represented in the AST
[23:00:03] <FromDiscord> <haxscramper> Like node indentation
[23:00:18] <FromDiscord> <haxscramper> And underlying token ranges
[23:00:45] <FromDiscord> <haxscramper> Speaking of `case`, `case:` with four different ways of writing total
[23:02:50] <FromDiscord> <haxscramper> Actually, forking nim parser and patching it from time to time does not seem like a terrible idea
[23:03:37] <FromDiscord> <haxscramper> I'm more likely to use tree-sitter anyway, but as an alternative that sounds not too bad
[23:04:20] <fn> <06Prestige99> I mean you could add support to the Nim parser to return info you need
[23:04:28] <fn> <06Prestige99> Then just use it for treesitter
[23:05:56] <FromDiscord> <haxscramper> what is the point of tree-sitter in that case?
[23:06:00] <FromDiscord> <haxscramper> tree-sitter is a parser generator
[23:06:26] <FromDiscord> <haxscramper> it also has support for incremental editing and AST querying, but that is all supplementary
[23:10:58] <FromDiscord> <haxscramper> Main problem with tree-sitter & nim is that our grammar seems to contain all possible edge cases
[23:11:15] <fn> <06Prestige99> You would get all of the benefits of tree sitter, you would just be using Nim as your parser
[23:11:31] <FromDiscord> <haxscramper> I can't do that
[23:11:40] <FromDiscord> <haxscramper> It is impossible
[23:11:54] *** Joins: max22- (~maxime@2a01cb0883359800bb717489435922c2.ipv6.abo.wanadoo.fr)
[23:11:58] <FromDiscord> <@bracketmaster-5a708063d73408ce4> @\_discord\_145405730571288577\:t2bot.io \: regarding your solution last night, I need to instantiate `sub_arr` within the macro itself - and manipulate it
[23:12:00] <FromDiscord> <haxscramper> "all benefits of tree sitter" are based on their incremental GLR parser algorithm
[23:12:14] <FromDiscord> <@bracketmaster-5a708063d73408ce4> sub\_arr needs to be parameterized by a value generated within the macro
[23:12:32] <FromDiscord> <haxscramper> And internal runtime that is tightly coupled with an implementation
[23:13:03] <fn> <06Prestige99> Treesitter supports custom parsers 
[23:13:16] <FromDiscord> <haxscramper> tree-sitter supports custom lexers
[23:13:43] <fn> <06Prestige99> Yeah that's what I'm talking about, use nim for that
[23:14:01] <FromDiscord> <haxscramper> I can write lexer in nim, yes
[23:14:13] <fn> <06Prestige99> Uh
[23:14:26] <FromDiscord> <haxscramper> But I can't reuse compiler lexer
[23:14:33] <fn> <06Prestige99> I guess I'm really struggling to get my point across
[23:14:37] <FromDiscord> <haxscramper> Because required lexer implementation is also coupled with their runtime
[23:14:57] <FromDiscord> <@bracketmaster-5a708063d73408ce4> so going back to this
[23:14:58] <FromDiscord> <@bracketmaster-5a708063d73408ce4> https://paste.debian.net/1205079
[23:15:03] <FromDiscord> <@bracketmaster-5a708063d73408ce4> I'm not sure its actually possible
[23:16:32] <FromDiscord> <haxscramper> What point? If I use tree-sitter, I can't take advantage of any already existing implementation in nim compiler and/or other handwritten parser. That is due to tree-sitter being a highly coupled, self-contained system that only has very narrow extension points for lexers.
[23:17:00] <FromDiscord> <haxscramper> So if you wanted to say something unrelated to it, then I might've misunderstood you
[23:17:43] <fn> <06Prestige99> Nah that was it, idk why that would prevent you from using Nim's lexer (with modifications)
[23:21:05] <FromDiscord> <haxscramper> Most obvious part is - nim lexer based in internal buffer and it controls it, while tree-sitter provides support for custom lexer in form of `bool tree_sitter_my_language_external_scanner_scan(void payload,  TSLexer lexer,  const bool valid_symbols)`
[23:21:38] <FromDiscord> <haxscramper> I could try to put nim scanner object in payload and somehow sync it with TsLexer, but that seems like a major pain
[23:22:11] <fn> <06Prestige99> I was thinking just have calls to Nim's lexer from within that function
[23:22:11] <FromDiscord> <haxscramper> Also nim lexer does not support incremental re-lexing, while TS one has this functionality built-in
[23:22:34] <FromDiscord> <haxscramper> I would have to sync two completely unrelated lexer states
[23:31:45] <FromDiscord> <haxscramper> After looking into it more, idea of hacking into `compiler/[lexer, parser]` seems pretty reasonable to me
[23:32:27] <FromDiscord> <haxscramper> I can store all tokens in the file and start/end token indices for a node, and that should be enough
[23:33:44] <FromDiscord> <carmysilna> Is it a viable idea to compile to Nim by importing the nim package and then directly emitting AST nodes from my AST, and then using nim API to generate code?
[23:35:00] <FromDiscord> <haxscramper> Yes, this is just a more complicated macro
[23:35:26] <FromDiscord> <haxscramper> I think someone was writing a language that compiled to nim
[23:39:19] <FromDiscord> <carmysilna> I think min does
[23:43:47] <FromDiscord> <creonico> Is this a valid way to declare an array? `var some_array:array[size, T];`
[23:45:52] <FromDiscord> <haxscramper> !eval var test\: array[100, int]
[23:45:57] <NimBot> Compile failed: /usercode/in.nim(1, 12) Error: ':' or '=' expected, but got 'array'
[23:46:09] <FromDiscord> <haxscramper> what
[23:46:40] <fn> <06Prestige99> !eval var test: array[100, int]
[23:46:46] <FromDiscord> <haxscramper> https://wandbox.org/permlink/dEiR1IGZajz6PWaq
[23:46:59] <NimBot> <no output>
[23:46:59] <fn> <12R2D299> /usercode/in.nim(1, 5) Hint: 'test' is declared but not used [XDeclaredButNotUsed]
[23:47:21] <fn> <06Prestige99> hax: it added a `\` before the `:` because of the bridge I think
[23:54:24] <FromDiscord> <haxscramper> But ultimately nim formatter must have support for custom pretty-printer plugins, due to various DSLs
[23:55:30] <FromDiscord> <haxscramper> Maybe reuse nimscript for that. Macro-like API - take in AST, return "block tree" with alternative layouts
