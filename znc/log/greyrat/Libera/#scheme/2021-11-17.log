[00:01:33] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[00:04:15] *** Joins: Inline (~Inline@2a02:908:1252:7a80:c0ad:80c4:dd74:5cc0)
[00:04:46] *** Quits: nrr__ (sid20938@lymington.irccloud.com) (Ping timeout: 256 seconds)
[00:05:23] *** Quits: Inline (~Inline@2a02:908:1252:7a80:c0ad:80c4:dd74:5cc0) (Remote host closed the connection)
[00:06:13] *** Joins: nrr__ (sid20938@lymington.irccloud.com)
[00:07:40] *** Joins: Inline (~Inline@2a02:908:1252:7a80:c0ad:80c4:dd74:5cc0)
[00:13:15] *** Joins: elderK (uid205007@helmsley.irccloud.com)
[00:17:54] *** Quits: shawnw (~shawn_w@152.44.212.188) (Ping timeout: 265 seconds)
[00:36:46] *** Quits: Inline (~Inline@2a02:908:1252:7a80:c0ad:80c4:dd74:5cc0) (Quit: Leaving)
[00:48:19] *** Joins: mononote (~mononote@user/mononote)
[00:57:10] *** Joins: Inline (~Inline@2a02:908:1252:7a80:9455:4a3b:6504:3d0c)
[01:11:58] *** Joins: seepel (~seepel@c-24-4-200-111.hsd1.ca.comcast.net)
[01:21:11] *** Quits: Inline (~Inline@2a02:908:1252:7a80:9455:4a3b:6504:3d0c) (Quit: Leaving)
[01:33:54] *** Joins: aquijoule_ (~richbridg@089144202142.atnat0011.highway.a1.net)
[01:36:34] *** Quits: richbridger (~richbridg@089144202142.atnat0011.highway.a1.net) (Ping timeout: 256 seconds)
[01:37:30] *** Joins: Inline (~Inline@2a02:908:1252:7a80:731:d6ac:6e05:dbb3)
[01:48:39] *** Joins: Inline_ (~Inline@2a02:908:1252:7a80:731:d6ac:6e05:dbb3)
[01:49:27] *** Inline is now known as Guest1099
[01:49:58] *** Quits: Inline_ (~Inline@2a02:908:1252:7a80:731:d6ac:6e05:dbb3) (Remote host closed the connection)
[01:50:24] *** Joins: Inline_ (~Inline@2a02:908:1252:7a80:731:d6ac:6e05:dbb3)
[01:51:10] *** Inline_ is now known as Inline
[02:11:56] *** Joins: robin (~robin@user/terpri)
[02:49:21] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[02:55:26] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Quit: ec)
[03:07:45] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[03:08:21] *** Joins: badkins (~badkins@136.56.92.199)
[03:12:59] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 264 seconds)
[03:25:47] *** Joins: s-liao (~s-liao@101.86.101.64)
[03:31:02] *** Quits: s-liao (~s-liao@101.86.101.64) (Quit: Client closed)
[03:31:27] *** Joins: s-liao (~s-liao@101.86.101.64)
[03:34:55] *** Quits: taiju (~taiju@240b:253:ec40:2400:2cdc:1f32:d88a:fa10) (Ping timeout: 268 seconds)
[03:42:04] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[03:45:32] *** Joins: badkins (~badkins@136.56.92.199)
[03:48:38] *** Quits: rgherdt (~rgherdt@2a02:8109:86c0:d8d:b451:65f7:f961:6c1a) (Ping timeout: 265 seconds)
[04:05:21] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[04:05:59] *** Joins: badkins (~badkins@136.56.92.199)
[04:08:03] *** Quits: Oshawott (~archenoth@2604:3d09:681:f00:987d:f829:9742:5ed4) (Read error: Connection reset by peer)
[04:09:36] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[04:09:45] *** Joins: badkins (~badkins@136.56.92.199)
[04:09:55] *** Quits: s-liao (~s-liao@101.86.101.64) (Quit: Client closed)
[04:14:24] *** Quits: _________ (~nobody@user/noodly) (Ping timeout: 268 seconds)
[04:15:25] *** Joins: _________ (~nobody@user/noodly)
[04:21:35] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[04:22:10] *** Joins: badkins (~badkins@136.56.92.199)
[04:24:13] *** Joins: archenoth (~archenoth@2604:3d09:681:f00:744c:3b3e:78c:3869)
[04:27:20] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 268 seconds)
[04:35:48] *** Joins: livoreno (~livoreno@user/notzmv)
[04:37:46] *** Joins: badkins (~badkins@136.56.92.199)
[04:46:49] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[04:47:04] *** Joins: badkins (~badkins@136.56.92.199)
[04:47:36] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[04:48:11] *** Joins: badkins (~badkins@136.56.92.199)
[04:53:14] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 268 seconds)
[04:57:27] *** Joins: s-liao (~s-liao@101.86.101.64)
[05:02:10] *** Quits: seninha (~seninha@user/seninha) (Quit: Leaving)
[05:17:33] *** Quits: livoreno (~livoreno@user/notzmv) (Read error: Connection reset by peer)
[05:28:29] *** Joins: livoreno (~livoreno@user/notzmv)
[05:32:02] *** Joins: [deleted] (~livoreno@user/notzmv)
[05:33:02] *** Quits: livoreno (~livoreno@user/notzmv) (Ping timeout: 265 seconds)
[06:00:16] <pi0> hey all
[06:01:01] <light> hi
[06:07:47] <pi0> i dont suppose we can do some java?
[06:08:10] <pi0> i know its scheme and a java channel is out there, but its not as supportive as this one
[06:11:18] *** Quits: [deleted] (~livoreno@user/notzmv) (Read error: Connection reset by peer)
[06:15:21] <gwatt> I suspect if you ask a bunch of java questions you'll find this channel increasingly helpful.
[06:17:03] <gwatt> increasingly *less* helpful, I meant
[06:20:40] *** Quits: s-liao (~s-liao@101.86.101.64) (Quit: Client closed)
[06:22:24] *** Joins: livoreno (~livoreno@user/notzmv)
[06:27:36] <Zipheir> Yes, I'd rather not have Java question-and-answer on #scheme.  If it's about general programming topics and the examples happen to be in Java, that seems fine.
[06:36:24] <pi0> sounds fair
[06:36:34] <pi0> can we go over tail recursion again
[06:36:55] *** Joins: s-liao (~s-liao@101.86.101.64)
[06:37:28] *** Quits: seepel (~seepel@c-24-4-200-111.hsd1.ca.comcast.net) (Ping timeout: 256 seconds)
[06:58:55] *** Joins: aquijoule__ (~richbridg@213-225-12-152.nat.highway.a1.net)
[07:01:29] *** Quits: aquijoule_ (~richbridg@089144202142.atnat0011.highway.a1.net) (Ping timeout: 265 seconds)
[07:09:12] *** Quits: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net) (Ping timeout: 256 seconds)
[07:32:25] *** Quits: skapata (~Skapata@user/skapata) (Ping timeout: 265 seconds)
[07:35:22] *** Joins: skapata (~Skapata@2804:14c:87b0:a6f9:a4ef:f059:ad4c:b8a4)
[07:35:22] *** Quits: skapata (~Skapata@2804:14c:87b0:a6f9:a4ef:f059:ad4c:b8a4) (Changing host)
[07:35:22] *** Joins: skapata (~Skapata@user/skapata)
[08:01:35] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Ping timeout: 250 seconds)
[08:07:17] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[08:08:13] <Menchers> or related to kawa scheme!
[08:11:17] *** Quits: madage (~madage@user/madage) (Remote host closed the connection)
[08:11:30] *** Joins: madage (~madage@user/madage)
[08:13:30] *** Joins: clacke (88d96f2df3@knopi.disroot.org)
[08:26:06] *** Joins: badkins (~badkins@136.56.92.199)
[08:30:50] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 260 seconds)
[08:32:06] *** Joins: badkins (~badkins@136.56.92.199)
[08:35:24] *** Quits: robin (~robin@user/terpri) (Read error: Connection reset by peer)
[08:35:40] *** Joins: robin (~robin@user/terpri)
[08:36:59] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 264 seconds)
[08:38:21] *** Quits: s-liao (~s-liao@101.86.101.64) (Quit: Client closed)
[08:58:10] *** Quits: klovett (~klovett@166.205.90.177) (Quit: ZZZzzz…)
[09:16:05] *** Quits: Guest1099 (~Inline@2a02:908:1252:7a80:731:d6ac:6e05:dbb3) (Quit: Leaving)
[09:16:13] *** Quits: Inline (~Inline@2a02:908:1252:7a80:731:d6ac:6e05:dbb3) (Quit: Leaving)
[09:27:11] *** Joins: seninha (~seninha@user/seninha)
[09:31:17] *** Quits: elderK (uid205007@helmsley.irccloud.com) (Quit: Connection closed for inactivity)
[10:04:13] *** Quits: seninha (~seninha@user/seninha) (Ping timeout: 250 seconds)
[10:34:52] *** Quits: grettke (~grettke@cpe-65-29-228-30.wi.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[10:35:20] *** Joins: grettke (~grettke@cpe-65-29-228-30.wi.res.rr.com)
[10:38:18] *** Quits: mononote (~mononote@user/mononote) (Ping timeout: 256 seconds)
[10:38:51] *** Quits: skapata (~Skapata@user/skapata) (Remote host closed the connection)
[10:42:48] *** Joins: tophullyte (tophullyte@gateway/vpn/protonvpn/tophullyte)
[11:01:27] *** Quits: grettke (~grettke@cpe-65-29-228-30.wi.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[11:14:36] *** Joins: s-liao (~s-liao@101.86.101.64)
[11:23:34] *** Joins: rgherdt (~rgherdt@2a02:8109:86c0:d8d:b451:65f7:f961:6c1a)
[11:31:02] *** Quits: s-liao (~s-liao@101.86.101.64) (Ping timeout: 256 seconds)
[11:35:44] *** Joins: ns12 (~ns12@user/ns12)
[11:44:05] <amazigh> dpk: what is the next step regarding generics?
[11:44:11] <amazigh> (and others)
[11:44:42] <amazigh> I read the SRFI Dictionaries https://srfi.schemers.org/srfi-225/srfi-225.html
[11:44:59] <amazigh> It does without generics.
[11:47:20] <ns12> What is the difference between letrec and letrec*? Is letrec the same as letrec*, except that the evaluation order of the init values are unspecified for letrec?
[11:49:31] <dpk> yes, as M N-W pointed out, a moderately bespoke solution is needed for dictionaries to handle both alists and plists
[11:50:04] <sjamaan> ns12: The letrec bindings can't directly see eachother either (except inside lambdas)
[11:50:47] <amazigh> I was somewhat requesting a summary of what RnRS position regarding generics.
[11:50:54] <amazigh> too much subtle maybe.
[11:51:14] <ns12> sjamaan: Does that mean Scheme implementations cannot define letrec as an alias of letrec*?
[11:51:28] <sjamaan> hmm, not sure
[11:51:48] <sjamaan> Just tested in CHICKEN and there letrec bindings have an undefined value rather than seeing the outer scope's bindings
[11:51:54] <amazigh> dpk: I was refering to this thread https://srfi-email.schemers.org/srfi-discuss/msg/17101503/ I will go throught it
[11:52:22] <dpk> i think my original mail sums up the situation reasonably well. there are a comparatively small number of operations we might like to make generic or generic-ish interfaces for in R7; and we can’t do efficient generic functions without type-of
[11:52:23] <sjamaan> I'd expect (let ((a 1)) (letrec ((a 2) (b a)) b)) to return 1 but in CHICKEN at least it returns undefined
[11:52:32] <sjamaan> Maybe that's a bug
[11:53:00] <sjamaan> MIT Scheme raises an error
[11:53:17] <sjamaan> scheme48 as well
[11:53:46] <dpk> custom writers we don’t need unless we have read macros, i think
[11:53:50] <sjamaan> Maybe my expectation is just wrong ;)
[11:54:07] <sjamaan> In Gauche it returns 2, so it looks like there letrec is aliased to letrec*
[11:54:34] <sjamaan> Gambit behaves like CHICKEN
[11:54:45] <dpk> getting the size of a collection may be a useful thing to attach to generators/cursors, but tricky to do so
[11:55:26] <dpk> collection access other than by iteration doesn’t need to be generic i think
[11:55:59] <ns12> sjamaan: I thought that letrec is the same as letrec* except that one cannot rely on evaluation order of init values in letrec. Looks like I have to study this a little more. I don't really understand what the R7RS section says.
[11:56:43] *** Quits: Menchers (Menchers@user/menchers) (Excess Flood)
[11:56:54] <dpk> collection access by iteration can be done by individual monomorphic procedures producing a generic iterator type, as in generators
[11:58:22] <dpk> and i don’t think we need arithmetic operator overloading. someone said they wanted quaternions, but i’d just make new procedures like q+, q-, q*, q/ etc
[11:58:55] <dpk> so all the examples i names can be done without actual generic procedures
[11:59:37] <dpk> therefore i lean towards providing told people can use to make their own generic procedure system efficiently, rather than baking it in
[11:59:57] <amazigh> I agree with the latter message
[12:00:04] <dpk> *tools
[12:00:28] <amazigh> do you consider generics to be duck-typing facility, and how concerning would it be?
[12:01:30] <dpk> syntax-case with identifier syntax is an example of such a tool ;-)
[12:01:50] <dpk> i don’t understand the question
[12:04:43] <amazigh> do you know duck-typing ?
[12:07:17] <amazigh> that is the basis of iterable protocol in python, it walks like a duck (has methods of a duck), then it is a duck
[12:07:39] <amazigh> it is some kind of latent / dynamic typing, and database land it is called schema on read.
[12:09:38] <amazigh> the dual of schema-on-read is scheme-on-write, like most SQL dbs, and are similar in spirit to static typing, where the type is declared before hand.
[12:10:11] <amazigh> with duck typing object do not have a type before hand, it does not matter, as long as they have an implementation for the generic
[12:10:16] <amazigh> with duck typing object do not have a type before hand, it does not matter, as long as they have an implementation for the generic method
[12:10:43] <dpk> well, someone could do that with generics if they wanted, why not
[12:11:00] <dpk> but i don't think we should bake it into the language
[12:12:01] <dpk> not because of duck typing, but because we don't need it, it's not how Scheme historically has worked, and it's probably better to let people do it themselves so everyone can get the version of it that works best for them
[12:12:17] <amazigh> I will read the thread from srfi-discuss (above link), and gather my thoughts.
[12:13:05] <amazigh> so, you position / point, the language should give the tools to build some generics machinery, without requiring a particular machinary?
[12:13:18] <dpk> yep
[12:13:28] <amazigh> yes, sounds good.
[12:14:27] <amazigh> Last time I checked, because I need it with SRFI-167-take-two, I went as far as describing predicate combinators, and prescribing a full ordering of the set of predicates.
[12:15:29] <amazigh> the more practical approach, because it does not require to change the current implementations, is to consider that predicates describe disjoints sets of objects, and if they do not the behavior of my generics are unspecified.
[12:16:13] <dpk> that said, at least if the R7RS voting process continues as it is, someone will probably make a SRFI that will end up on a ballot, and that SRFI will end up in R7RS because people will apparently vote for anything 🤷🏼‍♀️
[12:16:52] <amazigh> to be able to build a full order over predicates, such as (predicate<? p0? p1?), you need to be able to reason about the p0? et p1? definitions, and that can only be done i think at the interpreter / compiler level
[12:17:34] <amazigh> maybe full order requires `predicate<=?` with dunno
[12:18:07] <dpk> well, right, that's why i think we need type-of
[12:18:15] <amazigh> I also forgot to mention, that full-order is not possible, when two predicates describe overlapping sets.
[12:19:20] <amazigh> intersection is not empty but neither p0 subsume p1  nor p1 subsume p0
[12:19:49] <amazigh> oh, sorry, I did not understand the type-of comment. Yes, but that is historically frowned upon?
[12:30:44] *** Joins: Menchers (Menchers@user/menchers)
[12:34:27] <dpk> it's not how Scheme has historically worked, indeed
[12:34:56] <dpk> but, i realized, you can implement it in R7RS small
[12:35:11] <sham1> Since there was some talk of letrec and letrec*, annoyingly but understandably r7rs has different semantics for letrec Vs letrec* with regards to continuations
[12:35:54] *** Joins: s-liao (~s-liao@101.86.101.64)
[12:38:33] *** Parts: pranavats (3fba1d1b34@jabberfr.org) ()
[12:44:24] <dpk> https://gitlab.com/dpk/presrfis/-/blob/master/type-of.scm works on R7RS small because of the guarantees of section 3.2 (Disjointness of types)
[12:44:37] <dpk> it's not particularly *useful*, but it's possible
[12:45:16] *** Quits: s-liao (~s-liao@101.86.101.64) (Ping timeout: 256 seconds)
[12:45:38] <dpk> to be useful, it needs to be integrated with the procedural record-type interface, so type-of can return something more specific than <record> for user-defined types, and have an is-a? that can traverse type hierarchies, etc
[12:45:57] *** Joins: mononote (~mononote@user/mononote)
[12:46:58] *** Joins: s-liao (~s-liao@101.86.101.64)
[12:47:02] <amazigh> yes, hierachical types works great for that.
[12:49:05] <amazigh> I add to my todo to make summary.
[12:59:36] *** Joins: seninha (~seninha@user/seninha)
[13:13:00] *** Joins: gproto23 (~gproto23@user/gproto23)
[13:14:27] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Read error: Connection reset by peer)
[13:14:44] *** Joins: Avichi (~Avichi@2001:980:1b5c:1:d871:899f:c35a:2e37)
[13:17:09] *** Joins: taiju (~taiju@240b:253:ec40:2400:20e3:d321:f9f8:1864)
[13:21:57] *** Joins: civodul (~user@guix/contributor/civodul)
[13:35:53] *** Quits: livoreno (~livoreno@user/notzmv) (Ping timeout: 265 seconds)
[13:48:08] *** Quits: Balooga (sid407689@lymington.irccloud.com) (Ping timeout: 256 seconds)
[13:48:42] *** Quits: ullbeking (sid5364@user/ullbeking) (Ping timeout: 256 seconds)
[13:49:34] *** Joins: ullbeking (sid5364@user/ullbeking)
[13:49:37] *** Joins: Balooga (sid407689@lymington.irccloud.com)
[13:59:17] <mdhughes> jcowan: In SRFI-225, I kind of totally hate the DTD DICT thing, why not just use a record to hold both? But then half the functions aren't consistently (foo DTD DICT ...), they're (foo DTD ... DICT ...)
[14:00:47] <ns12> Is there an SRFI that defines immutable records with functional updates?
[14:01:20] <amazigh> ns12: i think that there is none, but SRFI website has a search engine.
[14:01:41] <amazigh> ns12: you can emulate (?) that will (scheme mapping hash) 
[14:01:50] <amazigh> ns12: you can emulate (?) that WITH (scheme mapping hash) 
[14:02:17] <amazigh> see https://srfi.schemers.org/srfi-146/
[14:02:26] <amazigh> emulate ~ built on top
[14:02:33] <mdhughes> jcowan: The first example in 225 under Predicates, the #f branch is wrong.
[14:03:25] <amazigh> ns12: there is performance optimization you can apply by taking into account the fact that immutable records, have a finite and know set of fields at compile time (or even runtime if it procedure too) and use a perfect hash.
[14:04:25] <amazigh> just mentioning the optim fyi. The fast path, is to pick SRFI-146, and build create a macro.
[14:05:45] <ns12> amazigh: What about SRFI 57? https://srfi.schemers.org/srfi-57/srfi-57.html
[14:05:46] <amazigh> also regarding the perfect hash, it really depends on the actual cost to compute the hash, sometime even with hash-tables, it is faster to use a alist / plist when (length objs) is n < something
[14:05:51] *** Quits: tophullyte (tophullyte@gateway/vpn/protonvpn/tophullyte) (Ping timeout: 265 seconds)
[14:06:07] <ns12> amazigh: It appears to provide record updates without mutation.
[14:07:11] <amazigh> first time I glimpse into that SRFI.
[14:07:13] <amazigh> what is the question?
[14:08:54] <ns12> amazigh: No question... Just wondering if you know about using SRFI 57 as an immutable record. Just wondering if it's actually usable.
[14:09:26] <amazigh> the best way to know, is to use it. I never used it.
[14:09:28] <amazigh> People have all sort of biased experience ;)
[14:10:41] <ns12> I wonder: Will R7RS Large have immutable records? Is it somewhere on the agenda?
[14:16:06] <amazigh> stay awhile and listen ;)
[14:16:14] <amazigh> idk
[14:16:50] <amazigh> pi0: we discuss java some time from PL / PLT point of view, but do not help with Java HW.
[14:17:58] <mdhughes> You don't need a special feature for immutable records, just don't define mutators for any fields.
[14:18:06] *** Quits: mononote (~mononote@user/mononote) (Remote host closed the connection)
[14:18:55] <mdhughes> It is very wasteful, tho. You're building & throwing away a vector containing all your data (mostly just pointers, one hopes) every single update.
[14:20:25] <dpk> we already have immutable records
[14:20:32] <dpk> just define a record type with no mutators :-)
[14:23:05] *** Quits: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de) (Quit: Leaving)
[14:23:19] <dpk> that said, i would like to have (at least the capability to implement) Guile's set-field/set-fields in R7RS Large
[14:23:45] <dpk> https://www.gnu.org/software/guile/manual/html_node/SRFI_002d9-Records.html#index-functional-setters
[14:28:25] <ns12> dpk: "just define a record type with no mutators" -- Yeah, but how do I conveniently update such a record?
[14:29:11] <ns12> SRFI 57 has "record-update", but I haven't tried to use it yet.
[14:29:40] <dpk> we're looking at SRFI 99 and various variants of it to fix the minor incompatibilities with R7RS
[14:29:58] <dpk> i don't know that SRFI 57 is supported by anyone
[14:33:19] <amazigh> Chicken has it, see http://practical-scheme.net/wiliki/schemexref.cgi?SRFI-57
[14:38:56] *** Quits: s-liao (~s-liao@101.86.101.64) (Quit: Ping timeout (120 seconds))
[14:39:11] *** Joins: s-liao (~s-liao@101.86.101.64)
[14:46:04] <ns12> dpk: Ah, so functional updates for immutable records is not on the R7RS Large agenda at all?
[14:46:17] <dpk> write a SRFI for it ;-)
[14:48:23] <ns12> dpk: I can't tell if you're serious ;-) since I am barely able to write a compliant R5RS interpreter.
[14:51:43] <amazigh> a SRFI is unrelated to writing a R5RS-compliant Scheme implementation.
[14:52:06] <amazigh> The immutable records you describe can be implemented as library, portably.
[14:52:20] <amazigh> SRFI must or should be portable, except in very rare cases.
[14:52:38] <amazigh> on a slightly unrelated note: I love this message https://srfi-email.schemers.org/srfi-discuss/msg/17119469/
[14:54:32] <amazigh> ns12: writing pre-srfi is first step, look at github.org/pre-srfi/ repo, start one, when you feel ready, then ask Arthur to start the SRFI process; and I recall that it is YOUR choice to finalize it, or not. I mean, nobody can stop you from building a SRFI about curly braces syntax.
[14:54:45] <amazigh> ask for feedback 
[14:55:10] <sham1> As long as the person implementing the Scheme is enjoying the process of it all and feels that their work is worthwhile, it's not wasted effort or anything like that
[14:56:20] *** Quits: buhman (sid411355@user/buhman) (Ping timeout: 268 seconds)
[14:56:25] <amazigh> tho, I did not say it is easy to write, and go through the SRFI process, but if people are available to comment and discuss (they usually are), it is an enlightening experience.
[14:56:36] <amazigh> tho do not expect a 100 comments per day ;)
[14:58:05] *** Joins: buhman (sid411355@user/buhman)
[14:59:31] <amazigh> And for the record, I like to remind that a withdrawn SRFI, is not a failure, it is as much insightful as finalized SRFI. *IF* the withdrawn SRFI is not a good idea, at least it will save the time other people trying the same thing (and they will have the SRFI mailing list for rationales, discussion etc...)
[15:00:37] <sham1> Somewhat annoyingly not every withdrawn SRFI has a notice telling you why it is withdrawn and what may be the replacement if any
[15:00:39] <amazigh> I was reminded of myself that, while reading about science publication, my take aways are 1) a problem / question can be more valuable that a positive result 2) a negative result is also interesting such as maybe the conclusion might be "that theory is a dead-end"
[15:01:22] <amazigh> there is not enough negative results published in science (I read that), and SRFI at least has that machinery that makes it stands out world-wide.
[15:04:39] <amazigh> AFAIU, finalized means "the *author* think it is a useful addition to Scheme implementations, and request the implementation of it", whereas withdrawn means "the *author* think it is not a useful addition to Scheme implementations"
[15:05:25] <amazigh> Also, maybe it should be added `at this time`. I do not have numbers, but things like SRFI-47 were finalized, but little implementations adopted, BUT it helped the overall long-now convo
[15:06:54] *** Quits: duncanm (sid287146@tinside.irccloud.com) (Ping timeout: 256 seconds)
[15:06:59] *** Quits: d_run (sid83858@hampstead.irccloud.com) (Ping timeout: 264 seconds)
[15:07:14] *** Joins: d_run (sid83858@hampstead.irccloud.com)
[15:07:28] *** Quits: rubin55 (sid175221@hampstead.irccloud.com) (Ping timeout: 256 seconds)
[15:07:36] <amazigh> that is, no implementations of an SRFI, does mean it useless. Again SRFI try to reference existing SRFIs when it makes to construct narative and help reader.
[15:09:13] *** Joins: rubin55 (sid175221@hampstead.irccloud.com)
[15:10:06] *** Joins: duncanm (sid287146@tinside.irccloud.com)
[15:10:06] <rudybot> la la la
[15:11:12] *** Quits: rubin55 (sid175221@hampstead.irccloud.com) (Max SendQ exceeded)
[15:12:22] *** Joins: rubin55 (sid175221@hampstead.irccloud.com)
[15:15:34] <amazigh> without negative results, we keep the legend of super hero genius; that is social and economical mistake, but off-topic.
[15:26:17] <ns12> There's a typo in the link to the "Pre-SRFI" GitHub organization. Here's the correct link: https://github.com/pre-srfi/
[15:27:20] *** Quits: Avichi (~Avichi@2001:980:1b5c:1:d871:899f:c35a:2e37) (Ping timeout: 256 seconds)
[15:30:40] *** Quits: madage (~madage@user/madage) (Remote host closed the connection)
[15:30:52] *** Joins: madage (~madage@user/madage)
[15:38:16] *** Quits: zwr (~zwr@2804:d45:b966:fb00:c972:cfd6:54b3:c83e) (Ping timeout: 268 seconds)
[15:38:39] *** Joins: zwr (~zwr@2804:d45:b966:fb00:f0c0:f746:9f80:b26b)
[15:48:59] *** Quits: mdhughes (~mdhughes@user/mdhughes) (Remote host closed the connection)
[15:49:26] *** Joins: mdhughes (~mdhughes@user/mdhughes)
[15:49:38] <amazigh> re generics: https://srfi-email.schemers.org/srfi-discuss/msg/17103930/ by dpk 
[15:53:17] *** Quits: mdhughes (~mdhughes@user/mdhughes) (Remote host closed the connection)
[15:53:33] *** Joins: mdhughes (~mdhughes@user/mdhughes)
[15:55:45] *** Joins: mdhughes_ (~mdhughes@user/mdhughes)
[15:56:11] *** Quits: mdhughes (~mdhughes@user/mdhughes) (Killed (NickServ (GHOST command used by mdhughes_)))
[15:56:14] *** mdhughes_ is now known as mdhughes
[16:13:12] *** Quits: X-Scale (~ARM@46.50.0.92) (Ping timeout: 256 seconds)
[16:17:12] *** Quits: s-liao (~s-liao@101.86.101.64) (Ping timeout: 256 seconds)
[16:19:40] *** Joins: X-Scale (~ARM@83.223.235.65)
[16:41:34] *** Joins: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net)
[16:50:05] *** Joins: s-liao (~s-liao@101.86.101.64)
[17:21:09] *** Quits: klu (~klu@user/klu) (Quit: .)
[17:21:30] *** Joins: klu (~klu@98.247.231.39)
[17:21:30] *** Quits: klu (~klu@98.247.231.39) (Changing host)
[17:21:30] *** Joins: klu (~klu@user/klu)
[17:23:01] *** Quits: jackhill (~jackhill@kalessin.dragonsnail.net) (Ping timeout: 245 seconds)
[17:23:57] *** Joins: jackhill (~jackhill@kalessin.dragonsnail.net)
[17:36:35] <seninha> Hello, I'm reading SICP and I'm at section 3.3 (butable list structures). When I define a pair, such as (define x '((a b) c d)) and try to mutate it with (set-car! x y), I get an error that the value of x is an immutable pair. How can I define and use mutable pairs for working with the book?
[17:36:40] <seninha> I'm using chibi-scheme.
[17:36:50] *** Joins: wnklmnn (~wnklmnn@2a02:908:4e2:9740:909c:db78:471d:a682)
[17:38:15] <sham1> Yeah, you can't mutate that. You'd want to probably use (list)
[17:40:31] <seninha> sham1: thanks, that works.
[17:41:14] <seninha> I thought '(a b) was a syntactic sugar for (list 'a 'b)
[17:42:32] <sham1> Sadly not quite
[17:42:51] <sham1> Well, depending on who you are, that might be a good thing
[17:43:55] *** Joins: sonny (~sonny@bras-base-london1483w-grc-27-70-51-121-200.dsl.bell.ca)
[17:44:05] <seninha> how so?
[17:45:31] <ns12> seninha: '(a b) is a literal list. The results of mutating a literal list is undefined. You should not mutate a list literal.
[17:46:04] <ns12> In contrast, (list 'a 'b) can be safely modified using "set-car!".
[17:47:40] <ns12> (list 'a 'b) allocates a new list.
[17:49:54] <sonny> what's a good way to represent state machines in scheme?
[17:50:09] <sham1> letrec
[17:50:19] <sham1> And mutually recursive functions
[17:52:28] <sham1> A state transition can then just be made into a tail-call, and since you'd have the states as local mutually recursive functions, it'd most likely compile down to simple gotos
[17:54:03] <sonny> yeah, I'm trying to get there, one moment
[17:54:43] <seninha> sham1, ns12: thank you
[17:54:49] <seninha> I'm reading R7RS, its index does not contain any reference to "literal" or "list literal"...
[17:58:37] *** Joins: klovett (~klovett@166.205.90.177)
[17:59:01] <sonny> sham1: handling the eof object and stream in general is confusing, would you do it like this? https://bpa.st/4QNA
[18:00:00] <ns12> seninha: Read section 4.1.2 "Literal expressions" (page 12).
[18:00:54] <ns12> " ... it is an error to attempt to alter
[18:00:54] <ns12> a constant (i.e. the value of a literal expression) using a
[18:00:54] <ns12> mutation procedure like set-car! or string-set!"
[18:01:40] <seninha> ns12: thanks!
[18:03:42] *** Quits: X-Scale (~ARM@83.223.235.65) (Ping timeout: 256 seconds)
[18:03:43] <seninha> oh, so '(a b) is a syntactic sugar for (quote (a b)), not (list 'a 'b)
[18:04:02] <Zipheir> Yes.
[18:04:34] <Zipheir> list is a procedure which returns a list, i.e. there's no list until the program is run.
[18:08:50] <Zipheir> sonny: SRFI 61 provides a convenient way of dealing with eof-object, e.g. (cond ((read-char in) char? => (lambda (c) ...)) (else 'done))
[18:09:21] <sonny> thanks
[18:09:47] <Zipheir> I don't mean to make things even more complicated. :)
[18:10:20] <sonny> why is eof not left as a numeric type?
[18:10:29] <sonny> just curious
[18:12:12] *** Quits: gproto23 (~gproto23@user/gproto23) (Ping timeout: 256 seconds)
[18:12:55] <sham1> Well it's not a number
[18:13:36] <sonny> it is in c/unix
[18:13:38] <Zipheir> It would break Scheme's type system, among other things.
[18:13:47] <sonny> oh
[18:13:51] <Zipheir> Because C's type system is totally broken!
[18:13:56] <sonny> lol
[18:14:48] <sonny> I refactored but I'm not sure who's responsibility it is to handle bad input https://bpa.st/F2VA
[18:14:55] <Zipheir> If eof-object were a number: (let ((x (read-u8 my-port))) (if (number? x) ... ...)) ; oops
[18:15:17] <sham1> https://bpa.st/RF6Q
[18:15:20] <sham1> I'd probably do it this way
[18:16:22] <sonny> ah, interesting
[18:16:45] <sham1> Well I don't even know if I'd do it quite like that. I'd return the parsed number, but yeah
[18:16:56] <sonny> (and (one-digit) (many-digits)) really shows the recursive nature nice
[18:17:22] <sham1> The many-digits is in the tail position, which is a good place for it to be
[18:17:57] <Zipheir> Where it has to be, if you're to avoid left recursion...
[18:18:25] <sonny> see, the eof check in one-digit I don't get, the first input can't be eof by definition
[18:18:56] <sonny> but, that's a real input I guess
[18:19:07] <sonny> maybe in real code you would check before then
[18:19:07] <sham1> If you don't get any input, you can have an unexpected EOF
[18:19:11] *** Joins: X-Scale (~ARM@83.223.235.65)
[18:19:31] <sham1> One improvement you'd want to probably do would be to "unread" a byte if it wasn't a character in the many-digits
[18:20:02] <Zipheir> peek-u8
[18:20:09] <sham1> ... or that
[18:20:23] <sham1> Or whatever that might be called in Racket
[18:20:56] <sham1> IDK, I personally find it a bit annoying to have to peek first and then consume, instead of consuming and if it doesn't match, unreading, but that's just me
[18:20:56] <Zipheir> Isn't peek-u8 in R6?
[18:20:59] <sonny> thanks, really impressed by your solution
[18:21:00] <sham1> It's the same thing
[18:22:24] <sham1> Zipheir: R6 seems to only have peek-char
[18:22:27] <sham1> R7 has peek-u8
[18:22:42] <Zipheir> Found it; it's lookahead-u8.
[18:23:04] <sham1> That it seems
[18:23:15] <sham1> Technically it's a descriptive name, but it's a bit verbose
[18:23:20] <sham1> I like the R7 name better
[18:23:21] <Zipheir> Agreed.
[18:24:47] *** Quits: s-liao (~s-liao@101.86.101.64) (Quit: Client closed)
[18:26:18] *** Joins: badkins (~badkins@136.56.92.199)
[18:27:13] <sonny> just noticed this (<= #x30 x #x90), is that standard?
[18:27:31] <Zipheir> Yes.
[18:28:15] *** Joins: mononote (~mononote@user/mononote)
[18:28:44] <Zipheir> <= returns #t if its arguments are monotonically non-decreasing (R7RS §6.2.6)
[18:29:01] <Zipheir> (And it takes any number of arguments.)
[18:29:12] <sonny> nice, unexpected scheme boost
[18:29:17] <sham1> Yeah. It checks whether the values are monotonically increasing. Or in other words, it's just the inequality #x30 ≤ x ≤ #x90
[18:29:18] <Zipheir> Er, at least two.
[18:32:08] <sham1> Some other languages have this kind of stuff for three values, like Python, but of course Scheme having symexes makes it easy to have any number of values in there. Well, any values above 2 as said
[18:34:56] <Zipheir> Scheme procedures that can be variadic usually are, which is nice.
[18:37:46] <sham1> And of course it makes it nice to check whether a list for example has the property of the elements being non-decreasing: (apply <= '(2 3 6))
[18:37:59] <sham1> Similar stuff is also there for other relational operators
[18:40:17] <Zipheir> I suppose for reliable programs you'd want to avoid the apply to an arbitrary list.
[18:40:32] <sham1> Obviously, but that's more just an example
[18:40:36] <Zipheir> Of course.
[18:41:16] <sham1> You'd want to check things like whether the list is proper (I don't recall if that check is mandated for apply itself) and stuff like that
[18:41:56] <Zipheir> Ugh, improper lists.
[18:44:05] <sham1> Yep
[18:44:18] <sham1> Those are indeed painful
[18:44:32] <Zipheir> Funny, CHICKEN gives: (apply + '(1 2 . 3)) ; => 3
[18:44:42] <Zipheir> *That's* an implementation choice.
[18:45:35] <Zipheir> chibi and Guile raise exceptions, which is more what I'd expect.
[18:46:32] <sham1> Meanwhile something like (apply + '#1=(1 . #1#)) could either raise an error, which I'd expect, or loop forever
[18:46:55] <Zipheir> Oof.
[18:47:49] *** Joins: gproto23 (~gproto23@user/gproto23)
[18:48:05] <sham1> Okay. Gauche at least raises an error
[18:48:22] <sham1> Guild doesn't
[18:48:27] <sham1> Guile*
[18:48:37] <Zipheir> chibi also errors out, good.
[18:48:42] <sham1> Apparently it gets stuck in the reader
[18:49:29] <sham1> Meanwhile CHICKEN just doesn't understand this datum label syntax OOTB
[18:49:55] <sonny> using another 'name' for the tail was obvious in bnf, but not in code. bnf is really underused
[18:50:17] <sonny> I also forgot let returns a value
[18:50:44] <sham1> And outside of the immediate Scheme world, SBCL just gives up saying that all the call frames were exhausted
[18:51:23] <Zipheir> sonny: Yeah, BNF is a great tool.
[18:52:38] <Zipheir> More generally, recursive equations are massively useful in all areas of computation.
[18:52:53] <sham1> And mathematics
[18:53:29] <sham1> Of course assuming one would even consider computing and mathematics disjointed, but that's another topic entirelh
[18:53:41] *** Joins: libfud (~libfud@2600:1700:48e8:d1cf:aaa1:59ff:fe53:95b8)
[18:54:08] *** Quits: johnjay (~pi@192.142.100.50) (Ping timeout: 256 seconds)
[18:56:20] *** Joins: johnjay (~pi@192.142.100.50)
[18:56:51] <jcowan> Zipheir: People can vote twice if they change their minds: all votes but the last are ignored.
[18:58:04] <Zipheir> Aha.
[19:04:06] <mdhughes> There are no improper lists. Lists are just chains of pairs which happen to have nil at the end.
[19:04:49] *** Quits: mononote (~mononote@user/mononote) (Remote host closed the connection)
[19:05:04] <Zipheir> What lists "are" can be debated.  That's how Scheme implements them, but it loosely corresponds to their usual inductive definition.
[19:05:46] <Zipheir> (for all types A, list A = Nil | Cons (A, list A))
[19:05:51] <mdhughes> Right, I wouldn't really say Scheme has lists. The library implements lists, the reader fakes them, but it has pairs.
[19:06:32] <mdhughes> But I'm accustomed to growable array O(1)-ish "lists" in most other languages.
[19:06:47] <Zipheir> True.  They mostly behave themselves, in any case.
[19:07:18] <Zipheir> e.g. flexvectors
[19:07:20] <sham1> Scheme has lists the same way C has strings. We use those words because they're convenient for their respective usages and from the context one knows that they are
[19:07:37] <Zipheir> Exactly.  In fact, that's how Olin Shivers puts it in SRFI 1.
[19:08:27] <Zipheir> Fortunately, Scheme's lack of "true" lists isn't usually as disastrous as C's lack of "true" strings.
[19:09:13] <gwatt> I'd go as far to say that most language warts aren't as bad as C's strings
[19:09:59] *** Joins: mononote (~mononote@user/mononote)
[19:11:20] <sham1> Indeed, at least R7 defines a list as either the empty list or a pair whose cdr is also a list. So it's inductively defined
[19:12:23] <sham1> And of course the set of all lists is the smallest set that satisfies the above
[19:24:09] *** Quits: sonny (~sonny@bras-base-london1483w-grc-27-70-51-121-200.dsl.bell.ca) (Quit: Client closed)
[19:29:33] *** Joins: skapata (~Skapata@2804:14c:87b0:a6f9:40a5:a81e:f992:bb69)
[19:29:33] *** Quits: skapata (~Skapata@2804:14c:87b0:a6f9:40a5:a81e:f992:bb69) (Changing host)
[19:29:33] *** Joins: skapata (~Skapata@user/skapata)
[19:50:15] *** Quits: j0ni (c79e08d4b1@chat.sr.ht) (Remote host closed the connection)
[19:52:45] *** Joins: j0ni (c79e08d4b1@2604:bf00:561:2000::2a)
[19:54:59] *** Quits: taiju (~taiju@240b:253:ec40:2400:20e3:d321:f9f8:1864) (Ping timeout: 264 seconds)
[19:56:20] *** Joins: taiju (~taiju@240b:253:ec40:2400:20e3:d321:f9f8:1864)
[20:03:04] *** Quits: wnklmnn (~wnklmnn@2a02:908:4e2:9740:909c:db78:471d:a682) (Quit: Leaving)
[20:08:12] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[20:18:00] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 256 seconds)
[20:19:37] *** Joins: aeth (~aeth@user/aeth)
[20:26:02] *** Quits: evdubs (~evdubs@cpe-66-8-236-219.hawaii.res.rr.com) (Ping timeout: 240 seconds)
[20:29:30] *** Joins: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de)
[20:38:32] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[20:39:03] *** Joins: badkins (~badkins@136.56.92.199)
[20:44:04] *** Quits: badkins (~badkins@136.56.92.199) (Ping timeout: 256 seconds)
[20:44:47] *** Joins: grettke (~grettke@cpe-65-29-228-30.wi.res.rr.com)
[21:07:48] *** Quits: klovett (~klovett@166.205.90.177) (Quit: ZZZzzz…)
[21:21:36] *** Joins: badkins (~badkins@136.56.92.199)
[21:48:50] *** Joins: sonny (~sonny@bras-base-london1483w-grc-27-70-51-121-200.dsl.bell.ca)
[21:50:19] <sonny> how can I delay in being evaluated? (let ([x (read-byte in)])
[21:50:41] <ecraven> what do you mean, delay?
[21:53:43] <sonny> I want to remove in as a global variable and bind it in S instead, but if I do that, it says in is unbound https://bpa.st/GD2Q
[21:54:05] <sonny> not sure what I mean, I just thought about lazy eval for some reason
[21:55:09] <gwatt> Is there a reason you can't pass `in` to `I` instead of trying to use global variables?
[21:55:45] <ecraven> that ^
[21:56:13] <sonny> I can do that, but I didn't want T to have multiple parameters, to make it easier for me to figure out this automata stuff
[21:56:18] <sonny> but that's valid
[21:59:39] <gwatt> what are you trying to accomplish? It looks like what you've written will just consume all the ascii digits and stop?
[21:59:55] <sonny> yes, that's it
[22:00:14] <sonny> I am making a machine to recognize integers
[22:00:54] <sonny> integer ::= digit | tale; digit ::= 0..9
[22:01:43] <sonny> which is really helping me get a handle on the notation and state machines and their implementation
[22:01:49] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 250 seconds)
[22:02:48] <sonny> if it was an imperative language, it's easy when you change the bnf to a diagram, but I'm starting to see the power of bnf
[22:03:29] *** Joins: aeth (~aeth@user/aeth)
[22:04:02] <sonny> now I just want to test on a bunch of values with (map S data)
[22:09:19] <gwatt> It might be a good idea to have S return the number it thinks it parsed, or #f if it didn't succeed. That way you can examine the result to make sure it's doing what you think it is
[22:13:15] <sonny> yeah, good call
[22:13:27] <jcowan> The curious thing is that every Lisp object is a (proper) list, an improper list, or a circular list.  Normally we don't treat things like 5 is improper lists of length zero, but it comes up, as in (lambda x ...).
[22:13:41] <jcowan> s/5 is/5 as
[22:16:02] <gwatt> How does it come up in (lambda x ...)? Do you mean the variable `x` ?
[22:16:45] *** Joins: klovett (~klovett@166.205.90.177)
[22:48:00] *** Joins: evdubs (~evdubs@cpe-66-8-236-219.hawaii.res.rr.com)
[22:49:10] <amazigh> such as: (define list (lambda args args))
[22:50:42] <dpk> if i have a predicate foo? and i want to define a variant of it with an asterisk, is that foo?* or foo*?
[22:51:26] <gwatt> *f*o*o*?* just to be sure
[22:51:47] <Zipheir> M*A*S*H notation.
[22:52:08] <Zipheir> jcowan: R7RS doesn't seem to say that atoms are improper lists.
[22:53:26] <Zipheir> dpk: The question is, does it check the predicate foo*, or is it a variant of the predicate foo ?
[22:53:34] <dpk> the latter
[22:53:37] <gwatt> dpk: Depending on what the new predicate does I would probably give it a slightly different name, like foo-bar?
[22:53:44] <Zipheir> Then foo?* seems right to me.
[22:55:39] <amazigh> foo-SpEcIaL?
[22:55:46] <amazigh> easy to type :p
[23:00:46] <Zipheir> Yeah, descriptive names are always preferable for me, rather than "primed" ones.
[23:02:02] *** Joins: Inline (~Inline@2a02:908:1252:7a80:e1d1:e64a:139f:9e8)
[23:21:54] *** Joins: tfeb (~tfb@88.98.95.237)
[23:26:35] *** Quits: sonny (~sonny@bras-base-london1483w-grc-27-70-51-121-200.dsl.bell.ca) (Quit: Client closed)
[23:45:35] *** Quits: Inline (~Inline@2a02:908:1252:7a80:e1d1:e64a:139f:9e8) (Remote host closed the connection)
[23:50:46] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[23:50:58] *** Joins: badkins (~badkins@136.56.92.199)
[23:54:55] *** Quits: tfeb (~tfb@88.98.95.237) (Ping timeout: 250 seconds)
[23:55:49] *** Joins: Inline (~Inline@2a02:908:1252:7a80:7839:e0f2:7ca6:b112)
[23:58:27] *** Quits: badkins (~badkins@136.56.92.199) (Remote host closed the connection)
[23:59:04] *** Joins: badkins (~badkins@136.56.92.199)
