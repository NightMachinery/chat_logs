[00:31:30] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[00:41:33] *** Joins: rotateq (~user@p200300e787056600fdfeed040e17b750.dip0.t-ipconnect.de)
[01:08:21] *** Quits: random-nick (~random-ni@87.116.178.231) (Quit: quit)
[01:09:42] *** Joins: random-nick (~random-ni@87.116.178.231)
[01:37:00] *** Joins: Oladon (~olad@98.43.81.226)
[01:46:35] *** Quits: Partmedia (~kevinz@172-221-159-029.res.spectrum.com) (Ping timeout: 268 seconds)
[01:50:36] *** Joins: Partmedia (~kevinz@172-221-159-029.res.spectrum.com)
[02:58:37] *** Quits: random-nick (~random-ni@87.116.178.231) (Ping timeout: 265 seconds)
[03:08:34] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[04:46:57] *** Quits: lottaquestions (~nick@2607:fa49:503e:3000:dd05:5816:a203:9234) (Ping timeout: 250 seconds)
[05:28:18] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[05:33:38] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[05:54:33] *** Quits: sts-q (~sts-q@212.53.219.238) (Ping timeout: 265 seconds)
[05:58:57] *** Joins: Oladon (~olad@98.43.81.226)
[06:09:20] *** Joins: sts-q (~sts-q@91.200.108.247)
[06:24:50] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 260 seconds)
[06:45:59] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[06:49:10] *** Quits: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 265 seconds)
[07:10:32] *** Quits: lotuseater (~user@p200300e7870566004b01295534bb48e2.dip0.t-ipconnect.de) (Ping timeout: 246 seconds)
[08:18:44] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[10:12:04] *** Joins: CodeBitCookie[m] (~code-bit-@2001:470:69fc:105::a2f)
[10:12:20] <CodeBitCookie[m]> Hello Everyone!
[10:12:59] <CodeBitCookie[m]> Can anyone explain to me how #+(or), which creates a comment, can have test in it and improve your workflow?
[10:13:00] <CodeBitCookie[m]> Thanks
[10:13:11] <CodeBitCookie[m]> tests*
[10:14:05] <CodeBitCookie[m]> Also why does that even exist when you have semi-colons (;)?
[10:30:11] <beach> This is a reader macro that checks a feature.  Normally, it is used to check for things like a particular implementation.
[10:31:04] <beach> Like #+sbcl.  Then the following expression is ignored if :SBCL is not an element of the list that is the value of *FEATURES*.
[10:31:22] <beach> But, this reader macro also allows Boolean combinations.
[10:31:44] <beach> So you can say #+(or sbcl ccl)...
[10:32:19] <beach> And the following expression is taken into account only if either :SBCL or :CCL is an element of that list.
[10:33:05] <beach> So if you say #+(or)... Then it is a Boolean expression that is never true.  So the following expression is then commented out.
[10:33:37] <beach> The difference between a comment and this reader macro is when the expression is followed by more characters.
[10:33:45] <beach> ... on the same line.
[10:34:24] <beach> So #+(or) (hello) (there) comments out only (hello)
[10:34:37] <beach> But ; (hello) (there) comments out both.
[10:34:49] <beach> Also, your expression could be over more than one line.
[10:35:21] <beach> So #+(or)(first-line<newline>second-line) will comment out the expression that covers two lines.
[10:35:44] <beach> But ; (first-line<newline>second-line) will comment out only the first line.
[10:44:43] <pjb> CodeBitCookie[m]: don't consider it as a comment, but rather as an ignored expression.
[10:45:49] <pjb> CodeBitCookie[m]: in a ; or #| |# comment, any text can exist.  But after #+(or) only valid sexps can exist: it must be readable (to some extent).
[10:46:08] <beach> Good point.
[10:52:20] <CodeBitCookie[m]> pjb: beach Ahhhh so the valid sexp is the main thing. The sexp compiles but doesn't run since it is "commented out" with a reader macro
[10:52:55] <beach> CodeBitCookie[m]: Almost!  It is not even returned by the reader.
[10:53:00] <beach> So the compiler never sees it.
[10:53:09] <beach> It is whitespace to the compiler.
[10:53:29] <CodeBitCookie[m]> so who checks if the sexp is valid
[10:53:45] <beach> The reader checks that it is well formed, but not more.
[10:53:48] <CodeBitCookie[m]> I thought the compiling happens before reading.
[10:53:53] <beach> Not at all.
[10:54:18] <beach> First, the expression is read, meaning it is turned into internal representation.
[10:54:19] <CodeBitCookie[m]> what falls in the criteria of it being well formed
[10:54:25] <beach> The compiler works on the internal representation.
[10:54:45] <beach> It must not contain any invalid characters.
[10:55:02] <beach> And I think it checks for invalid tokens too, like a:::b and stuff like that.
[10:55:16] <CodeBitCookie[m]> isn't every character supported by lisp?
[10:55:25] <CodeBitCookie[m]> like even in names you can escape everything even whitespace
[10:55:42] <beach> In a string you can.
[10:55:47] <beach> But not in a token.
[10:57:15] <beach> But yes, you can escape it so that it is treated as alphabetic.
[10:57:28] <CodeBitCookie[m]> is this a good explanation on tokens? http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_2-3-5.html
[10:58:32] <beach> Yes, that's the standard. 
[10:59:47] <CodeBitCookie[m]> then what about the lispworks one? which one should I follow?
[10:59:58] <CodeBitCookie[m]> Or are they the same?
[11:00:05] <beach> They are the same.
[11:00:12] <CodeBitCookie[m]> Oh thanks.
[11:01:43] <CodeBitCookie[m]> According to (then) the hyperspec, a token is "token n. a textual representation for a number or a symbol." but a name is "an identifier by which an object, a binding, or an exit point is referred to by association using a binding." So is the name a token or the other way around?
[11:01:53] <CodeBitCookie[m]> or they arent even related
[11:02:57] <beach> Some names are tokens, but not all.
[11:03:24] <beach> (SETF FOO) is a valid name for a function, but it is not a token.
[11:03:41] <beach> "COMMON-LISP" is the name of a package.  It is a string and not a token.
[11:03:57] <CodeBitCookie[m]> so 3 is a token?
[11:04:03] <beach> Yes.
[11:04:08] <CodeBitCookie[m]> and 'FOO is a token
[11:04:24] <beach> Well, that depends on what you mean by "is".
[11:04:43] <beach> When the reader sees 'FOO, it returns the list (QUOTE FOO) and that is not a token.
[11:06:07] <CodeBitCookie[m]> really? when does a reader see a symbol? is that then a token?
[11:06:15] <CodeBitCookie[m]> Also, sorry for all of my questions.
[11:07:15] <beach> If you just type FOO, then the reader will return a symbol.
[11:07:31] <beach> Try (read-from-string "FOO") and (read-from-string "'FOO")
[11:09:12] <CodeBitCookie[m]> Woowww.
[11:09:47] <CodeBitCookie[m]> thats really cool, so is the reader itself using some kind of advanced form of read-from-string (If you simplify the anology enough)?
[11:10:03] <beach> Since we are at it, try (read-from-string "#+(or) foo bar")
[11:10:36] <beach> READ-FROM-STRING just turns the string into a stream and calls READ on it.
[11:12:16] <CodeBitCookie[m]> ohhhh
[11:12:46] <CodeBitCookie[m]> I also noticed the `''FOO` returns the same thing as `(read-from-string "'FOO")`
[11:14:11] <beach> Sure.  The reader returns (QUOTE (QUOTE FOO)), which is then evaluated.
[11:14:38] <CodeBitCookie[m]> so `''FOO` isn't really a token
[11:14:41] <beach> And the evaluator sees (QUOTE ...) and returns the ... unevaluated, so the result of the evaluation is (QUOTE FOO).
[11:14:58] <beach> Again, it depends on what you mean by "is".
[11:15:28] <beach> The reader does not return a token for that sequence of characters. 
[11:15:53] <CodeBitCookie[m]> The evaluated version "is" a token but the input as a reader "isn't" where as (read-from-string "'FOO") "is" a token when passed to the reader as well as evaluated?
[11:16:58] <beach> No, "'FOO" when seen by the reader is turned into (QUOTE FOO) which is a list of tho elements, hence not a token.
[11:17:22] <beach> of two elements
[11:18:05] <CodeBitCookie[m]> can you tell me the 2 versions of what "is" can be
[11:18:22] <CodeBitCookie[m]> ... meant
[11:18:40] <CodeBitCookie[m]> g/be meant/mean
[11:18:41] <beach> 1. When seed by the reader.  2. After evaluation.
[11:18:43] <beach> At least.
[11:19:13] <beach> So 'FOO when read and then evaluated "is" a token.
[11:19:26] <beach> But 'FOO when only read, is a list.
[11:19:40] <beach> That's why you should always clarify, and never use just "is".
[11:21:14] <CodeBitCookie[m]> Ahhhhhhhh Thanks I finally understand this. I never really got it before but using list and quote is still unnatural to me and I just use them whenever. Since Quote doesn't evaluate things and list returns a list but evaluates it until a quote is applied?
[11:21:36] <CodeBitCookie[m]> by it I mean its arguments
[11:22:32] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[11:24:42] <CodeBitCookie[m]> I got it thanks
[11:28:29] <beach> Sure.
[11:28:53] <beach> The Common Lisp semantics for function call is that arguments are evaluated before the function is applied to them.
[11:29:28] <beach> Special operators don't work like that, which is why they are "special".
[11:29:42] <beach> QUOTE is a special operator that returns its argument unevaluated.
[11:31:49] <beach> So for example, when the expression (LIST (QUOTE X)) is evaluated, then LIST is a function so its argument (QUOTE X) is first recursively evaluated.  QUOTE is a special operator that returns its argument so the evaluation of (QUOTE X) results in the symbol X.
[11:32:16] <beach> Then LIST is applied to the symbol X, and constructs a list of it, so the entire expression evaluates to (X).
[11:33:19] <beach> Contrast it with the expression (QUOTE (LIST X)).  Then the top-level expression has the QUOTE special operator, so the argument, i.e., (LIST X) is returned unevaluated.
[11:56:29] <CodeBitCookie[m]> Ohhhhhhhhhhhhhhhhhhhhhh
[11:56:40] <CodeBitCookie[m]> now I get it. Great explanation
[11:58:30] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 260 seconds)
[11:58:48] <beach> Great!  Thanks!
[11:59:46] *** Joins: selwyn (~selwyn@user/selwyn)
[12:02:25] <CodeBitCookie[m]> Also, CL HyperSpec states that a keyword is a symbol which is interned. while it states that interned is "(of a symbol) accessible[3] in any package." So if I declare a keyword :FOO it is accessible everywhere meaning the :Foo is the same value in every package?
[12:02:58] <CodeBitCookie[m]> like "public static" in Java
[12:03:28] <CodeBitCookie[m]> or maybe I am confusing interned with external?
[12:04:03] <beach> The important thing about keywords is that they are symbols with "KEYWORD" as their "home package".
[12:05:14] <beach> It says so in definition 1 of the glossary.
[12:06:12] <beach> As for "interned", it is definition 2 that is the good one.
[12:06:32] <beach> I don't know what they mean by definition 1. 
[12:07:05] <beach> And neither of those have anything to do with whether the symbol in internAL or external.
[12:09:27] <CodeBitCookie[m]> i think by the first they mean :foo evaluates to itself like an atom
[12:09:33] <CodeBitCookie[m]> "1. It causes the symbol to become bound to itself."
[12:10:08] <CodeBitCookie[m]> "2. It causes the symbol to become an external symbol of the KEYWORD package."
[12:10:38] <beach> I don't see those under "keyword" or "interned".
[12:10:46] <CodeBitCookie[m]> so for 2 i don't understand why it says external on 2
[12:11:08] <CodeBitCookie[m]> beach: wdym?
[12:11:11] <CodeBitCookie[m]> http://www.lispworks.com/documentation/lw51/CLHS/Body/t_kwd.htm
[12:11:30] <beach> That's not the glossary.
[12:11:36] <beach> Which is why I didn't see it.
[12:12:26] <beach> But yes, keywords are special in that they are bound to themselves.
[12:13:15] <CodeBitCookie[m]> so about the external?
[12:13:50] <beach> It means you can access it from any other package without using a double package marker, i.e., ::
[12:14:25] <CodeBitCookie[m]> ahhh so implicit import like inheriting in OOP
[12:14:53] <beach> NOOOOOO
[12:15:02] <beach> Importing  means using NO package prefix.
[12:15:35] <beach> Accessing an external symbol in a different package requires a single package marker like my-package:foo.
[12:15:41] <CodeBitCookie[m]> hahahhah
[12:16:03] <CodeBitCookie[m]> well then whats the point of it, my hands not aching to type an extra `:`
[12:16:26] <beach> Possible symbol conflicts otherwise.
[12:16:45] <CodeBitCookie[m]> I don't get it.
[12:16:53] <beach> Also, favor to the maintainer of your code.  It is then obvious from what package the symbol originates.
[12:17:29] <CodeBitCookie[m]> I kind of get it. I think this is a whole chapter on its own so maybe you can refer to a link or book chapter I can read up on
[12:17:43] <beach> If you have say a function FOO in package P and a function FOO in package Q, and you want to use both, you can't unless you use a package marker.
[12:18:08] <beach> Yes, I think PCL has a chapter.
[12:18:21] <beach> minion: Please tell CodeBitCookie[m] about PCL.
[12:18:21] <minion> CodeBitCookie[m]: look at PCL: pcl-book: "Practical Common Lisp", an introduction to Common Lisp by Peter Seibel, available at http://www.gigamonkeys.com/book/ and in dead-tree form from Apress (as of 11 April 2005).
[12:18:49] <beach> I really need to get some work done.  I hope others can take over.
[12:19:55] <CodeBitCookie[m]> beach: Thank you for all the explaining. Bye, hope you get your work completed without problems
[12:20:33] <CodeBitCookie[m]> minion: ahhh, I read PCLs few chapters but not all of it.
[12:20:38] <CodeBitCookie[m]> gonna read
[12:20:39] <minion> ahhh, I read PCLs few chapters but not all of it: I can't be expected to work when CLiki doesn't respond to me, can I?
[12:22:10] <beach> minion: Are you a bot?
[12:22:10] <minion> i'm not a bot. i prefer the term ``electronically composed''. 
[12:42:59] <pjb> CodeBitCookie[m]: the keyword being external means that you can write a single colon:   :foo to access keyword:foo ; if it wasn't exported, we'd have to write ::foo or keyword::foo  (we can still use the double colon on exported symbols, including keywords, but it's not needed).
[13:15:51] *** Joins: lottaquestions (~nick@2607:fa49:503e:3000:b2cd:bffd:9b60:82b9)
[13:22:54] *** Joins: lotuseater (~user@p200300e7870566004b01295534bb48e2.dip0.t-ipconnect.de)
[13:26:48] <rotateq> So if continuations can be seen as a kind of time travel and one is compiling with them, maybe one day a program gets compiled before even read. :)
[13:39:15] <edgar-rft> programs might get compiled before they are read but I'm not convinced that they will be able to continue after that :-)
[13:44:45] <rotateq> all those pitty paradoxies of time travel
[14:40:10] *** Joins: lisp123 (~lisp123@5.30.23.247)
[14:42:03] *** Joins: random-nick (~random-ni@87.116.183.216)
[14:43:33] <CodeBitCookie[m]> pjb: Thanks!
[14:43:44] <CodeBitCookie[m]> rotateq: lol
[15:32:16] *** Quits: lisp123 (~lisp123@5.30.23.247) (Quit: Leaving...)
[15:58:44] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[16:14:40] *** Joins: jeffrey (~jeffrey@80-115-60-193.cable.dynamic.v4.ziggo.nl)
[16:15:01] <CodeBitCookie[m]> Hello Jeffrey
[16:15:10] <jeffrey> Hello
[16:15:57] <CodeBitCookie[m]> I am a beginner student here.
[16:16:36] <beach> Hello jeffrey.
[16:17:22] <jeffrey> Hello beach
[16:17:25] <beach> CodeBitCookie[m]: Oh, did you greet before you saw an utterance from jeffrey?  That's not done on IRC.  
[16:17:37] <beach> CodeBitCookie[m]: We would drown in greetings then.
[16:17:54] <beach> CodeBitCookie[m]: Plus, some people prefer to just lurk.
[16:18:03] <CodeBitCookie[m]> beach: Sorry beach. Will not do again.
[16:18:32] <jeffrey> I'm a lurker mostly
[16:18:42] <CodeBitCookie[m]> hmmm
[16:28:30] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[16:34:25] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[17:08:04] *** Quits: Josh_2 (~user@37.25.47.130) (Remote host closed the connection)
[17:40:56] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[17:49:56] *** Quits: jeffrey (~jeffrey@80-115-60-193.cable.dynamic.v4.ziggo.nl) (Quit: Client quit)
[17:50:42] *** Joins: jeffrey (~jeffrey@80-115-60-193.cable.dynamic.v4.ziggo.nl)
[17:51:00] <pjb> CodeBitCookie[m]: you may do it.  beach has a bot to greet automatically when he logs in.
[17:51:14] <beach> I do not.
[17:51:28] <pjb> A way to signal you're available for interactive interaction.
[17:51:37] <beach> I do it manually with my abbrev "gme" that expands to "Good morning everyone!"
[17:52:07] <pjb> you could have M-x gme RET that would send it to all channels ;-)
[17:52:26] <beach> Exactly what pjb says.  The greeting is a kind of indication that one is willing to exchange utterances. 
[17:53:08] <beach> pjb: I could, but I was "harasses" here (in #clschool) about it, so I now longer greet.
[17:53:48] <pjb> fine tuning. ok.
[17:57:43] <CodeBitCookie[m]> Gonna do that
[18:01:30] *** Joins: selwyn (~selwyn@user/selwyn)
[18:01:45] *** Quits: selwyn (~selwyn@user/selwyn) (Remote host closed the connection)
[18:02:10] *** Joins: selwyn (~selwyn@user/selwyn)
[18:05:47] *** Joins: Oladon (~olad@98.43.81.226)
[18:06:04] *** Quits: jeffrey (~jeffrey@80-115-60-193.cable.dynamic.v4.ziggo.nl) (Ping timeout: 252 seconds)
[18:07:50] <beach> *harassed 
[18:09:05] <CodeBitCookie[m]> yeah lol
[18:18:50] *** Joins: thrig (~thrig@70.97.65.251)
[18:27:14] *** Quits: lottaquestions (~nick@2607:fa49:503e:3000:b2cd:bffd:9b60:82b9) (Ping timeout: 260 seconds)
[18:29:42] *** Joins: Josh_2 (~user@37.25.47.130)
[18:30:46] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[18:46:28] *** Joins: lisp123 (~lisp123@5.30.23.247)
[18:50:55] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[19:03:09] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[19:03:42] *** Joins: lisp123 (~lisp123@5.30.23.247)
[19:06:36] *** Joins: shka (~herr@109.231.62.239)
[19:06:36] *** Quits: shka (~herr@109.231.62.239) (Client Quit)
[19:06:50] *** Joins: shka (~herr@109.231.62.239)
[19:09:09] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[19:23:26] *** Joins: dra (~dra@2a04:4540:640c:f100:8881:b96:6405:a162)
[19:25:04] *** Quits: dra (~dra@2a04:4540:640c:f100:8881:b96:6405:a162) (Client Quit)
[19:25:14] *** Joins: dra (~dra@2a04:4540:640c:f100:8881:b96:6405:a162)
[19:29:10] *** Quits: thrig (~thrig@70.97.65.251) (Remote host closed the connection)
[19:38:26] *** Parts: Partmedia (~kevinz@172-221-159-029.res.spectrum.com) ()
[19:39:01] *** Joins: lisp123 (~lisp123@5.30.23.247)
[19:44:52] *** Joins: thrig (~thrig@65.113.153.50)
[19:48:32] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[19:48:44] *** Joins: lisp123 (~lisp123@5.30.23.247)
[20:20:00] *** Joins: tophullyte (tophullyte@gateway/vpn/protonvpn/tophullyte)
[20:31:55] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[21:27:33] <CodeBitCookie[m]> I am doing the Lisp-Koans. I have run into a koan which I can't understand. Here is a link to the function: http://ix.io/3zXu
[21:27:41] <CodeBitCookie[m]> specifically,
[21:28:11] <CodeBitCookie[m]> I don't understand the (declare (special x)) and when calling f the answer isn't 20
[21:28:49] <CodeBitCookie[m]> Sorry it is 20
[21:29:01] <CodeBitCookie[m]> I still don't understand why the declare special
[21:30:24] <thrig> presumably x must be a dynamic variable for a dynamic variable test to be relevant
[21:30:41] <CodeBitCookie[m]> sorry i just realised that.
[21:30:48] <CodeBitCookie[m]> and was about to reply to my comment
[21:31:12] <CodeBitCookie[m]> but are there any more use cases for declare
[21:31:23] *** Joins: selwyn (~selwyn@user/selwyn)
[21:31:59] <thrig> probably documented in dec_dynamic-extent.html
[21:32:53] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[21:33:36] *** Joins: lisp123 (~lisp123@5.30.23.247)
[21:38:29] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[21:42:47] <rotateq> CodeBitCookie[m]: maybe you want to stick first more to working through some intro book material, so you can get your basics right
[21:44:20] <thrig> 10 REM GET BASIC RIGHT
[21:47:56] <rotateq> thrig: oh noez
[21:48:18] <rotateq> 10 print "Hello World"
[21:48:25] <rotateq> 20 goto 10
[21:48:42] <thrig> there are some basic implementations in CL though
[21:48:57] <rotateq> :)
[21:49:16] <rotateq> (tagbody 10 (print "Hello World") 20 (go 10))
[21:49:42] <thrig> most are more extensive than that
[21:49:59] <rotateq> hopefully
[22:08:14] <CodeBitCookie[m]> <rotateq> "CodeBitCookie: maybe you want to..." <- I will again fully read Practical Common Lisp without side tracking a 1000 times. Thanks for the reminder and help.
[22:09:25] *** Joins: lisp123 (~lisp123@5.30.23.247)
[22:09:59] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[22:10:12] *** Joins: lisp123 (~lisp123@5.30.23.247)
[22:40:10] <rotateq> CodeBitCookie[m]: no problem, keeping track well is not easy
[22:41:02] <thrig> hey, my puppy wandered into a dungeon, can you help save it?
[22:41:02] <plexi> AwwWWwwWww... Puppies...
[22:47:36] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[23:00:53] <pjb> thrig: http://informatimago.com/develop/lisp/com/informatimago/small-cl-pgms/basic/index.html
[23:00:59] <pjb> rotateq: ^ too
[23:01:42] <pjb> rotateq:  (tagbody 10 (write-line "Hello World") 20 (go 10))
[23:02:06] <thrig> aah good old memories about worrying about running out of additional lines between 30 and 35
[23:02:55] <pjb> thrig: https://gitlab.com/nasium-lse/nasium-lse/-/blob/master/lse-mode.el#L321
[23:04:33] <thrig> oh there's the raw link, hiding in a _
[23:06:44] *** Quits: thrig (~thrig@65.113.153.50) (Remote host closed the connection)
[23:12:05] <rotateq> line number 30+1/2 ...
[23:20:44] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[23:21:05] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
