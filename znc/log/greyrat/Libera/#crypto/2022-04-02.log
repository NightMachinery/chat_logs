[00:02:30] *** Quits: pulseaudio (~pulseaudi@103.42.174.55) (Ping timeout: 250 seconds)
[00:14:03] *** Quits: gproto23 (~gproto23@user/gproto23) (Remote host closed the connection)
[00:15:45] *** Joins: brolin (~brolin@191.95.16.58)
[00:28:38] *** Quits: zer0bitz (~zer0bitz@2001:2003:f750:a200:f81b:729b:7ef0:993) (Ping timeout: 260 seconds)
[00:40:29] *** Quits: ivii (~ivan@user/ivii) (Ping timeout: 252 seconds)
[00:40:41] *** Joins: ivii (~ivan@user/ivii)
[00:41:16] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Remote host closed the connection)
[00:45:47] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 246 seconds)
[00:45:58] *** Joins: Lord_of_Life_ (~Lord@user/lord-of-life/x-2819915)
[00:47:13] *** Lord_of_Life_ is now known as Lord_of_Life
[00:49:32] *** Joins: filename (~kilitary@188.242.105.134)
[00:53:37] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[00:54:10] *** Quits: filename (~kilitary@188.242.105.134) (Remote host closed the connection)
[00:54:22] *** Joins: gabriel1 (~gabriel1@user/gabriel1)
[01:00:23] *** Joins: zer0bitz (~zer0bitz@2001:2003:f750:a200:18ec:9063:4133:b132)
[01:02:31] *** Joins: llorllale (~llorllale@198.98.119.85)
[01:08:28] *** PJBoy is now known as Guest1669
[01:08:28] *** Quits: Guest1669 (~PJBoy@user/pjboy) (Killed (strontium.libera.chat (Nickname regained by services)))
[01:08:42] *** Joins: PJBoy (~PJBoy@user/pjboy)
[01:26:28] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Remote host closed the connection)
[01:33:45] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[01:38:52] *** Quits: brolin (~brolin@191.95.16.58) (Ping timeout: 272 seconds)
[01:48:52] *** Joins: Tangent-Man (~Tang3nt-M@77.14.200.146.dyn.plus.net)
[01:50:40] *** Quits: Tangent-Man (~Tang3nt-M@77.14.200.146.dyn.plus.net) (Remote host closed the connection)
[01:51:05] *** Joins: Tangent-Man (~Tang3nt-M@77.14.200.146.dyn.plus.net)
[01:52:20] *** Quits: andreasbuhr (~quassel@p549dbbe6.dip0.t-ipconnect.de) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
[02:02:17] *** Joins: brolin (~brolin@191.91.246.177)
[02:12:04] *** Quits: byteskeptical (~amnesia@user/byteskeptical) (Quit: Lost terminal)
[02:16:28] *** Joins: nq (~nq@82.79.141.40)
[02:18:02] *** Quits: zer0bitz (~zer0bitz@2001:2003:f750:a200:18ec:9063:4133:b132) (Read error: Connection reset by peer)
[02:26:57] *** Joins: Tang3nt-Man (~Tang3nt-M@81.174.132.104)
[02:27:03] *** Quits: Tangent-Man (~Tang3nt-M@77.14.200.146.dyn.plus.net) (Ping timeout: 260 seconds)
[02:35:55] *** Quits: halosghost (~halosghos@user/halosghost) (Quit: WeeChat 3.4.1)
[02:44:47] *** Joins: clf059 (~clf059@2603:3023:a2b:a800:5dcb:29b9:b26d:4ee1)
[02:46:09] *** Quits: clf059 (~clf059@2603:3023:a2b:a800:5dcb:29b9:b26d:4ee1) (Client Quit)
[02:58:44] *** Joins: MajorBiscuit (~MajorBisc@2a02:a461:129d:1:6d4c:38a4:18b7:4b48)
[03:01:29] *** Quits: ioxzev1z (~ioxzev1z@user/ioxzev1z) (Quit: Leaving)
[03:14:22] *** Quits: MajorBiscuit (~MajorBisc@2a02:a461:129d:1:6d4c:38a4:18b7:4b48) (Quit: WeeChat 3.4)
[03:28:45] *** Quits: Tang3nt-Man (~Tang3nt-M@81.174.132.104) (Remote host closed the connection)
[03:37:19] *** Quits: chomwitt (~chomwitt@ppp-94-67-69-112.home.otenet.gr) (Ping timeout: 260 seconds)
[03:48:37] <rk4> literally first hit in duckduckgo ;(
[04:20:37] *** Quits: xx (~xx@user/xx) (Ping timeout: 256 seconds)
[04:23:16] *** Joins: dude12312414 (~test@gateway/tor-sasl/dude12312414)
[04:24:35] <halosghost1> lol
[04:24:40] <halosghost1> rk4: searching is hard
[04:26:21] *** Joins: skaro (~skaro@2600:8807:180:80:c42d:6172:fae9:2b29)
[04:26:39] *** Quits: Klotz (~Klotzoman@gateway/tor-sasl/klotz) (Quit: Klotz)
[04:31:37] *** Quits: Wulf (~Wulf@user/wulf) (Ping timeout: 256 seconds)
[04:32:22] *** Quits: brolin (~brolin@191.91.246.177) (Remote host closed the connection)
[04:33:00] *** Joins: Wulf (~Wulf@user/wulf)
[04:37:22] *** Quits: dude12312414 (~test@gateway/tor-sasl/dude12312414) (Quit: THE RAM IS TOO DAMN HIGH)
[04:39:43] *** Quits: sobkas (~sobkas@95.175.17.217) (Remote host closed the connection)
[04:42:03] *** Joins: blarnath (~d34dh0r53@98.97.81.202)
[04:43:02] *** Quits: d34dh0r53 (~d34dh0r53@98.97.82.239) (Ping timeout: 252 seconds)
[05:01:03] *** Quits: ivii (~ivan@user/ivii) (Ping timeout: 260 seconds)
[05:17:05] <gevreeen> given a list of sessions 1, 2, 3, 4 . . .  n. with associated session keys K1 . . . Kn, we generate S(<Ki>, m) as a session number. however, how do we ensure that S(<Ki>, m) stays unique for any integer m and i?
[05:17:36] <gevreeen> with absolute certainty
[05:18:16] <gevreeen> m here would be the mth' exchange of message
[05:19:18] <gevreeen> and this scheme is supposed to give a rolling dynamic (as opposed to fixed) session number
[05:19:33] <MacGyver> We don't.
[05:19:44] <MacGyver> You're using different keys and different inputs.
[05:20:19] <MacGyver> Or am I misinterpreting S() here?
[05:20:33] <gevreeen> yeah, different keys and inputs.
[05:20:43] <MacGyver> And S is encryption using the key?
[05:21:12] <gevreeen> S is the process that produces the session number, the <> is a transform on the key
[05:21:44] *** Joins: filename (~kilitary@82.148.25.66)
[05:21:45] <MacGyver> And you're asking for *any* process that *would* guarantee uniqueness?
[05:22:15] <halosghost1> as a rule, it's impossible to ensure no repeats ever unless the number of bits in the target space is unbounded
[05:22:30] *** halosghost1 is now known as hg
[05:22:33] <MacGyver> Because then I'm thinking S could be encryption with a stable key.
[05:23:16] <gevreeen> yeah, some process S that can guarantees uniqueness, or there would be a collision
[05:24:07] <gevreeen> and yeah, we need a limit on the total number of sessions to guarantee uniqueness
[05:25:57] <gevreeen> then we impose upon ourselves an upper bound U for S and L for m, and this S(<Ki>, m> would stay unique as long as the total number of sessions S < U, and m < L
[05:26:56] <gevreeen> K1... Kn themselves should be unique
[05:26:58] <hg> when you say total, do you mean total ever, or do you mean total live at any given time?
[05:27:36] <MacGyver> I'm still thinking S could be encryption with a stable key.
[05:27:57] <MacGyver> Or any PRP, really.
[05:27:59] <hg> MacGyver: that's almost certainly true
[05:28:45] <hg> also, Kₙ could just as well be generating a new UUID
[05:29:04] <gevreeen> I think I would say total ever, as total live at any given time would mean killing old sessions
[05:29:51] <gevreeen> actually this should be written as S(<Ki>, m(i))
[05:30:22] <gevreeen> as clients only know their number of exchanges specific to the session, not the total
[05:30:59] <gevreeen> and right, encryption could work, but the problem is uniqueness
[05:31:44] <hg> gevreeen: how long do you expect this protocol to live?
[05:32:07] <gevreeen> that would the server allowance for long-running tasks, 10 minutes
[05:32:21] <hg> gevreeen: unless you're designing a system intended to last decades upon decades, you probably don't need the level of guarantee of uniqueness you're asking for
[05:32:54] <hg> hell, generate four v4 UUIDs and concatenate them, the potential for that key to ever collide is effectively nil
[05:34:27] <hg> but, of course, if you want to absolutely guarantee you'll never have a collision ever, just have a bignum (mpz_t) and increment it for every new session (never resetting it)
[05:34:40] <hg> so long as you keep adding RAM, you'll never run out
[05:36:04] <gevreeen> or, concat session_id||exchange_id and encrypt on the thing
[05:36:42] <gevreeen> now we just have to make sure the plaintext never collides
[05:37:17] <gevreeen> if both ids are fixed in width
[05:37:38] <gevreeen> and either id never wraps around
[05:38:30] <gevreeen> the downside being one key for all
[05:38:45] <hg> even if the ids are fixed-width, if they're UUIDs you just don't have to care about repetition
[05:39:14] <hg> and, if the plaintext needs to not repeat (I can't see why that would be but I'm not really sure what you're doing here), you can salt it with a UUID as well
[05:39:55] <gevreeen> scrap it. I think the uuid method is far easier
[05:41:11] *** Joins: frost (~frost@user/frost)
[05:43:40] *** Quits: mmlj4 (~mmlj4@ip174-69-109-162.no.no.cox.net) (Remote host closed the connection)
[05:44:13] <hg> I mean
[05:44:49] <hg> gevreeen: not to dissuade you given that that's what I've been advocating for, but just for the record, UUIDs don't guarantee no repeats ever (though, again, statistically speaking, it would be absolutely shocking if your system ever saw a repeated UUID)
[05:44:59] *** Joins: menace (~someone@ppp-93-104-173-139.dynamic.mnet-online.de)
[05:45:51] *** Quits: Deknos (~someone@user/menace) (Ping timeout: 256 seconds)
[05:48:01] <hg> (just want to be clear that UUIDs are almost certainly fine, but if they are, that means you probably don't need a true guarantee of no-repeats-ever)
[05:52:12] <maroon> happy birthday, dear collision, happy birthday to you
[05:54:07] *** Quits: Elzington (~Elzington@87.249.134.10) (Remote host closed the connection)
[05:54:44] *** Quits: gabriel1 (~gabriel1@user/gabriel1) (Ping timeout: 272 seconds)
[05:55:49] *** Joins: Elzington (~Elzington@68.235.43.12)
[06:10:49] *** Joins: TunnelJ (~TunnelJ@99-167-200-231.lightspeed.sndgca.sbcglobal.net)
[06:10:55] *** Quits: Sofia (~sofia@user/sofia) (Ping timeout: 240 seconds)
[06:15:28] *** Joins: Elzington_ (~Elzington@87.249.134.38)
[06:17:08] *** Joins: Sofia (~sofia@user/sofia)
[06:18:17] *** Quits: Elzington (~Elzington@68.235.43.12) (Ping timeout: 246 seconds)
[06:30:47] *** Joins: mmlj4 (~mmlj4@ip174-69-109-162.no.no.cox.net)
[06:52:13] <caveman> is there any combination of symmetric encryption cipher and operation mode that, if the encryption key has X entropy bits, then all its encrypted blocks are mathemtically proven secure with X entropy bits?
[06:53:56] <danieldg> no; the only proven encryption schemes are the trivial ones like OTP
[06:54:15] <danieldg> and that does follow for OTP
[06:54:53] <caveman> otp has perfect secrecy.  meaning, total entropy is more than just X bits, but rather the total number of bits in the ciphertext.  right?
[06:55:52] <danieldg> not sure about the 'more' but mostly yes
[06:56:08] <caveman> iirc, otp says:  if cipher text has Z many bits, then the total security is worth Z many entropy bits.
[06:56:43] <danieldg> that's not a normal way to measure things, but ok
[06:57:43] <caveman> my question is a bit more relaxed: is there an algorithm that guarantees X many entropy bits of its ciphertext, where X is the total number of entropy bits in its shared key?
[06:58:26] *** Joins: pulseaudio (~pulseaudi@223.223.137.136)
[06:58:27] <caveman> so, i'm asking for X bits, not Z bits.
[06:58:52] <danieldg> not a real one
[06:59:07] <danieldg> error-correcting codes do that
[06:59:13] <danieldg> but that's not encryption
[06:59:19] <pulseaudio> python enigma sims ?
[06:59:42] <caveman> error correcting codes use keys?
[06:59:49] *** Quits: [itchyjunk] (~itchyjunk@user/itchyjunk/x-7353470) (Ping timeout: 240 seconds)
[06:59:58] <hg> pulseaudio: it sounds like people have found some just searching ddg
[07:01:01] <caveman> danieldg: i don't get how keys, with X many entropy bits in them, relate to error correcting ods.
[07:01:20] <pulseaudio> can't quite get it
[07:04:00] *** Joins: [itchyjunk] (~itchyjunk@user/itchyjunk/x-7353470)
[07:04:43] <danieldg> caveman: maybe the GHASH operation has that property, when used as an encryption function and not a hashing function
[07:06:35] <danieldg> caveman: the point is you need a *simple* operation to have this property
[07:06:48] <danieldg> caveman: and that doesn't make for a secure cipher
[07:08:27] *** Quits: pulseaudio (~pulseaudi@223.223.137.136) (Remote host closed the connection)
[07:08:57] <caveman> this https://en.wikipedia.org/wiki/Galois/Counter_Mode ?
[07:09:09] <danieldg> yes.  It's just a dot product.
[07:10:04] <danieldg> er, multiplication in a field, not the matrix/vector one
[07:11:22] <danieldg> caveman: anyway, encrypt(key, block) = key * block
[07:17:03] *** Joins: gproto23 (~gproto23@user/gproto23)
[07:18:35] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Ping timeout: 240 seconds)
[07:20:41] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[07:27:22] *** Joins: _filename (~kilitary@188.242.105.134)
[07:29:13] *** Quits: filename (~kilitary@82.148.25.66) (Ping timeout: 260 seconds)
[07:40:30] *** Quits: Elzington_ (~Elzington@87.249.134.38) (Quit: Leaving)
[07:52:18] *** Quits: milkt (~debian@gateway/tor-sasl/milkt) (Remote host closed the connection)
[08:04:48] *** Quits: machinedgod (~machinedg@24.105.81.50) (Ping timeout: 260 seconds)
[08:06:58] *** Joins: milkt (~debian@gateway/tor-sasl/milkt)
[08:08:57] *** Joins: pulseaudio (~pulseaudi@223.223.137.136)
[08:10:30] *** Quits: pulseaudio (~pulseaudi@223.223.137.136) (Remote host closed the connection)
[08:20:04] *** _filename is now known as filename
[08:27:55] *** Quits: TunnelJ (~TunnelJ@99-167-200-231.lightspeed.sndgca.sbcglobal.net) (Quit: Quit)
[08:45:53] *** Quits: gproto23 (~gproto23@user/gproto23) (Remote host closed the connection)
[08:48:17] *** Joins: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb)
[09:05:22] *** Quits: Malvolio|Z (~Malvolio@user/malvolio) (Ping timeout: 272 seconds)
[09:39:11] *** Joins: ua__ (~ua@public-gprs226849.centertel.pl)
[09:42:43] *** Quits: ua_ (~ua@public-gprs222674.centertel.pl) (Ping timeout: 260 seconds)
[09:44:04] *** Quits: filename (~kilitary@188.242.105.134) (Remote host closed the connection)
[09:45:29] *** Quits: PJBoy (~PJBoy@user/pjboy) (Ping timeout: 246 seconds)
[09:46:39] *** Quits: AkechiShiro (~licht@user/akechishiro) (Ping timeout: 252 seconds)
[09:47:23] *** Joins: filename (~kilitary@188.242.105.134)
[09:47:31] *** Joins: AkechiShiro (~licht@user/akechishiro)
[09:53:43] *** Joins: BOKALDO (~BOKALDO@user/bokaldo)
[10:25:15] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Ping timeout: 240 seconds)
[10:27:26] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[10:38:03] *** Quits: [itchyjunk] (~itchyjunk@user/itchyjunk/x-7353470) (Remote host closed the connection)
[10:38:15] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Ping timeout: 240 seconds)
[10:50:35] *** Quits: skaro (~skaro@2600:8807:180:80:c42d:6172:fae9:2b29) (Quit: KVIrc 5.0.1 Aria http://www.kvirc.net/)
[10:54:27] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[11:02:38] *** Joins: gproto23 (~gproto23@user/gproto23)
[11:05:28] *** Quits: filename (~kilitary@188.242.105.134) (Remote host closed the connection)
[11:13:34] *** Joins: Tangent-Man (~Tang3nt-M@mutantalien.plus.com)
[11:28:25] *** Quits: igemnace (~ian@user/igemnace) (Quit: WeeChat 3.5)
[11:48:30] *** Joins: filename (~kilitary@188.242.105.134)
[11:49:38] *** Joins: Guyver2 (~Guyver@guyver2.xs4all.nl)
[12:03:31] *** Quits: gproto23 (~gproto23@user/gproto23) (Remote host closed the connection)
[12:27:38] *** Quits: menace (~someone@ppp-93-104-173-139.dynamic.mnet-online.de) (Quit: menace)
[12:53:04] *** Joins: igemnace (~ian@user/igemnace)
[13:04:12] *** Quits: Gallomimia (~Gallomimi@node-1w7jra2a2gqpy0uagmp10uuul.ipv6.telus.net) (Remote host closed the connection)
[13:30:52] *** Joins: chomwitt (~chomwitt@2a02:587:dc1b:d600:c3a8:b4dc:b642:1f2)
[13:48:37] *** Joins: ivii (~ivan@user/ivii)
[13:56:14] *** Quits: Church (~aleph@68.161.207.188) (Ping timeout: 260 seconds)
[13:56:25] *** Joins: callq (~callq@157.41.181.204)
[14:09:47] *** Parts: Guyver2 (~Guyver@guyver2.xs4all.nl) (Closing Window)
[14:13:26] *** Joins: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net)
[14:19:05] *** Quits: callq (~callq@157.41.181.204) (Quit: callq)
[14:21:44] *** Quits: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
[14:23:21] *** Joins: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net)
[14:23:49] *** Quits: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net) (Client Quit)
[14:25:22] *** Joins: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net)
[14:25:25] *** Joins: callq (~callq@2409:4062:4e16:b59e:d4fa:180e:f8a8:43d6)
[14:26:37] *** Joins: xx (~xx@user/xx)
[14:36:38] *** Joins: gproto23 (~gproto23@user/gproto23)
[14:36:50] *** Quits: gproto23 (~gproto23@user/gproto23) (Remote host closed the connection)
[14:37:29] *** Joins: gproto23 (~gproto23@user/gproto23)
[14:39:06] *** Joins: Klotz (~Klotzoman@gateway/tor-sasl/klotz)
[14:41:24] *** Quits: callq (~callq@2409:4062:4e16:b59e:d4fa:180e:f8a8:43d6) (Quit: callq)
[14:52:10] *** Joins: fanis30 (~anon@adsl-153.37.6.0.tellas.gr)
[15:00:22] *** Quits: frost (~frost@user/frost) (Ping timeout: 250 seconds)
[15:06:03] *** Quits: igemnace (~ian@user/igemnace) (Remote host closed the connection)
[15:10:57] *** Joins: sobkas (~sobkas@95.175.17.217)
[15:29:41] *** Joins: zer0bitz (~zer0bitz@2001:2003:f750:a200:a519:6081:f3da:f296)
[15:35:02] *** Quits: fanis30 (~anon@adsl-153.37.6.0.tellas.gr) (Quit: WeeChat 3.3)
[15:40:15] *** Quits: Klotz (~Klotzoman@gateway/tor-sasl/klotz) (Ping timeout: 240 seconds)
[15:43:38] *** Joins: Klotz (~Klotzoman@gateway/tor-sasl/klotz)
[15:44:22] *** Quits: BOKALDO (~BOKALDO@user/bokaldo) (Quit: Leaving)
[15:44:23] *** Quits: gproto23 (~gproto23@user/gproto23) (Read error: Connection reset by peer)
[15:45:16] *** Joins: gproto23 (~gproto23@user/gproto23)
[15:46:15] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Ping timeout: 240 seconds)
[15:47:44] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[15:52:17] *** Quits: filename (~kilitary@188.242.105.134) (Read error: Connection reset by peer)
[15:58:01] *** Joins: machinedgod (~machinedg@24.105.81.50)
[16:12:45] *** Joins: Church (~aleph@68.161.207.188)
[16:19:55] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Ping timeout: 240 seconds)
[16:24:43] *** Quits: sebn (~sebn@c90-142-43-192.bredband.tele2.se) (Ping timeout: 260 seconds)
[16:32:09] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[16:41:17] *** Quits: zer0bitz (~zer0bitz@2001:2003:f750:a200:a519:6081:f3da:f296) ()
[16:47:52] *** Joins: BOKALDO (~BOKALDO@user/bokaldo)
[16:47:54] *** Joins: xenoterracide (~xenoterra@99-124-139-34.lightspeed.iplsin.sbcglobal.net)
[17:04:43] *** Quits: xenoterracide (~xenoterra@99-124-139-34.lightspeed.iplsin.sbcglobal.net) (Ping timeout: 256 seconds)
[17:08:19] *** Joins: SlimmyJimmy (blank@user/slimmyjimmy)
[17:09:02] <bw> Are interactive zero-knowledge proofs simpler and easier to implement?
[17:12:56] *** Joins: PJBoy (~PJBoy@user/pjboy)
[17:14:21] <river> ???/
[17:19:16] *** Joins: igemnace (~ian@user/igemnace)
[17:23:35] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Ping timeout: 240 seconds)
[17:25:30] <yawkat> "it depends"
[17:45:53] *** Quits: SlimmyJimmy (blank@user/slimmyjimmy) (Remote host closed the connection)
[17:51:05] *** Quits: gproto23 (~gproto23@user/gproto23) (Remote host closed the connection)
[17:56:46] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[18:05:24] *** Joins: ioxzev1z (~ioxzev1z@user/ioxzev1z)
[18:22:39] *** Joins: SlimmyJimmy (blank@user/slimmyjimmy)
[18:41:44] *** Quits: ioxzev1z (~ioxzev1z@user/ioxzev1z) (Quit: Leaving)
[18:47:19] *** Quits: Pythayr (~pither195@vps-1494dc6f.vps.ovh.us) (Ping timeout: 260 seconds)
[19:01:51] *** Joins: filename (~kilitary@188.242.105.134)
[19:08:12] <Alipha> bw: than?
[19:08:39] <bw> Non-interactive
[19:12:28] *** Joins: zer0bitz (~zer0bitz@2001:2003:f750:a200:d90e:8b62:fe9d:3118)
[19:13:05] *** Joins: ioxzev1z (~ioxzev1z@user/ioxzev1z)
[19:16:43] *** Quits: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb) (Quit: ZNC - https://znc.in)
[19:19:04] *** Quits: igemnace (~ian@user/igemnace) (Quit: WeeChat 3.5)
[19:22:43] *** Joins: igemnace (~ian@user/igemnace)
[19:22:50] *** Quits: igemnace (~ian@user/igemnace) (Read error: Connection reset by peer)
[19:23:28] *** Joins: igemnace (~ian@user/igemnace)
[19:24:06] *** Quits: igemnace (~ian@user/igemnace) (Client Quit)
[19:24:45] *** Quits: filename (~kilitary@188.242.105.134) (Quit: joined libera)
[19:25:16] *** Joins: igemnace (~ian@user/igemnace)
[19:27:09] *** Joins: filename (~kilitary@static.246.201.46.78.clients.your-server.de)
[19:28:26] *** Joins: Pythayr (~pither195@072-238-180-064.res.spectrum.com)
[19:28:58] <hg> bw: iiuc, the Fiat-Shamir heuristic allows you to take any interactive zk proof and turn it into a non-interactive one
[19:29:08] <hg> (in the random oracle model)
[19:29:15] *** Joins: fanis30 (~anon@adsl-33.109.242.225.tellas.gr)
[19:29:44] <hg> so, making an interactive zk proof into a non-interactive one is as simple as “just” leveraging Fiat-Shamir on top of the interactive one you built
[19:30:01] <hg> https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic
[19:33:42] <bw> Ok
[19:38:23] *** Quits: machinedgod (~machinedg@24.105.81.50) (Ping timeout: 246 seconds)
[19:39:07] *** Quits: Pythayr (~pither195@072-238-180-064.res.spectrum.com) (Ping timeout: 260 seconds)
[19:39:24] *** Joins: Pythayr (~pither195@vps-1494dc6f.vps.ovh.us)
[19:40:13] *** Quits: milkt (~debian@gateway/tor-sasl/milkt) (Remote host closed the connection)
[19:45:31] *** Joins: [itchyjunk] (~itchyjunk@user/itchyjunk/x-7353470)
[19:49:51] *** Joins: milkt (~debian@gateway/tor-sasl/milkt)
[19:58:55] *** Joins: cvmn (~caveman@gateway/tor-sasl/caveman)
[20:01:15] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Ping timeout: 240 seconds)
[20:02:55] *** Quits: cvmn (~caveman@gateway/tor-sasl/caveman) (Ping timeout: 240 seconds)
[20:08:49] *** Joins: caveman_ (~caveman@gateway/tor-sasl/caveman)
[20:09:05] *** Quits: caveman_ (~caveman@gateway/tor-sasl/caveman) (Quit: the #end of the abyss)
[20:09:22] *** Joins: cvmn (~caveman@gateway/tor-sasl/caveman)
[20:10:51] *** Quits: fanis30 (~anon@adsl-33.109.242.225.tellas.gr) (Quit: WeeChat 3.3)
[20:15:43] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[20:24:19] *** Joins: andreasbuhr (~quassel@p549db84b.dip0.t-ipconnect.de)
[20:30:27] *** Quits: andreasbuhr (~quassel@p549db84b.dip0.t-ipconnect.de) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
[20:33:55] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Ping timeout: 240 seconds)
[20:37:15] *** Quits: cvmn (~caveman@gateway/tor-sasl/caveman) (Ping timeout: 240 seconds)
[20:37:46] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[20:39:37] *** Joins: LimaCharlie0410 (~Limacharl@221.149.170.18)
[20:55:08] *** Joins: andreasbuhr (~quassel@p549db84b.dip0.t-ipconnect.de)
[20:55:13] *** Quits: igemnace (~ian@user/igemnace) (Remote host closed the connection)
[20:55:49] *** Joins: TubbyTommy (blank@user/slimmyjimmy)
[20:59:08] *** Quits: SlimmyJimmy (blank@user/slimmyjimmy) (Ping timeout: 272 seconds)
[20:59:11] *** TubbyTommy is now known as SlimmyJimmy
[21:03:22] *** Joins: pulseaudio (~pulseaudi@223.223.137.136)
[21:03:25] *** Joins: zro (~zro@user/zro)
[21:06:49] <zro> If I'm moving files over ssh (say, scp), and I trust the recipient machine, is there any gain to encrypting the files first (say, pgp)?
[21:07:56] <river> no
[21:12:34] <zro> thanks, river 
[21:12:47] <zro> well, "no, it doesnt help, and in fact precludes useful functions" was my answer as well, however, my opponent in the argument seems to insist that thers some gain. got a link to something i can reference in argument?
[21:13:24] <river> why dont you ask him what the benefit is
[21:13:33] <ioxzev1z> zro, there is no gain assuming that the transfer is encrypted
[21:13:46] <danieldg> zro: define where trusted an untrusted parties sit and ask for a mechanism for an untrusted party to see anything interesting
[21:14:20] <river> also people who don't understand things are scared and get superstitious
[21:14:32] <river> which is where ideas like double encrypt things come from 
[21:14:33] <danieldg> that's how you prove anything, really
[21:14:35] <iz> cargo cult crypto
[21:15:04] <iz> i saw some smart guy do this once, so now i'm doing the same thing at all times
[21:15:12] <zro> i think there position is somthing like "if the ssh connection is magically broken with voodoo, then they still have to break the pgp"
[21:15:35] <river> I think it is correct that if they can break SSH they can get the plaintext of the file being transferred
[21:15:43] <iz> if they have voodoo though, that's trivial to break the pgp
[21:15:52] <river> if you think that is a realistic concern, don't use SSH
[21:16:07] *** Quits: SlimmyJimmy (blank@user/slimmyjimmy) (Quit: Going offline, see ya! (www.adiirc.com))
[21:16:11] <river> there's good reason to believe that SSH is secure though
[21:16:43] <iz> defense-in-depth is more of a security concept in general, which makes sense when the security of the systems being used is much less provable than with crypto systems
[21:20:57] <danieldg> there's more reason to believe the crypto on ssh is secure than there is to believe that sshd on the server is secure
[21:21:34] <danieldg> but then at that point you should not trust the destination machine
[21:22:05] *** Quits: LimaCharlie0410 (~Limacharl@221.149.170.18) (Remote host closed the connection)
[21:22:15] <danieldg> at some point you have to accept risk or secure your system by powering it off in a sealed bunker
[21:23:32] <iz> yeah, if you already stated the server is trusted, then it's trusted
[21:24:02] <iz> you have to decide what you trust and what you don't and go from there or else you can't do anything
[21:24:09] <river> well that escalated quickly
[21:25:40] <zro> right on. well thanks for the input. I mostly wanted to sanity check. I think ill stick to my position. thanks
[21:26:14] <river> yw
[21:27:03] <river> I suppose it is valid reasoning to say: I have belief p1 that SSH can be broken. I have belief p2 that PGP can be broken. Therefore belief p1 p2 (which is smaller) that both can be broken.
[21:27:27] <river> but I don't like this argument and think double wrapping is a bad practice
[21:28:54] *** Quits: varayu4812262 (~varayu@47.31.192.157) (Ping timeout: 272 seconds)
[21:28:57] <zro> my main initial objection to this was simply that encrypting the payload prior to transmission percludes useful things like the ability to do eg partial bakcups, use rsync, etc
[21:28:58] <danieldg> river: you have to counter that with other probabilities that are higher and define some p of acceptable risk when compared to effort e of doing the double-encrypt
[21:29:02] <zro> and i dont think it actually adds anything
[21:29:30] <danieldg> it does add a non-zero amount of security, but it subtracts lots of other things
[21:29:37] <iz> that's a good mathematical way to put it -- i think with modern crypto systems now, p1 and p2 will both be sufficently low already, however with other security technologies, the defense-in-depth approach makes more sense, b/c p1 and p2 in those cases will be much higher in general and above acceptable limits
[21:29:38] <river> that's a good way to defeat it
[21:29:42] <river> we need p > 0.9
[21:29:57] <river> but we already have p1 > 0.9, so we don't gain anything by using p1 p2
[21:30:00] <zro> ya that was my argument basically, i dont think it "hurts", but i think its totally unnecessary and just makes it more burdensome
[21:30:19] <river> ah i flipped around frmo p to 1-p for no reason, but ignoer that
[21:30:30] <iz> yeah, i got your meaning though
[21:31:28] <danieldg> also define the higher risk of data loss if you forget/lose the gpg key/password
[21:32:04] *** Joins: _filename (~kilitary@188.242.105.134)
[21:32:05] <zro> honestly, i think the compromise of long-term pgp private keys is the most likely scenario
[21:32:46] <danieldg> that too, and then the encryption is useless.  And maybe because you encrypted it you didn't secure the files as well as you should have
[21:33:32] *** Quits: filename (~kilitary@static.246.201.46.78.clients.your-server.de) (Ping timeout: 246 seconds)
[21:34:40] <zro> i dont think it applies here prolly cuz the shh vs pgp implementations are gonna be so different, but arent i correct in that, if you simply apply the same algo 2x, you didnt *really* double encrypt, you functionally just changed the key, no?
[21:35:09] <danieldg> no, you do double encrypt
[21:35:38] <danieldg> there is no K' such that AES(K1,AES(K2,M)) = AES(K',M)
[21:36:28] <zro> ok, im not sure where i got that from. prolly just not understanding the math correctly then
[21:36:40] <danieldg> the security level of AES is so high, however, that the realistic way to break it is to seal K and not break AES directly
[21:36:43] <int-e> danieldg: heh, plausible, but can you prove that?
[21:36:50] <danieldg> int-e: no
[21:37:02] *** Quits: andreasbuhr (~quassel@p549db84b.dip0.t-ipconnect.de) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
[21:37:25] <pulseaudio> which cipher was used in da vinci code ?
[21:37:37] *** Joins: JollyRoger (~JollyRoge@user/thejollyroger)
[21:37:49] *** JollyRoger is now known as PeterEaston
[21:37:54] *** PeterEaston is now known as TheJollyRoger
[21:41:22] <ioxzev1z> zro, if the encryption on your transfer is somehow broken, will you then automatically just start sending without encryption of the data in transit?
[21:41:35] <ioxzev1z> In that case you would benefit from encrypting the file before transfer
[21:42:03] <ioxzev1z> By broken I mean that the connections fails somehow and you automatically then fallback to non-encrypted transfer
[21:44:59] <zro> ioxzev1z: naw. im talking about just using ssh. eg scp or rsync or sftp maybe
[21:45:17] <zro> if theres a 'fallback to unencrypted' option on ssh, im unaware of it
[21:45:26] <ioxzev1z> Ok, so if the transfer is guaranteed to be encrypted then there is no reason to encrypt before send IMO.
[21:46:10] <zro> in #security, the best devils advocate response i got was basically "what if you fat figer the hostname and ssh into the wrong box"
[21:46:44] <ioxzev1z> So you have ssh keys on a wrong box?
[21:46:45] <iz> if your username and password work on the wrong box, there are much bigger issues
[21:47:24] <zro> iz: ya. thats kinda my thing. if the level of attack is such that ssh is rendered ineffective... ... ... they already have the long-term pgp private keys
[21:48:21] <iz> so the scenario is someone made a fake site, with your username and your pub key data.. AND you fat fingered the hostname that happened to be exactly that site?
[21:48:39] *** Joins: skaro (~skaro@2600:8807:180:80:5d47:1432:98e3:c73b)
[21:48:42] <zro> on a side note, im still really interested in this AES(K1,AES(K2,M)) != AES(K',M) bit. why on earth did i think that was possibly true? is this a property of lesser algos or something?
[21:48:48] *** Joins: LTCD (~LTCD@2a02:c7f:dd71:300:8df:5b98:e0c1:6b08)
[21:49:29] <LTCD> Hey I have a dumb question. If prime numbers are so hard to generate, how comes I can make a public and private key pair which use long prime numbers so quickly?
[21:49:40] <iz> also that argument basically boils down to "yeah, but what if the trusted host you are sending to, turns out to not be trusted?!?!"
[21:49:50] <zro> iz, i think fat fingered might be me being dramatic. ok, dns attack something maybe? 
[21:50:25] <zro> iz: i think thats what im getting at. but i think my opponent is trying to say that theres an attack vector on the ssh connection itself
[21:50:42] <iz> well, if you are sending to a server that isn't trusted, that's a whole different question
[21:50:42] <int-e> LTCD: It's not hard at around 2k bits or less.
[21:51:06] <danieldg> LTCD: hard is a relative measurement.  A computer can do a lot of work in one second.
[21:51:15] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Ping timeout: 240 seconds)
[21:52:29] <danieldg> zro: that's true for very simple algorithms like OTP when implemented as (key xor plaintext)
[21:52:34] <LTCD> int-e if it is not hard for my computer go generate a prime at 2K bits or less, why can't my computer generate primes 2K bits and attempt to crack encryption?
[21:52:38] <int-e> LTCD: Especially since for cryptographic purposes, nobody proves primality; probabilistic tests are good enough.
[21:53:06] <zro> danieldg: ok. that makes me feel slightly better.
[21:53:08] <iz> because you need to factor the product of primes to crack encryption -- not generate primes
[21:53:17] <iz> at least w/r/t rsa
[21:53:36] <iz> generating keys isn't the same as cracking encryption
[21:53:38] <int-e> LTCD: You mean for trial division? You'd have to guess the right prime out of 2^2k (a bit less than 2^2048, maybe 2^2030) possible ones...
[21:53:38] <danieldg> LTCD: you can do trial division to break RSA, but that will take something like 2^2000 tries to break 2048-bit RSA; factoring is a lot less work
[21:53:53] <LTCD> iz so then use my computer to generate them like it would for a pub/priv key pair. Then go through each one until two multiply successfully?
[21:54:18] <iz> no
[21:54:36] <iz> if it were possible to just do that, ppl would constantly be generating the same keys as other ppl
[21:54:39] <int-e> You can do that... but the universe will end before you finish.
[21:55:27] <iz> there are so many possible values, that when ppl generate keys they don't accidentally generate the same key as someone else
[21:55:34] *** Joins: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb)
[21:55:40] <iz> so you can't just guess in a practical way
[21:56:01] <LTCD> So even if I had a text file full of primes, to go through every possible pair multiplying them together, it still takes too long
[21:56:26] <int-e> ...execpt when the RNG is terrible
[21:58:42] <LTCD> But why, x=pq seems easy enough...
[21:59:14] <int-e> Oh I missed the 10th anniversary of this! https://lwn.net/Articles/481998/
[21:59:30] <LTCD> Start with first one, then go through each prime until two multiply into whatever you want
[22:00:19] <iz> LTCD: the problem isn't multiplying, it's factoring the result
[22:00:19] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[22:00:37] <int-e> LTCD: How long do you think it'll take you to count up to 10715086071862673209484250490600018105614048117055336074437503883703510511249361224931983788156958581275946729175531468251871452856923140435984577574698574803934567774824230985421074605062371141877954182153046474983581941267398767559165543946077062914571196477686542167660429831652624386837205668069376? (No skipping!)
[22:01:00] <LTCD> So you are saying, it is not just a case of multiplying two prime numbers together?
[22:01:23] <int-e> (that's 2^1000... so a rough estimate for how many primes you'd have to test to break a 2048 bit key using trial division)
[22:02:05] <Alipha> LTCD: it's easy to generate primes p and q. It's difficult to determine p and q given only p*q
[22:02:05] <iz> or even just find the factors of 2661528299
[22:02:28] <int-e> No, it's just that this number is astronomical; no computer, no data center, not even the whole planet turned into super-efficent grey goo will be able to finish a computation that big.
[22:02:33] *** Quits: Brnocrist (~spartak@user/brnocrist) (Ping timeout: 256 seconds)
[22:03:02] <int-e> We have /much/ better methods for factoring.
[22:03:06] <iz> LTCD: multiplying the primes together is how you make the key -- factoring the product of those primes is how you can break the public key to get the private key
[22:03:22] <iz> that's why there's so much fuss about factoring
[22:03:27] <Alipha> LTCD: determining if a number is prime does not involve trying to divide the number by every possible divisor. There are much, much faster ways
[22:04:06] *** Joins: Brnocrist (~spartak@user/brnocrist)
[22:04:24] <LTCD> Pretend I have an algorithm that can generate prime numbers on the fly, incredibly quickly. What would my next step be?
[22:04:33] <iz> to do what?
[22:04:35] <int-e> But they're still too slow to be used in practice for factoring 2048 RSA moduli (at least as far as publicly known). (Not counting quantum algorithms, which lack hardware support.)
[22:04:42] <LTCD> Crack my RSA key
[22:04:45] <iz> generating primes fast doesn't help you at all
[22:05:09] <danieldg> LTCD: the next step is throw out that algorithm and get out a factoring algorithm
[22:05:11] <iz> LTCD: multiplying the primes together is how you make the key -- factoring the product of those primes is how you can break the public key to get the private key
[22:05:50] <LTCD> Like my public key is 7 and my we need to find a factor to make 2978273
[22:06:01] <iz> no
[22:06:27] <iz> like what i just said to you twice
[22:06:58] <LTCD> But given my public key is the prime 7, if we are dealing with small numbers we could eventually figure it out?
[22:07:15] <iz> your public key is not a prime number
[22:07:25] <int-e> if your RSA public modulus is prime, you're fucked
[22:07:26] <LTCD> True
[22:08:18] <Peng> int-e: If you multiply two numbers and get a prime number, you might be a witch
[22:08:24] <int-e> The whole point of RSA decryption is that it's easy modulo primes.
[22:08:41] <int-e> Peng: 1*3 =<magic gesture>= 3
[22:09:08] <iz> a witch!
[22:09:11] <Peng> D:
[22:09:46] *** Joins: aleck1 (~aleck@user/aleck)
[22:10:10] *** Joins: cvmn (~caveman@gateway/tor-sasl/caveman)
[22:10:19] *** Quits: jtm (~jtm@user/jtm) (Quit: k byeeee)
[22:10:22] <LTCD> 1 isn't prime...
[22:10:49] <iz> peng didn't say two prime numbers though ;b
[22:10:55] <LTCD> Sorry
[22:11:48] <LTCD> I honestly put cryptography into the top 5 most difficult subjects. Crypto, math, physics, chemistry, engineering, law...
[22:12:23] *** Quits: aleck (~aleck@user/aleck) (Ping timeout: 260 seconds)
[22:12:33] <iz> crypto is really just applied math
[22:12:43] *** Joins: jtm (~jtm@user/jtm)
[22:12:51] <cvmn> every thought is applied math.
[22:13:23] <iz> except all the things that clearly aren't
[22:13:28] <Alipha> You could have all the computers in the world trying to generate primes until the death of the universe to try to guess what p and q are in p*q where p and q are 2048-bit primes and you'd still have a infinitesimal chance of actually finding p or q
[22:14:13] <cvmn> even with quantum computers?
[22:14:28] *** Joins: Gallomimia (~Gallomimi@node-1w7jra2a2gqpvpggwpec714yb.ipv6.telus.net)
[22:14:35] <iz> if that's your process, yes
[22:14:40] <cvmn> iz: name 1 thing that is not applied mathematics.
[22:15:04] <iz> conversation
[22:15:26] <int-e> sleep
[22:15:52] <iz> pooping
[22:16:23] <cvmn> iz: conversation is output generated by machine.  you're a machine, albeit biological and a bit more wet (neurons, hormones, etc).  machines are mathematical.  you have probability distribution defined in you.  it's very mathematical.  you just don't comprehend what you are.  but you're mathematics in action.
[22:16:44] *** Quits: LTCD (~LTCD@2a02:c7f:dd71:300:8df:5b98:e0c1:6b08) (Ping timeout: 250 seconds)
[22:16:47] <iz> before there was an application for it with crypto, crypto was all just theoretical math w/out any application
[22:17:00] <iz> that doesn't make it applied mathmatics
[22:17:03] <iz> words have meanings
[22:18:28] <cvmn> mathematics is just the best language mankind has found to date that allows it to "think" in the most accurate way.
[22:20:03] <TheJollyRoger> cvmn: Think I'm going to quote that sometime in the future, I just know it!
[22:21:12] *** Joins: dude12312414 (~test@gateway/tor-sasl/dude12312414)
[22:21:22] <cvmn> lel.
[22:24:15] <TheJollyRoger> For me, I unfortunately don't understand too much about the actual underlying mathematics behind things like the S-Boxes or Edwards Curves, so I just take it on faith that someone smarter than me has done the work on it. 
[22:27:09] *** Quits: lord| (~lordpipe@user/lordpipe) (Quit: https://i.imgur.com/xacQ09F.mp4)
[22:28:30] *** Joins: lord| (~lordpipe@user/lordpipe)
[22:28:55] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Ping timeout: 240 seconds)
[22:31:17] <TheJollyRoger> Nevertheless, what my simple primitive monkey mind *can* understand is that 2^256 would be more than a measurable portion of all the particles in the known universe, so as long as we don't invent magical storage that somehow is able to break the laws of physics, we won't be able to simply count that high via a simple iterative process, which is comforting.
[22:32:47] <ioxzev1z> That comes to like ~1.15*10^77, and iirc there are an estimated 10^80 protons in the universe
[22:32:51] <ioxzev1z> So yeah, big number
[22:33:12] <TheJollyRoger> Amazing!
[22:33:36] *** Joins: varayu4812262 (~varayu@157.37.149.148)
[22:34:00] <iz> you can use sort of a similar logic in reverse to see the improbability of interacting w/ intelligent life from some random place in the universe
[22:39:27] *** TheJollyRoger is now known as JollyRoger
[22:40:22] <cvmn> https://en.wikipedia.org/wiki/Confusion_and_diffusion#Diffusion
[22:40:23] <cvmn> > Diffusion means that if we change a single bit of the plaintext, then about half of the bits in the ciphertext should change, and similarly, if we change one bit of the ciphertext, then about half of the plaintext bits should change
[22:40:25] <cvmn> ^ any reason why 'half' is chosen?
[22:41:16] <iz> because that's the perfect amount
[22:41:27] <iz> if it's all of the bits, you know what will happen
[22:41:43] <iz> if it's 70% of the bits, you know 20% of what will happen
[22:41:59] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[22:42:06] <iz> if it's about half, you can't tell anything
[22:42:45] <cvmn> should the half be also random?  or can it be ``half bits on left''?
[22:42:53] <iz> no, random
[22:43:16] <iz> about half randomly throughout all the bits
[22:43:16] <danieldg> two unrelated random strings will have half their bits match.  That's the goal.
[22:43:33] <cvmn> say a hash is 512 bits.  changing 1 bit may depend on the 256 bits half on left, or the 256 bits half on right.  is this kind of halving ok?
[22:43:43] <iz> no
[22:46:23] *** Quits: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb) (Quit: ZNC - https://znc.in)
[22:46:51] <cvmn> i see.  thanks.
[22:47:46] <iz> just think of it like the bits from the input need to diffuse through all of the bits in the output
[22:49:20] <cvmn> yeah.  got it.  to rephrase:  upon changing 1 input bit, half of the hash's bits flip, and the others don't flip, hence giving maximum confusion/uncertanity to the adversary.  each time (changing hash bit or input) the half that flips also changes randomly.
[22:49:51] * iz nods yeah basically
[22:51:34] <cvmn> say i create an OTP-based hashing function, that's just an OTP encryption of input cleartext.  then, to create 512 bits hash off of it, i fold that ciphertext into itself by xoring, until i get 512 bits.  is this a perfectly secure hashing function?
[22:52:06] *** Quits: zro (~zro@user/zro) (Quit: WeeChat 3.5)
[22:52:09] <cvmn> not practical.  just wondering if this is a perfectly secure hashing function.
[22:52:40] <iz> no
[22:52:53] <iz> think about it, if you were to do that, the bits wouldn't diffuse
[22:53:28] <iz> changing one bit wouldn't change everything else, b/c you are just XORing 512 bits with itself over and over
[22:54:22] <cvmn> right.  
[22:55:17] <cvmn> any perfectly secure hashing function?  similar to how OTP shows a perfectly secure enc/dec?
[22:56:44] <iz> well hash functions don't have a key, so it's not really an equivalent
[22:57:30] <danieldg> there are one-time authenticators
[22:57:37] <danieldg> but that's not really a hash
[22:58:23] <danieldg> it's similar to how there isn't a perfect block cipher
[22:59:51] <iz> we just mix stuff up until it's mixed up more than we know how to unmix it up :b
[23:00:27] <danieldg> yeah, basically everything has a number of rounds
[23:00:36] <cvmn> i think i may help mankind here and propose a hashing/block cipher that's perfectly secure.
[23:01:04] <danieldg> that's a well-known problem with no solution yet
[23:01:11] <iz> you remind me of me in early school when i thought i would prove P=NP :D
[23:01:28] <cvmn> you mean, if i solve that, i'll be also solving P=NP?
[23:01:38] <danieldg> no, but it's about that hard
[23:01:54] <iz> yeah, just that it's similarly improbable
[23:02:33] <iz> but sometimes you have to just try anyway to find out exactly how improbable
[23:04:24] <cvmn> i have some thoughts.  i'm afraid i probably solved it.
[23:11:02] <cvmn> is O(m * n * log2(n)) good for a hashing function?  where m = hash length, n = message length.
[23:11:40] <iz> that doesn't even make sense
[23:11:58] <cvmn> why?
[23:12:14] <danieldg> usually you want (m + n), but anything could be interesting
[23:12:48] <cvmn> is O(m * n * log2(n)) already inside O(m * n)?
[23:12:55] <danieldg> no
[23:13:05] <yawkat> a perfectly secure hash function is impossible
[23:13:11] <cvmn> i wounder if log2(n) will have diminishing returns so tiny that it's ignorable.
[23:13:28] <cvmn> yawkat: is that proven?
[23:13:34] <yawkat> yes
[23:13:56] <cvmn> what is this proof called?
[23:13:57] <iz> O(m * x * log2(n)) = O(log2(n))
[23:14:07] <yawkat> it's called the pigeonhole principle
[23:14:16] <iz> you can't just throw terms into big-oh notation when you don't understand what it means
[23:15:17] <cvmn> iz: what's 'x' there?
[23:15:40] <cvmn> m = usually fixed, like 512.  so i see why m got dropped as it was treated like a constant.  but x = ?
[23:16:18] <iz> x is what you called n
[23:16:24] *** Quits: BOKALDO (~BOKALDO@user/bokaldo) (Quit: Leaving)
[23:16:26] <iz> i changed it because you used n in two places meaning different things
[23:17:07] <iz> unless you meant n, in which case it would be O(n log2(n))
[23:17:29] <cvmn> yawkat: same goes to OTP, no?  e.g. 2 different cleartexts may have the same ciphertext if their pads are unlucky enough to be different exactly in the unfortunate way to make them have identical ciphertext.
[23:17:37] <iz> but runtime with respect to input isn't really what you should be concerned about 
[23:17:45] <yawkat> cvmn: but that does not break the security
[23:17:58] <cvmn> same goes to a hashing function?
[23:18:01] <yawkat> no
[23:18:13] <cvmn> oh.  got it.  hashing functions have the unrealistic hope of being unique fingerprints.
[23:19:04] <yawkat> look at the definitions of IND-EAV encryption, and of compressing hash functions. it's easy to see which one you can and which one you cant make perfectly secure.
[23:19:36] <cvmn> to make a hashing function perfectly unique, it must be just a perfectly compressed string with a size thats equal to shannon's entropy of input  text.  but i guess this will violate confusion and diffusion?
[23:20:12] <yawkat> confusion and diffusion are not actually requirements for a hash function.
[23:20:17] <iz> well, hash functions accept any input length
[23:20:24] <iz> so eventually you will get a collision
[23:20:45] <iz> because the hash is a fixed size
[23:21:55] <cvmn> ideally, should the probability of collision be 2^-512 for a 512 bit hash?
[23:25:58] <cvmn> yawkat: i think the pigeonhole doesn't eliminate the existence of a perfect hashing function.  it just makes us accept reality that collisions will exist, and our hope is to minimise its probability.
[23:26:32] <iz> what do you think a perfect hashing function would mean then?
[23:26:33] <danieldg> this depends on a precise definition of perfect hash function
[23:26:57] *** Quits: CryptoClub (~fafs@35.red-88-8-42.dynamicip.rima-tde.net) (Ping timeout: 250 seconds)
[23:27:30] *** Joins: CryptoClub (~fafs@119.red-81-44-77.dynamicip.rima-tde.net)
[23:27:44] <yawkat> also "probability of collision be 2^-512" is too imprecise to say anything because collision resistance is adversarial
[23:27:58] <yawkat> if it wasnt adversarial it would be very easy to implement such a hash function
[23:28:42] <cvmn> iz: i propose this:  (1) asymptotically, any adversary mus only predict 50% of the hash's bits right upon flipping bits of its input.  (2) adversary's best hope for finding a collision should come at a probability of 2^-512.
[23:28:56] <cvmn> (assuming the hash is 512 bits)
[23:29:12] <yawkat> probability over what?
[23:29:58] <yawkat> i can break any hash function using that definition, by simply trying all inputs until i find a collision
[23:30:04] <yawkat> my attack succeeds with probability 1
[23:30:09] <cvmn> over the space of inputs.  his best strategy as he is sampling the space of inputs, he should nail it at 2^-512.
[23:30:52] <yawkat> you have to be more precise when making these definitions
[23:30:58] <yawkat> if you want to get anywhere
[23:31:05] <cvmn> i.e., on average, he finds a collision after trying 2^512 many times.
[23:32:44] <cvmn> 2^512 trials is a lot.  by then, his p.c. might be turned off by the cleaner as he won't be at office.
[23:33:07] <yawkat> this sounds like a random oracle definition, which can be proven to be impossible to fulfill
[23:33:59] <yawkat> but who knows, because your definition isnt precise enough to tell
[23:38:07] <cvmn> just to verify whether i understood you:  are you saying that, there cannot be an n-bit hashing function that, on average, requires the adversary to do 2^n trials to find a collision?
[23:38:57] <yawkat> it really depends on what you mean by trials
[23:39:55] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Ping timeout: 240 seconds)
[23:41:58] <danieldg> cvmn: it's assumed the adversary knows the function, for one, so 'trial' might be harder to define than you think
[23:42:01] <cvmn> i guess you're pay attention to the possibility that the normal user might be selecting input cleartext from a small set of possibilities, and the adversary may predict it easily without needing to test 2^512 inputs?
[23:42:04] <cvmn> yawkat: ^
[23:42:32] *** Quits: pulseaudio (~pulseaudi@223.223.137.136) (Ping timeout: 250 seconds)
[23:42:56] <yawkat> no, im paying attention to the fact that "trial" implies the hash function is a black box
[23:44:44] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[23:45:35] <cvmn> and, once we imply that, we've already made the claim that it is secure?  hence a pointless thought?
[23:46:26] *** Joins: x88x88x (~x88x88x@149.28.53.172)
[23:46:29] <danieldg> no, but you've made an unrealistic assumption, so conclusions from there aren't useful
[23:46:37] <yawkat> that
[23:46:40] <danieldg> it doesn't directly lead to it being secure
[23:46:45] <yawkat> if your definition requires the hash function to be a black box, it is not implementable
[23:47:28] <danieldg> no computer or circuit implements a black_box opcocde
[23:47:38] <yawkat> .o(TPM)
[23:47:57] <danieldg> well, that uses normal cryptography
[23:48:30] <danieldg> it's well-defined what it does, and the key is there if you break out your electron microscope :)
[23:49:03] <yawkat> .o(qubit in superposition)
[23:50:08] <danieldg> ok, that *might* be able to do it
[23:50:56] <danieldg> but have fun keeping that bit in superposition
[23:51:19] <yawkat> i only do theory. not my problem.
[23:53:07] <danieldg> an important part of hashing would be to have the same function implemented by more than one device
[23:53:17] <danieldg> but no-cloning theorem prevents that
[23:53:27] <cvmn> any proof that a circuit cannot implement an oracle?
[23:53:34] <danieldg> so... I think you can't use that
[23:53:39] <cvmn> or, what i it called?
[23:53:43] <cvmn> incompleteness theorem?
[23:54:40] <danieldg> cvmn: any circuit can be emulatted by any turing machine, and so isn't an oracle
[23:55:02] <yawkat> iirc there are schemes that are secure in ROM but can be easily broken outside of ROM.
[23:55:30] <cvmn> danieldg: because of the machine being finite in size?
[23:55:32] <yawkat> https://arxiv.org/pdf/cs/0010019.pdf apparently
[23:56:03] <danieldg> cvmn: that's not an important part of the proof, no
[23:56:23] <danieldg> but it is a reasonable assumption to make
[23:56:27] *** Joins: lucie22 (~lucie22@host-109-88-209-116.dynamic.voo.be)
[23:56:43] <danieldg> if your hash function requires an infinite-size machine I'm not sure who is going to use it
[23:58:07] <cvmn> why does emulation by a turing machine imply that it cannot be an oracle?
[23:58:25] <cvmn> or, what's the important part of the proof?
[23:59:40] <yawkat> danieldg: re the qubits, i think you could entangle some set of qubits, distribute them to users, and then collapse it into some base depending on hash input, at each of the user sites
