[01:34:03] *** Joins: Albertico[m] (~albertico@2001:470:69fc:105::1:3a89)
[09:14:18] *** Joins: sagax (~sagax_nb@user/sagax)
[12:30:09] *** Quits: AndyMaleh[m] (~andymaleh@2001:470:69fc:105::1:1a78) (Quit: You have been kicked for being idle)
[12:58:09] *** Quits: siasmj (sid6106@id-6106.lymington.irccloud.com) (Ping timeout: 268 seconds)
[12:58:54] *** Quits: fidothe (sid1130@id-1130.uxbridge.irccloud.com) (Ping timeout: 250 seconds)
[13:01:44] *** Joins: fidothe (sid1130@uxbridge.irccloud.com)
[13:12:21] *** Joins: siasmj (sid6106@id-6106.lymington.irccloud.com)
[14:03:46] *** Quits: sagax (~sagax_nb@user/sagax) (Excess Flood)
[14:30:29] *** Joins: sagax (~sagax_nb@user/sagax)
[16:22:31] <MateuszFryc[m]> headius:  any idea whether my mail with hs_err file from 16. Nov reached hot-spot-compiler group ? I still have no feedback from hot-spot group as well as I can't see in JBS my submission. You said you are the member of the group which is able to submit bugs directly. I am just wondering if I just need to wait or my submission vaporized somwhere ;)
[16:24:13] <edipofederle[m]> <enebo[m]> "edipo.federle: I have not seen..." <- well, me neither, but no idea what is the reason. 
[19:29:30] <headius> Good morning!
[19:29:54] <headius> Mateusz Fryc: I will check for your email today and if there's no responses or it didn't post I'll file a bug
[19:30:40] <MateuszFryc[m]> that would be lovely if someone competent could push it forward ;)
[19:33:59] <MateuszFryc[m]> I have came across at this issue today twice, I added some logging to show how compiling events look like
[19:34:00] <MateuszFryc[m]> https://gist.github.com/mateuszef/f11a660e85689e56a985f35213ff5aec
[19:34:36] <headius> There's a JVM flag that will let you disable compilation for a specific method, I think, if a workaround would be helpful right now
[19:36:20] <MateuszFryc[m]> Yes, I know eventually I will use that, but I want to observe it a little bit more now
[19:36:28] <headius> Ok cool
[19:37:02] <MateuszFryc[m]> it looks as if there are OSR compilation on other than 408 byte, then it works well, when compiling occurs at 408th byte it crashes.
[19:38:00] <MateuszFryc[m]> Server is being restarted as I use god gem as a watchdog, though currently running tasks are interrupted abruptly...
[19:38:15] <MateuszFryc[m]> not sure what more I could do to help solve this puzzle ;]
[19:47:37] <MateuszFryc[m]> Would it be possible to increase probability of OSR compilation at 408 byte  of this method ?
[19:47:41] <MateuszFryc[m]> So I would have to reverse engineer somehow bytecode to java source, and create jruby source code with magic particular magic comments, probably?
[19:47:42] <MateuszFryc[m]> As I still didn't manage to create simple reproducible snippet.
[19:48:03] <MateuszFryc[m]> here is a bytecode generated from method at compilation of which jvm crashes 
[19:48:04] <MateuszFryc[m]> https://gist.github.com/mateuszef/555ebefda374c4bd3be015bd8e20ca7a
[19:48:15] <MateuszFryc[m]> I don't have sources, so I glanced at this one
[19:48:15] <MateuszFryc[m]> https://www.tabnine.com/web/assistant/code/rs/5c667a731095a50001c7a676#L789
[19:48:26] <MateuszFryc[m]> I dont have experienec with converting bytecode back to sourcecode, so I am not sure where exactly this method we could be at (being at 408 byteceode), probably some mehtods are also inlined.
[19:48:33] <MateuszFryc[m]> s/I dont have experienec with converting bytecode back to sourcecode, so I am not sure where exactly this method we could be at (being at 408 byteceode), probably some mehtods are also inlined./I dont have experience with converting bytecode back to java sourcecode, so I am not sure where exactly this method we could be at (being at 408 byte of bytecode), probably some mehtods are also inlined./
[19:48:39] <MateuszFryc[m]> Not even sure if this is a right direction ..
[19:48:39] <MateuszFryc[m]> s/live/leave/
[19:48:39] <MateuszFryc[m]> or better to live rest to jvm engineers ;)
[19:48:51] <enebo[m]> public boolean parser_magic_comment(org.jruby.util.ByteList magicLine);
[19:48:56] <enebo[m]> This method I think is years old so it makes me think this is some regression on the JVM itself.
[19:50:19] <enebo[m]> Not sure if it is an option to try and use an older release of Java but that could be a workaround (it would take effort as well to pick the right version since we don't know why this is happening)
[19:50:26] <MateuszFryc[m]> hmm, this is byte code which my IDE (Eclipse) generated for 9.3.1.0 jar
[19:52:00] <MateuszFryc[m]> s/generated/showed/
[19:52:10] <enebo[m]> If your snippet is the method which is dying then it is very common code for processing top-lines of Ruby source files for things like '# encoding: utf-8'
[19:52:59] <enebo[m]> I also assume this tends to happen pretty quickly?
[19:53:49] <enebo[m]> I would expect the JVM to optimize parsing-related code prety shortly after startup
[19:54:52] <MateuszFryc[m]> well, I haven't noticed any particular happen apart from the one that it always fails at compilation of this particular method with OSR_BCI = 408. IT happens ocassibially.
[19:54:53] <MateuszFryc[m]> s/ocassibially/ocassionally/
[19:55:59] <MateuszFryc[m]> s/well, I haven't noticed any particular happen apart from the one that it always fails at compilation of this particular method with OSR_BCI = 408. IT happens ocassibially./well, I haven't noticed any particular happen apart from the one that it always fails at compilation of this particular method with OSR_BCI = 408. IT happens ocassionally. i.e 7 times so far (during last week)/
[19:56:18] <enebo[m]> but when your process is first starting or will it just happen later?  (the parser runs for evals so it is possible this does not happen immediately)
[19:56:21] <MateuszFryc[m]> either at the very begnning of working or after several days of working ;)
[19:56:30] <enebo[m]> interesting.
[19:57:24] <enebo[m]> Not actionable per se but I hoped at some level the JVM would be done with the parser-related code quickly since it mostly occurs at startup time.
[19:58:36] <MateuszFryc[m]> https://gist.github.com/mateuszef/5837c5098884d4505410945a35fc87cb
[19:58:54] <MateuszFryc[m]> so these are tmes when jvm crashed and generated hs_err with this exact error
[19:59:08] <MateuszFryc[m]> sometimes it works 2 days, sometimes it runs 20 minutes and crashes
[20:00:07] <MateuszFryc[m]> I had a hope that if it doesn't crash then I am good till I restart it manually, but id occurred I was wrong, probably because of deoptimization process..?
[20:00:12] <edipofederle[m]> enebo:  maybe you can take a look at the https://github.com/jruby/jruby/pull/6927 ? all tests regarding slice with ArithmeticSequence now pass, but not sure how fix another CI issues
[20:00:53] <MateuszFryc[m]> s/id/it/
[20:01:55] <edipofederle[m]> I will squash the commits, btw 
[20:02:07] <enebo[m]> Mateusz Fryc: yeah that could be.  That method is really large by Java standards as well so any speculative opts probably will cause some deoptimization
[20:04:01] <enebo[m]> edipo.federle: I will check but it feels like there is some existing method for doing what aryMakePartial does
[20:05:17] <edipofederle[m]> enebo[m]: I can check it, 
[20:05:17] <enebo[m]> edipo.federle: look at RubyArray.subseq
[20:05:43] <enebo[m]> edipo.federle: otherwise it looks like you did a faithful port of rb_ary_subseq_step
[20:06:03] <edipofederle[m]> yeap :D it ideally need some refactoring, I guess :)
[20:06:09] <enebo[m]> So just change for subseq and I guess squash and I will merge it
[20:07:13] <edipofederle[m]> cool, I will check it today
[20:07:13] <enebo[m]> edipo.federle: probably not... It looks fine
[20:11:43] <enebo[m]> edipo.federle: I just noticed you return null in two places which would return nil out of the Ruby method
[20:12:01] <enebo[m]> Likely those returns are nil but null will cause problems
[20:12:17] <edipofederle[m]> True, 
[20:12:17] <enebo[m]> I put it into a review on the PR
[20:12:37] <edipofederle[m]> shosuld be a RubyNil ?
[20:12:57] <edipofederle[m]> s/shosuld/should/
[20:13:46] <enebo[m]> context.nil you can use
[20:14:28] <enebo[m]> Actually this is a good time to bring this up
[20:14:54] <edipofederle[m]> Btw, there is a missing test from "Array#slice raises a RangeError when the start index is out of range of Fixnum FAILED"  (https://github.com/jruby/jruby/blob/master/spec/ruby/core/array/shared/slice.rb#L499) 
[20:15:02] <enebo[m]> you call getRuby().getCurrentContext() but at the place you call these new methods you have ThreadContext available
[20:15:32] <edipofederle[m]> but checking on RubyNumeric. java, looks like it is implemented .. not sure why is failing. . 
[20:28:39] <enebo[m]> edipo.federle: sorry ... this may sound weird but suddenly we had 13 turkeys outside our house
[20:28:41] <enebo[m]> we live in the city so it is a strange event
[20:31:49] <enebo[m]> edipo.federle: you do not need to solve the ThreadContext thing.  I will change it after I land.  I notice that aref does not have context as a param and I want to look into it (it is complicated enough I will not ask you to do it)
[20:33:04] <enebo[m]> The general thing about ThreadContext is usually all our methods get it passed in so we do not need to try and get it from Runtime.  
[20:46:55] <headius> enebo: I will be reviewing a backlog of issues in JNR and 9.3/2 today
[20:46:56] <enebo[m]> headius: yeah we may want to detarget some of the items still open for 9.3.2 also
[20:46:56] <headius> probably... I have been trying to be better about punting versus detargeting
[20:53:49] <headius> debug gem has been updated with JRuby logic to skip iseq and continuation stuff
[20:54:11] <headius> slowly knocking down these last few gems
[20:54:29] <headius> if we can get io/wait updated for JRuby then most of the net/* stuff can go to gems too
[21:23:44] <headius> enebo: this will take more investigation than we want for 9.3.2, probably, but should not be delayed too long: https://github.com/jruby/jruby/issues/6935
[21:23:57] <headius> I marked for 9.3.3. and pinged byteit101 to have a first look
[21:26:03] <headius> this one is odd too: https://github.com/jruby/jruby/issues/6924
[21:27:23] <headius> this will fix unsigned jffi lib which may bring more FFI behavior back on M1: https://github.com/jnr/jffi/pull/116
[21:27:50] <headius> I'm going to spin JNR releases based on that so we can see how it feels on master... clearly not doing a release during Thanksgiving week so it will bake for a bit
[21:32:07] <byteit101[m]> headius: responded
[21:32:45] <byteit101[m]> It's a bug/limitation with the current super verification algo in IR that enebo wrote
[21:32:54] <headius> aha
[22:27:28] <enebo[m]> I added a comment.  I am not sure if we should try and fix this issue
[22:28:19] <headius> I see the tricky part of this now
[22:28:54] <headius> so you think we should punt because it would not be valid in Java to do two super calls (which is what is getting kicked out) so we are within our rights to reject such forms in Ruby
[22:29:23] <enebo[m]> We can do flow analysis and verify super is not called more than once
[22:29:23] <headius> it is a regression of behavior though, yes?
[22:29:23] <headius> a regression to support newer better functionality but a regression nonetheless
[22:29:23] <enebo[m]> but an if stmt in Ruby can be anything
[22:29:35] <headius> oh I see we are rejecting it because we see two supers
[22:29:41] <headius> not JVM rejecting it
[22:29:44] <enebo[m]> So I am wondering how likely it will be something which is not depending on the ctor being done enough to have self
[22:29:54] <enebo[m]> yeah we intentionally detect this
[22:30:01] <byteit101[m]> enebo:
[22:30:01] <byteit101[m]> > if test since it cannot use self.
[22:30:01] <byteit101[m]> it can use self, but only the ruby half of self, not the java half of self
[22:30:30] <enebo[m]> byteit101: yeah but this is quite strange thing to do at this point in a Ruby object which is underpinned by Java
[22:31:00] <enebo[m]> Perhaps looking at in-params to setup arguments to super
[22:39:08] <byteit101[m]> We need to split the initialize, and as long as java can have the two halfs, in theory we could do anything, but the simple case of 1 super is trivial
[22:39:08] <enebo[m]> but people can work around that
[22:39:12] <enebo[m]> yeah the mechanics of splitting is another complication too
[22:39:21] <enebo[m]> Obviously we can support that too
[22:39:22] <enebo[m]> I just think bang for buck we have the right impl and this can largely be worked-around
[22:39:29] <enebo[m]> Perhaps a better error message (and possibly link to wiki?)
[22:39:29] <byteit101[m]> headius: > oh I see we are rejecting it because we see two supers
[22:39:29] <byteit101[m]> >  not JVM rejecting it
[22:39:29] <byteit101[m]> correct
[22:39:49] <byteit101[m]> > Perhaps looking at in-params to setup arguments to super
[22:39:49] <byteit101[m]> we used to do that, but that prohibits new arguments, which is why I had to change it for the concrete stuff
[22:39:49] <enebo[m]> logically we can support anything which only tries to invoke super a single time (and we can prove that statically) but that also mean we need to have before/after codes for each super and generate something a lot more complicated
[22:39:57] <byteit101[m]> args = if ... end
[22:39:57] <enebo[m]> byteit101: yeah
[22:39:57] <byteit101[m]> super *args #something like that
[22:40:04] <enebo[m]> With infnite resources this might be a fun project for someone but it is not difficult to work around as a limitation so I think maybe we improve error message with a wiki link?
[22:40:10] <byteit101[m]> I think I was going to improve the error messages via code review, but I think that was a sudden "lets just merge it as-is" and that never happened
[22:40:10] <enebo[m]> if (foo); if (bar); super; else; super; else; super; end
[22:40:12] <enebo[m]> heh I am missing an end but it is a deep hole
[22:40:12] <byteit101[m]> where is project loom when you need it?
[22:40:13] <enebo[m]> we do have an algorithm for this sort of thing but you have to generate a CFG to perform it
[22:40:14] <enebo[m]> We only do this on the startup instrs
[22:40:17] <enebo[m]> which again is doable to switch to full but another complcication
[22:41:50] <enebo[m]> byteit101: if you can add a better error message as PR that would be great.
[22:41:51] <byteit101[m]> I can, but I may take some time as I'm utterly swamped until next week
[22:41:52] <enebo[m]> byteit101: this is not a big deal timewise as we probably found the lone user who did this besides possibly you
[22:42:24] <enebo[m]> doing multiple super is pretty rare in Ruby itself
[22:44:21] <byteit101[m]> I've been finding lots of exciting bugs everywhere I look recently. Just the past 48 hours I've found a Java compiler bug with normal Java code and a code-smuggling vulnerability by accident in a product I shall not name until they get back to me
[22:45:01] <byteit101[m]> but I'll put this on my to-do list next week
[22:48:24] <enebo[m]> :)
[23:31:48] <headius> jnr-* released and all branches updated
