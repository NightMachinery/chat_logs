[00:01:04] <MarcoFe> hi everyone
[00:04:14] <Alipha> MarcoFe: hi
[00:05:48] *** Quits: son0p (~ff@2800:484:1d81:b700:d40b:900:b387:320) (Ping timeout: 268 seconds)
[00:24:12] *** Joins: joilerv (~joilerv@host86-191-93-41.range86-191.btcentralplus.com)
[00:25:35] *** Quits: Hash (~Hash@hashsecurity.org) (K-Lined)
[00:30:42] *** Joins: ivii (~ivan@user/ivii)
[00:33:41] *** Quits: zer0bitz (~zer0bitz@2001:2003:f74d:b800:50b5:b57f:7251:ce23) (Ping timeout: 245 seconds)
[00:34:06] *** Quits: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net) (Ping timeout: 245 seconds)
[00:43:36] *** Quits: machinedgod (~machinedg@24.105.81.50) (Ping timeout: 250 seconds)
[00:55:46] *** Quits: Guyver2 (~Guyver@guyver2.xs4all.nl) (Quit: Going offline, see ya! (www.adiirc.com))
[00:56:07] *** Quits: MarcoFe (~marcofe@93-36-164-204.ip61.fastwebnet.it) (Quit: Konversation terminated!)
[01:03:33] *** Joins: LordOfLive (uid538075@id-538075.tinside.irccloud.com)
[01:03:39] <LordOfLive> Yoo
[01:04:15] *** Joins: son0p (~ff@2800:484:1d81:b700:d40b:900:b387:320)
[01:05:27] *** Quits: ua_ (~ua@public-gprs218405.centertel.pl) (Ping timeout: 250 seconds)
[01:05:58] *** Joins: ua__ (~ua@public-gprs226401.centertel.pl)
[01:06:46] *** Quits: sdfgsdfg (~dfghsfgs@user/sdfgsdfg) (Quit: ayo yoyo ayo yoyo hololo, hololo.)
[01:14:58] *** Joins: sdfgsdfg (~dfghsfgs@user/sdfgsdfg)
[01:17:38] *** Quits: joilerv (~joilerv@host86-191-93-41.range86-191.btcentralplus.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[01:18:03] *** Quits: sdfgsdfg (~dfghsfgs@user/sdfgsdfg) (Client Quit)
[01:20:11] *** Quits: Narrat (~omnius@p200300df5f4d4df406ea56fffe2e7cdc.dip0.t-ipconnect.de) (Ping timeout: 250 seconds)
[01:36:29] *** Joins: sdfgsdfg (~dfghsfgs@user/sdfgsdfg)
[01:36:55] *** Joins: citizen_stig (~citizen_s@2001:982:9f64:1:a4e3:ad4b:910b:9e90)
[01:38:24] *** Joins: Narrat (~omnius@p200300df5f0818b406ea56fffe2e7cdc.dip0.t-ipconnect.de)
[01:40:12] *** Joins: machinedgod (~machinedg@24.105.81.50)
[01:42:33] *** Quits: neiluj (~neiluj@2a01:e0a:1f2:d960:fd06:1003:8832:dad7) (Quit: WeeChat 3.1)
[01:45:02] *** Quits: Tangent-Man (~Tang3nt-M@cpc145602-basl14-2-0-cust33.20-1.cable.virginm.net) (Quit: Leaving)
[01:51:32] *** Quits: citizen_stig (~citizen_s@2001:982:9f64:1:a4e3:ad4b:910b:9e90) (Quit: Textual IRC Client: www.textualapp.com)
[01:51:49] *** Quits: cwebber (~user@user/cwebber) (Ping timeout: 250 seconds)
[01:52:26] *** Joins: cvmn (~caveman@gateway/tor-sasl/caveman)
[02:02:01] *** Quits: sdfgsdfg (~dfghsfgs@user/sdfgsdfg) (Quit: ayo yoyo ayo yoyo hololo, hololo.)
[02:20:52] *** Joins: rmm (~rmm@user/rmm)
[02:25:29] *** Joins: gabriel1_ (~gabriel1@mail.virebent.art)
[02:25:39] *** Quits: gabriel1 (~gabriel1@user/gabriel1) (Read error: Connection reset by peer)
[02:29:10] *** Joins: karstensrage (~karstensr@nibbler.warped.com)
[02:29:24] <cvmn> is there a way to cryptographically define transactions, such that it automatically summarises, without losing ability to prove the correctness of the thing that's transacted?
[02:29:27] <cvmn> e.g. with cryptocurrencies, in order to prove that my coin is legit, i have to show the entire path it travelled all the way back to the genesis block.  this will make my coin's tail grow too long eventually, and seems excessive if my coin moved back and forth a lot between a few set of wallets.
[02:29:27] *** Quits: karstensrage (~karstensr@nibbler.warped.com) (Changing host)
[02:29:27] *** Joins: karstensrage (~karstensr@user/karstensrage)
[02:29:28] <cvmn> the lightening protocol tries to, sort of, solve this by opening a summarisation channel between parties.
[02:29:30] <cvmn> but it would be nice if we could do the summarisation in a more on-line manner, without needing to intend in advance to start such summarisation channel.
[02:29:32] <cvmn> is there a way to let things self-summarise?  without losing coin's legitimacy proof?
[02:31:25] <iz> all of that stuff is to prevent double spending
[02:33:47] *** Quits: kilitary (~kilitary@188.242.187.4) (Quit: entering irc ...)
[02:37:03] *** Quits: Narrat (~omnius@p200300df5f0818b406ea56fffe2e7cdc.dip0.t-ipconnect.de) (Quit: They say a little knowledge is a dangerous thing, but it's not one half so bad as a lot of ignorance.)
[02:38:02] *** Quits: Klotz (~Klotzoman@gateway/tor-sasl/klotz) (Quit: Klotz)
[02:40:30] *** Joins: igemnace (~ian@user/igemnace)
[02:51:41] *** Quits: trebuh (~trebuh@2001:41d0:a:15c7::1) (Remote host closed the connection)
[02:52:15] *** Joins: trebuh (~trebuh@2001:41d0:a:15c7::1)
[02:59:53] *** Quits: dude12312414 (~test@gateway/tor-sasl/dude12312414) (Quit: THE RAM IS TOO DAMN HIGH)
[03:15:29] *** Quits: teal_ (~teal@2600:1700:80:22d0::f) (Quit: Leaving)
[03:18:05] *** Quits: gabriel1_ (~gabriel1@mail.virebent.art) (Remote host closed the connection)
[03:21:59] *** Joins: sdfgsdfg (~dfghsfgs@user/sdfgsdfg)
[03:25:07] *** Joins: TonyStone31 (~TonyStone@2603-7080-8607-c36a-cdff-5348-04ff-b4e2.res6.spectrum.com)
[03:25:08] *** Quits: TonyStone (~TonyStone@cpe-74-76-51-197.nycap.res.rr.com) (Quit: Leaving)
[03:25:11] *** Quits: TonyStone31 (~TonyStone@2603-7080-8607-c36a-cdff-5348-04ff-b4e2.res6.spectrum.com) (Remote host closed the connection)
[03:25:37] *** Joins: TonyStone (~TonyStone@2603-7080-8607-c36a-cdff-5348-04ff-b4e2.res6.spectrum.com)
[03:30:21] *** Quits: poopster (poopster@user/poopster) (Ping timeout: 256 seconds)
[03:33:54] *** Quits: Soni (~quassel@autistic.space) (Ping timeout: 250 seconds)
[03:36:04] *** Joins: poopster (poopster@shell.xshellz.com)
[03:38:03] *** Joins: cwebber (~user@user/cwebber)
[03:44:33] *** Quits: ivii (~ivan@user/ivii) (Quit: Konversation terminated!)
[03:48:23] *** Quits: sdfgsdfg (~dfghsfgs@user/sdfgsdfg) (Quit: ayo yoyo ayo yoyo hololo, hololo.)
[03:52:50] *** Quits: poopster (poopster@shell.xshellz.com) (Ping timeout: 260 seconds)
[03:55:30] *** Quits: machinedgod (~machinedg@24.105.81.50) (Ping timeout: 256 seconds)
[04:03:20] *** Joins: Soni (~quassel@autistic.space)
[04:10:36] *** Quits: cvmn (~caveman@gateway/tor-sasl/caveman) (Ping timeout: 276 seconds)
[04:10:37] *** Quits: Wulf (~Wulf@user/wulf) (Ping timeout: 268 seconds)
[04:11:48] *** Joins: Wulf (~Wulf@user/wulf)
[04:12:14] <Alipha> cvmn: if you record the sender account's new balance in the block when the sender makes a transaction, then you only have to go back in history to the most recent transaction the sender made?
[04:17:03] <maroon> please record me as having a million!
[04:17:48] *** Joins: SlimmyJimmy (blank@user/slimmyjimmy)
[04:20:07] <LordOfLive> What is a test net
[04:24:31] <maroon> what context is it mentioned in?
[04:32:02] *** Quits: crabby (~crabby@2600:8801:f200:27:50ca:8f6d:76f4:d58f) (Ping timeout: 252 seconds)
[04:36:54] *** Quits: Malvolio (~Malvolio@user/malvolio) ()
[04:40:10] *** Joins: sdfgsdfg (~dfghsfgs@user/sdfgsdfg)
[04:40:33] *** Joins: Malvolio (~Malvolio@user/malvolio)
[04:44:37] *** Quits: sdfgsdfg (~dfghsfgs@user/sdfgsdfg) (Ping timeout: 240 seconds)
[04:45:01] *** Quits: Seirdy (~Seirdy@sourcehut/user/seirdy) (Quit: exiting 3.4)
[04:50:52] *** Joins: machinedgod (~machinedg@24.105.81.50)
[05:27:39] *** Quits: machinedgod (~machinedg@24.105.81.50) (Ping timeout: 256 seconds)
[05:36:37] *** Quits: PJBoy (~PJBoy@user/pjboy) (Ping timeout: 240 seconds)
[05:43:41] *** Joins: crabby (~crabby@2600:8801:f200:27:50ca:8f6d:76f4:d58f)
[05:51:21] *** Quits: _mikey (~mikey@user/mikey/x-4335048) (Ping timeout: 276 seconds)
[05:59:28] *** Quits: chasmo77 (~chas77@c-71-193-246-4.hsd1.or.comcast.net) (Quit: It's just that easy)
[06:33:47] *** Joins: dude12312414 (~test@gateway/tor-sasl/dude12312414)
[06:47:12] *** Quits: dude12312414 (~test@gateway/tor-sasl/dude12312414) (Quit: THE RAM IS TOO DAMN HIGH)
[06:54:37] *** Quits: vj-- (~vj@bras-base-toroon3514w-grc-83-174-93-56-58.dsl.bell.ca) (Ping timeout: 240 seconds)
[07:03:03] *** Joins: lainon (~lainon@2601:7c0:c500:4d20::3385)
[07:07:42] *** Quits: lainon (~lainon@2601:7c0:c500:4d20::3385) (Quit: lainon)
[07:17:42] *** Quits: mad_enz (~mad_enz@lnsm3-torontoxn-142-116-106-108.internet.virginmobile.ca) (Ping timeout: 260 seconds)
[07:24:36] <sshine> I see that Rust 'rand' has a CryptoRng trait: https://docs.rs/rand/latest/rand/trait.CryptoRng.html -- but are there any recommended CSPRNGs in Rust?
[07:26:57] <sshine> https://crates.io/search?q=csprng&sort=downloads
[07:30:01] *** Joins: mad_enz (~mad_enz@lnsm1-torontoxn-142-120-17-169.internet.virginmobile.ca)
[07:41:24] *** Joins: sdfgsdfg (~dfghsfgs@user/sdfgsdfg)
[08:11:50] <caveman> Alipha: yes, but then, how will the miner/block-maker proves that the balance that he put in the block is true?  
[08:14:10] <Alipha> caveman: I suppose you should also store the recipient's new balance. Then they look can through the history until the last time that sender sent or received coin to see their previous balance. Same for the recipient
[08:17:16] <caveman> yes.  then in order to prove the correctness of that block's content, one will need to show all blocks in the middle that link the genesis block to that final block.  right?  or am i missing something?
[08:19:46] *** Quits: crabby (~crabby@2600:8801:f200:27:50ca:8f6d:76f4:d58f) (Ping timeout: 260 seconds)
[08:23:35] <Alipha> caveman: if a block is older than say, 6 blocks--that is, a block has had 6 confirmations--then you can assume that the block is correct by the nature of how blockchains work
[08:24:37] *** Joins: BOKALDO (~BOKALDO@user/bokaldo)
[08:24:54] *** Quits: sdfgsdfg (~dfghsfgs@user/sdfgsdfg) (Quit: ayo yoyo ayo yoyo hololo, hololo.)
[08:25:25] <caveman> yes.  that works for old installations that have been following the progress since the genesis block.  but what about new installations?  they will suddenly see a ledger with 6 blocks history, that doesn't link to the genesis block.  does this matter?  
[08:32:25] *** Joins: crabby (~crabby@2600:8801:f200:27:34a9:6a83:f5ea:8688)
[08:34:18] <Alipha> caveman: so the purpose of this is to allow new miners to join the network without downloading the whole history?
[08:35:50] <caveman> maybe, but i was mainly thinking about allowing to spend money without needing to download full history.  e.g. what happens if a miner wanted to spend his rewards to someone?  will the miner need to supply the proof of his money, by sending him all blocks since genesis?
[08:36:23] <caveman> all blocks since genesis, is basically 25 terabytes per day (if cryptocurrency is used instead of visa, internationally)
[08:39:43] <Alipha> Wouldn't the miner just send his money and the other miners, who already have the entire history, would verify his balance and reject the transaction if he didn't have enough?
[08:41:05] <Alipha> ... You could have the miners periodically produce a summary block of everyone's balances. I'm not sure how feasible that would be with how many different accounts there are.
[08:41:22] <TimMc> Haha yeah, back when I still had some bitcoin (this was like 10 years ago now? no idea) I eventually had to switch to a "light" client because the blockchain was tens of GB and I was running out of space.
[08:41:52] <TimMc> So much for an egalitarian network where all nodes could participate and verify.
[08:42:34] <TimMc> (I think they still help with flood-fill, but maybe are now just hardcoded with a more recent block?)
[08:42:56] <TimMc> (which I guess is actually fine, it's not like you distrust the software)
[08:44:02] <Alipha> I haven't fully worked it out in my head, but I feel like you should be able to organize everyone's account and balance into a merkle tree, and then posting a transaction would involve including the path in the merkle tree to your account as proof.
[08:49:24] <caveman> Alipha: i thought of something similar:  let the ledger only contain latest wallet balances (delete them if their balance is zero), alongside the hash of the last block it is in.  then, if the owner wants to send that money to another person, he will be responsible to supply the proofs to the other person, in whicever way it works (if the receiver doesn't know anything, then the proof will need to
[08:49:26] <caveman> start from the genesis block)
[08:50:30] <caveman> but then, i started wondering, will that do much in reality?  because people will still need to download 25 terabytes per day at least once anyway.
[08:51:59] <caveman> if cryptocurrency replaced visa, the size of transacitons per day is at least about 25 terabytes.  if someone wants to prove his money that he got recently, to a receiver that didn't shop since last week, then the sender will need to send a week's worth of transactions to the receiver.  that's 25*7 = 175 terabytes.
[08:54:02] <Disconsented> sshine> https://rust-random.github.io/book/guide-rngs.html
[08:54:20] <Disconsented> https://rust-random.github.io/book/guide-rngs.html#cryptographically-secure-pseudo-random-number-generators-csprngs rather
[08:54:55] <Alipha> caveman: organize the transactions (which include sender's and recipient's new balances) in a block into a merkle tree, and then keep all blocks in a merkle tree. Then you only have to share the transaction and the merkle tree path to that transaction
[08:56:46] <caveman> how will confirmations accumulate?  or will there be 6 confirmation per tree branch?  
[08:56:49] <Disconsented> Well rather generally use ChaCha20
[08:58:53] <Alipha> caveman: eh, there's still a linear history. A merkle tree just concisely provides proof that an item is in the linear list of items.
[08:59:11] <Alipha> Read about merkle trees :-)
[08:59:43] <caveman> cool.  thanks!
[09:02:37] *** Joins: _mikey (~mikey@user/mikey/x-4335048)
[09:20:59] <Alipha> caveman: the issue though--which I haven't worked out--is that the merkle tree changes over time. Looking a these diagrams, https://www.quora.com/How-can-we-generate-a-Merkle-Tree-with-an-odd-number-of-leaves-or-an-odd-number-of-parent-nodes-say-5-leaves-as-an-example Now, the subtree 1234 and below won't change because that subtree is complete. But if I make a transaction in block 5 and I record my position
[09:21:00] <Alipha> in the tree (record the hash of 5 and the hash of 12345), the issue is, that 12345 hash is going to be irrelevant as soon as there's a block 6. So, I have to keep track of how the merkle tree changes, or talk to someone else who knows the full history in order to  determine what the new hashes are above me in the tree are
[09:44:56] *** Quits: crabby (~crabby@2600:8801:f200:27:34a9:6a83:f5ea:8688) (Quit: Leaving)
[09:57:42] *** Quits: drathir_tor (~drathir@wireguard/tunneler/drathir) (Ping timeout: 276 seconds)
[10:00:10] *** Quits: kish` (~aqua@user/aqua) (Remote host closed the connection)
[10:05:57] *** Joins: kish` (~aqua@user/aqua)
[10:08:59] *** Joins: drathir_tor (~drathir@wireguard/tunneler/drathir)
[10:11:05] *** Joins: Seirdy (~Seirdy@sourcehut/user/seirdy)
[10:16:32] *** Joins: hqdruxn08 (~hqdruxn08@user/hqdruxn08)
[10:18:46] *** Quits: hqdruxn08_ (~hqdruxn08@user/hqdruxn08) (Ping timeout: 260 seconds)
[10:25:26] *** Quits: kish` (~aqua@user/aqua) (Remote host closed the connection)
[10:30:07] *** Joins: kish` (~aqua@user/aqua)
[10:58:23] *** Joins: sdfgsdfg (~dfghsfgs@user/sdfgsdfg)
[10:59:45] *** Joins: ert (~ert@2001:4b99:1:1:216:3eff:fee5:446f)
[11:30:38] *** Joins: MajorBiscuit (~MajorBisc@c-001-028-049.client.tudelft.eduvpn.nl)
[11:34:59] *** Joins: Haohmaru (~Haohmaru@195.24.53.110)
[11:42:16] *** Joins: ivii (~ivan@user/ivii)
[11:46:04] *** Joins: shayr_ (shayr@ip62.ip-91-134-189.eu)
[11:49:01] *** Quits: shayr (shayr@ip62.ip-91-134-189.eu) (Ping timeout: 240 seconds)
[11:52:10] <caveman> is the use of merkle tree to speed up updating and verifying?  e.g. to update a tree, i update log2(n) many hashes instead of n.  similarly, to verify if a particular hash is in a tree, i do log2(n) hashes instead of n.
[12:04:18] *** Quits: jstoker (jstoker@user/jstoker) (Remote host closed the connection)
[12:04:51] *** Joins: thomas25- (thomas25@brought.to.you.by.bnc4free.com)
[12:05:28] *** Quits: kristjansson (sid126207@id-126207.tinside.irccloud.com) (Ping timeout: 268 seconds)
[12:05:44] *** Joins: jstoker (~jstoker@user/jstoker)
[12:05:59] *** Joins: dusk (~quassel@suki.ds7s.nl)
[12:06:04] *** Quits: HumanG33k (~HumanG33k@2a01:e0a:95:5d90:215:c5ff:fe68:fb04) (Ping timeout: 268 seconds)
[12:06:04] *** Quits: Starfoxxes (~Starfoxxe@2a02:8070:5390:d00:12bf:48ff:feb8:38c8) (Ping timeout: 268 seconds)
[12:06:04] *** Quits: thomas25 (thomas25@brought.to.you.by.bnc4free.com) (Ping timeout: 268 seconds)
[12:06:04] *** Quits: neildaemond (~neildaemo@ipv6two.tilde.club) (Ping timeout: 268 seconds)
[12:06:04] *** Quits: dusk_ (~quassel@suki.ds7s.nl) (Ping timeout: 268 seconds)
[12:06:54] *** Quits: caveman (~caveman@gateway/tor-sasl/caveman) (Remote host closed the connection)
[12:07:33] *** Joins: caveman (~caveman@gateway/tor-sasl/caveman)
[12:07:39] *** Joins: kristjansson (sid126207@id-126207.tinside.irccloud.com)
[12:07:42] *** Joins: neildaemond (~neildaemo@ipv6two.tilde.club)
[12:07:43] *** Joins: HumanG33k (~HumanG33k@2a01:e0a:95:5d90:215:c5ff:fe68:fb04)
[12:09:34] *** Quits: BGL (twenty@75-149-171-58-Washington.hfc.comcastbusiness.net) (Ping timeout: 250 seconds)
[12:11:38] *** Quits: taeaad_ (~taeaad@user/taeaad) (Quit: ZNC 1.7.5+deb4 - https://znc.in)
[12:12:52] *** Joins: taeaad (~taeaad@user/taeaad)
[12:13:12] *** Joins: Guyver2 (~Guyver@guyver2.xs4all.nl)
[12:18:16] *** Joins: machinedgod (~machinedg@24.105.81.50)
[12:18:19] *** Quits: jtgd (~jtgd@user/jtgd) (Quit: WeeChat 3.4)
[12:18:51] <caveman> is there any other feature of merkle trees that i didn't mention above?
[12:20:25] *** Joins: Starfoxxes (~Starfoxxe@2a02:8070:5390:d00:12bf:48ff:feb8:38c8)
[12:21:53] *** Joins: jtgd (~jtgd@user/jtgd)
[12:22:05] *** Joins: andreasbuhr (~quassel@p549db9a5.dip0.t-ipconnect.de)
[12:22:12] *** Quits: andreasbuhr (~quassel@p549db9a5.dip0.t-ipconnect.de) (Remote host closed the connection)
[12:23:05] *** Joins: andreasbuhr (~quassel@p549db9a5.dip0.t-ipconnect.de)
[12:33:13] <int-e> well there's the size of the membership certificate
[12:40:18] *** Quits: karstensrage (~karstensr@user/karstensrage) (Quit: ZNC - http://znc.in)
[12:43:34] *** Joins: karstensrage (~karstensr@nibbler.warped.com)
[12:44:17] *** Joins: chomwitt (~chomwitt@2a02:587:dc03:8900:12c3:7bff:fe6d:d374)
[12:54:08] <caveman> merkle trees have membership certificates?
[12:54:25] <caveman> any real life example of such certificates?
[12:59:24] <int-e> The certificate is simply the hash you claim to be in the tree, plus the adjacent subtree hashes along the path to the root that you have to use as input to get the hash at the root.
[13:06:51] <caveman> interesting.  if i get it right, very useful to reduce proof sizes from O(n) to O(log2 n).  amazing help.  thanks a lot.
[13:06:57] *** Quits: rmm (~rmm@user/rmm) (Ping timeout: 250 seconds)
[13:07:22] *** Joins: rmm (~rmm@user/rmm)
[13:17:18] *** Quits: abraham (~abraham@143.244.185.86) (Read error: Connection reset by peer)
[13:17:20] *** Joins: abraham1 (~abraham@143.244.185.86)
[13:34:53] *** Joins: PJBoy (~PJBoy@user/pjboy)
[14:06:32] *** Quits: gde33 (~gde33@84-106-154-98.cable.dynamic.v4.ziggo.nl) (Ping timeout: 240 seconds)
[14:07:03] *** Joins: gde33 (~gde33@84-106-154-98.cable.dynamic.v4.ziggo.nl)
[14:11:35] *** Joins: arjun (~arjun@user/arjun)
[14:23:22] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 256 seconds)
[14:23:30] *** Joins: Lord_of_Life_ (~Lord@user/lord-of-life/x-2819915)
[14:25:04] *** Joins: DeepDream (~neutrino@user/neutrino)
[14:26:20] *** Lord_of_Life_ is now known as Lord_of_Life
[14:55:47] *** Joins: gabriel1 (~gabriel1@user/gabriel1)
[15:05:38] *** Quits: igemnace (~ian@user/igemnace) (Quit: WeeChat 3.4)
[15:06:58] *** Joins: hlauk (~hlauk@176.33.108.116)
[15:07:57] *** Quits: hlauk (~hlauk@176.33.108.116) (Remote host closed the connection)
[15:09:47] *** Joins: frost (~frost@user/frost)
[15:29:20] *** Quits: BOKALDO (~BOKALDO@user/bokaldo) (Quit: Leaving)
[15:41:54] *** Quits: DeepDream (~neutrino@user/neutrino) ()
[15:44:36] *** Quits: frost (~frost@user/frost) (Quit: Connection closed)
[16:03:05] *** Quits: kish` (~aqua@user/aqua) (Remote host closed the connection)
[16:03:44] *** Joins: kish` (~aqua@user/aqua)
[16:31:24] *** Joins: Centaur (~sys@user/probe)
[16:35:26] *** Malvolio is now known as ProteinSquirrel
[16:36:34] *** Joins: d1cor (~diego@179.63.242.120)
[16:37:30] *** Joins: dez (uid92154@user/dez)
[16:40:24] *** Joins: pergaminho (~pergaminh@user/pergaminho)
[16:44:11] *** Quits: abraham1 (~abraham@143.244.185.86) (Ping timeout: 268 seconds)
[16:45:06] <TimMc> How do I go about getting a cryptography (and general security) review of a protocol and implementation?
[16:45:37] *** Joins: BGL (ninety@75-149-171-58-Washington.hfc.comcastbusiness.net)
[16:45:53] <TimMc> (for a noncommercial, open source project)
[16:47:20] <Deknos> you need at least the following: you need a reference implementation in a wellknown language with testvectors which should produce the correct output and also descriptions and (perhaps uml) sequence diagrams of the protocols, where the happy flow and the error case are shown and the reasoning why you chose each crypto or protocol element
[16:48:20] <Deknos> reasoning can be automated reasoning/proving or based on public wellknown principles or good cryptographic reasoning where you show which choice you made and which advantages and/or issues it could have.
[16:49:00] <MacGyver> Post in on hackernews.
[16:49:03] *** Joins: BOKALDO (~BOKALDO@user/bokaldo)
[16:49:07] <MacGyver> s/in/it/
[16:49:11] <MacGyver> Plenty of "review".
[16:50:19] <Deknos> answer there will be "just use age or betterits rust implementation rage"
[16:50:20] <Deknos> :D
[16:51:16] <MacGyver> Well honestly for the most part I agree with "just use age" but TimMc's been here long enough that if they're asking I assume it's not something they can "just use age" for :P
[16:51:37] <TimMc> Oh, I'm using libsodium for pretty much everything.
[16:51:45] <MacGyver> But yeah, all you'll get from there is memeing.
[16:51:48] <TimMc> I want to make sure I'm using it well and correctly. :>
[16:52:09] <MacGyver> TimMc: What's the project?
[16:52:26] <MacGyver> Is it something you could get random twitter-cryptographers excited about?
[16:52:49] <TimMc> Probably not! I think the crypto side is fairly boring. Uh, I hope it is, at least.
[16:53:33] <TimMc> It's a social journaling protocol -- blogging / Livejournal / Tumblr / Facebook post kind of experience, but with underlying strong privacy.
[16:53:33] <MacGyver> Urgh, the cybercurrency-bros have stolen #boringcrypto
[16:53:38] <TimMc> oh no!
[16:54:00] <TimMc> https://gitlab.com/timmc/cavern is the project although it'snot really ready for review yet.
[16:54:06] <MacGyver> I'm serious -- that used to be something touted around the heartbleed times.
[16:54:10] <MacGyver> "Cryptography must be boring".
[16:54:13] <TimMc> Yeah, I remember!
[16:54:15] <TimMc> boringssl
[16:54:40] <TimMc> and I think there's a boring crypto mailing list that I ran across a djb post on
[16:54:46] *** Quits: byteskeptical (~amnesia@user/byteskeptical) (Quit: Lost terminal)
[16:55:20] <TimMc> I did invent/implement my own crypto for one part of the project, but it's just on the implementation side and isn't a particularly important thing.
[16:55:44] <TimMc> (Post ID encryption, which I've discussed here.)
[17:01:34] <TimMc> Deknos: Yeah, I still need to write up formal specification of how key rotation works, and other security-sensitive aspects of the protocol.
[17:01:40] <TimMc> Especially URL handling, ugh.
[17:02:00] *** Joins: Guest82 (~Guest82@jordanov4.pppoe.optic-com.eu)
[17:02:05] <TimMc> How we ended up in a world where URL handling is fraught, I just don't know.
[17:03:29] <Deknos> key rotation, calculation how big your security margin is, which sidechannel attacks you did consider, what can happen if the API is used wrong
[17:03:49] <Guest82> hello, guys! is there any algorithm, so that I can generate unique hash of some data but limit the hash value to 16 characters, for example?
[17:04:06] *** Quits: MajorBiscuit (~MajorBisc@c-001-028-049.client.tudelft.eduvpn.nl) (Quit: WeeChat 3.4)
[17:04:11] <yawkat> take a normal hash, and truncate it.
[17:04:41] <Guest82> won't this result in collisions down the road?
[17:04:43] <yawkat> but 8 bytes is a bit short for uniqueness. so maybe dont use hex.
[17:04:51] *** Joins: igemnace (~ian@user/igemnace)
[17:04:53] <Deknos> actually there are a few books about crypto protocols like from boyd/matura, which are pretty good if you want to learn protocol analysis
[17:04:56] <yawkat> it will lead to as many collisions as any other approach
[17:05:19] *** Joins: MajorBiscuit (~MajorBisc@c-001-028-049.client.tudelft.eduvpn.nl)
[17:06:17] *** Quits: ProteinSquirrel (~Malvolio@user/malvolio) (Ping timeout: 240 seconds)
[17:07:28] <Guest82> the idea is to generate some unique identifier for rows form a database, so that i can expose the generated hash as reference to the specific row. i have an ID for every specific row, but i don't want to expose this ID. is it better to somehow transform this ID to a hashed value and use it instead of hashing the data from the whole row?
[17:07:37] <MacGyver> Guest82: 16 (hexadecimal) characters is 64 bits, so yes, that will lead to collisions. Your problem should be solved by encoding the output differently, not by truncation.
[17:07:41] <TimMc> Deknos: The gorgeous thing is that all calculation happens asynchronously on the client, so I'm not too worried about side channels. :-D
[17:08:02] <MacGyver> Guest82: Most often used for this is some form of base64 encoding.
[17:09:02] <TimMc> Guest82: I think the usual approach here is to generate an external ID, maybe a v4 UUID.
[17:09:17] <TimMc> and just store that in the rows
[17:09:22] *** Joins: Malvolio (~Malvolio@user/malvolio)
[17:10:12] <Guest82> TimMc: yes, unfortunately the requirement is to use this reference in some other systems, and they accepts IDs with up to 16 characters.
[17:10:24] <MacGyver> Guest82: But even then you're not going to achieve just 16 characters; best you can do for a 128-bit hash is going to be ~22 characters, and then you're still only on a 128-bit hash.
[17:10:24] <TimMc> Well, it doesn't have to be UUID.
[17:10:47] <MacGyver> Guest82: This *cannot* be done.
[17:10:58] <MacGyver> Guest82: Secure, compatible, pick one.
[17:11:15] <MacGyver> (Unless they mean "bytes" where they say "characters")
[17:11:47] <yawkat> 16 characters base64 is 96 bits, which may be barely enough if you also do local collision checking
[17:12:29] <TimMc> Guest82: What's your concern in exposing the internal IDs? Just generic "that's an implementation detail and might change"?
[17:12:48] <TimMc> or do you also want to hide the number or spacing of the IDs?
[17:13:16] *** Quits: ravan_ (~ravan@user/ravan) (Ping timeout: 245 seconds)
[17:13:22] <Guest82> well, the numbers of the IDs are thing that is concerning, because they are incremental.
[17:13:36] <MacGyver> Sounds like you need a form of FPE instead.
[17:13:43] <TimMc> And you don't want to reveal the size of your dataset?
[17:14:01] <TimMc> Or do you want to avoid someone iterating through, scraping the data?
[17:14:02] <Guest82> MacGyver: what's FPE?
[17:14:16] <yawkat> yea a PRP could work here
[17:14:18] <Guest82> TimMc: both.
[17:14:38] <MacGyver> Format-preserving encryption; in this case specifically just a pseudo-random permutation because your "format" is just "all numbers between 0 and whatever still fits."
[17:14:50] <Guest82> I already have some unique random hashes, but they are longer than 16 characters.
[17:14:54] <MacGyver> Then you don't have collision-concerns.
[17:16:15] *** Quits: Malvolio (~Malvolio@user/malvolio) (Ping timeout: 268 seconds)
[17:16:19] <MacGyver> Guest82: Do these need to be ASCII characters?
[17:16:28] <Guest82> MacGyver: could you elaborate more on this? are there any algorithms that can be used?
[17:16:30] <MacGyver> Guest82: Or do you mean "bytes" where you say "characters"?
[17:17:12] <Guest82> MacGyver: i think i will be safer if using just ASCII.
[17:17:13] *** Joins: Malvolio (~Malvolio@user/malvolio)
[17:17:38] <TimMc> If the obfuscated IDs are used externally, we can probably assume 16 byes ASCII.
[17:18:21] <TimMc> Guest82: I've written some code that takes small integer IDs -> encrypted IDs and back again: https://gitlab.com/timmc/cavern/-/blob/b4d2d5f3/spelunk/src/main/kotlin/org/timmc/spelunk/Crypto.kt#L491 -- but no one else has reviewed this code, and I have no particular training in this. Still, it may be of interest.
[17:18:31] <MacGyver> Then the base64-encoded output of a small-block block cipher should suffice.
[17:18:50] <MacGyver> I haven't looked into the lightweight-crypto-space for a while but that's where I'd look.
[17:19:57] <TimMc> "Small-domain" encryption is another keyword to use in your searches.
[17:23:12] *** Malvolio is now known as Guest7522
[17:23:12] *** Quits: Guest7522 (~Malvolio@user/malvolio) (Killed (strontium.libera.chat (Nickname regained by services)))
[17:24:03] <TimMc> If you encrypt your internal IDs and store those along with the data (which is going to be annoying, since it will be a two-transaction process and you'll be missing an external ID in the DB record in between) then make sure you also store a version number on the front of each ID.
[17:24:26] <TimMc> If you change your algorithm or internal IDs or anything else, you'll need to bump the version number to prevent collisions.
[17:25:07] <TimMc> (hmm, I'm wrong about two transactions, ignore that part)
[17:27:18] *** Joins: ravan (~ravan@42.201.198.151)
[17:27:18] *** Quits: ravan (~ravan@42.201.198.151) (Changing host)
[17:27:18] *** Joins: ravan (~ravan@user/ravan)
[17:27:28] *** Joins: Malvolio (~Malvolio@user/malvolio)
[17:27:55] <Guest82> so the idea here is to encrypt some parts of the record and base64 encode the result as external ID. do I really need encryption for my case? is there a way to stretch the internal ID somehow using hash functions or no?
[17:28:45] <Guest82> as i mentioned i already have a randomly generated column for the purpose of external ID, the problem is that it is longer than 16 characters.
[17:29:05] <MacGyver> Yes, and if you *randomly* generate it, or generate it by hashing, it should be longer than 16 characters.
[17:29:44] <MacGyver> The idea is that you *just* encrypt the internal (sequential) ID. Because it's using a block cipher with a stable key, you don't have to worry about collisions.
[17:30:07] <Guest82> so, i cant use the longer random generated hash and downcast it to 16 characters and preserve the uniqueness somehow?
[17:30:13] <MacGyver> No.
[17:30:30] <MacGyver> You will have collision concerns if you do that.
[17:30:52] <Guest82> does it matter what algorithm i choose to encrypt the internal numeric ID?
[17:30:55] <TimMc> Encryption is a 1-to-1 transformation, meaning that for every possible internal ID, there is exactly one external ID, taking up the same amount of space.
[17:31:11] <TimMc> (same amount assuming no headers, which is fine for this case)
[17:31:38] <Guest82> so, in theory when my internal ID grows by size the external will grow as well?
[17:31:39] <TimMc> Hashes *do* allow collisions, which is a problem in small spaces.
[17:31:44] <MacGyver> Didn't NIST standardize something for exactly this case?
[17:32:11] <Guest82> if you can point me to some algorithm that would be nice.
[17:32:13] <TimMc> Guest82: Important question: How many internal IDs will you *ever* have?
[17:32:39] <Guest82> TimMc: thats unknown at the moment :)
[17:32:47] <Guest82> TimMc: that's unknown at the moment :)
[17:33:06] *** Malvolio is now known as Guest2616
[17:33:28] <yawkat> MacGyver: FF3-1?
[17:33:30] <TimMc> I mean the most you can possibly imagine this application ever having, if it's a wild success.
[17:33:46] <MacGyver> yawkat: Possibly.
[17:34:16] <Guest82> TimMc: really don't know at the moment. what will be my limitation if I choose this method of encrypting the internal ID?
[17:34:20] *** Quits: Guest2616 (~Malvolio@user/malvolio) (Ping timeout: 256 seconds)
[17:34:48] <MacGyver> Finding a working implementation.
[17:34:55] <yawkat> apparently it's pretty much just feistel
[17:35:10] <TimMc> Guest82: Just thinking about how much room you have to play with.
[17:35:30] <MacGyver> By the pigeonhole principle, if your IDs grow beyond what this encryption-based method can end up fitting in 16 characters, you have a problem *anyway*, regardless of which method you've chosen to get there.
[17:35:57] <TimMc> Yeah, I'm not *too* worried about the encryption-based methods. :-)
[17:36:08] <TimMc> I was thinking more about the hashes.
[17:36:24] <TimMc> (and what encoding gets used)
[17:37:24] *** Joins: byteskeptical (~amnesia@user/byteskeptical)
[17:37:42] <MacGyver> Hmm, FF3-1 is specifically for FPE again, but in this case a simple pass of 3DES would suffice I think.
[17:37:52] <MacGyver> (Or any other block cipher with < 96 bits block size.)
[17:38:05] <MacGyver> And then base64-encode the result.
[17:38:15] <TimMc> 96 bits assuming no header
[17:38:44] <MacGyver> I recall some work was being done specifically to 80-bit block size ciphers.
[17:39:03] <MacGyver> The whole Simon&Speck thing?
[17:39:24] <MacGyver> (I wouldn't use those myself, but the competition they were in)
[17:39:46] <MacGyver> https://csrc.nist.gov/projects/lightweight-cryptography
[17:40:20] <TimMc> This needs to be secure against known-plaintext attacks too.
[17:40:30] <TimMc> The inputs will be pretty predictable!
[17:40:47] <Guest82> so, if i choose to use this FF3-1 algorithm (which is meant to preserve the original data) will the cipher text look like the plain text (the internal ID)?
[17:45:44] *** Quits: MajorBiscuit (~MajorBisc@c-001-028-049.client.tudelft.eduvpn.nl) (Quit: WeeChat 3.4)
[17:46:00] *** Joins: MajorBiscuit (~MajorBisc@c-001-028-049.client.tudelft.eduvpn.nl)
[17:46:15] *** Joins: Malvolio (~Malvolio@user/malvolio)
[17:52:38] *** Quits: MajorBiscuit (~MajorBisc@c-001-028-049.client.tudelft.eduvpn.nl) (Quit: WeeChat 3.4)
[17:52:54] *** Joins: MajorBiscuit (~MajorBisc@c-001-028-049.client.tudelft.eduvpn.nl)
[18:18:01] *** Joins: dude12312414 (~test@gateway/tor-sasl/dude12312414)
[18:19:21] *** Quits: sdfgsdfg (~dfghsfgs@user/sdfgsdfg) (Quit: ayo yoyo ayo yoyo hololo, hololo.)
[18:20:29] <wasamasa> lolwut
[18:21:11] <MacGyver> Guest82: "Look like" in your case would simply mean "is a number between 0 and 2^<domain size>", though.
[18:21:29] <MacGyver> Guest82: Considering you have sequential IDs without having mentioned a hard upper bound.
[18:21:44] <wasamasa> I love how the cryptanalysis of FF3-1 features a dude called Durak
[18:21:51] <MacGyver> Guest82: Hence why I mentioned FFP3-1 might be overkill, your case might not need that.
[18:22:01] <MacGyver> FF3-1*
[18:22:05] <wasamasa> lol
[18:25:36] <Guest82> MacGyver: why? what would be the difference between this FF3-1 cipher and 3DES of my incremental numbers? also, this starts to look a bit strange, since i will have to store some key, which will be used for the encryption. isn't there any standard way to produce such result with hashing? or my problem is that 16 characters (bytes) is just not
[18:25:36] <Guest82> enough for proper hashing algorithm?
[18:26:15] <MacGyver> Okay, answering those in backwards order:
[18:26:21] <MacGyver> Yes, that is your problem.
[18:26:36] <MacGyver> 16 *characters* doesn't translate to 16 *bytes*, as you said you want them to be ASCII.
[18:26:49] <MacGyver> At most it translates to 12 bytes.
[18:26:57] <MacGyver> And even 16 is not a lot if you're worried about collisions.
[18:27:37] <MacGyver> So no, there is no standard way to produce this result with hashing *and* be reasonably safe against collisions, if you have enough numbers to hash and you truncate down to small enough size.
[18:27:59] <MacGyver> Using a block-cipher based permutation indeed means you'll need to store a key.
[18:28:24] <MacGyver> And the main difference between FF3-1 and just a naive 3DES of your incremental numbers *here* is availability of implementation.
[18:29:06] <MacGyver> I suggested 3DES in particular because it's pretty certainly available and has a small enough blocksize for the output to fit into 16 characters of base64-encoding.
[18:29:19] <MacGyver> But there are also more modern ciphers with a small enough blocksize.
[18:29:31] <MacGyver> You'll have to go look for those options though.
[18:32:43] <Guest82> if i didn't have the restrictions of the length of the ID would that be a viable solution to use SHA-256 to hash all the information from the row?
[18:33:26] *** Quits: karstensrage (~karstensr@nibbler.warped.com) (Changing host)
[18:33:26] *** Joins: karstensrage (~karstensr@user/karstensrage)
[18:34:05] <yawkat> yes
[18:34:10] <MacGyver> Yes -- although personally I'd still want to actually *check* for collisions.
[18:34:16] <MacGyver> Just as a failsafe.
[18:34:43] <MacGyver> But at least the odds of hitting a collision are, at that point, pretty much negligible.
[18:35:25] <MacGyver> That being said, it would be trivial to figure out the internal ID if all the other information is known to the recipient of the external ID.
[18:36:01] <MacGyver> (Because they can easily compute SHA256 on all numbers + that information between 0 and 1000000000 in about a second or two)
[18:37:53] *** Quits: cwebber (~user@user/cwebber) (Remote host closed the connection)
[18:38:29] <Guest82> yes, this is true.
[18:40:18] *** Joins: gildasio (~gildasio@gateway/tor-sasl/gildasio)
[18:41:36] <Guest82> isn't there any standardized process for generating such IDs/reference-numbers in general? like bank transactions, bitcoin transactions, stock keeping unit (SKU) etc.? or every vendor choose some way of generating such IDs.
[18:41:54] <MacGyver> There are some standard processes, yes, like UUID-generation.
[18:42:12] <MacGyver> But none of them account for your length limitation.
[18:42:26] <Guest82> Yes, that's true :(
[18:43:14] <Guest82> Interestingly YouTube video IDs are also generated somehow and it appears that they grow in size.
[18:50:01] *** Joins: ioxzev1z (~ioxzev1z@user/ioxzev1z)
[18:52:10] *** Quits: Deknos (~someone@user/menace) (Quit: Deknos)
[18:59:29] *** Joins: Xeroine (~Xeroine@user/xeroine)
[18:59:37] *** Parts: Xeroine (~Xeroine@user/xeroine) ()
[19:07:15] *** Quits: d1cor (~diego@179.63.242.120) (Ping timeout: 268 seconds)
[19:11:21] <Peng> https://www.openssl.org/news/secadv/20220128.txt "BN_mod_exp may produce incorrect results on MIPS (CVE-2021-4160)"
[19:12:48] *** Quits: caveman (~caveman@gateway/tor-sasl/caveman) (Ping timeout: 276 seconds)
[19:13:15] *** Quits: dude12312414 (~test@gateway/tor-sasl/dude12312414) (Quit: THE RAM IS TOO DAMN HIGH)
[19:15:29] *** Joins: instantp10neer (~instantp1@user/instantp10neer)
[19:16:49] <Alipha> Guest82: I'd second using the  3DES suggestion. Though 16 bytes of a hash encoded as base64 is unlikely to have a collision until you get up into the trillions of records. However, you'd need some kind of backup plan if there is a collision. And if there's no feasible backup plan, then you're kinda stuck with the truncated hash idea.
[19:20:07] <MacGyver> Stuck as in, dead in the water at that point.
[19:20:22] <MacGyver> Not stuck as in, you need to make it work; it *fails* at that point without any option *to* make it work.
[19:21:10] <MacGyver> Alipha: Mind: 16 bytes of a hash encoded as base64 isn't the space available.
[19:21:21] <MacGyver> Alipha: The output space was described as 16 *characters*.
[19:21:31] *** Joins: caveman (~caveman@gateway/tor-sasl/caveman)
[19:21:34] <MacGyver> So best-case aiui is 96 bits.
[19:21:59] <MacGyver> (Assuming base64 and ASCII -- if the ASCII requirement is dropped and embedded NULLs are possible then it's 128 bits)
[19:23:28] <Alipha> Yep. The birthday collision point is 2^48, or 64 trillion.
[19:25:36] <Alipha> If Guest82 is storing millions of records, I'd be inclined just to risk it :-) Something like a 1/1000 chance there would be a collision?
[19:27:06] *** Quits: caveman (~caveman@gateway/tor-sasl/caveman) (Ping timeout: 276 seconds)
[19:27:19] <Alipha> And yes, "stuck" was a poor choice of a word
[19:37:08] *** Joins: dude12312414 (~test@gateway/tor-sasl/dude12312414)
[19:45:16] <TimMc> Guest82: Is storing a key going to be a problem?
[19:45:53] <TimMc> Also, why not just create and store 16 random chars of Base64 with each record?
[19:47:50] *** Joins: merty (~merty@94.190.193.113)
[19:47:53] *** Parts: merty (~merty@94.190.193.113) ()
[19:55:20] *** Joins: solractg (~solractg@51.37.40.227)
[19:58:48] <LordOfLive> Hey guys
[19:59:20] <LordOfLive> If I have Eth on kovan testnet they are not usuable?
[20:00:45] *** Quits: solractg (~solractg@51.37.40.227) (Quit: Client closed)
[20:06:47] <TimMc> LordOfLive: Check the channel topic.
[20:11:02] <Guest82> TimMc: i thought that i can just some information and use some hashing function, without the need for encryption. but as far as i understood, unless i start using UUID or SHA-256 it won't be possible. also the problem with the hashing function was, that if you know all of the information for the record, you can compute the internal ID (if it is
[20:11:02] <Guest82> part of the hashed input).
[20:11:27] <Guest82> TimMc: because I already have similar column, but it it 34 characters long, and it doesn't feel right to introduce one more unique ID. the problem is that i wanted to go without creating a new column, but i'm not sure if it will be possible.
[20:17:24] <Alipha> Guest82: just create a new column. it's a lot more straightforward :-)
[20:19:27] *** Quits: arjun (~arjun@user/arjun) (Remote host closed the connection)
[20:19:57] <TimMc> Guest82: New column called external_id. Every time you insert a row, generate 16 chars of Base64 for that column. Use that.
[20:20:40] *** Quits: Haohmaru (~Haohmaru@195.24.53.110) ()
[20:21:34] <TimMc> (Give the column a "UNIQUE" constraint, of course.)
[20:21:53] <Guest82> and this new column will be generated using random data plus i have to handle in case a collision happens.
[20:23:49] <Guest82> this will give me: one internal_id (incrementing numeric), one long_external_id (34 characters) and one short_external_id (16 characters) :)
[20:25:18] <TimMc> If you generate 1 billion of these records, you'd have a 1 in 7 trillion chance of a collision, according to this one birthday problem calculator I consulted.
[20:25:18] *** Quits: chomwitt (~chomwitt@2a02:587:dc03:8900:12c3:7bff:fe6d:d374) (Ping timeout: 250 seconds)
[20:26:01] <TimMc> (https://www.bdayprob.com/, solving for P)
[20:26:05] *** Joins: chomwitt (~chomwitt@2a02:587:dc03:8900:12c3:7bff:fe6d:d374)
[20:26:58] <Alipha> TimMc: are you assuming a 128-bit identifier, or only a 96-bit identifier? (assuming 16 base64 characters)
[20:28:18] <TimMc> 16 base64, 96 bit
[20:29:45] <Alipha> i keep getting "failed (timed out)" for D = 2^96, N = 2^30
[20:30:00] <TimMc> It should give three answers.
[20:30:06] <TimMc> first one a timeout
[20:30:13] <Alipha> oh, okay
[20:31:53] <Alipha> okay, so i greatly over-estimated the odds of a collision
[20:32:13] <TimMc> Interestingly, going from Base64 to Base94 (all printable ASCII, at least what's on my keyboard) doesn't improve the odds all *that* much. Base64 seems fine.
[20:33:02] <TimMc> Should still have the ability to retry once, though. :-)
[20:34:00] <Alipha> add a column to store a random value so that you can change the random value to rehash the row ;-)
[20:34:47] <TimMc> lol
[20:39:19] <Guest82> the idea was to have immutable external IDs, not something that i will change every month :)
[20:40:22] *** Quits: ioxzev1z (~ioxzev1z@user/ioxzev1z) (Quit: Leaving)
[20:40:36] <TimMc> Or every time you change your data. :-)
[20:51:28] <Guest82> guys, thank you very much for the help! will check if some of the solutions will work for me, otherwise will be back for another cryptography conversation with you :)
[20:57:01] <Alipha> i have java code for doing a 32-bit permutation, but you probably want a 64-bit permutation, if one of the goals is to make the ids not (easily) guessable
[21:04:43] *** Joins: thelounge0617 (5e865860@67.205.143.82)
[21:07:52] *** Quits: kish` (~aqua@user/aqua) (Remote host closed the connection)
[21:08:25] *** Joins: kish` (~aqua@user/aqua)
[21:09:25] <TimMc> I also shared my Feistel implementation. :-)
[21:09:59] <TimMc> but I think crypto is the wrong choice here
[21:21:28] *** thomas25- is now known as thomas25
[21:22:13] <MacGyver> If you want to generate the unique ID stably from some internal ID it's absolutely the right choice.
[21:22:50] <MacGyver> But the randomly-generated-stored-random-number-with-uniqueness-check is probably the better option here.
[21:23:50] <edk> using (format-preserving) for things like this is nice because you can just... not do the uniqueness check. it will always work and be unique and if it doesn't you can just let everyone die
[21:24:00] <edk> er, s/for/encryption for/
[21:24:07] *** Joins: nomagno (~nomagno@2001:470:69fc:105::c1f0)
[21:25:23] <nomagno> Hello! How would the following algorithm (the one listed under 'RSA Cryptosystem') hold up in the real world if implemented literally, with 512 bit keys? Just curious: https://www.tutorialspoint.com/cryptography/public_key_encryption.htm
[21:26:28] <iz> 512 bit keys for RSA would be way too small to be safe in the real world
[21:26:35] <Bostik> badly?
[21:26:39] <MacGyver> nomagno: Not.
[21:26:40] *** Joins: Halver[m] (~hoverhalv@2001:470:69fc:105::d0fe)
[21:26:40] *** Joins: KellerHusky[m] (~kellerhus@2001:470:69fc:105::478c)
[21:26:40] *** Joins: saolof[m] (~saolofenv@2001:470:69fc:105::1:6188)
[21:26:40] *** Joins: hsiktas[m] (~hsiktasm]@2001:470:69fc:105::30d4)
[21:26:40] *** Joins: cacu[m] (~cacuconve@2001:470:69fc:105::b9df)
[21:26:40] *** Joins: FelixFish[m] (~felixfish@2001:470:69fc:105::1:2e23)
[21:26:41] *** Joins: Histausse (~histausse@2001:470:69fc:105::1:711b)
[21:26:41] *** Joins: duckie (~duckie@user/duckie)
[21:27:12] <edk> setting aside the insufficient key size, using RSA "raw" is not considered a very good move
[21:27:29] <MacGyver> Both because what you're linking is schoolbook RSA which is *always* broken, regardless of key length, and because 512 bits has been broken for a while now because of key length.
[21:27:55] *** Joins: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net)
[21:29:16] <MacGyver> The last "real" system using 512 bit RSA was DNSSEC, and that was a bit of a hairy issue.
[21:30:08] <MacGyver> I think they moved that to 2048 bits somewhere around 2016.
[21:31:38] *** Joins: abraham1 (~abraham@143.244.185.86)
[21:33:47] <Peng> There's still people using 512-bit RSA DNSSEC. Not very many, though.
[21:34:18] *** Quits: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
[21:34:32] <MacGyver> The root signing keys though?
[21:34:44] <MacGyver> I mean I don't care about random mom-and-pop domain under godaddy.
[21:34:50] <MacGyver> But the root signing keys had to move too.
[21:35:06] <Peng> The root uses 2048-bit keys.
[21:35:50] *** Joins: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net)
[21:36:14] *** Quits: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net) (Client Quit)
[21:37:43] *** Quits: MajorBiscuit (~MajorBisc@c-001-028-049.client.tudelft.eduvpn.nl) (Ping timeout: 268 seconds)
[21:37:49] *** Joins: ___nick___ (~quassel@cpc68286-cdif17-2-0-cust533.5-1.cable.virginm.net)
[21:39:42] *** Quits: darthtilde (~dsd@user/ironsoba) (Ping timeout: 256 seconds)
[21:50:28] *** Quits: CryptoClub (~fafs@88.red-83-34-81.dynamicip.rima-tde.net) (Ping timeout: 256 seconds)
[22:01:15] *** Joins: hlauk (~hlauk@176.33.108.116)
[22:05:14] *** Joins: aleck (~aleck@user/aleck)
[22:06:42] *** Quits: aleck1 (~aleck@user/aleck) (Ping timeout: 250 seconds)
[22:08:23] *** Joins: d1cor (~diego@179.63.242.120)
[22:11:27] *** Quits: hlauk (~hlauk@176.33.108.116) (Quit: Leaving)
[22:13:36] *** Parts: Guest82 (~Guest82@jordanov4.pppoe.optic-com.eu) ()
[22:13:43] *** Quits: andreasbuhr (~quassel@p549db9a5.dip0.t-ipconnect.de) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
[22:45:12] *** Joins: hlauk (~hlauk@176.33.108.116)
[22:52:55] *** Joins: Edge (~Edge@84.71.232.254)
[22:54:18] *** Quits: Centaur (~sys@user/probe) (Remote host closed the connection)
[22:56:16] *** Quits: pergaminho (~pergaminh@user/pergaminho) ()
[23:01:13] *** Joins: pergaminho (~pergaminh@user/pergaminho)
[23:01:35] *** Quits: pergaminho (~pergaminh@user/pergaminho) (Client Quit)
[23:02:08] *** Joins: gabriel1_ (~gabriel1@37.170.71.1)
[23:03:30] *** Joins: hqdruxn08_ (~hqdruxn08@user/hqdruxn08)
[23:04:42] *** Quits: gabriel1 (~gabriel1@user/gabriel1) (Ping timeout: 256 seconds)
[23:04:42] *** Quits: hqdruxn08 (~hqdruxn08@user/hqdruxn08) (Ping timeout: 256 seconds)
[23:05:50] *** Joins: pergaminho (~pergaminh@user/pergaminho)
[23:08:21] *** Joins: zro (~zro@user/zro)
[23:08:45] *** Quits: thelounge0617 (5e865860@67.205.143.82) (Quit: The Lounge - https://thelounge.chat)
[23:09:50] *** Quits: pergaminho (~pergaminh@user/pergaminho) (Client Quit)
[23:10:11] *** Joins: pergaminho (~pergaminh@user/pergaminho)
[23:13:22] *** Quits: BOKALDO (~BOKALDO@user/bokaldo) (Quit: Leaving)
[23:15:38] *** Quits: hlauk (~hlauk@176.33.108.116) (Quit: Leaving)
[23:20:35] *** Joins: milkt (~debian@gateway/tor-sasl/milkt)
[23:22:26] *** Joins: jarthur (~jarthur@cpe-70-114-198-37.austin.res.rr.com)
[23:26:35] *** Parts: nomagno (~nomagno@2001:470:69fc:105::c1f0) ()
[23:30:58] *** Quits: Edge (~Edge@84.71.232.254) (Remote host closed the connection)
[23:36:07] *** Quits: d1cor (~diego@179.63.242.120) (Ping timeout: 268 seconds)
[23:44:30] *** Joins: crash (~crash@179.129.27.215)
[23:44:30] *** Joins: Pythayr` (~pither195@2600:1700:82f0:2fe0::11)
[23:45:51] *** Quits: crash (~crash@179.129.27.215) (Client Quit)
[23:45:56] *** Quits: Pythayr (~pither195@64.42.181.51) (Ping timeout: 250 seconds)
[23:50:01] *** Quits: Pythayr` (~pither195@2600:1700:82f0:2fe0::11) (Ping timeout: 250 seconds)
[23:50:18] *** Joins: Pythayr` (~pither195@64.42.181.51)
[23:51:40] <joe7057> I assume that the method for upgrading signing keys is to generate new, longer keys while the shorter ones are still secure, sign the new ones with the old ones, then start using the new ones.
[23:51:56] <joe7057> Or is there some issue with that approach?
[23:56:52] *** Joins: sdfgsdfg (~dfghsfgs@user/sdfgsdfg)
[23:57:45] *** Quits: Pythayr` (~pither195@64.42.181.51) (Quit: Leaving)
