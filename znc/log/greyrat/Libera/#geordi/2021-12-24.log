[00:48:31] <CarloWood>  { A a; f(std::move(a)); } struct A { std::vector<tracked::B> v; std::string m_s; A() : v(3), m_s("hello") { } A(A&& a) : m_s(a.m_s) { } }; void f(A&& a) { cout << s.m_s; }
[00:48:31] <geordi> error: 's' was not declared in this scope
[00:48:54] <CarloWood>  { A a; f(std::move(a)); } struct A { std::vector<tracked::B> v; std::string m_s; A() : v(3), m_s("hello") { } A(A&& a) : m_s(a.m_s) { } }; void f(A&& a) { cout << a.m_s; }
[00:48:55] <geordi> B0* B1* B2* hello B0~ B1~ B2~
[00:50:56] <CarloWood>  { A a; f(std::move(a)); } struct A { std::vector<tracked::B> v; std::string m_s; A() : v(3), m_s("hello") { } A(A&& a) : m_s(a.m_s) { } }; void f(A&& a) { cout << v.size(); }
[00:50:56] <geordi> error: 'v' was not declared in this scope
[00:51:01] <CarloWood>  { A a; f(std::move(a)); } struct A { std::vector<tracked::B> v; std::string m_s; A() : v(3), m_s("hello") { } A(A&& a) : m_s(a.m_s) { } }; void f(A&& a) { cout << a.v.size(); }
[00:51:02] <geordi> B0* B1* B2* 3 B0~ B1~ B2~
[00:51:17] <CarloWood>  { A a; f(std::move(a)); std::cout << a.v.size(); } struct A { std::vector<tracked::B> v; std::string m_s; A() : v(3), m_s("hello") { } A(A&& a) : m_s(a.m_s) { } }; void f(A&& a) { cout << a.v.size(); }
[00:51:18] <geordi> B0* B1* B2* 33 B0~ B1~ B2~
[00:51:56] <CarloWood>  { A a; f(std::move(a)); std::cout << ' ' << a.v.size(); } struct A { std::vector<tracked::B> v; std::string m_s; A() : v(3), m_s("hello") { } A(A&& a) : m_s(a.m_s) { } }; void f(A&& a) { cout << a.v.size(); }
[00:51:56] <geordi> B0* B1* B2* 3 3 B0~ B1~ B2~
[00:55:06] *** Joins: ashafq (~ashafq@pool-96-237-238-252.bstnma.fios.verizon.net)
[00:56:34] <CarloWood>  { A a; f(std::move(a)); std::cout << ' ' << a.v.size(); } struct A { std::vector<tracked::B> v; std::string m_s; A() : v(3), m_s("hello") { } A(A&& a) : m_s(a.m_s) { } }; void f(A&& a) { A a2(std::move(a)); cout << a.v.size(); }
[00:56:34] <geordi> Same output.
[00:56:45] <CarloWood>  { A a; f(std::move(a)); std::cout << ' ' << a.v.size(); } struct A { std::vector<tracked::B> v; std::string m_s; A() : v(3), m_s("hello") { } A(A&& a) : m_s(a.m_s) { BARK; } }; void f(A&& a) { A a2(std::move(a)); cout << a.v.size(); }
[00:56:46] <geordi> B0* B1* B2* A::A(A&&) 3 3 B0~ B1~ B2~
[01:03:48] <CarloWood> { A a; a.test(); } struct A { A* me; A() : me(this) { } void test() { if (me == this) cout << "OK!"; } };
[01:03:49] <geordi> OK!
[01:04:39] <CarloWood> { map<int, A> m; auto r = m.emplace(42, A{}); r.first->test(); } struct A { A* me; A() : me(this) { } void test() { if (me == this) cout << "OK!"; } };
[01:04:39] <geordi> error: 'struct pair<const int, A>' has no member named 'test'
[01:05:00] <CarloWood> { map<int, A> m; auto r = m.emplace(42, A{}); r.first->second.test(); } struct A { A* me; A() : me(this) { } void test() { if (me == this) cout << "OK!"; } };
[01:05:00] <geordi>  
[01:05:12] <CarloWood> { map<int, A> m; auto r = m.emplace(42, A{}); r.first->second.test(); } struct A { A* me; A() : me(this) { } void test() { if (me == this) cout << "OK!"; else cout << "Oops"; } };
[01:05:13] <geordi> Oops
[01:05:34] <CarloWood> { map<int, A> m; auto r = m.emplace(42, {}); r.first->second.test(); } struct A { A* me; A() : me(this) { } void test() { if (me == this) cout << "OK!"; else cout << "Oops"; } };
[01:05:34] <geordi> error: no matching function for call to 'map<int, A>::emplace(int, <brace-enclosed initializer list>)'
[01:06:03] <CarloWood> { map<int, A> m; auto r = m.emplace(42); r.first->second.test(); } struct A { A* me; A() : me(this) { } void test() { if (me == this) cout << "OK!"; else cout << "Oops"; } };
[01:06:04] <geordi> error: no matching function for call to 'construct_at(pair<const int, A>*&, int)'
[01:06:21] <CarloWood> { map<int, A> m; auto r = m.emplace(42, 0); r.first->second.test(); } struct A { A* me; A(int) : me(this) { } void test() { if (me == this) cout << "OK!"; else cout << "Oops"; } };
[01:06:22] <geordi> OK!
[01:33:23] *** Quits: Cyp (~cyp@213.237.85.9) (Read error: Connection reset by peer)
[01:40:31] <CarloWood> { map<int, A> m; auto r = m.emplace(42, 0, 3.14); r.first->second.test(); } struct A { A* me; A(int, double) : me(this) { } void test() { if (me == this) cout << "OK!"; else cout << "Oops"; } };
[01:40:31] <geordi> error: no matching function for call to 'construct_at(pair<const int, A>*&, int, int, double)'
[01:40:42] <CarloWood> { map<int, A> m; auto r = m.try_emplace(42, 0, 3.14); r.first->second.test(); } struct A { A* me; A(int, double) : me(this) { } void test() { if (me == this) cout << "OK!"; else cout << "Oops"; } };
[01:40:43] <geordi> OK!
[01:41:41] <CarloWood> { B b; b.g(); } struct B { void g() { map<int, A> m; auto r = m.try_emplace(42, 0, 3.14); r.first->second.test(); }}; struct A { A* me; A(int, double) : me(this) { } void test() { if (me == this) cout << "OK!"; else cout << "Oops"; } };
[01:41:41] <geordi> error: 'A' was not declared in this scope
[01:42:25] <CarloWood> { B b; b.g(); } struct A { A* me; A(int, double) : me(this) { } void test() { if (me == this) cout << "OK!"; else cout << "Oops"; } }; struct B { void g() { map<int, A> m; auto r = m.try_emplace(42, 0, 3.14); r.first->second.test(); }};
[01:42:26] <geordi> OK!
[01:43:01] <CarloWood> { B b; b.g(); } struct A { A* me; private: A(int, double) : me(this) { } public: void test() { if (me == this) cout << "OK!"; else cout << "Oops"; } }; struct B { void g() { map<int, A> m; auto r = m.try_emplace(42, 0, 3.14); r.first->second.test(); }};
[01:43:02] <geordi> error: 'A::A(int, double)' is private within this context
[01:43:29] <CarloWood> { B b; b.g(); } struct B; struct A { A* me; private: friend class B; A(int, double) : me(this) { } public: void test() { if (me == this) cout << "OK!"; else cout << "Oops"; } }; struct B { void g() { map<int, A> m; auto r = m.try_emplace(42, 0, 3.14); r.first->second.test(); }};
[01:43:29] <geordi> Same error.
[01:43:58] *** Joins: Cyp (~cyp@213.237.85.9)
[09:22:04] *** Quits: great_taste (~great_tas@user/great-taste/x-5798414) (Quit: Client closed)
[18:26:09] <CarloWood> { std::Vector<int> wut; }
[18:26:09] <geordi> error: 'Vector' is not a member of 'std'; did you mean 'hecto'? (fix known)
[19:14:55] *** Joins: great_taste (~great_tas@user/great-taste/x-5798414)
[20:53:09] <CarloWood> << "⛓"
[20:53:10] <geordi> ⛓
[20:53:22] <CarloWood> << '⛓'
[20:53:22] <geordi> warning: multi-character character constant
[20:53:27] <CarloWood> << '⛓'u
[20:53:27] <geordi> error: unable to find character literal operator 'operator""u' with 'int' argument
[20:55:15] <CarloWood> << u8"⛓"
[20:55:15] <geordi> error: ambiguous overload for 'operator<<' in 'cout << "\37777777742\37777777633\37777777623"' (operand types are 'ostream' {aka 'ostream'} and 'const char8_t [4]')
[20:55:54] <CarloWood> << u8'⛓'
[20:55:54] <geordi> error: Unexpected end of request. Expected any symbol.
[21:01:45] <CarloWood> << u8"⛓"
[21:01:45] <geordi> error: ambiguous overload for 'operator<<' in 'cout << "\37777777742\37777777633\37777777623"' (operand types are 'ostream' {aka 'ostream'} and 'const char8_t [4]')
[21:01:50] <CarloWood> << u8", ⛓"
[21:01:51] <geordi> error: ambiguous overload for 'operator<<' in 'cout << ", \37777777742\37777777633\37777777623"' (operand types are 'ostream' {aka 'ostream'} and 'const char8_t [6]')
