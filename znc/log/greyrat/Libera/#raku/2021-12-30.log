[00:00:05] <Woodi> jdv: not anymore. just unpack where it need to be
[00:00:33] <MasterDuke> and fwiw, that hours for installation is/was just on RPIs, not more normal desktop/laptop hardware
[00:00:37] <jdv> curious.  be interesting what exactly is slow for you.
[00:00:50] <Woodi> zef/hashes-style repos looks cargo-culted into installing distribution...
[00:01:42] <Woodi> on my laptop or old desktop installing rakudo-202[01]... was around hour...
[00:02:04] <jdv> what exactly did that entail?
[00:02:24] <Woodi> and repositories mechanism is buildin and many types of repos can coexists ?
[00:02:43] <jdv> i compiled rakudo head on my rpi4 the other day and it was minutes, not hours.
[00:02:54] <Woodi> with modules ?
[00:02:58] <jdv> many minutes  ht still:)
[00:03:03] <jdv> *but
[00:03:06] <jdv> no
[00:03:43] <jdv> installing modules, afaik, is dominated by the parse perf issue.
[00:04:11] <Woodi> parse of sources or jsons ?
[00:04:31] <jdv> source.  grammaes basically.
[00:05:02] *** Quits: linkable6 (lin-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[00:05:02] *** Quits: evalable6 (eva-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[00:05:23] <jdv> the thing precomp tries to ameliorate:(
[00:05:26] <Woodi> zef is like cpanm not installing from tarball...
[00:06:03] *** Joins: linkable6 (lin-able@2001:41d0:2:5eb5::)
[00:06:42] <jdv> it has to comp/precomp to run tests...
[00:06:51] <Woodi> also other day i found hashes are fast now with new dispatch dispatch :) jnthn++
[00:07:21] *** Joins: evalable6 (eva-able@2001:41d0:2:5eb5::)
[00:07:25] <jdv> in any case its a known pain point.  people are trying.  thanks for playing:)
[00:09:07] <Woodi> but eg. debian just unpack deb files do not run any tests. installing from release tarball is like deb, imo/ but i just could not fall into sleep but maybe I'm dreaming anyway ?
[00:10:09] <jdv> raku is like perl where tests are run upon install, at least with cpan, cpanm, zef, etc...
[00:10:43] <jdv> yes, if the modules were distro pkged youd skip that...
[00:11:22] <Woodi> do deb contains precompiled modules ? :)
[00:11:42] <jdv> afaik no so you take inital hit...
[00:12:46] <MasterDuke> the suse packages might be pre-precompiled. i think nine is involved there and he's talked about it at least
[00:13:41] <jdv> perf is center stage these days.  it might take a while but its a priority.
[00:16:26] *** Quits: guifa (~guifa@host-23-251-65-252.VALOLT4.epbfi.com) (Quit: guifa)
[00:18:06] <MasterDuke> the problem is that the current slowest part, grammars, has the fewest people who understand it well enough to improve it. and it might be the most novel thing about raku. some of the moarvm improvements are "just" implementing a reasonably-well-known theory or algorithm (i.e., there's prior practice to learn from, even though it could very well be
[00:18:06] <MasterDuke> quite complicated). but raku's grammar has fewer places to steal code from (as far as i'm aware, which is limited), so improving it requires doing more things for the first time
[00:19:16] <MasterDuke> and most of the original implementors of it aren't currently active for various reasons
[00:20:57] <jdv> :(
[00:31:49] *** Quits: bdju (~bard@user/bdju) (Ping timeout: 240 seconds)
[00:39:14] *** Joins: bdju (~bard@user/bdju)
[00:48:38] <nine> The openSUSE packages do contain precompiled files. It's really just installing them within seconds and your application will start up immediately
[00:49:06] <nine> If Debian packages do not contain precomp files, they are kind of only doing half the job and I'd wonder why.
[00:50:06] <nine> In fact being able to package precompiled files is one of the major goal of the often critiziced (and rarely understood) module management system.
[00:51:59] <nine> Also I really don't understand why people would waste hours having an underpowered device like a Pi precompile Raku code, when you can have a system doing it that's probably tens of times faster. But then, people seem to prefer making the wildest guesses as to how to improve them to actually understanding the systems they using.
[00:52:39] <nine> Understanding them would gain you the insight that precomp files are architecture independent and that you can simply copy them from your beefy desktop to your embedded device.
[01:12:44] *** Quits: MoC (~moc@user/moc) (Quit: Konversation terminated!)
[01:17:41] *** Quits: bdju (~bard@user/bdju) (Ping timeout: 256 seconds)
[01:24:24] *** Joins: bdju (~bard@user/bdju)
[01:25:39] <El_Che> nine: copy hashed directories is something people in the know would do, but it's not something very user friendly
[01:26:05] <El_Che> ask 100 raku users if they know about it and round 99 wouldn't have a clue
[01:26:26] <discord-raku-bot> <Skarsnik#7370> then why not have precompile file stored in mlodule management repo
[01:26:44] <discord-raku-bot> <Skarsnik#7370> ?
[01:56:34] *** Quits: bdju (~bard@user/bdju) (Ping timeout: 260 seconds)
[02:03:26] *** Joins: bdju (~bard@user/bdju)
[02:14:31] <japhb> Skarsnik: Precompiles are based on versions of the compiler and other modules.  A linux distro could do waterfall packaging, so guaranteed versions of all dependencies including the compiler, but zef could not reasonably do this without a storage explosion.  In theory we *could* offer a variant that has precompiles only from a snapshot at the instant of a new compiler release, but ... well, that kinda 
[02:14:37] <japhb> overlaps with Rakudo Star.
[02:17:41] <japhb> Woodi: As MasterDuke said, the multiple hours on RPi 4B/4 GB that I quoted was just for my full rebuild with all my favorite modules.  After a couple runs of just MoarVM, NQP, Rakudo, Zef, that base stack of four builds was 35-40 minutes on the RPi.
[02:20:57] <japhb> nine: My guess would be that precomp files are arch independent in the same way MoarVM is uint agnostic -- was fine in theory, but probably less accurate in real life.  I have my suspicions about whether 64-bit Linux on x64 to 32-bit Rasbian on aarch64 is handled perfectly, though to be honest I've never tested it with my full stack.  (Partially because there's no existing tool to test a full suite of 
[02:21:03] <japhb> *already installed* modules.)
[03:03:26] *** Quits: evalable6 (eva-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[03:03:26] *** Quits: linkable6 (lin-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[03:03:39] *** Quits: djerius (~quassel@pool-108-20-43-199.bstnma.fios.verizon.net) (Ping timeout: 256 seconds)
[03:10:43] *** Joins: djerius (~quassel@pool-108-20-43-199.bstnma.fios.verizon.net)
[03:24:34] *** Quits: jjido (~Denis@2a02:c7f:5c91:e700:6cc4:96c6:a3a5:e429) (Quit: My MacBook Air has gone to sleep. ZZZzzz‚Ä¶)
[03:38:49] *** Quits: reportable6 (rep-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[03:52:46] *** Quits: Skarsnik (~Skarsnik@91-170-31-218.subs.proxad.net) (Read error: Connection reset by peer)
[04:41:11] *** Joins: reportable6 (rep-able@2001:41d0:2:5eb5::)
[05:05:02] *** Joins: linkable6 (lin-able@2001:41d0:2:5eb5::)
[05:06:10] *** Joins: evalable6 (eva-able@2001:41d0:2:5eb5::)
[06:06:10] *** Quits: linkable6 (lin-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[06:06:10] *** Quits: evalable6 (eva-able@2001:41d0:2:5eb5::) (Read error: Connection reset by peer)
[06:06:12] *** Quits: lockywolf (~lockywolf@vultr-seoul-openbsd.lockywolf.net) (Quit: ZNC 1.8.2 - https://znc.in)
[06:06:23] *** Joins: linkable6 (lin-able@2001:41d0:2:5eb5::)
[06:07:58] *** Joins: evalable6 (eva-able@2001:41d0:2:5eb5::)
[06:37:28] *** Joins: lockywolf (~lockywolf@2a03:6000:6f63:638::177)
[06:48:10] *** Quits: lockywolf (~lockywolf@2a03:6000:6f63:638::177) (Quit: ZNC 1.8.2 - https://znc.in)
[06:48:27] *** Joins: lockywolf (~lockywolf@2a03:6000:6f63:638::177)
[06:58:32] *** Quits: jgaz (~jgaz@2600:8805:d980:7620::9e0) (Quit: Leaving)
[07:34:34] *** Joins: DISCO94 (~DISCO@c-76-102-40-242.hsd1.ca.comcast.net)
[07:37:17] *** Quits: DISCO94 (~DISCO@c-76-102-40-242.hsd1.ca.comcast.net) (Client Quit)
[08:37:17] *** Quits: coverable6 (cov-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[08:37:17] *** Quits: bisectable6 (bis-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[08:37:17] *** Quits: notable6 (not-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[08:37:17] *** Quits: greppable6 (gre-able@2001:41d0:2:5eb5::) (Read error: Connection reset by peer)
[08:37:17] *** Quits: evalable6 (eva-able@2001:41d0:2:5eb5::) (Read error: Connection reset by peer)
[08:37:17] *** Quits: committable6 (com-able@2001:41d0:2:5eb5::) (Read error: Connection reset by peer)
[08:37:17] *** Quits: reportable6 (rep-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[08:37:17] *** Quits: shareable6 (sha-able@2001:41d0:2:5eb5::) (Read error: Connection reset by peer)
[08:37:17] *** Quits: squashable6 (squ-able@2001:41d0:2:5eb5::) (Read error: Connection reset by peer)
[08:37:17] *** Quits: unicodable6 (uni-able@2001:41d0:2:5eb5::) (Read error: Connection reset by peer)
[08:37:17] *** Quits: sourceable6 (sou-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[08:37:17] *** Quits: quotable6 (quo-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[08:37:17] *** Quits: releasable6 (rel-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[08:37:17] *** Quits: bloatable6 (blo-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[08:37:17] *** Quits: benchable6 (ben-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[08:37:17] *** Quits: tellable6 (tel-able@2001:41d0:2:5eb5::) (Write error: Connection reset by peer)
[08:37:18] *** Quits: linkable6 (lin-able@2001:41d0:2:5eb5::) (Write error: Connection reset by peer)
[08:37:18] *** Quits: nativecallable6 (nat-able@2001:41d0:2:5eb5::) (Write error: Connection reset by peer)
[08:37:18] *** Quits: statisfiable6 (sta-able@2001:41d0:2:5eb5::) (Write error: Connection reset by peer)
[08:37:45] *** Joins: statisfiable6 (sta-able@2001:41d0:2:5eb5::)
[08:38:45] *** Joins: committable6 (com-able@2001:41d0:2:5eb5::)
[08:39:06] *** Joins: linkable6 (lin-able@2001:41d0:2:5eb5::)
[08:39:25] *** Joins: nativecallable6 (nat-able@2001:41d0:2:5eb5::)
[08:39:48] *** Joins: bisectable6 (bis-able@2001:41d0:2:5eb5::)
[08:39:54] *** Joins: notable6 (not-able@2001:41d0:2:5eb5::)
[08:40:01] *** Joins: releasable6 (rel-able@2001:41d0:2:5eb5::)
[08:40:07] *** Joins: reportable6 (rep-able@2001:41d0:2:5eb5::)
[08:43:40] *** Joins: canw (~canw@110.254.130.134)
[08:47:49] *** Quits: canw (~canw@110.254.130.134) (Client Quit)
[09:12:52] *** Joins: guifa (~guifa@host-23-251-65-252.VALOLT4.epbfi.com)
[09:13:23] *** Quits: guifa (~guifa@host-23-251-65-252.VALOLT4.epbfi.com) (Client Quit)
[09:36:28] *** Quits: reportable6 (rep-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[09:37:32] *** Joins: coverable6 (cov-able@2001:41d0:2:5eb5::)
[09:38:19] *** Joins: quotable6 (quo-able@2001:41d0:2:5eb5::)
[09:39:12] *** Joins: bloatable6 (blo-able@2001:41d0:2:5eb5::)
[09:39:52] *** Joins: evalable6 (eva-able@2001:41d0:2:5eb5::)
[09:40:20] *** Joins: squashable6 (squ-able@2001:41d0:2:5eb5::)
[09:41:28] *** Quits: lockywolf (~lockywolf@2a03:6000:6f63:638::177) (Quit: ZNC 1.8.2 - https://znc.in)
[09:42:32] *** Joins: lockywolf (~lockywolf@2a03:6000:6f63:638::177)
[10:04:51] *** Quits: lockywolf (~lockywolf@2a03:6000:6f63:638::177) (Quit: ZNC 1.8.2 - https://znc.in)
[10:05:55] *** Joins: lockywolf (~lockywolf@2a03:6000:6f63:638::177)
[10:06:02] *** Joins: Xliff_ (~Cliff@pool-71-255-227-73.washdc.east.verizon.net)
[10:09:49] *** Quits: Xliff (~Cliff@pool-71-255-227-73.washdc.east.verizon.net) (Ping timeout: 240 seconds)
[10:37:59] *** Joins: tellable6 (tel-able@2001:41d0:2:5eb5::)
[10:39:33] *** Joins: greppable6 (gre-able@2001:41d0:2:5eb5::)
[10:40:13] *** Joins: unicodable6 (uni-able@2001:41d0:2:5eb5::)
[10:47:10] *** Quits: frost (~frost@user/frost) (Quit: Ping timeout (120 seconds))
[10:55:17] <nine> japhb: no, the two situations are not nearly the same. If bytecode files are not really architecture independent, it's because of 1 or maybe 2 bugs that are easy to fix. I'd be quite surprised if it was more, since I have tested it on MIPS
[10:58:13] *** Quits: seednode (~seednode@user/seednode) (Quit: Nihil supernum.)
[10:59:03] *** Joins: seednode (~seednode@user/seednode)
[11:19:57] *** Quits: lockywolf (~lockywolf@2a03:6000:6f63:638::177) (Ping timeout: 240 seconds)
[11:23:11] *** Joins: lockywolf (~lockywolf@2a03:6000:6f63:638::177)
[11:23:12] *** Joins: defaultxr (~defaultxr@99-138-110-241.lightspeed.cicril.sbcglobal.net)
[11:24:02] <japhb> nine: I'm happy to hear that at least.  Was the MIPS 32-bit or 64-bit?
[11:25:59] <nine> IIRC 32 bit
[11:33:57] *** Quits: lockywolf (~lockywolf@2a03:6000:6f63:638::177) (Ping timeout: 240 seconds)
[11:37:51] *** Joins: benchable6 (ben-able@2001:41d0:2:5eb5::)
[11:39:47] *** Joins: shareable6 (sha-able@2001:41d0:2:5eb5::)
[11:44:44] *** Joins: lockywolf (~lockywolf@public.lockywolf.net)
[11:50:22] *** Quits: lockywolf (~lockywolf@public.lockywolf.net) (Quit: ZNC 1.8.2 - https://znc.in)
[11:51:23] *** Joins: lockywolf (~lockywolf@46.23.90.177)
[11:58:38] *** Quits: Sgeo (~Sgeo@user/sgeo) (Read error: Connection reset by peer)
[12:00:49] *** Quits: lockywolf (~lockywolf@46.23.90.177) (Remote host closed the connection)
[12:01:55] *** Joins: lockywolf (~lockywolf@46.23.90.177)
[12:13:58] *** Quits: merpaderp (~ircuser@89.111.36.243) (Ping timeout: 260 seconds)
[12:14:11] *** Joins: merpaderp (~ircuser@89.111.36.243)
[12:38:53] *** Joins: reportable6 (rep-able@2001:41d0:2:5eb5::)
[12:39:52] *** Joins: sourceable6 (sou-able@2001:41d0:2:5eb5::)
[12:51:19] <Woodi> so, how much precomp files depend on comiler(s) version ? i'm usually testing monthly releases so "stable" thing - is there technical reason to recompile every month ? compiler version string changes so system wants to recompile. but maybe internal representation of precomps do not change or can be abstracted somehow to "relink" or something ? 
[12:52:09] <Woodi> s/technicl reason to recompile modules every month/
[13:01:58] <nine> Short answer is: very, very much. A small, innocent change in the compiler's source code can change things so precompiled code cannot work anymore.
[13:23:13] *** Joins: Oshawott (~archenoth@2604:3d09:681:f00:cce1:27eb:b1e6:5092)
[13:26:37] *** Quits: archenoth (~archenoth@2604:3d09:681:f00:38e8:622c:40fd:396f) (Ping timeout: 240 seconds)
[13:31:37] *** Joins: jjido (~Denis@2a02:c7f:5c91:e700:c4c6:c62c:ab52:6d38)
[14:17:44] *** Joins: dakkar (~dakkar@host-87-21-202-39.retail.telecomitalia.it)
[14:20:34] <dakkar> m: my %a=:1x,:2y,:3z;  sub f(:$x,:$y) { 1 };    say f(|%(%a<x y>:p));
[14:20:35] <camelia> rakudo-moar 552edcb0b: OUTPUT: ¬´1‚ê§¬ª
[14:20:54] <dakkar> is there a prettier way to pass a hash slice as a set of named arguments?
[14:26:51] *** Joins: sena_kun (~sena_kun_@static-84-42-198-52.net.upcbroadband.cz)
[14:28:40] <lizmat> dakkar: if you have control of sub f:
[14:28:56] <lizmat> ah, no.. :-(
[14:29:32] <dakkar> were you trying sub f(*%named) ?
[14:29:37] <lizmat> yeah
[14:29:51] <lizmat> or even sub f(%named)
[14:30:04] <lizmat> but you're interested in the caller side  :-)
[14:30:35] <dakkar> f(%named) makes it a bit hard to set different type constraints on the different parameters üòú
[14:32:04] <moon-child> sub f(%named where .<y> ~~ T)
[14:32:37] <dakkar> sure, that's why I said "a bit hard"
[14:33:24] <dakkar> oh well, I'll probably spell it out the long way, to make the call clearer
[14:35:29] <dakkar> different question: what's the reason for not supporting something like `sub f(Str|Int $x)` ?
[14:35:59] <dakkar> (I actually wanted `Any:U|Int:D()`, which may have different implementation problems)
[14:39:25] <moon-child> I'm not sure what that would mean, actually
[14:39:27] <moon-child> (the latter, that is)
[14:39:40] <moon-child> does that mean: convert it to an Int:D if you can, otherwise leave it as Any:U?
[14:39:57] <moon-child> or: if it's defined, then it must be Int:D(); if it's undefined, then it can be Any:U?
[14:40:48] <dakkar> yes
[14:40:55] <moon-child> which?
[14:42:12] <lizmat> m: subset StrOrInt of Cool where * ~~ Str | Int; sub a(StrOrInt:D $a) { dd }; a 42; a "foo"
[14:42:13] <camelia> rakudo-moar 552edcb0b: OUTPUT: ¬´sub a(Cool:D $a where { ... })‚ê§sub a(Cool:D $a where { ... })‚ê§¬ª
[14:42:57] <lizmat> I guess eventually a sig of sub a(Str|Int $a) could be syntactic sugar for that
[14:44:14] <dakkar> moon-child: I'm not sure I see the difference between the two things you wrote‚Ä¶
[14:45:24] <dakkar> lizmat: I was under the impression that `Foo $x` was generally nicer to the dispatcher/optimiser/introspection than `$x where Foo`
[14:46:07] <dakkar> (also, coercions and `where` don't seem to play very well together)
[14:46:15] <moon-child> dakkar: supposing there were some undefined type which could be implicitly converted to Int:D
[14:46:19] <lizmat> pre new-disp the overhead was ginormous if you used "where"
[14:46:29] <dakkar> moon-child: ooh, right, of course
[14:46:35] <moon-child> would it fall into the Any:U bucket, on account of being undefined, or into the Int:D() bucket on account of being converted?
[14:46:38] <lizmat> it's one of new-disp's features that that has become a lot less
[14:47:00] <moon-child> also remember that by convention | is not short-circuiting and || i
[14:47:07] <dakkar> moon-child: multi f(Any:U);multi f(Int:D()); ‚Üê do the same as that?
[14:47:45] <dakkar> lizmat: very good to know (and many thanks to jnthn)
[14:47:46] <moon-child> in that case it depends on the order of definition.  But I assume that || is short-circuiting and | is not, so I find that inconsistent
[14:48:12] <dakkar> moon-child: you're right
[14:49:50] <moon-child> that said a short-circuiting (aka lazy) junction would be an interesting idea
[14:50:42] <dakkar> in the end I wrote `proto f($x) { my code }; multi f(Any:U) {}; multi f(Int:D()) {}`
[14:50:48] <lizmat> junction collapse is already short-circuiting
[14:53:58] <moon-child> m: say so none lazy <x y>.map(&say)
[14:53:58] <camelia> rakudo-moar 552edcb0b: OUTPUT: ¬´x‚ê§y‚ê§False‚ê§¬ª
[14:54:33] <moon-child> lizmat: I mean something that would avoid printing 'y' in the above
[14:55:16] <lizmat> m: say so none lazy <x y>.first(&say)
[14:55:17] <camelia> rakudo-moar 552edcb0b: OUTPUT: ¬´x‚ê§No such method 'lazy' for invocant of type 'Str'.  Did you mean any of‚ê§these: 'any', 'say'?‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª
[14:55:24] <lizmat> m: say so none <x y>.first(&say)
[14:55:24] <camelia> rakudo-moar 552edcb0b: OUTPUT: ¬´x‚ê§False‚ê§¬ª
[14:55:59] <moon-child> sure, but that's because of first, not none
[14:58:11] <lizmat> Hmmm...  
[14:59:19] <lizmat> the problem with this is that none() currently will need to build the Junction, before the "so" can collapse it
[15:00:01] <moon-child> yeah.  I'm imagining a 'none-lazy(...)' sort of thing, analogous to [...]
[15:00:12] <moon-child> (or just none(...), print it the same way)
[15:02:01] *** Quits: jjido (~Denis@2a02:c7f:5c91:e700:c4c6:c62c:ab52:6d38) (Quit: My MacBook Air has gone to sleep. ZZZzzz‚Ä¶)
[15:03:19] <dakkar> https://www.thenautilus.net/cgit/media-control/tree/lib/App/MediaControl/DB.rakumod#n95 I got what I wanted thanks to `proto` and a probably-weird use of `{*}`
[15:04:19] <lizmat> m: sub sonone(Iterable:D $i) { my $iter := $i.iterator; until (my $pulled := $iter.pull-one) =:= IterationEnd { return False if $pulled }; True }; say sonone ^10   # moon-child 
[15:04:19] <camelia> rakudo-moar 552edcb0b: OUTPUT: ¬´False‚ê§¬ª
[15:06:25] *** Joins: jjido (~Denis@2a02:c7f:5c91:e700:c4c6:c62c:ab52:6d38)
[15:07:04] <lizmat> hmmm... I guess a Junction could have lazy eigenstates   
[15:24:27] *** Quits: synthmeat (~synthmeat@user/synthmeat) (Quit: WeeChat 3.0)
[15:25:13] *** Joins: synthmeat (~synthmeat@user/synthmeat)
[15:29:05] *** Joins: frost (~frost@user/frost)
[15:37:01] *** Quits: reportable6 (rep-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[15:38:01] *** Joins: reportable6 (rep-able@2001:41d0:2:5eb5::)
[15:44:15] *** Quits: sena_kun (~sena_kun_@static-84-42-198-52.net.upcbroadband.cz) (Quit: Leaving)
[15:45:43] *** Joins: sena_kun (~sena_kun_@static-84-42-198-52.net.upcbroadband.cz)
[15:45:53] *** Quits: sena_kun (~sena_kun_@static-84-42-198-52.net.upcbroadband.cz) (Remote host closed the connection)
[15:49:32] *** Joins: sena_kun (~sena_kun_@static-84-42-198-52.net.upcbroadband.cz)
[16:14:13] *** Quits: Kaiepi (~Kaiepi@216.208.243.198) (Ping timeout: 240 seconds)
[16:23:25] *** Joins: Kaiepi (~Kaiepi@216.208.243.103)
[17:23:25] *** Quits: linkable6 (lin-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[17:23:25] *** Quits: evalable6 (eva-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[17:25:22] *** Joins: linkable6 (lin-able@2001:41d0:2:5eb5::)
[17:57:49] *** Quits: sena_kun (~sena_kun_@static-84-42-198-52.net.upcbroadband.cz) (Quit: Leaving)
[18:26:30] *** Joins: evalable6 (eva-able@2001:41d0:2:5eb5::)
[18:30:15] *** Joins: sena_kun (~koto@78.44.247.181)
[18:31:02] *** Quits: sena_kun (~koto@78.44.247.181) (Remote host closed the connection)
[18:37:43] *** Joins: Sgeo (~Sgeo@user/sgeo)
[18:45:00] *** Joins: jgaz (~jgaz@2600:8805:d980:7620::9e0)
[19:45:00] *** Quits: linkable6 (lin-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[19:45:00] *** Quits: evalable6 (eva-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[20:06:31] *** Joins: monkey_ (~user@190.104.116.153)
[20:16:20] *** Quits: jgaz (~jgaz@2600:8805:d980:7620::9e0) (Quit: Leaving)
[20:32:36] *** Joins: holyghost (~holyghost@2a02:a03f:64c8:9200:ad71:a2b4:70bd:cbf2)
[20:33:19] <holyghost> re
[20:33:44] <holyghost> BFI
[20:35:09] * holyghost is a bit drunk but had a nice vacation
[20:35:14] <holyghost> https://www.mediafire.com/file/eois5z8xluuwxtm/pycoffeebot-openbsd-0.2.0.tar.gz/file
[20:35:24] <holyghost> An irc bot system from me
[20:37:08] <holyghost> I'm trying out NLP (== natural language processing) with ANNs :-)
[20:45:03] *** Joins: sena_kun (~koto@94.142.239.45)
[20:47:25] *** Joins: linkable6 (lin-able@2001:41d0:2:5eb5::)
[21:06:32] *** Joins: TheAthlete (~TheAthlet@176.96.230.93)
[21:09:05] *** Joins: jgaz (~jgaz@2600:8805:d980:7620::9e0)
[21:09:36] *** Quits: discord-raku-bot (~RakuIRC@ip5f5ab74b.dynamic.kabel-deutschland.de) (Remote host closed the connection)
[21:10:04] *** Joins: discord-raku-bot (~RakuIRC@ip5f5ab74b.dynamic.kabel-deutschland.de)
[21:25:34] *** Quits: discord-raku-bot (~RakuIRC@ip5f5ab74b.dynamic.kabel-deutschland.de) (Remote host closed the connection)
[21:25:47] *** Joins: discord-raku-bot (~RakuIRC@ip5f5ab74b.dynamic.kabel-deutschland.de)
[21:36:13] *** Quits: sena_kun (~koto@94.142.239.45) (Quit: Leaving)
[21:36:19] *** Joins: atroxaper (~atroxaper@178.49.194.113)
[21:36:27] <atroxaper> Hello, #raku
[21:36:29] <tellable6> 2021-12-21T21:06:15Z #raku <SmokeMachine> atroxaper maybe FCO is not that smart‚Ä¶ :) but Red has :ver there because it‚Äôs updated by Mi6 and I could be wrong but I think that broke mi6 release when I removed that‚Ä¶
[21:38:01] *** Joins: sena_kun (~koto@94.142.239.45)
[21:38:19] *** Quits: reportable6 (rep-able@2001:41d0:2:5eb5::) (Remote host closed the connection)
[21:40:46] <atroxaper> .tell ugexe, please, tell me, is there a legal way to know which module what to 'use' from a custom CompUnit::Repository's need or so? An argument only tell us about what to load, but who needs it?
[21:40:47] <tellable6> atroxaper, I'll pass your message to ugexe
[21:45:40] <ugexe> who says `use` comes from a module?
[21:45:54] <ugexe> -e 'use Foo' and scripts `use Foo` as well
[21:47:12] <atroxaper> If it is script - ok. But if it was another CompUnit.
[21:47:40] *** Joins: evalable6 (eva-able@2001:41d0:2:5eb5::)
[21:50:54] <ugexe> I'm not even sure what that would mean
[21:51:26] <ugexe> examine the call stack i guess
[21:51:41] <ugexe> that will give you a file anyway
[21:55:46] *** Quits: monkey_ (~user@190.104.116.153) (Remote host closed the connection)
[21:59:50] *** Joins: monkey_ (~user@190.104.116.153)
[22:00:55] <atroxaper> ugexe: Now I will explain a little more. I found that if we don't write a version in "use", then the newest version from the repository will be used. Regardless of what is written in META 6.json, of course. I believe that firstly it is inconsistent, and secondly it is a security hole. I can upload a module to an Ecosystem with a module, for example, a Zef::Client module with a version higher than the real zef. If somebody install the module
[22:00:55] <atroxaper>  than zef will use it instead of its Zef::Client. Because the zef modules did not specify the version in the usage statements.
[22:01:49] *** Quits: dakkar (~dakkar@host-87-21-202-39.retail.telecomitalia.it) (Quit: e via, verso nuove avventure)
[22:04:06] <lizmat> atroxaper: the META just indicates what is needed according to the developer.  If the developer then just doesn't care what it loads... well...  that's their problem  :-)
[22:04:29] <lizmat> at least, that's the current situation
[22:05:30] <lizmat> that's why I *always* specify versions in my -use- statements
[22:05:53] <atroxaper> ugexe: Moreover, even within the same module, without dependencies, old versions of modules will use the new versions of their submodules, although they were tested only among the old version during installation.
[22:05:57] <lizmat> now I agree we have room for improvement here
[22:06:05] <ugexe> so pin your use statements
[22:06:12] <lizmat> atroxaper: what ugexe  says :-)
[22:06:37] <ugexe> there is no consistent way to derive what versions to use from META6.json depends because you can very well depend on multiple version of the same module
[22:08:20] <atroxaper> lizmat: I no do not agree that if is their problem. It is security problem. We cannot to force all developers specify version in use statements. But we want to use their module. I think we need to base on META6 information in case of 'empty' use version.
[22:10:23] <ugexe> misusing dependencies is indeed a developer problem even if we wish it wasnt
[22:10:46] <atroxaper> ugexe: META6 describes what we need to be installed for proper functioning of the module. When we need to 'use' a concrete version then we specify it. If we omit it, then use META6 info.
[22:11:03] <ugexe> "because you can very well depend on multiple version of the same module"
[22:11:07] <ugexe> how do you solve this?
[22:11:16] <ugexe> (note this is only the most very basic problem)
[22:12:06] <lizmat> ugexe: if you depend on multiple versions of a module, you need to be specific in your use statement
[22:12:22] <ugexe> thats pretty inconsistent
[22:12:55] <lizmat> I mean if code depends on Foo:ver<1.0>  *and* Foo:ver<2.0>, then a "use Foo" in a module of that distro, could be a compilation error?
[22:13:06] <ugexe> how do you declare you literally want any version?
[22:13:13] <ugexe> and not for META6.json to do magic?
[22:13:23] <lizmat> Foo:ver<*> afaik ?
[22:13:37] <ugexe> which is the same as use Foo...
[22:13:53] <atroxaper> Any version - omit it at all in use statement.
[22:13:54] <lizmat> well, yes, at the moment
[22:14:22] <lizmat> but with :ver<*> you're *specific* about accepting *any* version
[22:14:37] <ugexe> well anyway I'm completely against inconsistencies so good luck trying to convince me of anything i guess
[22:14:45] <atroxaper> lizmat: yes. You are right.
[22:17:07] <atroxaper> ugexe: which inconsistencies? META6 is obligatory elemnt of module. I specify dependency version there. And think that I do not need to specify the version in *all* use statement. Because I need to literally do in in *all* statement.
[22:17:56] <ugexe> that `use` does different things
[22:18:31] <ugexe> oh use will fill out your version unless you do this and then it instead does this, but you can also declare things like this to workaround that and get things to do this
[22:19:55] <atroxaper> If I update a version of dependency, i need to update a version literal in *all* use statements. It is consistent but it is very uncomfortably.
[22:20:22] <ugexe> you could very well write something to do it for you
[22:20:27] *** Quits: monkey_ (~user@190.104.116.153) (Ping timeout: 268 seconds)
[22:20:35] <ugexe> which is way more reasonable than being in rakudo core because you can actually use dependencies to do it
[22:20:48] <ugexe> rakudo doesn't know how to e.g. parse complicated depends 
[22:21:55] *** Joins: monkey_ (~user@190.104.116.153)
[22:22:54] <atroxaper> ugexe: One more time. I can override Zef::Client right now on foreigner host. And do anything on someone else's host instead of Zef::Client work.
[22:23:18] <ugexe> yes im quite familiar with how it works https://github.com/ugexe/zef/pull/334
[22:27:10] <atroxaper> ugexe: exactly! After this patch, I won't be able to replace the Zef::Client, but I can replace almost any module in the ecosystem. We won't be able to force all developers to write START my $VER... in each file.
[22:27:37] <ugexe> we could
[22:27:50] <ugexe> an ecosystem doesn't have to accept a distribution
[22:28:01] <atroxaper> But we already force them to write META6.json. We just need to ask them to specify version and auth for each depends.
[22:28:02] <ugexe> a user doesn't have to use a specific ecosystem
[22:29:33] <ugexe> we don't force them to write META6.json because they can use -Ilib
[22:29:48] <atroxaper> And do something like BEGIN my $VER... automatically. It will not crash anything but fix a lot of things.
[22:31:17] <ugexe> i would suggest being explicit until someone figures out how to implement all that in a consistent way
[22:31:24] <atroxaper> If I use -Ilib I know what I do. But if I use official ecosystem, I what to safe installation of safe modules.
[22:31:54] <ugexe> ecosystems are configurable, you're free to use whatever ecosystem your e.g. business allows/trusts
[22:32:18] <ugexe> if some module doesn't live up to some ecosystems standard that isn't really isn't something to be solved by the language
[22:35:52] <atroxaper> ugexe: Ok. Then. Let me rephrase. Now the language state allows  siply achieve dependency hell situation. Raku has very good system with auth, ver and api versioning but it is not defend us from dependency hell. There is no Ecosystem word in my description now.
[22:36:58] <ugexe> its not intended to avoid dependency hell. if anything our entire system welcomed it by making everything overridable/configurable/supercedable/etc
[22:37:22] <ugexe> even still, i would hardly classify our situation as what most people refer to as dependency hell
[22:38:17] <ugexe> being explicit about your dependencies everywhere is the classic way to avoid dependency hell
[22:39:07] <atroxaper> 1. I install module A, depends B:ver<1>. A works well. I install Module C depends B:ver<2>. A stopped working.
[22:39:28] <ugexe> if i write a module that doesnt work right that isnt the language fault
[22:39:54] <ugexe> we are looking for a solution to allow existing sloppy patterns to DTRT some of the time
[22:39:55] <atroxaper> Modules A,B and C is not my. 
[22:40:19] <ugexe> so dont use the broken modules
[22:40:34] <ugexe> no one forces you to use code that is written in a way that doesnt work
[22:41:15] <ugexe> if a given ecosystem had e.g. quality control Module A might not even be indexed at all
[22:43:06] <atroxaper> Are you serious? Ok. Then we need to ask all developers who what that other people use their work, write BEGIN my $VER... my $A-VER... my $B-VER.... It is so Raku, I mean easy.
[22:44:14] <ugexe> well like i said, you are welcome to attempt to implement what you suggest
[22:45:45] <ugexe> the hardest part will be figuring out how to do this without reading the META6.json when loading modules
[22:47:11] <ugexe> otherwise `use` statements will need to read a file and parse it to json which in the past has been too much of a performance penalty to consider doing
[22:48:06] <atroxaper> ugexe: I propose the following algorithm. Firstly, in CompUnit::Repository we need to have an access to caller CompUnit if it is. If we processing use statement with ver then load it. If we processing use statement with * then load higher version. if we processing omit version, then read META6 and understand which version the module whanted and load it.
[22:49:12] <ugexe> well part of my point was that is all so complicated to do that anything short of an implementation is probably moot
[22:49:51] <atroxaper> We can store META6 in some binary format. Or better write versions of module(file) dependencies in precomp file.
[22:50:36] <ugexe> I don't think anyone would stop you from doing those things
[22:54:40] <atroxaper> ugexe: I really ask you to consider the feasibility of these changes within the RSC. I think this is very, very important for the language.
[22:55:08] <ugexe> i have been commenting on the *feasibility* specifically
[22:55:45] <ugexe> thats why im telling you that if you think it is feasible that you should champion it and implement it
[22:56:01] <lizmat> atroxaper: again, what ugexe said  :-)
[22:56:19] <lizmat> but also, please make a problem solving issue for this
[22:56:26] *** Quits: jgaz (~jgaz@2600:8805:d980:7620::9e0) (Quit: Leaving)
[22:56:47] <atroxaper> lizmat: will do.
[22:56:52] <lizmat> I also have some ideas about the situation, and I think these are best discussed  / developed in an issue, rather than on IRC
[23:03:03] <atroxaper> lizmat: not so always :) https://github.com/lizmat/Hash2Class/blob/main/bin/h2c-skeleton#L8
[23:04:17] *** Quits: retupmoca (~retupmoca@2601:404:d100:16d3::1915) (Quit: WeeChat 3.3)
[23:04:39] <lizmat> atroxaper:  hehe   , ok, almost always  :-)
[23:22:06] <ugexe> fwiw if I were doing raku apps in production I would a) be using a local ecosystem/darkpan with vetted distributions only b) installing distributions in application specific locations instead of global locations
[23:27:15] <atroxaper> ugexe: I think Python's virtual environment is a crutch. I wouldn't want that for Raku.
[23:29:12] <atroxaper> Today I found --contained flag in zef and this is just the beginning.
[23:29:41] <ugexe> only problem is there is no way to remove the default site/home repos
[23:30:24] <ugexe> i.e. no way to say "only use this one specific repository and none of the defaults"
[23:31:00] <atroxaper> Custom CompUnit::Repository could hide site/home repos, no?
[23:31:37] <ugexe> yeah that would probably work
[23:31:55] <atroxaper> CompUnit::Repository::Barrier :)
[23:32:53] <ugexe> but it would probably be useful as a core thing so you can do `RAKUDO_DEFAULT_REPOS="" raku -I. t/my-test.t`
[23:33:13] <ugexe> (which would only use the . repo)
[23:34:03] <ugexe> then again in a test you'd want `use Test` which would mean it would have to be `RAKUDO_DEFAULT_REPOS="perl" raku -I. t/my-test.t`
[23:34:24] <ugexe> s/perl/core
[23:37:40] *** Quits: mexen (uid495612@user/mexen) (Quit: Connection closed for inactivity)
[23:40:49] *** Joins: reportable6 (rep-able@2001:41d0:2:5eb5::)
[23:41:27] *** Quits: atroxaper (~atroxaper@178.49.194.113) ()
[23:49:05] *** Joins: Skarsnik (~Skarsnik@91-170-31-218.subs.proxad.net)
[23:54:44] <spacekookie> Hey! Another grammar question >.> I extended the one I posted a few days ago to have "scopes" (which themselves are a set of lines with stuff in them). But I think something is not being evaluated properly because the % binding at the bottom is failing: https://paste.rs/woZ.pl
[23:55:23] <Skarsnik> grammar are black magic! xD
[23:57:43] *** Quits: monkey_ (~user@190.104.116.153) (Remote host closed the connection)
[23:59:06] *** Quits: euandreh (~euandreh@191.181.59.160) (Ping timeout: 245 seconds)
[23:59:31] *** Joins: monkey_ (~user@190.104.116.153)
