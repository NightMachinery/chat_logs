[00:00:17] *** Joins: Tuplanolla (~Tuplanoll@91-159-69-98.elisa-laajakaista.fi)
[00:09:27] *** Quits: gdd (~gdd@129.199.146.230) (Quit: WeeChat 3.3)
[00:11:00] *** Quits: gravicappa (~gravicapp@145.255.0.191) (Ping timeout: 240 seconds)
[00:17:39] *** Joins: gdd (~gdd@129.199.146.230)
[00:21:57] *** Quits: mro (~mro@port-92-195-185-146.dynamic.as20676.net) (Remote host closed the connection)
[00:23:12] *** Joins: mro (~mro@2002:5cc3:b992:0:8c1b:6917:8f20:3a5f)
[00:34:37] *** Joins: quartz (~quartz@user/quartz)
[00:59:35] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[01:03:38] *** Quits: mro (~mro@2002:5cc3:b992:0:8c1b:6917:8f20:3a5f) (Ping timeout: 250 seconds)
[01:05:24] *** Quits: hyphen (~hyphen@156.208.202.50) (Ping timeout: 240 seconds)
[01:14:30] *** Joins: oriba (~oriba@dynamic-078-054-159-212.78.54.pool.telefonica.de)
[01:18:12] <companion_cube> ahah damn, atdgen is broken since the last menhir release
[01:19:40] <quartz> Hello, can someone please explain the syntax behind "val xor : bool * bool -> bool = <fun> from this image? https://i.ibb.co/R2tqRGs/image.png
[01:20:34] <d_bot_> <NULL> `val <ident> : <type> = <value printed the best it can be>` ?
[01:21:16] <quartz> Huh?
[01:21:52] <quartz> Is p a variable in this case?
[01:21:52] <d_bot_> <NULL> Not sure what "syntax" you want explained
[01:22:59] <d_bot_> <NULL> `let <id> <arg1> ... <argn> = <expr>` is sugar for `let <id> = fun <arg1> ... <argn> -> <expr>`, so variable or formal argument, whichever you want to call it
[01:24:03] <quartz> Hmmm, OK.
[01:38:40] <sleepydog> the syntax highlighted in red is distinct. in this case, it's the ocaml interpreter's description of the value defined in the preceding expression. it happens to match OCaml's syntax for module signatures
[01:38:58] <d_bot_> <cemerick> FWIW, at least according to opam stats, lwt is used by ~6x more packages than async. JS keeps on with async for their own (probably good) reasons, but I think that kind of lopsided usage denotes a "winner"
[01:40:10] <d_bot_> <NULL> sleepydog: Only if you disregard `= <fun>` though
[01:40:30] <sleepydog> ah, yes, good catch
[01:41:50] <d_bot_> <cemerick> every language community has competing implementations satisfying a similar set of functionality, even those that include an implementation in their standard libraries. Competition (even leading to schisms in integration) is a sign of community size and health, not the opposite IMO
[01:43:25] <sleepydog> I think I generally agree with cemerick, but I always get a sense of FOMO when I'm forced to choose between two implementations. What if I made the wrong choice?
[01:44:16] <d_bot_> <VPhantom> Personally I see competition in a very small community as too expensive, whereas I see it as healthy in large communities with ample man-hours to invest. Since I have chosen Lwt, I will not consider using packages that use Async. That's an unfortunate fragmentation of an already small community.
[01:44:27] <d_bot_> <Anurag> There is a fair bit of async code that will never be seen on opam. Multiple industrial users (not Janestreet) use async.
[01:45:04] <sleepydog> It would be nice if some core types were defined in the stdlib, and then lwt/async/etc just provided implementations of those types, and library authors only worked with those types and didn't have to care about what concurrency runtime their callers used
[01:45:05] <d_bot_> <cemerick> absolutely granted, but we can only evaluate that which is publicly known
[01:45:09] <d_bot_> <VPhantom> (Luckily a lot of packages go through the extra trouble to support both.)
[01:45:35] <sleepydog> but I think it was said earlier, it's very hard to define the right abstractions, as everything has a tradeoff
[01:45:38] <d_bot_> <VPhantom> That would be lovely @sleepydog.
[01:46:38] <sleepydog> I like where gasche is trying to push the eio discussion towards basic questions, like how to block, how to cancel, etc.
[01:46:52] <d_bot_> <Anurag> @sleepydog: types are not the only thing that differs in async and lwt though. They have different semantics around binds, and very different approaches to error handling.
[01:52:32] <sleepydog> I like to think that those differences could remain as they are by finding common ground at a lower level. But I'm not well versed enough in either library.
[01:53:43] <d_bot_> <cemerick> an analogue situation would be something like e.g. web frameworks. It seems obviously good that there are multiple, and surely  more to come, and at a certain point of adoption, there will be framework-specific extension libraries that aren't easily portable to others. Why is that situation different from other categories of libraries/frameworks?
[01:53:56] <d_bot_> <cemerick> (he asks semi-rhetorically ðŸ™ƒ )
[01:55:01] <sleepydog> I think web frameworks are easier to compose with each other, though, so the duplication of effort is not as tragic.
[01:55:56] <d_bot_> <cemerick> tell that to the rails and merb folks some years back
[01:56:58] <d_bot_> <cemerick> concretely, there's all sorts of niggly details in a web framework (streaming vs wholesale response generation, for example) that make having a unitary set of abstractions pretty challenging
[02:13:49] *** Quits: quartz (~quartz@user/quartz) (Ping timeout: 256 seconds)
[02:14:35] *** Quits: dextaa_ (~dextaa@user/dextaa) (Remote host closed the connection)
[02:17:31] *** Quits: rgrinberg (~textual@2806:101e:7:70b6:a1e9:5294:11ab:484a) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[03:08:04] <companion_cube> Even the basic types are not shared
[03:09:00] *** Quits: Tuplanolla (~Tuplanoll@91-159-69-98.elisa-laajakaista.fi) (Ping timeout: 240 seconds)
[03:09:28] <companion_cube> The problem with async libraries is that they're so fundamental that there's a whole ecosystem on top of each
[03:10:26] <companion_cube> Redis clients, db connectors, graphql stuff, all sorts of protocols, are all dependent on the basic underlying concurrency library
[03:10:57] <companion_cube> If we had at least a standard future type, we could hope for better interop, but alas it never happened
[03:21:51] *** Quits: oriba (~oriba@dynamic-078-054-159-212.78.54.pool.telefonica.de) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
[03:25:26] *** Quits: Haudegen (~quassel@178.115.237.87.static.drei.at) (Ping timeout: 272 seconds)
[03:36:56] *** Joins: quartz (~quartz@user/quartz)
[03:40:35] <quartz> Sorry for asking this again, but I have let square x = x * x;;   What is the significance of val square : int -> int = <fun>
[03:41:26] <quartz> Specifically, what is the -> used for here?
[03:45:01] <companion_cube> Function type
[03:45:16] <companion_cube> Int to int
[03:46:16] <quartz> So the function accepts an int and returns an int?
[03:46:25] <companion_cube> Yep
[03:47:23] <quartz> So the -> has no significance in OCaml programming specifically? Like it's not an operator or anything
[03:47:56] <olle> It does
[03:48:13] <olle> It's the difference between type level and value level, I think
[03:48:52] * olle zzz
[03:49:27] <d_bot_> <NULL> It depends what you mean with "significance"
[03:49:30] <d_bot_> <Pim> Yep -> is a function at type level
[03:50:19] <quartz> OK thanks. I'm new obviously to OCaml
[03:50:21] <d_bot_> <NULL> It is used as the function type operator, in type expressions, and is also part of the `fun <pat>* -> <expr>` syntactical construct for lambdas
[03:53:02] *** Quits: olle (~olle@i5E866D84.versanet.de) (Ping timeout: 240 seconds)
[04:00:58] *** Quits: vicfred (~vicfred@user/vicfred) (Quit: Leaving)
[04:08:10] *** Quits: gentauro (~gentauro@user/gentauro) (Read error: Connection reset by peer)
[04:13:37] *** Joins: gentauro (~gentauro@user/gentauro)
[04:47:10] *** Joins: humasect (~humasect@2001:1970:57e0:4100::1ae0)
[04:47:24] *** Quits: humasect (~humasect@2001:1970:57e0:4100::1ae0) (Read error: Connection reset by peer)
[04:58:31] <quartz> Can someone explain this code? https://bpa.st/DSNQ
[04:58:53] <quartz> Why are they returning first by using ->
[04:59:21] <d_bot_> <NULL> I forgot this construction when listing off uses of `->`
[05:00:31] <d_bot_> <NULL> I can't really tell you "why", I don't know what the function should do
[05:00:39] <quartz> d_bot_: Why are you messages preceded by <NULL>
[05:01:06] <d_bot_> <NULL> NULL is my name, dbot is because it's the Discord bridge
[05:01:44] <quartz> You're communicating through IRC via Discord?
[05:02:01] <d_bot_> <NULL> Yeah, the channels are bridged by a bot
[05:03:05] <quartz> Oh nice. why not just use an IRC client?
[05:03:09] <quartz> weechat is nice
[05:07:30] <d_bot_> <NULL> Not all channels of the Discord are bridged (only one actually) plus I am on a bunch of other Discord servers but no other IRC ones
[05:11:45] <quartz> d_bot_: OK, sorry to bother you again, but can you explain line 4 of this code? https://bpa.st/HA3A
[05:12:53] <quartz> It's trying to add hd (the head of the list), to the tail of the list (tl) and return the head plus another call to sum?
[05:15:57] <d_bot_> <NULL> As I said, *NULL* is my name
[05:16:28] <d_bot_> <NULL> How much do you know about pattern matching ?
[05:16:41] <d_bot_> <NULL> I find lists aren't really the best way to introduce them
[05:18:04] <quartz> NULL: I'm new to pattern matching, it's something that is not seen in Java or C
[05:18:52] <d_bot_> <NULL> I guess this https://ocaml.org/learn/tutorials/data_types_and_matching.html should be a good way to learn about it
[05:20:49] <Corbin> quartz: In Java and C, there are switch-statements, right? We can take certain values, like unsigned ints, and compare them to see if they're 0, or 1, or 2, or etc.
[05:22:08] <quartz> Corbin: Right.
[05:22:12] <Corbin> In OCaml, we can switch, or "match", on other values too. In this example, we're examining a list. A list is either `x :: xs` or `[]`, and that's why those operators show up as patterns.
[05:22:58] <Corbin> The idea is that, in an expression, something like `x :: xs` builds a list; so in a pattern, it should un-build a list somehow.
[05:27:20] <quartz> Corbin: I don't understand how you can match 'l' with hd :: tl or what that even means.
[05:28:53] <Corbin> quartz: Well, let's go in the other direction first. Suppose I said something like `let l = hd :: tl in ...` this means that we're taking two values `hd` and `tl`, and making a new value `l` which glues them together.
[05:28:56] <d_bot_> <NULL> Read the link I gave and you should understand hopefully
[05:29:20] <d_bot_> <NULL> NB: `(::)` is an infix constructor
[05:30:10] <Corbin> Going in the other direction, `match l with | hd :: tl -> ...` means that we're starting with a value `l`, and we're going to pull it apart into two values `hd` and `tl` which were glued together before. (And maybe this fails, because not all lists have a head! Just like a switch statement, OCaml will try each of the patterns in sequence.)
[05:30:52] <Corbin> Yes, as NULL says, the `::` operator is actually acting as a constructor. Pattern-matching proceeds by looking at how a value was constructed; it lets us see which constructor was used.
[05:31:48] <sleepydog> quartz: if you are familiar with python, it is similar to destructuring assignment in python, where you can do a, b, c = some_list, except here it's being used conditionally
[05:33:22] <Corbin> sleepydog: Python recently gained a pattern-matching feature: https://www.python.org/dev/peps/pep-0634/ It's good to compare apples to apples.
[05:33:22] <quartz> Corbin: OK thanks for the explaination
[05:33:56] <Corbin> quartz: Does it make sense how this would work with your own custom datatypes?
[05:33:58] <quartz> So let l = hd :: tl will make l into a list [hd; tl] ?
[05:34:02] <sleepydog> Corbin: not everyone is familiar with that, though. it's a pretty new feature.
[05:35:02] <quartz> Corbin: My own custom datatypes? You mean the example?
[05:35:18] <quartz> Yeah sorry not familiar wit python, just C and Java mainly.
[05:35:56] <companion_cube> https://paste.isomorphis.me/X2x for example
[05:36:09] <companion_cube> first, a simple switch on integers
[05:36:24] <companion_cube> then, matching on tuples (a bit like destructuring in python)
[05:36:29] <Corbin> quartz: NULL linked to a good tutorial page.
[05:36:33] <companion_cube> then, your own custom type, where you have a choice
[05:37:10] <quartz> Corbin: I'll take a look
[05:37:27] <quartz> companion_cube: Thanks for the example.
[05:38:24] <companion_cube> this kind of "sum type" (of which lists are an instance) is an important part of why OCaml is so powerful
[05:39:27] <d_bot_> <NULL> If you're familiar with C, sum types are C union where the compiler is the one who manages which case we're in (through constructors)
[05:39:55] <companion_cube> union + an enum as the tag, mostly
[05:40:02] <companion_cube> all in a type safe way
[05:40:20] <d_bot_> <NULL> C has enums ?
[05:40:24] <companion_cube> sure
[05:40:24] <sleepydog> heh
[05:40:28] <companion_cube> they're basically ints, but yes
[05:40:51] <d_bot_> <NULL> Didn't know, but I never went deep into C anyway
[05:40:55] <companion_cube> (oh and also the switch falls through by default, which is hilariously bad)
[05:41:11] <sleepydog> it doesn't have "real" enums, they're ints. so you don't get exhaustiveness checks
[05:41:23] <companion_cube> yeah
[05:41:24] <sleepydog> though maybe you could come up with the right combination of gcc flags to get it
[05:41:30] <companion_cube> C++ did get proper enums I think
[05:42:06] <sleepydog> since learning ocaml i've been annoyed when i don't have sum types or pattern matching available. so i'm very pleased that python is getting pattern matching
[05:42:09] <d_bot_> <NULL> I know that, and the fact that other languages kept that as standard behaviour is also laughable
[05:42:19] <d_bot_> <NULL> that: fallthrough switches
[05:42:19] <companion_cube> it's slowly evolving, woo
[05:42:27] <companion_cube> see: rust
[05:44:13] <Corbin> Fallthrough was very important to assembly programmers, both for speed, and also because it's what lots of CPUs do by default. Similarly, Python didn't have pattern-matching because the semantics weren't any better than the "tower of if-statements" pattern.
[05:46:37] <d_bot_> <NULL> They could provide fallthrough switches through an additional keyword, but it has so few uses I don't understand why they would not provide regular switch before/at the same time
[05:47:10] <Corbin> Sum types are kind of like a design pattern; there's several different ways to implement them, even if they aren't builtin. In Java, sum types can be emulated with subclasses and the visitor pattern. OCaml (used to? still does?) have special bytecode instructions for working with sum types, to make them faster.
[05:49:26] <companion_cube> @NULL exactly
[05:49:42] <companion_cube> the rare case where you need fallthrough should be opt-in
[05:50:24] <sleepydog> i guess some of the C creators would agree, since that was changed in Go
[05:52:42] <Corbin> sleepydog: That's not unreasonable. We *did* find a construction that depends on it, but it's not common: https://en.wikipedia.org/wiki/Duff%27s_device
[05:53:01] <companion_cube> well there's no overlap, sleepydog, afaik
[05:55:37] <sleepydog> companion_cube: ken thompson was at least tangentially involved
[05:55:54] <quartz> Hello. I'm having trouble understanding what this problem is asking when it says "we allow the caller to define what f describes the sum"
[05:55:58] <quartz> https://bpa.st/PGBA
[05:56:43] <quartz> Why would they want to return a function, when it should return an int?
[05:56:46] <sleepydog> this looks like homework :)
[05:57:55] <quartz> sleepydog: Yes it is.
[05:58:10] <Corbin> quartz: Maybe they mean "which f". They're saying that the caller of psum should get to choose a function f, and psum should call f in order to do its summation work.
[05:58:40] <Corbin> Er, oh, I see. That *is* confusing. They mean that psum should call f, then do a sum, then call f, then do a sum, then call f...
[05:58:45] <sleepydog> that is my interpretation too, the language is a little awkward
[05:59:13] <Corbin> quartz: As a first step, what's the type of psum? Figuring this out will make things a lot easier.
[06:00:02] <Corbin> ...Oh, they gave it away at the bottom. So much for reading comprehension.
[06:00:34] <quartz> Corbin: A function that takes two functions as a arguement?
[06:00:37] <quartz> Yeah I saw that :)
[06:01:13] <d_bot_> <NULL> No it doesn't, it only takes one
[06:01:48] <quartz> Ahhh
[06:01:51] <d_bot_> <NULL> What do you think the type of the addition operator is, and do you understand why ?
[06:01:52] <quartz> Jeez I can't even read
[06:02:24] <d_bot_> <NULL> Or are you familiar with how curried function types are read ?
[06:02:31] <Corbin> quartz: A function and an int. Your TA's parentheses might be a little confusing; it's an instance of a type like `x -> y -> z` which takes two arguments, written like `x -> (y -> z)`.
[06:02:31] <quartz> psum: (int -> int) -> (int -> int) means it takes a function that returns an int and returns a function that returns an int?
[06:02:58] <quartz> NULL: I need to review those. This is the most confusing programming language ever, sorry.
[06:03:14] <d_bot_> <NULL> You aren't mentioning the types of the arguments, but that's what it is
[06:03:55] *** Joins: rgrinberg (~textual@2806:101e:7:70b6:a526:824c:9b4d:f939)
[06:04:17] <d_bot_> <NULL> This is directly inherited from Î»-calculus, it doesn't fall out of nowhere
[06:06:56] <quartz> Corbin: I'm not sure what you mean by that.
[06:13:10] <quartz> I don't understand why you'd need two functions here. It just starts at 1, multiplys it by itself, adds 1 to it, multiplies it by itself, and repeats the process all the way up to n which is the value passed into the function.
[06:14:33] <d_bot_> <NULL> I think you're expected to program `Î»f Î»n. Î£_{i=1}^n f(i)`
[06:15:20] <sleepydog> it is a contrived question. of course you could solve the problem with 1 function. but they must want you to become familiar with functions that build other functions.
[06:16:07] <sleepydog> examples where it is actually more useful could involve more code and become distracting
[06:16:41] <d_bot_> <NULL> One such better example would be a counter (it involves references though)
[06:17:00] <Corbin> quartz: The arrow (->) is right-associative; if you have a type like `x -> y -> z -> w` then it should be read as `x -> (y -> (z -> w))`. OCaml has ways of smoothing over these two different views of (->).
[06:18:15] <sleepydog> Something tells me that pulling back the curtains of how "multiple" args work in ocaml is just going to confuse at this point :)
[06:18:41] <quartz> sleepydog: I'm confused enough as it is.
[06:20:06] <Corbin> quartz: Do you think that you could write this with just one function? It might not be the final answer, but it could help you get there.
[06:20:32] <quartz> Corbin: I can try, but I'm getting tired and angry. I didn't think this would be this hard.
[06:24:08] <Corbin> No worries. It's okay to take a break.
[06:32:03] *** Joins: mbuf (~Shakthi@171.61.250.50)
[06:37:18] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 250 seconds)
[06:43:35] <quartz> Sorry I can't get it, even with a for loop
[06:49:17] <d_bot_> <NULL> In what languages can you do it ?
[06:51:00] <quartz> Java, C
[06:51:07] <quartz> But I need to do it in OCaml
[06:51:23] <d_bot_> <NULL> What would it look like (with no newline because IRC) ?
[06:53:12] <quartz> I'm trying
[06:53:19] <quartz> to do it with a for loop in OCaml
[06:53:32] <sleepydog> can you implement a simpler function that just adds the numbers 1 to n, without the `f` part?
[06:54:25] <d_bot_> <NULL> I'm proposing you to start from another language and work your way to OCaml
[06:55:28] <quartz> Uhhh
[06:55:30] <quartz> I can try
[06:55:38] <quartz> But how is this not working? https://godbolt.org/z/z4rde8cTb
[06:56:51] <d_bot_> <NULL> Local definitions take the shape `let <lvalue> = <expr> in <expr>`
[06:57:23] <d_bot_> <NULL> As opposed to toplevel/module-level definitions that are only `let <lvalue> = <expr>`
[06:58:26] <quartz> So how are you suppose to declare variables in this language?
[06:58:57] <sleepydog> if you are thinking of a variable as something you can modify, you create a reference
[06:59:24] <d_bot_> <NULL> *mutable* variables ? You can't. The only things you can mutate are fields of structs that have been declared mutable
[06:59:50] <d_bot_> <NULL> The most common workaround is using a reference, which behaves very close to a mutable variable
[07:00:27] <d_bot_> <NULL> So you first give yourself a reference `let r = ref 0 in ...` (0: default value, give yours)
[07:00:54] <d_bot_> <NULL> Then you assign to it using `r <- <expr>`
[07:00:58] <quartz> I'm taking notes.
[07:01:19] <d_bot_> <NULL> And you get the contents of it by prefixing a `!` (so `!r` is the contents of `r`)
[07:02:22] <sleepydog> if it's a `ref`, assignment would be `r := ...`
[07:02:50] <d_bot_> <NULL> You won't be able to mix up a reference with a regular int because they don't have the same type: a reference to an int has type `int ref` and not `int`
[07:03:22] <d_bot_> <NULL> sleepydog: oops right, `<-` is field assignment; `(:=)` is the more direct assignment for references
[07:04:35] <quartz> I think I'm going to call it a night, but thank you everyone for your help.
[07:04:46] <quartz> Brain is shutting off, even though I want to continue.
[07:08:37] *** Quits: quartz (~quartz@user/quartz) (Quit: WeeChat 3.4)
[07:11:04] *** Quits: terrorjack (~terrorjac@2a01:4f8:1c1e:509a::1) (Quit: The Lounge - https://thelounge.chat)
[07:12:49] *** Joins: terrorjack (~terrorjac@static.3.200.12.49.clients.your-server.de)
[07:31:54] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Remote host closed the connection)
[07:32:33] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[08:01:41] *** Joins: hsw (~hsw@106.104.103.195)
[08:10:39] *** Joins: gravicappa (~gravicapp@145.255.0.191)
[08:34:23] *** Quits: zebrag (~chris@user/zebrag) (Quit: Konversation terminated!)
[08:34:25] *** Quits: hackinghorn (~hackingho@user/hackinghorn) (Quit: Leaving)
[08:36:57] *** Joins: Haudegen (~quassel@178.115.237.87.static.drei.at)
[09:01:59] *** Quits: mbuf (~Shakthi@171.61.250.50) (Quit: Leaving)
[09:51:58] *** Quits: rgrinberg (~textual@2806:101e:7:70b6:a526:824c:9b4d:f939) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[10:16:45] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Remote host closed the connection)
[10:17:01] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[10:20:59] *** Quits: GreaseMonkey (greaser@user/greasemonkey) (Read error: Connection reset by peer)
[11:03:47] *** Joins: dextaa_ (~dextaa@user/dextaa)
[11:16:44] *** Quits: dextaa_ (~dextaa@user/dextaa) (Remote host closed the connection)
[11:31:32] <d_bot_> <Bluddy> I need to parse a binary file gradually: part of it is LZW compressed, part needs to be interpreted into a record. What's the best way to do this? Currently I'm trying to create a char Seq from the file buffer. When I need to read either a byte or a 16-bit word from the file, I read 2 chars and put them into a Byte, then use get_uint16_le or get_uint8. Any other ideas?
[11:31:33] <d_bot_> <Bluddy> I don't think @companion_cube's Iter can work for this, though I could be wrong.
[11:33:35] <d_bot_> <Bluddy> What I want is:
[11:33:35] <d_bot_> <Bluddy> * The ability to pull bytes out of a byte stream
[11:33:37] <d_bot_> <Bluddy> * The ability to have stages of processing: The LZW decompression is fed to another decompression algorithm. I don't want to manage buffers for this.
[11:33:38] <d_bot_> <Bluddy> * The ability to continue with processing the rest of the byte stream normally after the decompression area is done with
[11:34:07] <d_bot_> <Bluddy> Also, efficiency is not a major consideration here.
[11:49:01] <d_bot_> <orbitz> @Bluddy is the bitstring package still around?
[11:52:30] <d_bot_> <Bluddy> That's a really good idea for parsing headers and such, but it's not a solution for doing things like decompression.
[11:58:39] <d_bot_> <Bluddy> I guess this is where @companion_cube's suggestion to have channels be flexible would fit in
[12:07:24] *** Joins: mbuf (~Shakthi@122.178.120.57)
[12:15:50] <haesbaert> Cstruct doing shifts and so on ?
[12:24:46] *** Joins: olle (~olle@i5E866D89.versanet.de)
[12:51:35] <d_bot_> <tomb> What about mapping the file to a bigstring (i.e. some flavor of bigarray with char elements), and implementing combinators of type `Bigstring.t -> pos:int -> ?len:int -> {pos : int; return : 'a} Result.t` for some value of `'a`. I guess the issue might be that when you enter an LZW context, you might want to consider the stream of data that it produces lazily, which does not compose well with the above...
[13:00:34] <d_bot_> <Bluddy> yeah I'm thinking I want to just create some kind of BufferedStream structure.
[13:01:06] <d_bot_> <Bluddy> we really need an OOP type here
[13:05:21] <d_bot_> <tomb> IIRC, the way cryptokit's `transform`s are modeled (using objects and classes) makes it reasonably palatable to compose transformation. It makes it possible to push / pull elements and abstract nicely the internal buffers. I guess it would be interesting to try and adapt this to your setting.
[13:09:22] <d_bot_> <Bluddy> It's a fairly standard structure. In C++, you have streams as the base classes, and they are inherited by file streams, string streams etc. The user reads or writes to a stream not caring if it's a file or a string or anything else.
[13:10:15] <d_bot_> <Bluddy> We can emulate it with a record of functions and pass in 'self', or we can just use objects.
[13:14:00] <d_bot_> <glennsl> does anyone know of a convenient way to convert rescript to OCaml?
[13:14:23] <d_bot_> <glennsl> `rescript convert` doesn't seem to accept `.res` files
[13:15:17] <d_bot_> <glennsl> I suppose worst case I could manually convert rescript to reason, and then convert reason to OCaml.
[13:23:41] <d_bot_> <glennsl> And while trying to do so I discover that rescript doesn't actually have a valid representation in either OCaml or Reason because it uses reserved keywords and such.
[13:24:01] <d_bot_> <glennsl> Which I guess is a big part of the reason why it split from Reason.
[13:24:05] <d_bot_> <glennsl> SO I guess that answers that.
[13:40:44] *** Quits: Serpent7776 (~Serpent77@90-156-31-193.internetia.net.pl) (Read error: Connection reset by peer)
[13:40:58] *** Joins: mro (~mro@port-92-195-166-117.dynamic.as20676.net)
[13:42:55] *** Joins: Serpent7776 (~Serpent77@90-156-31-193.internetia.net.pl)
[13:43:55] *** Quits: olle (~olle@i5E866D89.versanet.de) (Remote host closed the connection)
[13:55:55] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Ping timeout: 256 seconds)
[13:58:08] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[13:59:36] *** Quits: mro (~mro@port-92-195-166-117.dynamic.as20676.net) (Remote host closed the connection)
[14:05:02] *** Joins: hackinghorn (~hackingho@user/hackinghorn)
[14:17:01] *** Quits: klu (~klu@user/klu) (Ping timeout: 245 seconds)
[14:18:01] *** Joins: klu (~klu@98.247.231.39)
[14:18:01] *** Quits: klu (~klu@98.247.231.39) (Changing host)
[14:18:01] *** Joins: klu (~klu@user/klu)
[14:19:24] *** Joins: mro (~mro@port-92-195-166-117.dynamic.as20676.net)
[14:23:03] *** Quits: mro (~mro@port-92-195-166-117.dynamic.as20676.net) (Remote host closed the connection)
[14:32:17] *** Quits: adanwan (~adanwan@gateway/tor-sasl/adanwan) (Remote host closed the connection)
[14:32:34] *** Joins: adanwan (~adanwan@gateway/tor-sasl/adanwan)
[15:04:46] *** Quits: Haudegen (~quassel@178.115.237.87.static.drei.at) (Quit: Bin weg.)
[15:32:48] *** Quits: hackinghorn (~hackingho@user/hackinghorn) (Remote host closed the connection)
[15:33:12] *** Joins: hackinghorn (~hackingho@user/hackinghorn)
[15:42:40] *** Quits: gahr (~gahr@user/gahr) (Quit: Lost terminal)
[15:59:50] *** Joins: mro (~mro@port-92-195-166-117.dynamic.as20676.net)
[16:03:25] *** Joins: Haudegen (~quassel@91.114.49.10)
[16:13:48] *** Quits: adanwan (~adanwan@gateway/tor-sasl/adanwan) (Remote host closed the connection)
[16:14:03] *** Joins: adanwan (~adanwan@gateway/tor-sasl/adanwan)
[16:26:52] *** Quits: mro (~mro@port-92-195-166-117.dynamic.as20676.net) (Remote host closed the connection)
[16:39:38] *** Joins: bartholin (~bartholin@158.110.70.82)
[16:50:45] *** Joins: olle (~olle@213.61.81.133)
[16:51:45] *** Joins: mro (~mro@port-92-195-166-117.dynamic.as20676.net)
[17:00:39] <d_bot_> <sarna> hey, I'm trying to follow "building git" in ocaml instead of ruby. I'm stuck trying to get zlib to work - is there any *simple* API for zlib in ocaml?
[17:02:20] <d_bot_> <sarna> I tried a couple but they either look like C (camlzip, zlib) or they have a very rigidly typed API that's not documented at all (decompress, carton)
[17:06:55] *** Joins: gahr (~gahr@user/gahr)
[17:08:23] *** Quits: gahr (~gahr@user/gahr) (Remote host closed the connection)
[17:21:02] *** Quits: mro (~mro@port-92-195-166-117.dynamic.as20676.net) (Remote host closed the connection)
[17:24:21] *** Joins: gahr (~gahr@user/gahr)
[17:30:52] *** Joins: mro (~mro@port-92-195-166-117.dynamic.as20676.net)
[17:34:38] <d_bot_> <jchavarri> this is what I ended up doing:
[17:34:39] <d_bot_> <jchavarri> - go to https://rescript-lang.org/try convert to Reason syntax
[17:34:40] <d_bot_> <jchavarri> - then convert to OCaml syntax either with refmt or with https://reasonml.github.io/en/try
[17:35:45] <d_bot_> <jchavarri> it's a bit tedious, but most of the process is automated (modulo all the rescript + reason attributes and annotations removal)
[17:36:55] <d_bot_> <jchavarri> as you mention, sometimes you have to manually change some words to make code compile (I especially remember `Promise.then` to `then_`)
[17:37:48] <d_bot_> <jchavarri> i am pretty sure that Melange can convert rescript to reason or OCaml syntaxes as well
[17:46:30] <d_bot_> <glennsl> Ah, thank you! I didn't realize the rescript playground still allowed that (it's under Settings, for those who might still wonder). I think that will do fine for my needs, but great tip about melange as well!
[17:48:32] <d_bot_> <KW78> Doesn't this answer your question
[17:48:33] <d_bot_> <KW78> `./lib/rescript.exe -print ml test.res # show ocaml code`
[17:48:35] <d_bot_> <KW78> in
[17:48:36] <d_bot_> <KW78> https://github.com/rescript-lang/syntax
[17:57:12] <d_bot_> <glennsl> @KW78 Unfortunately doesn't seem to work
[17:57:36] <d_bot_> <glennsl> I found the binary, but it doesn't accept the `-print` flag
[17:57:59] <d_bot_> <glennsl> It also doesn't accept just the filename, or anything else I've thrown at it
[17:58:27] <d_bot_> <glennsl> And running it without any arguments just has it complaining that it can't find `bsconfig.json`
[18:04:41] *** Quits: mro (~mro@port-92-195-166-117.dynamic.as20676.net) (Remote host closed the connection)
[18:08:37] *** Joins: dalek_caan (~Thunderbi@109.252.124.86)
[18:09:49] *** Joins: mro (~mro@port-92-195-166-117.dynamic.as20676.net)
[18:09:57] <d_bot_> <KW78> I haven't used it but they imply it is a different repo / install for *syntax developers* which compiles to a ./lib/rescript.exe
[18:09:58] <d_bot_> <KW78> Might be worth a try to go through the full install if you have lot of files
[18:09:59] <d_bot_> <KW78>
[18:10:00] <d_bot_> <KW78> Also you may want to ask on the Rescript forum
[18:10:02] <d_bot_> <KW78> (and if it is done in the playground there must be a software somewhere)
[18:14:06] *** Quits: mro (~mro@port-92-195-166-117.dynamic.as20676.net) (Remote host closed the connection)
[18:14:16] *** Joins: mro (~mro@port-92-195-166-117.dynamic.as20676.net)
[18:16:20] *** Quits: mro (~mro@port-92-195-166-117.dynamic.as20676.net) (Remote host closed the connection)
[18:17:46] *** Joins: mro (~mro@port-92-195-166-117.dynamic.as20676.net)
[18:21:58] <d_bot_> <romachkuna> can someone help me setup ocaml in vscode? i already downloaded ocaml64,added bin folder to the path, just cant seem to setup Ocaml in vscode using OcamlPlatform extension
[18:22:06] <companion_cube> @Bluddy I find first-class modules useful for OOP style here
[18:24:40] <d_bot_> <NULL> Launch vscode from within OCaml64's Cygwin console ?
[18:25:18] <d_bot_> <romachkuna> how do i do that?
[18:25:40] <d_bot_> <NULL> `code`
[18:26:06] <d_bot_> <Bluddy> @companion_cube Do you have an example somewhere? I find them cumbersome but I'm willing to try.
[18:26:45] <companion_cube> https://github.com/c-cube/bare-ocaml/blob/master/src/Bare_encoding.mli#L11-L31
[18:26:54] <companion_cube> and the same for OUTPUT below
[18:29:00] *** Quits: mro (~mro@port-92-195-166-117.dynamic.as20676.net) (Remote host closed the connection)
[18:29:17] *** Joins: mro (~mro@port-92-195-166-117.dynamic.as20676.net)
[18:32:49] *** Quits: mro (~mro@port-92-195-166-117.dynamic.as20676.net) (Remote host closed the connection)
[18:35:28] *** Joins: quartz (~quartz@user/quartz)
[18:38:19] *** Joins: mro (~mro@port-92-195-166-117.dynamic.as20676.net)
[18:41:11] <d_bot_> <Bluddy> cool. Looks almost identical to using records + explicitly passing self.
[18:41:18] <d_bot_> <Bluddy> but maybe it's a little cleaner
[18:41:29] <companion_cube> it's a bit easier imho
[18:41:32] <companion_cube> less namespacing to do
[18:41:57] <companion_cube> you can hide state inside, etc.
[18:42:10] <companion_cube> you can have a bigger (local) module and then cast it
[18:42:23] <d_bot_> <Bluddy> yeah
[18:42:24] <d_bot_> <VPhantom> I think I'm misunderstanding something from the stdlib (4.13): there's a `Uchar` module but we can't get those characters from strings nor append them to buffers or set them in bytes. ðŸ¤”
[18:43:34] <companion_cube> you can append them to buffers
[18:43:45] *** Quits: mro (~mro@port-92-195-166-117.dynamic.as20676.net) (Remote host closed the connection)
[18:44:00] <d_bot_> <VPhantom> Ah yes, good. But I can't read them from anywhere?
[18:44:04] <companion_cube> `Buffer.add_utf_8_uchar`
[18:44:05] <d_bot_> <Bluddy> @companion_cube I know you have the channel proposal going, but maybe it makes more sense to create a Stream library (unrelated to stdlib.Stream) using first-class modules and use that?
[18:44:13] <companion_cube> it's not going anymore.
[18:44:24] <d_bot_> <Bluddy> sure it is ðŸ™‚
[18:44:33] <companion_cube> and also, a stream library has 0 usefulness since it's not what most functions consume
[18:45:07] <d_bot_> <Bluddy> wasn't there a positive reaction to that PR?
[18:46:00] <d_bot_> <Bluddy> also, other languages don't change their file handles, but build stream libraries and then use that... if you make it available, it might catch on
[18:47:04] <companion_cube> it was just a RFC, oh well
[18:47:14] <companion_cube> what other languages did that?
[18:47:34] <companion_cube> afaik, most modern languages actually have an extensible notion of reader/writer
[18:47:37] <companion_cube> see: Go, rust, notably
[18:53:02] *** Joins: mro (~mro@port-92-195-166-117.dynamic.as20676.net)
[18:56:06] *** Quits: mro (~mro@port-92-195-166-117.dynamic.as20676.net) (Remote host closed the connection)
[18:58:17] <d_bot_> <Bluddy> hmm... well I guess c++ is my main reference point
[18:58:24] <d_bot_> <Bluddy> for this at least
[18:58:53] <d_bot_> <Bluddy> java too I think
[18:59:01] <d_bot_> <Bluddy> so not modern per se
[18:59:26] <d_bot_> <darrenldl> that would be nice
[19:00:34] <companion_cube> well, C++ has iostreams
[19:00:49] <companion_cube> I don't remmeber for java but of course it must be objects/interfaces, right?
[19:01:15] <companion_cube> well: https://docs.oracle.com/javase/8/docs/api/java/lang/Readable.html
[19:03:40] <d_bot_> <Bluddy> fair point. I guess in C++ they had to retrofit it...
[19:04:09] <d_bot_> <Bluddy> which is what we want to do...?
[19:04:35] <d_bot_> <Bluddy> I mean it's a little odd to just take channel and have it transparently be all these different things, no?
[19:04:36] <companion_cube> I mean, they added their own extensible layer on top of C's existing FILE*
[19:04:43] <companion_cube> why would it be? :/
[19:04:51] <companion_cube> why couldn't a channel be a byte stream?
[19:05:03] <companion_cube> given it's already the abstraction for a file, a socket, â€¦
[19:05:27] <d_bot_> <Bluddy> what if you want a buffered one? shouldn't it have something to distinguish it?
[19:05:28] <d_bot_> <romachkuna> can someone tell me why when i type in utop #use "test.ml";; it doesnt copy the code? (which is in test.ml)
[19:06:00] <companion_cube> channels are buffered
[19:06:07] <d_bot_> <Bluddy> then unbuffered
[19:06:23] <d_bot_> <Bluddy> I dunno for a typed language you'd imagine there would be some distinguishing type
[19:06:26] <companion_cube> ðŸ¤·
[19:06:34] <companion_cube> we don't have easy subtyping
[19:06:49] <companion_cube> in general that's done by having an unbuffered Read, and a BufferedRead extending it
[19:06:59] <companion_cube> and everyone using BufferedRead as soon as they can
[19:08:19] <companion_cube> if you want unbuffered IOs you probably want to directly interact with a Unix.file_descr or something like that
[19:09:00] <d_bot_> <orbitz> Implicit modules FTW!
[19:09:06] <d_bot_> <Bluddy> this is one place where I think modifying channel is a hacky solution waiting for the right language feature
[19:09:36] <d_bot_> <Bluddy> or just more performant OOP
[19:09:57] <d_bot_> <Bluddy> but we can solve the problem in user space with the right library
[19:11:35] <d_bot_> <orbitz> I think one issue is sub typing adds a lot of complexity that forcing people into accepting might be undesirable
[19:11:42] <companion_cube> we can't, since the problem is that everyone takes in_channel and out_channel as parameter
[19:11:59] <companion_cube> if you think people will adopt a new interface that's not even in the stdlib, you haven't looked at OCamlers :D
[19:12:27] <d_bot_> <orbitz> They'll do it...only if they made it ðŸ™‚
[19:12:31] <companion_cube> ^
[19:12:52] *** Joins: mro (~mro@port-92-195-166-117.dynamic.as20676.net)
[19:13:02] <companion_cube> look at ocamlnet's IO abstractions (OOP based), and BatIO, for existing examples
[19:20:21] <d_bot_> <darrenldl> wonder if one can create in_channel via ffi (though it's a bandaid solution)
[19:20:48] <companion_cube> no need for that, you just need a unix pipe! or a subprocess /s
[19:21:25] <d_bot_> <darrenldl> just use temporary files as buffers to implement in/out_channel proxies
[19:21:29] <d_bot_> <darrenldl> /s
[19:21:38] <companion_cube> yep, that's the sad state of things
[19:21:53] <companion_cube> also, you can't easily read from either a socket or a TLS socket
[19:22:04] <companion_cube> cause they obviously need to be different things ðŸ¤”
[19:23:49] <d_bot_> <darrenldl> seeme like one cannot use a file descriptor to make a channel either, hm
[19:24:28] <d_bot_> <darrenldl> *stares at wall pondering if temp file is worth it*
[19:25:23] <companion_cube> maybe Unix.pipe is the way :p
[19:26:40] *** Quits: mro (~mro@port-92-195-166-117.dynamic.as20676.net) (Remote host closed the connection)
[19:26:58] <d_bot_> <darrenldl> oh wait no Unix provides in_channel_of_descr it seems(?)
[19:27:08] <companion_cube> it does, yes
[19:27:23] <companion_cube> (there's a very ugly global structure underneath, btw.)
[19:38:31] <d_bot_> <darrenldl> *horrible idea emerges from reading memfd_create and mmap*
[19:38:45] *** Quits: hackinghorn (~hackingho@user/hackinghorn) (Ping timeout: 256 seconds)
[19:40:23] *** Quits: mbuf (~Shakthi@122.178.120.57) (Quit: Leaving)
[19:42:22] *** Joins: mro (~mro@2002:5cc3:a675:0:94a7:775e:9b2c:c93a)
[19:45:18] <d_bot_> <darrenldl> ugh, piping is really the only way as you said without breaching into C
[19:46:41] *** Joins: zebrag (~chris@user/zebrag)
[19:49:17] <d_bot_> <Bluddy> BatIO is nice!
[19:51:53] <d_bot_> <Bluddy> companion_cube I think the main reason it wasn't adopted is that 90% of OCaml usage in the wild is compilers, and they just don't need, or think they need, the functionality.
[19:52:22] <d_bot_> <Bluddy> you only realize you need it when you bump into it, and until then, you write your code without it
[19:54:43] *** Quits: mro (~mro@2002:5cc3:a675:0:94a7:775e:9b2c:c93a) (Remote host closed the connection)
[19:55:20] <companion_cube> BatIO could have been kind of ncie, but no one uses it cause it's slow and non standard
[20:00:28] <d_bot_> <Bluddy> Well why not come up with a nice light library? You kind of have a knack for these things...
[20:02:04] <d_bot_> <Bluddy> Though I guess it does get tangled up with async stuff
[20:04:52] <companion_cube> then we'd have a nice library with input and output buffer streams
[20:04:59] <companion_cube> and 0 other libraries using it
[20:09:28] <d_bot_> <Bluddy> Not if we promote it
[20:10:04] *** Joins: mro (~mro@port-92-195-166-117.dynamic.as20676.net)
[20:13:32] <companion_cube> "does it work with {async,lwt,eio}? no? oh well too bad"
[20:14:05] *** Quits: mro (~mro@port-92-195-166-117.dynamic.as20676.net) (Remote host closed the connection)
[20:20:36] <d_bot_> <Bluddy> Right the async part is the issue
[20:23:01] <d_bot_> <orbitz> This is why we need a stdlib scheduler! ðŸ¤£
[20:23:29] <companion_cube> good luck with that one too!
[20:25:08] *** Quits: Haudegen (~quassel@91.114.49.10) (Quit: Bin weg.)
[20:41:44] *** Joins: mro (~mro@port-92-195-166-117.dynamic.as20676.net)
[20:47:23] <d_bot_> <monk> is there a way to pass a flag to dune to ignore a specific warning
[20:47:32] <d_bot_> <monk> i don't want to disable the warning as failure generally
[20:48:00] <d_bot_> <monk> i simply want to test something before refactoring a bunch of code that may become irrelevant
[20:50:51] *** Joins: vicfred (~vicfred@user/vicfred)
[20:55:37] <d_bot_> <undu> octachron answered that some years ago: https://stackoverflow.com/questions/46489249/use-ocaml-warning-attribute-to-disable-warning-8-unexhaustive-match
[20:58:03] *** Quits: mro (~mro@port-92-195-166-117.dynamic.as20676.net) (Remote host closed the connection)
[20:58:25] <sleepydog> alternatively you can add an (env) clause to your dune file which lets you pass compiler flags, and use that: https://dune.readthedocs.io/en/stable/dune-files.html#env
[21:00:19] *** Joins: mro (~mro@port-92-195-166-117.dynamic.as20676.net)
[21:01:57] *** Quits: mro (~mro@port-92-195-166-117.dynamic.as20676.net) (Remote host closed the connection)
[21:03:53] *** Quits: olle (~olle@213.61.81.133) (Remote host closed the connection)
[21:15:05] *** Quits: bartholin (~bartholin@158.110.70.82) (Ping timeout: 256 seconds)
[21:17:36] <sleepydog> something like `(env (nowarn (flags (:standard -w -A))))` , then `dune build --profile=nowarn` works
[21:23:07] <d_bot_> <monk> running with `--profile=nowarn` is very close to what i want, thank you
[21:23:26] <d_bot_> <monk> a lot nicer than commenting a bunch of code out just for a test run of a binary, etc
[21:23:39] <d_bot_> <monk> without getting lazy and setting warnings off
[21:25:48] *** Joins: rgrinberg (~textual@2806:101e:7:7728:18a:215f:c191:4d5d)
[21:27:27] *** Joins: bartholin (~bartholin@158.110.70.82)
[21:46:54] *** Joins: olle (~olle@i5E866D89.versanet.de)
[21:58:25] *** Joins: wonko (~wjc@user/wonko)
[22:00:42] *** Quits: bartholin (~bartholin@158.110.70.82) (Ping timeout: 256 seconds)
[22:02:44] *** Joins: bartholin (~bartholin@158.110.70.82)
[22:09:59] *** Quits: rgrinberg (~textual@2806:101e:7:7728:18a:215f:c191:4d5d) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[22:13:16] *** Quits: quartz (~quartz@user/quartz) (Quit: WeeChat 3.4)
[22:13:40] *** Joins: rgrinberg (~textual@2806:101e:7:7728:18a:215f:c191:4d5d)
[22:18:00] *** Joins: hackinghorn (~hackingho@user/hackinghorn)
[22:32:44] *** Joins: Haudegen (~quassel@178.115.237.87.static.drei.at)
[22:38:21] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[22:52:35] <d_bot_> <romachkuna> ```code /cygdrive/c/Users/UserName/AppData/Local/Programs/Microsoft\ VS\ Code/Code.exe``` can someone tell me why this isnt working? i cant launch vscode from cygwin terminal
[22:59:42] *** Quits: dalek_caan (~Thunderbi@109.252.124.86) (Quit: dalek_caan)
[23:03:43] *** Joins: Anarchos (~Anarchos@88.168.112.216)
[23:05:54] *** Joins: mro (~mro@port-92-195-166-117.dynamic.as20676.net)
[23:06:26] *** Quits: mro (~mro@port-92-195-166-117.dynamic.as20676.net) (Remote host closed the connection)
[23:06:36] *** Quits: rgrinberg (~textual@2806:101e:7:7728:18a:215f:c191:4d5d) (Ping timeout: 245 seconds)
[23:11:24] *** Joins: mro (~mro@port-92-195-166-117.dynamic.as20676.net)
[23:17:46] *** Quits: olle (~olle@i5E866D89.versanet.de) (Ping timeout: 256 seconds)
[23:29:51] *** Quits: Anarchos (~Anarchos@88.168.112.216) (Quit: Vision[]: i've been blurred!)
[23:40:56] *** Joins: gwizon (~gwizon@ool-45798b07.dyn.optonline.net)
[23:44:45] *** Joins: Anarchos (~Anarchos@88.168.112.216)
[23:52:54] *** Quits: wonko (~wjc@user/wonko) (Ping timeout: 260 seconds)
[23:55:11] *** Quits: mro (~mro@port-92-195-166-117.dynamic.as20676.net) (Remote host closed the connection)
[23:56:11] *** Quits: Anarchos (~Anarchos@88.168.112.216) (Quit: Vision[]: i've been blurred!)
