[00:12:24] <pjb> (defclass foo () () (:documentation "This is the FOO class; instanciate it to make examples!")) (documentation (find-class 'foo) t) #| --> "This is the FOO class; instanciate it to make examples!" |# 
[00:17:28] <lisp123> pjb: hmmm so perhaps use documentation for documentation on the class and use describe for documentation on the instances?
[00:18:12] <pjb> lisp123: of course, you could add documentations on the instances, but it wouldn't be too useful in general, since instances in general are short lived and garbage collected sooner than later.
[00:18:50] <pjb> (let ((obj (make-instance 'foo))) (setf (documentation obj t) "This is an instance of FOO, for demo purpose")   (documentation obj t)) #| --> "This is an instance of FOO, for demo purpose" |# 
[00:18:59] <pjb> oops, obj is lost and gc'ed!
[00:19:18] <lisp123> +1 Makes Sense
[00:19:20] <pjb> But yes, in theory if you have long lived instances, you could document them.
[00:19:40] <pjb> (setf (documentation 42 t) "the answer to the question of life, the universe, and everything")
[00:19:47] <pjb> (documentation 42 t) #| --> "the answer to the question of life, the universe, and everything" |#  ; yay!
[00:20:47] <lisp123> Nice!
[00:21:22] <pjb> That said, given how documentation is specified, you couldn't rely on it.  If you wanted to document instances in an atual applications, you'd have to manage it yourself in your own hash-table or database, to be sure it's not lost.
[00:22:25] <lisp123> That makes sense
[00:22:52] <lisp123> And I am thinking more ideal, since long documentation strings do make code harder to follow
[00:23:11] <lisp123> So better to strip them out and place them somewhere else, at which point a custom documentation class seems to make more sense
[00:24:41] <pjb> That is, when you create an object, you may ask the user a comment or documentation text in addition to the data of the object.
[00:25:37] <pjb> (make-instance 'person :name "Pascal" :nick "pjb" :knowledge '("CL") :documentation "A knows-it-all lisper")
[00:25:52] <pjb> ;-)
[00:27:46] <lisp123> (type-of *pjb*) --> (lisper lisp-wizard black-belt ..) ;)
[00:35:27] <pjb> brown belt. I lack direly in pretty-printer and in CLOS/MOP, and some other parts of CLâ€¦
[00:38:38] *** Quits: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[00:40:15] <lisp123> Do you use much CLOS in your code?
[00:42:08] <lisp123> PREFACE: X3J13 voted in January 1989 (PRETTY-PRINT-INTERFACE)   to adopt a facility for user-controlled pretty printing as a part of the forthcoming draft Common Lisp standard. This facility is the culmination of thirteen years of design, testing, revision, and use of this approach.
[00:42:11] <lisp123> 13 years!
[00:44:55] <pjb> lisp123: Yes, I use the bare operators, defclass, defmethod; but there's much more to it.
[00:50:07] <lisp123> I see
[00:53:56] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[00:54:26] *** Joins: dra (~dra@2a04:4540:6409:4e00:cc08:6836:8a16:3bee)
[01:12:33] *** Quits: dra (~dra@2a04:4540:6409:4e00:cc08:6836:8a16:3bee) (Quit: Leaving)
[01:14:43] *** Quits: lisp123 (~lisp123@5.30.23.247) (Quit: Leaving...)
[01:20:58] *** Quits: shka (~herr@83.175.151.96.piasta.pl) (Ping timeout: 258 seconds)
[02:03:23] *** Quits: paule32 (~paule32@user/paule32) (Ping timeout: 264 seconds)
[02:03:44] *** Joins: paule32 (~paule32@user/paule32)
[02:34:32] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Remote host closed the connection)
[02:40:28] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[02:55:48] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[03:34:25] *** Joins: abrantesasf (~abrantesa@187.36.170.211)
[03:41:24] <winning-luser> i wrote a function, regretted the name of it, changed the name, but how do i get rid of old name from my repl session (sbcl)?
[03:42:16] <winning-luser> there is UNINTERN, but the value of the function name will be nil instead of throwing an error for being unbound, which seems more desirable
[03:43:35] <winning-luser> scratch that on UNINTERN, nvm.
[03:47:37] <winning-luser> symbols, packages, HOW DID I GET HERE
[03:51:14] *** Quits: random-nick (~random-ni@87.116.178.206) (Ping timeout: 258 seconds)
[03:59:51] <winning-luser> Found what I needed: http://clhs.lisp.se/Body/f_makunb.htm
[04:00:06] <winning-luser> makunbound
[04:01:41] <winning-luser> seems weird that the "e" would be left out here, but there are a lot of symbols with the prefix make-
[04:10:14] <pjb> Yes. 
[04:57:23] *** Quits: johnjay (~pi@192.142.100.50) (Ping timeout: 264 seconds)
[04:59:18] *** Joins: johnjay (~pi@192.142.100.50)
[05:17:13] <kagevf> winning-luser: in emacs you can use C-c C-u as a shortcut for makunbound (fyi)
[05:19:34] <winning-luser> kagevf: ah, a slime keybind, neat. thank you
[05:25:43] <kagevf> winning-luser: in a lisp file, try C-h m and you can see what else is available - the "m" is for "mode" 
[05:26:13] <winning-luser> yeah ive used emacs for a long time :)
[05:26:38] <kagevf> haha ok :) 
[05:26:38] <winning-luser> well, relative to my age, 5 years isnt long for others
[05:27:17] <kagevf> next month I will be using it for 2 years :) :) started with org mode
[05:27:45] <winning-luser> ive only been getting into org mode recently despite my long usage of Emacs, surprisingly enough
[05:28:50] <kagevf> yeah, it can be used for so much ... how long with CL?
[05:30:24] <winning-luser> that is hard to answer for my history with programming and learning has not been linear. lets just say im a noob. going through the PAIP book
[05:30:53] <winning-luser> a while back i read Touretzky's gentle intro, really awesome "babbys first programming" book
[05:32:34] <kagevf> yeah, I tried reading PCL first but then switched to gentle intro ... had a much better time
[05:33:26] <kagevf> haven't read paip yet ... will probably read sicp before that (and try to work on the problems with CL)
[05:33:30] <winning-luser> Common Lisp is actually why I got into Emacs and was among my first languages despite me not actually learning Common Lisp or much programming. i have a very non-linear and weird history of learning programming
[05:33:35] <winning-luser> I effectively only know Lisp
[05:33:51] <winning-luser> Common Lisp and Emacs Lisp, though the latter way more.
[05:34:04] <kagevf> oh wow that's really cool
[05:35:13] <kagevf> so it's often said that if a language with sexp's is one's 1st language, then it's completely natural to read / grok / etc ... would you agree? have you ever looked at non-Lisps and found them to be "weird"?
[05:35:33] <winning-luser> i never found s-exp's to be weird or hard or anything
[05:36:58] <winning-luser> looking at non-lisps i find them incredibly noisy
[05:37:06] <kagevf> I'm getting more used to it, but it's still not "native" for me yet hehe
[05:37:55] <winning-luser> whats your background experience? C-style languages?
[05:37:55] <kagevf> oh, right ... I bet if you looked at something like Java or C# it'd be very verbose looking ... 
[05:38:12] <winning-luser> Oh yeah, Java and C# definitely.
[05:38:19] <kagevf> I read a book on C# functional programming, and it was cool and everything, but the type info was definitely distracting
[05:38:35] <winning-luser> I will have to be using Java when I go to school soonish
[05:38:57] <kagevf> ohhh bummer
[05:39:39] <winning-luser> It doesn't bother me haha. I know a lot of people get caught up with what undergrad CS courses use for languages but it doesn't seem a big deal, honestly
[05:40:06] <kagevf> yeah ... it's the ideas / concepts that are important
[05:40:40] <winning-luser> No, its the paper you get at the end of the 4 years and the connections you make along the way ;)
[05:40:48] <kagevf> haha right
[05:41:44] <kagevf> and the algorithms you memorize too 
[05:42:21] <winning-luser> i do have actual interest in properly learning algorithms and better thinking with that, despite my teasing
[05:43:44] <kagevf> right on :) 
[05:55:29] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[05:56:34] *** Quits: sts-q (~sts-q@91.200.108.134) (Ping timeout: 252 seconds)
[06:07:55] *** Joins: sts-q (~sts-q@91.200.108.172)
[06:17:59] *** Quits: abrantesasf (~abrantesa@187.36.170.211) (Remote host closed the connection)
[06:48:34] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Read error: Connection reset by peer)
[06:48:59] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 264 seconds)
[08:49:44] *** Joins: shka (~herr@83.175.151.96.piasta.pl)
[08:52:06] *** Joins: lisp123 (~lisp123@5.30.23.247)
[08:54:44] <lisp123> What is everyone's opinion on using macros to strip out parts of a function (where it doesn't make sense to rewrite that part in its own function), as macros have access to lexical variables and thus don't need values passed in
[08:54:47] <lisp123> For example, https://pastebin.com/pGDTfuhJ
[08:57:00] <kagevf> lisp123: not sure ... the example in your paste looks like it would fall under the "don't use a macro when a function would do" rule 
[08:57:15] <kagevf> lisp123: in this case, what kind of syntax abstraction do you have in mind?
[08:57:35] <lisp123> kagevf: https://pastebin.com/4bSVVyid
[08:58:18] <lisp123> In the above, I don't need to write (do-this-step x), I can simply strip out that part of the code into a macro. This was I could use the macro names as 'pseudo-code' to describe parts of a complex function
[08:59:19] <kagevf> I see ... but there's no templating going on in this example, right? so my thought is "why not just use a function?" ... I don't see the case for using a macro ...
[08:59:26] <White_Flame> the only time I use constructs like that is from MACROLET, so the scope of the implicit variables is known
[08:59:38] <lisp123> However, because these macros MUST sit within a form which binds X, they are not standalone --> So I am 50-50. The alternative is to rethink the whole function to make it more modular
[09:00:20] <White_Flame> either that, or use functions & special variables
[09:00:41] <lisp123> kagevf: It lets me not have to write complex function calls like (do-this x y z a b c), and just (do-this) {this is where x y z a b c are local variables in the calling function}
[09:00:50] <lisp123> White_Flame: Do you have an example of MACROLET?
[09:01:04] <White_Flame> or a (let (vars...) (labels ....)) where the LABELS functions have implicit visibility to the LET variables
[09:01:08] <kagevf> lisp123: ah, ok
[09:01:35] <kagevf> I think macrolet is just a local macro ... defun:flet macro:macrolet
[09:01:45] <White_Flame> I think labels is actually probably the best way for what I think you're doing
[09:02:18] <kagevf> yeah, why not just use flet or labels or even a local lambda?
[09:02:39] <kagevf> the variables in the outer scope will still be visible
[09:02:44] <lisp123> White_Flame: My "issue" (its not really an issue) is that some functions are larger than need to be. So I wanted to split them out into discrete blocks. If I take out parts via a new function, then any local variables need to be passed in
[09:02:55] <White_Flame> and your utility functions are useless outside that particular body anyway
[09:03:23] <White_Flame> hence, they are local functions
[09:03:29] <White_Flame> and thus should be put within that scope
[09:03:39] <lisp123> And if I'm never going to use those subcomponents elsewhere, I was thinking, why not use a macro that expands in place and doesn't need any variables passed in
[09:04:22] <kagevf> (defun f (a b c) (let ((d 'whatever)) (flet ((g () (format t "~a ~a ~a ~a" a b c d)))))) <-- works lisp123 
[09:04:50] <White_Flame> (assuming you actually call G at some point ;) )
[09:04:53] <kagevf> lisp123: local flet or labels don't need the variables passed in like above .... like White_Flame was saying
[09:04:58] <lisp123> White_Flame: The only issue with labels, flet etc (again not an issue), is that it makes the overall code within the defun the same size / or big --> If I used a macro outside of the defun, I can split up the code blocks
[09:05:10] <kagevf> White_Flame: doh! you're right ... missed that!
[09:05:32] <White_Flame> lisp123: I don't think that matters in the slightest
[09:06:03] <kagevf> what do you mean by split up the code blocks?
[09:06:05] <White_Flame> each utility function can be small, and that main function body can be small, even if it all happens to be in one toplevel form
[09:06:40] <kagevf> you can even define a defun nested inside another defun
[09:06:57] <White_Flame> you can, but you shouldn't ;)
[09:06:59] <kagevf> ... I think the nested scope thing still works in that case
[09:07:19] <kagevf> White_Flame: oh, it's considered bad style? didn't know ... 
[09:07:22] <White_Flame> right, and it will overwrite the prior time you called it, since the DEFUN instance is global
[09:07:43] <lisp123> https://pastebin.com/PC9X7N3k
[09:07:49] <kagevf> ah, ok ... so best to avoid nested defun
[09:08:00] <White_Flame> (let (...) (defun ...)) is fine, but (defun ... (defun ...)) isn't.  The LET body is only called once, but the outer function in the double defun case can be called multiple times
[09:08:08] <lisp123> For example, here the labels function is relatively large
[09:08:35] <White_Flame> uh, no it's not ;)
[09:08:44] <lisp123> :D
[09:08:56] <White_Flame> and literally the entire point of exploded-lists is to run a recursive body, so that's the majority of it
[09:09:15] <White_Flame> I really don't see the problem
[09:09:16] <lisp123> Okay, for the purposes of this discussion, lets assume its large
[09:09:36] <lisp123> I was thinking of using (defmacro explosion) to strip out the labels part
[09:09:43] <White_Flame> sure, I have (let (...) (labels ...)) with dozens of labels functions
[09:09:53] <White_Flame> inside a defun
[09:10:30] <White_Flame> but the labels part makes no sense outside that function, and shouldn't be callable outside of it as your variables won't exist
[09:10:31] <lisp123> White_Flame: Why not strip them out? Like this https://pastebin.com/pGDTfuhJ
[09:10:47] <White_Flame> because test-macro is broken
[09:11:03] <White_Flame> unless you're in a particular magic place
[09:11:14] <kagevf> I don't get the benefit 
[09:11:17] <lisp123> White_Flame: Yes, that's basically the point I've come down to
[09:11:41] <lisp123> Okay, so I guess it creates too much confusiong vs. your point "but the labels part makes no sense outside that function, and shouldn't be callable outside of it as your variables won't exist" and I shouldn't do it
[09:11:43] <White_Flame> implictly visible variables are what special vars are for
[09:12:14] <White_Flame> so you can have (let ((*foo* ...)) (other-funcs)) and they will locally see all your bindings without passing them around, if things are truly large over both code space and execution spread
[09:13:06] <lisp123> White_Flame: Yeah I just was being lazy and didn't want to write special variable declarations
[09:13:42] <lisp123> But thanks, I take back my shortcut macro idea, seems like its only going to create a bit of confusion so is not worth the effort saved
[09:15:04] <White_Flame> in cases like these, size != complexity.  You can have large, well-organized subsystems within a local scope inside a single toplevel form
[09:15:41] <lisp123> kagevf: It boiled down to, if I am splitting up code blocks (i.e. outside of a lexical block), I lose lexical scope so variables need to be passed in. To avoid passing in variables, one alternative would be to declare special variables, the other would have been to use macros that expanded in place (my initial suggestion). 
[09:15:53] <lisp123> White_Flame: Thanks, got it
[09:17:28] <lisp123> White_Flame: What you say makes sense, as that is the purpose of local functions, so will be easier for people to read
[09:18:24] <kagevf> lisp123: so you had something like (defun f (a b) (format t "~a ~a" a b)) and (defun g () (let ((a 1) (b 2)) (f a b))) and you wanted a macro to turn #'f into a label inside of g?
[09:19:14] <lisp123> I read an interesting comment online (from c.l.l) on defun vs. defmethod the other day -----> use defmethod when one expects different versions vs. use defun when only one version is expected. I really like trying to use the right functions for the right task as it makes things clearer (hence I agree with you more)
[09:19:34] <lisp123> kagevf: Yes exactly
[09:19:49] <kagevf> lisp123: I see ... interesting thought exercise, for sure
[09:20:04] <lisp123> But looks like this just creates confusion as people expect macros to be stand-alone (as this dicussion went), so not worth the trouble
[09:20:51] <kagevf> yeah ... it seems like that would be confusing ... might be cool to try just to see what happens though hehe
[09:20:53] *** Joins: st_iron (uid370243@id-370243.uxbridge.irccloud.com)
[09:21:16] <st_iron> good morning
[09:21:21] <kagevf> defmethod allows you to specialize on different types, so the defun/defmethod quote above makes sense
[09:21:38] <White_Flame> technically, defmethod specializes on classes, not types
[09:21:45] <lisp123> Yeah, initially I was like, i'm going to make everything a defmethod lol
[09:22:36] <kagevf> White_Flame: ok ... is there something in Lisp that's a type but not a class? I think I recall reading something along those lines recently but can't quite remember ...
[09:23:14] <lisp123> st_iron: good morning
[09:23:14] <White_Flame> (or null (integer 10 20)) is a type, but a class is an intrinsic characteristic of an object
[09:23:38] <kagevf> ok, so "integer" wouldn't be considered a class? nor fixnum?
[09:23:42] <White_Flame> so fixnum/bignum are classes, and all classes are types, too.  But types can extend type tests well beyond just the class
[09:23:55] <kagevf> ahh, ok
[09:24:31] <White_Flame> oops, right, integer is the class, but fixnum/bignum are technically types
[09:24:43] <kagevf> I see
[09:24:53] <White_Flame> (as per the spec)
[09:24:58] <kagevf> if I wanted to specialize on a list (or maybe sequence?) of something is that possible?
[09:25:44] <White_Flame> not on a defmethod specializer
[09:26:02] <kagevf> ah, ok ... that's what I figured
[09:26:59] <White_Flame> however, both LIST and CONS are classes
[09:27:58] <White_Flame> you just can't specialize on the contents
[09:28:07] <White_Flame> that would be a manual test inside the list handler
[09:28:43] <kagevf> ohh ... ok, interesting
[09:29:20] <kagevf> so I can specialize on "list" I just can't specialize on what kind of list it is ... which makes sense since it could be anything inside of the list
[09:30:10] <lisp123> kagevf: I had the same conuldrum a few days ago
[09:30:20] <lisp123> The conclusion I got was that list is a DATA STRUCTURE
[09:30:41] <White_Flame> list is the class of the thing being stored.  Its subcomponents are not part of its class
[09:31:16] <kagevf> ah ... good ways of putting it lisp123 White_Flame thank you
[09:31:17] <beach> lisp123: I call Common Lisp lists a "concrete data type", as opposed to an "abstract data type".
[09:31:21] <lisp123> So one should wrap our objects around a list to separate the interface from the implementation (so instead of doing (car my-data-stored-in-list), do (semantic-meaning-of-first-object data-stored-in-list)
[09:31:42] <lisp123> beach: Thanks, will use that terminology
[09:33:07] <lisp123> beach: So, you will call a "BUS" an abstract data type?
[09:33:20] <lisp123> Or is there another term for classes
[09:33:59] <lisp123> (bus here being a transport vehicle to avoid doubt)
[09:35:53] <lisp123> Have to jet, have a great day all and happy lisping
[09:37:54] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 260 seconds)
[09:39:43] *** Joins: aeth (~aeth@user/aeth)
[09:43:15] <White_Flame> (jet being another transport vehicle ;) )
[09:46:08] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[09:47:06] *** Joins: lisp123 (~lisp123@5.30.23.247)
[09:57:29] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[09:58:00] *** Joins: rotateq (~user@b2b-78-94-235-194.unitymedia.biz)
[10:30:42] *** Joins: lisp123 (~lisp123@5.30.23.247)
[10:36:42] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[10:38:37] *** Quits: kagevf (~jfh@ip68-224-125-162.lv.lv.cox.net) (Ping timeout: 268 seconds)
[10:40:27] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[10:42:03] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[11:04:12] <beach> minion: memo for lisp123: What I call "concrete data type" is anything data type where there is essentially only one reasonable implementation.  An abstract data type is defined entirely by the operations possible on its instance, without reference to its implementation. 
[11:04:13] <minion> Remembered. I'll tell lisp123 when he/she/it next speaks.
[11:05:56] <beach> minion: memo for lisp123: s/anything/any/
[11:05:56] <minion> Remembered. I'll tell lisp123 when he/she/it next speaks.
[11:10:25] *** Quits: sts-q (~sts-q@91.200.108.172) (Ping timeout: 265 seconds)
[11:16:02] *** Joins: kagevf (~jfh@ip68-108-33-76.lv.lv.cox.net)
[11:24:33] *** Joins: sts-q (~sts-q@91.200.108.179)
[11:35:24] *** Joins: hendursa1 (~weechat@user/hendursaga)
[11:39:06] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[12:08:00] *** Joins: jeffrey (~jeffrey@80-115-60-193.cable.dynamic.v4.ziggo.nl)
[12:34:52] *** Quits: winning-luser (~winning-l@2601:8c1:181:1340::e50f) (Quit: zzz)
[13:11:26] *** Joins: lisp123 (~lisp123@5.30.23.247)
[13:16:18] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 260 seconds)
[13:23:41] *** Joins: random-nick (~random-ni@87.116.178.206)
[13:44:36] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[13:48:09] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 268 seconds)
[13:59:58] *** Quits: random-nick (~random-ni@87.116.178.206) (Ping timeout: 258 seconds)
[14:19:33] *** Joins: lisp123 (~lisp123@5.30.23.247)
[14:19:39] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[14:19:51] *** Joins: lisp123 (~lisp123@5.30.23.247)
[14:22:51] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Remote host closed the connection)
[14:24:07] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[14:31:25] <edgar-rft> with SBCL we might even be able to have ferroconcrete data types
[14:35:15] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[14:42:25] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[14:53:07] <rotateq> i want para- and diamagnetic ones too
[15:35:02] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 258 seconds)
[15:35:37] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[15:36:42] *** Joins: aeth (~aeth@user/aeth)
[15:59:45] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[16:06:14] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[16:10:14] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 265 seconds)
[16:11:58] *** Joins: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se)
[16:16:35] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Quit: ec)
[16:56:33] *** Joins: tyson2 (~user@cpe688f2ec1f9b3-cm688f2ec1f9b0.cpe.net.cable.rogers.com)
[17:16:21] *** Quits: hendursa1 (~weechat@user/hendursaga) (Quit: hendursa1)
[17:16:50] *** Joins: hendursaga (~weechat@user/hendursaga)
[17:27:41] *** Quits: rotateq (~user@b2b-78-94-235-194.unitymedia.biz) (Remote host closed the connection)
[18:35:37] *** Quits: hendursaga (~weechat@user/hendursaga) (Remote host closed the connection)
[18:38:11] *** Joins: thrig (~thrig@65.113.153.50)
[18:39:06] *** Joins: hendursaga (~weechat@user/hendursaga)
[19:03:52] *** Quits: tyson2 (~user@cpe688f2ec1f9b3-cm688f2ec1f9b0.cpe.net.cable.rogers.com) (Quit: ERC (IRC client for Emacs 27.2))
[19:35:40] *** Joins: rain3 (~rain3___@2a02:2f09:d003:5800:b41c:c37:1705:91bc)
[19:46:35] <lisp123> What do you guys think of creating 'classes' for functions (store the function in a slot) and then write methods to apply them?
[19:52:20] <beach> That's fine, but a more direct solution could be to use funcallable objects.
[19:54:19] <beach> Time to go fix dinner for my (admittedly small) family.  I'll be back tomorrow (UTC+2). 
[19:54:38] <lisp123> beach: Thanks. Will google. Enjoy dinner, nights
[19:59:00] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[20:06:33] <White_Flame> lisp123: what would be the point of that?  you want to be able to set different function objects in those slots for a dynamic dispatch?
[20:07:44] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[20:08:11] *** Joins: lisp123 (~lisp123@5.30.23.247)
[20:12:48] <kagevf> lisp123: curious - where did you get the idea for putting functions in slots?
[20:15:01] <White_Flame> it's fine to have an object with function-object slots, but if there's only 1 such slot I don't see much need for the wrapper
[20:16:25] <lisp123> White_Flame: I had various similar but different functions, so was looking at way to abstract away parts of it with the dispatch being 'automatic'
[20:17:05] <White_Flame> one function, or a number of functions in a single object?
[20:17:14] <White_Flame> eg, an "api" class
[20:17:20] <lisp123> kagevf: I was just thinking really. One can specialise on data types, so does it work for 'specialising' on functions
[20:17:51] <White_Flame> yes, you can specialize on FUNCTION
[20:17:53] <lisp123> White_Flame: I have functions that have two related functions, a recursive one and a helper one
[20:18:24] <lisp123> So most of the code for these functions are the same, except the recursive and helper functions within them
[20:18:33] <White_Flame> if the helper is the entry point to the recursion, that's really the only one you need to store, as it has compiled into it the call to the recursive one
[20:18:40] <lisp123> Its not
[20:18:58] <White_Flame> can you post an example?
[20:19:09] <lisp123> Its the other way round. Okay but dont shoot me for bad code :D
[20:19:15] <lisp123> Since I've been fixing it a lot lately
[20:19:49] <lisp123> https://pastebin.com/SW1kqzXz
[20:20:31] <lisp123> (it won't work and probably has a bit of errors as I'm reworking it atm). But I have a function RECURSIVE-COMMUTATION, which calls the more primitive COMMUTATION (helper) function
[20:21:36] <lisp123> And I have similar versions for RECURSIVE-ASSOCIATION & ASSOCIATION, RECURSIVE-DISTRIBUTION & DISTRIBUTION (these are the basic axioms in maths, recursive versions means look through all of the expression and generate all valid equivalent paths via commutation etc)
[20:22:07] <lisp123> There's probably other ways to abstract it away, but I was just thinking about classes & generics, hence the question
[20:24:31] <lisp123> I wonder if dynamic dispatch creates too much of a slowdown? My feeling is no at this point, since the objects aren't know at runtime
[20:25:09] <lisp123> (i.e. the calculation occurs at runtime anyway, so its just an additional small overhead to choose which function to use)
[20:28:36] <lisp123> Sorry to spam, I think in this example, it doesn't make that much sense
[20:29:14] <lisp123> But the general idea intrigues me, since it allows for an organisation of "processes" not just data objects
[20:30:01] <White_Flame> I don't quite understand the model yet
[20:30:23] <White_Flame> but the overhead of dispatch or fully dynamic funcall all depends on how much work is done in the function itself
[20:30:35] <lisp123> White_Flame: Good point
[20:31:00] <White_Flame> CPU branch prediction is also tackling dynamic dispatch to some extent
[20:31:37] <White_Flame> as with long-pipeline systems, a fully dynamic branch can cause huge stalls
[20:32:06] <White_Flame> and cache misses happen quite late there
[20:32:39] <lisp123> White_Flame: What's a "long-pipeline system"?
[20:32:56] <White_Flame> how long the CPU's pipeline is
[20:33:29] <White_Flame> but you probably shouldn't worry about that sort of stuff when first tackling this
[20:33:34] <lisp123> I see, thanks
[20:33:55] <White_Flame> get your abstractions right, to the point where the code is expressed well, and allows the dynamism you need
[20:34:52] <lisp123> +1 True
[20:40:25] <lisp123> White_Flame & kagevf: What you guys workings on these days?
[20:44:41] <kagevf> lisp123: very small web apps ... simple project where the focus is getting hands-on experience with CL
[20:45:37] <lisp123> kagevf: Nice :) IMO lisp might be the best language for web apps, very underrated in that sphere
[20:46:24] <kagevf> yeah, I've been working on top of hunchentoot (no clack or clog or whatever) + parenscript
[20:47:04] <kagevf> IDK if it's the most "scalable" to do it? but I like the level of abstraction ... not too low, not too hight
[20:47:08] <kagevf> * high
[20:47:26] <lisp123> How are you finding Parenscript?
[20:47:44] <lisp123> IMO given Lisp is compiled, it should perform a lot better than other frameworks (I'm just guessing)
[20:48:07] <lisp123> And one can put NGINX in front for any issues, and then have hunchentoot on the inside
[20:48:38] <kagevf> it seems to be pretty solid both IME and what others say
[20:49:11] <kagevf> as for parentscript, I like it ... sometimes though when doing things like writing macros, I get confused where CL stops and PS begins
[20:50:51] <lisp123> I see, that's interesting
[20:51:39] <kagevf> at some point I'll need to revisit what I've done so far ... hopefull current me has a better understanding of things than last year me
[20:52:28] <kagevf> what about you, lisp123 - what are you doing?
[20:52:52] <thrig> that's easy, they are typing on irc!
[20:53:14] <lisp123> kagevf: I'm trying to automate natural language processing to post on IRC in a meaningful way
[20:53:20] <lisp123> ;)
[20:54:24] <lisp123> As a bot, I'm a few steps behind minion, that's for sure
[20:57:55] *** Quits: rain3 (~rain3___@2a02:2f09:d003:5800:b41c:c37:1705:91bc) (Ping timeout: 260 seconds)
[21:04:07] <kagevf> lisp123: oh, interesting :) ... did you have any reading (materials) in particular for getting NLP info?
[21:05:05] <thrig> do you know anyone else who is a few steps behind minion?
[21:11:07] <lisp123> kagevf: Sorry, was just joking. I'm doing some basic work on automated theorem solving
[21:13:33] <lisp123> kagevf: Look into GPT-3 however, I think that's where a lot of NLP stuff is being done
[21:24:15] <kagevf> lisp123: ah, ok :) ... the automated theorem solving sounds interesting too 
[21:30:18] <lisp123> kagevf: Thanks, it does :) I'll try and share here once I have something meaningful. Hopefully I won't have too many CL questions left and can focus more on the actual coding. However I felt better to get a good foundation so the time spent up front learning good habits is worthwhile. Hopefully I'm not just procrastinating (maybe I am) :)
[21:31:45] *** Joins: random-nick (~random-ni@87.116.178.206)
[21:58:56] <kagevf> lisp123: cool, looking forward to it :) 
[22:23:54] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[22:30:35] *** Quits: st_iron (uid370243@id-370243.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[22:31:29] *** Quits: thrig (~thrig@65.113.153.50) (Remote host closed the connection)
[22:33:59] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 264 seconds)
[22:35:42] *** Joins: aeth (~aeth@user/aeth)
[22:41:06] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 265 seconds)
[22:41:58] *** Joins: aeth (~aeth@user/aeth)
[22:45:48] *** Joins: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca)
[22:46:35] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 264 seconds)
[22:48:15] *** Joins: aeth (~aeth@user/aeth)
[22:50:09] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[22:50:41] *** Joins: lisp123 (~lisp123@5.30.23.247)
[22:51:47] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[22:51:59] *** Joins: lisp123 (~lisp123@5.30.23.247)
[23:39:34] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 258 seconds)
[23:41:15] *** Joins: aeth (~aeth@user/aeth)
[23:54:01] *** Quits: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
