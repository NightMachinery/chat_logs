[00:23:18] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[00:30:15] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[00:32:50] *** Quits: shka (~herr@109.231.62.239) (Ping timeout: 252 seconds)
[00:38:22] *** Joins: makomo_ (~makomo@user/makomo)
[00:41:59] *** Quits: makomo_ (~makomo@user/makomo) (Client Quit)
[00:42:08] *** Joins: makomo (~makomo@user/makomo)
[00:53:12] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[01:00:33] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[01:24:48] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[01:27:46] *** Quits: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 252 seconds)
[01:31:02] *** Joins: fengshaun_ (~fengshaun@S0106bc9b6886e536.cg.shawcable.net)
[01:31:06] *** Quits: fengshaun_ (~fengshaun@S0106bc9b6886e536.cg.shawcable.net) (Remote host closed the connection)
[01:38:03] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[01:44:35] *** Joins: lisp123_ (~lisp123@5.30.23.247)
[01:44:50] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[01:45:49] *** Quits: sts-q (~sts-q@91.200.108.243) (Ping timeout: 260 seconds)
[01:45:54] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 260 seconds)
[01:46:22] *** Quits: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de) (Ping timeout: 260 seconds)
[01:47:23] *** Joins: edgar-rft (~edgar-rft@HSI-KBW-109-193-249-223.hsi7.kabel-badenwuerttemberg.de)
[01:50:46] *** Joins: lisp123 (~lisp123@45.130.83.193)
[01:51:26] *** Quits: lisp123 (~lisp123@45.130.83.193) (Client Quit)
[01:53:15] *** Quits: lisp123_ (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[01:56:58] *** Joins: sts-q (~sts-q@91.200.108.243)
[02:00:58] *** Joins: fengshaun_ (~fengshaun@S0106bc9b6886e536.cg.shawcable.net)
[02:09:33] *** Quits: emacsomancer (~emacsoman@136.60.128.68) (Quit: WeeChat 3.2)
[02:10:38] *** Joins: emacsomancer (~emacsoman@136.60.128.68)
[02:22:15] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[02:29:02] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[02:29:14] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Quit: Leaving)
[02:38:50] *** Joins: Oladon (~olad@98.43.81.226)
[02:40:30] *** Joins: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net)
[02:40:51] *** Quits: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net) (Read error: Connection reset by peer)
[02:50:51] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[02:52:21] *** Quits: copec (~copec@schrodbox.unaen.org) (Quit: checkity check out.)
[02:52:41] *** Joins: copec (~copec@schrodbox.unaen.org)
[02:57:59] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[03:17:44] *** Joins: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net)
[03:43:30] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[03:45:04] *** Joins: hendursaga (~weechat@user/hendursaga)
[03:49:03] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[03:51:18] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[03:51:23] *** Quits: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 252 seconds)
[04:15:37] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[04:17:17] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[04:20:22] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 260 seconds)
[04:30:40] *** Quits: hendursaga (~weechat@user/hendursaga) (Quit: hendursaga)
[04:31:06] *** Joins: hendursaga (~weechat@user/hendursaga)
[04:57:49] *** Joins: beach` (~user@2a01:cb19:150:3400:c055:f9b1:7312:8b56)
[05:02:16] *** Quits: beach (~user@2a01:cb19:150:3400:9bf0:4a9a:854e:dd91) (Ping timeout: 252 seconds)
[05:08:23] *** Quits: random-nick (~random-ni@87.116.178.0) (Ping timeout: 252 seconds)
[05:30:40] *** Quits: sjl (~sjl@cpe-66-66-5-59.rochester.res.rr.com) (Quit: WeeChat 2.2-dev)
[06:02:13] *** Joins: Oladon (~olad@98.43.81.226)
[06:06:04] *** Quits: fengshaun_ (~fengshaun@S0106bc9b6886e536.cg.shawcable.net) (Quit: bibi!)
[06:20:32] *** Quits: Josh_2 (~user@37.25.47.130) (Remote host closed the connection)
[07:11:02] *** Quits: sts-q (~sts-q@91.200.108.243) (Ping timeout: 252 seconds)
[07:13:40] *** Joins: sts-q (~sts-q@91.200.108.250)
[07:20:00] *** beach` is now known as beach
[07:20:14] *** ChanServ sets mode: +o beach
[07:23:27] *** beach sets mode: -o beach
[08:06:50] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 260 seconds)
[08:33:00] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[09:46:44] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[09:50:18] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 260 seconds)
[10:20:17] *** Joins: treflip (~user@95.79.32.99)
[10:21:14] *** Joins: shka (~herr@109.231.62.239)
[10:22:09] *** Quits: treflip (~user@95.79.32.99) (Remote host closed the connection)
[10:27:16] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[10:30:26] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 260 seconds)
[10:50:37] *** Joins: ln43 (~ln43@user/ln43)
[12:36:08] *** Joins: hendursa1 (~weechat@user/hendursaga)
[12:39:45] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[12:41:50] *** Joins: lisp123 (~lisp123@5.30.23.247)
[12:43:29] <lisp123> Good morning, I have a brain teaser for today
[12:43:43] <beach> Hello lisp123.
[12:43:53] <lisp123> Hi Beach, hope you are having a nice day?
[12:44:17] <beach> Not yet! :)  But I am working on it. 
[12:44:38] <lisp123> Ah, hopefully it gets better :) The weekend is coming soon too :)
[12:44:49] <beach> So they say.
[12:46:00] <lisp123> I have spent an hour on this, but perhaps its not that hard (or maybe it is). I can write a macro (defmacro sum (a b) (+ a b)) without problem
[12:46:27] <lisp123> I want to write a macro that writes this macro
[12:46:41] <beach> That's not a great macro though.
[12:47:17] <beach> It works only for literal numbers as inputs, and its expansion is a number, not a function call.
[12:48:06] <lisp123> Yes, its a contrived example. Basically what I am trying to achieve is the ability to have macros that define functions, but also define an equivalent macro that can be macroexpanded
[12:48:26] *** Quits: ln43 (~ln43@user/ln43) (Quit: Connection closed)
[12:48:42] <beach> It can quickly get complicated, because you often end up with double backquotes.
[12:49:32] <lisp123> Yep, that's where I am at. I either end up evaluating the whole expression and getting the result (e.g. (+ 3 4) = 7), or I get (+ a b) --> but I am after (+ 3 7)
[12:50:04] <lisp123> The alternative way is to have a function that replaces all symbols, a -> 3, b -> 7, but I am curious how to do this without that
[12:51:02] <beach> Well, any attempt at using the macro you showed is not going to have the + operator in it.
[12:52:07] <lisp123> Sorry, could you expand on that?
[12:53:05] <lisp123> Sorry I was missing a backquote, it is (defmacro sum (a b) `(+ a b))
[12:53:16] <beach> That won't work either.
[12:53:26] <beach> Because now you are not referring to a nor b in the body.
[12:53:37] <lisp123> Argh sorry
[12:53:45] <lisp123> (defmacro sum (a b) `(+ ,a ,b))
[12:53:53] <beach> Now we are getting somewhere.
[12:54:06] <lisp123> So I want to have a macro that can write the above
[12:54:07] <beach> And the macro that generates this one, what do you want it to do?
[12:54:18] <beach> That's not a problem in itself.
[12:54:46] <beach> What do you want the parameters to that other macro to look like?
[12:54:47] <lisp123> As of now, if I write the above, I can do (macroexpand-1 sum 3 5) to get (+ 3 5)
[12:54:54] <lisp123> Which is perfect
[12:55:13] <lisp123> But instead of me writing (defmacro sum (a b) `(+ ,a ,b)), I want a macro to be able to create this macro
[12:55:22] <beach> What do you want the parameters to that other macro to look like?
[12:55:35] <beach> No parameters, maybe?
[12:55:43] <beach> (defmacro meta-sum () ....)?
[12:56:47] <lisp123> (in pseudo-code (defmacro expander (name parameters &body body) ... Create a function (defun name (parameters) body) AND create a macro (demacro =name (parameters) body))
[12:58:13] <beach> Already that level of nesting requires some thinking and some trial-and-error. 
[12:58:26] <beach> What do you want the function to do?
[12:58:36] <lisp123> I want to be able to macroexpand functions
[12:58:54] <beach> I don't know what that means.
[12:59:18] <lisp123> One second will give an example
[12:59:48] <lisp123> (please feel not to spend any more time on it, just if you are curious)
[13:00:14] <beach> Yeah, we'll see.
[13:03:07] <lisp123> https://plaster.tymoon.eu/view/2629#2629
[13:04:05] <beach> Sure, any attempt to macro expand a function call will just return the same function call.
[13:05:03] <lisp123> Yes, so my goal is to write a macro that can (a) write a function with equivalent details (trivial) and (b) write a similar macro, e.g. =name that will macroexpand like in the example I shown
[13:05:41] <lisp123> I can manually write (b) for each function, but want to write a macro that automatically does this
[13:07:01] <lisp123> Problem is if I stop evaluation on BODY, it will keep the parameters A & B as they are, I want to go into BODY and turn on evaluation for those parameters to replace them with the values supplied (e.g. 3 & 4)
[13:07:38] <beach> I was going to say, what do you imagine passing your macro as the value of BODY?
[13:08:05] <lisp123> a list of arbitrary forms
[13:08:22] <beach> Because you can't easily turn (+ a (+ a b)) into (+ ,a (+ ,a ,b))
[13:08:34] <lisp123> Yes, that's where I am stuck
[13:09:12] <beach> I suspect you will remain stuck.
[13:09:21] <lisp123> (The alternative I have is to have my function replace-symbols simply go through the list and replace a for 3 and b for 4)
[13:09:52] <lisp123> Do you think there is any functionality in the way defmacro generates itself to overcome this?
[13:09:53] <beach> You can't do that either, because you need a code walker to determine whether you are looking at a parameter or some random data.
[13:11:31] <lisp123> Yes, agree
[13:12:41] <lisp123> I would do it under the assumption the parameter symbols are not used for anything else
[13:13:31] <lisp123> (not perfect)
[13:15:32] <White_Flame> so basically, you want to see what the effect would sort of be like if your function was declared inline
[13:16:34] <White_Flame> a major difference here in the two implementations would be something like `(+ ,a ,a ,b), where a function would evaluate A twice, and the function would only evaluate A once
[13:16:48] <White_Flame> erm, macro would end up evaluating A twice
[13:24:46] <lisp123> White_Flame: Not so much, basically I want to macroexpand functions
[13:25:19] <lisp123> But I understand better now, that in writing macros, I am explicitly stating how they are to be expanded
[13:25:42] <lisp123> (by constructing the list of the program, and turning evaluation on), whereas a function just follows the standard evaluation rules
[13:42:41] <White_Flame> what does it mean to "macroexpand" a function?
[13:43:01] <White_Flame> the only thing I could think of would be seeing the effect of inlining a function
[13:43:24] <White_Flame> but because of the single evaluation of parameters, there's an extra wrapper around even the inline functions
[13:43:41] <White_Flame> the compiler then does its shuffling magic in optimization
[13:45:14] <White_Flame> so I guess you could consider the function call (sum a b) expand to ((lambda (x y) (+ x y)) a b)
[13:45:41] <White_Flame> which is likely equivalent to (let ((x a) (y b)) (+ x y))
[13:46:02] <White_Flame> again, not exactly how macros handle their arguments, so there is a difference
[13:47:35] <White_Flame> s/expand to/inline into/
[13:49:19] *** Joins: treflip (~user@95.79.32.99)
[13:56:33] <lisp123> White_Flame: Thanks, don't quite follow but will read into and then let you know
[13:59:09] <lisp123> what does it mean to "macroexpand" a function? >> As this is not actually a thing, I am using the phrase informally to mean return the list of forms that make up the body of the function, but with the parameters evaluated within those forms
[13:59:50] <lisp123> Hence, in (sum 3 4) -> Not to return (+ a b) (the body of the function/macro) but rather (+ 3 4) (parameters are evaluated but the whole form is not)
[14:00:44] <lisp123> However, now I understand that macroexpansions of macros tend to do that well because we are explicit in which symbols to evaluate (via ,a and ,b) and not by some "magic" of the macro itself
[14:44:25] <White_Flame> a big thing with the parameters is what happens with side effects and multiple evaluation
[14:45:04] <White_Flame> the parameter in (foo (incf bar)) evaluates to a number, and mutates a variable
[14:45:31] *** Quits: treflip (~user@95.79.32.99) (Remote host closed the connection)
[14:45:35] <White_Flame> (defmacro foo (num) `(list ,num ,num)) would increment it twice, returning (list 10 11) or something
[14:45:57] <White_Flame> while (defun foo (num) (list num num)) would increment it only once at function call time, returning (list 10 10)
[14:46:22] <White_Flame> *returning the evaluation of...
[14:52:15] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[15:13:59] *** Joins: random-nick (~random-ni@87.116.165.220)
[15:22:13] <lisp123> White_Flame: Thanks, that's a good point
[15:24:03] <White_Flame> the LET-based expansion that I had above shows how the parameters are evaluated once
[15:27:10] <lisp123> Makes sense
[15:27:55] <lisp123> Somewhat related/unrelated, I am trying to understand now why (lambda (x y) (macro-call x y)) may not always be regarded as first class function
[15:28:53] <lisp123> Relevant extract: Functions are data, while macros are more like instructions to the compiler. Functions can be passed as arguments (e.g. to apply), returned by functions, or stored in data structures. None of these things are possible with macros. In some cases, you can get what you want by enclosing the macro call within a lambda-expression. This works, for example, if you want to apply or funcall certain macros:> (funcall #’(lambda (x y) 
[15:28:53] <lisp123> (avg x y)) 1 3) --> 2. However, this is an inconvenience. It doesn’t always work, either: even if, like avg, the macro has an &rest parameter, there is no way to pass it a varying number of arguments.
[15:31:42] <White_Flame> macros are functions that are called at compile-time.  They're passed source code, and return source code for that form in that locatino
[15:32:05] <White_Flame> anything you can do in a function body, you can do in a macro body
[15:32:08] <White_Flame> it just happens at compile-time
[15:32:24] <lisp123> What does it mean that "functions are data"?
[15:32:30] <lisp123> In the above context
[15:32:33] <lotuseater> and the lambda-list can even be more flexible :)
[15:32:43] <White_Flame> extracted from where?
[15:32:55] <lisp123> It's from Stack Overflow
[15:32:56] <White_Flame> also, I think it means "function objects are data"
[15:33:21] <lisp123> I see
[15:33:43] <lisp123> So if we put a macro inside a lambda expression, it also becomes an "object"
[15:33:54] <White_Flame> no
[15:34:09] <White_Flame> the macro creates source code for the lambda body that's compiled with the lambda
[15:34:33] <White_Flame> the macro does not have any sort of macro object instantiation at runtime when the lambda is called, or when the lambda object is created
[15:34:46] <White_Flame> *function object
[15:34:48] <lisp123> But for example (defparameter *x* (lambda (x y) (macro-call x y)) 
[15:35:11] <lisp123> Does that work?
[15:35:21] <White_Flame> if the macro doesn't check for any literals
[15:35:33] <White_Flame> eg (defmacro foo (&key foo bar) ...)
[15:36:01] <White_Flame> (lambda (key val) (foo key val)) won't pass the values, the macro lambda list needs those literal keywords in the source code
[15:36:34] <White_Flame> or (lambda (stream-var filename) (with-open-file (stream-var filename) ...)))
[15:36:52] <White_Flame> it needs the literal variable symbol at compile-time
[15:37:04] <White_Flame> you can't have an expectation that you can pass that in at runtime
[15:38:50] <lisp123> Oh, so I can't do ,key
[15:39:36] <lisp123> I think that makes sense (just thinking through it)
[15:40:40] <lotuseater> Better save yourself much time and first think about when NOT to write a macro and WHY.
[15:41:05] <lisp123> This is more of a theoretical exercise :) I've learnt alot from it
[15:41:30] <lotuseater> but obviously there is much left to think of
[15:41:43] <lisp123> For example, its now drilled into me the impacts of controlling evaluation when it comes to macros vs. functions
[15:42:27] <lisp123> And I get how macroexpansion impacts inlining (which allows creating lexical environments)
[15:42:58] <lotuseater> what does a function do which it's arguments when called?
[15:43:19] <lisp123> It evaluates the arguments left to right and then supplies to the function?
[15:44:06] <lotuseater> yes
[15:44:32] <lotuseater> but a macro leaves the forms unevaluated in the first place
[15:45:19] <lisp123> ok
[15:46:15] <mfiano> Yes, you should know the 2 reasons you'd ever want to write a macro, and why you wouldn't for any other case.
[15:46:57] <lisp123> I understand they are to control or prevent evaluation and that they are expanded into their calling contet
[15:47:01] <lisp123> context*
[15:47:31] <mfiano> Macros are for evaluation control and syntactic abstractions, nothing more. They are just functions, and obey all the rules of functions, just evaluated at a different time, so are perfect for these, and only these, problems.
[15:49:59] <lotuseater> So it's better to learn how to wave the wand before you actually use it. :)
[15:52:57] <lisp123> When we say, function objects are data --> Is that because of the strict (and unambiguous) evaluation rules for functions means that they are more suitable at runtime?
[15:54:58] <lisp123> And ultimately as a macro expands into a function, theoretically the only way to pass macros "as function objects" is to ensure the resultant code evaluates correctly when in its final expanded form (this alludes to White_Flame's comment on the requirement for literal keywords in the source code)?
[15:55:40] <White_Flame> a macro doesnt' expand into a function
[15:55:54] <White_Flame> a macroexpansion calls a defmacro function, and expands into whatever that function returns
[15:56:31] <lisp123> Yes, but ultimatley that macroexpansion is reduced to only function calls yes?
[15:56:40] <White_Flame> no, it could be anything
[15:57:05] <lisp123> Oh, I though macroexpansion recursively expanded until no more macros were left
[15:57:07] <White_Flame> special forms, function calls, literals (which would be compiled away?), tagbody tags, etc
[15:57:43] <lisp123> Oh yes. So basically it expands into anything that can be evaluated at runtime?
[15:57:44] <White_Flame> (hmm, maybe not practically tagbody tags)
[15:57:52] <White_Flame> anything that can be _compiled_
[15:57:56] <White_Flame> because this is not yet runtime
[15:58:01] <mfiano> Macros are temporal artifacts. They don't exist to the "compiler" or runtime.
[15:58:11] <lisp123> Thanks, that helps
[15:58:11] <White_Flame> macros create source code right before it's compiled
[15:58:28] <mfiano> You can emit anything in them
[15:58:34] <lisp123> So the concept of looking up a macro doesn't exist when it comes to compiled code right?
[15:58:40] <White_Flame> and the parameters to the macros are the literal source code from the macro call, since runtime doesn't exist yet
[15:58:41] <lisp123> As it is expanded before then?
[15:59:07] <White_Flame> right, when you have a compiled function object at runtime, there's no notion of macro involved
[15:59:10] <lisp123> So the evaluation rules for compiled code _does not_ include macroeexpansion?
[15:59:19] <lisp123> Thank you! It's finally made sense
[15:59:34] <lisp123> Hence macros can't be "data" at runtime, they no longer exist then
[15:59:38] <White_Flame> I believe it's correct to say that macros aren't evaluated
[15:59:42] <White_Flame> (might be wrong on that)
[16:00:07] <White_Flame> whatever the macro expands to is evaluated
[16:00:56] <lisp123> Understood, and since that expansion occurs before runtime, the concept of macros during runtime is nonsensical
[16:01:28] <lisp123> Thanks White_Flame, mfiano & lotuseater - all those comments helped :)
[16:01:37] <White_Flame> if you do EVAL or COMPILE at runtime, you call the compiler and create a new compile-time. That's the only real intersection
[16:01:46] <mfiano> Sort of. There is a clear set of steps a compiler takes, with macroexpansion happening before evaluation. However, things get complicated in that any phase can recursively call any other phase.
[16:02:05] <mfiano> So for example, you can call #'compile at runtime.
[16:02:10] <mfiano> Or macroexpand, or whatever
[16:02:50] <lisp123> I see
[16:02:54] <lotuseater> like for example the function FORMAT calls the macro FORMATTER on the control-string
[16:05:12] <lisp123> I see
[16:05:55] <lisp123> Ok, macroexpansion happens before evaluation - I know this, but I appreciate now I have to keep drilling this into my mental model
[16:06:21] <mfiano> Meta-circular evaluation is hard to wrap your head around.
[16:07:22] <lisp123> So when I do (apply #'(lambda (x y) (macrocall x y)) 3 4) --> The lambda wrapping around the macrocall is ensuring the macroexpansion takes place before it reaches apply?
[16:07:55] <White_Flame> the macro will be passed the symbols X and Y as its parameter for macroexpansion
[16:08:10] <White_Flame> whatever code it returns will be compiled as the body of the lambda function
[16:08:16] <lisp123> Understood
[16:10:03] <lisp123> Whereas (apply (macrocall x y) 3 4) would give an error as (macrocall x y) would be using "x" and "y" and not 3 & 4, furthermore it would be returning what that expansion returns and not the function object onto which 3 & 4 are applied?
[16:10:13] <mfiano> Both would give an error
[16:12:16] <mfiano> Because you are using APPLY where FUNCALL is needed.
[16:12:28] <White_Flame> https://plaster.tymoon.eu/view/2631#2631
[16:12:57] <White_Flame> here, the macro return genereates source code which names the labels function
[16:14:09] <lisp123> White_Flame: Thanks that makes ense
[16:14:21] <lisp123> mfiano: Yes, sorry you are right
[16:24:57] <lisp123> So I think this phrase, "function is data" or "function objects are data" is misleading given meta-circular evaluation, as White_Flame's example shows, we _can_ pass macros in nicely to apply or funcall, it just needs to evaluate to the right form that is expected by these functions (namely a function object)
[16:25:17] <lotuseater> it is "code is data"
[16:25:21] <White_Flame> that macro has nothing to do with runtime function objects
[16:25:35] <White_Flame> and yes, the symbols, lists, etc that make up the source code are plain runtime objects to the compile-time environment
[16:25:45] <White_Flame> s/to/in/
[16:26:12] <lisp123> lotuseater: yes "code is data" makes sense, "functions is data" I think is unnecessarily precluding other types of objects
[16:27:38] <White_Flame> at runtime, the value that #'foo evaluates to (or (lambda ...)) is a normal data object that can be passed around
[16:27:50] <White_Flame> and eventually funcalled or applied
[16:28:09] <White_Flame> I think that's all that that was saying
[16:28:56] <lisp123> Understood
[16:37:38] *** Joins: cranium (~cranium@user/cranium)
[16:40:19] <beach> lisp123: The phrase "function objects are data" means just that you can do with a function object whatever you can do with any other first-class thing (also known as a "datum" or an "object"), which is assign it to a variable, pass it as an argument to a function, and return it as a value from a function.  
[16:41:29] <beach> lisp123: A "macro" is not a first-class object, but the macro function resulting from the definition of a macro is.  
[16:45:33] <beach> lisp123: And you can indeed do (funcall (macrocall x y) 3 4), provided that the macro MACROCALL expands to code that, when evaluated, produces a function.  For example (defmacro macrocall (a b) (declare (ignore a b)) '#'+)
[17:02:02] <lisp123> Beach: thanks, yes now I finally understood that
[17:03:04] <lisp123> "A "macro" is not a first-class object, but the macro function resulting from the definition of a macro is." --> do you mean the macroexpansion (i.e. what is returned by (macrocall x y) is a first-class object?
[17:05:25] <beach> Yes, what a macro call returns is an ordinary datum.
[17:05:42] <lisp123> Thanks!
[17:05:47] <beach> But that is not what I meant.
[17:06:11] <beach> I meant that (macro-function 'macrocall) returns an ordinary function.
[17:06:28] <beach> So it is a first-class object just like any other function.
[17:12:13] <beach> lisp123: When the compiler sees a macro call like (macrocall x y), what it basically does is (funcall (macro-function 'macrocall) '(macrocall x y) <some-environment>) and then it compiles the result of that call in place of the original (macrocall x y).
[17:14:21] <lisp123> That is very useful to know, thanks!
[17:14:30] <beach> Sure.
[17:15:19] <lisp123> All of you are too helpful :) I wish I had a way to give back
[17:15:42] <beach> You will, when you are ready.  
[17:15:57] <beach> At least that is what I am betting on, or I wouldn't spend this much time.
[17:16:04] <lisp123> I will try my best
[17:23:39] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[18:14:15] *** Joins: Josh_2 (~user@37.25.47.130)
[18:15:08] *** Quits: hendursa1 (~weechat@user/hendursaga) (Quit: hendursa1)
[18:15:37] *** Joins: hendursaga (~weechat@user/hendursaga)
[18:16:03] *** Quits: Josh_2 (~user@37.25.47.130) (Remote host closed the connection)
[18:25:02] *** Joins: Josh_2 (~user@37.25.47.130)
[18:25:14] *** Quits: cranium (~cranium@user/cranium) (Quit: Leaving)
[18:44:50] *** Joins: tyson2 (~user@cpe688f2ec1f9b3-cm688f2ec1f9b0.cpe.net.cable.rogers.com)
[18:54:40] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[19:35:45] *** Joins: thrig (~thrig@65.113.153.50)
[20:02:21] <lisp123> Beach: I figured something out to the question from the start of the discussion
[20:02:36] <lisp123> (in very basic & badly written form): https://plaster.tymoon.eu/view/2632#2632
[20:04:08] *** Quits: tyson2 (~user@cpe688f2ec1f9b3-cm688f2ec1f9b0.cpe.net.cable.rogers.com) (Ping timeout: 265 seconds)
[20:04:10] <lisp123> The basic principle came from here: https://stackoverflow.com/a/4052618/10938537 (the rest is my very bad implementation which can get cleaned up, I just wanted to test out the idea)
[20:14:26] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[20:19:24] <beach> Sure, why not.
[20:44:00] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[20:51:06] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[21:11:57] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[21:17:53] <lotuseater> lisp123: please don't do this in that way
[21:18:57] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[21:38:13] <lisp123> lotuseater: Is there another way (without eval) to achieve this?
[21:39:00] <thrig> nobody expects the mediEVAL inquisition!
[21:39:54] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[21:41:23] <lotuseater> when macros need helper functions those are usually used for building s-exprs
[21:44:07] <lotuseater> and when building a new symbol like =FOO out of = and FOO you should use something like (alexandria:symbolicate '= 'foo)
[21:44:33] <lisp123> Yes, I have to clean up all that - this was a proof of concept around eval
[21:46:13] <lisp123> The key point I got from that SO link was that we can use eval to delay evaluation of macros after compiliation
[21:47:14] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[21:47:26] <thrig> the key point I got was "gosh that's complicated and I probably wouldn't be able to debug it"
[22:05:46] <lotuseater> sounds way too advanced for now
[22:06:18] <lotuseater> so go a few steps back and work on having a more stable ground to build on :)
[22:07:00] <thrig> also I mostly don't use the repl, so repl repl macros ... uh why?
[22:07:24] <lotuseater> by that I mean discovering in more detail important and often used standard symbols and how macros like PUSH, POP, AND, OR work and why they are such and not functions
[22:08:30] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[22:11:09] <lisp123> +1 that's a good idea. This was just an itch I had to satisfy (figuring out this problem), and I've certainly learnt a lot today
[22:11:58] <lotuseater> I hope not too much that's now false stuck.
[22:12:27] <lisp123> It's a learning process, eventually the true parts will stick more
[22:12:42] <lotuseater> read On Lisp by Paul Graham
[22:13:01] <lisp123> I have read maybe 40% of it, and plan to read the rest
[22:13:11] <thrig> I have read it. wrote some complicated macros. then I stopped doing that
[22:13:27] <lotuseater> thrig: ok and now?
[22:13:58] <thrig> no complicated macros
[22:14:02] <lotuseater> and of course not just reading but trying out yourself
[22:14:06] *** Joins: santiagopim (~user@90.167.66.93)
[22:14:23] <lotuseater> good, means elegance
[22:15:41] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[22:26:01] <pjb> lisp123: (let ((expr '(* a (/ (+ b c) (- b c))))) (dolist (subst '((a 1) (b 2) (c 3)) expr) (setf expr (subst (second subst) (first subst) expr))))  #| --> (* 1 (/ (+ 2 3) (- 2 3))) |# 
[22:31:29] <pjb> lisp123: https://termbin.com/2njf
[22:32:37] <pjb> lisp123: note: don't use ` , and ,@ because those are reader macros, ie. they are text with syntax that needs to be parsed, and to use it, you need to build a text instead of a sexp!
[22:32:46] <pjb> (in your generator).
[22:35:59] <lotuseater> "f ← (⍺+⍵)/⍺-⍵ ⋄ 2 f 3" :)
[22:36:27] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[22:37:58] <lisp123> pjb: thanks, I was thinking that route as well
[22:37:59] <lotuseater> or "[a;b;c] a×(b+c)/b-c"
[22:38:05] <lisp123> Where I fell over was in this example: https://plaster.tymoon.eu/view/2633#2633
[22:38:05] <pjb> lisp123: with examples: https://termbin.com/91ej
[22:38:22] <lisp123> (where there are multiple references to a symbol but in different contexts)
[22:39:02] <lisp123> (thanks for the note sexp & reader macros)
[22:41:56] <lisp123> pjb: make-generator is super cool, did you have it in your utils or something you created just now?
[23:14:59] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[23:25:12] *** Joins: Oladon (~olad@98.43.81.226)
[23:29:40] <pjb> lisp123: just created now.
[23:30:17] <pjb> lisp123: the structure of evaluators is always the same: you test for atoms, then you test the operator (if applicable), and you process the arguments, recursively.
[23:30:28] <pjb> lisp123: read AIM-8, it's exactly the same.
[23:31:08] <pjb> http://informatimago.com/develop/lisp/com/informatimago/small-cl-pgms/aim-8/aim-8.html
[23:31:42] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[23:32:00] *** Quits: thrig (~thrig@65.113.153.50) (Remote host closed the connection)
[23:32:13] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[23:32:28] *** Joins: lisp123 (~lisp123@5.30.23.247)
[23:32:40] <lisp123> pjb: Many thanks, will have a read of AIM-8 now
[23:40:50] <pjb> lisp123: just keep in mind that "evaluating" a symbol expression, is not limited to evaluating arithmetic expressions or lisp programs.  You can make evaluators to transform expressions of anything into anything you want. 
[23:41:22] <pjb> what "evaluation" means is that the processing is directed by the data, following the structure of the data.
[23:41:36] <pjb> hence the cond, which tests the structure of the data and decide what to do from it.
[23:41:50] <pjb> It's data-driven programming.
[23:42:10] <pjb> s/a symbol expression/a symbolic expression/
[23:42:16] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[23:43:19] <lisp123> Thanks - that's a good way to look at it. I guess in Lisp the process is to look at whether it is an atom, then look at the CAR and see if it is a special form or macro or function, and then to apply the right processing based on what type of data is there
[23:43:51] <pjb> right.
[23:44:23] <lisp123> Is there any alternate approachs vs. data-driven programming?
[23:44:35] <lisp123> Or do all languages ultimately do that
[23:45:44] <pjb> Well, you can do data-driven programming in all programming language.  Programming styles are programming-language neutral.
[23:45:49] <pjb> But in some languages it's easier.
[23:45:55] <pjb> I learned it in COBOL! ;-)
[23:46:36] <lisp123> Wow COBOL :)
[23:47:54] <pjb> Basically LCP, (Logique de Construction de Programmes = program construction logic) was a method used to build structured programming program notably in COBOL, and an important part of the method was data-drive programming, where you analyzed and designed the structure of your data (and file format, ie card decks or tape file record structures), and from this data structure description (a tree aka a sexp), you derivate the structure of
[23:47:54] <pjb> your program.
[23:49:16] <pjb> Basically when you have single elements (a "union" or record or structure), you have some sequence processing of each elements.  When you have a vector or list of elements, you have a loop. When you have alternatives, you have conditionals.
[23:50:09] <lisp123> That sounds complex
[23:50:12] <pjb> http://m.tourneur.perso.infonie.fr You can go thru google translation and browse the chapters on the left.
[23:50:20] <pjb> No, it's quite simple actually.
[23:50:26] <lisp123> I will have a read, sounds interesting
[23:51:24] <lisp123> Did you like programming in COBOL?
[23:51:26] <pjb> lisp123: you have to realize that in the 60s 70s, sequential files of records were quite important (in mainframes). You had chains of programs that communicated thru those files.
[23:52:29] <pjb> Well, not really, compared to Pascal, Modula-2, C, Smalltalk, etc even assembler. I quickly decided to never take a cobol job.  But I was young… :-)
[23:53:05] <pjb> I like programming languages, anyways, so from time to time, I compile my student cobol programs and have fun with them, nowadays with open cobol on linux! 
[23:53:44] <lisp123> I wish I could have programmed in those days, sounds like a lot more fun :) I read there is still some important cobol code in some banks etc
[23:54:04] <lotuseater> "some"
[23:54:40] <lotuseater> nearly in 80% of bank and insurance backend relies on such legacy stuff
[23:54:45] <pjb> The thing is that those programs processed text files, and used at the most sophisticated, interactive text terminals, (like Common Lisp *terminal-io* and standard I/O functions), so this is very simple compared to all the complications we have nowadays either with web programming or with GUIs and all their complications.
[23:55:30] <pjb> Indeed. You can take Open Cobol on Linux and learn it, and get a job^W a career!
[23:55:51] <pjb> You do OO and web with Cobol nowadays.
[23:56:16] <lisp123> Yes now it seems like one person cannot do much by themselves (meaningfully). Software is too complex
[23:56:33] <lisp123> Hmm time to join #cobolschool ;) :D
[23:56:37] <pjb> Yes, it's still possible.  If you're young, you can do it.
[23:56:43] <pjb> :-)
[23:57:21] <pjb> For example, there are industrial game software production, but there are still indi game programmers.
[23:58:20] <White_Flame> lisp123: on the contrary, an individual developer can create way more now than they could have in th epast
[23:58:50] <White_Flame> so many burdens have been lifted from you, compared to decades past
[23:59:01] <lisp123> Maybe its a problem with me then ;) :D
[23:59:01] <pjb> Of course, an independent game programmer will produce a $1 or $2 game on the appstore (and may possibly make a living of it), while an industrial game production studio will produce a 5 GB game that they will sell by buying a lot of ads.
[23:59:09] <pjb> Or  produce for PS5…
[23:59:25] <White_Flame> 5GB = indie game, 100GB = AAA game :-P
[23:59:59] <pjb> Exactly. I've done that, reproducing programs from the past.  Projects that took several years for whole teams, you can reproduce them with CL and modern computers and tools in a few months alone.
