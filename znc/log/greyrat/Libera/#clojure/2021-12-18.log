[00:00:15] *** Joins: matty_matt (~matt@129.222.239.110)
[00:04:37] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[00:04:55] *** Quits: puchka (~marius@165.73.240.60) (Remote host closed the connection)
[00:15:20] *** Joins: dadinn (~dadinn@cpc87065-finc18-2-0-cust67.4-2.cable.virginm.net)
[00:28:07] *** Quits: schmudde (~schmudde@216.169.6.249) (Read error: Connection reset by peer)
[00:29:25] *** Joins: schmudde (~schmudde@216.169.6.249)
[00:35:31] *** Quits: shiranaihito_ (~textual@123-192-192-149.dynamic.kbronet.com.tw) (Quit: My MacBook Air has gone to sleep. ZZZzzz‚Ä¶)
[00:42:37] *** Quits: schmudde (~schmudde@216.169.6.249) (Ping timeout: 240 seconds)
[01:33:13] <mwnaylor> One benefit of not solving every AoC puzzle on the day it's released is the opportunity to build my magit skills. My completed puzzles are now my master branch. Each new day, I created a new branch to solve. Once I get success on both parts 1 and 2, I merge back into master. Also, I'm seeing patterns that show up in new puzzles that are the same as prior days. That yells refactor to me. Stuff I recreate should be in my advent-2021.core
[01:33:13] <mwnaylor> namespace. Maybe this is chance to work on the bug-fix branch idea?
[01:33:58] <mwnaylor> Forgive multiple post. That's what my emacs erc client sends to server.
[01:52:17] *** Joins: libertyprime (~libertypr@125-239-52-43-fibre.sparkbb.co.nz)
[01:55:50] *** Quits: peterhil (~peterhil@dsl-hkibng32-54fb56-2.dhcp.inet.fi) (Read error: Connection reset by peer)
[01:57:39] *** Joins: peterhil (~peterhil@dsl-hkibng32-54fb56-2.dhcp.inet.fi)
[01:58:18] *** Joins: matty_matt (~matt@129.222.239.110)
[01:59:26] *** Quits: peterhil (~peterhil@dsl-hkibng32-54fb56-2.dhcp.inet.fi) (Max SendQ exceeded)
[02:02:07] *** Joins: schmudde (~schmudde@216.169.6.249)
[02:02:50] *** Joins: peterhil (~peterhil@dsl-hkibng32-54fb56-2.dhcp.inet.fi)
[02:18:40] *** Joins: atw (~user@2601:5c2:c500:76b0::78e6)
[02:25:09] *** Joins: poselyqualityles (~poselyqua@user/poselyqualityles)
[02:27:59] *** Quits: cmiles74 (~miles@068-184-030-013.res.spectrum.com) (Ping timeout: 256 seconds)
[02:43:36] *** Joins: xulfer (uid452788@id-452788.ilkley.irccloud.com)
[02:46:41] *** Quits: poselyqualityles (~poselyqua@user/poselyqualityles) (Ping timeout: 256 seconds)
[03:04:03] *** Joins: cmiles74 (~miles@068-184-030-013.res.spectrum.com)
[03:04:57] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[03:07:17] *** Quits: schmudde (~schmudde@216.169.6.249) (Ping timeout: 240 seconds)
[03:37:35] *** Joins: OscarZ (~oscarz@5d.57.36a9.ip4.static.sl-reverse.com)
[03:39:57] *** Quits: mamapitufo (~mamapituf@188.30.140.224.threembb.co.uk) (Ping timeout: 240 seconds)
[03:39:57] *** Quits: seschwar (~seschwar@user/seschwar) (Ping timeout: 256 seconds)
[03:42:30] *** Joins: seschwar (~seschwar@user/seschwar)
[03:56:38] *** Joins: matty_matt (~matt@129.222.239.110)
[03:57:00] *** Quits: cmiles74 (~miles@068-184-030-013.res.spectrum.com) (Ping timeout: 268 seconds)
[04:04:37] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[04:19:17] *** Quits: atw (~user@2601:5c2:c500:76b0::78e6) (Ping timeout: 240 seconds)
[04:20:42] *** Quits: seschwar (~seschwar@user/seschwar) (Quit: :wq)
[04:57:56] *** Joins: atw (~user@2601:5c2:c500:76b0::2db8)
[05:07:53] *** Joins: schmudde (~schmudde@216.169.6.249)
[05:09:15] *** Joins: cmiles74 (~miles@068-184-030-013.res.spectrum.com)
[05:29:35] *** Quits: OscarZ (~oscarz@5d.57.36a9.ip4.static.sl-reverse.com) (Quit: Leaving)
[05:52:56] *** Quits: libertyprime (~libertypr@125-239-52-43-fibre.sparkbb.co.nz) (Ping timeout: 268 seconds)
[05:56:38] *** Quits: cmiles74 (~miles@068-184-030-013.res.spectrum.com) (Ping timeout: 268 seconds)
[06:04:09] *** Joins: matty_matt (~matt@129.222.239.110)
[06:08:59] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[06:22:44] *** Joins: ajoberstar (~user@97-116-72-197.mpls.qwest.net)
[06:34:19] *** Joins: libertyprime (~libertypr@118-92-72-229.dsl.dyn.ihug.co.nz)
[06:53:11] *** Quits: schmudde (~schmudde@216.169.6.249) (Ping timeout: 256 seconds)
[07:09:45] *** Joins: cmiles74 (~miles@068-184-030-013.res.spectrum.com)
[07:11:16] *** Quits: ajoberstar (~user@97-116-72-197.mpls.qwest.net) (Remote host closed the connection)
[07:11:39] *** Joins: ajoberstar (~user@97-116-72-197.mpls.qwest.net)
[07:12:20] *** Quits: ajoberstar (~user@97-116-72-197.mpls.qwest.net) (Client Quit)
[07:30:56] *** Joins: matty_matt (~matt@129.222.239.110)
[07:35:37] *** Quits: atw (~user@2601:5c2:c500:76b0::2db8) (Ping timeout: 240 seconds)
[07:57:13] *** Quits: cmiles74 (~miles@068-184-030-013.res.spectrum.com) (Ping timeout: 256 seconds)
[08:03:21] *** Quits: libertyprime (~libertypr@118-92-72-229.dsl.dyn.ihug.co.nz) (Quit: leaving)
[08:24:10] *** Joins: poselyqualityles (~poselyqua@user/poselyqualityles)
[08:32:21] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[08:35:07] *** Quits: poselyqualityles (~poselyqua@user/poselyqualityles) (Ping timeout: 268 seconds)
[09:09:59] *** Joins: cmiles74 (~miles@068-184-030-013.res.spectrum.com)
[09:13:06] *** Joins: samebchase (~samebchas@51.15.68.182)
[09:33:15] *** Quits: faxmodem (~faxmodem@82-65-124-102.subs.proxad.net) (Quit: so long and thanks for all the fish)
[09:34:58] *** Joins: faxmodem (~faxmodem@82-65-124-102.subs.proxad.net)
[09:56:37] *** Quits: cmiles74 (~miles@068-184-030-013.res.spectrum.com) (Ping timeout: 240 seconds)
[10:29:26] *** Joins: matty_matt (~matt@129.222.239.110)
[10:33:37] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[10:36:10] *** Quits: xulfer (uid452788@id-452788.ilkley.irccloud.com) (Quit: Connection closed for inactivity)
[11:08:45] *** Joins: shiranaihito (~textual@123-192-192-149.dynamic.kbronet.com.tw)
[11:10:44] *** Joins: cmiles74 (~miles@068-184-030-013.res.spectrum.com)
[11:53:31] *** Quits: jespada (~jespada@87.74.33.157) (Ping timeout: 256 seconds)
[11:56:16] *** Joins: jespada (~jespada@87.74.33.157)
[11:57:02] *** Quits: cmiles74 (~miles@068-184-030-013.res.spectrum.com) (Ping timeout: 240 seconds)
[12:03:02] *** Quits: euandreh (~euandreh@2804:14c:33:9fe5:1e71:dc8c:d2fa:3d7e) (Ping timeout: 252 seconds)
[12:04:47] *** Joins: euandreh (~euandreh@2804:14c:33:9fe5:995c:e86e:470c:8a37)
[13:10:32] *** Joins: cmiles74 (~miles@068-184-030-013.res.spectrum.com)
[13:18:57] *** Quits: Colt (~Colt@user/colt) (Quit: Leaving)
[13:19:14] *** Joins: Colt (~Colt@user/colt)
[13:56:32] *** Quits: cmiles74 (~miles@068-184-030-013.res.spectrum.com) (Ping timeout: 240 seconds)
[14:11:35] *** Joins: puchka (~marius@165.73.241.3)
[14:46:33] *** Joins: seschwar (~seschwar@user/seschwar)
[14:46:41] *** Joins: uncleyear (~ian@pppoe.178-66-158-61.dynamic.avangarddsl.ru)
[14:51:31] *** Quits: uncleyear (~ian@pppoe.178-66-158-61.dynamic.avangarddsl.ru) (Remote host closed the connection)
[14:52:29] *** Joins: uncleyear (~ian@pppoe.178-66-158-61.dynamic.avangarddsl.ru)
[15:10:35] *** Joins: cmiles74 (~miles@068-184-030-013.res.spectrum.com)
[15:45:58] *** Joins: rito_ (~rito_gh@45.112.243.172)
[15:56:37] *** Quits: cmiles74 (~miles@068-184-030-013.res.spectrum.com) (Ping timeout: 240 seconds)
[16:16:55] *** Quits: lagash (lagash@lagash.shelltalk.net) (Ping timeout: 250 seconds)
[16:22:35] <rito_> I have noob question here. I am learning Clojure to learn functional paradigm. Is Clojure a good language for this purpose? Or should I focus on something else?
[16:22:59] <rito_> I want to "grow as a programmer", and hence want to properly learn the functional paradigm.
[16:23:10] <rito_> So, that my code is good elsewhere.
[16:23:30] <rito_> Do you recommend Clojure for it? Or do you recommend something other than it?
[16:23:50] <rito_> I am already quarter-way through "Getting Clojure" from PragPub.
[16:30:45] *** Joins: matty_matt (~matt@129.222.239.110)
[16:31:44] *** Quits: son0p (~ff@2800:484:1d81:b700:d40b:900:b387:320) (Remote host closed the connection)
[16:32:31] <ridcully> rito_: if you are seasoned programmer from the {}-langs or OO or whatever, clojure is a great way to push you out of your comfort zone.  it's functional programming with immutable data (the imho hard part) with a lisp syntax (the imho "easy" part where people think the hard part is)
[16:46:02] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 240 seconds)
[17:09:58] *** Joins: cmiles74 (~miles@068-184-030-013.res.spectrum.com)
[17:29:33] <mwnaylor> imho, Clojure would be easier than Haskell for learning fp.
[17:29:52] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.3)
[17:36:45] *** Quits: xsperry (~xs@user/xsperry) (Remote host closed the connection)
[17:37:19] *** Joins: xsperry (~xs@user/xsperry)
[17:38:33] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[18:06:43] *** Joins: atw (~user@2601:5c2:c500:76b0::e27b)
[18:07:19] *** Joins: matty_matt (~matt@129.222.239.110)
[18:07:56] <mwnaylor> I'm tempted to use read-string in a small project. Lines in the input file look exactly like an acceptable representation of a basic Clojure data type. I ùò©ùò¢ùò∑ùò¶ read the entire file in a text-mode buffer. It is all data and no code forms.
[18:07:57] *** Quits: cmiles74 (~miles@068-184-030-013.res.spectrum.com) (Ping timeout: 240 seconds)
[18:09:12] <ridcully> be sure to make that clojure.edn/read-string
[18:09:43] <ridcully> the regular read-string allows for code execution and it highly dangerous if the source for your string to read is under enemy control
[18:18:52] *** Quits: matty_matt (~matt@129.222.239.110) (Ping timeout: 256 seconds)
[18:21:46] <mwnaylor> That is a good tip. In this case, the core version would have been safe, with the sample file. BUT clojure.edn/read-string seems a best practice.
[18:21:49] *** Joins: cmiles74 (~miles@068-184-030-013.res.spectrum.com)
[18:23:57] *** Quits: atw (~user@2601:5c2:c500:76b0::e27b) (Ping timeout: 240 seconds)
[18:24:26] <rito_> [mwnaylor]: thanks, the second option I have is Elixir.
[18:24:59] <rito_> There's a book explicitly for learning Functional Programming and Elixir together, also from PragPub.
[18:25:16] <rito_> That is my second option. My ideal goal is to read and do both.
[18:25:31] <rito_> So far, I have been finding it easy.
[18:26:25] <rito_> [ridcully]: yes, definitely the LISP part is the easy one. LISP is a language with very easy and limited syntax. It was *designed* like that.
[18:26:59] <rito_> I had worked through some of SICP before, and most of The Little Schemer.
[18:27:06] <selfsymmetric-mu> It's like how I took Russian in school and everyone was impressed I could read the alphabet.
[18:28:02] *** Joins: atw (~user@2601:5c2:c500:76b0::8d0a)
[18:28:43] <selfsymmetric-mu> I thought Let Over Lambda was delightful. Made me understand the magical things you could do with scope in a Lisp.
[18:34:07] <Para> AFAIK one should use https://github.com/clojure/tools.reader instead of clojure.edn/read-string or the regular one; of course sci an option as well, depending on what you want exactly.
[18:35:52] <ridcully> i assumed reading aoc examples
[18:36:14] <ridcully> or the generic "just data" (and for sure no surprises)
[18:41:52] <mwnaylor> Yes, aoc, but didn't want to reveal too many spoilers.
[18:42:57] <ridcully> i think it's safe to assume, that we all had to add tooling for things like that to our solutions
[18:43:38] <ridcully> e.g. i have (defn read-array [s] (edn/read-string "[" s "]")) around
[18:43:51] <ridcully> with the `,` white-space you can read lots of stuff with that already
[18:44:37] *** Quits: atw (~user@2601:5c2:c500:76b0::8d0a) (Ping timeout: 240 seconds)
[18:50:52] *** Joins: schmudde (~schmudde@216.169.6.249)
[19:03:04] *** Quits: schmudde (~schmudde@216.169.6.249) (Ping timeout: 256 seconds)
[20:05:37] *** Joins: lagash (lagash@lagash.shelltalk.net)
[20:29:39] *** Joins: mamapitufo (~mamapituf@109.123.118.63)
[21:17:37] *** Joins: atw (~user@2601:5c2:c500:76b0::1d0f)
[21:22:48] *** Joins: tatsumaru (~tatsumaru@82.147.131.155)
[21:23:39] *** Quits: tatsumaru (~tatsumaru@82.147.131.155) (Client Quit)
[21:24:32] *** Joins: tatsumaru (~tatsumaru@82.147.131.155)
[21:24:47] <tatsumaru> hey guys, what's the difference between 'clojure.core' and 'clojure.lang'?
[21:28:40] <technomancy> tatsumaru: clojure.lang is a Java package and clojure.core is a clojure namespace
[21:30:09] <tatsumaru> hmm interesting (type list) is described by clojure.lang and (type vector) by clojure.core, can you say why please?
[21:32:01] <technomancy> list is a function that's implemented in Java and vector is a function written in clojure
[21:32:27] <technomancy> I think that code is not doing what you think it's doing; you're just getting the class for the function itself, not the data structure
[21:32:46] <technomancy> you probably want (type (list)) and (type (vector))
[21:33:59] <tatsumaru> actually I don't have expectations yet, I am just exploring the language. I don't have a programming background so some of my questions may not make any sense.
[21:35:05] <tatsumaru> i think I understand your explanation though, thanks
[21:35:58] <tatsumaru> i am guessing that only stuff that wasn't available in java already was written in clojure?
[21:36:05] <technomancy> sure. I think taking the type of a function could be interesting if you're curious about how clojure was implemented but probably not that relevant for learning how to use it.
[21:36:36] <technomancy> haha well... only Rich could say for sure. back in 2011 or so he said he wanted to rewrite all of clojure in clojure, but then he switched gears to focus on datomic, cljs, etc
[21:37:16] <tatsumaru> what are the benefits of rewriting clojure in clojure? is it about consistency?
[21:38:20] <technomancy> the primary benefit is that no one would ever have to look at the hideous indentation style used in clojure's Java code
[21:38:42] <technomancy> jk
[21:38:44] <tatsumaru> lol
[21:38:56] <tatsumaru> *not a java enthusiast*
[21:39:16] <technomancy> even Java fans would hate the way that Java code looks
[21:39:34] <technomancy> anyway the primary benefits are maintainability and finding gaps in the capabilities of clojure
[21:39:51] <technomancy> like if you try to become self-hosting and you fail, it points to a shortcoming in the language that needs to be addressed
[21:40:17] <technomancy> fun fact: that's why protocols and deftype exist; before they were added to the language, clojure could not have been implemented in itself
[21:40:59] <technomancy> I guess Rich thought thru everything and found the impediments to self-hosting, addressed them, and then never bothered to take it the rest of the way because he's OK with having a codebase that no one except him understands
[21:41:16] <tatsumaru> lol
[21:41:27] <tatsumaru> is it some big mess?
[21:42:07] <technomancy> well, I don't even know Java, so what do I know
[21:44:52] <Para> In perfect world there would be a tiered approach where there's core written in the language, bindings from the language to required native abstractions and native abstractions, but yeah, it's somewhere in between...
[21:45:23] <Para> And yeah, I have no idea either where Rich got his Java indentation style :D It's worst I've ever seen. Or maybe that's a deterrent on purpose?
[21:45:44] <technomancy> it's like when a frog has brightly colored markings to deter predators
[21:46:26] <tatsumaru> Isn't that to attract a mate?
[21:46:38] <technomancy> lol who knows
[21:46:48] <tatsumaru> Maybe he's looking for people who appreciate his indentation style
[21:47:20] <technomancy> I guess cljs is at least somewhat self-hosted so that's something
[21:48:10] <Para> My favorite dendrobates happens to be azureus, which apparently is called tinctorius now. It has an infertile mutation as well :) And I suppose it's an apt comparison.
[21:48:59] <Para> I also remember reading that animals in general don't really see their colorings, so there's no strong mating relation to it.
[21:49:18] <Para> Which of course begs the question why eg. puffer fish build those literal massive mating grounds and how do birds even work.
[21:49:37] <tatsumaru> play *x-files* intro music
[21:49:41] *** nullm0de1 is now known as nullm0dem
[21:50:00] <Para> https://www.youtube.com/watch?v=8YWl7tDGUPA
[21:50:43] <tatsumaru> haha
[21:53:41] *** Quits: dadinn (~dadinn@cpc87065-finc18-2-0-cust67.4-2.cable.virginm.net) (Ping timeout: 245 seconds)
[22:08:11] <tatsumaru> is it true, it's preferable to avoid the use of "do" in clojure to minimize side effects?
[22:10:15] <technomancy> yeah, where possible.
[22:11:47] <Para> I think the only place where I regularly see do is `(do (for [...` in CLJS/reagent
[22:11:52] <Para> That might be a wart though.
[22:14:07] <ridcully> what does do/for do in cljs?
[22:18:19] <Para> ...started thinking, might be doall+for
[22:18:32] <Para> Basically getting around laziness in reagent
[22:25:26] <atw> tatsumaru: you may find "do" necessary if you want to, for instance, log something from the branch of an if expression
[22:27:34] <Para> Sometimes it's also pretty alright in, say, a branch of `if` where you want to run two functions which cannot be `comp`'d together.
[22:29:03] *** Quits: puchka (~marius@165.73.241.3) (Quit: leaving)
[22:29:59] <technomancy> I've gotten in the habit of logging using (doto x (prn :HAY)) which is easy to inject into basically anywhere
[22:30:55] <technomancy> (for temporary debug logging, that is, not something you would leave in)
[22:35:34] *** Quits: paddymahoney (~paddymaho@cpe9050ca207f83-cm9050ca207f80.cpe.net.cable.rogers.com) (Ping timeout: 256 seconds)
[22:36:22] *** Joins: ajoberstar (~user@97-116-72-197.mpls.qwest.net)
[22:43:03] <Para> For that you need log4j.
[22:43:36] <tatsumaru> Is that safe to use now? Heard they found some vulnerability in that.
[22:45:20] <goodger> just a small one
[22:46:54] <Para> There was a new release just yesterday, or was it today.
[22:47:09] <Para> Turns out there was a fork bomb as well, among other things, in the variable expansion syntax :D
[22:48:55] <technomancy> PSA: http://www.slf4j.org/legacy.html exists
[22:49:01] <Para> Yeah.
[22:49:45] <Para> slf4j is pretty much all what one needs, and then those bridges where applicable
[22:50:34] <technomancy> feel like we dodged a bullet at work by having switched to that several years ago
[22:51:12] <Para> I haven't used log4j for a decade.
[22:51:38] <Para> Like, I've pretty much always used slf4j+logback.
[22:52:10] <Para> It's just a legacy thing, 
[22:52:32] <Para> I still haven't been made clear why I'd use timbre, tbh :)
[22:53:04] <ajoberstar> wouldn't call log4j2 legacy (at least if you're comparing with slf4j)
[22:53:36] <ajoberstar> It has some nice features with lambdas and json logging that aren't as easy (or may be not possible, haven't looked in a while) in slf4j
[22:53:38] <Para> I would call log4j2 fighting against windmills.
[22:54:00] <Para> One can polish a turd as proven by Mythbusters but at the end of it it's still just a ball of poop :)
[22:54:17] <technomancy> "it has these nice features you've never heard of" is kind of the whole problem
[22:55:27] <ajoberstar> *shrug* agree to disagree
[22:55:37] <Para> The only feature I can think of on top of slf4j that's still useful is providing the log row as a closure.
[22:55:45] <Para> The appenders do provide JSON logging etc.
[22:55:49] <tatsumaru> Para: turd could turn into fertilizer
[22:56:24] <Para> tatsumaru: and the current hype thing about data is that it isn't oil but manure/fertilizer.
[22:56:47] <ajoberstar> Logback's json support was a third-party appender last time I looked, but that was a few years ago
[22:56:56] <Para> ajoberstar: So?
[22:57:07] <Para> Like 97% of all java apps are 3rd party anyway :)
[22:58:04] <Para> Producing JSON from MDC or other native ways of providing objects to be serialized with Jackson are just fine.
[22:58:14] <technomancy> we use structured logging thru graylog and kibana at work thru slf4j and it works great. no idea if it's json or whatever under the hood
[22:58:35] *** Joins: dadinn (~dadinn@82-132-214-226.dab.02.net)
[22:58:56] <ajoberstar> Para: Log4j2's is jackson under the hood too, so not arguing third-party as a whole
[22:59:12] <Para> There is apparently GELF appender available, hmm
[22:59:14] <ajoberstar> Para: just didn't want my core appender to be maintained with different consistency than the main lib
[22:59:25] <Para> ajoberstar: That sounds like a non-issue TBH.
[22:59:59] <Para> Also, as technomancy said, the problem here is that log4j2 is bundling everything with a very wide scope.
[23:00:20] <Para> Jackson has numerous CVEs on its own, and managing multiple versions of it in the classpath is at times pure terror.
[23:01:42] <technomancy> jackson databind is the worst offender by far; once we excluded databind I can't remember ever seeing any CVEs
[23:02:01] <technomancy> jackson databind is actually a lot like the LDAP log4j thing; magic shit no one asked for that you pulled in by accident
[23:02:40] <atw> technomancy: re (doto x (prn :HAY)) -- interesting, it's sorta like prog1 :p
[23:02:52] <technomancy> atw: heh yeah exactly
[23:04:41] <atw> re magic no one asked for: I wonder if it would be possible to have an API-compatible, mundane version of jackson
[23:05:15] <Para> Wide range bundling is also a good way to prevent moving onwards. Earlier this year I was involved briefly in a customer case where customer's own home built logging...thing relied on an implementation of JMS only present in Oracle WebLogic, and it had hardcoded Windows paths.
[23:05:40] <Para> There was a general order to move to Linux based Kubernetes, and this system was their audit logging backbone. That was "fun".
[23:06:30] <rito_> selfsymmetric-mu: thanks, I will check it out.
[23:06:48] *** Quits: rito_ (~rito_gh@45.112.243.172) (Quit: Leaving)
[23:07:18] *** Quits: dadinn (~dadinn@82-132-214-226.dab.02.net) (Ping timeout: 256 seconds)
[23:11:11] *** Joins: AlaskanEmily (~AlaskanEm@user/alaskanemily)
[23:18:06] *** Joins: struchu (~struchu@staticline-31-183-167-203.toya.net.pl)
[23:18:24] *** Quits: struchu (~struchu@staticline-31-183-167-203.toya.net.pl) (Client Quit)
[23:18:44] *** Joins: struchu (~struchu@staticline-31-183-167-203.toya.net.pl)
[23:18:54] *** Quits: struchu (~struchu@staticline-31-183-167-203.toya.net.pl) (Client Quit)
[23:20:02] *** Joins: struchu (~struchu@staticline-31-183-167-203.toya.net.pl)
[23:20:55] *** Quits: struchu (~struchu@staticline-31-183-167-203.toya.net.pl) (Client Quit)
[23:30:49] <tatsumaru> hey guys, is it possible to refer to unnamed collections after they were defined? say you create some list like '(1 2 3 4) ?
[23:31:31] <tatsumaru> could you do some operations with that list without creating a new '(1 2 3 4) list
[23:32:40] <atw> what do you want to do with it?
[23:33:24] <ridcully> where have you put it and why is it lost there?
[23:36:17] *** Quits: mamapitufo (~mamapituf@109.123.118.63) (Ping timeout: 240 seconds)
[23:38:24] *** Joins: mamapitufo (~mamapituf@188.30.140.224.threembb.co.uk)
[23:42:47] <tatsumaru> atw: I don't know whatever, maybe cons it
[23:42:59] <tatsumaru> ridcully: I am not sure where it is, I am assuming some memory block
[23:44:29] <ridcully> maybe you could share your current code on some paste-site then.  it's not clear to me what you are after
[23:44:47] <jeaye> Also, we use vectors for most things, not lists.
[23:44:50] <ridcully> if you create something and don't hold on to it, the GC will free it eventually
[23:45:00] <jeaye> If you're creating '(1 2 3) in your code, you're likely not writing idiomatic Clojure.
[23:45:08] <tatsumaru> ridcully: so unnamed collections are not persistent?
[23:45:38] <technomancy> "persistent" has two distinct meanings; only one involves getting saved to durable storage
[23:45:43] <ajoberstar> If you're just in a repl, and eval '(1 2 3) you could reference it with *1
[23:45:57] *** Quits: atw (~user@2601:5c2:c500:76b0::1d0f) (Ping timeout: 240 seconds)
[23:46:04] <ridcully> tatsumaru: are we talking about something like `(do '(1 2 3) nil)` ?
[23:46:16] <technomancy> https://technomancy.us/132 <- re: different meanings of persistent
[23:47:00] <tatsumaru> ridcully: sure or just (list 1 2 3)
[23:47:34] <ridcully> then it's a no-op and it gets thrown away
[23:48:15] <tatsumaru> is this something that the GC does?
[23:48:34] <ajoberstar> Right, if there's no reference to an object, GC will toss it
[23:48:40] <ridcully> it is not an _super_ immutable like _maybe_ keywords/symbols are (with a global cache, that holds on to them)
[23:49:04] <jeaye> This should be an impl detail, though.
[23:49:12] <ridcully> don't know about the rules about strings (which are immutable on the jvm)
[23:49:17] <jeaye> What are you actually trying to do?
[23:49:25] <technomancy> keywords and strings can be interned but yeah not in a way that would affect language semantics, just performance
[23:49:32] <technomancy> big x-y problem energy here tbh
[23:49:56] <tatsumaru> technomancy: i was thinking of persistent as in "stays in ram until I close repl" not sure if that's a thing
[23:51:18] <jeaye> If that were the case, Clojure programs would run out of memory all the time, since every intermediate value is persistent and immutable.
[23:51:51] <jeaye> tatsumaru: If everyone forgets you, and nobody knows your name, do you still exist?
[23:52:11] <jeaye> That's what the GC asks of these values. If you want to keep a value around, hang onto it somewhere.
[23:52:39] *** Quits: shiranaihito (~textual@123-192-192-149.dynamic.kbronet.com.tw) (Quit: My MacBook Air has gone to sleep. ZZZzzz‚Ä¶)
[23:52:52] <tatsumaru> I was just wondering if unnamed values were bound to something like a memory block or whatever that could be referenced.
[23:53:12] <Para> tatsumaru: for optimization purposes Clojure does have transient collections, but as said, they're for optimization, wouldn't want to do that right off the bat.
[23:56:36] <Para> FWIW some years ago when I was talking about Clojure for people not familiar with it, one C# programmer did ask how Clojure doesn't run out of memory because it doesn't have explicit GC.
[23:57:50] <jeaye> Java has immutable strings and nobody blinks. Make everything else immutable and people go crazy.
[23:58:00] <ridcully> excuse my utter clr newbness, but isn't it a "jvm knockoff", which also has on-demand-gc?
[23:58:10] <Para> I suppose there's a gap in there, some sort of magical thinking related to how GC works in OO languages which differs enough from real world which prevents understanding how a LISP could have GC.
[23:58:32] <jeaye> ridcully: yup
[23:58:50] <Para> Yes, it is. In fact CLR 1.0 is a copy-paste of JVM, so much so that in silence Microsoft ended up paying a neat billion to Sun since even its docs were copy-pasted in parts where they described memory models and such.
[23:59:31] <Para> This bit of reality of course disappeared with Sun :)
[23:59:38] <Para> And CLR these days is an entirely different beast.
[23:59:55] <jeaye> These days, the CLR has some nice features compared to the JVM.
