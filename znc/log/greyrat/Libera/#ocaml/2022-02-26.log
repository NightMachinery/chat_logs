[00:00:40] *** Joins: quartz (~quartz@user/quartz)
[00:03:01] *** Quits: Techcable (~Techcable@168.235.93.147) (Ping timeout: 240 seconds)
[00:03:31] *** Joins: vijon (~vijon@8.47.15.5)
[00:06:40] *** Quits: vijon (~vijon@8.47.15.5) (Client Quit)
[00:36:41] *** Quits: tomku (~tomku@user/tomku) (Quit: Lost terminal)
[00:51:39] *** Quits: gravicappa (~gravicapp@145.255.0.191) (Ping timeout: 256 seconds)
[00:56:31] <quartz> Can someone explain line 9 of this code? https://godbolt.org/z/bjsqYzxdG   It's basically:   | hd :: tl -> hd + sum tl;; This is pattern matching based on if there are elements in the list?
[00:57:35] <quartz> so translated into English, the line "  | hd :: tl -> hd + sum tl;;" means: "if the list is not empty, than add the first element to the remainder of the list"
[00:58:14] *** Joins: tomku (~tomku@user/tomku)
[00:58:51] <d_bot_> <Butanium (@me on answer)> Yzs
[00:58:56] <Corbin> Sure. It sounds like you've got it.
[00:59:15] <d_bot_> <Butanium (@me on answer)> hd stands for `head`, the first element of the list
[00:59:23] <quartz> The expression "hd :: tl" is just so weird.
[00:59:25] <quartz> Yes
[00:59:28] <d_bot_> <Butanium (@me on answer)> And `tl` for `tail`
[00:59:35] <d_bot_> <Butanium (@me on answer)> The rest of the list
[01:00:12] <d_bot_> <Butanium (@me on answer)> What do you find it weird ?
[01:00:24] <d_bot_> <Butanium (@me on answer)> Another common notation is `x :: xs`
[01:00:37] *** Quits: tomku (~tomku@user/tomku) (Client Quit)
[01:02:06] <quartz> Well, it's weird because "hd :: tl" means "append the head of the list to the remainder of the list"
[01:02:35] <quartz> If pattern matching is like switch statements in C or Java, than how is "hd :: tl" a pattern.
[01:03:38] *** Joins: tomku (~tomku@user/tomku)
[01:03:39] <Corbin> It means "detach the head of the list from the remainder of the list".
[01:04:46] <quartz> Corbin: I thought :: meant "append"
[01:05:19] <Corbin> quartz: As an expression, yes. But as a pattern, every constructor becomes a deconstructor.
[01:07:13] *** Quits: kaph (~kaph@net-109-116-124-149.cust.vodafonedsl.it) (Ping timeout: 256 seconds)
[01:09:46] *** Quits: Serpent7776 (~Serpent77@90-156-31-193.internetia.net.pl) (Quit: leaving)
[01:10:23] <quartz> Corbin: I'm trying to write a function that gets the max value of a list. I'm not sure how to do this because I can't store variables in OCaml. My function header is: let rec maxVal (l : int list) : int = ...
[01:10:55] <quartz> Unless I pass in a variable like an int into the function like I did for my function that gets the sum of a list at line 15 here.
[01:10:57] <quartz> https://godbolt.org/z/hMojsav6x
[01:11:54] <quartz> So, I guess what I"m asking is: how can I write the function that gets the max value without some way to store a variable.
[01:16:40] <d_bot_> <glennsl> `::` means _prepend_, not _append_. I.e. it adds an element to the _front_ of the list, not to the _back_.
[01:19:00] *** Quits: olle (~olle@i5E866D9A.versanet.de) (Ping timeout: 240 seconds)
[01:19:39] <d_bot_> <glennsl> Also, it's useful to think of lists not as arrays, but as nested "cons" cells, which are essentially tuples . For example, `[1; 2; 3]` is essentially represented as `( 1, ( 2, ( 3, () ) ) )`.
[01:20:45] <d_bot_> <glennsl> From that it's easier to understand the syntax `1 :: 2 :: 3 :: []` which, if we make the associativity explicit, is parsed as `1 :: (2 :: (3 :: []))`.
[01:21:23] <d_bot_> <glennsl> And `hd :: tl` is essentially the same as `(hd, tl)`
[01:21:49] <quartz> Why is everyone ignoring me? haha
[01:21:58] <d_bot_> <Butanium (@me on answer)> ?
[01:22:51] <d_bot_> <Butanium (@me on answer)> Just use the same as sum
[01:23:07] <d_bot_> <Butanium (@me on answer)> But instead of `+` you'll need `max`
[01:23:16] <quartz> I just asked about my stupid function that is suppose to get the max value for a list. How can I do it, because you can't declare variables in OCaml
[01:23:49] <quartz> Butanium: Yes, but is it necessary to pass in a value alongside the list? Why can't I just write the functin so that it only accepts a list
[01:25:08] <Corbin> quartz: You will have to open your mind a little. The trick is understanding `rec`, and I imagine that that is the point of the homework.
[01:25:50] <quartz> Corbin: This isn't a homework question at all actually, I'm doing it to learn this language
[01:25:55] <Corbin> glennsl showed part of the trick. Because a list is really like a series of nested cells, we can talk in terms of recursion: either a list is the empty list, or it's a cell containing a value and a list.
[01:25:59] <quartz> But yeah I do have homework to do
[01:26:40] <Corbin> Sorry. I was going to say "the point of the assignment", but I felt that that would be an unhelpful pun.
[01:27:31] <quartz> I'm not asking anyone to do my homework for me :) It's not helpful to me anyway as I have an exam on this, so what good will it do if someone does my homework for me, as I"ll be clueless when it comes to taking the exam :)
[01:27:35] *** Joins: kaph (~kaph@net-109-116-124-149.cust.vodafonedsl.it)
[01:28:03] <quartz> Anyway... OK, use a rec... but can't it be done WITHOUT a rec?
[01:28:13] <quartz> As all these OCaml functions are so elegant.
[01:29:14] <Corbin> Maybe it could be done without `rec`. I don't know OCaml well enough to say for sure. But `rec` is a powerful hint: it means that your function should call itself, recursively, in at least one case.
[01:30:04] <quartz> OH! Recursion haha I thought you were talking about something else, sorry
[01:30:45] <quartz> Corbin: Yes of course I'll use recursion, but what I'm asking is, how can it be done without the ability to STORE a value? I need to compare "hd" with a stored value that contains the largest int seen so far.
[01:30:49] <octachron> Yes, it can do without rec using either: a fold (a higher-order function that describes a limited class of recursive functions), a while loop and a mutable reference, or a Z-combinator.
[01:32:01] <octachron> You can store values as function arguments. But for the first version of the function, you don't need to "store" anything.
[01:33:00] <octachron> If I have a element x, and the maximum m of a list of elements, can you compute the maximum of the two values, x and m?
[01:33:32] <Corbin> quartz: Not a stored value, a computed value. And the computation is recursive. Let's consider the case where a list is a value and another list. The maximum would be computed by comparing the value to the maximum of that other list.
[01:33:39] <d_bot_> <Alistair> Recursion can be done without `rec`
[01:33:45] <Corbin> What octachron said. I think I'm being confusing.
[01:34:14] <d_bot_> <Alistair> It's possible to implement a fixed point combinator using recursive datatypes
[01:34:47] <quartz> Corbin: But how do you get the max of the "other list"
[01:35:11] <Corbin> Have your function recursively call itself.
[01:36:14] <octachron> quartz, with recursion, you need to basically consider that you have already done the computation for the rest of the list and ask yourself how can I compute max (head :: rest) if I know max rest?
[01:36:37] <quartz> But I need some sort of evaluation... like maxSeen < hd
[01:37:07] <octachron> No, no, you are trying to do to much.
[01:37:20] <quartz> Wtf this is so confusing... lol
[01:37:27] <octachron> Recursion is all about being lazy and doing one step at each time.
[01:37:28] <d_bot_> <Butanium (@me on answer)> Ok quartz
[01:37:52] <octachron> Do you know how to compute `max []`?
[01:37:56] <quartz> So I don't need some type of evaulation statement?
[01:38:14] <octachron> Do you know how to compute max (x::rest), if you know max rest?
[01:38:36] <octachron> Then with recursion, you know how to compute max for all lists.
[01:38:54] <d_bot_> <Butanium (@me on answer)> Recursion is like "it'll work at last step (here you know the max if a list with one element) and I have to make it work at steps k"
[01:39:05] <d_bot_> <Butanium (@me on answer)> Step k is what otachron describe
[01:39:12] <d_bot_> <Butanium (@me on answer)> Assume you know what the max of rest is
[01:39:22] <quartz> Rest being tl?
[01:39:25] <d_bot_> <Butanium (@me on answer)> How you compute the max of x and rest
[01:39:26] <d_bot_> <Butanium (@me on answer)> Yes
[01:39:29] <d_bot_> <Butanium (@me on answer)> The rest of the list
[01:39:40] <quartz> Well, you can't? I need two ints to compare
[01:39:49] <quartz> I can't do int < list
[01:40:06] <d_bot_> <Alistair> You have two ints, the head `x` and the maximum of `rest`
[01:40:39] <quartz> But how do you compute the max of "rest"?
[01:40:49] <quartz> That's using the problem to describe the answer
[01:41:09] <d_bot_> <Alistair> Using recursion, we can just use `max rest` to compute the max of `rest`
[01:41:21] <octachron> That's recursion, you can use `max rest`, aka the function that you are defining.
[01:41:35] <quartz> But at what point do I compare the values?
[01:41:59] <octachron> (And that's work because `rest` is smaller than the original list)
[01:42:52] <quartz> Can someone write out an example of a working function that does this?
[01:42:55] <quartz> Just so I can see
[01:43:07] <octachron> Note that you can totally write  `| x :: rest -> let max_rest = max rest in `
[01:44:02] <Corbin> You've got all the pieces here already. We've got `x : int` and `rest : list int` and `max rest : int` and `x > max rest : bool`.
[01:44:24] <octachron> Maybe an example of the length function: `let rec len l = match l with | [] -> 0 | x :: rest -> 1 + len rest`
[01:48:22] <quartz> Corbin: So I DO need some type of comparion
[01:48:29] <quartz> Comparison
[01:48:39] <d_bot_> <Alistair> Yes
[01:48:56] <quartz> So the function signature will have 4 parameters?
[01:49:13] <d_bot_> <Butanium (@me on answer)> `max i j` give you the max of i and j
[01:51:29] <d_bot_> <Alistair> Should we move to #beginners so we can write some more code?
[01:51:57] <quartz> If you like.
[01:53:05] <quartz> Ahhh BRB, need to move locations.
[01:53:10] *** Quits: quartz (~quartz@user/quartz) (Quit: WeeChat 3.4)
[01:53:49] <sleepydog> recursion is such a wonderful concept :)
[02:02:11] *** Quits: zebrag (~chris@user/zebrag) (Ping timeout: 256 seconds)
[02:10:18] *** Joins: emad (~emad@102.45.236.212)
[02:11:57] *** Joins: quartz (~quartz@user/quartz)
[02:23:31] *** Joins: zebrag (~chris@user/zebrag)
[02:41:43] <quartz> Can someone tell me why there is an error in my code? https://godbolt.org/z/Gf5P5x3xx
[02:47:15] *** Quits: troydm (~troydm@host-176-37-124-197.b025.la.net.ua) (Ping timeout: 256 seconds)
[02:48:07] <d_bot_> <colin> The `max = List.hd` is very suspicious.
[02:48:36] <d_bot_> <colin> Generally, you'd you use structural recursion over the list to destructure it, rather than using h(ea)d and t(ai)l.
[02:48:59] *** Joins: rgrinberg (~textual@2806:101e:7:70b6:5c5e:da58:6afa:ce86)
[02:50:16] <d_bot_> <colin> However, if you want to do it this way, fix the logic and maintain the current "max" as a parameter. You must exhaust the list to make sure you've found the "max". So, if max < List.hd l, then then you do maxVal (List.hd l) (List.tl l) else you do the same except maintain the current max.
[02:51:02] <d_bot_> <colin> So, in other words, if the list is non-empty, you can do `maxVal (if max < List.hd l then List.hd l else max) (List.tl l)`, but this is a mess. You can factor out the common subexpressions.
[02:51:36] <d_bot_> <colin> I use "max" in scare quotes because seeding max with 0 may not work if all your numbers are negative, for example. You really need to seed it with an element from the list for it to truly be working out the maximum.
[02:51:49] *** Joins: Tuplanolla (~Tuplanoll@91-159-69-98.elisa-laajakaista.fi)
[02:51:50] <quartz> Ohhh right
[02:51:52] <d_bot_> <colin> The functional generalisation of looping with an accumulator would be to do this with List.fold_left.
[02:54:54] <quartz> It's best to just get rid of the accumulator thing
[02:54:59] <quartz> Rather, max
[02:55:01] *** Quits: rgrinberg (~textual@2806:101e:7:70b6:5c5e:da58:6afa:ce86) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[02:55:04] <quartz> God I'm dumb as dirt
[02:55:51] <d_bot_> <colin> Maintaining the current maximum as a good idea. Lots of code in functional programming is written in this way. It's not uncommon to define a function in terms of an initial application of an inner function (partially applied).
[02:56:13] <d_bot_> <colin> Such as the style of doing `let foo = let rec go x = function ... in go y`
[02:57:59] <d_bot_> <colin> Your code isn't very idiomatic because if `List.hd` and `List.tl` do not throw an exception, then the provided list must be non-empty (it must be a cons cell). So these extractions from cons can be more succinctly captured using pattern matching on the list.
[03:31:01] *** Joins: troydm (~troydm@host-176-37-124-197.b025.la.net.ua)
[03:38:09] *** Joins: rgrinberg (~textual@2806:101e:7:70b6:5c5e:da58:6afa:ce86)
[03:39:51] *** Quits: rgrinberg (~textual@2806:101e:7:70b6:5c5e:da58:6afa:ce86) (Client Quit)
[04:00:37] *** Quits: quartz (~quartz@user/quartz) (Ping timeout: 256 seconds)
[04:29:42] *** Quits: Tuplanolla (~Tuplanoll@91-159-69-98.elisa-laajakaista.fi) (Quit: Leaving.)
[04:33:15] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Ping timeout: 240 seconds)
[04:34:17] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[04:43:27] *** Joins: quartz (~quartz@user/quartz)
[04:44:08] *** Joins: Everything (~Everythin@37.115.210.35)
[04:44:40] *** Joins: rgrinberg (~textual@2806:101e:7:70b6:5c5e:da58:6afa:ce86)
[04:46:04] *** Quits: emad (~emad@102.45.236.212) (Quit: Leaving)
[05:01:18] *** Quits: quartz (~quartz@user/quartz) (Quit: WeeChat 3.4)
[05:34:20] <d_bot_> <mbacarella> ah. good points as well
[06:02:17] *** Quits: gwizon (~gwizon@ool-45798b07.dyn.optonline.net) (Quit: Lost terminal)
[06:20:32] <d_bot_> <darrenldl> @pilothole are you pushing ocaml in your org?
[06:22:10] <d_bot_> <darrenldl> i think most crucially would be tagged union + exhaustiveness check, other things exist in "mainstream" langs in some form (e.g. fp)
[06:22:28] *** Quits: kaph (~kaph@net-109-116-124-149.cust.vodafonedsl.it) (Read error: Connection reset by peer)
[06:22:39] *** Joins: kaph (~kaph@net-109-116-124-149.cust.vodafonedsl.it)
[06:23:03] <d_bot_> <darrenldl> "enum as int" remains a headache inducing source of vulns/bugs
[06:27:53] <d_bot_> <mbacarella> no, I've been thinking of ways to contribute to cybersecurity and most roads lead to helping orgs manage their massive investments in Windows better or advising them on what security products to buy and they all sounds really exhausting
[06:36:57] *** Quits: chrisz (kzl6qdiutz@55d41ae4.access.ecotel.net) (Ping timeout: 250 seconds)
[06:39:20] <d_bot_> <darrenldl> ah, well ocaml is very good for the type of analysis you want to do in cybersec land from experience
[06:39:40] <d_bot_> <mbacarella> what do you mean?
[06:40:30] <d_bot_> <mbacarella> that it's significantly easier to white box audit ocaml applications?
[06:41:57] <d_bot_> <darrenldl> that, and also tools that relate to structural analysis are often written in ocaml, say BAP
[06:42:25] <d_bot_> <darrenldl> (binary analysis platform is what its called in full iirc
[06:42:59] <d_bot_> <mbacarella> hmm interesting
[06:43:25] <d_bot_> <darrenldl> log analysis is easier in ocaml since you can do AST manipulation very easily compared to trying to mangle your way through in say python
[06:43:41] <d_bot_> <darrenldl> code gen is similarly easier
[06:44:15] <d_bot_> <darrenldl> say for generating security policy/config for apparmor or bubblewrap
[06:44:35] <d_bot_> <mbacarella> > Just type bap in your shell and it will print a message which shows BAP capabilities. The disassemble command will take a binary program, disassemble it, lift it into the intermediate architecture agnostic representation, build a control flow graph, and finally apply staged user-defined analysis in a form of disassembling passes.
[06:44:48] <d_bot_> <mbacarella> well where's this been all of my life
[06:46:42] <d_bot_> <darrenldl> radare2 is a much more popular alternative to bap i think, but its written in C, so not very good reference point
[06:47:46] <d_bot_> <darrenldl> if you throw enough manpower into things then sure you can get a very complex analysis engine at the cost of bizzare macros with fragile usage schemes etc
[06:49:46] <d_bot_> <darrenldl> offensive cybersec is largely dominated by python, since you often only want to write very short proof of concept code that just has to "kind of work" and no one cares about the code quality
[06:51:15] <d_bot_> <darrenldl> i am still trying to find time to rework a sandboxing code gen written in ocaml into a proper automated sandboxing utility
[06:51:50] <d_bot_> <nave01314> sum types are so nice
[06:52:10] <d_bot_> <nave01314> I am always missing them in languages that don’t support
[06:52:46] <d_bot_> <darrenldl> very much so indeed
[06:54:03] <d_bot_> <mbacarella> yeah so seems like the business case for OCaml in cybersec is
[06:54:03] <d_bot_> <mbacarella> * building secure new applications
[06:54:05] <d_bot_> <mbacarella> * have an edge on novel malware analysis
[06:54:06] <d_bot_> <mbacarella> * maybe an edge in forensics to figure out how you got owned
[06:54:27] *** Joins: nerdypepper (~nerdypepp@user/nerdypepper)
[06:57:19] <d_bot_> <darrenldl> malware analysis engine can be source of vuln due to them often being in low level lang and presumably very complex internals
[06:58:44] <d_bot_> <darrenldl> i think a paragraph on how difficult it is to replicate sum type in say C is worth noting if you are trying to convince someone
[07:00:11] <d_bot_> <mbacarella> I do wonder how many 0-days are in criminal / intelligence agency hands that specifically target and exploit malware detection tools
[07:01:23] <d_bot_> <darrenldl> basically you need C style enum + union but with
[07:01:24] <d_bot_> <darrenldl> - no namespacing/typing of enums in java/c/etc (i can use enum meant for another function in any function/situation without compilation error)
[07:01:25] <d_bot_> <darrenldl> - using union in C requires ridiculously careful manipulation, again with little to no help from compiler
[07:01:58] <d_bot_> <darrenldl> prolly too many, since said detection tools often run at hoghest priviledge
[07:02:03] <d_bot_> <darrenldl> highest*
[07:03:31] <d_bot_> <darrenldl> (or meaningfully highest - when all your most crucial data is in user home, succussfully safeguarding root/equivalent while leaving user level access vulnerable is not that useful
[07:04:41] <sleepydog> i'm not in this field -- wouldn't it be common practice to do this kind of work in a sandbox? or an air-gapped machine, even. is it just not done because of laziness?
[07:04:45] *** Joins: xd1le (~xd1le@user/xd1le)
[07:05:01] <d_bot_> <darrenldl> do you run your anti virus in a sandbox : p ?
[07:05:48] <sleepydog> ah, i misread, sorry. i thought you were talking about ad-hoc analysis
[07:05:58] <d_bot_> <darrenldl> but yes for a serious analysis setup, you are right
[07:07:31] <d_bot_> <darrenldl> meaningfully not that different in terms of analysis the two groups of software do, if not worse in antivirus
[07:07:37] <sleepydog> another juicy target would be the more invasive anti-cheat mechanisms for online video games
[07:07:55] <d_bot_> <darrenldl> oh yeah 100%
[07:08:15] <d_bot_> <darrenldl> widespread remote code execution sometimes too
[07:09:48] <d_bot_> <darrenldl> but ye, this is slightly too common in practice, where the vendor of your security product that you supposedly want to trust is not doing a very good job (e.g. NAS as backup solution, firewall/router firmware)
[07:22:58] *** Quits: kaph (~kaph@net-109-116-124-149.cust.vodafonedsl.it) (Read error: Connection reset by peer)
[07:23:14] *** Joins: kaph (~kaph@net-109-116-124-149.cust.vodafonedsl.it)
[07:32:02] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Remote host closed the connection)
[07:32:19] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[07:33:07] *** Quits: Haudegen (~quassel@178.115.237.87.static.drei.at) (Ping timeout: 256 seconds)
[07:50:52] *** Joins: Techcable (~Techcable@168.235.93.147)
[08:06:27] *** Joins: spip (~bobo@37.173.243.243)
[08:07:15] *** Quits: bobo (~bobo@37.165.132.78) (Read error: Connection reset by peer)
[08:51:42] *** Joins: mbuf (~Shakthi@117.96.199.11)
[09:00:21] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 245 seconds)
[09:13:27] *** Quits: rgrinberg (~textual@2806:101e:7:70b6:5c5e:da58:6afa:ce86) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[09:49:32] *** Quits: zebrag (~chris@user/zebrag) (Quit: Konversation terminated!)
[10:07:20] *** Quits: tomku (~tomku@user/tomku) (Quit: Lost terminal)
[10:23:24] *** Joins: tomku (~tomku@user/tomku)
[10:40:48] *** Joins: gravicappa (~gravicapp@145.255.0.191)
[11:01:48] *** Quits: hackinghorn (~hackingho@user/hackinghorn) (Ping timeout: 240 seconds)
[11:27:00] *** Joins: dalek_caan (~Thunderbi@109-252-124-86.nat.spd-mgts.ru)
[12:12:46] *** Joins: mro (~mro@port-92-195-205-59.dynamic.as20676.net)
[12:14:03] *** Quits: mro (~mro@port-92-195-205-59.dynamic.as20676.net) (Remote host closed the connection)
[12:47:09] *** rwmjones|HOLS is now known as rwmjones
[12:53:51] *** Joins: mro (~mro@port-92-195-205-59.dynamic.as20676.net)
[13:44:14] *** Quits: mro (~mro@port-92-195-205-59.dynamic.as20676.net) (Remote host closed the connection)
[13:46:07] *** Joins: mro (~mro@port-92-195-205-59.dynamic.as20676.net)
[13:52:09] *** Joins: hackinghorn (~hackingho@user/hackinghorn)
[14:27:51] *** Joins: adanwan_ (~adanwan@gateway/tor-sasl/adanwan)
[14:30:55] *** Quits: mro (~mro@port-92-195-205-59.dynamic.as20676.net) (Quit: Leaving...)
[14:31:35] *** Quits: adanwan (~adanwan@gateway/tor-sasl/adanwan) (Ping timeout: 240 seconds)
[14:53:55] *** Joins: bartholin (~bartholin@109.53.3.104)
[14:55:00] *** Quits: troydm (~troydm@host-176-37-124-197.b025.la.net.ua) (Ping timeout: 240 seconds)
[14:55:15] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Ping timeout: 240 seconds)
[14:55:34] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[15:17:24] *** Quits: bartholin (~bartholin@109.53.3.104) (Ping timeout: 240 seconds)
[15:30:51] *** Joins: bartholin (~bartholin@109.53.0.239)
[15:39:13] *** Joins: troydm (~troydm@host-176-37-124-197.b025.la.net.ua)
[15:59:09] *** Quits: kaph (~kaph@net-109-116-124-149.cust.vodafonedsl.it) (Ping timeout: 256 seconds)
[16:06:13] *** Quits: Everything (~Everythin@37.115.210.35) (Quit: leaving)
[16:23:48] *** Quits: bartholin (~bartholin@109.53.0.239) (Ping timeout: 240 seconds)
[16:32:12] *** Joins: Haudegen (~quassel@178.115.237.87.static.drei.at)
[16:54:57] *** Quits: mbuf (~Shakthi@117.96.199.11) (Read error: Connection reset by peer)
[16:55:40] *** Joins: mbuf (~Shakthi@117.96.199.11)
[17:30:56] *** Joins: kaph (~kaph@net-109-116-124-149.cust.vodafonedsl.it)
[18:19:17] *** Quits: kaph (~kaph@net-109-116-124-149.cust.vodafonedsl.it) (Read error: Connection reset by peer)
[18:23:55] *** Joins: olle (~olle@i5e866d87.versanet.de)
[18:29:05] *** Joins: kaph (~kaph@net-109-116-124-149.cust.vodafonedsl.it)
[18:32:01] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[18:51:28] <d_bot_> <mbacarella> lets see how would a very well architected anti-virus system work. you'd separate out privileges right? the hooks into the OS are as thin as possible and simply collect data or enforce policy, and they submit their data to a malware rules engine that runs with no privileges other than access to its local database, and it simply produces a PASS | FAIL response
[18:51:44] <d_bot_> <mbacarella> i'm sure in practice they all run as admin
[18:55:52] <d_bot_> <darrenldl> sure, but you'd run into resource drain (see chrome - they have the perfect type of setup as you've described)
[18:56:16] <d_bot_> <darrenldl> renderer in separate process, communication via ipc, etc
[18:57:56] <d_bot_> <darrenldl> if they wrote it in rust, then they'd get best of both worlds (obviously), but that takes effort, and a lot of effort for translating presumably decade long code base
[18:59:24] <d_bot_> <darrenldl> one issue with ipc though is you often dont have further authentication/protection, so may be a concern for malware interception maybe
[19:01:03] *** Quits: olle (~olle@i5e866d87.versanet.de) (Ping timeout: 256 seconds)
[19:05:34] <d_bot_> <darrenldl> basically we want microkernel with good boundary
[19:05:49] <d_bot_> <darrenldl> in practice
[19:11:19] <Corbin> mbacarella: You might find the "virus-proof" line of thinking to be more fruitful, if you're willing to rearchitect the OS. In capability-security research, the idea of a virus-proof OS was that *all* code has explicit authority granted to it when it runs, and so any "virus" must be running at the user's behest. TBF this approach predated the invention of clickjacking, and folks have needed to patch Web browsers, X11, etc. to make it work.
[19:16:26] <Corbin> I went looking for demos of "CapDesk", a capability desktop shell that wraps common office tools. The best I can find is this old talk from a researcher about HP's "Virus Safe" initiative: https://www.youtube.com/watch?v=pMhH6IKBrVo
[19:19:48] <companion_cube> Isn't qubes the closest usable implementation?
[19:20:05] <companion_cube> Not capabilites, but at least decent isolation by level of privilege
[19:23:00] <Corbin> Depends on the metrics for "closest" and "usable". One choice of metrics leads to Windows 8! I hear that Genode is relatively usable on top of seL4 today, and that would be quite close. Google's working on Fuchsia too.
[19:23:57] <Corbin> Qubes is very cool when it comes to isolation, but it's actually not capability-oriented. Their approach uses more classical security analyses. Something like CloudABI, Capsicum, or even seccomp and eBPF would be closer in design.
[19:25:17] <Corbin> Oh! This is a good video. I haven't reached the end yet, but at the end there is a demo for "Polaris", a tamed Windows environment. There's nothing exactly like this available today AFAIK.
[19:29:01] <d_bot_> <Butanium (@me on answer)> using this max function `let max (x : int) (y : int) = if x < y then y else x` instead of classic `max` double the speed of my code. Do you think it's something which could be handled by Flambda for example ?
[19:29:21] <d_bot_> <Butanium (@me on answer)> Like detecting non polymorphic use of polymorphic functions
[19:33:33] *** Quits: xd1le (~xd1le@user/xd1le) (Quit: xd1le)
[19:33:46] <d_bot_> <VPhantom> Not sure about Flambda but FIY there's `Int.max` in the `Stdlib`.
[19:36:11] <d_bot_> <Butanium (@me on answer)> Yes since 4.13
[19:36:15] <d_bot_> <Butanium (@me on answer)> I'm in 4.12
[19:38:47] *** Quits: kakadu (~kakadu@195.19.236.234) (Remote host closed the connection)
[19:39:47] <companion_cube> Corbin: closest if you're on a desktop and you want to play super paranoid. I guess a hardened Linux might also work, I honestly don't have that much interest in security
[19:40:45] <Corbin> companion_cube: Did you make it to the submarine story yet? Qubes has the same architecture as what got deployed to the submarines; I'm talking about the line of research discussed in the talk as an alternative.
[19:41:01] <Corbin> Sure. I don't really like security either.
[19:41:06] <companion_cube> I'm not watching the video
[19:42:53] <d_bot_> <dinosaure> yeah, from what I know, `flambda` is about to specialize such things
[19:43:49] <d_bot_> <Butanium (@me on answer)> you mean that in the future it'll be able to do this or that it should do it ?
[19:44:28] <d_bot_> <dinosaure> it can do it now but you need to switch to `ocaml+flambda` 🙂
[19:44:41] <d_bot_> <Butanium (@me on answer)> I already did
[19:45:09] <d_bot_> <dinosaure> ah and it did not optimize it? you probably should notify vlaviron about that :/
[19:45:19] <d_bot_> <Butanium (@me on answer)> https://cdn.discordapp.com/attachments/436568060288172044/947164941595602995/unknown.png
[19:45:43] <Corbin> companion_cube: Okay. Well, be aware that these folks are slowly dying and their websites are vanishing, so we don't get a whole lot of flexibility in which archeological artifacts we get to study.
[19:46:45] <d_bot_> <Butanium (@me on answer)> where can I do it ?
[19:47:19] <d_bot_> <dinosaure> probably on the post you did in discuss 🙂
[19:48:31] <companion_cube> For pure websites there's the internet archive at least
[19:48:58] <d_bot_> <Butanium (@me on answer)> ok will do
[19:52:21] *** Quits: tomku (~tomku@user/tomku) (Ping timeout: 256 seconds)
[19:52:35] <d_bot_> <darrenldl> Corbin: i think the usual conclusiob was you need too much effort to writing the right security policy for desktop applications
[19:53:37] *** Joins: tomku (~tomku@user/tomku)
[19:54:21] <Corbin> darrenldl: Sure, each individual application needs to either be completely rewritten, or tamed with custom policy and API.
[19:55:27] <d_bot_> <darrenldl> life would be easier if everything security was message passing
[20:06:47] *** Quits: spip (~bobo@37.173.243.243) (Ping timeout: 256 seconds)
[20:06:50] *** Joins: bobo (~bobo@37.172.68.59)
[20:10:01] *** Quits: mbuf (~Shakthi@117.96.199.11) (Quit: Leaving)
[20:10:11] *** Quits: Techcable (~Techcable@168.235.93.147) (Ping timeout: 256 seconds)
[20:16:08] *** Joins: bartholin (~bartholin@109.53.4.163)
[20:40:14] *** Joins: wingsorc__ (~wingsorc@user/wingsorc)
[20:46:46] <d_bot_> <romachkuna> where can i practice ocaml ?(codewars doesnt have ocaml problems)
[20:47:11] *** Joins: olle (~olle@i5E866D87.versanet.de)
[20:48:46] <d_bot_> <Butanium (@me on answer)> exercism.io
[20:49:09] <d_bot_> <Butanium (@me on answer)> https://www.ocaml.org/learn/tutorials/99problems.html
[20:49:45] <d_bot_> <Butanium (@me on answer)> https://ocaml-sf.org/learn-ocaml-public/#
[21:06:25] <companion_cube> @Bluddy seems like cancellation shouldn't be an async feature at all
[21:06:39] <companion_cube> lwt's cancellation seems to be avoided by the people I asked
[21:07:08] <companion_cube> in Async I don't know, but they have sort of supervision trees so that's a bit clearer I imagine
[21:07:23] <companion_cube> and with threads, there's no builtin cancellation at all
[21:07:37] <d_bot_> <orbitz> I use cancellation in my concurrency monad pretty ubiquitously
[21:10:25] <companion_cube> in dune apparently they don't
[21:10:32] <companion_cube> guess there's no consensus :D
[21:10:36] <companion_cube> @orbitz how does it work?
[21:11:18] <d_bot_> <orbitz> In what sense would you like me to answer that question?
[21:11:48] *** Quits: olle (~olle@i5E866D87.versanet.de) (Ping timeout: 240 seconds)
[21:12:40] <d_bot_> <orbitz> Dune doesn't strike me as the kind of app that needs to can much.
[21:15:13] <companion_cube> well, what's the semantics of cancel
[21:15:22] <companion_cube> how does it propagate through bind, etc.
[21:17:10] <d_bot_> <orbitz> You cancel a future and it spreads from there. Each future also has a function that gets run on cancel
[21:17:25] *** Quits: bartholin (~bartholin@109.53.4.163) (Ping timeout: 240 seconds)
[21:19:58] <d_bot_> <orbitz> @companion_cube  https://hg.sr.ht/~mmatalka/abb-dump/browse/src/abb_fut/abb_fut.ml?rev=tip#L626
[21:20:23] <d_bot_> <Anurag> > companion_cube: in Async I don't know, but they have sort of supervision trees so that's a bit clearer I imagine
[21:20:23] <d_bot_> <Anurag> Async's monitors are indeed really nice. I find it a lot easier to think about proper error handling/cancelling etc in a reliable manner when using async + monitors vs the primitives availabled in Lwt. I don't claim to understand all the nuances that go into designing a concurrency library as I've never undertaken such a task, but as a user Async's model (monitors for exception/error handling) has consistently been a lot easier f
[21:21:02] <d_bot_> <Bluddy> What's the JS Promise approach?
[21:21:20] <d_bot_> <Bluddy> Would be useful to know what works for them
[21:21:49] <companion_cube> @orbitz looks like lwt's semantics, mostly
[21:21:59] <companion_cube> (lwt also has combinators to "stop" cancellation)
[21:23:00] <companion_cube> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise <-- does it have cancellation? not sure, tbh
[21:23:29] <d_bot_> <mbacarella> Isn't the other problem with capabilities that you now need to trust whoever edits the capability descriptor set for each application? And just because you limited the set of things the legitimate application can do doesn't mean you can't introduce an attack through it?
[21:24:17] <d_bot_> <Bluddy> I guess I keep confusing failure with cancellation @companion_cube
[21:25:15] <d_bot_> <orbitz> @Bluddy I don't believe JS promises have a cancelled concept
[21:25:30] <d_bot_> <mbacarella> Obviously it's better for applications to give up privileges it doesn't need, and even better for the OS to limit the privileges to strictly what it thinks it needs. More confused about why the model didn't have problems before clickjacking
[21:26:20] *** Joins: rgrinberg (~textual@2806:101e:7:70b6:5c5e:da58:6afa:ce86)
[21:26:56] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Remote host closed the connection)
[21:27:50] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[21:30:49] *** Joins: bartholin (~bartholin@109.53.0.62)
[21:32:47] <d_bot_> <Bluddy> I can see the value in cancellation for certain applications. I don't see how you can have any notion of expected state unless you strongly limit side effects.
[21:41:02] *** Quits: bartholin (~bartholin@109.53.0.62) (Ping timeout: 240 seconds)
[21:46:16] <Corbin> mbacarella: Yes, when everything is local to one machine. When a capability is handed out from some remote service, though, then the remote service retains control over revocation or other matters of trust.
[21:46:40] <Corbin> The classic paper "Capability Myths Demolished" https://srl.cs.jhu.edu/pubs/SRL2003-02.pdf addresses this somewhat, although it doesn't have a perfect quote I can give you.
[21:55:51] *** Joins: bartholin (~bartholin@109.53.0.62)
[21:57:05] *** Quits: unyu (~pyon@user/pyon) (Quit: Reboot.)
[21:59:06] <companion_cube> afaik rust futures also don't have any notion of cancellation
[22:02:04] *** Joins: zebrag (~chris@user/zebrag)
[22:04:41] <d_bot_> <Butanium (@me on answer)> https://cdn.discordapp.com/attachments/436568060288172044/947200011094073384/unknown.png
[22:04:52] <d_bot_> <Butanium (@me on answer)> dinausore for now lambda doesn't support it
[22:06:13] *** Joins: unyu (~pyon@user/pyon)
[22:18:49] *** Quits: gravicappa (~gravicapp@145.255.0.191) (Ping timeout: 256 seconds)
[22:23:02] *** Quits: bobo (~bobo@37.172.68.59) (Ping timeout: 240 seconds)
[22:23:13] *** Joins: bobo (~bobo@37.172.68.59)
[22:45:53] <d_bot_> <danchro> Hi, so I copied this off the 99 problems site and for some reason it throws an error when I paste it into the online IDE website
[22:45:56] <d_bot_> <danchro> let flatten list =
[22:45:56] <d_bot_> <danchro>     let rec aux acc = function
[22:45:58] <d_bot_> <danchro>       | [] -> acc
[22:45:59] <d_bot_> <danchro>       | One x :: t -> aux (x :: acc) t
[22:46:00] <d_bot_> <danchro>       | Many l :: t -> aux (aux acc l) t in
[22:46:01] <d_bot_> <danchro>     List.rev (aux [] list);;
[22:49:14] <d_bot_> <idk> I think you did not copy this part
[22:49:14] <d_bot_> <idk> https://cdn.discordapp.com/attachments/436568060288172044/947211222145716234/IMG_0665.png
[22:49:58] <d_bot_> <danchro> oops 😅  thank you !
[22:53:09] *** Quits: bartholin (~bartholin@109.53.0.62) (Ping timeout: 256 seconds)
[22:56:15] *** Joins: hornhack (~hackingho@user/hackinghorn)
[22:58:29] *** Quits: hackinghorn (~hackingho@user/hackinghorn) (Ping timeout: 256 seconds)
[23:07:14] *** Joins: olle (~olle@i5E866D87.versanet.de)
[23:23:20] *** Joins: bartholin (~bartholin@158.110.70.204)
[23:39:01] *** Quits: rgrinberg (~textual@2806:101e:7:70b6:5c5e:da58:6afa:ce86) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[23:53:44] *** Quits: dalek_caan (~Thunderbi@109-252-124-86.nat.spd-mgts.ru) (Quit: dalek_caan)
[23:56:56] *** Joins: rgrinberg (~textual@2806:101e:7:79ba:dc50:f4f5:8b68:5890)
