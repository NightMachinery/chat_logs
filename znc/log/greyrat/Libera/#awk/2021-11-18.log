[00:23:04] *** Joins: Penguin666 (~Penguin66@217.138.205.135)
[00:26:27] *** Quits: Penguin666x (~Penguin66@217.138.205.135) (Ping timeout: 265 seconds)
[00:48:23] *** Quits: Torr (~Torr@user/torr) (Ping timeout: 264 seconds)
[00:51:17] *** Joins: Torr (~Torr@user/torr)
[00:51:41] *** Quits: Torr (~Torr@user/torr) (Read error: Connection reset by peer)
[01:01:12] *** Quits: YaoNai (~YaoNai@user/yaonai) (Quit: leaving)
[01:01:43] *** Quits: lavaball (felix@31.204.155.215) (Remote host closed the connection)
[01:06:23] *** Quits: user51 (~user51@176.228.151.30) (Remote host closed the connection)
[01:12:33] *** Joins: Torr (~Torr@user/torr)
[01:17:51] <nmz1> out of curiousity, how do languages do == ?
[01:18:20] <nmz1> like "string1" == "string2"
[01:18:29] <nmz1> do they loop and match the entirety of it?
[01:18:46] <nmz1> or do they keep a hash of all strings and then just match that?
[01:19:19] <emanuele6> to hash it, you need to loop the string anyway
[01:19:36] <nmz1> well yeah
[01:20:01] <nmz1> so whenever you create a string, is it hashed?
[01:20:28] <emanuele6> generally for c-strings (NUL terminated strings), they iterate both strings at the same time till both reach the NUL character
[01:20:43] <nmz1> because I realize a str==str is quite fast
[01:21:00] <nmz1> ah
[01:21:14] <emanuele6> if at any time in the iteration the characters are different, the result is false and they stop iterating
[01:21:15] <nmz1> so, size!=size first and then that
[01:21:31] <nmz1> or no shortstrings?
[01:21:41] <nmz1> has to be a cstring
[01:21:43] <emanuele6> but that is usually implemented by the standard C library as strncmp
[01:22:19] <emanuele6> nmz1: it only makes sense to do size!=size if the strings are stored as struct string { char *chars; size_t size }
[01:22:29] <emanuele6> with Cstrings it doesn't really make sense
[01:22:50] <emanuele6> i guess it would make sense to check size1!=size2 also for pascal strings
[01:23:11] <nmz1> struct string { char *chars; size_t size } is this a shortstring/pascal string?
[01:23:34] <emanuele6> pascal strings are something like "\005hello" vs "hello\0"
[01:23:45] *** Joins: OMGOMG (~bobrobert@poppy.ifi.uio.no)
[01:24:09] <emanuele6> the first character represents an 8bit number that defines the length of the string
[01:24:33] <emanuele6> and that number of characters after the first are part of the string
[01:24:59] <emanuele6> i don't know if struct string { char *chars; size_t size } has a name
[01:25:11] <emanuele6> the idea is similar to a pascal string
[01:25:17] <emanuele6> but not limited to 255 characters
[01:25:28] <emanuele6> that is how c++ and java implement strings iirc
[01:26:37] <emanuele6> but i think that java also saves the hash when you define a string (since java strings are immutable)
[01:27:13] <emanuele6> and uses the hash, the length and character-by-character to compare strings
[01:27:44] <nmz1> that's what I was thinking was happening
[01:28:03] <nmz1> since looping seems innefficient
[01:28:15] <emanuele6> it's the only way for c strings
[01:29:18] <emanuele6> if you wanted to use an hash, your strings would have to be immutable
[01:30:04] <emanuele6> otherwise c[3] = 'x'; would be very expensive
[01:30:32] <emanuele6> since it would have to recompute to loop the entire string to recompute the hash
[01:30:50] <emanuele6> awk could use that string implementation since strings are immutable
[01:30:56] <nmz1> well, you can just pick which string to use no?
[01:31:09] <nmz1> data type*
[01:31:14] <emanuele6> but generally awk implementations use Cstrings
[01:31:38] <nmz1> weird considering awk doesn't have arrays
[01:31:52] <emanuele6> it does?
[01:32:08] <nmz1> you can't do c[3] = "x"
[01:32:09] <emanuele6> associative arrays which can be used as arrays.
[01:32:22] <emanuele6> nmz1: oh, you mean that strings are immutable, yes
[01:32:40] <emanuele6> so awk could use that implementation as i said
[01:32:45] <emanuele6> but generally Cstrings are used
[01:35:48] <emanuele6> either way, i don't think that implementation would speed things up much
[01:36:03] <emanuele6> unless you compare a constant many times, i guess
[01:36:15] <emanuele6> and the strings are very long
[01:38:03] <emanuele6> unless you reuse the values, computing an hash for everything just adds overhead
[01:38:57] <emanuele6> well, you could lazily compute it i guess
[02:25:12] *** Quits: Torr (~Torr@user/torr) (Read error: Connection reset by peer)
[03:03:03] *** Joins: Torr (~Torr@user/torr)
[03:19:00] *** Quits: jetchisel (jetchisel@user/jetchisel) (Ping timeout: 265 seconds)
[03:19:00] *** Joins: lesihctej (jetchisel@user/jetchisel)
[03:44:59] *** Quits: seninha (~seninha@user/seninha) (Remote host closed the connection)
[03:58:54] *** Quits: defjam (~eb0t@90.209.246.132) (Ping timeout: 260 seconds)
[04:00:35] *** Joins: defjam (~eb0t@90.197.82.19)
[04:08:51] *** Quits: defjam (~eb0t@90.197.82.19) (Ping timeout: 250 seconds)
[04:10:53] *** Joins: defjam (~eb0t@90.203.122.187)
[04:21:46] *** Joins: loganlee (~Thunderbi@user/loganlee)
[04:21:57] *** Quits: loganlee (~Thunderbi@user/loganlee) (Client Quit)
[04:54:13] *** Quits: defjam (~eb0t@90.203.122.187) (Ping timeout: 265 seconds)
[04:56:11] *** Joins: defjam (~eb0t@90.194.39.133)
[05:26:47] *** Quits: lesihctej (jetchisel@user/jetchisel) (Ping timeout: 264 seconds)
[05:33:51] *** Quits: defjam (~eb0t@90.194.39.133) (Ping timeout: 265 seconds)
[05:35:29] *** Joins: defjam (~eb0t@90.197.82.195)
[06:06:43] *** Quits: Meli (~meli@user/meli) (Ping timeout: 250 seconds)
[06:15:39] *** Joins: Meli (~meli@user/meli)
[06:18:13] *** Quits: BSaboia (~bsaboia@177.37.198.227) (Quit: This computer has gone to sleep)
[06:25:59] *** Joins: BSaboia (~bsaboia@177.37.198.227)
[06:26:06] *** Joins: lgc (~lgc@user/lgc)
[06:28:43] *** Quits: BSaboia (~bsaboia@177.37.198.227) (Client Quit)
[07:45:30] *** Joins: BSaboia (~bsaboia@177.37.198.227)
[07:49:51] *** Quits: BSaboia (~bsaboia@177.37.198.227) (Client Quit)
[08:21:38] *** Quits: earnestly (~earnest@user/earnestly) (Ping timeout: 260 seconds)
[08:57:40] *** Joins: loganlee (~Thunderbi@user/loganlee)
[09:12:53] *** Quits: AJ_Z0 (~AJ_Z0@user/aj-z0/x-3780512) (Ping timeout: 246 seconds)
[09:22:17] *** Quits: larryv (~larryv@zsh/patchmanager/larryv) (Quit: larryv)
[09:23:44] *** Joins: AJ_Z0 (~AJ_Z0@user/aj-z0/x-3780512)
[09:37:33] *** Joins: kensanata (~user@user/kensanata)
[09:53:30] *** Joins: aramtsamtsam (~Thunderbi@2001:861:388a:5600:1710:c3dc:c776:df35)
[09:57:41] *** Quits: aramtsamtsam (~Thunderbi@2001:861:388a:5600:1710:c3dc:c776:df35) (Ping timeout: 250 seconds)
[09:58:58] *** Joins: user51 (~user51@176.228.151.30)
[10:16:07] *** Quits: defjam (~eb0t@90.197.82.195) (Ping timeout: 265 seconds)
[10:17:48] *** Joins: defjam (~eb0t@90.210.88.222)
[10:44:43] *** Joins: aramtsamtsam (~Thunderbi@94.239.102.102)
[10:50:57] *** Quits: roarde (~roarde@user/roarde) (Quit: Leaving)
[10:54:54] *** Joins: jetchisel (jetchisel@user/jetchisel)
[10:55:20] *** Quits: aramtsamtsam (~Thunderbi@94.239.102.102) (Quit: aramtsamtsam)
[11:35:26] *** Quits: defjam (~eb0t@90.210.88.222) (Ping timeout: 256 seconds)
[11:37:06] *** Joins: defjam (~eb0t@90.210.94.131)
[11:40:23] *** Quits: chasmo77 (~chas77@71.63.241.168) (Ping timeout: 250 seconds)
[11:43:12] *** Joins: chasmo77 (~chas77@71.63.241.168)
[11:47:19] *** Quits: defjam (~eb0t@90.210.94.131) (Ping timeout: 250 seconds)
[11:49:24] *** Joins: defjam (~eb0t@90.197.82.230)
[12:10:53] *** Quits: llua (~llua@zsh/developer/llua) (Ping timeout: 264 seconds)
[12:11:09] *** Quits: kensanata (~user@user/kensanata) (Ping timeout: 265 seconds)
[12:38:57] *** Joins: llua (~llua@zsh/developer/llua)
[12:48:37] *** Joins: lavaball (felix@31.204.155.215)
[13:10:07] *** Quits: wuseman (~wuseman@user/wuseman) (Quit: ZNC 1.8.2+deb2build1 - https://znc.in)
[13:19:42] *** Quits: defjam (~eb0t@90.197.82.230) (Ping timeout: 256 seconds)
[13:20:43] *** Joins: defjam (~eb0t@90.202.44.78)
[13:21:49] *** Joins: wuseman (~wuseman@81-234-120-217-no68.tbcn.telia.com)
[13:21:49] *** Quits: wuseman (~wuseman@81-234-120-217-no68.tbcn.telia.com) (Changing host)
[13:21:50] *** Joins: wuseman (~wuseman@user/wuseman)
[13:31:23] *** Quits: jetchisel (jetchisel@user/jetchisel) (Ping timeout: 265 seconds)
[13:36:04] *** Joins: jetchisel (~jetchisel@user/jetchisel)
[13:50:03] *** Joins: BSaboia (~bsaboia@177.37.198.227)
[14:02:57] *** Quits: elastic_dog (~elastic_d@2a01:118f:822:9c00:f583:aa51:9ad4:d4fb) (Ping timeout: 250 seconds)
[14:08:16] *** Joins: elastic_dog (~elastic_d@2a01:118f:822:9c00:f583:aa51:9ad4:d4fb)
[14:19:12] *** Quits: defjam (~eb0t@90.202.44.78) (Ping timeout: 256 seconds)
[14:20:06] *** Joins: defjam (~eb0t@90.204.62.61)
[14:23:34] *** Quits: jetchisel (~jetchisel@user/jetchisel) (Ping timeout: 268 seconds)
[14:25:25] *** Joins: jetchisel (jetchisel@user/jetchisel)
[14:28:14] *** Quits: loganlee (~Thunderbi@user/loganlee) (Quit: loganlee)
[14:55:29] *** Quits: defjam (~eb0t@90.204.62.61) (Ping timeout: 265 seconds)
[14:57:24] *** Joins: defjam (~eb0t@90.202.47.175)
[15:14:49] *** Quits: defjam (~eb0t@90.202.47.175) (Ping timeout: 265 seconds)
[15:16:42] *** Joins: defjam (~eb0t@90.210.93.250)
[15:40:55] *** Joins: earnestly (~earnest@user/earnestly)
[16:17:24] *** Joins: X-Scale` (~ARM@165.201.137.78.rev.vodafone.pt)
[16:17:38] *** Quits: X-Scale (~ARM@83.223.235.65) (Ping timeout: 256 seconds)
[16:19:15] *** X-Scale` is now known as X-Scale
[16:35:20] *** Joins: seninha (~seninha@user/seninha)
[16:42:08] *** Joins: aramtsamtsam (~Thunderbi@2001:861:388a:5600:1710:c3dc:c776:df35)
[16:45:01] *** Quits: BSaboia (~bsaboia@177.37.198.227) (Quit: This computer has gone to sleep)
[16:46:58] *** Joins: BSaboia (~bsaboia@177.37.198.227)
[17:09:22] *** Quits: BSaboia (~bsaboia@177.37.198.227) (Quit: This computer has gone to sleep)
[17:09:52] *** Joins: BSaboia (~bsaboia@177.37.198.227)
[18:20:49] *** Joins: larryv (~larryv@zsh/patchmanager/larryv)
[18:36:49] *** Joins: jess (~jess@libera/staff/jess)
[18:43:16] *** Quits: defjam (~eb0t@90.210.93.250) (Ping timeout: 256 seconds)
[18:45:08] *** Joins: defjam (~eb0t@90.210.95.134)
[18:49:23] *** Quits: defjam (~eb0t@90.210.95.134) (Read error: Connection reset by peer)
[18:55:26] *** Joins: defjam (~eb0t@90.213.43.181)
[19:09:42] *** Quits: aramtsamtsam (~Thunderbi@2001:861:388a:5600:1710:c3dc:c776:df35) (Ping timeout: 268 seconds)
[19:22:51] *** Joins: aramtsamtsam (~Thunderbi@94.239.102.102)
[19:27:48] *** Joins: kensanata (~user@user/kensanata)
[19:41:09] *** Quits: defjam (~eb0t@90.213.43.181) (Ping timeout: 268 seconds)
[19:42:45] *** Joins: defjam (~eb0t@90.210.91.65)
[19:54:06] *** Quits: enick_495 (~dngraymat@2001:470:69fc:105::793b) (K-Lined)
[19:54:06] *** Quits: ForeverNoob[m] (~foreverno@2001:470:69fc:105::8c6) (K-Lined)
[19:54:09] *** Quits: psydroid (~psydroid@user/psydroid) (K-Lined)
[19:54:15] *** Quits: ttmrichter-M (~ttmrichte@user/ttmrichter) (K-Lined)
[19:54:17] *** Quits: jmcantrell (~jmcantrel@user/jmcantrell) (K-Lined)
[19:54:18] *** Quits: siraben (~siraben@user/siraben) (K-Lined)
[19:55:43] *** Quits: BSaboia (~bsaboia@177.37.198.227) (Quit: This computer has gone to sleep)
[19:59:16] *** Quits: shbot (~shbot@37.139.2.101) (Remote host closed the connection)
[19:59:27] *** Joins: shbot (~shbot@37.139.2.101)
[20:01:28] *** Quits: defjam (~eb0t@90.210.91.65) (Ping timeout: 256 seconds)
[20:02:04] *** Joins: defjam (~eb0t@90.199.243.99)
[20:04:59] *** Joins: psydroid (~psydroid@user/psydroid)
[20:05:18] *** Quits: mete (~mete@static.201.165.216.95.clients.your-server.de) (Ping timeout: 244 seconds)
[20:07:04] *** Joins: mete (~mete@static.201.165.216.95.clients.your-server.de)
[20:09:33] *** Quits: odc (sid197788@helmsley.irccloud.com) (Ping timeout: 250 seconds)
[20:10:00] *** Quits: tag (sid271787@lymington.irccloud.com) (Read error: Connection reset by peer)
[20:10:00] *** Quits: ljharb (sid43720@user/ljharb) (Read error: Connection reset by peer)
[20:10:04] *** Quits: eruditass (uid248673@uxbridge.irccloud.com) (Read error: Connection reset by peer)
[20:10:04] *** Quits: mobius (sid478273@uxbridge.irccloud.com) (Read error: Connection reset by peer)
[20:11:49] *** Joins: tag (sid271787@lymington.irccloud.com)
[20:12:52] *** Joins: YaoNai (~YaoNai@user/yaonai)
[20:13:08] *** Joins: jmcantrell (~jmcantrel@user/jmcantrell)
[20:13:08] *** Joins: siraben (~siraben@user/siraben)
[20:13:08] *** Joins: ttmrichter-M (~ttmrichte@user/ttmrichter)
[20:13:08] *** Joins: Guest5434 (~dngraymat@2001:470:69fc:105::793b)
[20:13:09] *** Joins: ForeverNoob[m] (~foreverno@2001:470:69fc:105::8c6)
[20:14:17] *** Joins: ljharb (sid43720@user/ljharb)
[20:14:54] *** Joins: mobius (sid478273@uxbridge.irccloud.com)
[20:15:06] *** Joins: eruditass (uid248673@uxbridge.irccloud.com)
[20:18:50] *** Joins: odc (sid197788@helmsley.irccloud.com)
[20:19:35] *** Quits: defjam (~eb0t@90.199.243.99) (Ping timeout: 264 seconds)
[20:21:24] *** Joins: defjam (~eb0t@90.210.93.143)
[20:29:20] *** Quits: psydroid (~psydroid@user/psydroid) (Quit: Client limit exceeded: 20000)
[20:29:28] *** Quits: siraben (~siraben@user/siraben) (Quit: Client limit exceeded: 20000)
[20:29:35] *** Quits: Guest5434 (~dngraymat@2001:470:69fc:105::793b) (Quit: Client limit exceeded: 20000)
[20:29:56] *** Quits: chasmo77 (~chas77@71.63.241.168) (Quit: It's just that easy)
[20:30:03] *** Quits: ttmrichter-M (~ttmrichte@user/ttmrichter) (Quit: Client limit exceeded: 20000)
[20:30:05] *** Quits: ForeverNoob[m] (~foreverno@2001:470:69fc:105::8c6) (Quit: Client limit exceeded: 20000)
[20:30:51] *** Joins: chasmo77 (~chas77@71.63.241.168)
[20:31:15] *** Quits: jmcantrell (~jmcantrel@user/jmcantrell) (Quit: Client limit exceeded: 20000)
[20:50:33] *** Joins: chandoo (~chandoo@pool-71-172-140-13.nwrknj.fios.verizon.net)
[20:53:38] <chandoo> hi
[20:56:58] <chandoo> I have two csv files one file1 with 6 rows(2 columns) and second file2 with 10,000 rows(many columns). I want to add file1 6 rows 2 columns to file2 before the row repeatedly until the last row.
[20:57:44] <chandoo> how do i achieve this with awk
[20:59:32] <nmz1> mmmm
[21:01:22] <nmz1> chandoo: before the row repeatedly?
[21:01:52] <lopid> the mandate is to use awk?
[21:02:08] <nmz1> cat file1 file2 > file3
[21:03:39] <nmz1> I don't understand the repeatedly part
[21:03:51] <chandoo> let me give example
[21:04:01] <nmz1> is there a row that repeats, and then you add to that?
[21:04:04] *** Joins: vlm (~vlm@user/vlm)
[21:04:11] <nmz1> you could give example input and example output
[21:04:19] <nmz1> put it in a pastebin
[21:04:27] <chandoo> okay
[21:07:42] <emanuele6> awk -vother_file=./file2 '{ while(getline l < other_file) print $0","l }' file1
[21:08:50] <chandoo> https://pastebin.com/DpZ2HFqm
[21:08:52] <emanuele6> err, i forgot to close
[21:09:06] <emanuele6> awk -vother_file=./file2 '{ while (getline l < other_file) print $0","l; close (other_file) }' ./file1
[21:09:10] <chandoo> i pasted few rows for file2
[21:09:16] <nmz1> ah, append column from file1 to file2?
[21:09:17] <emanuele6> here close()ing the file is actually important hehe
[21:09:28] <chandoo> file1 as 3 rows
[21:09:52] <chandoo> i want to merge the file1 rows with file2
[21:10:04] <emanuele6> see what i sent
[21:10:34] <chandoo> after first 3 rows in file2, it should repeat again from 4th row so on until last row in file2
[21:10:48] <emanuele6> but the best solution is just to use paste if you want to do this
[21:11:30] <chandoo> the goal is distribute the records evenly to the name
[21:11:48] <chandoo> from file2
[21:11:52] <emanuele6> are you ignoring me?
[21:12:08] <nmz1> maybe he has a slow internet connection
[21:12:09] <chandoo> emanuele6, sorry not ignoring
[21:12:26] <nmz1> they*
[21:13:05] <chandoo> emanuele6, i didn't understand how to use paste
[21:13:15] <emanuele6> i said
[21:13:26] <emanuele6> this is how you do it in awk:  awk -vother_file=./file2 '{ while (getline l < other_file) print $0","l; close (other_file) }' ./file1
[21:13:42] <emanuele6> but it is best to just use the paste(1) utility:    paste -d, file1 file2
[21:14:34] <chandoo> but paste only does for first 3 lines
[21:15:15] <emanuele6> you are right actually
[21:15:20] <emanuele6> but awk works
[21:15:44] <emanuele6> there was a unix tool to do this though, maybe it was not paste
[21:16:01] <chandoo> i am trying your awk statement
[21:17:41] <emanuele6> maybe i imagined paste being able to repeat fields
[21:18:20] <emanuele6> s/fields/files/
[21:18:55] <emanuele6> awk is the best solution i guess
[21:19:44] <chandoo> emanuele6, the statement works, i see peter repeating so many times and next starting with meter
[21:19:54] <chandoo> i didnt understand how it is working
[21:20:30] <chandoo> is it distributing equally to all the lines
[21:21:02] <chandoo> i mean 3 names distributed equally among the 10,000 records in file2?
[21:22:04] <emanuele6> for each of the line of file1, awk reads file2 and for each line of file2, it prints the line from file1, a comma, and the line from file2
[21:22:13] <emanuele6> while (getline l < other_file) print $0","l
[21:22:58] <emanuele6> # echo a > file1; printf '%s\n' b c d > file2; awk -vother_file=file2 '{ while (getline l < other_file) print $0","l; close(other_file) }' file1
[21:22:59] <shbot> emanuele6: a,b
[21:22:59] <shbot> emanuele6: a,c
[21:22:59] <shbot> emanuele6: a,d
[21:25:01] <emanuele6> an alternative solution is to pass the two files to awk directly and store the first file in memory
[21:26:39] <emanuele6> # echo a > file1; printf '%s\n' b c d > file2; awk '{ if (NR == FNR) { a[NR] = $0 } else { for (i = 1; i < length(a); ++i) print a[i]","$0} }' file1 file2
[21:26:40] <shbot> emanuele6: no output
[21:27:24] <emanuele6> oh, <= oops
[21:27:28] <emanuele6> # echo a > file1; printf '%s\n' b c d > file2; awk '{ if (NR == FNR) { a[NR] = $0 } else { for (i = 1; i <= length(a); ++i) print a[i]","$0} }' file1 file2
[21:27:29] <shbot> emanuele6: a,b
[21:27:29] <shbot> emanuele6: a,c
[21:27:29] <shbot> emanuele6: a,d
[21:27:34] *** Joins: tangy (~tangy@user/tangy)
[21:27:48] <chandoo> I ran it on 7000 records, okay i know what is happening,it is repeating 7000 records for each name
[21:27:55] <emanuele6> that also works, but requires more memory 
[21:27:59] <chandoo> the output has 21000 records
[21:29:43] <chandoo> which is not good
[21:30:01] <chandoo> may be i am not explaining it properly.
[21:30:45] <chandoo> say file2 has 9 records, the output i am expecting is peter has 3, meter has 3 and bater has 3
[21:31:12] <chandoo> but total records should not be trippled
[21:31:17] <chandoo> in file2
[21:31:32] <emanuele6> what happens if file2 has 10 records?
[21:31:56] <chandoo> it should repeat peter again which is the first line in file1
[21:32:28] <emanuele6> and if it has 12?
[21:32:45] <emanuele6> peter * 4, meter * 4, bater * 4 ?
[21:33:32] <emanuele6> or does 3 indicate the number of records in file1?
[21:34:15] <emanuele6> so peter * 3, meter * 3, bater * 3, peter * 3?
[21:34:21] <chandoo> correct
[21:34:41] <emanuele6> well, you need to know the length of the first file then
[21:34:44] <chandoo> in my file1 some time i will have 7 records or 10
[21:34:50] <emanuele6> so something similar to the second solution
[21:35:57] <chandoo> your first solution works, but the only problem is it is multipling the records file1 times file2
[21:37:00] <emanuele6> # echo a > file1; printf '%s\n' b c d > file2; awk '{ if (NR == FNR) { a[NR] = $0 } else { print a[(FNR-1)%length(a)+1]","$0} }' file1 file2
[21:37:01] <shbot> emanuele6: a,b
[21:37:01] <shbot> emanuele6: a,c
[21:37:01] <shbot> emanuele6: a,d
[21:37:07] <emanuele6> # echo a > file1; printf '%s\n' b c d > file2; awk '{ if (NR == FNR) { a[NR] = $0 } else { print a[(FNR-1)%length(a)+1]","$0} }' file2 file1
[21:37:08] <shbot> emanuele6: b,a
[21:37:48] <emanuele6> # printf '%s\n' A B C  > file1; printf '%s\n' d e f g h i j k l m n > file2; awk '{ if (NR == FNR) { a[NR] = $0 } else { print a[(FNR-1)%length(a)+1]","$0} }' file1 file2
[21:37:57] <shbot> emanuele6: A,d
[21:37:57] <shbot> emanuele6: B,e
[21:37:57] <shbot> emanuele6: and so forth... (but now the pastebin is sick of me)
[21:38:05] <emanuele6> oh, man
[21:39:44] <chandoo> lol it overwrote my data with a and b :(
[21:39:53] <chandoo> let me pull the files again
[21:40:08] <emanuele6> eitherway, it works http://0x0.st/-R6b.txt
[21:40:30] <emanuele6> maybe there is smarter math do  (FNR-1)%length(a)+1
[21:42:40] <emanuele6> s/do/to do/
[21:43:11] <emanuele6> i guess you could use a[NR-1] to make life easier later
[21:43:59] *** Joins: Torr_ (~Torr@user/torr)
[21:44:07] <emanuele6> not really, because you would still need (FNR-1)%length(a
[21:46:38] <emanuele6> a[NR-1] and a[i++%length(a)] is the cleaner way probably
[21:46:56] <emanuele6> or just use: a[NR] and a[(FNR-1)%length(a)+1]
[21:47:13] <nmz1> shbot uses a pastebin?
[21:47:16] <nmz1> wha?
[21:47:45] <user51> cat file2 | awk '$0 = substr("ABC", NR % length("ABC"), 1)","$0'
[21:47:51] <emanuele6> nmz1: if the output is >=4 lines, yes
[21:48:59] <user51> my code has a problem
[21:49:00] <user51> ignore it
[21:50:03] <nmz1> I mean, I have a rolling pastebin command, its super simple
[21:50:15] <emanuele6> nmz1: https://gitlab.com/geirha/shbot/-/blob/master/evalcmd
[21:50:24] <nmz1> if x goes down, use this one
[21:50:29] <nmz1> sprunge.us goes down a lot
[21:50:35] <nmz1> and ix.io was giving me troubles
[21:51:42] <user51> yeah this is too awkward with awk
[21:52:34] <emanuele6> i never realised using % on 1-indexed arrays was this awkward
[21:54:24] *** Quits: aramtsamtsam (~Thunderbi@94.239.102.102) (Quit: aramtsamtsam)
[21:54:34] <user51> maybe getline and close could be done together
[21:55:07] <chandoo> give me a moment i am preparing a dataset with the ouput as well, for better idea
[21:59:48] <chandoo> pls check this https://pastebin.com/qL0NZ8Sz
[22:00:32] *** Quits: defjam (~eb0t@90.210.93.143) (Ping timeout: 240 seconds)
[22:00:58] <emanuele6> https://pastebin.com/raw/qL0NZ8Sz
[22:01:26] <emanuele6> what?
[22:02:42] *** Joins: defjam (~eb0t@90.198.60.224)
[22:02:43] <emanuele6> chandoo: awk 'FNR == 1 { if(h) print h","$0 else h=$0; next } { if (NR == FNR) { a[NR] = $0 } else { print a[(FNR-1)%length(a)+1]","$0} }' file1 file2
[22:03:15] <emanuele6> actually, you can also remove the braces for the second if/else
[22:03:27] <chandoo> let me try
[22:03:38] <emanuele6> chandoo: awk 'FNR == 1 { if (h) print h","$0 else h = $0; next } { if (NR == FNR) a[NR] = $0 else print a[(FNR-1)%length(a)+1]","$0 }' file1 file2
[22:03:59] <emanuele6> that is to treat the first line specially
[22:04:56] <emanuele6> ah, right you need a semicolon if you don't use {}
[22:04:59] <emanuele6> nevermind
[22:05:59] <emanuele6> also the modulo math needs to change
[22:06:06] <emanuele6> because now the array is two indexed
[22:06:36] <chandoo> i am getting syntax error
[22:06:42] <emanuele6> yes.
[22:07:38] <emanuele6> # printf '%s\n' A B C  > file1; printf '%s\n' d e f g h i j k l m n > file2; awk 'FNR == 1 { if (h) print h","$0; else h = $0; next } NR == FNR { a[NR] = $0; next } { print a[(FNR-2)%length(a)+2]","$0 }' file1 file2
[22:07:43] <shbot> emanuele6: A,d
[22:07:44] <shbot> emanuele6: B,e
[22:07:44] <shbot> emanuele6: etc... ( http://ix.io/3Fnf )
[22:07:48] <emanuele6> now it has to be -2 +2
[22:07:56] <emanuele6> even more awk-ward
[22:07:57] <user51> chandoo: remove the first line in file1, put it in a different file
[22:08:07] <user51> save the edited file1
[22:08:28] <user51> cat it repeatedly until the result has more lines than file2
[22:08:46] <emanuele6> user51: this is #awk, only awk solutions :P
[22:09:11] <user51> not having ungetline was a mistake :P
[22:09:28] <user51> this really could be neatly solved by a circular buffer
[22:10:16] <chandoo> https://pastebin.com/Gfq6V7Kh
[22:10:29] <emanuele6> yes, we know
[22:10:34] <emanuele6> we already addressed that
[22:10:35] * chandoo checking the syntax error
[22:10:35] *** Joins: roarde (~roarde@user/roarde)
[22:10:45] <emanuele6> chandoo: check the last command
[22:11:04] <chandoo> is this  awk 'FNR == 1 { if (h) print h","$0 else h = $0; next } { if (NR == FNR) a[NR] = $0 else print a[(FNR-1)%length(a)+1]","$0 }' file1 file2
[22:11:40] <emanuele6> <emanuele6 >ah, right you need a semicolon if you don't use {}
[22:11:53] <emanuele6> <emanuele6 >also the modulo math needs to change
[22:12:09] <emanuele6> <emanuele6>chandoo: check the last command
[22:12:49] <chandoo> emanuele6, you are amazing
[22:13:33] <chandoo> validating it
[22:13:46] <emanuele6> but it's weird that you have the header into the file with the data to be honest
[22:13:53] <emanuele6> is that common?
[22:14:41] <chandoo> yes file i get is with header
[22:15:43] <chandoo> this is simply superb, thanks a lot emanuele6 
[22:17:06] <chandoo> right now they way i am doing is , i import them into mysql. add columns to the table add a special sequence column, and update the records distrubuting evenly and query them back and export csv file
[22:18:38] <emanuele6> if you were actually doing csv manipulation, that would be better than awk 
[22:19:11] <emanuele6> but since you are just combining two lines of whatever together with a comma between them awk is better
[22:19:57] <chandoo>  printf '%s\n' A B C  > file1; printf '%s\n' d e f g h i j k l m n > file2; awk 'FNR == 1 { if (h) print h","$0; else h = $0; next } NR == FNR { a[NR] = $0; next } { print a[(FNR-2)%length(a)+2]","$0 }' file1 file2
[22:20:20] <chandoo> in this i replaced at the end with file1 and file2
[22:20:37] <chandoo> not before the printf statements
[22:20:59] <chandoo> am i doing it right
[22:21:18] <emanuele6> huh?
[22:21:30] <chandoo> i see good output
[22:22:06] <emanuele6> what are you asking?
[22:22:34] <chandoo> do i have to replace file1 and file2 in all the locations in the command
[22:22:39] <chandoo> with actual files
[22:22:44] <chandoo> or just at the end
[22:23:33] <emanuele6> i don't understand
[22:24:13] *** Quits: Torr_ (~Torr@user/torr) (Quit: leaving)
[22:24:18] <chandoo> sorry my mistake , i copied your complete command including printf statements
[22:24:35] <emanuele6> printf is bash code
[22:24:52] <chandoo> it is not needed
[22:24:58] <emanuele6> i use the printf commands to create file1 and file2 for shbot
[22:25:09] <chandoo> just awk statement is working good
[22:25:11] <chandoo> okay
[22:33:23] *** Quits: lavaball (felix@31.204.155.215) (Remote host closed the connection)
[22:36:41] *** Joins: X-Scale` (~ARM@92.250.99.18)
[22:38:11] *** Quits: X-Scale (~ARM@165.201.137.78.rev.vodafone.pt) (Ping timeout: 264 seconds)
[22:39:45] *** Joins: X-Scale (~ARM@46.50.7.119)
[22:41:50] *** Quits: X-Scale` (~ARM@92.250.99.18) (Ping timeout: 256 seconds)
[22:43:11] <chandoo> emanuele6, thanks for helping with the awk statement. it was elegant.
[22:43:33] <emanuele6> > (FNR-2)%length(a)+2
[22:43:33] <chandoo> I know little bit of awk, but not as complex as you write
[22:43:41] <emanuele6> hehe awk-ward math though
[22:44:08] <emanuele6> chandoo: it's simple
[22:44:17] <emanuele6>   FNR == 1  is true if FNR is 1
[22:44:29] <emanuele6> FNR is the record number for the current file
[22:44:53] <emanuele6> it will be 1 only for the first line of file1 and for the first line of file2
[22:45:14] <emanuele6>   if (h) print h","$0; else h = $0
[22:45:24] <emanuele6> if FNR==1 is true, you check if h is set
[22:45:39] <emanuele6> if it is not, you set h to the current line: h = $0
[22:46:14] <emanuele6> otherwise, if h is set already, you print the current line preceded by h and ","
[22:47:02] <emanuele6> then there is `next' that skips the rest of the code (we don't want to run the rest of the code for the first line of file1 and file2)
[22:47:16] <emanuele6> now the next check is  NR == FNR
[22:47:31] <emanuele6> NR is like FNR, but it is not local to the file
[22:48:10] <emanuele6> so if file1 has 3 lines and file2 has 4 lines and you are at line 2 of file2, you will have FNR=2 NR=5
[22:48:30] <emanuele6> because the second record of the second file is the fifth record overall
[22:48:46] <emanuele6> so  NR == FNR  is basically a check to check if you are reading the first file or not
[22:49:05] <emanuele6> if we are reading the first file, we run    a[NR] = $0; next
[22:50:02] <emanuele6> so we add a value to the a associative array at index NR with the content of the current line
[22:50:12] <emanuele6> and then use next to skip the rest of the code
[22:50:52] <emanuele6> finally we run the rest of the code only if we are not reading the first file and this is not the first line of the current file
[22:50:59] <emanuele6> the code is    print a[(FNR-2)%length(a)+2]","$0
[22:52:02] <emanuele6> so we use some math a[(FNR-2)%length(a)+2] to cycle the values of a   (lenght(a) is the number of values in a, i.e. the number of records in file1 excluding the header)
[22:52:20] <emanuele6> and we print that value, a comma, and the current line
[22:53:55] <chandoo> emanuele6, thanks for explaining the code, I took notes, I will spend time understanding it.
[22:54:08] <chandoo> a[NR]
[22:54:39] <chandoo> the NR in the arrary is it just a name or NR function
[22:54:50] <emanuele6> it's _NR
[22:54:58] <emanuele6> err, NR
[22:55:04] <emanuele6> <emanuele6 > NR is like FNR, but it is not local to the file
[22:55:12] <emanuele6> <emanuele6 > so if file1 has 3 lines and file2 has 4 lines and you are at line 2 of file2, you will have FNR=2 NR=5
[22:55:32] <chandoo> i got that
[22:55:40] <emanuele6> it's a number
[22:55:56] <chandoo> but in the array is little confusing to me
[22:56:25] <chandoo> a is the array name and NR holds the number of the current record right
[22:56:36] <emanuele6> yes
[22:57:08] <chandoo> is NR a variable in the array
[22:57:15] <emanuele6> NR is the index
[22:57:30] <nmz1> and it is a variable
[22:57:45] <emanuele6> # awk 'BEGIN{ a[1]="hi"; a[2]="hello"; print a[2] }'
[22:57:46] <shbot> emanuele6: hello
[22:58:16] <emanuele6> i set a[1]="hi" and a[2]="hello", if i print a[2] later, it will print hello
[22:58:41] <chandoo> so NR is both at the same time
[22:58:48] <emanuele6> both what?
[22:58:52] <emanuele6> NR is a number, right?
[22:59:05] <emanuele6> if NR is 2, a[NR]=$0 will be the same as a[2]=$0
[22:59:18] <nmz1> NR == Number Record
[22:59:28] <nmz1> its a number
[22:59:31] <chandoo> if i use a[CR]
[22:59:37] <nmz1> CR?
[22:59:40] <chandoo> does it work the same way
[22:59:53] <emanuele6> i don't know what CR is
[22:59:57] <nmz1> what's CR?
[23:00:40] <chandoo> what i mean is in AWK NR is a function which holds the current record number
[23:00:58] <chandoo> oh okay i got it now
[23:01:07] <emanuele6> well, it's a variable, not a function, but yes
[23:02:06] <emanuele6> # printf '%s\n' hehe > file1; printf '%s\n' haha lol > file2    ;   awk '{ printf "FILENAME=%s NR=%s FNR=%s $0=%s\n", FILENAME, NR, FNR, $0 }' file1 file2
[23:02:07] <shbot> emanuele6: FILENAME=file1 NR=1 FNR=1 $0=hehe
[23:02:07] <shbot> emanuele6: FILENAME=file2 NR=2 FNR=1 $0=haha
[23:02:07] <shbot> emanuele6: FILENAME=file2 NR=3 FNR=2 $0=lol
[23:03:16] <emanuele6> "haha" is the 1-st (FNR) record for the current file (FILENAME) that is file2 and the 2-nd (NR) record overall
[23:05:26] *** Quits: tangy (~tangy@user/tangy) (Remote host closed the connection)
[23:05:34] <chandoo> got it
[23:06:07] <chandoo> i ran awk '{print NR,FNR}' file1 file2
[23:06:18] <chandoo> now i understood what mean FNR as local
[23:06:47] <chandoo> FNR holds the records of the files where as NR is cumulative of the records in the output
[23:06:56] *** Quits: Guest4253 (~Guest4253@user/tangy) (Remote host closed the connection)
[23:07:35] <chandoo> if i pass 3 files what happens
[23:07:38] <chandoo> let me try
[23:08:03] <emanuele6> NR keeps increasing for every record, FNR also keeps increasing for every record, but gets reset at the start of every file
[23:08:05] *** Quits: nmz1 (~nmz@24.137.228.140) (Ping timeout: 250 seconds)
[23:46:58] *** Joins: nmz1 (~nmz@24.137.228.140)
