[00:02:01] *** Quits: lisp123 (~lisp123@5.30.23.247) (Quit: Leaving...)
[00:17:15] *** Quits: shka (~herr@109.231.62.239) (Ping timeout: 265 seconds)
[00:19:01] *** Joins: taichi (~mariari@user/mariari)
[00:19:22] *** Quits: mariari (~mariari@user/mariari) (Ping timeout: 260 seconds)
[00:23:19] *** Quits: test_user (~test_user@2a02:908:1252:7a80:7b8c:52d6:562c:de3a) (Ping timeout: 252 seconds)
[00:29:27] *** Joins: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431)
[00:49:57] *** Quits: cage (~cage@dynamic-adsl-78-15-41-207.clienti.tiscali.it) (Quit: rcirc on GNU Emacs 27.1)
[01:04:25] *** Quits: Devon (~devon@c-24-2-157-5.hsd1.ma.comcast.net) (Ping timeout: 252 seconds)
[01:13:08] *** Joins: joe_mad (~user@you.are.just.verymad.net)
[01:23:15] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[01:28:55] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 260 seconds)
[01:29:19] *** Joins: Lord_of_Life (~Lord@user/lord-of-life/x-2819915)
[01:35:17] *** Parts: joe_mad (~user@you.are.just.verymad.net) (ERC (IRC client for Emacs 27.1))
[01:38:59] *** Joins: Fare (~fare@172.58.217.195)
[01:57:50] *** Quits: Fare (~fare@172.58.217.195) (Ping timeout: 260 seconds)
[01:58:40] *** Quits: vats (~vats@103.70.83.191) (Ping timeout: 260 seconds)
[02:11:51] *** Joins: Fare (~fare@172.58.217.195)
[02:21:40] *** Joins: akoana (~ah@user/akoana)
[02:27:55] *** Joins: john-a-carroll (~john-a-ca@host-92-28-178-6.as13285.net)
[02:40:07] *** Quits: john-a-carroll (~john-a-ca@host-92-28-178-6.as13285.net) (Ping timeout: 252 seconds)
[02:42:15] *** Quits: Fare (~fare@172.58.217.195) (Ping timeout: 265 seconds)
[02:42:21] *** Quits: pve (~pve@37-136-10-145.rev.dnainternet.fi) (Quit: leaving)
[03:08:32] *** Joins: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3)
[03:08:47] *** Quits: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3) (Remote host closed the connection)
[03:08:57] *** Quits: White_Flame (~quassel@user/white-flame/x-6930243) (Remote host closed the connection)
[03:09:16] *** Quits: kulernil (~kulernil@gateway/tor-sasl/kuler) (Write error: Connection reset by peer)
[03:09:16] *** Quits: hendursaga (~weechat@user/hendursaga) (Write error: Connection reset by peer)
[03:09:16] *** Quits: gxt (~gxt@gateway/tor-sasl/gxt) (Write error: Connection reset by peer)
[03:09:16] *** Quits: azimut_ (~azimut@gateway/tor-sasl/azimut) (Remote host closed the connection)
[03:09:22] *** Joins: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3)
[03:10:11] *** Joins: White_Flame (~quassel@user/white-flame/x-6930243)
[03:18:24] *** Joins: Lycurgus (~juan@98.4.112.204)
[03:29:38] *** Quits: gaqwas (~john@dynamic-095-114-050-136.95.114.pool.telefonica.de) (Ping timeout: 265 seconds)
[03:35:51] *** Joins: kakuhen (~kakuhen@user/kakuhen)
[04:04:14] *** Parts: akoana (~ah@user/akoana) (Leaving)
[04:06:04] *** Quits: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3) (Ping timeout: 252 seconds)
[04:15:49] *** Quits: random-nick (~random-ni@87.116.165.220) (Ping timeout: 252 seconds)
[04:55:04] *** Joins: Fare (~fare@2601:184:4a7f:995c:97a9:9a6c:2f6d:38ee)
[04:56:23] *** Joins: Oladon (~olad@98.43.81.226)
[06:08:38] *** Quits: Josh_2 (~user@37.25.47.130) (Quit: ERC (IRC client for Emacs 27.1))
[06:41:20] *** Parts: contrapunctus (a75f5b1571@2a00:c70:1:178:170:40:189:1) ()
[06:41:47] *** Joins: contrapunctus (a75f5b1571@2a00:c70:1:178:170:40:189:1)
[06:45:07] *** Quits: hubvu (sid495858@id-495858.tinside.irccloud.com) (Changing host)
[06:45:07] *** Joins: hubvu (sid495858@user/hubvu)
[06:46:32] *** Quits: srhm (~srhm@user/srhm) (Read error: Connection reset by peer)
[06:50:31] *** Quits: Fare (~fare@2601:184:4a7f:995c:97a9:9a6c:2f6d:38ee) (Ping timeout: 252 seconds)
[06:55:43] *** Joins: srhm (~srhm@user/srhm)
[06:56:06] *** Quits: srhm (~srhm@user/srhm) (Client Quit)
[07:16:12] *** Joins: Fare (~fare@2601:184:4a7f:995c:1d33:d96a:928:a930)
[07:17:02] *** Joins: pillton (~user@193-116-116-247.tpgi.com.au)
[07:21:41] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[07:31:32] <beach> Good morning everyone!
[07:33:50] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 260 seconds)
[07:36:21] *** Quits: Skyfire (~pyon@user/pyon) (Quit: brb)
[07:41:08] *** Quits: abrantesasf (abrantesas@gateway/vpn/protonvpn/abrantesasf) (Quit: Leaving)
[07:46:06] *** Joins: Skyfire (~pyon@user/pyon)
[08:16:04] *** Joins: Oladon (~olad@98.43.81.226)
[08:21:02] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[08:21:16] *** Quits: semz (~none@user/semz) (Ping timeout: 252 seconds)
[08:27:28] *** Joins: hendursaga (~weechat@user/hendursaga)
[08:28:28] *** Joins: gxt (~gxt@gateway/tor-sasl/gxt)
[08:33:23] *** Joins: semz (~none@user/semz)
[08:44:46] *** Quits: igemnace (~ian@user/igemnace) (Remote host closed the connection)
[09:01:16] *** Quits: nature_ (~nature@mail.blazebone.com) (Ping timeout: 252 seconds)
[09:24:22] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[09:27:31] <semz> good morning
[09:37:03] <beach> Hello semz.
[09:42:38] *** Quits: Fare (~fare@2601:184:4a7f:995c:1d33:d96a:928:a930) (Ping timeout: 260 seconds)
[09:49:48] *** Joins: Doraemon (~NeoCron@p200300c4cf4f9c00198c896a0feeb747.dip0.t-ipconnect.de)
[09:52:01] *** Quits: neocron (~NeoCron@p200300c4cf3ba70012c3036b63257be6.dip0.t-ipconnect.de) (Ping timeout: 252 seconds)
[09:54:47] *** Joins: Fare (~fare@2601:184:4a7f:995c:4e7:c276:8502:260f)
[10:16:12] *** Quits: Lycurgus (~juan@98.4.112.204) (Quit: Exeunt)
[10:23:40] *** Joins: shka (~herr@109.231.62.239)
[10:28:22] *** Quits: Fare (~fare@2601:184:4a7f:995c:4e7:c276:8502:260f) (Ping timeout: 260 seconds)
[10:32:35] *** Joins: karlosz (~karlosz@12.196.174.98)
[10:37:17] *** Quits: karlosz (~karlosz@12.196.174.98) (Client Quit)
[11:12:06] *** Joins: karlosz (~karlosz@12.196.174.98)
[11:16:20] *** Joins: Devon (~devon@c-24-2-157-5.hsd1.ma.comcast.net)
[11:17:48] *** Joins: igemnace (~ian@user/igemnace)
[11:29:41] *** Quits: karlosz (~karlosz@12.196.174.98) (Quit: karlosz)
[12:12:54] *** Joins: treflip (~user@95.79.32.99)
[12:19:03] *** Joins: ln43 (~ln43@user/ln43)
[12:20:46] *** Parts: treflip (~user@95.79.32.99) (ERC (IRC client for Emacs 27.2))
[12:25:28] *** Quits: Doraemon (~NeoCron@p200300c4cf4f9c00198c896a0feeb747.dip0.t-ipconnect.de) (Ping timeout: 252 seconds)
[12:36:10] *** Joins: hendursa1 (~weechat@user/hendursaga)
[12:39:15] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[12:40:12] *** Joins: gaqwas (~john@dynamic-095-115-065-228.95.115.pool.telefonica.de)
[12:48:42] *** Joins: Everything (~Everythin@37.115.210.35)
[12:50:13] *** Quits: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431) (Quit: Leaving)
[13:12:43] *** Quits: andreyorst (~andreyors@2.92.126.234) (Quit: WeeChat 3.2)
[13:23:56] *** Joins: VincentVega (~user@212.241.24.161)
[13:25:34] *** Joins: pve (~pve@178-55-46-33.bb.dnainternet.fi)
[13:57:21] *** Quits: ln43 (~ln43@user/ln43) (Quit: Connection closed)
[14:02:47] *** Quits: hugo (znc@verdigris.lysator.liu.se) (Quit: ZNC 1.7.5 - https://znc.in)
[14:03:08] *** Joins: hugo (znc@verdigris.lysator.liu.se)
[14:15:09] *** Joins: cage (~cage@dynamic-adsl-78-15-41-207.clienti.tiscali.it)
[14:18:35] <akater[m]> Yesterday I had a little conversation about CLOS usage in Emacs.  And I formulated something I've been thinking about for a long time.  The purpose of Lisp object systems — at least Flavors and CLOS — is to enable modular design via flexible and predictable code reuse.  When you don't reuse code by means of inheritance and don't see how and why it would happen, there is no point in using CLOS, at all.  Agree?
[14:21:21] <White_Flame> the method dispatch is very useful even if you never use defclass
[14:21:24] <semz> Code reuse need not happen through inheritance specifically, generic functions can do that just fine.
[14:23:10] <beach> akater[m]: Also, people may avoid code reuse and may fail to see how and why it could happen, out of ignorance.  Ignorance is a bad excuse for avoiding CLOS.
[14:23:30] <White_Flame> also, the failings of OO in general are not unique failings of CLOS
[14:24:12] <White_Flame> especially since CLOS goes way more powerful than typical simplified object systems
[14:24:58] <semz> I'd actually say that inheritance is the most overrated aspect of OOP. I rarely ever find myself using it. There's also the aspect that classes are redefinable at runtime while structs are not, but this is more of a CL quirk than anything general.
[14:26:35] <borodust> etimmons: hmm, it seems for quicklisp type of a source, clpm expects there to be present *-versions.txt file
[14:27:09] <borodust> etimmons: this file is not required for quicklisp client to work with a ql dist
[14:27:11] <mfiano> borodust: Yes. It needs to know the entire history
[14:27:19] <mfiano> Otherwise how would the lockfile be written?
[14:27:51] <hayley> Inheritance is one way to get mixins, which are underrated (though perhaps over-represented in CLOS).
[14:28:36] <borodust> mfiano: well, it's like with asdf versions, not every dist is versioned :)
[14:29:17] <borodust> i mean, if that's how clpm dictates it must be - i'm fine with that
[14:30:27] <hayley> I admit I made too much spooky action at a distance for myself by using :after methods to achieve some sort of "reactive" programming. But it was only a problem because I need the behaviour of a concurrent program written down in (close to) one place so that I can model it.
[14:31:52] <mfiano> I think the most under-used CLOS feature is progn method combination. I rarely see that used in codes that are not my own. Maybe it is just too domain-specific...idk, but I use it all the time.
[14:32:51] <hayley> Seems I have used progn to implement hooks for STOP-CONNECTION <https://cal-coop.gitlab.io/netfarm/documentation/decentralise2.html#%28idx._%28gentag._2%29%29>
[14:32:59] <mfiano> Nice
[14:35:03] <beach> mfiano: https://github.com/robert-strandh/SICL/blob/master/Code/Cleavir/Meter/meter.lisp
[14:35:18] <hayley> If I ever feel like writing it, I'll eventually get to the third iteration of my node software, which hopefully should be space efficient first (we need to check the transitive closure of objects but only temporarily) and then hopefully time efficient.
[14:36:05] <hayley> Been thinking I should test software transactional memory at that layer. If I use a SQL database properly, I would be marking out transactions somewhere anyway.
[14:36:35] <mfiano> Very nice. For me, progn combination is so useful that it is probably my favorite feature of CLOS. It comes in useful far too often for me, and I don't know of a comparable feature in any other object system.
[14:37:15] <beach> Here, we use the APPEND method combination: https://github.com/robert-strandh/SICL/blob/master/Code/Cleavir/Input-output/io.lisp
[14:38:24] <beach> Features like that are rarely used, like macros, but when you need them, they are totally essential.
[14:46:37] <akater[m]> White_Flame: Dispatch is useful but it doesn't require CLOS.  When only a single method is ever going to be applicable per gf call, you may just as well roll your own interface to recompiling a defun.  I think I'd do that without thinking twice.
[14:46:52] <White_Flame> GFs & method dispatch are part of CLOS
[14:47:10] <White_Flame> oh, right
[14:47:23] <White_Flame> but yeah, it's better to use built-in dispatch than roll your own
[14:47:59] <beach> And with generic functions, the methods don't have to be physically in the same place.
[14:48:24] <beach> And yes, rolling your own is not a great idea.
[14:49:01] *** Joins: random-nick (~random-ni@87.116.165.220)
[14:50:25] <beach> akater[m]: PRINT-OBJECT is an example of a generic function where typically a single method is applicable for every call, but it is totally essential for application code to be able to add a method to it, without editing a global function.
[14:54:44] <akater[m]> beach: With print-object, it's trivial to imagine a use case for :before or :after method
[14:57:21] <akater[m]> All right, we seem to disagree.  CL is missing a simpler inheritance-less dispatch — for legit reasons, I think (there's likely no single good enough design for this) but it is this fact that gives rise to one “Let's make all functions generic!” attempt after another.  Meanwhile, people will keep writing such dispatching mechanisms (an reasonable ones) because they want expressive user-space optimization, dependent types and so on.
[14:57:45] <beach> I think you understood that when I mentioned PRINT-OBJECT, I was giving an example of a generic function with many methods, where typically only one is applicable, but where each method belongs to a totally separate "module", so that it is not reasonable to modify a global definition.
[14:59:10] <hayley> I disagree that any "user-space optimization" is any good, even if we limit ourselves to dispatching without inheritance. Merely inlining methods based on type inference with no regard for handling redefinition is definitely a step down.
[14:59:16] *** Joins: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431)
[15:01:24] <beach> akater[m]: What kind of optimizations are you thinking of?
[15:01:25] <hayley> Hot take: most of the perceived performance benefits of limiting dispatch techniques are disproven by reading up on the Self compiler. 30 years old isn't old enough to be conventional "wisdom" I guess.
[15:05:46] <hayley> I mean, polymorphic inline caches nail down the set of actually used effective methods. Using dependent types...is another thing which wouldn't fit in the Common Lisp standard unless you are willing to specify a dependent type system too.
[15:10:20] <mfiano> Having undecidable type inference wouldn't be very appealing.
[15:15:05] *** Quits: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431) (Quit: Leaving)
[15:24:25] *** Joins: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3)
[15:26:09] <akater[m]> beach: E.g. ones that make Common Lisp programmers migrate to Julia, or motivate them to write libraries like static-dispatch, polymorphic-functions and so on.
[15:33:16] <hayley> I try not to think about people who think that static "dispatch" is related to ad-hoc polymorphism.
[15:34:12] <mfiano> Can you elaborate, hayley?
[15:34:54] <hayley> polymorphic-functions looks great actually, but it requires a few compiler extensions which don't look like "user-space optimization".
[15:35:42] *** Quits: kakuhen (~kakuhen@user/kakuhen) (Quit: Leaving...)
[15:35:44] <mfiano> After quite a bit of use, I am no longer a fan of these semantic-altering method dispatch extensions.
[15:36:51] <mfiano> Also fail to see how they relate to Julia's dynamic typing parametric polymorphism
[15:37:24] <hayley> PCL mentions it in the chapter on generic functions; that there is no real dispatch done on "overloaded methods" as they exist in Java and C++. They could well be sugar for separate functions (and, in fact, the Java compiler desugars methods internally).
[15:38:04] <hayley> And, as there is no standard type inference algorithm for Common Lisp, which methods are chosen due to type inference are more or less implementation-defined.
[15:38:22] <mfiano> Yes
[15:38:40] <akater[m]> Parametric types is its own example.
[15:39:36] <hayley> (But again, polymorphic-functions propagates type information between functions, and it doesn't mention handling function redefinition, so I assume it would not work.)
[15:41:23] *** Quits: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3) (Remote host closed the connection)
[15:42:02] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[15:42:36] <akater[m]> Well, my point is, people do write their own dispatch methods, this is not going anywhere.  And I still think method combination according to inheritance is the core of CLOS and if it's not actually utilized, and there's no vision as to why it might be, no need to get CLOS involved.
[15:43:19] <mfiano> I don't understand. I rarely use inheritance, but use CLOS quite heavily.
[15:43:33] <hayley> What the Julia language does, to my knowledge, is use a parametric type system, and the compiler generates method code for each instantiation of a function type. The compiler also notably tracks dependencies and recompiles code if types and/or method definitions change.
[15:43:49] <mfiano> hayley: Right. At least in Julia, new code will be jitted as types change at runtime. These CL lbraries alter the semantics of generic functions in this respect.
[15:44:04] <hayley> Yes, exactly my point.
[15:44:57] <akater[m]> This is going to be one single point where I disagree with common CL users' wisdom.  But given how underrated define-method-combination is, I don't mind it.
[15:48:40] <mfiano> But yeah, I think we are on the same page. I can no longer think of using such libraries, as the result may differ from compile-time to run-time, or even implementation to implementation. It has resulted in me chasing down some hard to find bugs in the past.
[15:50:13] <hayley> I wouldn't mind more JITing in Common Lisp compilers, but there is the issue that, with some things that a JIT might speculate on, performance "ramps up" or is otherwise inconsistent.
[15:50:21] <mfiano> When I think of performance, the first thing I consider is programmer productivity, not efficiency of computer resources. It is, after all, why I transitioned to CL from Python a couple decades ago.
[15:51:40] <hayley> Though polymorphic-functions-esque "JIT"ing, wherein we just generate specialised code for instances of a polymorphic function, is definitely safe to do, as performance only drops while specialised code is generated again.
[15:51:50] *** Quits: pillton (~user@193-116-116-247.tpgi.com.au) (Quit: ERC (IRC client for Emacs 27.2))
[15:51:52] <mfiano> Yes, I think I favor a consistent execution performance over the nightmares profiling JIT code can incur
[15:52:25] <hayley> (I believe that to be the case as redefinition of functions only occurs with someone poking at it, and in that case, your typing and/or thinking speed is the limiting factor.)
[15:55:22] <mfiano> I will take your word for it. Redefinition and performance conflict each other in so many places in my experience.
[15:55:58] <hayley> On the other hand, things like generic function caches and call-site snippets generated for generic function dispatch (aka polymorphic inline caches, again) still ramp up. But I guess the variation is small enough that people don't care.
[15:57:30] <mfiano> Like, take #'standard-instance-access for example, where we can instruct CLOS on how to locate slot values. We could, and I did before, write a metaclass to generate inlinable accessor functions like structs, which would allow for redefinition, but redefinition of superclasses would pose a problem for live instances.
[16:03:28] <mfiano> For that to work, you would have to severely constrain the user by enforcing the sealing of classes or some such, which is what I did, but it made sense since superclasses were implementation details in the the package.
[16:04:18] <mfiano> in the _library_ package.
[16:05:18] *** Quits: Everything (~Everythin@37.115.210.35) (Quit: leaving)
[16:05:19] <mfiano> and I had to present the class definition in a macro to prevent users from defining derivations of this optimized type.
[16:05:32] <hayley> Redefinition could be handled on a path which handles type errors, provided you check types.
[16:06:14] <hayley> The slow path would be used until the function is re-compiled, either by the system or by the programmer.
[16:09:05] <mfiano> I'm not sure how you would handle obsoleted instances in a slow path though.
[16:11:52] <hayley> I'm only really aware of how obsolete instances are handled in SICL, so I can only comment on that. Each, say, "version" of a class has a unique stamp number.
[16:12:34] <hayley> So the fast path would be used if the object is a standard instance, and the stamp of the object is the same as the stamp of the class version we compiled against.
[16:14:23] <hayley> The slow path would be used to detect an obsolete instance, in which case we update the instance and retry, to detect obsolete code, in which case we use a slower lookup procedure (and possibly queue the function for recompilation), or signal a type error.
[16:15:02] <mfiano> I see, though I was considering user code, not implementation code.
[16:15:30] <mfiano> Like how al ibrary might write something that utilizes S-I-A in a redefinition-safe way
[16:16:15] <hayley> I think this procedure would nearly work with user code, except that you would have to be able to detect obsolete code as well as obsolete instances.
[16:16:36] <mfiano> Right, and that's the part I decided not to dive too deep into :)
[16:17:16] <hayley> A normal generic function for the slow path would never have obsolete code, come to think of it. So perhaps use that for the slow path?
[16:17:34] <hayley> The MOP dependency protocol, to my knowledge, does handle obsolete code for generic functions.
[16:25:17] <hayley> mfiano: Though I think programmer productivity can be improved by having a compiler which generates fast code, as you can get away with writing a simple but inefficient algorithm on some workloads. But of course the result isn't an efficient program.
[16:26:30] <mfiano> Sure.
[16:26:59] <mfiano> I have yet to read the call site optimization paper in full.
[16:27:13] <hayley> Another thing: a few days ago I needed to modify a A* implementation in Python to track sets of visited locations. Copying all the sets took significant time according to the profiler. So I asked my colleagues if there was a HAMT implementation in Python.
[16:28:27] <mfiano> I haven't studied it too deeply yet, but have you seen this? https://www.gdcvault.com/play/1022094/JPS-Over-100x-Faster-than
[16:28:35] <hayley> But there is a problem with that idea, at least when you use CPython: there is no way a pure Python implementation would be fast, and an implementation using C extension would increase the risk that we cannot build the program somehow.
[16:29:22] <hayley> I was vaguely aware of JPS, but not any algorithm with a + on the end of the name.
[16:31:24] <hayley> In my situation, I don't think it would work too well though. The main problems are that substantial time is taken while incrementally loading the world from Minecraft, even with caching, and the cost function I use does not expose many "symmetries" to make use of.
[16:34:44] <mfiano> I see. Tbh I haven't used A* with anything more than an L1 norm heuristic
[16:35:46] <hayley> Experimentally, runs in a straight line tend to only be a few blocks long. But, if I had more time, a proper investigation would interesting. I had to replace all the data structures, as someone only tested the implementation on little 2D mazes and not 3D open areas, and so everything blew up in size.
[16:36:48] <hayley> I nearly did implement something like jump points, but the points were computed while searching, rather than before.
[16:38:44] <hayley> Someone told me about how another group used multiple processes to retrieve world data, and my stupid chunk-at-a-time cache was apparently faster. So I guess there is not much you can do to optimise Python code.
[16:39:12] <mfiano> I haven't used Python in a couple decades and can't remember how slow it is. Not sure how close to acceptable algorithm complexity will buy you over there. I just remember it being "slow", whatever I was comparing it to at the time.
[16:40:36] <hayley> Yeah, that was our conclusion. We wanted to use PyPy instead, but Numpy would refuse to load for whatever reason. (They were pretty surprised when I mentioned that Common Lisp had multi-dimensional arrays out of the box.)
[16:41:56] <pjb> My bad experience with python that it didn't support thread on the platform I needed it (OpenWrt/mips), so in the end I wrote it in C, but it would have been faster to do it in CL and use ecl from the start.
[16:42:43] <hayley> On paper, it is true that performance is a property of implementations and not languages. In practise, it is still true, because you can write a fast compiler for even "slow" languages like Python and JavaScript. In practise (but for real this time), you have to be lucky for programs to not depend on behaviour of the slow implementation.
[16:43:46] <hayley> Common Lisp (hey, some wise people thought it was hard to compile in the 80s, and some less wise people think it is now) and JavaScript got lucky, as there have been multiple implementations of either for a long time.
[16:44:39] <mfiano> I vaguely recall Guido refusing to support TCO many years ago, for some crazy reasons, probably an excuse born out of his early design mistakes making it difficult.
[16:45:29] <semz> I believe the argument was that it made backtraces harder to read.
[16:46:03] <hayley> In #lispcafe a video came up about some "software drag race" where the author said Lisp used bytecode interpretation. More amusingly, the rest of the video dragged on about the bytecodes employed by the Java and C# virtual machines, as if they weren't immediately discarded by the compiler.
[16:46:21] <hayley> Something like http://funcall.blogspot.com/2011/03/tail-recursion-and-debugging.html I guess?
[16:49:40] <mfiano> Yeah it's a common misconception about CL :/
[16:50:23] <hayley> I found it more amusing that the same misconception was nearly carried out on Java and C♯.
[16:51:08] <mfiano> I recently recommended to the Julia landugage team to make their disassembler more like cl:disassemble. They were very surprised to learn it showed code size etc (on SBCL) almost as much as they were that an "interpreted language" could have such a feature.
[16:51:11] <hayley> In the end, of course, the benchmark numbers reflected the reality wherein both implementations using optimising compilers.
[16:51:41] <mfiano> But now Julia shows code size etc like SBCL
[16:51:45] <hayley> Funny, I thought they were relatively aware of Common Lisp.
[16:52:31] <mfiano> Yeah me too, especially since the parser is written in Lisp
[17:03:22] *** Quits: hendursa1 (~weechat@user/hendursaga) (Quit: hendursa1)
[17:03:57] *** Joins: hendursaga (~weechat@user/hendursaga)
[17:26:16] *** Joins: Fare (~fare@2601:184:4a7f:995c:fff9:8c2c:df1f:5a31)
[17:43:24] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[17:55:22] <jcowan> In Femtolisp, which is not quite CL and not quite Scheme -- and is interpreted.  So the idea of Lisp *compilers* probably wasn't in view.
[17:57:15] <jcowan> Oh.  JVM bytecode is by no means discarded: all cold code is interpreted until the JIT kicks in.  The CLR bytecodes are never interpreted, though.
[17:57:30] <jcowan> mfiano, hayley:  ^^
[18:00:28] <hayley> Right, yes. I should elaborate: the subject of testing is a method run in a tight loop, which the JVM would run the optimising compiler on. So performance is not a function of bytecode design.
[18:03:16] <mfiano> jcowan: Speaking of, that seems to be you in the first comment of the above article :)
[18:06:50] <jcowan> It is.
[18:07:32] *** Quits: Fare (~fare@2601:184:4a7f:995c:fff9:8c2c:df1f:5a31) (Ping timeout: 245 seconds)
[18:24:37] <jcowan> If you see a John Cowan or a johnwcowan, it's probably me.
[18:26:58] *** Joins: Fare (~fare@2601:184:4a7f:995c:fb65:4153:7bec:2ddd)
[18:28:24] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Read error: Connection reset by peer)
[18:29:15] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[19:11:43] *** Quits: Alfr (~Alfr@user/alfr) (Quit: Leaving)
[19:22:52] *** Joins: srhm (~srhm@user/srhm)
[19:23:11] *** Joins: IPmonger (~IPmonger@c-69-242-83-226.hsd1.pa.comcast.net)
[19:23:17] *** Quits: srhm (~srhm@user/srhm) (Read error: Connection reset by peer)
[19:23:25] *** Quits: IPmonger (~IPmonger@c-69-242-83-226.hsd1.pa.comcast.net) (Remote host closed the connection)
[19:23:44] *** Joins: srhm (~srhm@user/srhm)
[19:25:04] *** Joins: Alfr (~Alfr@user/alfr)
[19:34:37] <jmercouris> well, that's the thing, Julia has nothing to do with Lisp
[19:34:40] <jmercouris> they keep claiming it does
[19:34:44] <jmercouris> but it really doesn't
[19:34:55] <jmercouris> you could make the argument that it has something to do with /A/ Lisp
[19:34:59] <jmercouris> but that's not really the same thing
[19:41:04] <mfiano> Who is "they"? How can _you_ claim that, with its borrowing of many Common Lisp specific features?
[19:42:19] *** Joins: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431)
[19:48:46] *** Quits: Alfr (~Alfr@user/alfr) (Remote host closed the connection)
[19:49:16] *** Joins: Alfr (~Alfr@user/alfr)
[19:50:29] <markasoftware_> Do java and c# compile their bytecodes to native at runtime?
[19:50:44] <markasoftware_> And if so is that a relatively recent development?
[19:52:20] <mfiano> Yes, and no
[19:52:36] *** Quits: amk (~amk@109.255.169.126) (Remote host closed the connection)
[19:53:47] *** Joins: amk (~amk@109.255.169.126)
[19:56:15] *** Joins: aug0stus (~user@modemcable116.102-20-96.mc.videotron.ca)
[19:56:19] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Ping timeout: 252 seconds)
[19:56:59] *** Joins: Guest93 (~Guest93@modemcable116.102-20-96.mc.videotron.ca)
[19:57:06] *** Joins: amb007 (~a_bakic@241.13.23.93.rev.sfr.net)
[19:58:24] *** Quits: Guest93 (~Guest93@modemcable116.102-20-96.mc.videotron.ca) (Client Quit)
[20:01:16] *** Quits: amb007 (~a_bakic@241.13.23.93.rev.sfr.net) (Read error: Connection reset by peer)
[20:02:21] *** Joins: amb007 (~a_bakic@241.13.23.93.rev.sfr.net)
[20:05:07] *** Quits: amb007 (~a_bakic@241.13.23.93.rev.sfr.net) (Read error: Connection reset by peer)
[20:05:27] <jcowan> markasoftware_: csc compiles all code it enters in a just-in-time fashion, whereas javac does that only with hot code, using a bytecode interpreter for cold code.
[20:05:46] <mfiano> jmercouris: It's obviously not _a_ Lisp, but it has more in common with (Common) Lisp than most modern languages. Even its dynamic type system is a weird hybridization of structural/nominal typing in much of the same way CL is.
[20:05:55] *** Joins: amb007 (~a_bakic@241.13.23.93.rev.sfr.net)
[20:06:34] <mfiano> and layers on top of that have many similarities borrowed from CL. Therefor your comment to me just sounded like a SLW rant except with no basis
[20:08:55] <random-nick> I don't know if it still does that, but .NET used to have a windows service which compiles registered CLR .dll files to native images
[20:09:18] <random-nick> so it's also partially ahead out time
[20:10:25] *** Joins: Guest949 (~Guest94@modemcable116.102-20-96.mc.videotron.ca)
[20:10:45] *** Quits: Guest949 (~Guest94@modemcable116.102-20-96.mc.videotron.ca) (Client Quit)
[20:12:31] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[20:20:02] <jcowan> "slw rant"?  Dr. Google (and UD) not helpful today.
[20:21:34] <mfiano> https://wiki.c2.com/?SmugLispWeenie
[20:21:47] * mfiano ducks AoT
[20:22:51] <lotuseater> this picture :D
[20:24:42] <jcowan> Ah, thanks. I am glad to see that Common Lispers see Schemers under the sign of peace.
[20:24:43] *** Quits: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431) (Quit: Leaving)
[20:24:53] <jcowan> :-)
[20:25:44] <lotuseater> https://trash.randomerror.de/gy5qs/addicts.png
[20:26:32] *** Parts: aug0stus (~user@modemcable116.102-20-96.mc.videotron.ca) (ERC (IRC client for Emacs 27.1))
[20:30:07] *** Joins: dra (~dra@2a04:4540:641e:b500:ece8:867a:9e59:aae8)
[20:30:21] <mfiano> https://matrix-client.matrix.org/_matrix/media/r0/download/jews.rip/KKZVStrdeyhjHvfEApPkdCkA
[20:31:42] <beach> The value of youth is greatly overestimated.
[20:34:46] *** Quits: VincentVega (~user@212.241.24.161) (Ping timeout: 265 seconds)
[20:36:15] <beach> mfiano: That's a very disturbing URL.
[20:36:28] <mfiano> But, for the record, I am not a Julia user. It is a decent language if I ever needed a non-Lisp for data science. It surely is a better choice than Python, R, or MATLAB in this regard, but I am not a data scientist. I use pragmatic in that I use the language that gets the task done. It's just coincidental that that has always been CL :)
[20:36:48] <mfiano> s/use/am/
[20:38:27] <mfiano> I suppose it is. I didn't see that.
[20:38:33] <mfiano> Apologies
[20:46:59] *** Joins: asarch (~asarch@2806:10ae:7:9cc2:f73e:28a0:4ca2:6e57)
[20:48:53] *** Joins: john-a-carroll (~john-a-ca@host-92-28-178-6.as13285.net)
[21:00:49] *** Quits: john-a-carroll (~john-a-ca@host-92-28-178-6.as13285.net) (Quit: Ping timeout (120 seconds))
[21:02:10] *** Quits: asarch (~asarch@2806:10ae:7:9cc2:f73e:28a0:4ca2:6e57) (Quit: Leaving)
[21:07:15] <jmercouris> Perhaps I am a SLW :-)
[21:08:47] *** Joins: karlosz (~karlosz@12.196.174.98)
[21:14:49] *** Quits: karlosz (~karlosz@12.196.174.98) (Quit: karlosz)
[21:16:43] *** Quits: aleamb (~aleamb@81.61.187.171.dyn.user.ono.com) (Quit: bye)
[21:18:29] *** Joins: karlosz (~karlosz@12.196.174.98)
[21:27:21] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Remote host closed the connection)
[21:27:40] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[21:29:31] <jmercouris> I must say that page explaining SLWs could be very offensive
[21:33:31] <jcowan> Anything of the from "smug $TOPIC weenie" is inherently offensive, unless reclaimed by the people it describes.
[21:34:38] <jmercouris> I meant the images and descriptions, and the divisive culture it promotes
[21:34:47] <jmercouris> But yes, the premise of it is also offensive
[21:38:03] *** taichi is now known as mariari
[21:39:32] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Quit: WeeChat 3.2)
[21:39:38] <jcowan> I mean, I say things like "Oops, I'm being a smug Lisp weenie here, aren't I."
[21:42:11] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[21:44:55] *** Joins: Oladon (~olad@98.43.81.226)
[21:51:19] <jcowan> PyCall and PyJulia form a pretty good bidirectional bridge, it would seem.  Perhaps "Reach for Julia when CPython is too slow" is better advice than "Reach for C when CPython is too slow".  Also, Julia's interface to C/C++/Fortran doesn't involve writing fugly glue code in C.
[21:53:02] <jcowan> I especially like that you can transparently pass a Julia functions as an argument to a Python function and vice versa, something that is usually treated as Just Too Hard.
[22:05:00] *** Quits: karlosz (~karlosz@12.196.174.98) (Quit: karlosz)
[22:05:37] *** Joins: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431)
[22:06:37] *** Quits: shka (~herr@109.231.62.239) (Ping timeout: 265 seconds)
[22:23:18] *** Joins: nature_ (~nature@mail.blazebone.com)
[22:29:36] *** Joins: asarch (~asarch@2806:10ae:7:9cc2:f73e:28a0:4ca2:6e57)
[22:39:28] *** Joins: vats (~vats@103.70.83.191)
[22:59:36] *** Joins: yitzi (~yitzi@173-27-106-188.client.mchsi.com)
[23:30:25] *** Quits: mariari (~mariari@user/mariari) (Ping timeout: 252 seconds)
[23:31:43] <moon-child> jcowan: 'just too hard'  it's certainly not _hard_ to implement, but you need to somehow manage the lifetime of the closure
[23:32:10] *** Joins: mariari (~mariari@user/mariari)
[23:33:47] *** Quits: Fare (~fare@2601:184:4a7f:995c:fb65:4153:7bec:2ddd) (Ping timeout: 245 seconds)
[23:50:30] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[23:52:12] *** Joins: Fare (~fare@2601:184:4a7f:995c:dd68:9c41:abc:66e5)
