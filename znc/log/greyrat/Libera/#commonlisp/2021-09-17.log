[00:00:12] <Bike> it kind of sounds to me like you want to load the apl file with the system
[00:00:25] <Bike> like as a component of the asd rather than a manual load call
[00:00:25] <CptKirk> yes, but while developing, I need to reload the apl file
[00:00:42] <CptKirk> also, please tell me how I would do it as a component of the asd?
[00:01:02] <pjb> For asdf, you could define a specific class of apl file, with a specific function to compile and load them.
[00:01:10] <Bike> you'd have to define a custom component type. people do it with grovel files and stuff. i haven't done it enough to know the details.
[00:01:21] <CptKirk> oh interesting
[00:01:23] <pjb> check the asdf manual.
[00:01:32] <CptKirk> yes, I'd be happy to load the file once
[00:01:34] <pjb> it's done for example, to compile C libraries.
[00:01:43] <CptKirk> but during development, I need to reload the file as I make changes
[00:01:46] <Bike> if you just want a C-c C-k equivalent I'd look at defining an emacs shortcut
[00:01:57] <Bike> or whatever editor you're using, i guess i don't know if you're using slime
[00:02:00] <pjb> Not only once, but it would reload it when needed because of changes on the file or its dependencies.
[00:02:13] <CptKirk> oh really?
[00:02:27] <CptKirk> if it reloads files on change,that'd be a good approach
[00:02:47] <pjb> And indeed, Defining an C-c C-k (or C-c C-l) in apl-mode hooked to april could be nice.
[00:03:03] <pjb> CptKirk: Yes, asdf = make basically. asd file = makefile.
[00:03:04] <Bike> asdf doesn't have anything like watching for filesystem changes, far as i know. you'd still have to hit the reload command somewhere
[00:03:20] <CptKirk> but it isn't "hooked to april" its "hooked to my lisp code" because that's where april is called
[00:03:27] <pjb> Bike: it still compare file system dates between dependencies.
[00:03:27] <CptKirk> which is the problem
[00:03:35] <pjb> clhs file-write-date
[00:03:35] <specbot> http://www.lispworks.com/reference/HyperSpec/Body/f_file_w.htm
[00:03:45] <CptKirk> not only do I need 3 buffers open, one for apl to edit, 1 for lisp to recompile, and one for slime, its annoying
[00:04:08] <CptKirk> It would be great to just save my apl file and I can call the function in slim
[00:04:10] <CptKirk> slime*
[00:04:43] <CptKirk> which is what I'm trying to do now
[00:04:57] <CptKirk> but unfortunately it only works when I manually compile the form
[00:05:43] <CptKirk> 3 buffer workflow is not a happy place
[00:06:08] <Bike> well, if you make the apl file part of the system, you could just use the asd system reload function and get both the apl and the lisp reloaded.
[00:08:04] <CptKirk> :components ((:module "mod"
[00:08:05] <CptKirk> :components ((:file "bar")
[00:08:05] <CptKirk> (:file"baz")
[00:08:06] <CptKirk> (:file "quux"))
[00:08:06] <CptKirk> :perform (compile-op :after (op c)
[00:08:07] <CptKirk> (do-something c))
[00:08:07] <CptKirk> :explain (compile-op :after (op c)
[00:08:08] <CptKirk> (explain-something c)))
[00:08:09] <CptKirk> is this what you're talking about?
[00:08:59] <Bike> https://common-lisp.net/project/cffi/manual/html_node/Groveller-ASDF-Integration.html here's what it looks like for grovel files
[00:09:24] <Bike> the definitions to make it work are here https://github.com/cffi/cffi/blob/master/grovel/asdf.lisp
[00:10:39] <Bike> phantomics or someone might be interested in doing the work, since it seems like a useful way to use april
[00:13:45] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[00:13:47] *** Joins: tubal_cain (~TubalCain@ipservice-092-208-213-020.092.208.pools.vodafone-ip.de)
[00:14:50] <CptKirk> This would be really cool
[00:15:10] <CptKirk> Then I could specify the files, their workspaces, and have all those names aviailable on load
[00:16:53] <CptKirk> then the solutions would just be like... `(defsol ws.day1)` which would be a macro to call the function day1 in workspace ws using april
[00:17:02] <CptKirk> cool
[00:17:13] <CptKirk> I'll have to experiment with this approach
[00:19:37] *** Joins: mortemeur (~mortemeur@pool-173-76-107-201.bstnma.fios.verizon.net)
[00:19:42] <CptKirk> how does that file get loaded and definitions available before asdf finishes loading?
[00:20:20] <Bike> the grovel/asdf.lisp file? that's what :defsystem-depends-on does
[00:20:31] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[00:20:44] <Bike> it tells asdf to load the cffi-grovel system before even starting to deal with the example-software system definition
[00:21:20] <CptKirk> oh def-system-depends-on is the entry point to define those asdf::grovel-file
[00:21:30] <CptKirk> asdf::cffi-grovel-file
[00:21:44] <Bike> i don't think it's in the asdf package, but yeah, you get the idea
[00:22:09] <CptKirk> (setf (find-class 'asdf::cffi-grovel-file) (find-class 'grovel-file))
[00:22:23] <Bike> why would you do that
[00:22:28] <CptKirk> I didn't, they did :P
[00:22:37] <CptKirk>  :components
[00:22:38] <CptKirk>     ((:file "package")
[00:22:38] <CptKirk>      (:cffi-grovel-file "example-grovelling")
[00:22:39] <CptKirk>      (:cffi-wrapper-file "example-wrappers")
[00:22:39] <CptKirk>      (:file "example")))
[00:22:39] <Bike> oh, well, dang. there you go then
[00:22:41] <CptKirk> so they can define that
[00:22:47] <Bike> i figured it was doing something else for keywords
[00:22:59] *** Quits: tubal_cain (~TubalCain@ipservice-092-208-213-020.092.208.pools.vodafone-ip.de) (Quit: Leaving)
[00:23:00] <CptKirk> it seems like the setf is defining the component type
[00:23:33] <CptKirk> but I don't understand this part
[00:23:34] <CptKirk>    :defsystem-depends-on ("cffi-grovel")
[00:23:57] <CptKirk> there is no file "cffi-grovel"
[00:24:12] <CptKirk> but there is an `(in-package :cffi-grovel)` in `asdf.lisp`
[00:25:29] <Bike> cffi-grovel is an asdf system
[00:25:33] <Bike> https://github.com/cffi/cffi/blob/master/cffi-grovel.asd behold!
[00:25:56] <Bike> :defsystem-depends-on ("cffi-grovel") tells asdf to find and load the system named cffi-grovel
[00:26:22] <Bike> and to emphasize this again: asdf does not know or care about packages
[00:26:43] <Bike> usually packages have about the same names as the system defining them, but that's not required and asdf doesn't care either way
[00:27:21] <CptKirk> oh so this whole extension to asdf thing is an external system
[00:27:26] <CptKirk> damn
[00:27:37] <Bike> depends on whta you mean by "external"
[00:27:40] <CptKirk> I mean
[00:27:41] <Bike> it's still, like, part of cffi
[00:27:45] <CptKirk> I don't know what I mean by anything
[00:27:48] <phantomics> Just read the chat here, getting asdf integration for April is something I'll look into
[00:27:58] <CptKirk> I'm just flailing trying to say stuff to find answers to my brain confusion
[00:28:04] <Bike> that's fine
[00:28:08] <Bike> don't worry be happy
[00:28:34] <CptKirk> I see there are multiple .asd files in the root folder
[00:30:02] *** Joins: nature (~nature@mail.blazebone.com)
[00:32:23] *** Quits: srhm (~srhm@user/srhm) (Quit: Konversation terminated!)
[00:32:47] *** Joins: srhm (~srhm@user/srhm)
[00:36:08] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Quit: Laa shay'a waqi'un moutlaq bale kouloun moumkine)
[00:37:08] *** Joins: Lord_of_Life (~Lord@user/lord-of-life/x-2819915)
[00:37:31] *** Quits: srhm (~srhm@user/srhm) (Read error: Connection reset by peer)
[00:38:12] *** Joins: srhm (~srhm@user/srhm)
[00:38:44] *** Quits: cage (~cage@dynamic-adsl-78-15-41-207.clienti.tiscali.it) (Quit: rcirc on GNU Emacs 27.1)
[00:45:35] *** Joins: molson__ (~molson@2001-48F8-704A-CA1-0-0-75F-1030-static.midco.net)
[00:45:37] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Quit: Laa shay'a waqi'un moutlaq bale kouloun moumkine)
[00:46:37] *** Joins: Lord_of_Life (~Lord@user/lord-of-life/x-2819915)
[00:46:52] *** Quits: mariari (~mariari@user/mariari) (Quit: WeeChat 3.2)
[00:47:51] *** Quits: mortemeur (~mortemeur@pool-173-76-107-201.bstnma.fios.verizon.net) (Read error: Connection reset by peer)
[00:47:58] <CptKirk> @bike it appears that this works because the output of the files in question are lisp source files
[00:48:07] <CptKirk> i don't think the output of april is a lisp source file
[00:48:44] <Bike> isn't it? i thought it was an apl-to-lisp compiler. but even if it isn't, i think you can tell asdf to do arbitrary things to "load" a file
[00:49:04] *** Quits: molson_ (~molson@2001-48F8-704A-CA1-0-0-75F-102A-static.midco.net) (Ping timeout: 268 seconds)
[00:51:58] <Bike> i see asdf itself defines a java-source-file component type, though it doesn't seem to do much
[00:52:07] <CptKirk> it is not a transpiler, it is a compiler
[00:52:16] <CptKirk> the output is a compilation
[00:53:02] <Bike> okay. still don't think it should be a problem.
[00:55:14] *** Joins: mortemeur (~mortemeur@pool-173-76-107-201.bstnma.fios.verizon.net)
[00:57:18] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[01:01:13] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[01:08:04] <phantomics> Bike: April doesn't produce Lisp files, it directly compiles and evals code. Do you know if asdf extensions can be used to do things that compile Lisp code directly rather than producing Lisp code that is fed to asdf?
[01:08:34] <Bike> I am reasonably sure that you can tell asdf to do literally anything in as a "load" action.
[01:08:43] <Bike> (or a "compile" action, or whatever)
[01:08:50] <Bike> strike "in"
[01:09:19] <Bike> so you could for example just have it call this april-load function kirk is using, probably
[01:11:46] <phantomics> Ok, looking into that
[01:11:57] <Bike> https://common-lisp.net/project/asdf/asdf.html#Creating-new-operations i think what you would do is something like (defmethod perform ((op load-op) (component april-file)) ...)
[01:12:04] <Bike> but, again, i have not done this myself
[01:13:54] <phantomics> Thanks, that helps
[01:16:55] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[01:19:04] *** Quits: khrbt (~znc@user/khrbt) (Ping timeout: 268 seconds)
[01:23:43] *** Joins: khrbt (~znc@user/khrbt)
[01:25:52] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[01:28:57] <CptKirk> ok I'm getting super peeved. I just created a blank quickpackage:make-package and it can't compile
[01:29:35] <CptKirk> oh... I needed quickproject
[01:29:56] <CptKirk> `(quickproject:make-project #P"/mnt/c/d/aoc/cl" :name "apl-load" :depends-on '(april))
[01:29:56] <CptKirk> `
[01:30:06] <CptKirk> ok I did use quick project... jesus can't keep these names straight
[01:30:26] <CptKirk> so I made the project, I symlinked to the local-projects folder just as I did before
[01:30:38] <CptKirk> (asdf:load-system "apl-load") and get a compile error
[01:30:45] <CptKirk> I'm lost
[01:30:59] <Bike> well, "compile error" sounds like asdf found the system fine
[01:31:06] <Bike> and there's just a problem in your source file
[01:31:16] <CptKirk> I didn't do anything yet
[01:31:21] <Bike> what's the error?
[01:31:34] <CptKirk> COMPILE-FILE-ERROR while
[01:31:35] <CptKirk> compiling #<CL-SOURCE-FILE "apl-load" "package">
[01:31:35] <CptKirk>    [Condition of type UIOP/LISP-BUILD:COMPILE-FILE-ERROR]
[01:31:44] <Bike> christ, asdf, why are you like this
[01:31:45] <CptKirk> I have literally not even opened the files at this point
[01:32:15] <CptKirk> and that's the same invocation I used when defining "aoc-15" earlier
[01:32:35] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Read error: Connection reset by peer)
[01:32:58] <Bike> okay. what does package.lisp look like?
[01:33:28] *** Joins: Lord_of_Life_ (~Lord@user/lord-of-life/x-2819915)
[01:33:42] <CptKirk> ;;;; package.lisp
[01:33:42] <CptKirk> (defpackage #:apl-load
[01:33:43] <CptKirk>   (:use #:cl))
[01:33:48] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[01:33:59] <CptKirk> I have changed nothing after running quickproj
[01:34:01] <Bike> alright. seems fine. i don't know why asdf decided to choke on that.
[01:34:10] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 252 seconds)
[01:34:41] *** Joins: selwyn (~selwyn@user/selwyn)
[01:34:47] <CptKirk> ;;;; apl-load.asd
[01:34:48] <CptKirk> (asdf:defsystem #:apl-load
[01:34:48] <CptKirk>   :description "Describe apl-load here"
[01:34:49] <CptKirk>   :author "Your Name <your.name@example.com>"
[01:34:49] <CptKirk>   :license  "Specify license here"
[01:34:50] <CptKirk>   :version "0.0.1"
[01:34:50] <CptKirk>   :serial t
[01:34:51] <CptKirk>   :depends-on (#:april)
[01:34:51] <CptKirk>   :components ((:file "package")
[01:34:52] <CptKirk>                (:file "apl-load")))
[01:34:52] <CptKirk> both files are present
[01:35:20] <CptKirk> ;;;; apl-load.lisp
[01:35:21] <CptKirk> (in-package #:apl-load)
[01:35:24] <CptKirk> that's the other files contents
[01:36:14] *** Lord_of_Life_ is now known as Lord_of_Life
[01:36:27] <Bike> Well, I don't know. Did you do (ql:register-local-projects)?
[01:37:05] <CptKirk> COMPILE-FILE-ERROR while
[01:37:05] <CptKirk> compiling #<CL-SOURCE-FILE "apl-load" "package">
[01:37:06] <CptKirk>    [Condition of type UIOP/LISP-BUILD:COMPILE-FILE-ERROR]
[01:37:11] <etimmons> CptKirk: what is your current *package* ?
[01:37:13] <CptKirk> after running it, that's still the error
[01:37:18] *** Quits: mortemeur (~mortemeur@pool-173-76-107-201.bstnma.fios.verizon.net) (Read error: Connection reset by peer)
[01:37:21] <CptKirk> how do I check that?
[01:37:35] <Bike> enter *package* in your repl
[01:37:45] <CptKirk> common-lisp-usear
[01:38:16] <CptKirk> oh goodness... so aoc no longer loads
[01:39:06] <CptKirk> what did I doooo!!?!?! X(
[01:39:31] <etimmons> Hmmm, there goes that idea. But I'm surprised ASDF isn't giving you any other information than what you've copied
[01:39:46] <Bike> asdf sometimes gives stupid errors when compile-file fails.
[01:40:26] *** Quits: selwyn (~selwyn@user/selwyn) (Remote host closed the connection)
[01:40:50] *** Joins: selwyn (~selwyn@user/selwyn)
[01:41:27] <CptKirk> oh ok. I added the defsystem-depends-on
[01:41:39] <CptKirk> and the depends on can't be loaded for no reason
[01:43:13] <CptKirk> and it works
[01:43:17] <CptKirk> *magic*
[01:44:51] *** Quits: yitzi (~yitzi@173-27-106-188.client.mchsi.com) (Quit: Leaving)
[01:46:05] <CptKirk> nice, I got the pattern working for creating a new component and then doing stuff with it
[01:51:45] *** Quits: cuz (~user@38.140.58.234) (Ping timeout: 268 seconds)
[01:57:06] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[02:00:34] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Ping timeout: 252 seconds)
[02:00:42] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[02:01:32] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[02:05:40] *** Quits: gaqwas (~john@dynamic-095-118-105-217.95.118.pool.telefonica.de) (Ping timeout: 252 seconds)
[02:07:33] *** Joins: cuz (~user@38.140.58.234)
[02:07:56] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Read error: Connection reset by peer)
[02:08:07] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[02:09:13] <CptKirk> Error while trying to load definition for system #1=aoc-15 from
[02:09:14] <CptKirk> pathname /mnt/c/d/aoc/cl/aoc-15.asd:
[02:09:14] <CptKirk>    The value
[02:09:15] <CptKirk>      #<ASDF/USER::APRIL-FILE #1# "15.apl">
[02:09:15] <CptKirk>    is not of type
[02:09:16] <CptKirk>      (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING PATHNAME
[02:09:16] <CptKirk>          SYNONYM-STREAM FILE-STREAM)
[02:09:22] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Read error: Connection reset by peer)
[02:09:22] <CptKirk> how am I meant to interpret this error?
[02:09:58] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 252 seconds)
[02:09:59] <CptKirk> what type is #<...?>
[02:10:03] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[02:11:51] *** Joins: waleee (~waleee@h-98-128-228-119.na.cust.bahnhof.se)
[02:12:58] *** Quits: cuz (~user@38.140.58.234) (Ping timeout: 260 seconds)
[02:16:35] <CptKirk> ok, so its an instance of a class
[02:16:45] <CptKirk> so how do I get the value from #1#?
[02:17:34] *** Joins: akoana (~ah@user/akoana)
[02:17:35] <phantomics> It would be an asdf class method
[02:17:44] <phantomics> You have an april-file object type?
[02:18:02] <CptKirk> yes
[02:18:11] <CptKirk> it inherits from cl-source-file
[02:18:23] <CptKirk> i'm looking for members/methods for that, but i really don't know what I'm doing
[02:19:16] <CptKirk> https://common-lisp.net/project/cl-mathstats/documentation/asdf-package/generic-efunction-perform.html
[02:19:27] <CptKirk> like I found some, but I don't see any user docs
[02:23:10] *** Quits: fengshaun (~fengshaun@S010680615f0c2c0a.cg.shawcable.net) (Quit: bibi!)
[02:25:21] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Remote host closed the connection)
[02:25:34] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[02:25:42] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[02:27:29] *** Quits: Spawns_Carpeting (~pi@user/spawns-carpeting/x-6969421) (Quit: ZNC 1.7.2+deb3 - https://znc.in)
[02:28:22] *** Joins: Spawns_Carpeting (~pi@user/spawns-carpeting/x-6969421)
[02:29:02] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Read error: Connection reset by peer)
[02:29:15] *** Joins: mortemeur (~mortemeur@pool-173-76-107-201.bstnma.fios.verizon.net)
[02:29:34] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[02:31:03] *** Quits: frgo (~frgo@p200300deef0cee00a1d722b9ebc8d8ab.dip0.t-ipconnect.de) (Remote host closed the connection)
[02:31:17] <Bike> CptKirk: #1=aoc-15 ... #1# means that the #1# is also aoc-15. like #<ASDF/USER::APRIL-FILE aoc-15 "15.apl">
[02:31:31] *** Joins: frgo (~frgo@p200300deef0cee005d8a5b6e8d5a763f.dip0.t-ipconnect.de)
[02:31:33] <CptKirk> oh
[02:32:24] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[02:32:27] <Bike> what this error means is that asdf expects something to be either a string, a pathname, or a file stream, but you gave it an april-file object instead
[02:33:28] <CptKirk> so (slot-value file 'name) doesn't work
[02:33:34] <CptKirk> because its a user level symbol
[02:33:44] <CptKirk> how do I refer to the... is it 'file:name?
[02:33:48] <Bike> what?
[02:34:02] <Bike> i have no idea what you're trying to do here. what is the "file"?
[02:34:13] <CptKirk> bleh
[02:34:31] <CptKirk> (defmethod component-pathname ((f april-file))
[02:34:31] <CptKirk>   (progn (print (slot-value f 'file:name))
[02:34:32] <CptKirk>          (call-next-method)))
[02:34:51] <Bike> okay, so april-file is your class, right? just use the reader you defined.
[02:34:52] <CptKirk> https://common-lisp.net/project/cl-mathstats/documentation/asdf-package/class-source--file.html
[02:35:01] <CptKirk> I didn't define a reader?
[02:35:05] <CptKirk> I'm inheriting from a class
[02:35:11] <CptKirk> (defclass april-file (cl-source-file)
[02:35:12] <CptKirk>   ())
[02:35:24] <Bike> okay. so look at this page here. See how, next to name, it says "Accessors: component-name"
[02:35:30] <CptKirk> oh
[02:35:32] <Bike> that means that component-name is a function you can use to get the name
[02:36:00] <Bike> it's more usual to use access functions like that than to use slot-value
[02:36:26] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Read error: Connection reset by peer)
[02:36:57] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[02:37:04] <CptKirk> (defmethod component-pathname ((f april-file))
[02:37:04] <CptKirk>   (progn (print (component-name 'name))
[02:37:05] <CptKirk>          (call-next-method)))
[02:37:06] <CptKirk> ?
[02:39:17] <CptKirk> ah this worked
[02:39:19] <CptKirk> (defmethod component-pathname ((f april-file))
[02:39:19] <CptKirk>   (progn (print (component-name f))
[02:39:20] <CptKirk>          (call-next-method)))
[02:41:26] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Ping timeout: 260 seconds)
[02:41:40] *** Joins: amb007 (~a_bakic@254.13.23.93.rev.sfr.net)
[02:43:27] *** Quits: shka (~herr@109.231.62.239) (Ping timeout: 265 seconds)
[02:43:28] *** Quits: amb007 (~a_bakic@254.13.23.93.rev.sfr.net) (Read error: Connection reset by peer)
[02:45:26] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[02:47:08] <CptKirk> I don't know how you're supposed to just know HOW to use something from someone giving you a picture of it
[02:57:21] *** Quits: Spawns_Carpeting (~pi@user/spawns-carpeting/x-6969421) (Quit: ZNC 1.7.2+deb3 - https://znc.in)
[02:59:51] *** Joins: Spawns_Carpeting (~pi@user/spawns-carpeting/x-6969421)
[03:00:40] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[03:06:29] *** Joins: dra (~dra@2a04:4540:6404:1900:3904:4775:d71b:22ab)
[03:16:44] *** Joins: mariari (~mariari@user/mariari)
[03:20:48] *** Quits: copec (~copec@schrodbox.unaen.org) (Remote host closed the connection)
[03:21:09] *** Joins: copec (~copec@schrodbox.unaen.org)
[03:23:05] *** Quits: Xach (~xach@66-63-89-62.static.suscom-maine.net) (Ping timeout: 265 seconds)
[03:23:12] *** Joins: Xach (~xach@66-63-89-62.static.suscom-maine.net)
[03:25:18] *** Quits: rgherdt (~rgherdt@2a02:8109:86c0:d8d:2cb3:8945:1c5c:6ee2) (Ping timeout: 260 seconds)
[03:25:30] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[03:26:56] *** Quits: mortemeur (~mortemeur@pool-173-76-107-201.bstnma.fios.verizon.net) (Ping timeout: 268 seconds)
[03:30:25] *** Quits: taiju (~taiju@240b:253:ec40:2400:a8af:540:19a2:818b) (Ping timeout: 268 seconds)
[03:32:37] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[03:38:06] *** Joins: dra_ (~dra@2a04:4540:6421:6000:3904:4775:d71b:22ab)
[03:40:42] *** Quits: dra (~dra@2a04:4540:6404:1900:3904:4775:d71b:22ab) (Ping timeout: 260 seconds)
[03:46:13] *** Quits: dra_ (~dra@2a04:4540:6421:6000:3904:4775:d71b:22ab) (Remote host closed the connection)
[03:52:18] *** Joins: taiju (~taiju@240b:253:ec40:2400:a8af:540:19a2:818b)
[03:53:27] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[03:57:47] *** Quits: Lycurgus (~juan@98.4.112.204) (Quit: Exeunt)
[04:02:02] *** Joins: keir (~keir@user/keir)
[04:03:49] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Ping timeout: 252 seconds)
[04:03:53] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[04:06:36] *** Quits: ec_ (~ec@gateway/tor-sasl/ec) (Client Quit)
[04:15:55] *** Quits: VincentV` (~user@212.241.25.220) (Remote host closed the connection)
[04:24:12] *** Joins: beach` (~user@2a01:cb19:150:3400:893d:92a4:273f:ff45)
[04:28:07] *** Quits: beach (~user@2a01:cb19:150:3400:c055:f9b1:7312:8b56) (Ping timeout: 252 seconds)
[04:30:10] *** Quits: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431) (Remote host closed the connection)
[04:30:29] *** Joins: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431)
[04:32:02] *** Quits: taiju (~taiju@240b:253:ec40:2400:a8af:540:19a2:818b) (Ping timeout: 260 seconds)
[04:40:46] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[04:42:19] *** Quits: attila_lendvai (~alendvai@C22674C1.nat.pool.telekom.hu) (Ping timeout: 252 seconds)
[04:42:58] *** Parts: pranavats (3fba1d1b34@jabberfr.org) ()
[04:48:31] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[04:52:31] *** Quits: srhm (~srhm@user/srhm) (Read error: Connection reset by peer)
[04:52:56] *** Joins: srhm (~srhm@user/srhm)
[05:02:48] *** Joins: pillton (~user@2405:b000:703:2::34:248)
[05:13:29] *** Quits: keir (~keir@user/keir) (Quit: ZNC - https://znc.in)
[05:15:09] *** Joins: keir (~keir@user/keir)
[05:22:49] *** Quits: keir (~keir@user/keir) (Quit: ZNC - https://znc.in)
[05:23:08] *** Joins: keir (~keir@user/keir)
[05:31:31] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.2)
[05:33:08] *** Quits: random-nick (~random-ni@87.116.176.198) (Ping timeout: 268 seconds)
[05:37:26] *** Joins: cyberbanjo (~malik@2607:fb90:4221:b3ee:ce77:6396:f4f3:bcc)
[05:38:38] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[05:39:36] *** Quits: cyberbanjo (~malik@2607:fb90:4221:b3ee:ce77:6396:f4f3:bcc) (Client Quit)
[05:45:37] <raeda> Is github.com/symbolics on here? I'm doing some statistics work and think Lisp-Stat would be a great way to consolidate existing stats code, but registering a new company with the name Symbolics and requiring a contributor license agreement are worrying signs
[05:52:06] <White_Flame> wat
[05:53:42] <hayley> IIRC using the GitHub name Symbolics doesn't really mean you are founding Symbolics 2 (for that see ##symbolics2)
[05:54:57] <raeda> They've registered Symbolics PTE LTD in Singapore
[05:55:05] <hayley> Okay, that's weird.
[05:55:28] <hayley> But I'd wager the name is generic enough that you might get away with it.
[05:56:32] <moon-child> they also opened a PR to some random github project purporting to make it work on genera
[05:58:09] <raeda> I'm sure there aren't any legal problems, it's just weird to see someone setup an account / company with a well known name and then require that open source contributors sign an agreement
[05:58:25] <White_Flame> and it's MSPL, which is a bit weird
[05:58:34] <raeda> You know, instead of just licensing the project under MIT / BSD / GPL and being done with it
[05:58:58] *** Joins: karlosz (~karlosz@12.196.174.98)
[06:01:11] <raeda> I'll try emailing the address in the asd file
[06:11:14] *** Joins: kakuhen (~kakuhen@user/kakuhen)
[06:30:54] *** Joins: Oladon (~olad@98.43.81.226)
[06:35:10] *** Quits: nature (~nature@mail.blazebone.com) (Read error: Connection reset by peer)
[06:37:09] *** Joins: nature (~nature@mail.blazebone.com)
[06:39:49] *** Parts: pranavats (3fba1d1b34@jabberfr.org) ()
[06:41:45] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[06:44:54] *** Joins: CptKirk49 (~CptKirk@97-118-72-33.hlrn.qwest.net)
[06:55:02] <CptKirk> @loke are you here?
[06:56:32] <loke[m]> Hello CptKirk
[06:56:40] <CptKirk> ohi
[06:56:56] <CptKirk> I pinged you in aplfarm, since it isn't cl related
[06:57:08] <loke[m]> Yeah, I saw it :-)
[07:04:01] *** Quits: CptKirk49 (~CptKirk@97-118-72-33.hlrn.qwest.net) (Quit: Client closed)
[07:09:31] *** Joins: lad (~lad@user/lad)
[07:10:31] *** Quits: karlosz (~karlosz@12.196.174.98) (Quit: karlosz)
[07:14:22] *** Joins: char (~charles@cpe-76-186-124-165.tx.res.rr.com)
[07:24:57] *** beach` is now known as beach
[07:25:06] *** ChanServ sets mode: +o beach
[07:28:29] *** beach sets mode: -o beach
[07:31:25] <beach> Good morning everyone!
[07:31:54] <CptKirk> hello
[07:32:29] *** Quits: nature (~nature@mail.blazebone.com) (Ping timeout: 265 seconds)
[07:35:21] <CptKirk> in a macro, how do I define a name which is defined in the macro, but available to users of the macro?
[07:35:34] <CptKirk> and if that's bad, how would I do that in another way?
[07:35:52] <CptKirk> like, pass an unbound symbol to be used to define something I need the value of
[07:36:51] <CptKirk> (defmacro my-mac (thing1 thing2 &rest body) `(let ((',@#":available-name ,@body)) ...)
[07:36:53] <beach> You can introduce any symbol in a macro and it can be used by the caller of the macro.  But it is best to avoid that and instead have the caller put a symbol in there, as in WITH-OPEN-FILE for instance.
[07:37:17] <CptKirk> so maybe...
[07:37:30] <beach> `(let ((thing ...)) ,@body) and THING is available in the body.
[07:38:11] <CptKirk> (defmacro m (arg1 artg2 symbol-do-use) `(let ((,symbol-to-use ,@body)) ...))
[07:38:12] <beach> Anaphoric macros use this technique to bind IT around the body, for instance.
[07:38:25] <beach> Yes, that's the better way.
[07:38:35] <CptKirk> ok, body isn't really body, but parser of input
[07:38:40] <CptKirk> the actual body is defined
[07:38:43] <CptKirk> so I might call it parser
[07:38:55] <beach> No difference.
[07:39:23] *** Joins: karlosz (~karlosz@12.196.174.98)
[07:39:45] <CptKirk> hmm, this doesn't work
[07:40:38] <CptKirk> https://pastebin.com/raw/UAn4ZegB
[07:41:04] <CptKirk> maybe a nested let is in order?
[07:41:12] <Bike> what didn't work?
[07:41:15] <CptKirk> input is unbound
[07:41:34] <CptKirk> oh
[07:41:42] <CptKirk> becuase (first input) is trying to evaluate now
[07:41:44] <CptKirk> not later
[07:41:47] <CptKirk> that's no good
[07:42:16] <Bike> this is unrelated, but i wanted to ask before: why (eval '(april:april-load #p"./15.apl")) instead of just (april:april-load #p"./15.apl")
[07:42:28] <CptKirk> because that's a compiler macro
[07:43:01] <CptKirk> and during development to save double the amount of effort, it is evaluated every time I call into the expression rather than only once at the beginning
[07:43:11] <Bike> huh. odd macro
[07:43:22] <CptKirk> i'm talking with phantomics about it
[07:43:35] <CptKirk> but how do I avoid (first input) from being evaluated inline?
[07:43:55] <Bike> I don't know what you mean by evaluated inline
[07:44:06] <Bike> What you should generally do with macros is compare how they expand to what you want
[07:44:18] <Bike> do (macroexpand-1 '(defsolution 1 input (first input))) and see what looks wrong
[07:45:12] <CptKirk> it isn't expanded at all
[07:45:17] <CptKirk> it returns the expression
[07:45:17] <Bike> What?
[07:45:24] <CptKirk> (macroexpand-1 '(defsolution 1 input (first input)))
[07:45:24] <CptKirk> (DEFSOLUTION 1 INPUT (FIRST INPUT))
[07:46:01] <Bike> `probably you're in the wrong package or something then
[07:46:08] <CptKirk> no I'm in the right package
[07:46:11] <Bike> (whatever-your-package-is::defsolution ...P)
[07:46:14] <Bike> well then the macro isn't defined
[07:46:21] <Bike> what's (macro-function 'defsolution)?
[07:46:24] <CptKirk> no I'm not :C
[07:49:16] <CptKirk> ok, now the format is not returning its evaluation
[07:49:25] <Bike> is there a macro function or not?
[07:49:28] <CptKirk> I thouthg (format nil "fmtstr" args) returns it?
[07:49:36] <Bike> yes, format nil returns the string.
[07:49:40] <CptKirk> yes I am in the correct package now
[07:49:49] <Bike> So what does (defsolution ...) expand to?
[07:51:08] <CptKirk> got it
[07:51:20] <CptKirk> (macroexpand-1 '(defsolution 1 input (first input)))
[07:51:21] <CptKirk> (LET* ((APL (EVAL '(APRIL-LOAD #P"./15.apl")))
[07:51:21] <CptKirk>        (INPUT (INPUT-FOR-DAY 2015 1))
[07:51:22] <CptKirk>        (INP (FIRST INPUT)))
[07:51:22] <CptKirk>   (APRIL-C "day1" INP))
[07:51:23] <CptKirk> T
[07:51:27] <CptKirk> I had a missing paren after the let
[07:51:37] <CptKirk> not the let... the definitions
[07:51:48] <Bike> well, if you got it working that's good.
[07:52:00] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[07:52:05] *** Joins: hendursa1 (~weechat@user/hendursaga)
[07:56:25] *** Quits: waleee (~waleee@h-98-128-228-119.na.cust.bahnhof.se) (Ping timeout: 252 seconds)
[07:59:02] *** Quits: karlosz (~karlosz@12.196.174.98) (Quit: karlosz)
[08:02:04] *** ChanServ sets mode: -o Bike
[08:06:28] <CptKirk> follow up question
[08:06:49] <CptKirk> https://pastebin.com/raw/DsEFPegC
[08:07:06] <CptKirk> how do I phrase this (if (null parser) sym ,@parser)
[08:07:18] <CptKirk> so that if there is no parser passed in, then I just assign input to ,sym
[08:07:30] <CptKirk> or
[08:07:36] <CptKirk> wait I should do that above the `(...)
[08:07:39] <Bike> so you want the "parser" to be a series of forms?
[08:07:44] <Bike> not just one form?
[08:07:54] *** Joins: karlosz (~karlosz@12.196.174.98)
[08:08:46] <CptKirk> it can be a series of forms
[08:09:12] <CptKirk> but basically `inp` is the input to the april-c function
[08:09:20] <CptKirk> s/function/macro/
[08:09:55] <Bike> well, for a start you probably want (progn ,@parser), then, because IF doesn't take an indefinitely long sequence of forms
[08:10:05] <CptKirk> https://pastebin.com/raw/vrZc759a
[08:10:17] <CptKirk> oh I see
[08:10:32] <Bike> this code won't work because, other than the progn thing, you splice the value
[08:10:36] <Bike> so if the value is a symbol that won't work
[08:10:44] *** Parts: akoana (~ah@user/akoana) ()
[08:11:00] <CptKirk> no it won't be
[08:11:00] <Bike> you can have (if (null parser) sym `(progn ,@parser)), and then (inp ,value)
[08:11:11] <CptKirk> ah
[08:11:14] <Bike> VALUE will be a symbol if PARSER is nil, no?
[08:11:47] <CptKirk> yes that did the trick
[08:11:58] <CptKirk> no if parser is nil, use the value of the symbol
[08:12:07] <CptKirk> so in the previous line
[08:12:10] <CptKirk> (,sym (something))
[08:12:17] <CptKirk> so ,sym will be some value
[08:12:47] <Bike> In the macroexpander you bind the VALUE variable to (if (null parser) sym parser). So if parser is nil, obviously VALUE will be SYM.
[08:12:52] <Bike> SYM is a symbol.
[08:12:57] <Bike> Later, you have (inp ,@value).
[08:13:03] <Bike> so you try to splice in a symbol.
[08:13:04] <CptKirk> yes, I'm saying what you recommended worked
[08:13:09] <CptKirk> (defmacro defsolution (day sym &rest parser)
[08:13:09] <CptKirk>   (let ((value (if (null parser)
[08:13:10] <CptKirk>                    sym
[08:13:10] <CptKirk>                    `(progn ,@parser))))
[08:13:11] <CptKirk>     `(let* ((apl (eval '(april:april-load #P"./15.apl")))
[08:13:11] <CptKirk>             (,sym (input-for-day 2015 ,day))
[08:13:12] <CptKirk>             (inp ,value))
[08:13:12] <CptKirk>        (april-c ,(format nil "day~d" day)
[08:13:13] <CptKirk>                 inp))))
[08:13:16] <Bike> right. i just want to be clear about the problem
[08:13:23] <CptKirk> so sym is a symbol
[08:13:26] <CptKirk> this lets me do
[08:13:38] <CptKirk> (defsolution 1 input (aref input 0))
[08:13:44] <CptKirk> and (defsolution 2 input)
[08:13:48] <CptKirk> because day 2 needs no parsing
[08:13:56] <beach> CptKirk: Please use a paste service for more than a line or so of code.
[08:13:58] <Bike> please do multiline pastes in pastebin or something, by the way. i know it's going a bit out of your way, but it clogs up the irc
[08:14:11] <CptKirk> sorry :C
[08:14:18] <Bike> also, you seem new to the language, so #clschool might be good
[08:15:07] <beach> Yes, I don't think this is the right way to learn a language, but then, learning Common Lisp may not be a goal for CptKirk.
[08:15:53] <Bike> eh, going through apl is kind of wacky, but they're doing alright
[08:15:54] <CptKirk> what do you think is not the right way to learn a language?
[08:16:16] <beach> Starting with the use of a nontrivial library like April.
[08:16:19] <CptKirk> I should clarify, my first exposure to common lisp was 5 years ago now. I've been through a laundry list of books
[08:16:33] *** Quits: semz (~none@user/semz) (Ping timeout: 268 seconds)
[08:16:46] <CptKirk> But all of my time with Common Lisp has been toy problems all done in the repl, using only basic list structures
[08:17:27] <beach> The standard language has a lot more than lists to offer though.
[08:17:30] <CptKirk> I'm not claiming expertise or experience, but I wouldn't say I'm starting from the beginning
[08:17:38] <beach> OK.
[08:17:53] <CptKirk> @beach I know there are a lot of features, but I never did bother with asdf, or importing libraries until this week :/
[08:17:56] <CptKirk> haven't really had the need
[08:19:19] <Bike> i don't mean to sound like an elitist, but repl exercises don't really compare to actually writing programs. I mean, I could probably take a few minutes and write matrix multiplication or something in APL, but i'd hardly say I know it
[08:19:37] <Bike> (well, actually i bet apl has that built in, whatever)
[08:20:05] <CptKirk> my use case can maybe elucidate further. I'm professional applicaiton developer in C#/python/angular/react/node with loads of backend tools etc. I was a full time APLer for 2 years, and now host a discord for all array languages. The issue for me is that all the existing FOSS array languages are limited in their library vocabulary, and seeing the
[08:20:05] <CptKirk> relative maturity of april and the library list of Common Lisp, I'm thinking it would be good to have CL as the driver that talks to the outside world, ffi, libraries, rest, sockets, etc, and APL can do all the pretty logical stuff
[08:20:30] <Bike> sounds neat.
[08:21:01] <CptKirk> which is a very similar pattern to the unix design pattern, using lisp to orchestrate c libraries
[08:21:06] <CptKirk> at least... in theory
[08:21:10] <CptKirk> and I aim to test that theory
[08:21:43] <CptKirk> I don't think you sound elitist, I really am a novice
[08:21:47] <beach> That does sound good.
[08:22:42] <CptKirk> from where I'm sitting, I'm not going to learn much more about modern CL reading the classic books. I've learned academic CL, but I have never had an application to build with it, so its all been relatively novice level activities
[08:22:54] <CptKirk> And I have always had a soft-spot for LISP and its dialects
[08:23:10] <CptKirk> So this is the perfect moment for me to really dig in and jump in the deep end
[08:23:22] <beach> Excellent!
[08:23:55] <CptKirk> so thanks to everyone for their patience and helpfulness :)
[08:24:05] <CptKirk> I've learned a lot these past few days
[08:26:13] <Bike> yeah, books are useful but only get you so far
[08:26:30] <CptKirk> I've actually done some more than once
[08:26:36] <CptKirk> land-o-lisp was so fun I did it twice
[08:26:45] <CptKirk> er... 3 times actually :P
[08:27:35] <beach> It may be fun, but it is badly written and I don't recommend it.
[08:27:56] <beach> The author uses incorrect and inconsistent terms.
[08:28:23] <beach> I really should start my page about Common Lisp book reviews, but I am too busy with other stuff at the moment.
[08:28:58] *** Joins: semz (~none@user/semz)
[08:33:27] <CptKirk> I did notice the poor writing the more time I spent with it
[08:33:33] <CptKirk> and the terms
[08:33:48] <CptKirk> PAIP is much more profesionally written, though the density took me a while to get throught it
[08:34:34] <beach> Yes, Norvig is a good author.
[08:34:42] <beach> s/author/writer/
[08:34:50] <dualinverter[m]> I started with Land of Lisp because I had a copy of it lying around; it was a fun read until actual lisp learning started. After a couple of chapters, I found it disorienting.
[08:34:50] <dualinverter[m]> I am now reading "Practical Common Lisp"; so far it has been wonderful.
[08:34:50] <dualinverter[m]>  
[08:35:40] <beach> Yes, Seibel writes well too.
[08:37:38] *** Quits: brettgilio (~brettgili@x-node.gq) (Quit: Ping timeout (120 seconds))
[08:37:58] *** Joins: brettgilio (~brettgili@x-node.gq)
[08:40:01] *** Quits: Bike (~Glossina@71.69.170.70) (Quit: Lost terminal)
[08:46:55] <loke[m]> Didn't he mention the possibility of a new edition of PCL?
[08:47:58] <hayley> I think so.
[08:48:55] <beach> That would be good.
[08:49:41] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[09:12:33] *** Quits: karlosz (~karlosz@12.196.174.98) (Quit: karlosz)
[09:22:23] <dieggsy> is there some kind of compilation reader macro shorthand in the style of #+ for if a symbol is unbound
[09:22:26] <dieggsy> ...by chance lol
[09:22:47] <dieggsy> i can just (when (not (fboundp ..) ...)
[09:24:49] *** Quits: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431) (Quit: Leaving)
[09:27:05] *** Joins: rain3 (~rain3___@2a02:2f09:d100:8700:1ae4:6be9:2a58:7de6)
[09:28:37] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[09:30:33] *** Joins: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net)
[09:32:00] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 268 seconds)
[09:33:51] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 268 seconds)
[09:49:32] <lisp123> I liked CLtL2e a lot, suprised it doesn't get more love from newbies
[09:49:56] *** Joins: gaqwas (~john@dynamic-095-117-036-184.95.117.pool.telefonica.de)
[09:50:00] <lisp123> I guess its a bit lengthier read, whereas PCL does good summaries for each section
[09:51:31] *** Quits: doyougnu (~user@c-73-25-202-122.hsd1.or.comcast.net) (Ping timeout: 268 seconds)
[09:52:04] <beach> Also, it was written before the standard was voted, so it differs in some places.
[09:53:16] <beach> I think what we need is a Common Lisp reference, probably in the form of a web site.  I think this could be done by starting with the dpANS and adding more material.
[09:56:57] <moon-child> clhs?
[09:58:03] <lisp123> beach: have you seen this? https://mr.gy/ansi-common-lisp/
[09:58:05] <beach> No, that's not good enough.  It is a document primarily meant for creators of Common Lisp implementations.
[09:58:25] <beach> moon-child: ^
[09:58:28] *** Joins: Nilby (~Nilby@2601:603:1481:30a0:b585:ec2f:e2e3:d9e7)
[09:58:30] <lisp123> HTML version of the draft
[09:59:06] <beach> Yes, I saw that.  We also have the fantastic work by scymtym to parse the dpANS into various formats.
[09:59:22] <moon-child> eh, I have no intention of creating a common lisp implementation, and I have always found it adequate.  It could perhaps be made more approachable in some respects, but not majorly so
[09:59:24] <moon-child> imo
[09:59:58] <lisp123> Nice, I will check out his/her work
[10:00:03] <beach> moon-child: OK, example: Read the page on AREF and tell me what happens if you give it an object that is not an array.
[10:01:46] <beach> moon-child: You need to know that the information is to be found in...
[10:01:50] <beach> clhs 1.4.4.3
[10:01:51] <specbot> The ``Arguments and Values'' Section of a Dictionary Entry: http://www.lispworks.com/reference/HyperSpec/Body/01_ddc.htm
[10:02:27] <beach> moon-child: Most newbies, and many experienced Common Lisp programmers don't know that.  For example, jmercouris was convinced that an error would be signaled.
[10:02:40] *** Quits: Nilby (~Nilby@2601:603:1481:30a0:b585:ec2f:e2e3:d9e7) (Ping timeout: 240 seconds)
[10:03:32] *** Joins: Nilby (~Nilby@c-67-160-81-88.hsd1.wa.comcast.net)
[10:08:43] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Remote host closed the connection)
[10:08:58] *** Joins: taiju (~taiju@240b:253:ec40:2400:a8af:540:19a2:818b)
[10:10:03] *** Quits: defaultxr (~defaultxr@99-138-110-241.lightspeed.cicril.sbcglobal.net) (Ping timeout: 265 seconds)
[10:15:47] *** Joins: defaultxr (~defaultxr@99-138-110-241.lightspeed.cicril.sbcglobal.net)
[10:39:41] <lisp123> I just noticed that Elisp passes parameters by value
[10:39:58] <lisp123> Is there a reason that CL passes by reference? Is that for optimisation reasons?
[10:41:37] <lisp123> (excluding small integers and other potential items that are passed by value)
[10:46:16] *** Joins: jmhimara (~jmhimara@2600:6c54:7c00:21ac:94e1:8411:6cf2:514c)
[10:46:40] <moon-child> lisp123: what do you mean by that?
[10:47:29] <moon-child> as far as I know, there is no semantic difference between the way parameters are passed in elisp and cl.  This snippet has the same behaviour in both, for instance https://0x0.st/-3ZM.txt
[10:48:51] <moon-child> https://0x0.st/-3Zu.txt  as does this
[10:49:01] *** Joins: pve (~pve@37-136-88-109.rev.dnainternet.fi)
[10:49:54] *** Quits: pve (~pve@37-136-88-109.rev.dnainternet.fi) (Client Quit)
[10:49:58] *** Quits: jmhimara (~jmhimara@2600:6c54:7c00:21ac:94e1:8411:6cf2:514c) (Client Quit)
[10:51:26] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Ping timeout: 260 seconds)
[10:52:30] *** Joins: amb007 (~a_bakic@210.38.22.93.rev.sfr.net)
[10:52:44] <lisp123> moon-child: hmm thanks, that seems to be working
[10:52:45] <moon-child> lisp123: http://metamodular.com/common-lisp-semantics.html
[10:54:34] <lisp123> I have some buffer-local-variables in elisp, I think that's what is throwing it up
[10:54:41] <lisp123> Will investigate
[10:54:48] <lisp123> Thats a useful link - thanks!
[10:58:00] *** Joins: pve (~pve@37-136-88-109.rev.dnainternet.fi)
[11:03:48] *** Joins: shka (~herr@109.231.62.239)
[11:08:25] *** Joins: rgherdt (~rgherdt@ip5f5af456.dynamic.kabel-deutschland.de)
[11:18:48] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[11:19:44] *** Joins: lisp123 (~lisp123@5.30.23.247)
[11:24:29] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[11:24:41] *** Quits: santiagopim (~user@84.78.249.190) (Remote host closed the connection)
[11:25:35] <phantomics> Hey moon-child, I figured out what was wrong with {⍵{2÷⍨⍵+⍺÷⍵}⍣≡⍵}12345678 in April
[11:25:44] <phantomics> It needs to be {⍵{2.0÷⍨⍵+⍺÷⍵}⍣≡⍵}12345678
[11:26:42] <phantomics> Because the 2 is handled as a rational number, the numerator and denominator get huge and the comparison tolerance doesn't work. A consequence of supporting ratios in April
[11:27:41] <moon-child> ah!
[11:27:59] *** Quits: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Ping timeout: 256 seconds)
[11:28:51] <pjb> emacs lisp passes parameters exactly like any other lisp, by value ! Always. CL passes parameters by value too.
[11:28:53] <moon-child> in raku, rational numbers will get automatically promoted to floats once the numerator/denominator exceed some threshold, unless you explicitly request otherwise.  Such behaviour might be worth considering
[11:28:59] <pjb> (for the innocent bystanders)
[11:30:10] <beach> pjb: Exactly.
[11:30:20] <moon-child> (perhaps the threshold might be when the denominator exceeds ÷⎕ct.  That way rational comparisons can always be exact, with no semantic drawbacks)
[11:31:32] <moon-child> (rather than 'with no semantic drawbacks', I should say 'in a semantically consistent manner'.  Except that that is not right...)
[11:31:41] <beach> moon-child: Also, the "Examples" section of many Common Lisp HyperSpec dictionary entries contains non-conforming code.  For a creator of a Common Lisp implementation, it is known that these sections are not normative, but it is embarrassing that newbies are given such examples.
[11:32:26] <beach> [referring to the Common Lisp HyperSpec as a reference document]
[11:35:11] <moon-child> beach: fair enough.  What you point out about type mismatches I think is the sort of minor augmentation I mentioned would be helpful but not essential.  In that it still describes correct usage of the function.  But the non-conforming examples are more egregious (and identifying them is far harder to automate!)
[11:35:19] *** Quits: gaqwas (~john@dynamic-095-117-036-184.95.117.pool.telefonica.de) (Ping timeout: 252 seconds)
[11:35:21] <moon-child> I encountered one just the other day
[11:37:07] <beach> Sure, nothing is essential, but I think we can do much better than the Common Lisp HyperSpec in a reference document.  For the AREF case, I could see the phrase "If an argument of a type other than an array is given, then the consequences are undefined" explicitly inserted.
[11:37:31] <beach> And when there is a phrase such as "an error should be signaled", at least making that phrase a link to the meaning of the phrase would be useful.
[11:38:21] *** Joins: lisp123 (~lisp123@5.30.23.247)
[11:39:08] <beach> lisp123: If you read the link you were give, you will see that Common Lisp, just like most modern languages (Haskell excluded) use call by value.
[11:39:17] <beach> *given
[11:39:40] <moon-child> why haskell excluded?
[11:39:40] *** Quits: amb007 (~a_bakic@210.38.22.93.rev.sfr.net) (Read error: Connection reset by peer)
[11:39:45] *** Joins: karlosz (~karlosz@12.196.174.98)
[11:39:51] *** Joins: amb007 (~a_bakic@210.38.22.93.rev.sfr.net)
[11:40:18] <lisp123> beach: the tricky part is this "So, although values are copied before passed to the function, what is copied here is a reference."
[11:40:20] <beach> Because it does not use call by value, and instead "lazy evaluation".
[11:40:37] <beach> lisp123: But that has nothing to do with the phrase "call by value".
[11:40:38] <moon-child> right
[11:40:40] <hayley> I guess lazy evaluation is considered "call by name".
[11:41:02] <beach> hayley: As I recall, it's not quite the same.
[11:41:23] <beach> lisp123: Call by value just means that arguments are evaluated before a function is called.  Nothing else.  It says nothing about the nature of those arguments.
[11:41:23] *** Quits: amb007 (~a_bakic@210.38.22.93.rev.sfr.net) (Read error: Connection reset by peer)
[11:41:32] *** Joins: OlCe (~user@lfbn-nic-1-565-28.w90-118.abo.wanadoo.fr)
[11:41:41] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[11:42:09] <moon-child> wiki says 'if [a parameter] is used several times, it is re-evaluated each time it appears'
[11:42:13] <beach> I am sorry if the C++ people attempt to change established terminology, and I won't grant them that pleasure.
[11:42:13] <Nilby> The CL spec examples reinforce my belief in thinking for yourself and being skeptical of authority.
[11:42:39] <lisp123> beach: Yes that part is clear. Its more around 'parameters passed by value'
[11:42:53] <moon-child> (regarding call-by-name)
[11:43:06] <hayley> Well, given that evaluation of Haskell code is more or less deterministic, I think avoiding re-evaluation would be an optimization.
[11:43:09] <beach> lisp123: Again, "pass by value" = "call by value" means that they are evaluated before passed.  Nothing else.
[11:43:13] <lisp123> As I understand, the value passed is a copy of the reference? Is that correct?
[11:44:20] <beach> lisp123: In all modern languages, when call-by-value is used, a copy of the value is passed, no matter the nature of that value.  In certain languages, like C++ and Pascal, and Algol, you can change that by &name, var name, etc.
[11:45:42] <beach> lisp123: In early implementations of Fortran, this was not the case, so you could say f(1) and f could be defined with parameter x and then x = 2 in the body, and then subsequently, references to 1 would be 2.
[11:45:50] <beach> That's not a good idea if you ask me.
[11:46:42] <lisp123> beach: Thanks for the explanation
[11:46:55] *** Quits: scymtym (~user@ip-94-114-248-79.unity-media.net) (Ping timeout: 252 seconds)
[11:47:06] <lisp123> That link also is very helpful, with a bit more time I should be able to internalise the concepts
[11:47:08] <beach> Sure.  It's all in the page of that link.
[11:49:12] <moon-child> hayley: no, because if you never evaluate an effectful form, the effect will not happen.  For instance, this snippet prints nothing http://ix.io/3z7s
[11:49:21] <moon-child> AIUI
[11:50:24] <beach> hayley: Call by name, as I recall, is so weird that it was never implemented even in Algol.
[11:50:44] <hayley> Evaluating an effectful form in Haskell does not cause effects; the effect only occurs if it appears in the value bound to main in Haskell.
[11:51:48] <beach> I believe what Haskell does is called "call by need".
[11:52:00] <hayley> Right, yes.
[11:57:56] *** Quits: pillton (~user@2405:b000:703:2::34:248) (Quit: ERC (IRC client for Emacs 27.2))
[12:02:53] <phantomics> moon-child: automatic float promotion may be worth considering
[12:04:13] *** Joins: Duuqnd (~Duuqnd@185.201.174.78)
[12:06:11] *** Joins: attila_lendvai (~alendvai@217.65.124.57)
[12:25:23] *** Quits: notzmv (~zmv@user/notzmv) (Read error: Connection reset by peer)
[12:25:33] *** Joins: selwyn (~selwyn@user/selwyn)
[12:29:02] <beach> I often want to say something like "there is no experiment the application programmer can conduct in order to determine whether some objects are not really references to memory, and are instead encoded in the pointer itself", but...
[12:29:18] <beach> Then I think about EQ, so I haven't said that.  However,
[12:29:55] <beach> Now that I think about it, an implementation can decide to "intern" certain numbers, and so the EQ experiment won't work.
[12:31:40] <beach> pjb: So we can be really nasty to people who try to exploit EQ-ness by having all integers and characters be real references, but we intern, say only odd numbers, and lower-case letters.
[12:31:50] <beach> pjb: In BOCL I mean.
[12:32:16] <OlCe> Hi beach. You are touching on the reason of EQL's existence versus EQ I guess.
[12:32:46] <Duuqnd> What's BOCL?
[12:33:39] <beach> OlCe: Indeed.  But it is mostly the fact that, whenever I use the term "uniform reference semantics", some people like to point out that the implementation could be optimized in some ways, so that not all objects are references.
[12:34:13] <beach> Duuqnd: BOotstrap Common Lisp.  A project to create a conforming Common Lisp implementation meant only for bootstrapping others.
[12:34:35] <beach> Duuqnd: It would be the only Common Lisp implementation optimized for maintainability rather than performance.
[12:35:28] <Duuqnd> I see. I've found two different repos, one is yours and the other is on gitlab. Which one are you referring to (I'd assume it's yours)?
[12:35:47] <beach> Duuqnd: To me, it is partly an argument against writing Common Lisp implementations in some language other than Common Lisp, for various reasons.  Though I know perfectly well that jackdaniel prefer for ECL to be bootstrapped from C for other reasons.
[12:35:55] *** Joins: hendursaga (~weechat@user/hendursaga)
[12:36:28] <beach> Duuqnd: It is complicated.  I started mine, and then pjb started his own, and worked faster for some time, so I gave up.  But then pjb got a full-time job...
[12:36:44] <beach> So I guess both are stalled right now.
[12:37:51] <beach> It is an amusing project to think about, in that it is really hard to avoid thinking in terms of performance.
[12:38:16] <Duuqnd> Writing a CL implementation in C sounds pretty painful
[12:38:33] <beach> Well, some things would still be Common Lisp, like the full reader.
[12:38:52] <OlCe> beach: Sounds amusing, indeed.
[12:39:04] <beach> The purpose is that it can be built using C only.
[12:39:18] *** Quits: hendursa1 (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[12:39:26] <beach> OlCe: Exactly.  Feel free to contribute. :)
[12:39:50] *** Quits: saturn2 (~visitant@user/clone-of-saturn/x-1551297) (Ping timeout: 260 seconds)
[12:39:52] <OlCe> beach: Ha ha. I would love to, but I have no time...
[12:40:02] <beach> Welcome to the club.
[12:40:34] <Duuqnd> That's (a Lisp in C only) certainly useful to have. Is there a reason why ECL doesn't cut it (I'm not very familiar with ECL)?
[12:41:15] <beach> No, no reason.  ECL is fine.  But it is less maintainable than it could be, simply because performance is taken into account.
[12:41:18] <OlCe> Duuqnd: Was going to ask more or less the same question.
[12:41:23] <hayley> ECL is designed to run relatively fast, and not just as a bootstrapping tool.
[12:41:50] <OlCe> So BOCL is indeed written in CL itself (I had guessed, but now I'm sure).
[12:42:02] <beach> No, in C for the "core".
[12:42:03] <hayley> BOCL is written in C.
[12:42:09] <OlCe> Ha no, I misread.
[12:42:11] <OlCe> Yes.
[12:42:20] <beach> It can't be written in CL, because of the bootstrapping argument.
[12:42:30] <jackdaniel> ecl features two runtimes: one is inside a bytecode vm (and its a very trivial target without many optimizations) and one is compiled to C and then to native
[12:42:35] <OlCe> Mmm... It could be written in CL, and then compiled to C with ECL, no? :-p
[12:42:59] <OlCe> jackdaniel: Interesting.
[12:43:04] <beach> OlCe: No, because of the FSF definition of "source code".
[12:43:26] <jackdaniel> but then you defeat the purpose of having it as a bootstrapping tool - if you depend on ecl to bootstrap then you may stop at ecl right away
[12:43:31] <jackdaniel> OlCe: ^
[12:44:06] <OlCe> jackdaniel: Not necessarily. You can compile an old version once and for all, and use that as bootstrap for newer versions, which are themselves bootstrap for whatever other compiler.
[12:44:21] <OlCe> But yes, this becomes complicated.
[12:44:48] <jackdaniel> the point is to have it bootstrappable from C, not from the previous version of the same implementation
[12:44:56] <beach> OlCe: The use case is what I said.  Some Unix distributions want every program to be possible to build using only C.
[12:44:59] <jackdaniel> fwiw ccl and cmucl depend on the "previous" version of the same implementation
[12:45:09] <jackdaniel> and sbcl depends on /any conforming/ common lisp implementation
[12:45:48] <Nilby> I could just slow down ECL for you? I think it's unlikely, given various examples from history, for a full CL in C to be practically any more maintainable than say ECL.
[12:45:58] <jackdaniel> my personal opinion is that the problem is already solved having both clisp and ecl, but the argument of better maintainability of bocl as the prime goal is a sound one regardless
[12:46:26] <OlCe> You are bootstrappable from C if starting with some fixed version (of say, BOCL) pre-compiled to C. You just distribute this C code as the first bootstrap.
[12:46:34] <beach> Nilby: You have no idea what kind of tricks we have planned. :)
[12:46:34] <jackdaniel> i.e ecl could be stripped from: networking, threading, native compiler, dlopen and various other extensions
[12:46:39] <jackdaniel> and that would improve the maintainability
[12:46:57] <OlCe> jackdaniel: Yes.
[12:47:31] <Nilby> beach: Tricks sound less maintaible than more. e.g. CLisp's wacky macro preprocssing.
[12:47:57] <beach> Nilby: Sure, you don't have to take my word for it.
[12:48:02] <jackdaniel> at the cost of performance, features and general usability. so that would be the primary difference between them: bocl would be only for boostrapping (because it would be rather useless in practice due to lack of common extensions); while ecl is meant to be used as the environment to write applications in
[12:49:54] <Nilby> beach: I think you write more maintaible code than most, but code has a way of developing it's own inertial momentum.
[12:50:01] <beach> Nilby: Imagine, for instance, every object being heap allocated, with a separate "header", so that CLASS-OF can be the same operation no matter what object type it is.
[12:50:20] <OlCe> Then, if you not only want a C bootstrap but also that such codeis easy to understand, pre-compiling to C might not be the best option.
[12:50:35] <OlCe> I've never looked at ECL-produced code up to now personally.
[12:50:46] <jackdaniel> ecl produces fairly readable code
[12:51:02] <beach> OlCe: Again, it also does not qualify as "source code" so can not be used in those Unix distributions.
[12:51:40] <OlCe> beach: I hear you. But what's the problem exactly? Licenses?
[12:51:59] <jackdaniel> OlCe: it is a computer-generated code, so it is not the source, only an intermediate form
[12:52:13] <beach> No.  "source code" is defined to be the "preferred version for modification by maintainers".
[12:52:14] <jackdaniel> and intermediate code is prone to trustuing-trust issues
[12:52:25] <OlCe> jackdaniel: Sure. And?
[12:52:46] <OlCe> jackdaniel: Ok. Does ECL restrict the produced code in any way?
[12:52:57] <jackdaniel> and since it is not a source code, then it is not considered a source code?
[12:52:58] <OlCe> beach: I understand that.
[12:53:06] <jackdaniel> restrict how?
[12:53:10] <Duuqnd> Yeah, "restrict" seems a bit vague here
[12:53:25] <OlCe> Restrict the use, distribution, or whatever else you can do with the code.
[12:53:41] <Duuqnd> I don't think a compiler can legally do that to its output
[12:53:51] <jackdaniel> no it doesn't, but the produced code depends on the ecl runtime
[12:53:54] *** Quits: dtman34 (~dtman34@c-73-62-246-247.hsd1.mn.comcast.net) (Ping timeout: 265 seconds)
[12:54:03] <jackdaniel> hence it requires ecl present that is a subject of its licensed
[12:54:36] <OlCe> Duuqnd: I think you could do that legally, but that's another problem (and discussion).
[12:54:39] <jackdaniel> Duuqnd: of course it could, but foss licenses does not imply such restriction (result of running the program is not the subject of its license)
[12:55:15] <OlCe> jackdaniel: Yes, this is what I had in mind. ECL runtime can be linked-in statically, but it can dynamically as well I think?
[12:55:26] <jackdaniel> yes
[12:55:36] <OlCe> jackdaniel: In the second case, there is no restriction on the produced code I guess.
[12:55:42] <Duuqnd> I was under the impression that a compiler's author couldn't claim any copyright on the code the compiler generates
[12:55:51] <jackdaniel> fasl files are in case of the c compiler in fact .so objects (with extra sauce)
[12:57:08] <jackdaniel> bytecodes compiler is a different story
[12:57:45] <OlCe> beach: I'm very much interested in bootstrapping techniques, especially from C, but I'm not very sensitive to the "source code" argument.
[12:57:57] <OlCe> beach: Can we know which distributions you are talking about?
[12:58:10] *** Quits: taiju (~taiju@240b:253:ec40:2400:a8af:540:19a2:818b) (Ping timeout: 240 seconds)
[12:58:32] <jackdaniel> the point is that many people are sensitive to it. I believe that debian requires all software to be boostrappable from C (even indirectly, like C -> ECL -> SBCL)
[12:59:24] <jackdaniel> as of why C has such prominent position as "granted" - perhaps it had its merit 20y ago
[12:59:27] <OlCe> jackdaniel: But again, this is the case in all proposals above. What is not the case is bootstrap from true "source code", as mentioned by beach.
[12:59:47] *** Quits: karlosz (~karlosz@12.196.174.98) (Quit: karlosz)
[13:00:08] <OlCe> jackdaniel: I couldn't agree more on C.
[13:00:21] <jackdaniel> I don't think that they would accept a C source code that is transpiled from something else (in a form that is not meant for maintanace)
[13:01:24] <jackdaniel> like the publisher would not accept a book translation being a result of putting the original in google translate
[13:02:47] <OlCe> jackdaniel: Especially since the C standard says "undefined behavior" in so many not-that-obvious cases, and most compilers viciously take advantage to optimize code away. And when you start doing nonsense, then it's best to optimize to the point where there is no more program at all.
[13:02:50] <jackdaniel> beach mentioned that there is a foss definition of the source code, so that would be the criteria for inclusion
[13:03:29] <OlCe> jackdaniel: I'm not in their heads, so I don't know for sure what they actually want behind this kind of restrictions, but
[13:04:05] <jackdaniel> as of undefined behavior there are various strategies to take advantage of it - and that depends on the compiler and on the platform
[13:04:41] <jackdaniel> i.e casting the function pointer to the data pointer makes perfect sense in a system where both are in the same address space, while it should result in an error otherwise
[13:04:44] <OlCe> jackdaniel: IMPOV, you want bootstrapping for reproduceability and security
[13:05:32] <OlCe> jackdaniel: and for this code transpiled once and for all is as good as it gets.
[13:05:53] <OlCe> jackdaniel: You don't have to update it to new versions of BOCL or others. You just bootstrap the new versions on top of it.
[13:06:19] <jackdaniel> well I can tell that your mind is set on certain ideas, so I'll leave the discussion at that
[13:06:20] <OlCe> jackdaniel: If it has flaws, you correct them by hand in C (if readable). In case of a big problem, you transpile again, but this should be fairly rare.
[13:08:02] <OlCe> jackdaniel: I'm exposing my assumptions and needs, in order to clarify where they differ from what you (and beach) are stating, nothing more. I'm not necessarily "set" as you say. And I perfectly understand and appreciate what you are saying. There is no contradiction.
[13:08:44] <jackdaniel> I'm not saying that you're not appreciating it. I'm saying that we've exchanged views and there is nothing to add ,)
[13:09:57] <OlCe> Ok, then. I just find the reasons behind, e.g., Debian's requirements unclear.
[13:10:04] <OlCe> I'll try to find answers elsewhere.
[13:11:14] <jackdaniel> OlCe: I'd start here https://en.wikipedia.org/wiki/Source_code and check the [5] annotation regarding fsf definition
[13:16:45] <OlCe> jackdaniel: Entirely expectable from the FSF. This binds several distributions that absolutely want to abide by this definition and obtain or keep the FSF clearance. It's a problem I personally don't have.
[13:17:08] <OlCe> But I guess it's the problem beach is having.
[13:17:55] *** Joins: taiju (~taiju@240b:253:ec40:2400:a8af:540:19a2:818b)
[13:18:47] <OlCe> And this has not much to do with reproduceability, nor security (directly at least). It's a matter of ideology for those groups.
[13:19:16] * jackdaniel shrugs
[13:19:28] <jackdaniel> this gets offtopic
[13:19:53] *** Joins: dtman34 (~dtman34@c-73-62-246-247.hsd1.mn.comcast.net)
[13:22:17] <pjb> beach: it's even worse, since nothing says that implementation defined behavior cannot change over time.
[13:22:24] <pjb> (as long as it's documented).
[13:22:30] <pjb> but randomness can be documented!
[13:23:12] <jackdaniel> #+random (random 5) #-random 42
[13:23:32] <hayley> I disagree that it is "a matter of ideology", given the damn point is to have usable source code.
[13:24:03] *** Quits: lisp123 (~lisp123@5.30.23.247) (Read error: Connection reset by peer)
[13:24:19] *** Joins: fengshaun (~fengshaun@S010680615f0c2c0a.cg.shawcable.net)
[13:24:27] *** Quits: fengshaun (~fengshaun@S010680615f0c2c0a.cg.shawcable.net) (Remote host closed the connection)
[13:24:49] *** Joins: lisp123 (~lisp123@5.30.23.247)
[13:25:23] <hayley> Having a solid definition of useful source code is how we don't consider, say, all front-end code to be "free or open source software", or even anything distributed in machine code form only.
[13:26:30] <jackdaniel> if someone disagrees with the fsf point it is easy to look at it as ideology;; there is nothing wrong with that - opposite stance "I don't care" is also an ideology;; associating negative meaning with the word "ideology" is just a matter of sophistry
[13:26:40] <pjb> Duuqnd: writing C code is "painful" for anything.  Only with time, C programmers become masochistic enough to bear it.  Now when you're both a lisper and a C programmer, of course, you don't write the painful C code: you generated it with some lisp code! :-)
[13:27:42] <hayley> Perhaps I am still eating out of the trash can of ideology, by considering having access to useful source code to a good idea.
[13:28:04] <OlCe> hayley: That's why I asked about readability of ECL-produced C code.
[13:28:24] <OlCe> hayley: C code can be produced mechanically and still be useful.
[13:28:33] <jackdaniel> well, I'm sold to fsf ideology too, it is very practical
[13:28:42] <OlCe> hayley: That's why I'm talking about ideology.
[13:29:01] <OlCe> hayley: But surely there are other concerns and forces yes.
[13:29:05] <pjb> Let's say the difference between bocl and clisp, is that bocl aim to use standard C without using C implementation defined behavior or extensions, so that it can be compiled and run on all platform with a standard C compiler.
[13:29:06] <jackdaniel> OlCe: code may be readable, but it is also more verbose and harder to change by hand
[13:29:07] <hayley> OlCe: My non-normative opinion is that the C code produced is reasonable. But I would prefer to modify the Lisp code that it was generated from.
[13:29:17] <jackdaniel> i.e you can't read it but you can't easily write it correctly by hand
[13:29:31] <OlCe> hayley: I don't dispute that. On the contrary, I agree with you.
[13:29:32] <jackdaniel> s/can't read it/can read it/
[13:29:40] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 240 seconds)
[13:29:58] <OlCe> hayley: But I'm very much separating the matter of modifying source code and the matter of bootstrapping.
[13:30:03] <hayley> I think my prior example of "all front-end code" is more illuminating though, particuarly with compressed JavaScript code.
[13:30:13] <OlCe> hayley: Indeed.
[13:30:22] <jackdaniel> if it is the lisp code that you develop (say bocl) with, then this lisp code is the source code
[13:30:28] <hayley> While I get some source code, it is not useful for much one would want to use source code for.
[13:30:32] *** Joins: fengshaun (~fengshaun@S010680615f0c2c0a.cg.shawcable.net)
[13:32:28] <hayley> OlCe: Okay then. But remember one approach for bootstrapping is to start with a pre-compiled Lisp image, and we have to determine why starting with C source code is better.
[13:33:28] <OlCe> hayley: Sure. I don't think bootstrapping with C is better in general. But in environments where only a C compiler is available, it's tremendously useful...
[13:33:34] <hayley> Oops, I said source code. "we have to determine why starting with mechanically generated C code is better."
[13:33:53] <OlCe> hayley: Same reason. ;-)
[13:34:33] <OlCe> And, true, as jackdaniel says, ECL may already fit the bill quite well.
[13:36:16] <hayley> Yes, I agree. So I guess the proposal for a bootstrapping Common Lisp is not too practical from this point of view. But it would be easier for the implementors to write the simplest code in C and then never touch it again.
[13:37:03] <OlCe> hayley: And for security matters, I prefer to be able to access as much source code as I want, a property I have with a C bootstrap (and open-source libc and compilers). I have absolutely no guarantee on this, nor practical and reliable means to verify it with a pre-compiled Lisp image.
[13:37:30] <OlCe> hayley: Yes. C reduced to a minimum.
[13:43:25] <beach> OlCe: I am personally not at all interested in bootstrapping Common Lisp from C.  But BOCL to me is an argument against most "Debian" type arguments, since it would suffice for a pure Common Lisp implementation of Common Lisp (like SICL) to include BOCL in the distribution in order to qualify.
[13:44:28] <beach> Plus, BOCL is, like I said, a very rewarding mental exercise.
[13:44:37] <OlCe> beach: Ok, I see.
[13:44:41] <OlCe> beach: Surely. ;-)
[13:46:12] <beach> And we had problems using SBCL for SICL bootstrapping in the past, because of decisions made in the name of SBCL performance.  BOCL would not have any such restrictions due to performance compromises.
[13:46:56] <beach> We have not tried any other host Common Lisp implementation for bootstrapping SICL, but it would not surprise me the least if we ran into restrictions of this type in other Common Lisp implementations too.
[13:48:56] <OlCe> beach: Without taking too much of your time, out of curiosity, may I ask for types or examples of such restrictions? If you have pointers to web pages or papers instead, that's more than welcome as well.
[13:50:12] <beach> Well, first we created too many FUNCALLABLE-STANDARD-OBJECTs, because those used to all be allocated in something called "immobile space" (I think) and the size of that space was not increased by any arguments to the system.
[13:51:02] <beach> Then, we generated too big host functions, exposing some super-linear behavior of the SBCL compiler, so what now takes less than a minute used to take the better part of an hour.
[13:51:35] *** Joins: scymtym (~user@2001:638:504:20e6:6ac3:87e0:e782:f3fc)
[13:51:44] <beach> stassats kindly fixed the first problem.
[13:52:05] <beach> But we had to reorganize SICL bootstrapping to solve the second one.
[13:53:18] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[13:53:19] <beach> OlCe: Does that give you an idea of the problems?
[13:55:38] <OlCe> beach: Yes, thanks.
[14:00:38] <OlCe> beach: The super-linear problem was an algorithmic mistake or oversight, or the consequence of a problem intrinsically hard to solve?
[14:01:15] <jackdaniel> OlCe: some clever compiler tricks have some upper limit before they give up
[14:01:18] <OlCe> beach: Because in the second case, you would have the same problem with BOCL compiling SICL. Anyway, now that you've fixed it in SICL, it doesn't matter much.
[14:01:28] <jackdaniel> taking inlining - you can't inline mutually-referring functions ad infinitum
[14:01:36] <jackdaniel> so there is the inlining depth parameter for the compiler
[14:01:48] <jackdaniel> s/for/in/
[14:02:49] <jackdaniel> same may go for other characteristics - the compiler may give up on analyzing too long function (because i.e compilation time grows exponentially with the function length)
[14:03:59] *** Joins: lisp123 (~lisp123@5.30.23.247)
[14:04:05] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[14:04:17] *** Joins: lisp123 (~lisp123@5.30.23.247)
[14:04:29] *** Quits: kakuhen (~kakuhen@user/kakuhen) (Quit: Leaving...)
[14:06:41] <beach> OlCe: It is not uncommon for optimizing compilers to have some quadratic algorithms, by necessity.
[14:07:11] <beach> And I can very well imagine the maintainers of some Common Lisp implementation being unwilling to fix such issues, citing the unusual use case.
[14:07:21] <OlCe> Yes, it's true when you're trying to optimize. A problem you won't have with BOCL.
[14:07:24] <OlCe> Yes.
[14:09:05] <beach> So I fear a situation where one day I add some feature to SICL, start the bootstrapping procedure, and I will run into some arbitrary restriction that can't easily be fixed.
[14:10:08] <beach> So, yes, I think those are restrictions that were introduced for reasons of performance.  Which won't be a problem with BOCL.
[14:11:56] <OlCe> Mmm, yes. But some are more or less unavoidable. Plus, I assume you also expect SICL to compile SICL (same or other version), which may trigger quadratic (or worse) behavior as well, don't you? The host functions' size seems to be a problem that had to be fixed in SICL anyway.
[14:12:24] <OlCe> But at least you'll be in full control of the whole chain.
[14:12:30] <beach> Exactly.
[14:13:49] <jackdaniel> some compiler optimizations may be necessary to make a certain code compilable - i.e for deeply recursive functions a tail recursion may be necessary
[14:14:17] <jackdaniel> so either bocl will need to have certain optimizations or you may need to avoid certain constructs in the compiled code
[14:14:28] <OlCe> jackdaniel: Also true yes.
[14:14:31] <jackdaniel> (that said I'm aware that you can't expect tail recursion in CL:)
[14:15:24] <OlCe> Most of the time, I consider deep recursion to be a bad idea, and I make the effort to rewrite the code into non-recursive form.
[14:15:29] <beach> Yes, if I write SICL to expect tail-call optimization, that's bad.
[14:15:59] <OlCe> jackdaniel: ;-)
[14:16:52] <beach> Also, I think BOCL would be an amusing community project.  Most people here seem to know some C.
[14:17:11] <jackdaniel> well, this is just one example; another would be a function length - I remember we've hit a certain issue with C compilers when using ECL to compile magicl
[14:17:14] <jackdaniel> if the file is too long then gcc/clang goes belly up
[14:17:18] <beach> It would be easy to add some C code for a yet-unimplemented Common Lisp feature.
[14:18:02] <beach> jackdaniel: Right, C compilers have such issues as well.
[14:18:09] <OlCe> jackdaniel: In practice, don't all reasonably alive CL implementations implement tail-recursion?
[14:18:10] <jackdaniel> the answer was to split the function into number of smaller functions spread in files
[14:18:16] <jackdaniel> if I remember correctly
[14:18:40] <jackdaniel> OlCe: tail recursion is not always desired - i.e it makes debugging harder; so that would depend on the optimization settings
[14:19:03] <Nilby> The old lispers didn't have this problem. They had already first written a slow lisp, in a crap language.
[14:19:13] <jackdaniel> ecl native code depends on the underlying c compiler (but it makes a certain effort to make the tail recursion possible for the c compiler)
[14:19:42] <jackdaniel> I don't know about abcl 
[14:19:59] <beach> OlCe: Maybe not.  If you have a Common Lisp implementation that is compatible with the C calling convention, tail-call optimization is very hard.
[14:22:26] <jackdaniel> there is a certain trick called cheney on the mta: https://plover.com/~mjd/misc/hbaker-archive/CheneyMTA.html it utilises a certain trick to make it work (but it requires certain decisions to be incorporated in the implementation)
[14:22:42] <hayley> Nilby: Then they have the problem of having only a slow Lisp, and recovering from headaches induced by writing in crap languages.
[14:22:58] <beach> jackdaniel: Indeed.
[14:24:57] <jackdaniel> uh oh, I've used the word "certain" three times and "trick" twice:)
[14:25:08] <Nilby> hayley: Indeed. But I think they already recoverd by when CL came about.
[14:25:38] <jackdaniel> gimp devs started with common lisp but deemed it slow and bloated
[14:25:42] <Nilby> The evolution of Dylan is also intersting. The people a with lot of resources wrote the proprietary Dylan in CL. Then the free community wrote a slow one first in C, than transpiling to C.
[14:26:18] <Nilby> Then finally the CL Dylan was re-written in Dylan.
[14:26:37] <beach> jackdaniel: Oh, wow!  I had no idea.  What a mistake.
[14:27:09] <jackdaniel> hm, since the program they wrote in cl was way too slow I guess that switching the language was the right choice
[14:27:29] <jackdaniel> it might be because they had no good implementation at hand or hardware was too slow or that they were poor cl programmers
[14:27:37] <beach> Yeah.
[14:27:58] <jackdaniel> regardless which that was, the pivot seems to be a correct choice
[14:29:06] <jackdaniel> beach: first hand testimony: https://docs.gimp.org/2.10/en/gimp-introduction-history.html
[14:30:06] *** Quits: frgo (~frgo@p200300deef0cee005d8a5b6e8d5a763f.dip0.t-ipconnect.de) (Remote host closed the connection)
[14:30:32] <hayley> "Something that did not rely on nested lists to represent a bitmap." Excuse me what the fuck
[14:30:33] *** Joins: frgo (~frgo@p200300deef0cee005d8a5b6e8d5a763f.dip0.t-ipconnect.de)
[14:30:37] <OlCe> jackdaniel: Interesting.
[14:30:47] <OlCe> hayley: Exactly.
[14:31:29] <jackdaniel> mind that they were students on whom lisp was forced on :) still core dump at 17mb in cl is a bad taste, a sensible restart sounds better ,)
[14:31:44] <jackdaniel> also that might be an exaggeration after being frustrated with cl, they could actually have used arrays
[14:31:49] <Nilby> somehow the scheme in gimp doesn't make me so happy
[14:32:07] <jackdaniel> well, it is just a "scripting plug"
[14:32:19] <hayley> An array would be, say, four times as small at least.
[14:32:51] <jackdaniel> otoh extending the array (i.e resizing the image) could be a copying operation
[14:33:10] *** Quits: attila_lendvai (~alendvai@217.65.124.57) (Read error: Connection reset by peer)
[14:33:20] <hayley> I heard that Photoshop uses some kind of persistent data structure, funnily enough.
[14:33:45] <OlCe> jackdaniel: Yes, but you would have the same problem in C, which could as well be solved in CL.
[14:33:47] *** Joins: attila_lendvai (~alendvai@217.65.124.57)
[14:34:31] <jackdaniel> I'm not going to take a bait and discuss whether C or CL was more practical on machines with 32MB ram ;) I'll be back later
[14:35:09] <hayley> Using nested lists to represent a bitmap in C would be equally dumb.
[14:35:22] <jackdaniel> (and noticeably harder, mind that)
[14:35:41] <OlCe> :-)
[14:36:55] <Nilby> I can say from experience a Lisp GUI running on 32MB on CMU lisp was so slow it could barely trace my mouse.
[14:38:41] <beach> jackdaniel: I see.  Though "Common Lisp" does not dump core.  Some implementations might, of course.
[14:39:04] <beach> hayley: Yeah, it looks like incompetence was a factor.
[14:40:09] <rain3> yeah. but it's easier to say "it's because of lisp"
[14:40:19] <beach> Indeed.
[14:41:15] <jackdaniel> beach: sure; but it is very likely that what they had was an ancient hardware  (compared to today) and imlementation that was inferior if you compare results of writing the same program in C and CL (performance-wise) on said hardware
[14:41:31] <jackdaniel> ditto Nilby testimony
[14:41:33] <Nilby> Sadly, I can still get any lisp on unix to dump core. Recently I made sbcl wedge the kernel.
[14:41:58] <lisp123> Why do people choose to use scheme as their scripting language for their applications? Is it because it is "smaller" than CL? Is it worth having a subset of "CL" for quick use
[14:42:10] <beach> Fair enough.
[14:42:42] <jackdaniel> lisp123: people with the same idea as yours standardized the programming language interlisp
[14:43:22] <beach> What ideas are they?
[14:43:28] <jackdaniel> notably the interlisp project (supposedly) drained the project eulisp from competent developers (and eulisp was more interesting than internlisp)
[14:43:36] <hayley> lisp123: Well, there was a Usenet thread called "Ousterhout loses the plot" or something, where it is more or less argued that CL was deemed doubleplusungood due to 1. having long names and 2. having implementation authors who thought they could write fast implementations.
[14:43:55] <jackdaniel> beach: that having a subset of common lisp is a good thing for slower hardware
[14:44:02] <beach> Ah, OK.
[14:44:55] <jackdaniel> whew, not interlisp
[14:45:08] <jackdaniel> the other name (/me tries to remember)
[14:45:19] <lisp123> hayley: Oh I see
[14:45:21] <Nilby> eulisp?
[14:45:23] <beach> Islisp?  PSL?
[14:45:29] <beach> NIL
[14:45:40] <jackdaniel> islisp, yes
[14:45:44] <jackdaniel> beach: thanks
[14:45:46] <beach> Sure.
[14:46:01] <jackdaniel> none of what I've said above applies to interlisp of course
[14:46:03] <hayley> lisp123: This one: https://groups.google.com/g/comp.lang.functional/c/xLNt2BU34SA/m/IiAMlVFT22gJ
[14:46:48] <lisp123> hayley: Thanks!
[14:47:24] <beach> lisp123: What is interesting, though, is that they choose a static language for the core application, citing performance.  Then they include a scripting language in the form of an interpreter.  Then people start writing code using the scripting language, because they can't do it in the static language.  Then the combination is much slower than if they had chosen a dynamic language for both.
[14:47:26] <lisp123> I might sound out of line, but that John Ousterhout fellow doesn't sound too smart..
[14:48:07] <beach> Oh, I think he is smart.  But he wasn't very knowledgeable in the past, like when he wrote TCL.
[14:48:27] <lisp123> beach: lol - based on how they wrote the starting notes to the GIMP history, it seems logical they went down that route
[14:48:39] <beach> Yes.
[14:49:00] <beach> lisp123: In addition, this combination of a static and a dynamic language easily turns into a debugging nightmare.
[14:49:00] <hayley> There is a smattering of familiar names in that thread, oddly enough, including Robert Virding, Rainer Joswig, Henry Baker, Doug Lea...
[14:51:01] <lisp123> It's a good (and long) read, thanks for sharing
[14:53:28] *** Quits: igemnace (~ian@user/igemnace) (Remote host closed the connection)
[14:54:27] <lisp123> beach: I can imagine
[14:54:44] <lisp123> Emacs is in this weird state of mixing C with elisp
[14:57:12] <lisp123> Does interlisp code work perfectly in CL?
[14:57:41] <lisp123> It would be cool to have a mini CL, basically the basics of lisp but with CL's rules in mind
[14:58:55] <beach> Interlisp is different from Common Lisp.
[14:59:27] <beach> But there is a project to merge the two.  I forget the name.
[14:59:34] <beach> But jcowan would know.
[15:00:31] <lisp123> Thanks, I see
[15:03:15] <beach> Medlay maybe?
[15:03:16] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Ping timeout: 252 seconds)
[15:03:22] <beach> Er, Medley.
[15:03:36] <lisp123> I read the wiki page for interlisp, it mentioned that as an open source project, so probably it
[15:03:41] *** Joins: amb007 (~a_bakic@210.38.22.93.rev.sfr.net)
[15:11:37] *** Joins: yitzi (~yitzi@173-27-106-188.client.mchsi.com)
[15:13:01] <hayley> "There are far more ugly programs than ugly languages.  Using a 'good' language does not guarantee pretty programs.  In fact, since a 'good' language has immense power, it is possible to write uglier programs in a 'good' language, than it is to write ugly programs in a 'bad' language.  This, of course, is one of the justifications I've seen for forcing people to write in 'bad' languages !!" -- Henry Baker
[15:14:45] *** Quits: Duuqnd (~Duuqnd@185.201.174.78) (Quit: Duuqnd)
[15:15:41] *** Joins: Duuqnd[m]1 (~duuqnd@2001:470:69fc:105::e9c0)
[15:16:53] <hayley> Another good line is "Two words: 'Lisp Machine'."
[15:16:54] *** Quits: amb007 (~a_bakic@210.38.22.93.rev.sfr.net) (Read error: Connection reset by peer)
[15:17:45] *** Joins: random-nick (~random-ni@87.116.183.203)
[15:19:13] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[15:20:09] *** Joins: lisp123 (~lisp123@5.30.23.247)
[15:20:45] <mfiano> Well said
[15:20:49] *** Quits: Cymew (~ante@c-e989225c.023-1144-7570702.bbcust.telenor.se) (Ping timeout: 268 seconds)
[15:21:10] *** Quits: yitzi (~yitzi@173-27-106-188.client.mchsi.com) (Remote host closed the connection)
[15:21:19] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[15:21:59] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[15:22:53] *** Quits: rain3 (~rain3___@2a02:2f09:d100:8700:1ae4:6be9:2a58:7de6) (Ping timeout: 268 seconds)
[15:23:07] *** Quits: attila_lendvai (~alendvai@217.65.124.57) (Read error: Connection reset by peer)
[15:23:38] *** Joins: attila_lendvai (~alendvai@217.65.124.57)
[15:25:11] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[15:29:05] *** Quits: frgo (~frgo@p200300deef0cee005d8a5b6e8d5a763f.dip0.t-ipconnect.de) (Remote host closed the connection)
[15:29:34] *** Joins: frgo (~frgo@p200300deef0cee005d8a5b6e8d5a763f.dip0.t-ipconnect.de)
[15:32:56] <Nilby> I should remember to cite Henry when I use the overwhelming power to write egregiously ugly code.
[15:36:17] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[15:36:18] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[15:36:55] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[15:50:05] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[15:50:55] *** Quits: dre (~dre@2001:8003:c932:c301:3743:ee79:8c00:65b1) (Remote host closed the connection)
[15:58:10] *** Joins: lisp123 (~lisp123@5.30.23.247)
[16:03:26] *** Joins: Cymew (~ante@host-217-213-69-149.mobileonline.telia.com)
[16:08:43] *** Joins: IPmonger (~IPmonger@c-69-242-83-226.hsd1.pa.comcast.net)
[16:08:56] *** Quits: IPmonger (~IPmonger@c-69-242-83-226.hsd1.pa.comcast.net) (Remote host closed the connection)
[16:10:09] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 268 seconds)
[16:17:38] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[16:18:44] <jmercouris> beach: I still think an error SHOULD be signaled :-D
[16:32:08] *** Joins: [X-Scale] (~ARM@31.22.160.28)
[16:32:34] *** Quits: X-Scale (~ARM@83.223.226.16) (Ping timeout: 260 seconds)
[16:33:29] *** [X-Scale] is now known as X-Scale
[16:34:16] *** Joins: cage (~cage@dynamic-adsl-84-220-251-50.clienti.tiscali.it)
[16:51:41] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 268 seconds)
[16:52:48] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[17:01:33] *** Joins: selwyn (~selwyn@user/selwyn)
[17:05:05] *** Joins: lisp123 (~lisp123@5.30.23.247)
[17:13:15] <beach> jmercouris: Indeed, and that's what it will do in WSCL.
[17:16:21] *** Quits: Cymew (~ante@host-217-213-69-149.mobileonline.telia.com) (Ping timeout: 265 seconds)
[17:16:52] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[17:17:32] *** Joins: lisp123 (~lisp123@5.30.23.247)
[17:19:53] *** Joins: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431)
[17:22:55] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 268 seconds)
[17:30:47] *** Joins: Bike (~Glossina@71.69.170.70)
[17:30:47] *** ChanServ sets mode: +o Bike
[17:30:58] *** Joins: Cymew (~ante@c-e989225c.023-1144-7570702.bbcust.telenor.se)
[17:31:21] *** Joins: kevingal (~quassel@2a02:8084:4140:f300:35b4:f9f2:852b:7b98)
[17:34:07] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[17:50:58] <hayley> I'm settling a little discussion about persistent data structures now: when was the last time you (the reader) destructively modified a list?
[17:52:04] <Bike> i don't remember the exact context, but it was along the lines of (loop ... nconc (loop ... collect ...))
[17:52:15] *** Joins: lisp123 (~lisp123@5.30.23.247)
[17:53:28] <hayley> (I guess bonus points if your list would have been allocated in a previous GC cycle, but that is not something people pay attention to.)
[17:55:44] <Bike> mm, for modifying something more persistently, i don't recall... maybe altering an alist
[17:57:52] <beach> I think I do it every day.  Cleavir instructions have a list for inputs, for outputs, and for successors.  I think we sometimes destructively modify those.
[17:59:20] <hayley> Guess I would have to check, but I only recall PUSH and REMOVE on such lists.
[18:00:49] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[18:00:49] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[18:00:57] *** Joins: amb007 (~a_bakic@210.38.22.93.rev.sfr.net)
[18:00:57] *** Quits: amb007 (~a_bakic@210.38.22.93.rev.sfr.net) (Read error: Connection reset by peer)
[18:01:09] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[18:02:28] <hayley> (SETF NTH-SUCCESSOR) and INSERT-INSTRUCTION-BETWEEN do indeed destructively modify lists, yes.
[18:02:58] <Gnuxie> I like to use (setf alexandria:assoc-value) a lot
[18:02:58] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[18:03:10] <beach> hayley: Right.
[18:03:38] <mfiano> I use alexandria:deletef and cl:nreverse a lot.
[18:03:57] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[18:05:55] *** Quits: attila_lendvai (~alendvai@217.65.124.57) (Read error: Connection reset by peer)
[18:06:08] <mfiano> Come to think of it, I rely on my implementation performing a lot of (potentionally) destructive list operations.
[18:06:23] <mfiano> I think the "how often" question is "every few minutes"?
[18:06:34] *** Joins: attila_lendvai (~alendvai@217.65.124.57)
[18:07:18] <mfiano> potentially*
[18:07:50] <hayley> Seems I am doing something unusual, as I rarely write code which mutates lists...ever, I think.
[18:08:28] <mfiano> Maybe your NBHM can be much more performant then :)
[18:09:11] <hayley> Very funny, a NBHM is just a vector with some glitter glued onto it. And when I mutate sequences, I usually reach for a vector.
[18:09:51] *** Quits: attila_lendvai (~alendvai@217.65.124.57) (Read error: Connection reset by peer)
[18:10:40] *** Joins: attila_lendvai (~alendvai@217.65.124.57)
[18:13:55] <mfiano> I usually reach for the sequence that makes sense. Norvig-style queues and fixed array queues are both useful in different situations for example.
[18:14:57] <hayley> Usually I just use safe-queue (as most of the time I use queues in a concurrent program too). But then the queue in sb-concurrency uses a list internally.
[18:19:09] <Nilby> does nreverse count?
[18:19:32] <mfiano> On most implementations.
[18:20:53] <Nilby> I know it's shameful, but a quick count of some potentially list mutative keywords in my current codebase: nconc 66 rplaca 10 rplacd 26 "\\(setf \\(car" 13 "\\(setf \\(cdr" 15 "nreverse" 209
[18:21:18] <mfiano> Don't forget about the ones that don't have any particular naming convention
[18:21:36] <mfiano> Like #'sort
[18:21:51] <Nilby> I know there are many other :o
[18:23:20] <Nilby> I feel like nreverse should be like an machine opcode or something
[18:23:24] <mfiano> RPLACA/RPLACD annoy me as names, where the convention is to descriptively name your operators, so I barely ever use them. Reminds me of writing an assembler :/
[18:27:22] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[18:27:34] *** Quits: attila_lendvai (~alendvai@217.65.124.57) (Remote host closed the connection)
[18:27:48] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[18:28:05] *** Joins: attila_lendvai (~alendvai@217.65.124.57)
[18:28:36] <mfiano> _death: Did you like the Paepcke book? Just received my copy, and will probably start reading it later today.
[18:31:06] *** Quits: attila_lendvai (~alendvai@217.65.124.57) (Read error: Connection reset by peer)
[18:31:26] <_death> mfiano: it's a collection of papers.. many were very interesting.. there were a few that I didn't care for
[18:31:44] *** Joins: attila_lendvai (~alendvai@217.65.124.57)
[18:31:46] <mfiano> _death: Cool. Anything you particularly liked about it over amop/keene?
[18:32:08] <mfiano> No idea what I'm walking into. Havent read any of the papers before
[18:35:58] *** Joins: lisp123 (~lisp123@5.30.23.247)
[18:36:13] <_death> different kinds of books, so find it hard to compare.. I liked all three
[18:37:40] <mfiano> _death: Ok. By the way, feel free to recommend any other Lisp books you liked. You have recommended 2 I have never heard of so far (the previous being Building Problem Solvers)
[18:38:03] <mfiano> Which I also got now (but haven't read yet)
[18:38:51] <Nilby> mfiano: I agree. I wish I could convice my fingers not to type junk like (rplacd (nthcdr ... since it reads like nonsense.
[18:39:46] <_death> well my favorite programming book, which is also a Lisp book, is PAIP.. which you probably already read
[18:41:10] <mfiano> I haven't finished it actually. I keep meaning to go back to it
[18:45:29] <_death> some books I would not call "Lisp books" but do use a kind of Lisp in a low-key way.. for example Hoare's Communicating Sequential Processes book
[18:46:06] <mfiano> I am equally interested in those.
[18:46:12] <mfiano> Thanks, looking it up.
[18:46:52] <_death> also many AI-related books and papers from the 1980s and the 1990s..
[18:48:46] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[18:53:28] <_death> one way to make a book into a Lisp book is to implement everything it talks about in Lisp as you read it ;)
[18:53:49] <_death> it can take a long time, but some books are worth it
[18:55:59] <_death> some books are easier to implement (e.g., they have pseudocode).. others require you to read part of their bibliography & other resources found on the web
[18:57:07] <_death> then after you read the papers and implement them, you understand where the author put more effort, and where he skimped ;)
[18:59:41] <mfiano> :)
[18:59:50] <_death> some papers are quite cryptic.. others build on other papers.. so you can spend a month implementing ideas from a paper and its related papers, even if the paper was a few pages
[19:01:08] <mfiano> I would like to try doing that sometime
[19:01:20] <_death> sometimes there is not enough information to make it easy to test your implementation..
[19:01:33] <lukego> I had forgotten about the Lisp in CSP. I love that book, even based on its non-Lisp content :).
[19:01:43] <mfiano> I have given myself more freedom from gamedev this year to explore other programming interests, and that is exactly something i wanted to do
[19:06:48] *** Joins: doyougnu (~user@c-73-25-202-122.hsd1.or.comcast.net)
[19:12:13] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[19:12:55] *** Joins: eddof13 (~textual@static-201-163-9-58.alestra.net.mx)
[19:16:48] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
[19:28:47] *** Quits: Cymew (~ante@c-e989225c.023-1144-7570702.bbcust.telenor.se) (Ping timeout: 265 seconds)
[19:37:34] *** Quits: attila_lendvai (~alendvai@217.65.124.57) (Read error: Connection reset by peer)
[19:38:13] *** Joins: attila_lendvai (~alendvai@217.65.124.57)
[19:48:56] *** Joins: nature (~nature@mail.blazebone.com)
[19:56:28] *** Joins: VincentVega (~user@212.241.25.220)
[20:05:10] *** Joins: mortemeur (~mortemeur@pool-173-76-107-201.bstnma.fios.verizon.net)
[20:12:46] *** Quits: mariari (~mariari@user/mariari) (Ping timeout: 265 seconds)
[20:13:10] *** Quits: Nilby (~Nilby@c-67-160-81-88.hsd1.wa.comcast.net) (Ping timeout: 240 seconds)
[20:24:30] *** Joins: lisp123 (~lisp123@5.30.23.247)
[20:25:13] *** Joins: jealousmonk (~user@2804:431:e7c4:a9fe:237b:ad37:48fd:1566)
[20:26:14] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[20:27:17] *** Quits: mortemeur (~mortemeur@pool-173-76-107-201.bstnma.fios.verizon.net) (Read error: Connection reset by peer)
[20:28:38] <jcowan> Medley is a programming environment that provides two languages: Interlisp and Common Lisp.  Unfortunately, the CL stands somewhere between CLtL1 and CLtL2.  This needs fixing.
[20:29:21] <jcowan> It would pretty much be a Common Lisp project to do so, and I would expect that the CL test suite could drive it.
[20:30:55] <beach> How is the evaluator written?
[20:31:37] <ecraven> C
[20:31:46] <ecraven> https://github.com/Interlisp/maiko
[20:31:58] <ecraven> ah, sorry, misread "evaluator" as "emulator"
[20:32:24] <jcowan> There is an IL interpreter, a CL interpreter, an IL compiler to bytecode, and a CL/IL compiler to bytecode.  There is no native code compiler.
[20:33:04] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Ping timeout: 265 seconds)
[20:33:14] <beach> Wow, there must be a lot of overlap there.
[20:33:48] *** Joins: amb007 (~a_bakic@242.38.22.93.rev.sfr.net)
[20:35:19] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 268 seconds)
[20:42:19] <jcowan> A fair amount, but IL and CL developed independently for decades.  Interoperation is good: CL sees IL functions and fexprs as CL functions and macros (although only some of them return an actual macro definition to CL:MACRO-FUNCTION.
[20:42:47] <jcowan> And IL can access any CL function with a package prefix
[20:43:55] <Bike> i'm flipping through the manual now. seems to describe everything as a function... setq, for example
[20:45:42] <beach> jcowan: I was thinking especially between interpreter and compiler.
[20:46:13] <Bike> has an extensible loop, though
[20:46:14] <jcowan> Bike: It's a fexpr (or fsubr)
[20:46:32] <Bike> i was guessing that was what "nlambda" means, but selectq isn't labeled as one (while stuff like cond is)
[20:46:57] <jcowan> beach: Local variables are dynamically bound in the IL interpretter  only.
[20:47:12] <Bike> "If LAMBDA-WORD is the symboL NLAMBDA, then the arguments to the function are not evaluated" i am a genius
[20:47:30] <beach> jcowan: Is that what Interlisp requires?
[20:47:39] <jcowan> Yes.
[20:47:42] <beach> Wow.
[20:47:46] <Bike> i think the manual said all variables are dynamic, but i'm skimming
[20:47:53] <beach> jcowan: And that still leaves duplication between the Common Lisp interpreter and the Common Lisp compiler.
[20:47:55] <Bike> (like, "dynamic" in the CL sense, i mean)
[20:48:22] <jcowan> Such was the case in Maclisp as well.  It was one of Scheme's contributions to CL that locals are lexical unless declared otherwise.
[20:48:46] <Bike> yeah, i know
[20:48:46] <jcowan> (It's one of IL's contributions to CL that (car nil) = (cdr nil) = nil
[20:48:47] <jcowan> )
[20:48:49] <beach> Well, the Maclisp compiler used lexical scoping.
[20:49:01] <jcowan> So do the IL and IL/CL compilers.
[20:49:14] <Bike> all parameters are optional and extra arguments are silently ignored
[20:49:22] <beach> But not the Common Lisp interpreter?
[20:49:39] <Bike> the loop ("iterative") stuff and the record types are kind of interesting, though
[20:49:42] <jcowan> No.  The CL compiler is mostly CLtL compliant
[20:50:14] <jcowan> The other implementation of IL runs on the PDP-10, which is available in emulation.
[20:50:30] <Bike> is interlisp an actual standardized language? i thought it was, but what i'm looking at is obviously an implementation manual
[20:50:40] <beach> I see.  So the reason there is not as much duplication between the Common Lisp interpreter and the Common Lisp compiler is that the interpreter incorrectly uses dynamic binding for lexical variables?
[20:50:49] <jcowan> No.
[20:51:05] <Bike> doesn't look like it... ah, i'm thinking of islisp
[20:51:49] * beach is lost now.
[20:52:07] <Bike> heh, there's "kwote"
[20:52:18] <beach> Maclisp had that one too.
[20:52:25] <Bike> which is like a double quotation i guess?
[20:52:46] <beach> It was (defun kwote (x) (list 'quote x)) as I recall.
[20:52:46] <jcowan> Only the IL interpreter makes all local vribles dynamic.
[20:53:03] <Bike> oh, eval is extensible, interesting
[20:53:21] <Bike> i wonder how that's used in practice
[20:53:53] <jcowan> I believe that IL:EVAL has access to the lexical environment.
[20:54:14] <Bike> yeah i can't tell if this thing is being weird about what is and isn't an nlambda. (rpl n form) "evaluates the expression form n times" but it's just listed as a function
[20:54:49] <jcowan> which exact manual are you looking at?
[20:54:52] *** Joins: mariari (~mariari@user/mariari)
[20:55:11] <Bike> the "Medley Language Reference" i found on interlisp.org
[20:55:35] <Bike> it was on the medley wiki
[20:56:36] *** Quits: srhm (~srhm@user/srhm) (Quit: Konversation terminated!)
[20:56:54] <jcowan> Okay, that's the latest
[20:56:57] *** Joins: srhm (~srhm@user/srhm)
[20:57:36] <jcowan> https://interlisp.org/docs/IRM.pdf, right?
[20:57:41] <Bike> Yep
[20:58:10] <Bike> no quasiquotation...
[21:00:28] <beach> jcowan: What would be the special features of Medley that make it the preferred choice over a modern Common Lisp implementation?
[21:01:16] <beach> Interlisp obviously, but what makes Interlisp preferable to a modern Common Lisp implementation today?  And why do you want Common Lisp as one of the languages in Medley?
[21:01:45] *** Quits: srhm (~srhm@user/srhm) (Read error: Connection reset by peer)
[21:01:47] <jcowan> Well for #2 we have it, and for #1, the Medley environmen t is written in IL
[21:02:07] *** Joins: srhm (~srhm@user/srhm)
[21:02:09] <jcowan> So the model here is: develop in Medley CL, deploy in SBCL.
[21:02:37] <_death> medley is a whole system
[21:03:05] <beach> jcowan: So the strength is the development environment?
[21:03:34] <jcowan> The work rquired to upgrade Medley CL to the ANS should be fairly small; the biggest part is figuriung out wht needs fixing.
[21:03:45] <jcowan> Yes, the IDE.
[21:03:51] <beach> Got it.
[21:04:22] <jcowan> Admittedly, Medley doesn't look that much like a modern concensus IDE, but more so than Emacs.
[21:04:28] <jcowan> -sensus
[21:05:00] <Bike> the part of the manual about the environment is longer than the part about the language
[21:05:06] *** Quits: kevingal (~quassel@2a02:8084:4140:f300:35b4:f9f2:852b:7b98) (Read error: Connection reset by peer)
[21:05:37] <Bike> got a dedicated list structure editor
[21:07:24] <jcowan> Two, actually: a TTY_style one and a GUI one.
[21:08:37] <jcowan> Maclisp effort wentt into building the language; IL effort into building the environment.
[21:10:32] <_death> jcowan: one question is how to conciliate a saved image and new changes in the medley repo
[21:11:03] <jcowan> I have also thought a little about what it would take to implement IL in CL, thus providing the Medley environment  with the speed of a modern CL
[21:14:04] <jcowan> You'd need a few changes, like providing an :export-all flag for packages
[21:16:17] <jcowan> But beyond that you would, I hope, only need to implement the functions currently written in C.
[21:26:02] *** Quits: amb007 (~a_bakic@242.38.22.93.rev.sfr.net) (Read error: Connection reset by peer)
[21:26:06] *** Quits: Skyfire (~pyon@user/pyon) (Ping timeout: 260 seconds)
[21:29:51] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[21:43:00] *** Quits: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Quit: Client closed)
[21:43:09] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 265 seconds)
[21:44:32] *** Joins: aeth (~aeth@user/aeth)
[21:46:16] *** Joins: tfeb (~tfb@109.249.185.23)
[21:48:33] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
[21:48:44] *** tfeb is now known as tfb
[21:48:58] *** Parts: pranavats (3fba1d1b34@jabberfr.org) ()
[21:49:55] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[21:50:53] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Ping timeout: 265 seconds)
[21:51:47] *** Joins: amb007 (~a_bakic@226.38.22.93.rev.sfr.net)
[21:54:38] *** Quits: tfb (~tfb@109.249.185.23) (Quit: died)
[21:59:43] *** Joins: lisp123 (~lisp123@5.30.23.247)
[22:05:08] <lisp123> Can the IL IDE be used today?
[22:07:19] *** Joins: kakuhen (~kakuhen@user/kakuhen)
[22:09:57] <CptKirk> what is that?
[22:10:34] <lisp123> InterLisp
[22:10:56] <lisp123> one of the ancestors of Common Lisp, there was a discussion earlier today on it. Apparently it had a very good development environment
[22:14:40] *** Quits: VincentVega (~user@212.241.25.220) (Read error: Connection reset by peer)
[22:16:00] *** Joins: ndr (~CptKirk@97-118-72-33.hlrn.qwest.net)
[22:16:02] *** Joins: yitzi (~yitzi@173-27-106-188.client.mchsi.com)
[22:16:19] *** Quits: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Quit: Client closed)
[22:16:22] *** Quits: ndr (~CptKirk@97-118-72-33.hlrn.qwest.net) (Client Quit)
[22:16:39] *** Joins: ndr (~CptKirk@97-118-72-33.hlrn.qwest.net)
[22:16:48] <cosimone> hello, is there some way, to your knowledge, to manipulate the internal representation of floating point numbers as something such as a bit vector?
[22:17:25] *** Quits: ndr (~CptKirk@97-118-72-33.hlrn.qwest.net) (Client Quit)
[22:17:42] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
[22:18:10] <yitzi> cosimone: https://common-lisp.net/project/ieee-floats/
[22:18:31] *** Quits: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Client Quit)
[22:18:37] <cosimone> that seems what i'm looking for, thanks
[22:18:42] <yitzi> yw
[22:19:12] <cosimone> isn't there anything like that in the standard?
[22:21:22] <Bike> no. the standard does not mandate any particular floating point system.
[22:21:30] <Bike> the closest thing is
[22:21:33] <Bike> clhs integer-decode-float
[22:21:33] <specbot> http://www.lispworks.com/reference/HyperSpec/Body/f_dec_fl.htm
[22:21:47] <Bike> but i don't think that's what you're asking for
[22:22:39] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
[22:23:49] <cosimone> i see
[22:24:28] <Bike> there's also https://github.com/Shinmera/float-features which uses implementation specifics to get the actual bits, which is maybe what you want
[22:28:58] <yitzi> Bike: I saw in the ANSI spec that attempting to delete the cl or keyword package is unspecified behavior. Any idea why that would even be permitted? Some implementation prevent it and some actually let me do it.
[22:29:35] <Bike> when the standard says something like that i think it's more to let implementations be lazy by not putting in measures to prevent it, rather than because doing it is a good idea
[22:30:02] *** Quits: amb007 (~a_bakic@226.38.22.93.rev.sfr.net) (Ping timeout: 265 seconds)
[22:30:19] *** Joins: amb007 (~a_bakic@120.244.204.77.rev.sfr.net)
[22:30:27] <yitzi> Amazing. CCL actually let me do it. SBCL gave me a pile of restarts and then let me do it and then promptly froze.
[22:33:03] <Bike> sounds about right
[22:33:08] *** Quits: fengshaun (~fengshaun@S010680615f0c2c0a.cg.shawcable.net) (Quit: bibi!)
[22:34:57] *** Quits: amb007 (~a_bakic@120.244.204.77.rev.sfr.net) (Ping timeout: 268 seconds)
[22:35:10] <cosimone> wow
[22:35:42] <yitzi> Yeah, both tried to stop me with package locks. So far only ECL and CLASP said no outright. ABCL just did so without complaint.
[22:40:13] *** Joins: fengshaun (~fengshaun@S010680615f0c2c0a.cg.shawcable.net)
[22:42:42] *** Quits: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Quit: WeeChat 2.8)
[22:43:07] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
[22:46:43] *** Joins: amb007 (~a_bakic@86.15.23.93.rev.sfr.net)
[22:49:00] *** Quits: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Quit: WeeChat 2.8)
[22:49:17] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
[22:49:38] *** Quits: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Client Quit)
[22:49:57] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
[22:51:16] *** Quits: amb007 (~a_bakic@86.15.23.93.rev.sfr.net) (Ping timeout: 252 seconds)
[22:54:18] *** Quits: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Client Quit)
[22:54:44] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
[22:55:01] *** Quits: srhm (~srhm@user/srhm) (Read error: Connection reset by peer)
[22:55:40] *** Joins: srhm (~srhm@user/srhm)
[22:58:52] *** Quits: Noisytoot (~noisytoot@sourcehut/user/noisytoot) (Ping timeout: 245 seconds)
[22:59:48] *** Joins: Noisytoot (~noisytoot@sourcehut/user/noisytoot)
[23:02:50] *** Quits: specbot (~specbot@common-lisp.net) (Remote host closed the connection)
[23:02:51] *** Quits: minion (~minion@common-lisp.net) (Read error: Connection reset by peer)
[23:03:12] *** Joins: minion (~minion@common-lisp.net)
[23:03:21] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[23:03:23] *** Quits: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Quit: WeeChat 2.8)
[23:03:39] *** Joins: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net)
[23:03:53] *** Joins: specbot (~specbot@common-lisp.net)
[23:07:38] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 268 seconds)
[23:08:29] *** Joins: Lord_of_Life (~Lord@user/lord-of-life/x-2819915)
[23:13:05] *** Joins: CptKirk24 (~CptKirk@97-118-72-33.hlrn.qwest.net)
[23:13:05] *** CptKirk24 is now known as CptJimKirk
[23:16:13] *** Quits: CptKirk (~CptKirk@97-118-72-33.hlrn.qwest.net) (Quit: WeeChat 2.8)
[23:20:09] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[23:29:32] *** Joins: gaqwas (~john@dynamic-095-117-036-184.95.117.pool.telefonica.de)
[23:38:38] <recordgroovy> ABCL lets me define a condition inheriting stream-error, but doesn't let me apply stream-error-stream to it, hmm...
[23:39:20] *** Joins: tyson2 (~user@bras-base-toroon0628w-grc-46-142-112-141-177.dsl.bell.ca)
[23:42:46] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[23:43:19] *** Joins: lisp123 (~lisp123@5.30.23.247)
[23:47:58] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
