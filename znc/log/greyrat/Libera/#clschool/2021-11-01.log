[00:40:22] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Remote host closed the connection)
[00:41:29] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[01:21:09] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[01:49:57] *** Quits: dra (~dra@2a04:4540:6419:4d00:9c4f:2d61:e582:82f7) (Quit: Leaving)
[02:25:13] *** Joins: dra (~dra@2a04:4540:6419:4d00:e866:3747:ef3c:6e50)
[02:32:11] *** Quits: random-nick (~random-ni@87.116.165.220) (Ping timeout: 264 seconds)
[02:53:47] *** Quits: johnjay (~pi@192.142.100.50) (Ping timeout: 264 seconds)
[03:13:14] *** Joins: johnjay (~pi@192.142.100.50)
[03:28:50] *** Quits: dra (~dra@2a04:4540:6419:4d00:e866:3747:ef3c:6e50) (Quit: Leaving)
[03:58:26] *** Quits: lotuseater (~user@p200300e7871bd300c158d62dc7544d08.dip0.t-ipconnect.de) (Ping timeout: 260 seconds)
[04:40:34] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[04:55:00] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Quit: WeeChat 3.3)
[05:58:20] *** Joins: lisp123 (~lisp123@5.30.23.247)
[06:03:23] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 264 seconds)
[06:24:05] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[06:48:21] *** Joins: Oladon (~olad@98.43.81.226)
[06:56:46] *** Quits: sts-q (~sts-q@212.53.219.244) (Ping timeout: 260 seconds)
[06:58:43] *** Joins: lisp123 (~lisp123@5.30.23.247)
[07:00:56] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[07:01:12] *** Joins: lisp123 (~lisp123@5.30.23.247)
[07:01:17] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[07:09:49] *** Joins: sts-q (~sts-q@212.53.219.240)
[08:08:26] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[09:24:12] *** Quits: Riviera (Riviera@user/riviera) (*.net *.split)
[09:24:12] *** Quits: lonjil (~quassel@user/lonjil) (*.net *.split)
[09:24:12] *** Quits: Kabriel (~Kabriel@user/kabriel) (*.net *.split)
[09:24:26] *** Joins: lonjil (~quassel@user/lonjil)
[09:24:26] *** Joins: Riviera (Riviera@user/riviera)
[09:26:03] *** Joins: Kabriel (~Kabriel@user/kabriel)
[09:32:50] *** Quits: il (~il@user/f/x-7830992) (*.net *.split)
[09:33:27] *** Joins: il (~il@2a05:f480:1800:ce9:5400:3ff:fe4c:b137)
[09:33:31] *** Quits: il (~il@2a05:f480:1800:ce9:5400:3ff:fe4c:b137) (Signing in (il))
[09:33:31] *** Joins: il (~il@user/f/x-7830992)
[09:59:53] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Remote host closed the connection)
[10:00:40] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[10:06:08] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[10:20:14] *** Quits: bcasiello (~bcasiello@066-189-087-112.biz.spectrum.com) (Ping timeout: 260 seconds)
[10:33:04] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Remote host closed the connection)
[10:33:30] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[11:35:33] *** Joins: hendursa1 (~weechat@user/hendursaga)
[11:39:06] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[12:31:21] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Remote host closed the connection)
[12:31:55] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[14:57:58] *** Joins: lisp123 (~lisp123@5.30.23.247)
[15:02:58] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 260 seconds)
[15:14:08] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[16:06:47] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[16:50:46] *** Joins: shka (~herr@83.175.151.96.piasta.pl)
[16:52:31] *** Joins: random-nick (~random-ni@87.116.165.220)
[16:56:11] *** Quits: shka (~herr@83.175.151.96.piasta.pl) (Read error: Connection reset by peer)
[17:00:10] *** Joins: shka (~herr@83.175.151.96.piasta.pl)
[17:04:39] *** Quits: hendursa1 (~weechat@user/hendursaga) (Quit: hendursa1)
[17:11:35] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[17:12:57] *** Joins: hendursaga (~weechat@user/hendursaga)
[17:35:24] *** Joins: silasfox (~sbv@p200300fb27055fee8dc5d1c492ffbbde.dip0.t-ipconnect.de)
[17:52:48] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 268 seconds)
[17:58:24] *** Joins: thrig (~thrig@70.97.65.251)
[18:10:23] *** Quits: thrig (~thrig@70.97.65.251) (Remote host closed the connection)
[18:25:06] *** Quits: johnjay (~pi@192.142.100.50) (Ping timeout: 260 seconds)
[18:27:38] *** Joins: johnjay (~pi@192.142.100.50)
[18:51:10] *** Joins: tyson2 (~user@cpe00fc8d34ff03-cm00fc8d34ff00.sdns.net.rogers.com)
[19:19:48] *** Quits: silasfox (~sbv@p200300fb27055fee8dc5d1c492ffbbde.dip0.t-ipconnect.de) (Quit: WeeChat 3.3)
[19:45:20] *** Joins: cyberbanjo (~user@2607:fb90:42ac:8e3f:1162:3750:ee6e:9b2d)
[19:54:25] <cyberbanjo> Why doesn't solve-a and solve-b behave identically? Can't recur from inside a cond?
[19:54:25] <cyberbanjo> https://pastebin.com/raw/yirwAVH9 (40 lines)
[19:54:25] <cyberbanjo>  
[19:55:35] *** Joins: bcasiello (~bcasiello@066-189-087-112.biz.spectrum.com)
[19:55:48] <beach> You don't return 1 in solve-b.
[19:56:03] <beach> er, in solve-a I mean.
[19:57:22] <beach> So solve-a returns NIL for anything except 1.
[19:58:31] <beach> And Common Lisp has no restrictions as the one you are suggesting.
[19:58:35] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 264 seconds)
[19:59:59] *** Joins: aeth (~aeth@user/aeth)
[20:01:57] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Remote host closed the connection)
[20:04:31] <beach> cyberbanjo: Hello?
[20:05:13] <beach> Perhaps you meant to put the test for the initial number being 1 inside the COND?
[20:05:50] <cyberbanjo> I think that might be it, but I thought if and cond did the same thing
[20:06:34] <beach> If has a `then' branch and an optional `else' branch.  COND has an arbitrary number of branches.
[20:07:06] *** Joins: Jacobis9000 (~jonaholuf@81.145.248.247)
[20:07:10] <beach> Also, you have calls to SOLVE inside SOLVE-A and SOLVE-B but no recursive calls to neither SOLVE-A nor SOLVE-B.
[20:07:13] *** Quits: tyson2 (~user@cpe00fc8d34ff03-cm00fc8d34ff00.sdns.net.rogers.com) (Remote host closed the connection)
[20:07:21] <cyberbanjo> OMG duh
[20:07:23] <cyberbanjo> tyt
[20:08:11] <beach> Furthermore, you should always have both the `then' and the `else' branch in your IFs.
[20:08:13] <cyberbanjo> Yes, but doesnt cond macro expand into nested ifs? Thats why I thought that
[20:08:23] <beach> Yes, it does.
[20:10:31] <beach> If you IF is in a context where the value is required, it should always have a `then' branch, even if that branch contains NIL.
[20:11:25] <beach> If your IF is in a context where the value is NOT needed, and you want to perform some side effect only in one of the two branches, then use WHEN or UNLESS instead of IF.
[20:11:49] <beach> So in other words, there is never any use for an IF with only a `then' branch. 
[20:12:29] <White_Flame> cyberbanjo: or, the implementation could have IF expand into COND, and use COND as the fundamental operation
[20:12:54] <beach> More stylistic stuff: Instead of (eql 0 ...) you should use (zerop ...)
[20:13:07] <beach> Instead of (+ 1 ...) you should use (1+ ...).
[20:13:49] <beach> cyberbanjo: There is a very general rule in programming that you should use the most specific construct that will have the desired effect.  And both ZEROP and 1+ are more specific than EQL and +.
[20:14:30] *** Quits: cyberbanjo (~user@2607:fb90:42ac:8e3f:1162:3750:ee6e:9b2d) (Remote host closed the connection)
[20:15:12] <beach> White_Flame: Well, COND must still have a macro expander.
[20:15:37] *** Joins: cyberbanjo (~user@2607:fb90:42ac:8e3f:1162:3750:ee6e:9b2d)
[20:15:45] <cyberbanjo> sorry d/c is there a log of this group :()
[20:15:53] <beach> No, sorry.
[20:16:11] <cyberbanjo> OK :\
[20:16:18] <beach> White_Flame: But yes, that macro expander could expand into IF which could then expand into COND which would be treated as a special operator.
[20:16:38] <Jacobis9000> emacs deciding to use ctrl for it's ctrl key is bad. I accidentally pressed ctrl-z instead of ctrl-c and lost everything.
[20:17:14] <beach> That doesn't lose anything, does it?
[20:17:22] <Jacobis9000> it's gone, it closed it all
[20:17:32] <cyberbanjo> Not sure, my issue is sometimes I start an infinite loop in emacs
[20:17:35] <beach> Just minimized.
[20:17:38] <beach> Not closed.
[20:17:47] <Jacobis9000> says [1]+ Stopped
[20:17:54] <beach> do fg
[20:17:58] <beach> Then you get it back.
[20:18:07] <Jacobis9000> I am in my ordinary terminal now
[20:18:09] <Jacobis9000> it exited emacs
[20:18:19] <beach> No, stopped is not exited.
[20:18:31] <Jacobis9000> fg worked!
[20:18:32] <Jacobis9000> wtf
[20:19:13] <cyberbanjo> yes C-z suspends process
[20:19:26] <cyberbanjo> kinda nice if you not using tmux/screen to do something else and resume
[20:19:42] <beach> Emacs doesn't do things like that.  If you try to quit with unsaved buffers, it will ask you.  If you try to quit with child processes running, it will ask you.
[20:20:17] *** Joins: tyson2 (~user@cpe00fc8d34ff03-cm00fc8d34ff00.sdns.net.rogers.com)
[20:20:36] <beach> cyberbanjo: Did you see my remarks about conventions?
[20:21:00] <beach> ... the "branches of IF" thing?
[20:21:00] <cyberbanjo> Yes, at least the specific-iest thing possible: 1+, zerop. 
[20:21:07] <cyberbanjo> Yes, when * unless vs if
[20:21:11] <beach> Great!
[20:21:29] <cyberbanjo> Great to you! TY
[20:21:37] <beach> YW
[20:21:48] <beach> er, YAW
[20:27:05] <Jacobis9000> we have to return 't but we do not return 'nil, or returning 'nil is fine?
[20:27:13] <Jacobis9000> it is confusing as to when the ' is necessary
[20:30:08] <White_Flame> T and NIL evaluate to themselves, and really don't need quoting
[20:30:08] <Jacobis9000> what is the difference between nil and 'nil?
[20:30:54] <White_Flame> it's only a difference of intent for when you're talking about the specific symbol T/NIL that you'd quote it, as opposed to the value T/NIL, but both evaluate to exactly the same
[20:31:01] <White_Flame> *of expressing intent
[20:31:07] <Jacobis9000> ah yes the book does not quote them
[20:31:16] <Jacobis9000> I can't recall what the quote is all about
[20:31:24] <White_Flame> it means not to evaluate
[20:31:32] <Jacobis9000> ah yes
[20:31:40] <White_Flame> (foo 'a) passes the literal symbol A.  (foo a) evaluates the value of the variable A and passes that
[20:31:56] <Jacobis9000> I need to make notes about this somewhere
[20:32:19] <White_Flame> and '(+ 1 2) evaluates to a list of 3 items.  (+ 1 2) evaluates to the number 3
[20:33:42] <White_Flame> and (eval '(+ 1 2)) passes the literal source code list to EVAL, which the evaluates that into 3
[20:34:22] <White_Flame> having source code as just plain data lists is one of the most uniquely powerful features of lisp, as you get into more advanced stuff
[20:37:34] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[20:39:34] *** Quits: tyson2 (~user@cpe00fc8d34ff03-cm00fc8d34ff00.sdns.net.rogers.com) (Remote host closed the connection)
[20:39:58] *** Quits: aeth (~aeth@user/aeth) (Ping timeout: 260 seconds)
[20:41:48] *** Joins: aeth (~aeth@user/aeth)
[20:46:03] <cyberbanjo> If I do (prin1 (format t "~a " number)
[20:46:14] <cyberbanjo> ) How can I not get NILs
[20:47:30] <cyberbanjo> NVM format returns nil but also just prints no need for prin1
[20:47:57] <White_Flame> if you do FORMAT NIL instead of FORMAT T, then it returns a string that you can then print or do whatever with
[20:50:29] <cyberbanjo> When I tried that it printed in what I figured was a string representation: "1 ""2 ""3 ""4 "... since I wasnt buffering to a string just printing, I think it was because I was passing both the string "1 " and nil to format but idrk
[20:51:02] <White_Flame> yes, prin1 will print a string with its doublequotes
[20:51:15] <White_Flame> there's a bunch of little print operations like that, print, princ, prin1, write, etc
[20:51:23] <White_Flame> all with different behavior
[20:51:40] <cyberbanjo> Do you know of a good reference or comparison between them? 
[20:51:43] <White_Flame> sometimes it's easier to just use FORMAT to print instead of those, when such differences matter
[20:52:02] <White_Flame> well, here is _the_ reference: http://www.lispworks.com/documentation/HyperSpec/Body/f_wr_pr.htm
[20:52:20] <White_Flame> "princ is just like prin1 except that the output has no escape characters. It binds *print-escape* to false and *print-readably* to false. The general rule is that output from princ is intended to look good to people, while output from prin1 is intended to be acceptable to read."
[20:52:48] <cyberbanjo> Love
[20:53:05] <White_Flame> CLHS is your friend, but it is a dense reference, not tutorial material
[21:09:09] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[21:10:02] <Jacobis9000> I have to say on the whole I hugely enjoy the little exercises in this book
[21:10:32] <Jacobis9000> except that one I didn't understand, turning COND into AND
[21:12:08] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[21:12:36] *** Quits: bcasiello (~bcasiello@066-189-087-112.biz.spectrum.com) (Ping timeout: 268 seconds)
[21:12:52] <beach> What book is that?
[21:13:24] <Jacobis9000> Common Lisp a Gentle Intro
[21:13:31] <beach> Ah, OK.
[21:14:50] <Jacobis9000> I just made a function first using COND, then using IF, and now using AND/OR
[21:14:59] *** Joins: bcasiello (~bcasiello@066-189-087-112.biz.spectrum.com)
[21:15:05] <Jacobis9000> it's fun!
[21:15:16] <Jacobis9000> I am looking forward to coding actual programs
[21:16:51] <Jacobis9000> I just hope it sticks, because it is not like programming in other languages
[21:24:56] <White_Flame> it's a lot closer to other popular languages compared to prolog or haskell etc
[21:28:42] <cyberbanjo> CL kinda seems like a weird old python imo
[21:29:02] <White_Flame> CL has syntactic regularity, python has none
[21:29:15] <edgar-rft> Learning Lisp only *looks* difficult but in realiy it isn't. It's always (function argument-1 argument-2 ...) There are only approx 20 or so exceptions to this evaluation scheme, everything else is always the same.
[21:29:17] <Jacobis9000> yes that is the nice thing about CL compared to python
[21:29:27] <Jacobis9000> python has terrible syntax, not as bad as Swift though
[21:29:44] <White_Flame> erlang is surprisingly bad in that regard, too
[21:30:05] <cyberbanjo> I wish more langauages had erlangs bitsyntax pattern matching on binary seems coolaf
[21:30:37] <White_Flame> of course, individual things like that are easily constructable in CL
[21:31:12] <Jacobis9000> ok I am stuck again, I have to rewrite IF using AND/OR in a way that never fails
[21:31:32] <White_Flame> seems easy enough ;)
[21:31:51] <White_Flame> but then again, have you had classes or anything in boolean logic?
[21:32:08] <White_Flame> if so, then you've probably already done this
[21:32:09] <Jacobis9000> heh no
[21:32:19] <Jacobis9000> I've never had any classes in logic
[21:32:25] <White_Flame> and I suspect they really mean using AND/OR/NOT
[21:33:06] <Jacobis9000> although I have got an MA in the history of ideas, but never any formal training in logic.
[21:33:25] <Jacobis9000> now I think of it, seems odd there wasn't a class on logic.
[21:33:48] <White_Flame> for (if test then else), then is true when test is true, and else is true when (not test) is true
[21:35:38] *** Joins: paule32 (~paule32@user/paule32)
[21:36:00] <Jacobis9000> so his example is (if (oddp 5) (evenp 7) 'foo) oddp 5 is true, but evenp 7 is false. 
[21:36:18] <White_Flame> evenp doesn't matter if oddp fails
[21:36:22] <White_Flame> it isn't even evaluated
[21:36:34] <White_Flame> and you can use short-cutting in AND/OR to do the same
[21:37:16] <White_Flame> but really it's not about false, but if (oddp 5) is true, then (evenp 7) is evaluated and returned
[21:37:40] <White_Flame> again, doable with AND/OR
[21:37:41] <paule32> hello
[21:37:43] <Jacobis9000> I can't see how to do this with and/or
[21:37:54] <White_Flame> what does (and x y) do when X is true, and when X is false?
[21:37:58] <paule32> this has to do with order and presendece ?
[21:38:08] <paule32> the first match, goals ?
[21:39:04] *** Joins: dra (~dra@2a04:4540:6415:8400:2de7:98e5:184c:b5e1)
[21:39:59] <Jacobis9000> I will skip this question, it's like that rewrite COND question
[21:40:22] <cyberbanjo> :)
[21:40:37] <White_Flame> you haven't answer my question there, which will help
[21:40:56] <Jacobis9000> when x is true, and continues, when x is false, and returns nil
[21:40:58] <White_Flame> what does (and x y) do when X is true, and what does it do when X is false?
[21:41:09] <White_Flame> expand on "continues"
[21:41:18] <Jacobis9000> it continues to the next thing
[21:41:30] <White_Flame> for this particular expression
[21:41:34] <Jacobis9000> until all are true and then it returns the last thing
[21:41:41] <White_Flame> right
[21:41:44] <White_Flame> which is?
[21:41:51] <Jacobis9000> y
[21:42:07] <White_Flame> right. so for (and x y), if X evalutes true then Y is returned
[21:42:21] <White_Flame> for (if x y) if X evaluates true, then Y is returned
[21:42:26] <Jacobis9000> yes
[21:42:44] <White_Flame> now for (if (not x) z) ...
[21:43:27] <Jacobis9000> if not x then z
[21:43:29] <Jacobis9000> ??
[21:43:34] <White_Flame> which is the same as (if x nil z)
[21:43:43] <Jacobis9000> eh?
[21:43:48] <White_Flame> combining the two, you get (if x y z)
[21:43:52] <White_Flame> y = then, z = else
[21:43:58] <Jacobis9000> you've lost me
[21:44:07] <White_Flame> you have the "then" case, and the "else" case for IF
[21:44:20] <White_Flame> if X is true, then you return the "then" case, as in (and x then)
[21:44:33] <White_Flame> if X is false,t hen you return the "else" case, as in (and (not x) else)
[21:45:00] <White_Flame> only one of those 2 cases will be used
[21:45:09] <White_Flame> either one or the other
[21:45:15] <White_Flame> either one OR the other
[21:47:04] <White_Flame> capice? :)
[21:47:15] <Jacobis9000> no
[21:47:19] <White_Flame> *capisce
[21:47:29] <White_Flame> (and x y) = if x then return y
[21:47:32] <White_Flame> right?
[21:47:44] <Jacobis9000> ok
[21:47:54] <White_Flame> (and (not x) z) = if x is false, then return z
[21:48:12] <White_Flame> right?
[21:48:15] <Jacobis9000> ok
[21:48:40] <White_Flame> (if x y z) = if x is true, then return Y.  OR else, if x is false, then return Z
[21:48:56] <White_Flame> right?
[21:49:00] <Jacobis9000> yeah
[21:49:20] <White_Flame> in other words, (or (if x y) (if (not x) z))
[21:49:28] <White_Flame> right?
[21:49:51] <pjb> White_Flame: more precisel, it means: evaluate x; if the main result is true then evaluate y and return its values, otherwise evaluate z and return its values.
[21:50:15] <White_Flame> pjb: that doesn't work for this, because X is technically evaluated twice, which is an externality for the way these problems have been worded
[21:51:06] <Jacobis9000> ok I think I fixed it
[21:51:11] <Jacobis9000> I will pastebin hang on
[21:51:24] <White_Flame> ok, and my last expression is exactly the same as (or (and x y) (and (not x) z))
[21:52:08] <White_Flame> (and the edge cases of "but what if X is T and Y is NIL, so it will take the other OR branch?" still hold if you work them through)
[21:52:57] <Jacobis9000> https://pastebin.com/xYtPYQE0
[21:53:19] <White_Flame> yep
[21:53:31] <Jacobis9000> that is correct? I am not certain why
[21:53:40] <White_Flame> well, we worked through the derivation
[21:53:56] <White_Flame> you do know which branch is taken, and what the correct answer is already, right?
[21:56:06] <Jacobis9000> well in this code example: (or (and (oddp 5) (evenp 7)) = nil, so or moves to (and (not (oddp 5)) 'foo) which evalautes to T so hang on I dunno
[21:56:11] <Jacobis9000> lost 
[21:56:26] <Jacobis9000> don't see why it's nil
[21:56:30] <Jacobis9000> can't follow this at all
[21:56:42] <Jacobis9000> I don't see why would you ever do this
[21:56:57] <White_Flame> (oddp 5) is true, so it returns the result from evenp, which is NIL
[21:57:03] <White_Flame> so that is the correct answer
[21:57:29] <Jacobis9000> but or is looking for a non-nil return value
[21:57:34] <White_Flame> the other branch is ignorable.  The (and (not <test>) ...) ensures that it stays NIL and that the other branch is skipped
[21:57:38] <Jacobis9000> so it should ignore the first and and move to the second
[21:58:03] <White_Flame> if you had (or (and <test> <then>) <else>), then the <else> expression would be returned accidentally
[21:58:10] <White_Flame> adding (not <test>) ensures that it's not
[21:58:23] <White_Flame> if the correct answer is NIL, then the whole thing evaluates to NIL
[21:58:29] <Jacobis9000> sorry I can't understand this and it is time to stop thinking about it and move on
[21:58:49] <White_Flame> yeah, this was not a good introductory case, it should have been presented with a non-NIL answer first
[21:59:20] <White_Flame> again, for somebody well versed in logic, this all makes familiar sense.  but it may not be intuitive otherwise
[21:59:52] <White_Flame> but I think you understood enough of the structure to have the benefit of it
[22:00:51] <Jacobis9000> it was ten years ago I last read philosophy and I had no training in logic anyway, I have no idea how to write formal logic
[22:01:31] <Jacobis9000> the book gives the code I wrote but no explanation for why it works as it works
[22:02:10] <White_Flame> yeah, it likely assumes it's already known.  don't worry about it
[22:04:37] *** Joins: lisp123 (~lisp123@5.30.23.247)
[22:05:15] <Jacobis9000> I feel like I am on the edge of understanding 
[22:05:29] <Jacobis9000> but I think I've had enough coding for today
[22:08:09] <Jacobis9000> so I just did C-x 0 to close my file, and C-x C-v to open a new one, and instead of opening it alongside the slime REPL, it has completely replaced the slime REPL, how do I get the slime REPL back??
[22:08:46] <lisp123> C-x b
[22:08:52] <lisp123> *s ---> autocomplete
[22:08:54] <lisp123> try that
[22:09:23] <lisp123> *slime-re ... is what th ebuffer is called
[22:10:01] <lisp123> (global-set-key (kbd "C-c s") #'(lambda () (interactive) (switch-to-buffer "*slime-repl sbcl*"))) 
[22:10:02] <White_Flame> C-x 0 doesn't close the file, it only closes the emacs panel
[22:10:10] <White_Flame> C-x C-k closes the actual file
[22:10:18] <Jacobis9000> I did C-x b *slime-repl and it opened a new window not sharing the screen called *slime-repl
[22:10:21] <lisp123> I like to use the above in my .emacs to make life easier (slime doesn't have the best window management)
[22:10:46] <Jacobis9000> I am constantly quitting out of emacs and restarting the whole thing
[22:10:59] <lisp123> Jacobis9000: Yeah, takes time to get used to
[22:11:00] <Jacobis9000> I can't say I like it at all
[22:11:16] <lisp123> Stick with it (I plead), it really does get pretty good after some time
[22:11:21] <White_Flame> if you C-x 0 your buffer, it's still there in the C-x b buffer list
[22:11:35] <Jacobis9000> it needs a page which lists all windows
[22:11:36] <lisp123> (winner-mode 1)                               ;; C-c <- to undo and C-c -> to re-do 
[22:11:38] <White_Flame> recall that emacs was written at a time where you just had a fullscreen text terminal, and it did this multi-file thing within it itself
[22:11:40] <lisp123> Is useful
[22:11:48] <lisp123> to add to your .emacs
[22:12:02] <lisp123> Then C-c left arrow and C-c right arrow lets you revert to your previous window set up
[22:12:12] <lisp123> Jacobis9000: C-x C-b to get list of open files in the background
[22:12:30] <White_Flame> also, compare it to standard text editors, where you get a bunch of open files but can only ever see one at a time
[22:13:45] <White_Flame> "Ultimate N00b SLIME/Emacs Cheat Sheet": http://pchristensen.com/wp-content/uploads/2008/02/slimecommands.pdf
[22:14:07] <Jacobis9000> where should I insert (winner-mode 1)
[22:14:11] <lisp123> Jacobis9000: Give yourself 3 months with Emacs (and Common Lisp), and I promise you your life will be changed forever. Okay, that's enough for me today :D
[22:14:21] <lisp123> C-x C-f then ~/.emacs
[22:14:23] <lisp123> add it in there
[22:14:28] <White_Flame> and yeah, I'm not en emacs fan either, but I deal with it because it's the best supported CL dev environment
[22:14:30] <Jacobis9000> anywhere?
[22:14:35] <lisp123> Yes
[22:14:56] <lisp123> Then save the file and you might need to restart emacs (but try C-x e (with your cursor right after the closing paranthesis)
[22:15:00] <lisp123> And see if it works
[22:15:41] <lisp123> C-x 3 to split vertically, C-x 2 to split windows horizontally, C-x 0 to close current window, they will be your friends
[22:16:03] <lisp123> White_Flame: Are you more of a VIM fan?
[22:16:04] <White_Flame> C-x 0 only hides a window, it doesn't close it
[22:16:06] <White_Flame> no
[22:16:22] <White_Flame> I'd be much more of a modern IDE fan
[22:16:46] <lisp123> (technically, close the window, and hide the buffer ;))
[22:17:04] <lisp123> White_Flame: Some modern IDEs are definitely nice
[22:17:39] <White_Flame> emacs and vim are clunky relics, whose few nicer programmatic features would be welcome in modern environments
[22:18:06] <Jacobis9000> but C-x 2 does not split my windows horizontally, it opens ANOTHER instance of the same window I am on split horizontally with the window I was on
[22:18:18] <White_Flame> and their presence reinforce the standard of 1960s-era development practices
[22:18:36] <cyberbanjo> What are post-1960s development practices?
[22:18:59] <White_Flame> cyberbanjo: none really exist yet, but I hold out hope :-P
[22:19:17] <cyberbanjo> What's lacking?
[22:19:21] <White_Flame> it's all just monospace dead text files, with sugar on top
[22:19:35] <cyberbanjo> Hmm, you dont use like structural editing? Then its trees
[22:19:56] <lisp123> Jacobis9000: Yes, so a "window" means like a small box within your Emacs as you see. In Emacs, "frames" refer to what you think of as windows
[22:20:04] <White_Flame> no actual structural editing, no ability to format or link anything in your source code (eg, have embedded document features), all functions/expressions are constrained to a single fixed textual representation, and in their order in files, etc
[22:20:05] <lisp123> windows subdivide a "frame"
[22:20:09] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[22:20:35] <lisp123> and files are in "buffers". Buffers can either be visible in a window, or hidden
[22:20:49] <lisp123> C-x b is to change *B*uffer, for example
[22:20:59] <lisp123> Annoying terminology, but you get used to it
[22:21:00] <White_Flame> you can also have multiple windows viewing a single buffer, if you want
[22:21:07] <Jacobis9000> ok so I now have got the REPL back, but I've lost the window with my file in it 
[22:21:11] * Jacobis9000 pulls out his hair
[22:21:18] <White_Flame> C-x b <tab>
[22:21:26] <White_Flame> see all your buffers
[22:21:33] <White_Flame> C-x b <enter> just toggles to the prior buffer
[22:21:42] <White_Flame> those are the 2 main things you need
[22:21:58] <lisp123> Jacobis9000: C-x o to switch between windows. So I suggest subdividing into 2 windows via C-x 2 or C-x 3, put REPL in one and file in the other
[22:22:00] <cyberbanjo> Jacobis9000: Have you tried the emacs tutorial? It's an interactive way to learn about how emacs talks about it self, how to understand it
[22:22:04] <cyberbanjo> C-h t
[22:22:05] <lisp123> Once you get used to it, its pretty badass
[22:22:34] <Jacobis9000> that is what I am trying to do lisp123
[22:23:00] <Jacobis9000> my method so far has been to quit emacs, and restart from beginning every time I keep losing windows like this
[22:23:06] <Jacobis9000> how do you do the emacs tutorial?
[22:23:13] <cyberbanjo> C-h t
[22:23:25] <White_Flame> you don't "lose" windows, just like you don't lose tabs in a "normal" text editor when you open up a new file
[22:23:28] <cyberbanjo> or M-x help-with-tutorial
[22:23:40] <Jacobis9000> that does not work cyberbanjo
[22:23:49] <lisp123> C-? t try
[22:24:05] <White_Flame> Jacobis9000: you should have a menu bar with a "Buffers" entry and simply use the mouse to pick from your open buffers
[22:24:18] <Jacobis9000> the mouse? I can't use the mouse man
[22:24:22] <Jacobis9000> this is in the terminal
[22:24:30] <White_Flame> uh
[22:24:33] <White_Flame> how did you start emacs?
[22:24:51] <White_Flame> or are you not on your own desktop session?
[22:24:57] <Jacobis9000> cd ~/coding/lisp/exercises 
[22:25:02] <Jacobis9000> emacs file.lisp
[22:25:08] <lisp123> Jacobis9000: Try to avoid restarting Emacs. Tell what you see exactly now and we will guide you
[22:25:10] <White_Flame> and that didn't open up the GUI version of emacs?
[22:25:51] <Jacobis9000> I didn't realise there was a GUI version
[22:26:08] <cyberbanjo> How did you install emacs? Maybe you installed the one compiled without X libraries / no GUI?
[22:26:09] <Jacobis9000> so now I have the REPL in one big window, and a small thin window with a list of buffers
[22:26:36] <Jacobis9000> my aim: file on top, REPL on bottom
[22:26:53] <Jacobis9000> so I can C-x o between them and type my code to save into a file, or run it in the REPL
[22:26:57] <Jacobis9000> that is what I have been doing
[22:27:08] <Jacobis9000> but to get to that, I have to keep restarting emacs
[22:27:09] <lisp123> Okay
[22:27:19] <lisp123> Do C-x 2 now
[22:27:32] <lisp123> Confirm that you will have 2 windows with the REPL
[22:27:37] <Jacobis9000> confirmed
[22:27:45] <lisp123> Is the cursor in the top or bottom half?
[22:27:54] <Jacobis9000> top
[22:28:08] <lisp123> Type C-x C-b and tell us what buffers are listed
[22:29:04] <Jacobis9000> *slime-repl sbcl*, myfile.lisp, *scratch*, *messages*, *slime-events*, *completions*, *inferior-lisp*
[22:29:17] <lisp123> And you want to go to myfile.lisp into the top window?
[22:29:23] <Jacobis9000> yes please
[22:29:36] <lisp123> So do C-x b and type my <tab>
[22:29:44] <lisp123> (tab autocomplete and press enter)
[22:30:08] <Jacobis9000> AHA!
[22:30:15] <lisp123> Now try C-x o
[22:30:20] <Jacobis9000> ok now I still have the list of buffers up, how do I close that?
[22:30:22] <lisp123> Your cursor should move to the bottom window
[22:30:45] <lisp123> It should not be up, but in any case, navigate to it by going C-x o
[22:30:50] <lisp123> until the cursor is in that window
[22:30:54] <lisp123> then do C-x 0
[22:31:00] <White_Flame> or q
[22:31:04] <Jacobis9000> aha sorted, I am getting the hang now
[22:31:29] <White_Flame> also, I'd say don't use C-x C-b.  Instead, do C-x b <tab> for a temporary list of your buffers instead of a permanent one
[22:31:31] <Jacobis9000> My cheat sheet that I printed off is missing a lot of crucial commands
[22:31:33] *** Quits: bcasiello (~bcasiello@066-189-087-112.biz.spectrum.com) (Ping timeout: 268 seconds)
[22:31:38] <lisp123> Great. C-x 2 C-x 3 C-x b C-x C-b C-x C-f C-x C-s C-x o, those should be the most useful ones for you now
[22:31:54] <White_Flame> probably need some commas in that list
[22:32:04] <lisp123> White_Flame: Yeah what you say is right, Jacobis9000 do that
[22:32:04] <Jacobis9000> lol
[22:32:35] <Jacobis9000> ok I will run the tutorial now and see if that teaches me
[22:32:41] <Jacobis9000> and make notes like I did when I learned Vim
[22:32:55] <lisp123> Jacobis9000: Do you know how to use VIM?
[22:33:10] <cyberbanjo> Also C-h k (whats this key combo do), C-h a (let me search for emacs lisp) and C-h m (what key combos do stuff in this buffer, organized by modes)
[22:33:20] <Jacobis9000> well I can write code and textfiles in it, I don't know how to use it's more "powerful" features
[22:33:53] <lisp123> There is a mode called "EVIL MODE" which lets you use most of VIM bindings in Emacs, I'd highly recommend it given your background
[22:34:09] <lisp123> (it still pays to know the Emacs command set, but evil mode is _nice_)
[22:37:28] <Jacobis9000> is there a text file with the tutorial somewhere so I can just print it?
[22:37:35] <Jacobis9000> on my system I mean
[22:39:21] <lisp123> Dunno if you have a web browser in. your current environment
[22:39:22] <lisp123> https://www.gnu.org/software/emacs/tour/
[22:40:43] <Jacobis9000> aha I did something clever (lol) I C-x C-s the tutorial to a file on my Mac, and now I can print with lp
[22:41:03] <lisp123> https://emacsformacosx.com
[22:41:28] <lisp123> Jacobis9000: There you go, you are already well on your way to becoming an Emacs wizard ;)
[22:41:40] <lisp123> You mentioned earlier you didn't have the GUI emacs
[22:41:52] <lisp123> ^ ^ ^ that link is really good for Mac users
[22:41:58] <Jacobis9000> ok thanks
[22:50:21] <Jacobis9000> ok thanks for your help guys
[22:50:39] <Jacobis9000> I am going to drive my lorry in Euro Truck Simulator now, I need to relax
[22:50:48] <lisp123> Enjoy
[23:05:00] <lisp123> Is there a way to achieve (defmethod my-function ((obj atom))?
[23:05:09] <lisp123> I get ATOM is not a class
[23:05:40] <lisp123> I tried (obj (typep atom)) and that didn't work either. Worst case I have to use the default method in defgeneric but I was hoping for a more 'specialised' solution
[23:11:47] <pjb> (defgeneric your-function (obj) (:method ((x t)) 'atom-stuff) (:method ((x cons)) (and 'cons-stuff (error "Not an atom"))))
[23:11:48] <White_Flame> if you have (obj list), then another (obj t) would be pretty appropriate, however (call-next-method) from the LIST specializer would also hit it
[23:12:02] <pjb> (your-function '42) #| --> atom-stuff |#  (your-function '(a . d)) #| ERROR: Not an atom |# 
[23:12:04] *** Quits: lucerne (~lucerne@ip202.ip-51-178-215.eu) (Quit: Bye)
[23:12:05] <White_Flame> and yeah, depending on where you want a pramater of NIL to go
[23:12:36] <lisp123> hmmm thanks
[23:15:54] *** Joins: greyrat (~greyrat@ip202.ip-51-178-215.eu)
[23:17:23] *** Server sets mode: +nt 
[23:19:00] *** Quits: sjl (~sjl@cpe-66-66-5-59.rochester.res.rr.com) (Quit: WeeChat 2.2-dev)
[23:43:37] *** Joins: sjl (~sjl@cpe-66-66-5-59.rochester.res.rr.com)
[23:53:05] *** Quits: mfiano (~user@2603-7081-2d02-95bd-0250-b6ff-fef3-da40.res6.spectrum.com) (Remote host closed the connection)
[23:56:04] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[23:59:07] *** Quits: Jacobis9000 (~jonaholuf@81.145.248.247) (Ping timeout: 268 seconds)
