[00:04:10] *** Quits: makomo (~makomo@user/makomo) (Ping timeout: 240 seconds)
[00:05:07] *** Quits: lisp123 (~lisp123@45.130.83.208) (Ping timeout: 252 seconds)
[00:30:15] *** Quits: waleee (~waleee@h-98-128-228-119.na.cust.bahnhof.se) (Quit: WeeChat 3.2)
[00:32:07] *** Quits: rain3 (~rain3___@2a02:2f09:d30b:1300:514:bcc7:8202:1798) (Ping timeout: 245 seconds)
[00:39:02] *** Joins: lisp123 (~lisp123@45.130.83.208)
[00:45:02] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[00:45:03] *** Joins: makomo (~makomo@user/makomo)
[00:56:55] *** Quits: lisp123 (~lisp123@45.130.83.208) (Remote host closed the connection)
[01:05:23] *** Joins: lisp123 (~lisp123@45.130.83.208)
[01:09:53] *** Joins: lisp123_ (~lisp123@45.130.83.208)
[01:10:45] *** Quits: lisp123 (~lisp123@45.130.83.208) (Ping timeout: 268 seconds)
[01:12:16] *** Joins: silasfox (~sbv@xdsl-87-78-57-101.nc.de)
[01:12:58] *** Quits: lisp123_ (~lisp123@45.130.83.208) (Read error: Connection reset by peer)
[01:14:58] *** Joins: lisp123 (~lisp123@45.130.83.208)
[01:32:25] *** Quits: silasfox (~sbv@xdsl-87-78-57-101.nc.de) (Ping timeout: 248 seconds)
[01:42:57] *** Quits: lisp123 (~lisp123@45.130.83.208) (Remote host closed the connection)
[01:54:17] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 244 seconds)
[02:21:57] *** Joins: lisp123 (~lisp123@5.30.23.247)
[02:32:36] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 250 seconds)
[02:39:17] *** Joins: [itchyjunk] (~itchyjunk@user/itchyjunk/x-7353470)
[02:53:30] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[03:17:09] *** Quits: makomo (~makomo@user/makomo) (Ping timeout: 268 seconds)
[03:46:10] *** Quits: shka (~herr@109.231.62.239) (Ping timeout: 240 seconds)
[04:12:04] *** Quits: random-nick (~random-ni@87.116.165.220) (Ping timeout: 252 seconds)
[05:03:04] *** Joins: lisp123 (~lisp123@5.30.23.247)
[05:11:28] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[06:35:21] *** Quits: sts-q (~sts-q@91.200.108.204) (Ping timeout: 248 seconds)
[06:45:40] *** Joins: sts-q (~sts-q@91.200.108.251)
[07:30:37] *** Quits: jeffrey (~jeffrey@80-115-60-193.cable.dynamic.v4.ziggo.nl) (Ping timeout: 252 seconds)
[07:32:40] *** Quits: sts-q (~sts-q@91.200.108.251) (Ping timeout: 240 seconds)
[07:46:25] *** Joins: sts-q (~sts-q@91.200.108.138)
[09:09:24] *** Joins: lisp123 (~lisp123@5.30.23.247)
[09:11:31] *** Quits: [itchyjunk] (~itchyjunk@user/itchyjunk/x-7353470) (Remote host closed the connection)
[09:14:10] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 240 seconds)
[09:38:14] *** Joins: fef (~thedawn@user/thedawn)
[09:40:14] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[09:40:52] *** Joins: retropikzel (~retropikz@2001:999:200:4ae7:e4f6:828a:e4c3:7465)
[09:43:48] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 268 seconds)
[10:00:35] *** Joins: kstuart (~user@185.92.25.246)
[10:07:35] *** Joins: selwyn (~selwyn@user/selwyn)
[10:34:14] *** Quits: fengshaun (~fengshaun@68.69.214.210) (Quit: bibi!)
[10:34:35] *** Joins: fengshaun (~fengshaun@68.69.214.210)
[10:45:38] *** Joins: lisp123 (~lisp123@5.30.23.247)
[11:12:59] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[11:13:12] *** Joins: lisp123 (~lisp123@5.30.23.247)
[11:13:15] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[11:25:42] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[11:28:54] *** Joins: shka (~herr@109.231.62.239)
[11:29:04] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 250 seconds)
[11:40:09] *** Joins: rain3 (~rain3___@2a02:2f09:d30b:1300:514:bcc7:8202:1798)
[11:51:17] *** Joins: makomo (~makomo@user/makomo)
[11:57:31] *** Quits: retropikzel (~retropikz@2001:999:200:4ae7:e4f6:828a:e4c3:7465) (Quit: Leaving)
[12:25:10] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[12:29:16] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[12:32:20] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 250 seconds)
[12:35:36] *** Joins: hendursa1 (~weechat@user/hendursaga)
[12:38:03] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 244 seconds)
[13:18:19] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[13:19:31] *** Joins: selwyn (~selwyn@user/selwyn)
[13:19:46] *** Quits: selwyn (~selwyn@user/selwyn) (Remote host closed the connection)
[13:20:10] *** Joins: selwyn (~selwyn@user/selwyn)
[13:21:18] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 250 seconds)
[13:42:02] *** Quits: santiagopim (~user@90.166.59.254) (Remote host closed the connection)
[13:42:25] *** Joins: santiagopim (~user@90.166.59.254)
[14:06:31] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[14:21:58] *** Quits: kstuart (~user@185.92.25.246) (Ping timeout: 250 seconds)
[14:25:44] *** Joins: lisp123 (~lisp123@5.30.23.247)
[14:27:09] *** Joins: selwyn (~selwyn@user/selwyn)
[14:27:54] *** Quits: selwyn (~selwyn@user/selwyn) (Remote host closed the connection)
[14:28:19] *** Joins: selwyn (~selwyn@user/selwyn)
[14:30:12] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 250 seconds)
[14:40:48] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[15:11:41] *** Joins: random-nick (~random-ni@87.116.181.225)
[15:13:08] *** Joins: tyson2 (~user@70.31.33.162)
[15:21:40] *** Joins: selwyn (~selwyn@user/selwyn)
[15:26:41] *** Joins: dlowe (~dlowe@user/dlowe)
[15:32:27] *** Quits: dlowe (~dlowe@user/dlowe) (Remote host closed the connection)
[15:36:45] *** Joins: ln43 (~ln43@user/ln43)
[15:38:30] <ln43> Hi all, anyone knows why when i try to load a .lisp file that begins with (ql:quickload '(something-here)) i get: Symbol's function definition is void: ql:quickload ? 
[15:39:29] <ln43> running the same content of that file from the lisp repl is actually working
[15:39:59] <ln43> but anyhow, should it be related to the how packages are handled in a certain sense ?
[15:40:30] <ln43> ok reading from Emacs using M-x load-file filename.lisp
[15:46:16] <random-nick> how are you loading it?
[15:46:33] <random-nick> if you're using sbcl --script then sbcl won't load your .sbclrc
[15:46:42] <random-nick> which contains code which loads quicklisp
[15:47:03] <ln43> ok, i'm using Portacle right now
[15:47:11] <ln43> and Sbcl is preinstalled
[15:47:50] <ln43> but compiling that .lisp file with compile-file from the repl i get a .fasl file
[15:48:00] <ln43> ... strange
[15:48:33] <ln43> anyway i would like to load directly the .lisp file inside the repl
[15:48:50] <random-nick> oh, I see the problem
[15:48:57] <random-nick> load-file is emacs' function
[15:49:00] <ln43> maybe there is a command shortcut of an unknown repl command
[15:49:04] <random-nick> to load an emacs lisp file
[15:49:15] <ln43> it's a common lisp file
[15:49:21] <random-nick> to load a common lisp file use slime-load-file
[15:49:32] <ln43> let me check
[15:50:15] <ln43> many thanks it's working
[15:50:28] <ln43> and which command should i use from the repl instead?
[15:51:44] <random-nick> from the slime repl? there's the standard function LOAD
[15:52:25] <random-nick> which you could use like (load "path/to/file")
[15:53:15] <ln43> ok
[15:53:36] <random-nick> for loading more complex projects with multiple files you should read up on ASDF
[15:55:07] <ln43> is it not possible use quicklisp to simplify a bit those things ?
[15:55:49] *** Joins: lisp123 (~lisp123@5.30.23.247)
[15:55:59] <random-nick> well, ASDF is analogous to what a build system is for other languages
[15:56:04] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[15:56:26] *** Joins: lisp123 (~lisp123@5.30.23.247)
[15:56:40] *** Quits: lisp123 (~lisp123@5.30.23.247) (Client Quit)
[15:57:00] <random-nick> projects contain .asd files which describe the name, dependencies and other information about a system along with what files belong to it and how to load them
[15:57:30] <ln43> ok, i should still see how to structure a project
[15:58:31] *** Joins: lisp123 (~lisp123@5.30.23.247)
[15:59:01] <random-nick> quicklisp is built on top of ASDF and a simplification of how quickload works is that it hooks into ASDF to download missing systems from quicklisp and then tells ASDF to load the specified systems
[15:59:22] <ln43> anyway, just for clarification: can the terms project and package could be used interchangeably ?
[16:00:14] <random-nick> no, because that would cause confusion
[16:00:33] <random-nick> in common lisp, package is what's defined with defpackage
[16:01:07] <random-nick> it's an object with associated symbols, like modules in other languages
[16:01:48] <random-nick> and a project/system can contain multiple common lisp packages
[16:02:19] <ln43> ok, clear explanation
[16:02:51] <lisp123> ln43: What random-nick said. In Common Lisp, packages are used to store symbol names so that you don't have clashes between two names (e.g. if two programmers both use the symbol 'A' - which one do we refer to when we say A? To avoid any name clashes, we can register each in their own package, so refer to one by programmer-a-package::A and the other by programmer-B-package::B) 
[16:03:12] <lisp123> Replace programmer-a-package & programmer-b-package with more sensible names
[16:04:44] <ln43> ok, many thanks... it's clear
[16:05:23] <ln43> yes like happens for modules using python for example, in that case using . instead of :
[16:05:33] <ln43> but the concept maybe is similae
[16:05:39] <ln43> similar
[16:05:43] <lisp123> I am not sure about python
[16:05:52] <lisp123> But note that the package doesn't 'hold' the program
[16:05:56] <lisp123> its just a lookup table
[16:06:06] <lisp123> which then points to the actual code / data
[16:06:50] <lisp123> so package is just a lookup table, and project is what you normally think of one
[16:07:26] <lisp123> It can get confusing because one might _name_ a package and project with the same name , e.g. "my super duper app"
[16:07:48] <lisp123> "my super duper app" as the package name refers to the lookup table which stores the mapping of all the symbols associated with that package
[16:08:13] <lisp123> "my super duper app" as a project / system is the collection of files which are your actual source code
[16:09:09] <lisp123> Lisp places a lot of importance on symbol names, which is why you may see many of us trying to be very clear on why the distinction between package and system is important :)
[16:21:39] <ln43> yes but why call system something that using the term project looks more intuitive to understand what it stands for ?
[16:22:11] <ln43> reading above i understand that a project and a system are the same thing 
[16:22:49] <ln43> anyway yes, i should read something about just to start
[16:25:14] <lisp123> I guess system has a relatively specific term
[16:25:51] <lisp123> System = a collection of files, usually with a particular build order (i.e. compile / load dependencies first) so that everything compiles / loads correctly
[16:26:29] <lisp123> I'm not sure if project actually has any specific meaning in Common Lisp, but to me its similar to what a project is. I got confused as well initially between packages vs. systems so you are not alone :)
[16:26:43] <lisp123> similar to what a system* is
[16:27:06] <ln43> ok, so a system could be made up of many projects that are written used many packages
[16:27:17] <lisp123> yes of course
[16:27:26] <ln43> with packages i refer to all those available as libraries
[16:27:30] <ln43> made by others
[16:27:30] <lisp123> a system could be made up of many systems
[16:27:38] <lisp123> no packages are lookup tables
[16:27:41] <lisp123> libraries = systems
[16:27:49] <ln43> ops
[16:28:01] <lisp123> packages are just a lookup table to avoid nameclash - what if two libraries used the same function "super-function"
[16:28:21] <lisp123> If we store the names in their individual packages, we can appropriately refer to each when you try using both libraries at the same time
[16:28:27] <lisp123> Nothing more, nothing less
[16:29:29] <lisp123> its confusing cause in other languages, people might call libraries packages
[16:30:23] <edgar-rft> ln43: Lisp is a very old language so there often was the problem that Lisp used words for things that later were named differently in other programming languages while Lisp kept the old names. That's the main reason why in Lisp many things seem to have weird names. Luckily the weird names are used very consistently in Lisp, they don't have different meanings in different contexts for example, so you only 
[16:30:23] <edgar-rft> have to learn them *once*. But I agree that this is often confusing, especially for newbies.
[16:30:23] <ln43> ok so each library has its own package
[16:30:27] <ln43> associated
[16:31:02] <lisp123> usually yes
[16:31:24] <ln43> and when i write a project then i'm creating a new system
[16:31:43] <lisp123> to create a system, you need to create a .ASD file (Another System Definition)
[16:31:50] <ln43> ok
[16:32:07] <ln43> yes right, that is the meaning of aSd
[16:32:20] <lisp123> System = Collection of Files --> An .asd file writes down which files make up that collection and which order to load them
[16:32:49] <lisp123> ln43: Yeah its a nice name isn't it :)
[16:33:04] <ln43> ok i'm noting that for the first time
[16:33:12] <ln43> so system was there for a purpose
[16:33:27] <lisp123> yes, so package & system have specific meanings in Common Lisp
[16:33:45] <lisp123> I'm not aware of project having any specific meaning, but somebody much smarter can confirm if there is one
[16:33:48] <edgar-rft> ASDF = Another System Definition Facility - details see -> https://common-lisp.net/project/asdf/
[16:34:15] <lisp123> edgar-rft: Does project have a specific meaning in Common Lisp?
[16:35:13] <edgar-rft> I'm not totally sure, the "system" terminology comes from the old Lisp-Machine computers.
[16:36:23] <edgar-rft> lisp123: your explanations are very good so far, I only try to interfere if I really have something important to say :-)
[16:37:28] <lisp123> edgar-rft: That's a relief :) The concepts of systems were relatively new to me, so ln43 you are in good company
[16:37:51] <edgar-rft> beach may decide whether "project" has a fixed meaning in Lisp, he *teaches* Lisp at a university 
[16:37:52] <ln43> many thanks
[16:40:25] <edgar-rft> ln43: the usually recommened book (and the best Lisp beginner intro I know) is Peter Seibel's "Practical Common Lisp", readable for free here -> https://gigamonkeys.com/book/
[16:40:40] <ln43> when i create a new system using defsystem i should take care of the order in which are specified dependencies in :depends-on () ?
[16:41:10] <ln43> ok i will try to get that book
[16:44:43] <edgar-rft> ln43: Unfortunately I'm not an ASDF/defsystem expert, I usually just (load "my-lisp-code.lisp") what is not a really good practice for bigger projects that are using external libraries.
[16:45:19] <lisp123> I think it doesn't depend on the order, since each is self contained
[16:45:30] <lisp123> but within :file, the order matters
[16:46:07] <lisp123> https://ashok-khanna.medium.com/introduction-to-asdf-d25efe2780c2
[16:46:35] <random-nick> does it matter if you didn't specify :serial t?
[16:47:24] <lisp123> random-nick: No, I don't think so. But you have the issues with modules not being able to see their parent files, so from that perspective I like to say it matters
[16:48:12] <lisp123> I'm curious on how to treat modules that depend on files outside of them, if you have an answer? I have just done :serial t for convenience as a result
[16:51:33] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 258 seconds)
[16:53:05] <lisp123> I think the best approach to deal with modules is to have .asd file in each module and avoid using the :module command generally. IIRC beach recommended something similar before but I am equally likely to be mistaken
[16:53:36] *** Joins: waleee (~waleee@h-98-128-228-119.NA.cust.bahnhof.se)
[16:54:46] <ln43> yes but in that way you increase the total number of the .asd files or not ?
[16:55:59] <ln43> in my opinion is better have maybe only one .asd file, just for clarity, and then use (:module ... ) or (:file ...) 
[16:56:29] <ln43> ok but it is a first opinion only 
[16:57:04] <ln43> i prefer have in only one file all the "dependencies" listed so it's easier to take care of them
[16:57:26] <lisp123> ln43: Yeah, that's what I am doing too. I was just doing (load ...) before :)
[16:57:34] <ln43> of course, not using any automating tool
[16:57:39] <lisp123> Good to know the theory so that later you know when to use it etc.
[16:57:40] <random-nick> lisp123: the ASDF file has an example of a module depending on a file which is a toplevel component of the system https://common-lisp.net/project/asdf/asdf.html#A-more-involved-example
[16:58:06] <lisp123> ln43: But I agree with you in the sense, why overcomplicate in small projects
[16:58:10] <random-nick> I don't know what to do if it depends on a file in another module, I guess depend on the whole module?
[16:59:05] <lisp123> random-nick: thanks for the link, useful to see how it works
[17:00:13] <random-nick> meant to say ASDF manual, not ASDF file
[17:00:19] <lisp123> random-nick: I think so too
[17:01:05] *** Quits: tyson2 (~user@70.31.33.162) (Quit: ERC (IRC client for Emacs 27.2))
[17:01:25] <lisp123> random-nick: note that the "package" in the example you linked, within the :module, is a separate file I believe to the (:file "package") above it
[17:02:04] <lisp123> I think basically :file / :module just scan the current directory for files named with the string provided
[17:02:19] <lisp123> so :module will try to find "package.lisp" within the folder mod/
[17:02:52] <edgar-rft> Common Lisp has a rather huge builtin "standard library" that is included in the Common Lisp language specification and available in *all* Common Lisp implementations by default. This means that in Common Lisp you have to deal with much less external libraries than in other programming languages.
[17:06:48] *** Joins: lisp123_ (~lisp123@45.130.83.191)
[17:06:50] <edgar-rft> The main reason why I'm such a bad ASDF expert is that I just simply never had such a huge pile of external libraries that I needed to write an ASD file for it.
[17:08:54] <edgar-rft> Of course that doesn't mean that you (and I) should not learn ASDF. just simply because ASDF it's very handy if you want to share your code with other people :-)
[17:09:18] <ln43> ok but then what do you do to load external libraries ?
[17:09:55] <ln43> for example in the .lisp file i was looking there was a (ql:quickload (....)) as the first line
[17:10:01] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 248 seconds)
[17:10:22] <ln43> ok, it was enough simple but again, only one file was requiring those libraries
[17:11:21] <lisp123_> ln43: Do you have QuickLisp setup correctly on your computer?
[17:11:33] <random-nick> lisp123: if I'm understanding the manual correctly, the :depends-on refers to the component named "package", which was earlier in the list defined as (:file "package"), and the :file default options tell it to add .lisp to get the filename which represents the component
[17:11:50] <ln43> lisp123_ : i think so, i'm using Portacle
[17:11:57] <ln43> so basically i suppose yes
[17:12:22] <lisp123_> ln43: Great. QuickLisp will load the libraries for you
[17:13:35] <lisp123_> random-nick: oh I think you are right :) 
[17:13:40] <ln43> yes and i was reading of cl-project to create a basic system scaffold
[17:14:02] <ln43> yes maybe exists something else too
[17:14:05] <random-nick> or rather, the filename which refers to the file that comprises the component
[17:14:07] <ln43> as an alternative
[17:14:23] <edgar-rft> ln43: I nearly never have needed external libraries in the last 20 years because Common Lisp had everything builtin what I needed. Okay I agree that's a very cheap excuse for not learning ASDF but I really never needed anything other than (asdf:load-system "system-name").
[17:15:14] <lisp123_> random-nick: yes, you are right. Very useful for me to learn this, thanks
[17:15:59] <lisp123_> ln43: Could you clarify on your aims? Do you just want to create a structure for your own project to go into?
[17:16:17] <ln43> and does asdf take care of dependencies automatically ? 
[17:16:44] <ln43> i mean for example it downloads them if something is missing ?
[17:16:59] <ln43> no i don't think
[17:17:00] <lisp123_> ln43: That's basically quicklisp
[17:17:05] <ln43> right
[17:17:25] <lisp123_> So ASDF _assumes_ you downlaoded each dependency and each dependencies dependencies (recursion!)
[17:17:30] <lisp123_> Quicklisp does it for you
[17:17:39] <ln43> so why learn how to use asdf if exists quicklisp ?
[17:17:46] <lisp123_> Quicklisp uses ASDF
[17:17:58] <ln43> ok but it does something more in addition
[17:17:59] <lisp123_> ASDF tells you _how_ to build your system, i.e. which files to load in which order
[17:18:18] <ln43> ok...
[17:18:35] <lisp123_> Quicklisp combines this with an auto downloader to download everything for you (also QuickLisp does some checks to make sure dependencies work well with each other)
[17:18:41] <lisp123_> (so you don't get dependency hell)
[17:18:58] <ln43> that is a good thing
[17:19:19] <lisp123_> Yeah, its a secret weapon of CL - QL makes its very easy to do stuff very fast
[17:19:35] <ln43> otherwise yes it would be like install something on a distro without a package manager to say
[17:19:49] <ln43> not so easy... and a lot of time required
[17:19:58] <lisp123_> Yes
[17:20:24] <lisp123_> A neat trick - you can use quicklisp to download your dependencies, and then in the future, you can remove the QL command from your code and just use ASDF directly
[17:20:31] <lisp123_> That's what I do
[17:20:40] <ln43> suppose install X without nothing... maybe a month of time is not enough
[17:21:10] <ln43> ok... but again, i like quicklisp because it make things more easy to digest
[17:21:41] <lisp123_> Yes, its very good :)
[17:27:06] <ln43> and external libraries are required if one wants a GUI or just write a simple chat for example ...
[17:29:29] <ln43> or to do linear algebra interfacing external foreign libraries
[17:30:10] <lisp123_> You will find you can do a lot in CL without external libraries. I guess it depends on each one's style, but its not uncommon for Lisp programmers to write most things themselves
[17:31:14] <ln43> but why one have to rewrite things that already are existent, well tested and work well ?
[17:32:23] <lisp123_> Fair point
[17:32:58] <ln43> no, a good point is the reuse of well tested code to save time
[17:33:35] <ln43> and maybe rewrite only few parts but not all from scratch ...
[17:33:35] <lisp123_> Depends on the nature of programming one is doing. GUI / webserver etc. yes I agree
[17:33:50] <lisp123_> For other stuff, I like to write a lot of stuff myself
[17:34:33] <lisp123_> Because if you have a better understanding of code, you can use it in many different ways (which can be done with external libraries but IMO one would be less inclined)
[17:35:07] <ln43> ok but you understand that is not a good way... it should be like try to keep up to date and do system administration work on a linux system built from scratches 
[17:35:13] <lisp123_> lol
[17:35:15] <ln43> it makes few sense
[17:35:17] <ln43> xd
[17:35:19] <lisp123_> I don't disagree :D
[17:35:27] <ln43> that is why red hat exists :)
[17:35:40] <lisp123_> But a lot of lispers I think have this opinion, and I think its partly due to books like this https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html
[17:36:09] <lisp123_> Heck, every few weeks somebody is writing a new lisp interpreter and posting it on Hacker News :D
[17:36:22] <lisp123_> they don't even want to rely on the compiler if they could avoid it ;)
[17:37:20] <ln43> sicp was intended to be done in scheme, not CL
[17:37:32] <ln43> and there is a huge difference 
[17:37:44] <lisp123_> Its enjoyable to write things oneself - and combine and abstract based off your own code - I think Lisp programming pushes people towards that direction
[17:38:24] <lisp123_> Scheme & CL are both lisps though, the general principles are somewhat similar
[17:39:16] *** Quits: dtman34 (~dtman34@c-73-62-246-247.hsd1.mn.comcast.net) (Ping timeout: 268 seconds)
[17:39:19] <ln43> yes but creating a CL implementation conformant is a work that takes decades
[17:39:27] <ln43> for a single people or two of them
[17:39:34] <ln43> maybe three too
[17:40:04] <lisp123_> Yeah I agree, I am just saying that the nature of lisp programming IMO does make a reasonable amount of lisp programmers to do things themselves
[17:40:32] <lisp123_> Not whether that's the best use of their time
[17:42:27] <ln43> write good maintainable software is not a thing that each one can do by himself for all what he needs 
[17:42:43] <ln43> it's not humanly conceivable 
[17:44:11] <lisp123_> Yes, for reasonably scoped projects for use by others I agree
[17:44:18] <ln43> i mean , take any software an see how many bugs there are even if it was made by teams of engineers ...
[17:44:36] <lisp123_> But for hobby projects, or for personal projects - why not? One is just having fun then
[17:45:04] <ln43> maybe ok, they was working eye blindly?
[17:45:11] <beach> ln43: Though a language like Common Lisp eliminates a host of bugs that you would have in a language like C++.
[17:45:45] <beach> In particular, dangling pointers, and (to some extent) memory leaks. 
[17:46:20] <ln43> and notice how much effort is required to create clasp 
[17:46:45] <beach> Sure, but they made things hard for themselves. 
[17:46:46] <ln43> for which reason if not to reuse existing tools ?
[17:47:08] <beach> They couldn't use existing tools because of the inter-operation with C++.
[17:47:24] <ln43> but the reason is simple: it's not possible rewrite hundreds and hundreds of libraries from 0
[17:48:33] <beach> I see what you mean.
[17:49:14] <ln43> yes it  takes more time maybe
[17:49:24] <beach> The real sad part is that people use C++ to create all those libraries, thereby making life harder for themselves and for others.  And it is not even clear that it's the best way to get fast code, let alone maintainable code.
[17:49:59] <ln43> c++ or python ...
[17:50:31] <ln43> yes those languages are mainstream in the scientific community 
[17:50:38] <beach> Nobody uses Python to create libraries, or so I have been told.  It would involve a factor 50 performance penalty.
[17:51:39] <beach> Scientists are a particular breed.  They think they know everything, just because they know one domain of science.  So they believe they know how to write software too.  We can observe the result of that.
[17:51:56] <beach> Medical doctors are perhaps even worse.
[17:54:27] <ln43> ok, right... but python is used as a scripting language while before for example for the same purposes was used perl
[17:54:54] <beach> I take your word for it.  
[17:55:40] <ln43> see just for reference: http://130.149.89.49:2080/v6.14/books/cmd/default.htm?startat=pt01.html
[17:56:00] <ln43> ok abaqus is using python for that purpose to say
[17:56:31] <edgar-rft> A now retired professor of the local university once said to me that it's more important to know a little bit of possibly many things than being a specialist in only one thing.
[17:57:14] <rain3> edgar-rft: Donald Knuth doesn't agree
[17:58:19] <rain3> https://www.youtube.com/watch?v=75Ju0eM5T2c
[17:58:36] <edgar-rft> rain3: he got this opinion from watching his other professor collegues
[17:58:50] <ln43> why don't write a lisp interface to calculix ? 
[17:58:52] <ln43> xd
[17:59:09] <beach> ln43: Don't get me started...  People write software using static languages like C++ because they think it will be fast.  Then they notice they need modularity, so they use smart pointers and reference counters, or they copy objects all the time.  
[17:59:11] <beach> Already they have lost a factor 10 in performance.  Then they discover they need scripting.  So they add Python.  Now, users start writing programs in Python, so they take another factor 50 in performance penalty, and they have a mess that can't be maintained.
[17:59:59] <ln43> yes, that is the point
[18:00:02] <beach> ln43: Instead, they could have chosen to write the entire application in Common Lisp.  It would be faster, smaller, more modular, more maintainable, and easier to debug and to write "scripts" for, since no particular mechanism is required. 
[18:02:16] <ln43> yes maybe for new products that should be the preferable way, but people that are working on those tools are not motivated to learn new languages and so on... so basically this is a no return situation
[18:02:44] <beach> Right, as I often say, people spend a lot of time and energy to avoid learning Common Lisp.  
[18:02:49] <beach> Not that I understand why.
[18:03:11] <ln43> yes.... lie try to avoid to use C for the kernel... it's not so easy
[18:03:19] <ln43> just to say
[18:03:31] <beach> "kernel"?
[18:03:34] <ln43> or create an alternative OS that does not rely massively on C
[18:03:52] <beach> It is easier than to create a Unix-like OS.
[18:04:16] <ln43> so why there aren't new proposals ?
[18:04:27] <beach> What makes you think there aren't?
[18:05:40] <beach> http://metamodular.com/closos.pdf
[18:05:55] <ln43> ok, but that is only theory mostly
[18:06:03] <ln43> i mean something converted to practice
[18:06:23] <ln43> yes, already implemented 
[18:06:23] <beach> Not at all.  There are already three operating systems written in Lisp.
[18:06:33] <ln43> ops
[18:07:03] <ln43> ok but on which machines they are running ?
[18:07:23] <beach> Genera is the most advanced one, because it is commercial and has lots of effort put into it.  But Mezzano and Movitz are great examples of how much easier it is to write an OS if you do it right. 
[18:07:27] <rain3> https://github.com/froggey/Mezzano
[18:07:56] <beach> ln43: I take it you are going to add restrictions until your initial point of view is correct.
[18:08:35] <beach> It has to run on x86.  It has to have a kernel.  It must use processes.  It must be written in a language without GC.  Right?
[18:09:56] <beach> But yes, rain3 is right.  Both Mezzano and Movitz run on x86. 
[18:11:27] <beach> ln43: Lisp runs fine on stock hardware these days.  No need for special hardware.  We made great progress in compiler technology and other techniques for implementing Common Lisp.
[18:12:25] <beach> So, no, an operating system is definitely not a good example of software that has to be written in a static language with manual memory management. 
[18:12:46] <ln43> i dont' agree completely: see that for example multi-thread supports is still an "issue" for sbcl depending on the base OS
[18:13:04] <ln43> even because they don't have developers for all the available OSes
[18:13:21] <ln43> and a little extra work for porting is still required
[18:13:48] <beach> And that justifies writing an operating system in C?  I don't see the logic. 
[18:14:35] <ln43> no that is to say that i don't know how Cl should run on stock hardware if each implementation is OS dependent 
[18:15:01] <beach> And you are jumping from the language Common Lisp to a particular implementation (SBCL) that has its origins from half a century ago, and that is maintained by a handful of volunteers. 
[18:15:23] <ln43> yes because that one is a sort of standard
[18:15:49] <ln43> recommended and suggested for speed and not only for that among CL users
[18:16:02] <beach> If something runs well on stock hardware, that does not have anything to do with the operating system.
[18:16:24] <ln43> yes of course
[18:16:32] <beach> I was arguing that you don't need special hardware like Lisp machines to run Lisp efficiently, which I think you were hinting before.
[18:16:46] <ln43> but there is no CL implementation that runs everywhere as far as i know
[18:17:08] <beach> So what do you conclude from that?
[18:17:13] <beach> That it is impossible?
[18:17:20] <ln43> ok, there are for the same architectures variations based on the os
[18:17:55] <beach> The only conclusion I draw is that Common Lisp does not have massive support from rich corporations. 
[18:19:42] <random-nick> ECL and CLISP are more portable than SBCL afaik
[18:20:11] <random-nick> and ABCL runs on java which is supposedly very portable
[18:20:58] <ln43> yes but running on jvm it's like ride a monster  : /
[18:21:10] <ln43> i don't like java at all
[18:21:23] <ln43> even if it's used diffusely 
[18:21:31] <beach> Anyway, I don't much like the way this conversation is going, so I'll go back to attempting this, apparently impossible, task that I am working on.
[18:24:22] <rain3> ln43: trust me you'll like CL if you play with it .
[18:32:45] *** Quits: pjb (~pjb@user/pjb) (Ping timeout: 258 seconds)
[18:34:22] *** Quits: ln43 (~ln43@user/ln43) (Quit: Connection closed)
[18:39:38] *** Joins: [itchyjunk] (~itchyjunk@user/itchyjunk/x-7353470)
[18:44:37] *** Quits: lisp123_ (~lisp123@45.130.83.191) (Remote host closed the connection)
[18:45:34] *** Joins: tyson2 (~user@toroon12-3096782677.sdsl.bell.ca)
[18:47:14] *** Joins: nij- (~jin@2001-48F8-9021-806-0-0-0-70A0-dynamic.midco.net)
[18:47:19] <nij-> What does this mean? #1=(programmable . #1#)
[18:47:57] <beach> #n= and #n# are reader macros.
[18:48:12] <beach> #n= marks a place in the input, and #n# refers to it.
[18:48:27] <beach> So the reader creates a circular list from this syntax.
[18:49:03] <beach> If you attempt to print it without handling circularity, you get (programmable programmable programmable....).
[18:53:38] <beach> Try (print (subseq '#1=(programmable . #1#) 0 20)) for instance.
[18:54:08] <beach> Or replace the 20 by 100, 1000, as you wish.
[18:54:48] <beach> The list has a single CONS cell.  The CAR of the cell refers to the symbol PROGRAMMABLE, and the CDR of the cell refers to the cell itself.
[18:55:01] <beach> nij-: Did you faint?
[18:57:05] <edgar-rft> nij-: the specific # syntax from your question is explained here -> http://www.lispworks.com/documentation/HyperSpec/Body/02_dhp.htm
[18:57:52] <beach> I guess it's easy to be overwhelmed when yet another unique feature of Common Lisp is revealed. 
[19:00:34] <nij-> Oh, I was reading about LEM. Sorry.
[19:01:34] <nij-> Nope I didn't faint xD
[19:01:56] <mfiano> Too bad you can't control the termination case. Would be nice to create a acyclic structure of a certain depth with a concise reader syntax, instead of #.(make-list ...)
[19:02:07] <mfiano> or similar
[19:04:15] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[19:05:11] <nij-> ooops, this kiills lisp ;;; (print (subseq #1='(programmable . #1#) 0 20))
[19:05:46] <beach> You put the quote in the wrong place.
[19:06:10] <beach> So now you have an infinitely deep list as well.
[19:06:18] <nij-> but why did it kill lisp
[19:06:34] <beach> Because it was trying to traverse an infinite data structure.
[19:06:41] *** Joins: lisp123 (~lisp123@45.130.83.191)
[19:07:01] <beach> I mean, they could have tried to protect against that, but apparently they didn't.
[19:08:35] <nij-> I see
[19:08:58] <beach> If you set *print-level* to something like 10, you see it better.
[19:09:25] <random-nick> wouldn't #1='(programmable . #1#) go like (quote (programmable . (quote (programmable . ...))))
[19:09:45] <random-nick> why would that freeze?
[19:10:42] <beach> Because you now have infinite depth too.
[19:10:45] <random-nick> does subseq deep copy it?
[19:11:00] <beach> No.
[19:11:05] <nij->  you want '#1='(programmable . #1#)
[19:11:07] <random-nick> I assume quote wouldn't traverse the quoted form?
[19:11:16] <nij-> without the first quote, it tries to evaluate the form
[19:11:21] <mfiano> There is no deep copy in Common Lisp. It doesn't make sense to have that built in to the language.
[19:11:27] <beach> random-nick: What?
[19:11:51] <random-nick> mfiano: there's COPY-TREE
[19:11:53] <mfiano> There is copy-tree for deep copying of cons cells, but not their non-cons-cell references
[19:11:54] <beach> random-nick: You have (programmable quote (programmable quote (programmable quote...
[19:12:15] <mfiano> So it's not really a deep copy as you would expect from static languages
[19:12:35] <beach> random-nick: Try assigning to *print-level* and do it again.
[19:12:41] <beach> random-nick: And you will see.
[19:13:40] <nij-> Any practical usage of #n=..#n#?
[19:13:58] <beach> Like I said, creating shared and circular structures.
[19:14:08] <mfiano> Sure, if you need to refer to an uninterned symbol for example
[19:14:47] <beach> nij-: I often use it to save entire data structures to secondary storage, so that I can re-create the exact same structure reading it back.
[19:15:14] <beach> nij-: I use that for Gsharp scores, SICL ASTs, Accounts in Compta, you name it.
[19:15:16] <random-nick> evaluating #1='(programmable . #1#) doesn't freeze anything
[19:15:35] <random-nick> but the printer exceeds the control stack without *print-level*
[19:15:43] <nij-> It doesn't random-nick. But if you take subseq..3, then it is bad.
[19:15:47] <beach> That's what I said, yes.
[19:15:51] <nij-> now try to print that bad thing , it kills lisp
[19:15:51] <mfiano> Why would it? It would just print infinitely until your heap is exhausted
[19:16:12] <nij-> the point is subseq 20 i think
[19:16:22] <beach> The printer algorithm is probably not that smart.
[19:16:33] <nij-> beach: I fail to see how you use that to save entire data structures..
[19:16:41] <nij-> SO far it seems like a fun trick to me.
[19:16:49] <beach> OK.
[19:17:08] <random-nick> subseq just gives an error that the sequence length is only 3
[19:17:51] <nij-> beach: No.. I mean.. could you elaborate? I'm not mocking or something, just not able to see the use case.
[19:17:57] <nij-> understand the use case*
[19:18:30] <random-nick> mfiano: yeah, that's what's unclear to me
[19:18:51] <random-nick> that expression shouldn't freeze or kill the system
[19:19:15] <random-nick> (and it doesn't for me, on sbcl)
[19:19:32] <mfiano> It shouldn't, you're correct, and it doesn't, also correct.
[19:19:46] <beach> nij-: http://metamodular.com/bach-suite-iv-prelude.gsh
[19:19:58] <beach> nij-: This is an entire music score from Gsharp.
[19:20:37] <nij-> random-nick:  mfiano  Tried it again. It didn't fail.
[19:20:38] <beach> nij-: The [ character does (apply #'make-instance (read-delimited list...)).
[19:20:41] <nij-> SUper weird.
[19:22:24] <nij-> not sure what this is really doing
[19:22:33] <nij-> but why do you want an infinite structure like this?
[19:23:11] <random-nick> it's not infinite, it's circular
[19:23:24] <beach> nij-: A staff contains chords, and the chords contain notes, and each note has contains a reference to its staff.  TADA! infinite.
[19:23:26] <random-nick> (which makes traversal infinite)
[19:23:41] <beach> Right, circular.
[19:24:29] <nij-> !!
[19:24:31] <nij-> I get it
[19:24:45] <nij-> What does "chord" mean here? 
[19:24:54] <beach> *sigh*
[19:25:05] <beach> A collection of notes to be played simultaneously. 
[19:25:13] <mfiano> Why does that matter? It's domain knowledge irrelevant to the example.
[19:25:31] <nij-> Oh, then I misunderstood what staff means. lemme looked it up. sorry for my poor eng
[19:25:36] <beach> Like C# diminished chord in first inversion.
[19:26:07] <beach> A staff is usually a 5-line thingy on a music score.
[19:26:10] <aeth> An emacs contains chords, and the chords contain keys, and each key contains a reference to its emacs?
[19:26:12] <nij-> Oh!
[19:26:17] <nij-> #engschool
[19:26:30] *** Joins: lisp123_ (~lisp123@5.30.23.247)
[19:26:35] <nij-> aeth:  haha
[19:26:39] *** Joins: Josh_2 (~user@37.25.47.130)
[19:27:08] <nij-> So what was mfiano  not happy with?
[19:27:22] <beach> nij-: So several of my programs contain circular and shared data structures, and I save them to secondary memory using PRINT.
[19:27:30] <nij-> (beach that's a good example, thanks :D)
[19:27:50] <nij-> Secondary memory?
[19:28:04] <mfiano> I am not happy with this discussion devolving. I have to go get productive.
[19:28:13] *** Joins: lisp123__ (~lisp123@45.130.83.191)
[19:28:34] <beach> nij-: https://en.wikipedia.org/wiki/Computer_data_storage#Secondary_storage
[19:28:41] <nij-> mfiano: Beware of me! Bye 
[19:28:55] <beach> mfiano: Take care.
[19:29:20] <nij-> Oh you mean it literally @@ Ok thanks for your patience..
[19:29:38] <beach> There is not much left of it for today.
[19:29:58] <nij-> *duck*
[19:30:04] *** Quits: lisp123 (~lisp123@45.130.83.191) (Ping timeout: 250 seconds)
[19:30:57] *** Joins: pjb (~pjb@user/pjb)
[19:31:53] *** Quits: lisp123_ (~lisp123@5.30.23.247) (Ping timeout: 248 seconds)
[19:32:34] <edgar-rft> I hope we agree shat GSharp should not be able to play C++ chords :-)
[19:33:50] <nij-> edgar-rft: :-)
[19:36:05] <pjb> edgar-rft: but it can play C♯♯ chords.
[19:36:42] <pjb> I'd use 𝄰 but I don't have a font for it.
[19:37:51] *** Joins: thrig (~thrig@65.113.153.50)
[19:39:09] *** Quits: tyson2 (~user@toroon12-3096782677.sdsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[19:40:05] <edgar-rft> don't you have C𝄪 ?
[19:40:32] <edgar-rft> ...even if that renders totally weird here :-(
[19:41:52] <thrig> what's all this about D?
[19:42:20] <edgar-rft> musical accidental glyphs :-)
[19:43:43] *** Joins: tyson2 (~user@toroon12-3096782677.sdsl.bell.ca)
[19:43:45] <thrig> there's little accidental about them, unless a player hits the wrong key
[19:44:30] <edgar-rft> maybe you mistake that with musical accidents :-)
[19:47:35] <pjb> edgar-rft: I have. Right, it's kind of a rotated +…
[19:48:37] *** Quits: nij- (~jin@2001-48F8-9021-806-0-0-0-70A0-dynamic.midco.net) (Quit: Using Circe, the loveliest of all IRC clients)
[19:49:06] <pjb> So a good C𝄪𝄪 chord, could be f♯a♯b♯ ?
[19:49:52] <thrig> off by one
[19:59:10] *** Quits: tyson2 (~user@toroon12-3096782677.sdsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[20:03:45] <edgar-rft> depends on what *kind* of chord, could be theoretically everything where a C𝄪𝄪 note is involved
[20:04:17] <pjb> indeed.
[20:04:39] <thrig> probably why some use pitch set classes instead
[20:04:48] *** Quits: lisp123__ (~lisp123@45.130.83.191) (Ping timeout: 268 seconds)
[20:04:58] <pjb> thrig: well, C𝄪 = D (approximately) therefore C𝄪𝄪 = E (approximately) therefore we're talking about E major here.
[20:05:50] <pjb> thrig: so, f♯ a♯ b♯ is II ;  E f♯ a♯ would be I ; but I'm only a music newbie.
[20:06:13] <edgar-rft> pjb: that's only true for equal-temperament tuning, but nowhere else
[20:06:21] <pjb> Indeed.
[20:06:48] <pjb> Let's go microtonal! https://www.youtube.com/watch?v=BMgL4RPGHwY
[20:07:26] <pjb> https://www.youtube.com/watch?v=uSZX4bgBtAI
[20:08:54] <edgar-rft> let's go to #c++ and ask whether they have a well-tuned programming language
[20:09:15] <thrig> they got rid of trigraphs?
[20:09:25] <thrig> .. but then stuck six other legs onto the donkey
[20:14:47] *** Quits: fef (~thedawn@user/thedawn) (Ping timeout: 244 seconds)
[20:15:09] *** Joins: fef (~thedawn@user/thedawn)
[20:21:38] *** Joins: selwyn (~selwyn@user/selwyn)
[20:25:23] *** Joins: jeffrey (~jeffrey@80-115-60-193.cable.dynamic.v4.ziggo.nl)
[20:36:34] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[20:52:46] *** Quits: ryanbw (~ryanbw@mab.sdf.org) (Quit: I'll be back.)
[21:02:21] *** Joins: lisp123 (~lisp123@45.86.202.65)
[21:05:10] *** Quits: hendursa1 (~weechat@user/hendursaga) (Quit: hendursa1)
[21:05:36] *** Joins: hendursaga (~weechat@user/hendursaga)
[21:14:53] *** Quits: derelict (~derelict@user/derelict) (Quit: WeeChat 3.2)
[21:25:59] *** Quits: pjb (~pjb@user/pjb) (Quit: need to reboot to install of a new version of a macOS kernel module.)
[21:48:15] *** Joins: derelict (~derelict@user/derelict)
[21:50:40] *** Quits: MetaYan (~MetaYan@c-7b5d235c.07-84-7462671.bbcust.telenor.se) (Ping timeout: 240 seconds)
[21:54:22] *** Joins: MetaYan (~MetaYan@c-7b5d235c.07-84-7462671.bbcust.telenor.se)
[22:18:53] *** Joins: tyson2 (~user@toroon12-3096782677.sdsl.bell.ca)
[22:25:21] *** Joins: pjb (~pjb@user/pjb)
[22:26:42] *** Joins: lisp123_ (~lisp123@5.30.23.247)
[22:29:52] *** Quits: lisp123 (~lisp123@45.86.202.65) (Ping timeout: 252 seconds)
[22:32:28] *** Quits: fef (~thedawn@user/thedawn) (Remote host closed the connection)
[22:40:11] <lisp123_> (defun test (&key (df #'car))  (funcall df '(1 2 3)))
[22:40:14] <lisp123_> So I did the above
[22:40:28] <lisp123_> is there a reason I didn't have to #' the df?
[22:40:47] <lisp123_> Is the first argument of funcall always evaluated to its function object?
[22:42:10] <lisp123_> CLHS says so :) So above can be ignored
[22:42:31] <thrig> #'df would presumably call a df defun, which presumably you don't want here
[22:43:03] <lisp123_> thrig: you are right
[22:43:14] <lisp123_> thanks, thats a good nuance to know
[22:53:47] *** Quits: thrig (~thrig@65.113.153.50) (Remote host closed the connection)
[23:12:25] <pjb> lisp123_: it's really easy: in CL, a name (a symbol) can designate two different things: variables or functions.
[23:12:53] <pjb> lisp123_: (actually, it can also designate more, like blocks, tags, types, anything). But for CL, variables and functions are the basis.
[23:13:17] <pjb> lisp123_: when you evaluate foo alone, it's taken as the name of a variable foo.
[23:13:39] <pjb> lisp123_: when you want to get the function named foo, you need to use (function foo) (abbreviated as #'foo).
[23:14:23] <lisp123_> pjb: How does df work in the above? Is it a symbol?
[23:14:35] <pjb> lisp123_: now, what is df?  It's the name of a parameter variables.  Therefore when you evaluate df, you get the value of that variable, which is the result of #'car aka (function car), which is the function named car.
[23:14:35] <lisp123_> (can I give it a variable value and also a function value)?
[23:14:45] <pjb> df is a symbol.
[23:15:17] <pjb> lisp123_: assuming you didn't played with *read-base*.
[23:15:35] <lisp123_> For example, this doesn't work: (defun test (&key (df #'car))  (funcall #'df '(1 2 3)))
[23:15:42] <pjb> lisp123_: if you set *read-base* to an integer greater than 15., then df would be read as an integer.
[23:15:59] <pjb> lisp123_: no, because here, (function df) tries to find a function named df.
[23:16:07] <pjb> But you defined no function with the name df.
[23:16:18] <pjb> You only defined a paremeter variable named df.
[23:17:10] <pjb> (defun df (x) 'outer)
[23:17:10] *** Joins: selwyn (~selwyn@user/selwyn)
[23:17:10] <pjb> (defun test-1 (&key (df #'car))  (funcall #'df '(1 2 3)))   (test-1) #| --> outer |# 
[23:17:10] <pjb> (defun test-2 (&key (df #'car))  (funcall   df '(1 2 3)))   (test-2) #| --> 1 |# 
[23:17:45] <lisp123_>  (defun test (&key (df #'car))  (setf df 55) (funcall #'df '(1 2 3)))
[23:17:52] <lisp123_> What about this (above)?
[23:18:01] *** Quits: tyson2 (~user@toroon12-3096782677.sdsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[23:18:04] <pjb> This would still call the function named df.
[23:18:05] <lisp123_> I thought if df is a symbol, it can have both a variable value and a function value
[23:18:12] <pjb> The variable named df is irrelevant in that funcall.
[23:18:13] <lisp123_> oh soryr
[23:18:14] <lisp123_> my mistake
[23:18:37] <lisp123_> Try without the #' in front of df
[23:18:39] <pjb> lisp123_: a symbol has indeed a symbol-function and a symbol-value, but this is something else (but related).
[23:19:07] <lisp123_> "Value of DF in (SB-KERNEL:%COERCE-CALLABLE-FOR-CALL DF) is 55)
[23:19:08] <pjb> lisp123_: when the variable is a lexical variable,  then it's unrelated to the symbol-value.
[23:19:31] <lisp123_> pjb: so a lexical variable only has one "value", which can be either a variable or a symbol?
[23:19:36] <pjb> lisp123_: when the variable is a dynamic variable, then the value of the variable is "stored" in the symbol-value of the symbol naming the variable.
[23:20:05] <pjb> lisp123_: but it's a little more complicated, with threads, since each threads can have it's onw dynamic variable, hence it's own symbol-value for the same symbol.
[23:20:54] <pjb> lisp123_: the error without the code doesn't mean anything. Try http://ideone.com
[23:21:47] <lisp123_> pjb: thanks
[23:22:22] <lisp123_> I got it now. We need #' for dynamic symbols because it can have two values, a variable & a function (which must be set via defun, not simply (setf df #'car)
[23:22:36] <lisp123_> Whereas for lexical variables, there is only one value associated with the variable
[23:22:55] <pjb> lisp123_: check this: https://ideone.com/AW0nMJ
[23:22:56] <lisp123_> So #' is not meant to be done (since that looks up the global environment)
[23:23:15] <pjb> no, #' is underlated to dynamic variables named by special symbols.
[23:23:50] <pjb> We need quote because lisp is homoiconic, to distinguish the case when you want a literal symbol, instead of a variable.
[23:24:23] <pjb> We need function because Common Lisp is a lisp-2, to distinguish the case when x names a function, instead of x naming a variable.
[23:24:34] <mfiano> (defun foo () (print :foo)) (flet ((foo () (print :bar))) (funcall 'foo) (funcall #'foo))
[23:24:39] <lisp123_> Thanks
[23:24:58] <pjb> lisp123_: in addition symbols can designate a function.
[23:25:16] <mfiano> The first call uses indirection to refer to the local function.
[23:25:37] <pjb> when we do (funcall 'foo), funcall iw use (fdefinition 'foo) to get the function object.  For symbols, fdefinition return the (symbol-function 'foo)
[23:25:59] <lisp123_> pjb & mfiano - thanks I get understand now :)
[23:26:04] <mfiano> err the function in thje global environment
[23:26:05] <pjb> lisp123_: this will be the same as (function foo), UNLESS you have a local function definition named foo, in which case (function foo) will return the local function!
[23:26:40] <pjb> Hence the difference between (funcall 'foo) and (funcall #'foo): without local function foo, it's the same, with a local function foo it's different.
[23:27:24] <lisp123_> pjb: oooo now that's very interesting
[23:27:37] <mfiano> Try my example and try to see why it prints two different things
[23:27:42] <pjb> lisp123_: now, where there may be some confusion, is in function calls: (defun foo (x) (* x 2))   (let ((foo 21)) (foo foo))
[23:27:44] <lisp123_> Let me save that down for future reference
[23:28:01] <pjb> lisp123_: in (foo foo), the first foo names a function, and the second foo names a variable.
[23:28:16] <pjb> lisp123_: this is the rule for function calls.
[23:28:31] <lisp123_> mfiano: Thanks, I tried it, but I only get it now, I didn't read through carefully the first time I looked at the output
[23:28:55] <pjb> lisp123_: note in (block foo (tagbody foo (if (foo foo) (go foo) (return-from foo 42))))
[23:29:10] <pjb> there 4 different things named foo: a block, a tag, a function and a variable.
[23:29:50] <pjb> lisp123_: you can invent new name spaces. You only need to provide an operator such as function to map symbols to objects.
[23:30:10] <lisp123_> pjb: thanks, I understand it much better now
[23:31:19] <pjb> (defmacro color (name) …) (defmacro vehicule (name) …)   (block red (tagbody red (if (eql (vehicule-color (vehicule red)) (color red)) (red red) (return-from red red)) (go red))))
[23:31:27] <pjb> there red is very confusing.
[23:32:27] <pjb> But at least for the vehicule named red, and for the color named red, you have the prefix operators (vehicule red) (color red).  For the function red, you don't have a prefix operator since we use the function red as an operator itself in (red red).  And there is a variabled named red, and a block and at tag.
[23:33:41] <pjb> I hear this car is named red, and is also of the color named red (coincidence???): http://www.blogcdn.com/www.autoblog.com/media/2011/06/lightning-mcqueen-1308849942.jpg
[23:33:59] <lisp123_> :D Nicely done
[23:34:12] <pjb> But I believe it was quite a dynamic car!
[23:34:24] <pjb> What is the function of red? (I don't know, I've not seen the movie)
[23:34:31] <lisp123_> heh :P
[23:34:32] <pjb> The last two lines are interverted.
[23:35:41] <pjb> I've got a filter in erc that prevents me to send unix commands. Such as ls -l etc.  And I have a commands named What, at, yes, etc, so each time I start a message with those words, I have to do something special to send the message ;-)
[23:36:15] <lisp123_> Have you ever accidentally pasted a full program into erc?
[23:48:41] <pjb> Yes, of course.
[23:48:51] <pjb> Now, erc has an option to filter that out!
[23:49:20] <pjb> One time I had a an addon that would automatically make a paste, when I pasted more than a few lines in erc. So I got the habbit of pasting large texts in erc…
[23:49:32] <pjb> When the add-on was disabled, it was pretty.
[23:50:08] <lisp123_> Haha it would have been interesting
[23:50:23] <lisp123_> I am using lime chat which blocks any multi line output by default
[23:50:51] <lisp123_> But sometimes I use erc and its definitely too close to pasting in code
