[00:24:25] *** Quits: mgl (~mgl@cpc87455-finc19-2-0-cust234.4-2.cable.virginm.net) (Ping timeout: 256 seconds)
[00:39:26] *** Joins: notzmv (~zmv@user/notzmv)
[01:29:49] * hayley realises that, would modules be objects that are stored in slots of a module object, then "type splitting" is splitting on dependent types.
[01:34:01] <hayley> e.g. (class (blah-module #|constructor|# with-list: list) #|superclass list|# () (define list-module list) (define (make-list) (new: (list: list-module) 1 2 3))) now I need to decide that LIST-MODULE is a module, and so we may as well generate specialised code for each BLAH-MODULE with different LIST-MODULE.
[01:35:21] <hayley> In sh^Wstatic "performant" languages like C++ and Rust, you have the types you specialise on in <> before the constructor. e.g. Blah<ThisListModuleType>(ThisListModuleType()) or something.
[01:36:15] <hayley> However, just having classes and slots for modules means that modules look like ordinary objects (cause they are). So I definitely don't want to split on e.g. (class (point from: x y) ...) which would be pointless.
[01:39:18] <neominimum> shka: That is really useful info! I thought spawning threads was costly too.
[01:39:19] <hayley> In a high performance implementation, with a user that cares for such things, I guess I could just have the user specify slots that the implementation should consider splitting on the types on, which achieves the pointy-brachet monomorphisation in an otherwise transparent way.
[01:40:23] <hayley> I recall, while testing decentralise2, thread spawning took 50Âµs or so. But keeping them alive isn't so bad.
[01:45:18] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[01:46:37] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[01:46:54] *** Joins: mgl (~mgl@cpc87455-finc19-2-0-cust234.4-2.cable.virginm.net)
[01:48:04] *** Joins: dra (~dra@2a04:4540:641b:4800:95e:e5:2d2a:e79d)
[01:48:06] <dra> Hello!
[02:02:18] <hayley> Hello dra.
[02:04:12] *** Joins: eugercek (~user@user/eugercek)
[02:04:26] *** Quits: eugercek (~user@user/eugercek) (Remote host closed the connection)
[02:05:00] <hayley> GHC has a SPECIALIZE pragma to tell the compiler that you want a specific instance of a function type to be compiled separately.
[02:15:15] <shka> neominimum: i also thought so, but it could be different on windows
[02:17:21] <shka> i don't care about windows, never checked myself
[02:30:04] *** Quits: chiselfuse (~chiselfus@user/chiselfuse) (Remote host closed the connection)
[02:30:21] *** Joins: chiselfuse (~chiselfus@user/chiselfuse)
[02:57:30] *** Quits: shka (~herr@109.231.3.55) (Ping timeout: 272 seconds)
[03:08:39] *** Quits: dra (~dra@2a04:4540:641b:4800:95e:e5:2d2a:e79d) (Remote host closed the connection)
[03:09:43] *** Quits: cosimone (~user@93-47-229-38.ip115.fastwebnet.it) (Quit: ERC (IRC client for Emacs 27.1))
[03:24:23] <hayley> moon-child: lol that r/gameenginedevs thread is painful
[03:24:57] <hayley> "A compacting GC means a reference has two indirections instead of just one, combined with indexing into component arrays, you're paying for three indirections for random access." Wut
[03:25:54] <hayley> Shenandoah used to use a Brooks forwarding pointer (i.e. every object has a pointer to its current version) but they ended up reworking it to a Baker (and/or rest of the planet) forwarding pointer.
[03:27:20] <hayley> FWIW I'd ask for a source for such claims, since they're going to suffer in finding one.
[03:34:33] *** Joins: robin (~robin@user/terpri)
[03:34:38] <sm2n> hayley: What thread?
[03:34:53] <hayley> https://www.reddit.com/r/gameenginedevs/comments/t25gzm/dominion_a_highperformance_highconcurrency_ecs/
[03:34:55] -ixelp- Reddit - Dive into anything
[03:35:20] <hayley> "If by "comparable performance" you mean being between 10x and 100x slower (in a best case scenario at that!) than a good C++/Rust implementation, then I think you can definitely achieve that." I wonder how they came up with these numbers.
[03:35:49] <hayley> For RE engines and hash tables, I often get some integer factor than "good Rust implementations". /me shrugs
[03:37:27] <hayley> Well, I did get in trouble with burntsushi, cause he once said that he couldn't imagine how to achieve similar performance to Rust in Lisp, and I said I'd have to make one-more-re-nightmare slower to do that.
[03:38:47] *** Quits: mgl (~mgl@cpc87455-finc19-2-0-cust234.4-2.cable.virginm.net) (Ping timeout: 256 seconds)
[03:40:07] <sm2n> wow that thread is full of misinformation
[03:40:27] <sm2n> it's impressive how much of it is so confidently stated
[03:42:29] <White_Flame> people don't read
[03:42:43] <White_Flame> so what they know is the entire universe of fact they've ever been exposed to
[03:43:04] <White_Flame> everything else "isn't real" in almost a literal sense to them
[03:44:28] <hayley> Double indirection for copying came late into the game; Baker (and now Pauseless/ZGC) test for fromspace, and Pauseless achieves it by checking a bit in the pointer. And there was that C.ai paper from 1971 which mentioned a read barrier for concurrent copying. Brooks published in mid-80s from memory.
[03:46:17] <moon-child> gilberth: rather than starting up a new thread to perform some task, it would be better to have a dedicated threadpool.  Then you can just wake it up
[03:46:31] <moon-child> gilberth: however, for file i/o, I think it is better to do that asynchronously w/the main thread
[03:49:48] <hayley> https://www.reddit.com/r/AreTheStraightsOK/comments/t3ekk9/this_shouldnt_exist/
[03:49:50] -ixelp- Reddit - Dive into anything
[03:51:14] <hayley> At least someone photoshopped in the NYT logo...I guess.
[03:52:00] <hayley> If I squint, it references "/int/ posts", so it's bait.
[03:52:55] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 240 seconds)
[04:16:37] *** Quits: random-nick (~random-ni@87.116.167.125) (Ping timeout: 240 seconds)
[04:18:10] * hayley uploaded an image: (354KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/DaoaacPoJUxnKMaBFVhpNxLb/failed-you.png >
[04:19:01] <moon-child> lol
[04:51:43] * hayley uploaded an image: (358KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/ndkovjYdqOXlNJCDNLZbRjOj/i-also-depress-people.png >
[04:52:53] * hayley reads Playdate C documentation
[04:53:17] <hayley> "Why use the C API? Performance. Lua is garbage collected. Its garbage collectorâ€™s performance varies wildly from game-to-game and even frame-to-frame within the same game" Seriously? That's your first complaint about performance of an interpreter?
[04:55:26] <moon-child> luajit?
[04:55:46] <moon-child> and, I don't think http://wiki.luajit.org/New-Garbage-Collector ever happenbed
[04:55:47] -ixelp- New Garbage Collector
[04:55:49] <moon-child> happened
[04:57:30] <hayley> IIRC it's a STM32 thingy, so porting LuaJIT seems...unlikely.
[04:57:59] <moon-child> :/
[04:58:38] <hayley> Correction: "180 MHz Cortex M7" with 16MB primary memory, and 32kB L1 cache.
[04:59:18] <hayley> (In my defense, STM32 chips also have M7 cores.)
[05:00:22] <moon-child> my mcu runs at 600mhz
[05:00:29] <hayley> Wikipedia says "STMicroelectronics STM32F746 (ARM Cortex-M7F) 180 MHz" even.
[05:00:33] <moon-child> 64kb cache (split evenly between i$ and d$)
[05:00:35] <moon-child> hardfloats
[05:00:41] <moon-child> and branch prediction!1!1
[05:00:58] <hayley> Does it predict branches?
[05:01:10] <moon-child> I think so ...
[05:01:13] <moon-child> either way it must be good
[05:01:47] <hayley> Some "micro"controller. Though I do want to see about cramming Zero Feet onto a Raspberry Pi Pico.
[05:02:41] <hayley> "This is the mail system at host applied-langua.ge. I'm sorry to have to inform you that your message could not be delivered to one or more recipients. It's attached below." Oh, you bastard. And you took a whole week.
[05:03:00] <moon-child> 6cm x 1.7cm is ... well, not tiny, but still pretty small
[05:03:17] <hayley> "host <snip> refused to talk to me: 554 bosimpinc02 bizsmtp  Connection rejected. Reverse DNS for <snip> does not exist." ...
[05:07:55] <hayley> And my VPS provider is contemplating some way to set up a reverse DNS request system, because they have to bug their ISP about it...
[05:18:38] <hayley> This will take forever, so I will bug Gilad Bracha on Twitter.
[05:37:56] <hayley> Nah, the question is too messy to fit in a tweet. I sent it from gmail. Ew.
[05:53:46] <kakuhen> GC bad
[05:54:05] <kakuhen> when I used Java in the 90s, it felt very slow, and C felt faster, so GC bad
[06:12:06] <edgar-rft> What I don't get is why collecting all that garbage instead of throwing it away?
[06:16:15] <semz> why is it always game developers
[06:18:06] *** Joins: masinter (~masinter@c-73-158-116-21.hsd1.ca.comcast.net)
[06:19:13] *** Joins: dave0 (~davezero@069.d.003.ncl.iprimus.net.au)
[06:20:20] * edgar-rft goes selling some collected garbage at ebay
[06:21:11] <hayley> semz: I regret to say that's why gameshit is in my lexicon.
[06:29:52] *** Quits: molson (~molson@172-103-21-94-dynamic.midco.net) (Remote host closed the connection)
[06:31:53] *** Joins: molson (~molson@172-103-21-94-dynamic.midco.net)
[06:32:50] <moon-child> damn game developers, they ruined game development!
[06:34:36] *** Quits: dave0 (~davezero@069.d.003.ncl.iprimus.net.au) (Read error: Connection reset by peer)
[06:37:16] *** Joins: dave0 (~davezero@069.d.003.ncl.iprimus.net.au)
[06:47:50] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Remote host closed the connection)
[07:06:50] * hayley shakes clenched fist
[07:07:32] <dave0> old man yells at cloud
[07:51:24] *** Quits: waleee (~waleee@h-178-174-193-77.NA.cust.bahnhof.se) (Ping timeout: 240 seconds)
[07:55:42] *** Joins: semz_ (~semz@user/semz)
[07:56:33] <kakuhen> i will write a visual novel engine in common lisp, and nobody will stop me
[07:58:39] *** Quits: semz (~semz@user/semz) (Ping timeout: 256 seconds)
[07:59:24] <hayley> <beach> i will write a common lisp in common lisp, and nobody will stop me
[08:00:01] <semz_> store the CGs inside the lisp image, maybe it will force some of the VN miners to learn Lisp
[08:00:36] *** semz_ is now known as semz
[08:03:44] <kakuhen> sounds fun
[08:03:51] * edgar-rft will write a visual novel that nobody can see
[08:04:10] <kakuhen> that reminds me i wrote a toy BBS in common lisp using fukamachi's web framework a few months ago
[08:04:19] <kakuhen> once i patch caveman2 to work seamlessly with postgresql, i will likely publish it somewhere
[08:04:24] <kakuhen> preferably not github...
[08:05:11] <kakuhen> bbs is one of the most simple """web 2.0""" projects you can work on, and it was really cozy writing the back-end in common lisp and using djula as a templating engine for the front-end
[08:30:53] * hayley reads the C++ style guide for university again
[08:31:05] <hayley> "Meta programming using the C pre-processor is not permitted" No #include?
[08:37:35] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Remote host closed the connection)
[08:38:00] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[08:48:04] *** Quits: chiselfuse (~chiselfus@user/chiselfuse) (Remote host closed the connection)
[08:48:20] *** Joins: chiselfuse (~chiselfus@user/chiselfuse)
[08:51:12] <dave0> the only thing i know about c++ is that i can more-or-less write it as c
[08:54:08] <aeth> with some std:: mixed in
[08:55:04] <aeth> my C++ is basically C with https://en.cppreference.com/w/cpp/container
[08:55:05] -ixelp- Containers library - cppreference.com
[08:55:28] <aeth> as well as std::cout << "hello " << name << std::endl;
[08:55:31] <aeth> but that's about it
[08:55:39] <kakuhen> at least it's not what UCLA does: forcing C++ but a very outdated standard that makes the language extra useless and artificially difficult
[08:56:09] <aeth> I mean, all universities do that it's just that C++11 is the minimum "viable" C++ and at that point it's 11 years old so universities are starting to allow it
[08:56:27] <kakuhen> UCLA isn't
[08:56:35] <kakuhen> as far as ive seen friends' cs coursework, it's still C++03
[08:56:42] <aeth> give it a few years
[08:56:49] <aeth> maybe they're waiting for 15 years of C++11
[08:57:01] <kakuhen> that's the more likely scenario
[08:57:11] <kakuhen> it's easier to continue recycling 10 year old course materials
[08:58:20] <kakuhen> but yes, no nullptr, no container initializers, no shared_ptr, no access to any of the concurrency stuff, and so on
[08:58:31] <kakuhen> at that point I wonder "why not just amplify the suffering and use C"
[08:59:17] <aeth> to be fair
[08:59:27] <aeth> no class is going to do concurrency stuff without it being a currency class, at least in C++
[08:59:49] <kakuhen> hmm,, then I guess I can point out how they have to cope with iterators rather than just range-based loops using auto
[08:59:50] <aeth> iirc I think I did a tiny bit at the kernel level in my OS class
[08:59:55] <aeth> (Linux kernel level)
[09:00:25] <aeth> now, auto, yeah, that's the big win of modern C++
[09:00:38] <aeth> no way in heck am I going to guess the type signature of some of those things
[09:01:06] <aeth> (and, yeah, the Linux kernel is C, not C++, but in a university class there's not much of a difference)
[09:01:23] <kakuhen> yeah they almost force you into using C++ like C anyway
[09:02:00] <aeth> when writing code for a class, you can't use any feature that makes the TA/prof think that you got it online, so you have to write it at a level that the TA understands
[09:02:11] <aeth> so even if they didn't force you to write C++ like C, you'd have to do it anyway
[09:03:22] <aeth> you can't use knowledge you're not supposed to have yet, and that's like 95% of C++
[09:03:32] <hayley> "Remove-duplicates of a bit-vector first determines whether the bit-vector is all zeros or all ones or mixed; if all zeros, the result is #*0, if all ones the result is #*1, if mixed and the first element is 1 then the result is #*10, otherwise the result is #*01.  Therefore, no new low-level bit-vector functions are required for remove-duplicates."
[09:03:50] <hayley> Funny how...uninteresting(?) some of the CL sequence functions are on bit vectors.
[09:07:00] *** Quits: robin (~robin@user/terpri) (Ping timeout: 240 seconds)
[09:09:26] *** Joins: robin (~robin@user/terpri)
[09:13:42] *** Quits: chiselfuse (~chiselfus@user/chiselfuse) (Write error: Connection reset by peer)
[09:13:42] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Read error: Connection reset by peer)
[09:16:34] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[09:17:58] *** Joins: chiselfuse (~chiselfus@user/chiselfuse)
[09:22:15] <ck_> std::good morning
[09:38:08] <hayley> https://www.ardanlabs.com/blog/2018/01/escape-analysis-flaws.html wehn stack allocation is a compile-time concern
[09:38:08] -ixelp- Escape-Analysis Flaws
[09:41:15] <hayley> "The static code analysis the compiler performs is providing many benefits, such as the ability to optimize the code you write over time" idk, looks like it's not.
[09:50:37] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Write error: Connection reset by peer)
[09:50:37] *** Quits: chiselfuse (~chiselfus@user/chiselfuse) (Read error: Connection reset by peer)
[09:50:53] *** Joins: chiselfuse (~chiselfus@user/chiselfuse)
[09:51:00] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
[09:54:18] * hayley had an idea with regards to a stupid question in the algorithms workshop tomorrow.
[09:54:47] <masinter> i fundamentally don't understand the modern attitude about performance
[09:55:09] <hayley> One is supposed to write an algorithm that tells if two strings are anagrams. The easiest way is to sort both strings and compare. Another way is to count the occurence of each character into a table, then compare tables.
[09:55:56] <masinter> what's a constant factor anyway that the best compiler can do over an interpreter
[09:56:08] <moon-child> ooh how about
[09:56:13] <hayley> However, pick a mixing function f that is associative and commutative (e.g. + mod 2^n or LOGXOR). Now reduce the mixing function over both strings.
[09:56:24] <moon-child> sort the first string according to location of each character in the second
[09:56:49] <hayley> If the resulting mixture is the same for both, they might be anagrams, and move onto a slower but precise test. If not, they can't be anagrams.
[09:56:59] <hayley> masinter: 2 magnitudes, give or take.
[09:57:11] <masinter> well with medley everything runs 1000 times faster
[09:57:27] <moon-child> 3 orders of magnitude from andy, and 2 from bill?
[09:57:29] <moon-child> I'll take it
[09:58:00] <masinter> i mean, the C code was written for a big-endien 32-bit cpu
[09:58:26] <masinter> and it's swapping bits all the time
[09:59:06] <moon-child> byteswapping is irrelevant in the face of interpretive overhead
[09:59:18] <hayley> Now, if your mixing function f can be SIMD-ed, or at least processed in a bit-parallel manner (e.g. LOGXOR), the test is basically free w.r.t the hash table diddling or sorting.
[09:59:28] <masinter> the byte codes are compact and compile
[09:59:33] <hayley> x86 BSWAP?
[09:59:49] <moon-child> masinter: doesn't matter
[09:59:56] <moon-child> unless by 'compile' you mean 'compile to native code'
[10:00:43] <masinter> my guess is 2 orders of magnitude
[10:01:16] <hayley> .oO(How creative.)
[10:01:32] <masinter> i mean i agree
[10:01:47] <moon-child> actually _doing work_ is fairly irrelevant, performance-wise, unless it falls into a fairly small bucket of operations (div, sqrt, simd).  Otherwise, what taxes performance is figuring out what work there actually is to be done; figuring out how that work relates to the other work that has recently been done and is going to be done soon; and cache
[10:01:51] <masinter> probably with different data
[10:02:08] <moon-child> the work of bswap is free.  The effect it has on the dependency graph is minimal.  And the data it operates on is data that you needed to fetch anyway
[10:03:12] <masinter> it used to be that working set mattered
[10:03:26] <masinter> just how much memory could you afford
[10:03:29] <hayley> I'm kidding, I understand.
[10:04:12] <moon-child> masinter: tradeoffs now are somewhat more annoying, but it is still funny to think: we didn't add a layer of cache on top; we added a layer of hard disc on the bottom
[10:04:35] <masinter> so rather than measuring performance in percentages or benchmarks, measure it in "Moore's law time"
[10:05:14] <moon-child> R.I.P. moore's law
[10:05:40] <masinter> just as a metric
[10:05:43] * hayley counts 13.3 years of Moore's law wrongly applied to speedup due to an optimising compiler.
[10:06:17] <masinter> i'd think everyone would be focusing on parralel
[10:06:44] <hayley> That's not so far off what Alan Kay said about developing, actually. Something like "make a fast computer and you can hack on software from 15 years into the future. Then optimise the shit out of it, and you get 30." But I forgot it actually.
[10:07:23] <masinter> Alan wouldn't curse
[10:07:31] <hayley> Nah, optimising let you hack 10-15 years in the future.
[10:07:48] <masinter> at the time it was budget
[10:07:49] <hayley> https://youtu.be/NdSD07U5uBs?t=2846 according to this slide.
[10:07:50] -ixelp- Alan Kay, 2015: Power of Simplicity - YouTube
[10:08:02] <hayley> masinter: Not true, he said something like "The kids went batshit!!" in his TED talk.
[10:08:24] <masinter> that was a performance
[10:08:31] <hayley> https://youtu.be/Eg_ToU7m1MI?t=707
[10:08:32] -ixelp- Alan Kay: A powerful idea about teaching ideas - YouTube
[10:08:34] <hayley> Sure.
[10:09:23] * hayley uploaded an image: (402KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/CAgsOdfVUDwqMhcdFHNiDQsx/microsoft-aquisition.png >
[10:10:13] <masinter> https://smalltalkzoo.thechm.org/
[10:10:14] -ixelp- welcome
[10:13:12] <masinter> I think these days the main thing people want is access to good data
[10:14:37] <masinter> Andrew Ng
[10:17:10] <masinter> the problem with relying on optimizing compiler is that it presents an uneven performace profile to the programmer
[10:18:31] <masinter> you have to know the details about how good it is, and you tweak your code to match what the compiler can recognize
[10:19:01] <masinter> common lisp sequences for example
[10:19:23] <masinter> lenght is order N or order 1
[10:19:23] <moon-child> _CPUs_ present an uneven performance profile
[10:19:28] <moon-child> it's kind of a lost cause
[10:19:48] <masinter> that's giving up
[10:20:01] * hayley tests her pre-filter for anagrams
[10:20:46] <hayley> So, positive answers aren't much slower (as the filter is dwarfed by making and diddling hash tables), and a negative answer (that doesn't false positive) is almost 100Ã— faster.
[10:20:53] <moon-child> I disagree regarding sequences, though.  Lists and vectors are clearly distinct types with distinct interfaces; there just happens to be one set of interfaces which are implemented by both
[10:20:58] <moon-child> hayley: are you using counting sort?
[10:21:23] <hayley> No sorting. I put character counts into a hash table.
[10:22:00] <moon-child> flatten that hash table
[10:22:08] <moon-child> I bet it gets at least 10x faster
[10:23:18] <hayley> Probably. But then I still have another magnitude from filtering.
[10:23:48] <hayley> And, if I could break out of portable CL, I could stuff two characters into a GPR, and a few more in a SIMD register if needed.
[10:24:01] <moon-child> just an estimate.  I would not be surprised if they had comparable performance
[10:24:31] <hayley> I recall the SBCL hash table implementation being quite decent for non-concurrent programs.
[10:25:18] <moon-child> ah, cl and its 'characters'.  pray, is "Ã¡b" an anagram of "bÃ¡"? :P
[10:25:36] <moon-child> hayley: no hash function is cheaper than the identity
[10:26:11] <hayley> I don't think 2Â²Â¹ words of space overhead would fly.
[10:26:59] <edgar-rft> let's find all characters that are UTF-8 byte-sequence anagrams :-)
[10:27:29] <moon-child> first: you are are off an order of magnitude; (log char-code-limit 2) ~~ 20.09
[10:27:46] <moon-child> second: why not?  2^20 is 1m, so that's 8mb
[10:28:07] <moon-child> third: this is a strange definition of anagram, where glyphs which appear identical are not treated as such
[10:28:20] <hayley> 2 is a while off 10.
[10:28:38] <hayley> brb, dinner.
[10:28:45] <moon-child> I never specified _which_ magnitude it was an order of :)
[10:28:49] <moon-child> cya
[10:29:09] <ck_> > is "Ã¡b" an anagram of "bÃ¡"?
[10:29:19] <ck_> https://www.youtube.com/watch?v=-crgQGdpZR0
[10:29:19] -ixelp- ABBA - Take A Chance On Me (Official Music Video) - YouTube
[10:42:34] <hayley> Back.
[10:49:54] <hayley> But the issue is that the whole filter test (8ns for three characters) executes in roughly the same amount of time CPython needs to execute one bytecode instruction (from empirical tests, it gets something like 200 MIPS on my machine). I can't imagine doing any of such bullshittery in Python, because fast ops that I can use to avoid things are not awfully fast.
[10:50:47] <moon-child> only 8ns for one bytecode instruction
[10:50:49] <moon-child> that is fast!
[10:52:40] <hayley> Well. The Netfarm VM runs around 70 MIPS, and is 1/3 the speed of CPython (it bounds checks everything; bytecode is untrusted. And I don't do the bullshit CPython's dispatch does)
[10:54:54] <moon-child> seems easier to pre-verify
[10:55:51] <hayley> I neglected to make pre-verification feasible.
[10:56:13] <moon-child> heh, how's that?
[10:56:30] <hayley> The bytecode permits making any combination of initial IP and environment depth when creating a function object.
[10:57:03] <moon-child> oh
[10:57:09] <moon-child> urp
[10:57:31] <hayley> Well, any function description number (each indexing an initial IP and argument count). Then I could attach environment info to each function description, I guess.
[10:57:40] <moon-child> well, at least it's not like x86 (I hope), which can not even be disassembled meaningfully
[10:58:35] <moon-child> is the initial IP allowed to be dynamically chosen?  If not, could scan for entrypoints, and verify based on that, pretty straightforward
[10:58:40] <moon-child> or just verify lazily, with a cache
[10:58:43] <hayley> An instruction can successfully decode differently if you start inside it, if that's what you mean. But you can disassemble meaningfully enough, since control flow is static enough.
[10:58:53] <moon-child> oh, nevermind then
[10:59:06] <moon-child> you are just as bad as x86!
[10:59:26] <hayley> I could work out such verification though, since target IPs are static.
[11:00:13] <hayley> While it looks bad, I don't see the issue from the POV of a verifier. For a two-byte instruction, you have a different instruction if you parse an instruction one byte in.
[11:00:57] <moon-child> if you have no dynamic control flow, then yes, there is not a problem
[11:01:40] <hayley> There are only forward conditional and unconditional branches, and tail recursion.
[11:02:19] <moon-child> that is not bad, then
[11:02:33] <moon-child> on x86, you have to make a huge graph, and then try to prune it heuristically
[11:02:36] <moon-child> if you want to avoid cheating
[11:03:16] <hayley> But the issue is that this is a replicated object system, and you can write your own scripts. Most are likely not too complex. So I'm not sure if optimisations allowed by verification offset the time taken in verification.
[11:03:36] *** Quits: chiselfuse (~chiselfus@user/chiselfuse) (Remote host closed the connection)
[11:03:37] <moon-child> v8 has 4 or 5 layers of jit now
[11:03:48] <moon-child> something similar seems appropriate
[11:03:53] <moon-child> 'C and C++ are both answers to the question "what if instructions were simpler to emit than error messages?"'
[11:04:14] <hayley> I am not Lars Bak, nor do I have a lot of Googlers to enslave for writing optimisations.
[11:04:32] <gilberth> I wonder if I could load CLIM2 and Free-CLIM into the same image.
[11:04:48] <moon-child> hayley: damn
[11:04:53] <hayley> Free-CLIM2
[11:05:08] <gilberth> What is the "2" doing there?
[11:05:29] <hayley> Free-CLIM + CLIM2 = Free-CLIM2
[11:05:31] <moon-child> portmanteau?
[11:05:51] <gilberth> And what is it called when I load McCLIM, too?
[11:06:08] <hayley> I was considering a VM->CL method JIT, but I never got around to it.
[11:06:24] <hayley> Or, rather, basic block JIT IIRC, but it never materialised anyway, so who cares?
[11:06:31] *** Joins: chiselfuse (~chiselfus@user/chiselfuse)
[11:07:00] <gilberth> Nah, we almost have relative package names. I could load CLIM2 and just rename the packages. Mine already are called FREE-CLIM-... with CLIM being a nick name.
[11:07:16] <hayley> gilberth: Free-McCLIM2
[11:07:54] <gilberth> Nope, the package name is "FREE-CLIM".
[11:09:21] <gilberth> However, I wonder how much I could borrow. But perhaps not, CLIM2 isn't particular solid code.
[11:09:35] <hayley> Someone: "this one austistic guy i know plays this game religiously
[11:09:39] <edgar-rft> Free-McCLIM+CLIM2-Or-Not
[11:09:47] <hayley> I recall testing the Netfarm interactor in CLIM2 on macOS, and it hated to be resized.
[11:10:13] <hayley> And I believe I had to patch some code to avoid telling xlib(?) to make zero-width things. Maybe you heard about it long ago, maybe not. idk
[11:10:46] <hayley> No, it was on Ubuntu, rather...
[11:10:49] * hayley uploaded an image: (14KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/BulZKyjTNToEWBTMnCCUNDnc/Screenshot%20from%202020-09-10%2010-55-34.png >
[11:11:04] <gilberth> Yep, all the panes, gadgets, and backend stuff is fragile. I wonder if the Motif backend is more stable. However, I imagine I could borrow some of the command processing, completion, etc. stuff. Especially as I don't care too much for the latter.
[11:12:45] <gilberth> hayley: Zero-width is an annoying X11 thing, as the minimum size of windows and pixmaps is 1x1. It always surprises me that even today zero is considered to be special somehow. This was an issue with early McCLIM, too. And I killed it at the backend. You can set a sheet region to +nowhere+.
[11:13:15] <hayley> IIRC I measured that basic block compilation, notably putting stack locations into local variables, would get a 3-5Ã— speedup for fib(). But I considered my BC performance to be good enough, given how short-lived Netfarm programs are, and that you get an object-oriented instruction set, rather than one with a bullshit word-addressed memory or something.
[11:13:46] <hayley> (I mean that bignum addition, CONS, CAR, CDR, etc are instructions, like a Lisp bytecode would. Because, well, I wrote it based on Lampkin's SECD machine and chapter 5 of SICP.)
[11:13:47] <gilberth> And CLIM2 hates you, when you neither have (:menu-bar nil) nor a menu.
[11:14:28] <hayley> Pardon me, Landin, not Lampkin.
[11:15:50] <hayley> I consider it all very good, when e.g. Ethereum gives you persistent and volatile byte memory, and someone told me that it would be too hard to write a bytecode VM with proper lexical scoping.
[11:17:05] <hayley> It's surprisingly easy. And, when your control flow is all tail recursion (as in my next VM), bytecode is almost trivial. I want to write about the compiler, but bytecode generation is almost not worth mentioning, honestly.
[11:20:15] <hayley> Instead, I hurt my head on things like "supposing the compiler sees different layouts for different layouts for the value of a slot, how do I manage invalidation". Which provided some company while I walked to the market and back twice today.
[11:22:21] *** Quits: masinter (~masinter@c-73-158-116-21.hsd1.ca.comcast.net) (Quit: ~ Trillian - www.trillian.im ~)
[11:24:56] <hayley> I know I want that, so that compiled code for one module can inline from another module, but it hurts my head.
[11:25:46] <hayley> But I think it's not too hard, in the end. /me just needs to write it down?
[11:29:38] <hayley> The one thing I don't like is that I can't tell if some slot is going to have a module, which I should monomorphise on, or if it's just another object, which I probably shouldn't monomorphise (but it might help for some, idk). It strikes me as not dissimilar to dependent types, since, well, "types" and modules are objects, but I don't think dependent types hackers would ever pull such stunts.
[11:32:31] <hayley> The user could just a provide "should the implementation monomorphise this?" annotation, but it strikes me as a very implementation-dependent optimisation. Far from, say, declaring types in a DEFSTRUCT.
[11:33:50] *** Joins: treflip (~user@user/treflip)
[11:45:43] * gilberth wants an emacs mode which colours all symbols that are not internal to my package differently.
[11:47:19] <gilberth> I already have a list of all symbols exported from CLIM to have my defining forms coloured differently for them. Hmm.
[11:56:46] *** Joins: shka (~herr@109.231.3.55)
[11:57:43] <selwyn> good morning everyone
[12:02:59] <hayley> Good morning selwyn!
[12:04:38] *** Joins: cosimone (~user@93-47-229-38.ip115.fastwebnet.it)
[12:09:41] *** Joins: eugercek (~user@user/eugercek)
[12:21:03] <selwyn> good morning hayley
[12:30:59] * hayley uploaded an image: (353KiB) < https://libera.ems.host/_matrix/media/r0/download/matrix.org/MwAkmoEXCXXnZKCRoBgSQMQO/failed-you.png >
[12:31:49] <hayley> Well, Baker did write about optimising CL sequence functions on bit vectors to do bit-parallel operations (which you could even extend to SIMD, surely) and I read that before coming up with my hashing trick for anagram detection.
[12:32:28] *** Joins: mgl (~mgl@cpc87455-finc19-2-0-cust234.4-2.cable.virginm.net)
[12:33:29] <hayley> Apparently that optimisation isn't on any website, but it greatly speeds up the (probably more common) case where you don't have anagrams, most of the time (dependent on your "hash" function).
[12:38:01] *** Joins: Lycurgus (~juan@98.4.112.204)
[13:00:45] <dave0> i believe generating anagrams is a valid use of a computer
[13:01:06] <hayley> Not generating, we are testing if two strings are anagrams of each other. 
[13:01:08] <dave0> even, important
[13:01:09] <hayley> e.g. (anagram-p "cat" "tac")
[13:01:16] <dave0> oh
[13:01:28] <dave0> sort the letters, do a compare
[13:01:38] <hayley> Yes, that's how I thought to do it first.
[13:01:38] <pjb> it should be anagramp
[13:02:10] <hayley> You can also tabulate the number of each character, and then compare. But I figured that, with a hash function with some properties, you can avoid a trickier test after doing a much faster heuristic.
[13:03:01] <hayley> Suppose you have a function H : integer Ã— integer â†’ integer s.t. H is associative and commutative. Then you can reduce H over the characters in both strings. If they are equal, then you may have anagrams. If not, you cannot have an anagram.
[13:03:18] <hayley> If H is something like xor or modular addition, you can make this test very, very fast in practise.
[13:05:53] * dave0 lies and says he understands
[13:06:24] <dave0> counting the letters seems interesting
[13:07:57] <hayley> It's O(n) in time, though you need space for the count table.
[13:08:39] <hayley> dave0: Just think that 'c' + 'a' + 't' == 't' + 'a' + 'c', so you can use + as a "hash function" of sorts, where hashes being equal implies you might have anagrams, and hashes being different implies you definitely don't.
[13:08:46] <selwyn> hayley: thats smart
[13:09:05] <selwyn> parallel reduction gives you faster than linear time right
[13:09:15] <hayley> Right.
[13:10:55] <selwyn> h is the hash function?
[13:12:29] <hayley> Yes.
[13:13:41] <hayley> Though it isn't really a "hash function", since those usually are used to avoid equality tests. I guess ANAGRAM-P is an equivalence relation, still.
[13:14:34] *** Joins: waleee (~waleee@h-178-174-193-77.NA.cust.bahnhof.se)
[13:19:58] <gilberth> "Fatal error: Can't create Mach semaphore." Oops, what happened?
[13:20:18] <shka> a fatal error, clearly :P
[13:20:53] <gilberth> Yep, game over. The question is: Why?
[13:22:18] <moon-child> dtrace time?
[13:22:50] <gilberth> Well, for that I would need to be able to recreate the error to begin with.
[13:23:20] <hayley> You made more than 1, which implies you could deadlock?
[13:24:55] <gilberth> How would just creating a semaphore cause a dead lock? Also: Why is there a semaphore created at all? Where did that happen? We will never know.
[13:25:48] *** Quits: waleee (~waleee@h-178-174-193-77.NA.cust.bahnhof.se) (Ping timeout: 240 seconds)
[13:27:19] <hayley> Creating two would let you achieve it later Granted, you could with one too.
[13:27:53] <gilberth> Yes, but it said "Can't create".
[13:30:28] * hayley shrugs
[13:31:07] <dave0> hayley: i did isanagram() with a hash table
[13:31:31] <dave0> but it's in c
[13:31:38] <hayley> https://www.youtube.com/watch?v=1B3Xi5L6siI
[13:31:38] -ixelp- Turning plastic gloves into hot sauce - YouTube
[13:40:36] <dave0> hayley: https://termbin.com/xhp2
[13:41:13] <dave0> hayley: not as fast as your hash
[13:43:43] <dave0> whoops it has a bug
[13:43:58] <dave0> oh well it's pretty close
[13:46:51] <hayley> Hey, Gilad Bracha responded to my email. 
[13:58:28] *** Joins: kevingal (~quassel@149.157.114.33)
[14:02:26] <dave0> fixed   https://termbin.com/cb0ao
[14:03:02] *** Quits: kevingal (~quassel@149.157.114.33) (Ping timeout: 240 seconds)
[14:03:09] *** Joins: kevingal (~quassel@2001:770:c0:401:488e:8cf8:8d59:f91c)
[14:03:14] <hayley> Nice.
[14:04:44] <hayley> The trick I had was to compute the "hash" before computing and comparing tables. But I like the idea that you decrement the table for the second string, and can bail a bit earlier.
[14:05:03] <hayley> But you better check that the table has all zeroes at the end, right? Else you might decide e.g. "a" and "" are anagrams.
[14:05:45] <hayley> ...though, if you check the strings are the same length at the end, it's not possible to not run out of another character. Neat! 
[14:06:10] <dave0> thanks :-)
[14:07:02] <dave0> i aced algorithms class in school
[14:07:25] <dave0> i also aced unix class which i'm less proud of ;-)
[14:07:36] <dave0> everything else was barely scraped by
[14:10:15] <hayley> My code uses a hash table, since Lisp has Unicode characters and an array with all those would be too big for my liking. So I am more dependent on a fast filter in a way.
[14:10:32] <dave0> yeah my code doesn't scale
[14:15:03] * hayley reads "convenience is not a virtue"
[14:15:15] * hayley grumbles and wants nice shit for everybody
[14:15:30] <hayley> A wise person once said "if weâ€™re going to be putting our shit out on the line itâ€™s definitely not going to be so that I can live simply."
[14:21:56] *** Quits: Lycurgus (~juan@98.4.112.204) (Quit: Exeunt)
[14:22:45] <kakuhen> i had to drop out of algorithms because too much busy work when combined with grad clases
[14:25:27] <gilberth> Hmm, would it be rude to catch idioms in application frame layouts? Like merging (outlining () (labelling (:label "hey") ...) into one thing, so that the label is above the then broken outline?
[14:28:34] <ck_> rude to whom
[14:29:39] * selwyn wonders what is in algorithms class
[14:29:43] <selwyn> there are a lot of algorithms
[14:30:59] <ck_> I was pondering that question but decided against asking it
[14:31:43] <ck_> once, just for fun, I audited a beginners lecture in a different university. "What is an algorithm?" was a question that prof answered
[14:31:47] <ck_> would you like to know the answer
[14:32:10] <selwyn> yes please
[14:32:26] <ck_> an algorithm, my friend, is "the set of all functions that realize it"
[14:32:29] <ck_> very cool
[14:32:35] <selwyn> uh
[14:32:45] <ck_> don't think of wheels or other circular structures
[14:32:54] <hayley> Apparently you learn in primary school that an algorithm defines a line or something. I remember hearing that in primary school. "Uh, what?" I remember hearing my younger brother repeat it. "Uh, what?!"
[14:32:58] <ck_> that's just an illusion I'm sure. That answer is actually galaxy brain perfect
[14:33:13] <selwyn> clearly i need to go to algorithm class
[14:33:53] <hayley> However /me intends to write algorithms in functional style, when possible, just to be annoying.
[14:34:42] <gilberth> ck_: Rude to the application programmer who might expect two nested panes. But then the spec doesn't really say so.
[14:34:46] <hayley> I got bored of writing braindead totally-not-BASIC code in high school. But my teacher let me write with pattern matching and other niceties when I had to write about a compression algorithm I was going to use.
[14:35:11] <ck_> gilberth: in a library you're writing you mean?
[14:36:32] <gilberth> ck_: I am talking about CLIM.
[14:37:31] <hayley> But I could spec my anagram test like "anagram(s1, s2) = hash(s1) hash(s2) /\ sort(s1) = sort(s2) where hash(s) = \Sum s \mod 2^N"
[14:38:09] <ck_> I know, and assumed you were speaking about your implementation, then asked to make sure
[14:38:26] <hayley> And I believe this would lead to a very straightforward implementation. It's also not hard to work out complexity, for what it's worth. sort is O(n log n), sum is O(n), so it's all O(n log n) time.
[14:38:29] <selwyn> i think the ability to write algorithms effectively in a programming language is underrated
[14:38:53] <hayley> I think writing algorithms in anything other than imperative style is underrated.
[14:38:59] <selwyn> for all of its faults, c++ at least to me seems to be a language you can implement algorithms in
[14:39:06] <selwyn> whereas this is very difficult in python
[14:39:43] <hayley> https://plover.com/~mjd/misc/hbaker-archive/sigplannotices/gigo-1997-03.html "Theory of computation people have trouble `step-counting' any language other than `machine language,' even though Turing himself was fond of the lambda calculus."
[14:39:43] -ixelp- Sigplan Not. Mar 1997: When Bad Programs Happen to Good People
[14:39:58] <hayley> selwyn: But it's executable pseudocode!!!1!
[14:40:16] <shka> selwyn: no built-in true arrays?
[14:40:45] <selwyn> shka: well, yeah, so you use the numpy ones
[14:41:49] <gilberth> ck_: Yes, I am speaking about my implementation. As I wish to merge outlining and labelling and make (outlining () (labelling () ...)) look the same as (labelling () (outlining () ...). So I wonder, if some application programmer would be really surprised, if there is only one pane there.
[14:41:52] <selwyn> but when one writes an algorithm
[14:42:09] <ck_> gilberth: I believe that matters only in code that is released
[14:42:27] <selwyn> this is precisely when one's 'low level logic' and 'high level logic' becomes too tightly coupled to separate out
[14:42:34] <gilberth> But then when you say (make-pane 'interactor-pane :scroll-bars t) there already is a scroller and a viewport pane secretly wrapped around your stream pane.
[14:43:04] <selwyn> so if i had to distill my criticism of python, it is that you can't write algorithms in it
[14:43:12] <hayley> So far it also seems that the lecturers are too focused on implementation details. Again: who the hell cares about pointers being 5 bytes or whatever. Just say that the size of an adjacency matrix is O(nÂ²) for n vertices and an adjacency list is O(n+m) for m edges.
[14:43:35] <selwyn> as evidenced by the large number of libraries that use c to implement their algorithms, and the fact that people usually switch to implementing things in c when they become too much like an algorithm
[14:43:41] <hayley> They don't care for anything other than asymptotic behavior for time, seemingly, so at least be consistent!
[14:43:50] <gilberth> ck_: Very funny.
[14:44:39] <hayley> No one asks "if addition takes 2 cycles, and a multiplication 12, how long does so and so take to run". Perhaps because such questions are too poorly defined on superscalar, branch predicting, out of order, ... processors.
[14:44:44] <ck_> but is it not also accurate?
[14:46:35] <gilberth> Only in a certain sense, because I want to release something that works. Eventually.
[14:47:03] <hayley> But then, I cannot talk about how, say, a vector will take half the space of a list, as there are no CDR pointers. (Lisp machines are that way ----->)
[14:47:24] <ck_> absolutely understandable
[14:48:23] <ck_> What I'm saying is that that is probably all you need to worry about -- the working part.  Rudeness shouldn't matter, in my opinion, when you're filling one of the many gaps in the specification
[14:48:52] <selwyn> hayley: analysis of quantum algorithms is usually also done in the equivalent of imperative style
[14:49:06] <hayley> ):<
[14:49:10] <selwyn> but some new ways of visualising them seem to be really useful and catching on
[14:49:22] <selwyn> this thing called 'zx-calculus'
[14:49:38] <shka> selwyn: i learned to appreciate CL's shiftf and other such macros
[14:50:02] <shka> it makes algorithmic code easier to understand
[14:50:28] <gilberth> ck_: Perhaps. And in contrast to McCLIM, when I see sth not well specified I ask "What would be the most useful thing here?" and not "What would be the most annoying thing.". The CLIM spec is not a bible. At least not mine.
[14:51:14] <ck_> ok
[14:53:30] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca)
[14:55:05] <selwyn> shka: yes
[14:56:02] <gilberth> ck_: IMHO of course.
[14:56:18] <selwyn> sometimes i like to think of the hyperspec as a religious text
[14:57:04] <gilberth> Well, in contrast to the CLIM spec, the ANSI spec is finished.
[14:57:12] <selwyn> there are scholarly disputes over whether we should fix the mistakes in the current one, or even write a new one altogether to reflect the modern age
[14:57:21] <selwyn> the overall culture tends towards conservatism nevertheless
[14:58:05] <selwyn> not much chance of a martin luther nailing a new spec to the door
[14:58:09] <gilberth> I am all for that approach. What we could need though is CLtL3 to document the de-facto standard.
[14:59:06] <ck_> with the attack of SICL all of this will be fixed
[14:59:25] <gilberth> Opting for a new spec would open the door to get all kinds of funny wet-dreams into it. I don't like that perspective.
[14:59:28] <ck_> or is it WSCL
[14:59:45] <hayley> WSCL.
[15:01:10] <gilberth> Well, there are many missing parts. For one thing the lexical envvirnment access. At e.g. a predicate telling me if something is a type specifier. Would WSCL address that too?
[15:01:31] <selwyn> in this analogy, common lisp is the catholic church
[15:01:36] <selwyn> unsure how i feel about that
[15:01:48] <gilberth> Nah, a CLtL3 would be fine, as we have de factor standards like threads, Gray streams, MOP and a few things I may have missed.
[15:02:02] <hayley> I don't think so. The first WSCL project is to attack some UB that should be defined, and also some stupid typoes and inconsistencies.
[15:02:07] <gilberth> * de facto ;)
[15:03:19] <gilberth> Well, the UB thing is easy. Just say that an error must be signaled. Done.
[15:03:35] *** Quits: pjb (~pjb@user/pjb) (Remote host closed the connection)
[15:04:24] <gilberth> But that is not crucial. Or would you like a CL which crashes on (typep 1 'foo)?
[15:06:46] <gilberth> And this is what I meant. Given two x and y you can't formulate anything to test whether (typep x y) won't be UB.
[15:10:24] <gilberth> BTW (scrolling () ..) does that too as it sneaks in a viewport. So what is mapped out by the layout macros already does not reflect the real pane hierarchy.
[15:12:04] <hayley> I believe that will signal an error in WSCL, yes.
[15:13:11] <gilberth> That isn't my point. I would like to test whether something is a valid argument to TYPEP. Oh, and that better takes an environment too.
[15:13:52] <hayley> Hm, nothing in CLtL2 environment spec either?
[15:15:52] <gilberth> I don't believe so. You can't define lexical types.
[15:19:11] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[15:45:34] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 260 seconds)
[15:48:16] *** Quits: eugercek (~user@user/eugercek) (Ping timeout: 272 seconds)
[15:51:47] <gilberth> Oops, CCL crashed with signal 11. Something is not right.
[16:12:45] *** Joins: random-nick (~random-ni@87.116.176.196)
[17:49:31] *** Quits: dave0 (~davezero@069.d.003.ncl.iprimus.net.au) (Quit: dave's not here)
[18:06:36] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 240 seconds)
[18:13:20] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[18:17:45] *** Quits: chiselfuse (~chiselfus@user/chiselfuse) (Remote host closed the connection)
[18:18:03] *** Joins: chiselfuse (~chiselfus@user/chiselfuse)
[18:49:38] *** Joins: notzmv (~zmv@user/notzmv)
[18:59:12] *** Quits: treflip (~user@user/treflip) (Quit: ERC (IRC client for Emacs 27.2))
[19:40:02] *** Joins: pjb (~pjb@user/pjb)
[19:50:12] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 240 seconds)
[19:51:36] <gilberth> Not my day. Somehow CCL likes to fight with Mach perhaps. I really don't know what's going on. And with SBCL my keystroke-to-buffer-flip latency is 20ms.
[19:54:50] *** Joins: eugercek (~user@user/eugercek)
[19:55:41] <shka> good news everybody, that SOB has been eliminated https://www.jpost.com/international/article-699032
[19:56:05] <ck_> they got Bin Laden's Right Hand again?
[19:56:10] <gilberth> And I need a real Linux machine. I noticed that xterm feels as sluggish as my input editor. My "benchmark" is hitting "a" and let auto repeat kick in. The cursor seems jumpy a bit. It's way better on my laptop.
[19:56:37] *** Quits: eugercek (~user@user/eugercek) (Read error: Connection reset by peer)
[19:57:05] <gilberth> shka: Does that help?
[19:57:47] <shka> gilberth: yes, chechen chain of command was decapitated 
[19:57:54] <shka> also, this guy was seriously EVIL
[19:58:31] <gilberth> shka: I confess that I hear the name for the first time. You seem to be way better informed than me.
[19:59:59] <shka> well, you haven't heard about chechen gay purges?
[20:00:18] <gilberth> No, I haven't.
[20:00:39] <shka> well, ok, but you played vampire bloodlines
[20:00:49] <shka> and this is somehow related 
[20:00:57] <shka> believe it or not
[20:01:03] <gilberth> How so?
[20:01:32] * gilberth feels completely ignorant.
[20:01:59] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[20:02:12] <shka> the text book for the recent edition of vampire masquerade came out, and mentioned how chechnya gay purges are cover up for vampire activity  
[20:02:35] <shka> and that lead to some repercussions
[20:03:00] <shka> but what is important, in chechnya homosexuals are simply being killed off 
[20:03:17] <shka> no trial, prosecution or anything
[20:03:29] <shka> you simply disappeared 
[20:04:10] <shka> and they torture people to get lists of new targets
[20:04:53] <shka> https://en.wikipedia.org/wiki/Anti-gay_purges_in_Chechnya#Key_events 
[20:05:42] <gilberth> shka: Thanks, I'll read that later. I got a priority interrupt by my wife.
[20:06:25] <Gnuxie> shka: it's not confirmed 
[20:07:06] <Gnuxie> he did a video call with Kadyrov or whoever afterwards to say he was still alive
[20:09:10] <shka> :(
[20:09:53] *** Quits: mgl (~mgl@cpc87455-finc19-2-0-cust234.4-2.cable.virginm.net) (Ping timeout: 256 seconds)
[20:11:12] *** Joins: notzmv (~zmv@user/notzmv)
[20:11:50] <Gnuxie> is unfortunate 
[20:19:26] <selwyn> the london underground is on strike this week
[20:19:40] <selwyn> and some genius said that there shouldn't be a strike 'while there's a war on'
[20:23:13] <shka> well, they press coverage will be compromised
[20:24:20] <selwyn> why should an industrial dispute in britain be affected by a war somewhere else
[20:24:51] <ck_> but there's always a war on
[20:26:12] <shka> https://english.elpais.com/science-tech/2022-03-01/the-one-centimeter-long-bacterium-thats-visible-to-the-naked-eye.html
[20:26:12] -ixelp- Thiomargarita magnifica: Scientists discover one-centimeter long bacterium thatâ€™s visible to the naked eye | Science & T [...]
[20:36:27] *** Joins: Lycurgus (~juan@98.4.112.204)
[21:30:06] <selwyn> watching the iem final
[21:31:10] <shka> oh, already
[21:31:13] <shka> who is playing?
[21:31:18] <selwyn> its a rerun
[21:31:27] <selwyn> serral vs reynor
[21:31:59] <shka> funny to see final without a korean 
[21:32:23] *** Quits: kevingal (~quassel@2001:770:c0:401:488e:8cf8:8d59:f91c) (Ping timeout: 256 seconds)
[21:32:24] <selwyn> italian is the least esports nationality ever
[21:32:48] <selwyn> finnish is maybe second to korean otoh
[21:33:07] <shka> south vs north :D
[21:33:14] <ck_> italians are the kings of amateur radio though
[21:33:59] *** Quits: Lycurgus (~juan@98.4.112.204) (Quit: Exeunt)
[21:35:13] <ck_> now I want to make a "[country] is most known for.." list with nerd facts
[21:38:30] <selwyn> why do esports have age restrictions
[21:54:14] <selwyn> you get 15 year olds who play in premier league football matches
[21:56:02] <Gnuxie> probably to discourage kids from missing school to become esport players 
[21:56:23] <Gnuxie> though
[21:56:30] <Gnuxie> maybe not, that's just a boomer mindset 
[21:56:48] <White_Flame> does make sense in terms of societal rules, though
[21:57:01] <selwyn> 'we don't need no education'
[21:57:45] <White_Flame> but clearly kids of those ages probably have prime reaction time compared to older
[21:57:57] <White_Flame> -clearly :-P
[21:59:46] <neominimum> re: adding things to the spec, I wonder if it would be more useful to add parallel execution that can gracefully degrade to concurrent execution given the implementation constraints via some declarations like (declare (async foo bar)). Then when execution reaches those particular function calls they instead get spun off into a new thread or whatever the runtime thinks is appropriate.
[22:00:02] <Gnuxie> i think the reaction time doesn't get the better of you until 27, pulled straight out my ass though 
[22:01:35] *** Joins: eugercek (~user@user/eugercek)
[22:02:16] <neominimum> *whatever the runtime supports
[22:07:57] *** Quits: szkl (uid110435@id-110435.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[22:09:13] <neominimum> adding threading to the spec may be useful for those that need that lower level abstraction, but I don't think it's necessary for the average user to need to think of the how of parallelism but simply the what should be run parallel/concurrenly.
[22:10:53] <neominimum> *the what/the what that
[22:11:25] <shka> neominimum: all of stuff in the standard may behave differently in multi-thread
[22:12:11] <shka> so that's why i think that acknowledging of threads existence is a must for a standard
[22:12:45] <shka> good that there is consensus on what behavior is sane in CL for many cases
[22:12:56] <shka> but it would be good to document it
[22:19:58] <neominimum> I'm no authority but I wonder if the fact that the spirit of execution can differ simply given different runtime environments may in fact be a flaw in the standard. Don't get me wrong I don't think the spec needs to assume a parallel runtime environment, but it needs to at least ensure that all things work as expected despite the runtime environment. Anyway, I can't really defend the idea as I haven't given it much thought.
[22:25:12] *** Quits: Psybur (~Psybur@mobile-166-170-32-247.mycingular.net) (Remote host closed the connection)
[22:28:44] <neominimum> I've got CLtL2 and ANSI Common Lisp on a boat to my current location so I hope they will give me a better understanding of the design intricacies of CL.
[22:34:04] <clothespin> morning
[22:45:50] <gilberth> Well, what I think saves us in a way is that we have multiple implementations of CL in contrast to single-implementation languages. And there also is some competition and some things like Gray streams e.g. or most recently package local nicknames get more or less universally adopted after people have made experience with it. Just like many things we take for granted today came as libraries initially.
[22:46:03] <gilberth> And I believe that this is healthy.
[23:01:46] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-17-50-101-91-98.dsl.bell.ca) (Remote host closed the connection)
[23:29:46] <selwyn> gnuxie: https://pbs.twimg.com/media/FMyeTtVXMAIARZF.jpg
[23:31:11] *** Quits: qhong (~qhong@rescomp-21-400677.stanford.edu) (Ping timeout: 245 seconds)
[23:31:35] <selwyn> the british press is taking advantage of the war to do mccarthyism against train drivers
[23:32:11] <selwyn> meanwhile, saint tony blair's lobbying for putin is conveniently forgotten by witch hunters
[23:40:00] *** Quits: lonjil (~quassel@user/lonjil) (Remote host closed the connection)
[23:41:08] *** Joins: lonjil (~quassel@user/lonjil)
[23:43:35] *** Quits: Aurora_v_kosmose (~LispyLigh@user/lispylights) (Ping timeout: 240 seconds)
[23:46:07] *** Joins: christophergray (~christoph@186.151.17.62)
[23:46:16] *** Quits: Rue (~rue@2001-b011-1000-1bf7-9b06-3902-8db2-c5f0.dynamic-ip6.hinet.net) (Ping timeout: 250 seconds)
[23:48:19] *** Joins: Rue (~rue@2001-b011-1000-17ff-0191-633b-7286-36db.dynamic-ip6.hinet.net)
[23:54:03] *** Quits: edgar-rft (~edgar-rft@ip-109-193-249-223.um39.pools.vodafone-ip.de) (Ping timeout: 256 seconds)
[23:54:26] *** Joins: edgar-rft (~edgar-rft@ip-109-193-249-223.um39.pools.vodafone-ip.de)
[23:54:50] *** Joins: Aurora_v_kosmose (~LispyLigh@user/lispylights)
