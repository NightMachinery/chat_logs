[00:51:25] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Quit: ec)
[00:51:46] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[01:11:59] *** Quits: GreaseMonkey (greaser@user/greasemonkey) (Quit: No Ping reply in 180 seconds.)
[01:12:06] *** Joins: greaser|q (greaser@antihype.space)
[01:38:46] *** Quits: rotateq (~user@ipservice-092-209-022-135.092.209.pools.vodafone-ip.de) (Quit: tschav mit 'v')
[01:43:37] *** Quits: shka (~herr@109.231.0.226) (Ping timeout: 240 seconds)
[02:47:01] *** Joins: rotateq (~user@p200300e787097300818cd04b4ea1a4f3.dip0.t-ipconnect.de)
[02:57:45] *** Joins: Oladon (~olad@98.43.81.226)
[03:10:42] *** Quits: greaser|q (greaser@antihype.space) (Changing host)
[03:10:42] *** Joins: greaser|q (greaser@user/greasemonkey)
[03:10:53] *** greaser|q is now known as GreaseMonkey
[04:11:03] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[04:19:10] *** Quits: Josh_2 (~user@37.25.47.130) (Remote host closed the connection)
[04:50:35] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Quit: ec)
[04:51:28] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[04:52:32] *** Quits: rotateq (~user@p200300e787097300818cd04b4ea1a4f3.dip0.t-ipconnect.de) (Ping timeout: 240 seconds)
[05:08:20] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Quit: ec)
[05:08:33] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[05:26:17] *** Quits: random-nick (~random-ni@87.116.167.125) (Ping timeout: 240 seconds)
[06:26:30] *** Joins: lisp123 (~lisp123@5.30.23.247)
[07:02:06] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[07:17:57] *** Quits: sts-q (~sts-q@91.200.108.229) (Ping timeout: 240 seconds)
[07:19:57] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[07:23:20] *** Joins: sts-q (~sts-q@91.200.108.162)
[07:34:57] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 268 seconds)
[07:41:55] *** Joins: lisp123 (~lisp123@5.30.23.247)
[08:27:34] *** Quits: lisp123 (~lisp123@5.30.23.247) (Quit: Leaving...)
[08:37:44] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[09:19:14] *** Quits: mfiano (~mfiano@li1282-157.members.linode.com) (Remote host closed the connection)
[09:19:36] *** Joins: mfiano (~mfiano@li1282-157.members.linode.com)
[11:15:05] *** Joins: Jing (~hedgehog@240e:390:7c53:a7e1:315f:3454:b0d8:112e)
[12:06:38] *** Quits: plexi (~orcabot@digital.sanctuary.org) (Ping timeout: 260 seconds)
[12:16:55] *** Joins: plexi (~orcabot@digital.sanctuary.org)
[12:23:59] *** Joins: spiaggia (~user@141-160-190-109.dsl.ovh.fr)
[12:31:58] *** Joins: shka (~herr@109.231.0.226)
[12:55:44] *** Quits: spiaggia (~user@141-160-190-109.dsl.ovh.fr) (Quit: ERC (IRC client for Emacs 26.3))
[13:22:32] *** Quits: Jing (~hedgehog@240e:390:7c53:a7e1:315f:3454:b0d8:112e) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[13:30:43] *** Joins: lisp123 (~lisp123@5.30.23.247)
[13:31:59] *** Joins: Jing (~hedgehog@240e:390:7c53:a7e1:81fd:e333:1e93:e27e)
[13:32:10] *** Joins: rotateq (~user@p200300e78706a00050f72feb644e2401.dip0.t-ipconnect.de)
[13:37:57] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 240 seconds)
[14:30:37] *** Joins: random-nick (~random-ni@87.116.181.150)
[14:56:02] *** Quits: kagevf_ (~jfh@ip68-108-33-76.lv.lv.cox.net) (Ping timeout: 240 seconds)
[15:01:16] *** Joins: kagevf (~jfh@ip68-108-33-76.lv.lv.cox.net)
[15:12:53] *** Quits: kagevf (~jfh@ip68-108-33-76.lv.lv.cox.net) (Ping timeout: 256 seconds)
[15:13:06] *** Joins: kagevf (~jfh@ip68-108-33-76.lv.lv.cox.net)
[15:17:08] *** Joins: artchad (~user@public-gprs225103.centertel.pl)
[15:45:57] *** Joins: lisp123 (~lisp123@5.30.23.247)
[15:46:14] <lisp123> Can I put a macro within a macro?
[15:46:29] <lisp123> (e.g. (defclass () (my-slots-macro)) where my-slots-macro expands into the necessary slot forms
[15:57:35] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[16:06:48] <pjb> lisp123: nope.
[16:07:10] <pjb> lisp123: the reason is because slots are not a lisp form, and a macro must return a lisp form.
[16:07:48] <pjb> instead, write a function: (generate-my-slot-list)  and write a macro (defmacro define-class-with-my-slot-list (…) `(defclass () ,(generate-my-slot-list)))
[16:10:57] <lisp123> pjb: Thanks! That will be very useful
[16:11:34] <pjb> The point is that lisp operators are scoped by their form. You cannot have an effect inside-out. You must define an enclosing operator (macro), and have it process the inside form specifically.
[16:12:11] <pjb> lisp123: take for example, declarations. DECLARE only works in lisp forms that are prepared to process them: LET, LET*, LAMBDA, LOCALLY, etc.  
[16:13:00] <pjb> If you wanted to define an operator similar to DECLARE, you would have to define enclosing forms, to process it.
[16:13:34] <pjb> This where local macros and local functions come handy.  Note how next-method-p and call-next-method are local operators only available in a defmethod scope.
[16:14:25] <pjb> This allows code walking and macro-expansion to work.
[16:17:33] <lisp123> pjb: Thanks for this useful information, just trying to process it now
[16:18:22] <rotateq> lisp123: but you maybe could wrap a symbol-macrolet or macrolet form around
[16:21:38] <lisp123> pjb: Thanks, I think I get most of it. Does that mean something like LET was defined in a way that allows arbitrary macros to occur within it and be macroexpanded?
[16:22:19] <lisp123> rotateq: I will read into that as well
[16:22:54] <rotateq> lisp123: but be careful, they can't fire always (the macrolets). well, at compile-time
[16:23:34] <rotateq> and no, i would say it's more to the macroexpander itself
[16:23:41] <pjb> rotateq: the point is that slot lists in defclass are not lisp forms, they're just literal arguments to defclass, and no macroexpansion is done on them, so symbol-macrolets cannot work.
[16:23:42] <lisp123> (I guess LET is a special form, but assuming it was implemented as a macro)
[16:23:48] <rotateq> LET, LET* and LOCALLY are special ops
[16:24:08] <pjb> rotateq: again, if you want to be able to use such extensions, you need to define your own defclass macro to perform the required macroexpansions.
[16:24:09] <rotateq> okay pjb! thanks :)
[16:24:50] <rotateq> no lisp123, but you can build LET on LAMBDA of course if you want
[16:24:54] <pjb> rotateq: yes. But you can essentially ignore the difference between special operators and macros, since an implementation can implement any special operator as a macro, and any standard macro as a special operator.
[16:25:15] <rotateq> yes yes
[16:25:39] <rotateq> or as shown in the wonderful and heavy 10 pages paper about metacircular semantics
[16:25:52] <rotateq> "oh, now we define LABELS with FLET"
[16:33:05] <lisp123> https://github.com/sbcl/sbcl/blob/d35ad6f9bee212499cb827fec3195bf2064c10a2/src/code/parse-body.lisp#L20
[16:33:14] <lisp123> An Example of what pjb just said
[16:33:23] <lisp123> I get it now - thanks!
[16:39:21] <lisp123> And to answer my own question (For anyone else) -> Does that mean something like LET was defined in a way that allows arbitrary macros to occur within it and be macroexpanded? --> NO when those arbitrary macros return lisp forms
[16:40:45] *** Quits: rotateq (~user@p200300e78706a00050f72feb644e2401.dip0.t-ipconnect.de) (Quit: tschav mit 'v')
[16:41:41] <pjb> lisp123: it depends on the subexpression of let.
[16:41:57] <pjb> lisp123: for example, the first subexpression of let is processed specially, as a list of bindings.
[16:42:23] <lisp123> pjb: Yes, that makes sense
[16:42:25] <pjb> Then let processes one docstring and one or more declare expressions in the body, followed by body forms.
[16:42:41] <pjb> Only the body forms are processed as code form, ie. macroexpanded, etc.
[16:42:48] <lisp123> I never knew LET had docstrings!
[16:42:53] <pjb> Plus the initialization expressions in the bindings, of course.
[16:43:10] <pjb> lisp123: oops, I'm confused, LET doesn't have docstrings.
[16:43:17] <lisp123> ah ok
[16:43:19] <pjb> That would be taken as a body form.
[16:43:47] <lisp123> This all makes sense now, and why PARSE-BODY in SBCL parses for declare expressions
[16:44:15] <pjb> Note how this is a difference between lambda, so the naive transformation (let ((v1 e1) … (vn en)) . body) -> ((lambda (v1 … vn) . body) e1 … en) is faulty.
[16:45:03] <lisp123> I see
[16:45:44] <pjb> well, it still works in this direction. for lambda to let you'd have to be more careful.
[16:46:34] <lisp123> Why is that?
[16:46:34] <pjb> ((lambda (x) "docstring" (declare (integer x)) "result") 2) #| --> "result" |#   (let ((x 2)) "docstring" (declare (integer x)) "result") #| ERROR: While compiling an anonymous function : The DECLARE expression (declare (integer x)) is being treated as a form, possibly because it's the result of macroexpansion. DECLARE expressions can only appear in specified contexts and must be actual subexpressions of the containing forms. |# 
[16:46:49] <pjb> because the docstring can appear in the middle of declarations.
[16:47:06] <pjb> but in a LET, that would stop the processing of DECLAREs 
[16:47:17] <lisp123> Ah got it
[16:49:16] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[16:49:36] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Client Quit)
[17:09:52] *** Quits: santiagopim (~user@90.167.94.91) (Remote host closed the connection)
[17:15:36] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[17:46:41] *** Joins: Josh_2 (~user@37.25.47.130)
[17:50:11] *** Joins: rain3 (~rain3___@2a02:2f09:d113:6d00:6f23:fba2:d834:1a7)
[18:04:21] *** Joins: vats (~vats@103.158.91.47)
[18:07:07] *** Joins: domovod (~domovod@176.196.122.197)
[18:12:29] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[18:16:03] *** Joins: lisp123 (~lisp123@5.30.23.247)
[18:21:01] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[18:38:48] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[19:13:43] *** Joins: lisp123 (~lisp123@5.30.23.247)
[19:41:37] *** Joins: rotateq (~user@185.66.193.48)
[19:54:49] *** Quits: lagash_ (lagash@lagash.shelltalk.net) (Quit: ZNC - https://znc.in)
[19:55:16] *** Joins: lagash (lagash@lagash.shelltalk.net)
[20:04:30] *** Quits: Jing (~hedgehog@240e:390:7c53:a7e1:81fd:e333:1e93:e27e) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[20:14:50] *** Joins: treflip (~user@user/treflip)
[20:17:13] <lisp123> Is it typical practice that symbols that appear as arguments in macro calls should be not quoted?
[20:18:20] <lisp123> Is that a widespread convention?
[20:37:02] <White_Flame> depends on what it's for
[20:37:14] <White_Flame> if you're giving it a variable name, then no it shouldn't be quoted; it's a literal variable
[20:37:28] <White_Flame> the main question is that value going to be evaluated or not
[20:37:39] <White_Flame> it's often quite handy for it to be evaluated
[20:38:17] <lisp123> White_Flame: Yeah I see it mostly in terms of classes being passed into a macro
[20:38:29] <White_Flame> as in the name of a class?
[20:38:41] <lisp123> What would be an example of where evaluating a symbol in a macro call would be handy?
[20:38:56] <White_Flame> (push 'foo x)
[20:39:07] <lisp123> Yes, like (define-interface ... (something class-name) ...) vs 'class-name
[20:40:01] <White_Flame> if you're taking a name, then yes you're probably not going to be parameterizing it further
[20:40:09] <White_Flame> especially for DEFINE-* style forms
[20:40:44] <White_Flame> and if you need to generate the classname, then you can always use another macro around it to do `(define-interface ... (something ,(generate-class-name)))
[20:41:17] <lisp123> Thanks for that example, that indeed is very useful
[20:41:52] <lisp123> Yes, it was just that I got confused a bit since I was used to quoting class-names in make-instance forms, so when I saw this API, my typo wasn't clear immediately
[20:43:32] <lisp123> Thanks White_Flame
[20:43:38] <White_Flame> np
[21:10:30] *** Quits: lisp123 (~lisp123@5.30.23.247) (Quit: Leaving...)
[21:11:30] *** Joins: Jacobis9000 (~jonaholuf@host86-158-34-224.range86-158.btcentralplus.com)
[21:11:36] <Jacobis9000> Hello :)
[21:12:24] *** Quits: Jacobis9000 (~jonaholuf@host86-158-34-224.range86-158.btcentralplus.com) (Client Quit)
[21:13:10] *** Joins: Jacobis9000 (~jonaholuf@host86-158-34-224.range86-158.btcentralplus.com)
[21:18:59] <Jacobis9000> where is the website on which is stored all the LISP functions?
[21:22:44] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[21:24:28] <artchad> Even if this question is bait, here is the link: http://www.lispworks.com/documentation/HyperSpec/Front/index.htm
[21:25:04] <artchad> actually, we're in #clschool, I guess some people don't know about the hyperspec yet.
[21:29:52] <rotateq> one ring to rule ALL lisp functions :)
[21:30:31] <rotateq> it's more said to be symbols, cause not everything is a function and some symbols stand for more than one thing
[21:31:29] <bremner> and of course, because someone has to be that guy, not all lisp functions are in the hyperspec. 
[21:32:11] <rotateq> even sauron wasn't too powerful with the one ring
[21:34:02] <aeth> Right.
[21:34:30] <aeth> Contrast with Haskell's Hoogle, which is literally a site with all of the Haskell functions (in public libraries, anyway)
[21:34:49] <rotateq> oh yes, i mean it's useful, but not always
[21:35:02] <aeth> http://l1sp.org/ could be a much, much lower tech version of Hoogle but it barely has any libraries in it
[21:35:32] <bremner> leftpad.lisp when?
[21:36:33] <aeth> bremner: https://gitlab.com/mbabich/trivial-left-pad
[21:45:24] <kagevf> hmm surprised that not all functions aren't in the hyperspec ... or is that just referring to non-standard functions?
[21:46:41] <kagevf> is there a standard CL function that's not in the hyperspec??
[21:47:09] <kagevf> actually ... I think I can answer my own question with some code pjb provided a few weeks ago ...
[21:50:42] <bremner> kagevf: I was just being a smartass. Obviously many people write lisp functions and these are not in the hyperspec.
[21:50:57] *** Quits: domovod (~domovod@176.196.122.197) (Quit: WeeChat 3.4)
[21:50:59] <bremner> so yeah, referring to non-standard functions
[21:51:28] <bremner> nevermind all _possible_ lisp functions, for the logicians...
[21:58:10] <kagevf> bremner: haha ok :) ... I should've realized that hehehe
[21:59:36] <lagash> How might I 'alias' a type? Say I have (deftype direction () '(member :forwards :backwards)), how best could I 'rename' it, give it a different docstring, etc? The idea being, those two types are essentially identical.
[22:00:18] <kagevf> 636 functions in the standard (or in the CL package - same thing in this case?) ... at least that's what I get when I run do-external-symbols on sbcl
[22:02:25] <Jacobis9000> thanks for the link, I've used the site before but could not remember it nor find it
[22:02:29] *** Joins: Oladon (~olad@98.43.81.226)
[22:02:43] <Jacobis9000> I haven't been doing LISP for some time, I have been studying for my degree
[22:09:39] <lagash> *or at least one is not considered a subtype of the other
[22:13:10] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[22:18:51] <Jacobis9000> So I got really stuck on making a function ADD-VOWELS to add (A E I O U) to a set of letters retaining the status of the list as a set. I was trying IF, COND, all sorts. All it was, was: (defun ADD-VOWELS (x) (union x '(A E I O U)))
[22:19:18] <Jacobis9000> got myself in a right knot
[22:19:29] <rotateq> how about '(#\A #\E #\I #\O #\U) ? :)
[22:19:51] <Jacobis9000> what does #\ do?
[22:20:47] <rotateq> reading in a character object
[22:21:47] <Jacobis9000> Sorry I don't understand
[22:22:03] <rotateq> or better a name and builds up a character object :)
[22:22:21] <rotateq> you can also reference chars by their unicode names this way which is really cool
[22:22:34] <Jacobis9000> Interesting
[22:22:40] <rotateq> #\latin_small_letter_e_with_diaeresis
[22:24:05] <rotateq> or maybe #\nand or #\nor
[22:24:25] <Jacobis9000> can't seem to get that to work in my REPL
[22:24:26] <rotateq> then with (format nil "~a" char) you can pretty print them
[22:24:37] <rotateq> oh that's strange
[22:24:43] <rotateq> which impl do you use?
[22:25:01] <Jacobis9000> SBCL?
[22:25:03] <rotateq> okay
[22:25:10] <rotateq> it should work
[22:25:16] <rotateq> what did you type in?
[22:25:30] <Jacobis9000> I tried: (list '(#\latin_small_letter_e_with_diaeresis))
[22:25:40] <Jacobis9000> and just: #\latin_small_letter_e_with_diaeresis
[22:25:54] <rotateq> just type it in on its own
[22:26:18] <Jacobis9000> It just returns the whole string
[22:26:18] <rotateq> (list #\nand #\nor)
[22:26:25] <rotateq> yes and?
[22:26:49] <Jacobis9000> what is it supposed to do?
[22:28:13] <rotateq> the #\ ? what i said
[22:28:23] <rotateq> a string is a vector of characters
[22:30:57] <rotateq> and chars are not just (multiple) bytes
[22:33:03] <kagevf> you write a character literal with #\ ... and a string is a vector of characters (basically just re-phrasing what rotateq said)
[22:33:10] <rotateq> hehe
[22:33:28] <rotateq> kagevf: my thoughts are mostly useless, so free :)
[22:34:12] <kagevf> rotateq: I was just building on what you already said :)
[22:34:36] <rotateq> :)
[22:35:03] <kagevf> so not useless IMO 
[22:36:54] <Jacobis9000> how do you define a function with multiple parameters? I have forgotten
[22:36:59] <rotateq> but all in all I am useless :)
[22:37:17] <bremner> Jacobis9000: (defun foo (bar baz) ...)
[22:37:24] <bremner> or did you mean something else?
[22:37:26] <Jacobis9000> thank you
[22:37:29] <Jacobis9000> that's it
[22:37:55] <Jacobis9000> (defun foo (bar) (baz) ...) was not working, I should have just tried your way
[22:38:08] <kagevf> rotateq: that can't be true
[22:38:45] <rotateq> oohhh sadly it is, but don't worry
[22:39:35] <rotateq> Jacobis9000: you can also have more flexible lambda lists in function definitions
[22:41:59] <rotateq> with optional arguments and keywords for example
[22:42:16] <rotateq> but maybe first fixed ones to master step by step :)
[22:45:16] *** Quits: treflip (~user@user/treflip) (Remote host closed the connection)
[22:50:28] <rotateq> and well, you could think about how such a DEFUN expression may be macroexpanded
[22:51:21] <rotateq> (defun foo (x y) ...) => (block foo (lambda (x y) ...) ...) or such
[22:51:56] <Jacobis9000> this book has suddenly got too hard for me
[22:52:09] <Jacobis9000> I had no trouble to this point, but have failed to write two functions so far
[22:52:19] <kagevf> Jacobis9000: which one?
[22:52:25] <Jacobis9000> now I am trying to write MY-SUBSETP
[22:52:49] <kagevf> hmmm sounds like "Gentle Intro" ...?
[22:52:59] <Jacobis9000> oh I see, yeah
[22:53:35] <rotateq> which book?
[22:53:36] <kagevf> Jacobis9000: "learn from failure", right?
[22:54:06] <rotateq> err and err and err again, but less and less and less. even knuth has this in his hallway
[22:54:13] <Jacobis9000> No I mean, "Oh I see you were asking which book, yes it is Gentle Intro"
[22:54:17] <rotateq> hehe
[22:55:32] <Jacobis9000> I just can't work it out. If set x is a subset of set y, then substracting y from x should leave the empty set. Write MY-SUBSETP...
[22:55:37] <Jacobis9000> Empty set?
[22:55:39] <Jacobis9000> Eh?
[22:56:05] <rotateq> öhm
[22:56:11] <rotateq> which site?
[22:56:14] <Jacobis9000> My attempts using SET-DIFFERENCE have failed
[22:56:19] <Jacobis9000> I will just look up the answer
[22:56:24] <rotateq> no! :D
[22:56:32] <rotateq> takes the fun out of it
[22:56:38] <rotateq> fun-fun-function
[22:57:15] <Jacobis9000> I can't work out how set-difference works
[22:57:21] <Jacobis9000> It is very confusing
[22:57:36] <rotateq> mathematically maybe?
[22:57:42] <rotateq> but yes, i see
[22:57:51] <rotateq> which site do you refer to in the book?
[22:57:56] <Jacobis9000> site?
[22:57:59] <rotateq> yes?
[22:58:01] <rotateq> page
[22:58:08] <Jacobis9000> page 174
[22:58:16] <rotateq> sry, it's "Seite" in german for page
[22:58:20] <rotateq> okay let me see
[23:06:58] <rotateq> maybe you're better of then with practical common lisp
[23:09:57] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[23:13:02] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[23:16:49] *** Quits: vats (~vats@103.158.91.47) (Ping timeout: 256 seconds)
[23:17:02] <kagevf> it took me a couple of weeks while reading "Gentle Intro" before Lisp started to click ... so I would recommend sticking with Gentle Intro and not to get discouraged
[23:17:26] <kagevf> and I found PCL a lot better *after* going through Gentle Intro ... 
[23:18:40] <pjb> Jacobis9000: do you know the set difference operator?  {1,2,3,4}∖{3,4,5,6} = {1,2} ?
[23:18:54] <pjb> Jacobis9000: this is what SET-DIFFERENCE computes.
[23:19:24] <pjb> Jacobis9000: but first you need to understand the representation used for sets by those lisp set operators  (intersection, union, set-difference).
[23:20:55] <pjb> Jacobis9000: sets are lists of elements.  The elements are distinguished by EQL (unless you pass a :test argument to the operator).  They may also be mapped from the list elements using the :key argument.  The important point here is that there can be duplicates in the list, representing the same set: (1 1) = (1) = {1}
[23:21:26] <pjb> (set-difference '(1 2 3 4) '(3 4 5 6)) #| --> (2 1) |# 
[23:21:33] <pjb> and of course, order doesn't matter.
[23:23:22] <pjb> (defun my-subsetp (sub set &key (test (function eql)) (key (function identity))) (null (set-difference sub set :test test :key key))))
[23:29:40] <pjb> lagash: just use deftype: (deftype orientation () "a kind of direction" 'direction)
[23:29:43] *** Quits: artchad (~user@public-gprs225103.centertel.pl) (Read error: Connection reset by peer)
[23:31:12] <pjb> rotateq: actually it's (lambda (x y) docstring declarations… (block foo . rest-of-body))
[23:32:05] <rotateq> yes thx pjb
[23:33:47] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[23:34:29] *** Quits: rain3 (~rain3___@2a02:2f09:d113:6d00:6f23:fba2:d834:1a7) (Ping timeout: 268 seconds)
