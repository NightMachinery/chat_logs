[00:00:39] *** Joins: lottaquestions (~nick@2607:fa49:503e:3000:61ba:b577:79b9:2407)
[00:36:46] *** Joins: Alex[m] (~thekkidda@2001:470:69fc:105::feaf)
[00:37:26] *** Quits: shka (~herr@109.231.62.239) (Ping timeout: 252 seconds)
[01:04:06] *** Quits: lottaquestions (~nick@2607:fa49:503e:3000:61ba:b577:79b9:2407) (Ping timeout: 260 seconds)
[01:10:55] *** Joins: lottaquestions (~nick@2607:fa49:503e:3000:a123:232c:fae5:3bd8)
[01:23:14] *** Quits: Josh_2 (~user@37.25.47.130) (Ping timeout: 260 seconds)
[01:34:54] *** Quits: lottaquestions (~nick@2607:fa49:503e:3000:a123:232c:fae5:3bd8) (Ping timeout: 260 seconds)
[02:43:06] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[02:50:13] *** Joins: beach` (~user@2a01:cb19:150:3400:2a6:806:3923:229)
[02:54:19] *** Quits: beach (~user@2a01:cb19:150:3400:893d:92a4:273f:ff45) (Ping timeout: 252 seconds)
[02:57:19] *** Quits: random-nick (~random-ni@87.116.178.231) (Ping timeout: 265 seconds)
[03:16:46] *** Joins: lisp123 (~lisp123@5.30.23.247)
[03:25:18] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[03:25:21] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[03:42:50] *** Joins: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net)
[03:45:32] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 252 seconds)
[04:59:24] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[05:31:54] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[05:34:52] *** Quits: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 252 seconds)
[05:46:26] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 260 seconds)
[05:55:20] *** Quits: sts-q (~sts-q@91.200.108.209) (Ping timeout: 252 seconds)
[06:03:50] *** Joins: sts-q (~sts-q@212.53.219.238)
[06:15:46] *** Quits: hendursaga (~weechat@user/hendursaga) (Quit: hendursaga)
[06:16:16] *** Joins: hendursaga (~weechat@user/hendursaga)
[06:46:52] *** beach` is now known as beach
[06:47:07] *** ChanServ sets mode: +o beach
[06:48:13] *** beach sets mode: -o beach
[07:22:48] *** Joins: lisp123 (~lisp123@5.30.23.247)
[07:31:26] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 260 seconds)
[08:12:39] *** Joins: lisp123 (~lisp123@5.30.23.247)
[09:19:57] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[09:23:07] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 252 seconds)
[09:38:08] *** Joins: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net)
[09:40:43] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 252 seconds)
[09:43:08] *** Joins: shka (~herr@109.231.62.239)
[10:54:49] *** Quits: lisp123 (~lisp123@5.30.23.247) (Quit: Leaving...)
[10:55:12] *** Joins: lisp123 (~lisp123@5.30.23.247)
[11:35:19] *** Joins: hendursa1 (~weechat@user/hendursaga)
[11:38:51] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[11:59:16] *** Joins: treflip (~user@95.79.32.99)
[12:26:44] *** Joins: st_iron (uid370243@id-370243.uxbridge.irccloud.com)
[12:26:50] <lisp123> Another Qn - Is this a valid use of Eval - To combine with ` to splice a list? https://plaster.tymoon.eu/view/2644#2644
[12:46:09] <beach> Why do you have source code in the first place and not already a function?
[12:47:45] <mfiano> No that's not a good use for eval.
[12:47:52] <mfiano> Something smells bad about that code.
[12:48:17] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[12:48:21] <mfiano> One of the only "good" uses of eval I can think of, is in compiler macros after testing for a constant variable.
[12:48:52] *** Joins: lisp123 (~lisp123@5.30.23.247)
[12:49:12] <beach> lisp123:  It looks like you are deliberately creating strange situations where you then need to use unconventional code to fix them up. 
[12:49:20] <beach> Not just this time.  Often!
[12:54:17] <mfiano> From the call-site, it looks like LOG-DEFUN is a macro and you are trying to expand it at runtime...
[12:54:37] <mfiano> I really don't understand how you got into this situation.
[12:54:59] <beach> That's the sort of thing I am referring to.
[12:55:58] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[12:57:25] <mfiano> Yeah, reading it closer I can see there is some confusion on which parts of your code should be done at macro-expansion time and which at runtime.
[12:58:59] *** Joins: lisp123 (~lisp123@5.30.23.247)
[12:59:19] <lisp123> Ok
[12:59:29] <mfiano> Unrelated, but I think it was you who asked about DESTRUCTURING-BIND yesterday or so. In your code you are taking the SECOND, THIRD, and NTH-CDR, which is expensive, since it follows the same chain of conses multiple times. D-B would solve this.
[13:00:33] <lisp123> mfiano: Good idea, thanks
[13:01:53] <mfiano> Your main issue is of architectural reasoning though. You must clearly envision what parts of your code should be performed at macro-expansion time. It helps to sketch out your API first, rather than adding on to an ill-formed idea with unconventional code.
[13:03:06] <lisp123> beach: Why do you have source code in the first place and not already a function? --> This is the source code that I need to transform for logging, its not a straight forward transformation so I need to access the actual code of it
[13:03:45] <beach> lisp123: Maybe so, but I have serious doubts about that.
[13:03:51] <lisp123> mfiano: I'm more or less done :) Will share my 'Autologger' tool today hopefully, it looks good so far
[13:06:31] <lisp123> beach: I like to break boundaries and try new things. Maybe I ask stupid questions from time to time, but that's only because I try to learn to the fullest extent possible and question each part until it makes sense to me. It's not like I am some sort of idiot :)
[13:06:32] <mfiano> Software is never "done", and I have doubts it is "good" given the problems I've seen you manufacture. I am not trying to be offensive, just stating some observations.
[13:07:34] <beach> lisp123: Yes, I know.  I am just pointing out that many of the things you try seem to get into situations like I described.
[13:07:51] <lisp123> mfiano: That's fine, perhaps my level of what is "good" is much lower than others. At least I'm happy with it :) No offense taken. There's also a balance that needs to be done between "perfect code" and what works. I need to move on from my autologger tool, so for me good is good enough :)
[13:08:26] <mfiano> "perfect code" is an oxymoron. It's trade-offs all the way down.
[13:08:42] <beach> lisp123: So, it would be useful to sometimes ask yourself "how did I get into this situation, and can I avoid it" rather than "now that I am in this situation, how can I deal with it".
[13:09:18] <beach> lisp123: Like, in this case "How did I create the necessity for using EVAL, and how can I avoid that situation?"
[13:10:02] <mfiano> Rgw baqwe ub rgua xaw might just be to move some of the logic of LOG into a macrolet.
[13:10:07] <mfiano> Whoops
[13:10:13] <mfiano> The answer in this case might...
[13:11:30] <mfiano> But I didn't look too closely. I tend to sketch out the interface of macros before I implement them, and think carefully about what needs to be computed at macro-expansion time vs run-time.
[13:11:45] <mfiano> I think this is a good habit to have. It might benefit you as well.
[13:11:45] <lisp123> beach: Yes, but that's a different question (and it seems like there is an assumption that I won't look at that part seperately myself). The question was that ` provides a convenient way to shorthand splicing alist via ,@  --> However to access that at run-time, one needs to eval the quoted form
[13:12:14] <lisp123> Now the answer by mfiano on destructring-bind is the solution
[13:12:18] <lisp123> (I think)
[13:12:23] <beach> lisp123: ` and ,@ work fine at run time.
[13:12:44] <lisp123> Is it possible to write `,@var?
[13:12:58] <mfiano> That is nonsensical
[13:13:47] <lisp123> Yes, so I wanted to splice var into the parent list --> (eval `(log-defun ,(second source-def) ,(third source-def) ,@(nthcdr 3 source-def)))
[13:14:09] <lisp123> Now, eval isn't aware of the lexical environment, but that is not an issue in this case
[13:14:17] <beach> You can write `(hello ,@var) though.
[13:14:29] <lisp123> but then hello won't run -> I need to eval it
[13:14:49] <lisp123> (unless I'm mistaken)
[13:15:00] <pjb> lisp123: is log-defun a macro?
[13:15:20] <beach> The question is why you have a LOG-DEFUN as a macro in the first place. 
[13:15:23] <pjb> lisp123: if it is a macro, then make log a macro too that just expand to log-defun. No eval.
[13:15:32] <pjb> lisp123: if it is a function, then just call it. No eval.
[13:15:44] <pjb> lisp123: if you need to splice arguments of a function, use apply.
[13:16:17] <lisp123> pjb: if you need to splice arguments of a function, use apply. --> Thanks, that (& destructuring-bind) answer the question
[13:16:32] <pjb> lisp123: (apply (funciton log-defun) (second source-def) (third source-def) (nthcdr 3 source-def)) or just (apply (funciton log-defun) (rest source-def))
[13:16:38] <lisp123> Thanks for that. The rest is just questioning the code, which is unrelated to the question I asked
[13:16:40] <mfiano> Is log-defun a macro or function?
[13:17:25] <mfiano> given you didn't quote the nth-cdr argument, i'd assume the former.
[13:17:53] <lisp123> Like obviously I'm not going to have perfect code, I was just asking some specific questions that came to my mind. We shouldn't have to have perfect code everywhere to ask a question!
[13:18:37] <lisp123> mfiano: Yes its a macro, and there's likely a better way to do it. But that wasn't the question so I rather not enter into that discussion :)
[13:19:01] <mfiano> Why is it a macro?
[13:19:17] <mfiano> It seems like it should be a function. This could be the root of your issue
[13:19:21] <pjb> what code transformation or generation is it doing?
[13:19:23] <mfiano> So let's _not_ ignore it
[13:19:40] <mfiano> Macros are for syntactical abstractions and evaluation control. Is it doing any of that?
[13:19:54] <pjb> assuming it expands to a defun, then LOG should be a macro too.
[13:19:55] <lisp123> https://plaster.tymoon.eu/view/2646#2646
[13:20:23] <pjb> and since it would expand to a defun, hence definining something new, it should be renamed something like DEFINE-LOG.
[13:20:25] <lisp123> (sorry for the indenting)
[13:20:30] <mfiano> Ok, multiple issues in that code
[13:21:38] <lisp123> pjb: Probably. It's a bit too advanced for me, so I'm just getting it done now - in a few months I'll probably come back and fix it all :)
[13:22:05] <pjb> lisp123: note that TRACE is a macro.
[13:22:30] <pjb> or s/log/add-logging/
[13:22:52] <mfiano> lisp123: The biggest issue I see is you didn't gensym RESULT
[13:23:19] <lisp123> mfiano: Thanks, good point
[13:25:07] <mfiano> This code is hurting my brain. Like why are the special variables in the lambda list of LAMBDA? That makes no sense to me
[13:25:19] <mfiano> They are special variables!
[13:25:53] <lisp123> Don't worry about it, I don't want to waste everyone's time here
[13:26:08] <pjb> lisp123: in your case, I thing you should have a function to do the job of log-defun.
[13:26:21] <mfiano> You are not wasting my time. I am genuinely curious. That doesn't seem like it's going to do what you want.
[13:26:37] <mfiano> and I was about to suggest what pjb just did.
[13:26:42] <pjb> lisp123: basically log-defun redefines a function at run-time. You should do that with (setf (symbol-function fname) new-lambda) instead of defun.
[13:27:57] <mfiano> What even happens if you lexically bind a special variables symbol in a function's parameters, pjb or beach?
[13:28:08] <mfiano> THat code is hurting my brain...never seen that before
[13:28:53] <mfiano> Line 8 is what I'm referring to
[13:29:44] <lisp123> pjb: I wanted to learn & use macros also :) But I think I agree with you, looks like it can be done completely with a function
[13:39:42] *** Joins: rain3 (~rain3___@2a02:2f09:d100:8700:1ae4:6be9:2a58:7de6)
[13:45:54] *** Joins: random-nick (~random-ni@87.116.178.231)
[13:46:05] *** Quits: lisp123 (~lisp123@5.30.23.247) (Quit: Leaving...)
[13:51:26] <pjb> lisp123: learning macros is also learning when not to use macros. There are only about ~80 macros in CL vs. ~640 functions  https://termbin.com/uqik2
[14:17:43] *** Joins: selwyn (~selwyn@user/selwyn)
[14:17:59] *** Quits: selwyn (~selwyn@user/selwyn) (Remote host closed the connection)
[14:18:24] *** Joins: selwyn (~selwyn@user/selwyn)
[14:29:03] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[14:49:10] *** Joins: selwyn (~selwyn@user/selwyn)
[14:49:56] *** Quits: selwyn (~selwyn@user/selwyn) (Remote host closed the connection)
[14:50:20] *** Joins: selwyn (~selwyn@user/selwyn)
[15:02:14] *** Quits: rain3 (~rain3___@2a02:2f09:d100:8700:1ae4:6be9:2a58:7de6) (Ping timeout: 260 seconds)
[15:26:44] *** Quits: treflip (~user@95.79.32.99) (Quit: ERC (IRC client for Emacs 27.2))
[16:00:15] *** Joins: rain3 (~rain3___@2a02:2f09:d100:8700:1ae4:6be9:2a58:7de6)
[16:23:57] *** Joins: Josh_2 (~user@37.25.47.130)
[16:33:25] *** Quits: Josh_2 (~user@37.25.47.130) (Remote host closed the connection)
[16:41:39] *** Joins: tyson2 (~user@70.31.33.162)
[16:56:29] *** Quits: st_iron (uid370243@id-370243.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[16:59:40] *** Quits: rain3 (~rain3___@2a02:2f09:d100:8700:1ae4:6be9:2a58:7de6) (Ping timeout: 252 seconds)
[17:23:04] *** Joins: Josh_2 (~user@37.25.47.130)
[17:42:34] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[18:11:50] *** Quits: hendursa1 (~weechat@user/hendursaga) (Quit: hendursa1)
[18:12:15] *** Joins: hendursaga (~weechat@user/hendursaga)
[18:30:30] *** Joins: lisp123 (~lisp123@5.30.23.247)
[18:33:18] *** Quits: plexi (~orcabot@digital.sanctuary.org) (Quit: Don't panic!)
[18:35:08] *** Joins: plexi (~orcabot@digital.sanctuary.org)
[18:35:45] *** Joins: thrig (~thrig@65.113.153.50)
[18:39:20] *** Quits: shka (~herr@109.231.62.239) (Ping timeout: 265 seconds)
[18:53:40] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[18:54:29] *** Joins: lisp123 (~lisp123@5.30.23.247)
[18:59:05] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[19:09:10] *** Joins: st_iron (uid370243@id-370243.uxbridge.irccloud.com)
[19:09:53] *** Joins: lisp123 (~lisp123@5.30.23.247)
[19:13:38] *** Joins: lottaquestions (~nick@2607:fa49:503e:3000:dd05:5816:a203:9234)
[20:09:41] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[20:42:49] <lisp123> pjb & beach & all: Thanks for all your help over the last few weeks, I've finalised v0.1 of Autologger, which you may feel free to use / fork & improve etc: https://github.com/ashok-khanna/autologger
[20:43:10] <lisp123> Lots to go, but its getting there. Cheers
[21:04:07] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[21:12:12] *** Joins: rain3 (~rain3___@86.127.200.187)
[21:17:55] <lotuseater> i would like to say something about that file, but I should wait till they come back
[21:19:48] *** Joins: lisp123 (~lisp123@5.30.23.247)
[21:20:24] <lotuseater> lisp123: it's not necessary to write out this big list in the end
[21:20:43] <lotuseater> and *cl-functions* is not a good name either (sry)
[21:20:45] <lisp123> lotuseater: which one?
[21:21:02] <lotuseater> in you file cl-autologger.lisp
[21:22:02] <lotuseater> (defvar *cl-symbols* #.(loop for s being the external-symbols in (find-package :cl) collect s))
[21:23:30] <lisp123> brb
[21:23:37] <lotuseater> unfortunately the list you have there has 1522 elements, when doing (length (remove-duplicates *cl-functions*)) 752 remain
[21:28:29] <lisp123> I think I needed to have a list due to some shadowing that was taking place, I could probably remove duplicates thoug, didn't realise there would be any
[21:29:56] <lotuseater> for example it doesn't contain '(** *** ++ +++ // /// &aux &key ... *print-circle* *read-eval* ...)
[21:30:18] <lotuseater> any? over twice as much
[21:32:34] <lisp123> I'll look into why that's happening, perhaps its :CL & :CL-USER somehow
[21:33:12] <lisp123> It's not exactly double, which is interesting
[21:36:28] <lotuseater> anyway having such a big list of symbols that can be computed in the file makes it very noisy
[21:37:05] <lisp123> I don't have a way to compute it
[21:37:26] <lisp123> Right above the list is the code to compute it, so its not like I don't know how
[21:37:45] <lotuseater> so you may have your custom *shadows* list or such and instead do (defvar *cl-symbols* #.(loop for s being the external-symbols in (find-package :cl) unless (member *shadows*) collect s))
[21:38:30] <lotuseater> but it doesn't seem to work correctly
[21:39:59] <lotuseater> of course I appreciate what you have there
[21:40:57] <lisp123> It's a long work in progress, but hopefully it can inspire someone to do something better - the idea I think is ok
[21:41:43] <lotuseater> did you look at log4cl?
[21:42:31] <lisp123> I did - but its different. You have to insert the logging statements into your code, which I wanted to avoid
[21:43:16] <lisp123> Also mine has an Emacs interface to go U/D/N/P across logging levels -> Some of my functions have too many recursive calls / nested calls, it was a necessity to build something to navigate them
[21:47:33] <lotuseater> ok
[22:12:15] *** Quits: thrig (~thrig@65.113.153.50) (Remote host closed the connection)
[22:33:28] *** Quits: rain3 (~rain3___@86.127.200.187) (Ping timeout: 252 seconds)
[22:45:26] <pjb> lisp123: learning macros is also learning when not to use macros. There are only about ~80 macros in CL vs. ~640 functions  https://termbin.com/uqik2
[22:47:31] <lisp123> I agree
[22:47:47] <pjb> lisp123: if you really want the functions specified in the comment, then read my termbin paste to see how to get them!
[22:49:51] <lisp123> pjb: Thanks
[22:50:16] <pjb> Note:  you need to test for macro-function first because macros are also fboundp.
[22:50:36] <lisp123> Yes, I noticed that
[22:50:42] <pjb> and normally, for special-operator-p too, because the implementation is free to fbind them too.
[22:51:14] <lisp123> Isee
[22:51:49] <pjb> Now, since macros can be implemented as special-operators, perhaps macro-function should be tested first too.
[22:52:21] <lisp123> Is it the other way also?
[22:52:27] <pjb> when macros are implemented as special operators, the implementation must stil  provide a macro-function for them.
[22:52:36] <pjb> and yes it's also the other way.
[22:53:44] <pjb> Note that the spec for special-operator-p refers the fixed list of symbols: special operator n. one of a fixed set of symbols, enumerated in Figure 3-2, that may appear in the car of a form in order to identify the form as a special form. 
[22:53:55] <pjb> it's independent on whether the implementation implements them as macros.
[22:53:59] <White_Flame> also inline functions are very useful if you're considering performance.  Even if it does a bunch of "runtime" checks, those could be statically eliminated when inlined
[22:54:02] *** Joins: selwyn (~selwyn@user/selwyn)
[22:56:54] <lisp123> pjb: Thanks
[22:57:03] <lisp123> White_Flame: Yes, for sure :)
[22:57:37] <White_Flame> I bring it up as some people in learning turn to macros for performance, when inline functions could do the same and are generally better
[22:57:58] <pjb> Indeed.
[22:58:31] *** Quits: st_iron (uid370243@id-370243.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[23:08:50] *** Quits: tyson2 (~user@70.31.33.162) (Quit: ERC (IRC client for Emacs 27.2))
[23:09:34] <mfiano> True, but unlike macros, honoring inline isn't mandated. Only notinline, special and optimize/safety are required.
[23:21:41] *** Quits: lisp123 (~lisp123@5.30.23.247) (Quit: Leaving...)
[23:27:57] <White_Flame> right, this is hand-in-hand with your implementation, which if you're concerned about execution speed will be sbcl
[23:38:46] <lotuseater> "Hello, this is your special operator speaking."
