[00:04:14] *** Quits: mro (~mro@port-92-195-240-9.dynamic.as20676.net) (Ping timeout: 265 seconds)
[00:05:08] <d_bot> <Alistair> Continuing this, suppose I have the module ```
[00:05:08] <d_bot> <Alistair> module Dependent_list (T : sig type _ t end) = struct
[00:05:09] <d_bot> <Alistair>
[00:05:10] <d_bot> <Alistair>   type nil = | Nil
[00:05:12] <d_bot> <Alistair>
[00:05:13] <d_bot> <Alistair>   type _ t =
[00:05:14] <d_bot> <Alistair>     | [] : nil t
[00:05:16] <d_bot> <Alistair>     | (::) : 't T.t * 'ts t -> ('t * 'ts) t
[00:05:17] <d_bot> <Alistair>
[00:05:18] <d_bot> <Alistair> end
[00:05:19] <d_bot> <Alistair> ```
[00:07:14] <d_bot> <Alistair> Is there a way to write something like: ```ocaml
[00:07:15] <d_bot> <Alistair> type _ expr =
[00:07:16] <d_bot> <Alistair>   | ...
[00:07:18] <d_bot> <Alistair>   | Texp_tuple : 'ts (Dependent_list (struct type nonrec 'a t = 'a expr)).t -> 'ts expr
[00:07:19] <d_bot> <Alistair> ```
[00:10:34] <d_bot> <infrandomness> isn't that for reason?
[00:10:38] <d_bot> <infrandomness> I use OCaml
[00:16:47] *** Joins: Tuplanolla (~Tuplanoll@91-159-69-50.elisa-laajakaista.fi)
[00:37:41] <d_bot> <octachron> @TheBloodlessMan , you need to go through a recursive module to have a name for the argument of Dependent_list, note that you can use the type-only recursive module trick `module rec M: ... = M and N : ... = F(M)`
[00:48:58] *** Quits: rgrinberg (~textual@186.4.37.225) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[01:17:46] *** Quits: mosterdt_ (~mosterdt@user/mosterdt) (Remote host closed the connection)
[01:30:45] *** Quits: jess (~jess@libera/staff/jess) (Quit: Lost terminal)
[01:31:23] *** Joins: jess (~jess@libera/staff/jess)
[01:41:13] *** Joins: rgrinberg (~textual@ip11-246-50-179.ct.co.cr)
[01:55:33] <d_bot> <Et7f3> What is the difference of "failed test" and "unexpected errors" in OCaml testsuite ?
[02:18:20] *** Joins: vicfred (~vicfred@user/vicfred)
[02:24:35] *** Joins: grobe0ba (grobe0ba@mars.pulpie.xyz)
[02:31:30] *** Quits: Haudegen (~quassel@178.115.237.87.static.drei.at) (Ping timeout: 260 seconds)
[02:33:12] <d_bot> <crackcomm> I'd guess one is different output and second is an exception thrown
[02:34:30] *** Quits: zebrag (~chris@user/zebrag) (Quit: Konversation terminated!)
[02:42:51] *** Joins: shawnw (~shawn_w@c-73-225-121-73.hsd1.wa.comcast.net)
[02:57:25] *** Quits: Tuplanolla (~Tuplanoll@91-159-69-50.elisa-laajakaista.fi) (Quit: Leaving.)
[03:01:34] *** Quits: rgrinberg (~textual@ip11-246-50-179.ct.co.cr) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[03:06:47] *** Joins: hexology (~hexology@user/hexology)
[03:54:14] *** Joins: rgrinberg (~textual@ip11-246-50-179.ct.co.cr)
[04:02:32] *** Quits: hyphen (~hyphen@156.208.61.77) (Ping timeout: 258 seconds)
[04:44:13] *** Joins: hyphen (~hyphen@156.208.92.252)
[07:57:19] *** Joins: mbuf (~Shakthi@122.178.207.237)
[08:27:40] *** Quits: ansiwen (~sanders@vm1.a6n.de) (Quit: ZNC 1.7.1 - https://znc.in)
[08:29:58] *** Joins: ansiwen (~sanders@vm1.a6n.de)
[09:21:11] *** Quits: rgrinberg (~textual@ip11-246-50-179.ct.co.cr) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[09:33:59] *** Quits: shawnw (~shawn_w@c-73-225-121-73.hsd1.wa.comcast.net) (Ping timeout: 264 seconds)
[09:40:23] *** Joins: gravicappa (~gravicapp@145.255.9.64)
[10:12:06] *** Joins: mro (~mro@port-92-195-202-101.dynamic.as20676.net)
[10:28:49] *** Joins: Exagone313 (exa@irc.moe)
[10:29:18] *** Joins: jonasbits_ (~quassel@2a00:66c0:1:1::58)
[10:30:34] *** Joins: ski_ (~ski@remote12.chalmers.se)
[10:31:00] *** Joins: dinosaure1 (~dinosaure@163.172.65.89)
[10:34:36] *** Joins: daimrod2 (~daimrod@loire.omecha.info)
[10:37:41] *** Joins: tizoc` (~user@li296-221.members.linode.com)
[10:39:50] *** Quits: Franciman (~Franciman@mx1.fracta.dev) (Ping timeout: 260 seconds)
[10:39:50] *** Quits: Exa (exa@irc.moe) (Ping timeout: 260 seconds)
[10:39:50] *** Quits: smondet[m] (~smondetma@2001:470:69fc:105::b33) (Ping timeout: 260 seconds)
[10:39:50] *** Quits: mewfree[m] (~mewfreema@2001:470:69fc:105::c904) (Ping timeout: 260 seconds)
[10:39:50] *** Exagone313 is now known as Exa
[10:39:50] *** Quits: tizoc (~user@li296-221.members.linode.com) (Ping timeout: 260 seconds)
[10:39:50] *** Quits: ski (~ski@remote12.chalmers.se) (Ping timeout: 260 seconds)
[10:39:50] *** Quits: dinosaure (~dinosaure@163.172.65.89) (Ping timeout: 260 seconds)
[10:39:50] *** Quits: daimrod1 (~daimrod@loire.omecha.info) (Ping timeout: 260 seconds)
[10:39:50] *** Quits: jonasbits (~quassel@2a00:66c0:1:1::58) (Ping timeout: 260 seconds)
[10:40:21] *** Joins: Franciman (~Franciman@mx1.fracta.dev)
[10:45:38] *** Joins: mewfree[m] (~mewfreema@2001:470:69fc:105::c904)
[10:45:51] *** Joins: smondet[m] (~smondetma@2001:470:69fc:105::b33)
[10:52:33] *** Joins: Haudegen (~quassel@178.115.237.87.static.drei.at)
[11:07:55] *** Quits: vicfred (~vicfred@user/vicfred) (Quit: Leaving)
[11:39:17] *** Joins: hendursa1 (~weechat@user/hendursaga)
[11:42:45] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[11:53:40] <d_bot> <octachron> @Et7f3 : failed test: the test was run, behaved as expected and reported a "failed" result. unexpected error: there was an error when trying to run the test and no reporting was ever done.
[11:58:18] *** Joins: bobo (~bobo@37.164.39.78)
[11:58:36] *** Quits: spip (~bobo@37.172.108.3) (Ping timeout: 265 seconds)
[12:00:56] <d_bot> <joris> Hi, a week ago i created a new local switch with  opam. At this time, i had LDFLAGS set on my local shell. Since then, opam keeps trying to reuse this LDFLAGS value in all build, even though it is not in env anymore 🤯
[12:01:02] <d_bot> <joris> any idea where this state is stored ?
[12:01:38] *** Quits: mro (~mro@port-92-195-202-101.dynamic.as20676.net) (Remote host closed the connection)
[12:02:03] *** Joins: mro (~mro@2002:5cc3:ca65:0:ace1:e7b6:4c55:5c3d)
[12:05:09] *** Joins: olle (~olle@i5E8666F6.versanet.de)
[12:06:47] *** Quits: mro (~mro@2002:5cc3:ca65:0:ace1:e7b6:4c55:5c3d) (Remote host closed the connection)
[12:07:49] *** Joins: mro (~mro@port-92-195-202-101.dynamic.as20676.net)
[12:41:37] *** Quits: mro (~mro@port-92-195-202-101.dynamic.as20676.net) (Remote host closed the connection)
[12:41:56] *** Joins: mro (~mro@port-92-195-202-101.dynamic.as20676.net)
[12:54:57] *** Joins: bartholin (~bartholin@158.110.155.0)
[13:10:34] <d_bot> <joris> whatever i'm recreating the switch
[13:45:03] *** Joins: cedric (~cedric@2a01:cb11:821:7c00:1b9d:4c8d:f219:3247)
[14:09:19] *** tizoc` is now known as tizoc
[14:18:28] *** Joins: rond_ (~rond_@2a02:a31a:a23c:f480:2fd7:e087:5546:a438)
[14:29:49] *** Joins: kakadu (~kakadu@195.19.236.234)
[14:53:19] <sim642> Switched a dune-project from 2.3 to 2.8 and now the binaries it produces have no write permissions any more. Why is that? I have some scripts which copy those out for usage, so it screws with that overwriting.
[15:04:22] <d_bot> <Emile Trotignon> reason is just another syntax for ocaml. You can mix them with no particular configuration in a given project. Just name the reason files .re and the ocaml files .ml, and everything will work fine
[15:10:51] *** Quits: mro (~mro@port-92-195-202-101.dynamic.as20676.net) (Remote host closed the connection)
[15:12:42] <d_bot> <Emile Trotignon> However its true that revery is easier to use with reason syntax, but its not a requirement at all.
[15:19:48] *** Joins: glassofethanol (~ethanmorg@82.16.192.251)
[15:22:34] *** Quits: gravicappa (~gravicapp@145.255.9.64) (Ping timeout: 258 seconds)
[15:24:16] *** Quits: glassofethanol (~ethanmorg@82.16.192.251) (Client Quit)
[15:24:32] *** Joins: glassofethanol (~ethanmorg@82.16.192.251)
[15:24:51] *** Joins: mro (~mro@port-92-195-202-101.dynamic.as20676.net)
[15:29:28] *** Quits: mro (~mro@port-92-195-202-101.dynamic.as20676.net) (Ping timeout: 258 seconds)
[15:35:01] *** Quits: Haudegen (~quassel@178.115.237.87.static.drei.at) (Quit: Bin weg.)
[15:42:35] *** Quits: bobo (~bobo@37.164.39.78) (Ping timeout: 260 seconds)
[15:54:20] *** Quits: hackinghorn (~hackingho@user/hackinghorn) (Quit: Leaving)
[15:56:13] *** Joins: gareppa (~gareppa@user/gareppa)
[15:56:15] <vsiles> sim642: strange, I'm getting a .exe with the executable rights with 2.9
[15:57:40] *** Quits: gareppa (~gareppa@user/gareppa) (Remote host closed the connection)
[15:57:59] <vsiles> what file system are you building on ?
[16:07:26] *** Joins: bobo (~bobo@37.172.246.51)
[16:13:52] *** Joins: spip (~bobo@37.172.31.171)
[16:14:10] *** Quits: bobo (~bobo@37.172.246.51) (Ping timeout: 252 seconds)
[16:15:30] <leah2> i'm trying to build coq 8.14 with dune, but it fails linking the toplevels... it passes /usr/lib/ocaml/zarith/zarith.cma directly as an argument, but then can't find dllzarith.so (same dir), how can i make it use a -I /usr/lib/ocaml/zarith line?
[16:16:24] <Franciman> hi leah2 :P
[16:16:36] <leah2> ;)
[16:21:37] *** Quits: mbuf (~Shakthi@122.178.207.237) (Quit: Leaving)
[16:36:49] *** Joins: Haudegen (~quassel@91.114.49.10)
[16:40:58] *** Joins: mro (~mro@port-92-195-202-101.dynamic.as20676.net)
[16:45:35] *** Quits: mro (~mro@port-92-195-202-101.dynamic.as20676.net) (Ping timeout: 260 seconds)
[16:46:26] *** Quits: nfc_ (nfc@tilde.institute) (Ping timeout: 260 seconds)
[16:56:32] *** Quits: glassofethanol (~ethanmorg@82.16.192.251) (Quit: leaving)
[16:58:46] <saltrocklamp[m]> in `try do_stuff with BadThing -> ...`, how do i get access the exception itself? e.g. to use `Printexc.to_string` on it.
[16:59:37] <octachron> the exception itself is `BadThing`?
[17:00:23] <octachron> in other words, `BadThing` is a standard extension constructor of the type `exn`
[17:07:43] <smondet[m]> to give it a name you can use `as`
[17:08:12] <saltrocklamp[m]> yes, e.g. `Stream.Failure`
[17:08:18] <smondet[m]> `with Bad_thing as this_exn -> OPrintexc.to_string this_exn`
[17:08:26] <saltrocklamp[m]> and thanks smondet , that looks like it worked
[17:11:03] *** Quits: gopiandcode (~kirang@137.132.213.138) (Ping timeout: 258 seconds)
[17:13:33] *** Joins: nfc_ (nfc@tilde.institute)
[17:14:26] *** Quits: tomku (~tomku@user/tomku) (Quit: Lost terminal)
[17:16:07] *** Joins: mro (~mro@port-92-195-202-101.dynamic.as20676.net)
[17:23:28] *** Joins: gopiandcode (~kirang@137.132.213.138)
[17:24:11] <d_bot> <NULL> What octachron was implying is that for an exception without arguments, you don't need to name it to reuse it, `Printexc.to_string Bad_thing` will be the same as `Printexc.to_string this_exn` (and when there are arguments, you could repass them). Naming is easier in this case
[17:24:26] <d_bot> <NULL> in this last* case
[17:25:37] *** Quits: mro (~mro@port-92-195-202-101.dynamic.as20676.net) (Ping timeout: 258 seconds)
[17:26:45] <saltrocklamp[m]> oh, i see
[17:27:41] *** Joins: bobo (~bobo@37.173.213.27)
[17:28:08] <saltrocklamp[m]> i am now looking into ocamldoc syntax, and it looks like record member comments come after the record, on the same line. is it also possible to put the comment before the record? i have a somewhat detailed doc comment and it looks very ugly to have it dangling off the right side
[17:28:36] <companion_cube> it doesn't have to be on the same line
[17:28:46] <companion_cube> but you can't have an empty line between the record and comment.
[17:29:16] <saltrocklamp[m]> ok, so the comment can be on the line right below it? as opposed to above, like in most other cases
[17:29:50] *** Quits: spip (~bobo@37.172.31.171) (Ping timeout: 260 seconds)
[17:29:53] *** Joins: Manis (~Manis@77-56-190-146.dclient.hispeed.ch)
[17:30:49] <companion_cube> it can be above too
[17:31:08] <companion_cube> I personally like it below, but you know, choices
[17:31:47] <saltrocklamp[m]> oh, interesting. that wasn't clear from the examples in https://ocaml.org/manual/ocamldoc.html#s%3Aocamldoc-comments, thanks for clarifying
[17:32:48] *** Joins: mro (~mro@port-92-195-202-101.dynamic.as20676.net)
[17:33:16] *** Quits: mro (~mro@port-92-195-202-101.dynamic.as20676.net) (Remote host closed the connection)
[17:33:18] <companion_cube> be sure to look for warning 50
[17:33:25] <companion_cube> it'll tell you if some doc comments are dangling
[17:33:44] <Manis> Hi. I'm trying to parse a file in OCaml that contains different IDs of the form [a-z]{3}[0-9]{6}. To make it easier to apply pattern matching I thought that it would make sense to convert the string into a structure of some form. It would be nice if e.g. abc000001-style IDs could be stored in some AbcID while def123456 IDs would be a DefID (for a given set of 3-letter prefixes). Being able to convert from/to strings would be a plus. Could some
[17:33:45] <Manis> point me to an OCaml structure that would be appropriate for such a problem?
[17:34:03] <saltrocklamp[m]> "warning 50" sounds like something out of a dystopian novel, like "catch 22" :P
[17:38:12] <d_bot> <darrenldl> Manis: just use two maps/trees?
[17:38:54] *** Joins: tomku (~tomku@user/tomku)
[17:39:35] <saltrocklamp[m]> my naive translation of my newbie-level understanding of haskell would be: `type thing_id = | AbcId of string | DefId of string` and a function `parse_id : string -> thing_id`
[17:41:24] <saltrocklamp[m]> or `parse_id : string -> thing_id option`
[17:41:26] <Manis> saltrocklamp: That could work… I guess I was thinking way too far
[17:42:18] <Manis> Basically all I want to do it attach a label to the value so that I can pattern match it.
[17:45:55] <Manis> Another problem where I have probably been thinking way too far. I'm reading in multiple files via a parsing function that returns an assoc list. It there an "easy" way to merge all those association lists into a hashtbl using a custom merging function for key collisions?
[17:46:35] <companion_cube> I'd suggest using `Map` instead of lists
[17:46:38] <Manis> My current approach is List.assoc -> Seq -> Map -> Map.union -> Seq -> Hashtbl.
[17:46:55] <companion_cube> you could have `Map` and only `Map` :)
[17:47:58] <Manis> Isn't a Map slower for lookups?
[17:48:15] <companion_cube> it's faster than assoc lists anyway
[17:50:45] <d_bot> <Et7f3> Thanks so I should focus more un unexpected failure.
[17:51:45] <Manis> Certainly, I'm just using the assoc list to fill the hash table once. After being filled at start up it is static and only lookups will occur on it, that's why I'm asking.
[17:53:10] <companion_cube> oh ok.
[17:53:11] *** Quits: Boarders (sid425905@id-425905.lymington.irccloud.com) (Ping timeout: 264 seconds)
[17:55:26] *** Joins: Boarders (sid425905@id-425905.lymington.irccloud.com)
[17:56:08] <d_bot> <darrenldl> the number of possible 3 letter prefixes is fixed?
[17:56:38] <sim642> vsiles, executable yes, but not writable. The permissions are r-xr-xr--
[17:57:57] *** Joins: mro (~mro@2002:5cc3:ca65:0:5946:ff2e:d97:a3d0)
[17:58:11] *** Quits: mro (~mro@2002:5cc3:ca65:0:5946:ff2e:d97:a3d0) (Remote host closed the connection)
[18:01:59] <Manis> darrenldl: Yes, there's only three valid 3 letter prefixes.
[18:03:17] <companion_cube> NSA, FBI, CIA?
[18:05:02] <Manis> damn, they figured it out!
[18:05:07] * Manis has left the chat
[18:05:25] <d_bot> <darrenldl> hm...i don't know if i'd go with record type instead tbh
[18:09:04] *** Joins: spip (~bobo@37.173.213.27)
[18:09:04] *** Quits: bobo (~bobo@37.173.213.27) (Read error: Connection reset by peer)
[18:14:10] <Manis> I wanted to go with records initially. Maybe, instead of trying to have different types I could just pattern match on the record fields instead.
[18:14:21] *** Joins: mro (~mro@port-92-195-202-101.dynamic.as20676.net)
[18:14:22] <Manis> And put the prefix in one field and the number in the other.
[18:14:43] <d_bot> <darrenldl> ye, just have one field be of variant type
[18:15:02] <d_bot> <darrenldl> my gut feeling is you'd end up having to write accessors if you go against the record type route
[18:15:12] <d_bot> <darrenldl> at which point, eh
[18:15:15] <Manis> of variant type?
[18:15:22] <d_bot> <darrenldl> yep
[18:15:55] *** Joins: pmetzger (~pmetzger@c-73-60-229-197.hsd1.nh.comcast.net)
[18:16:54] <d_bot> <darrenldl> from my experience, type t = ABC of string | DEF of string is less convenient than type prefix = ABC | DEF type t = { prefix: prefix; id : string }
[18:17:19] *** Quits: mro (~mro@port-92-195-202-101.dynamic.as20676.net) (Remote host closed the connection)
[18:17:40] <d_bot> <darrenldl> (when you want to ensure the string is of uniform structure)
[18:17:47] <Manis> My OCaml lingo is not that great. Do you mean: type prefix = CIA | FBI | Nsa ;; type ident = { prefix: prefix, id: int } ?
[18:17:57] <d_bot> <darrenldl> correct
[18:19:06] <Manis> Looks reasonable. I'll go with that. Thanks a lot for helping me out of my confusion!
[18:19:33] *** Quits: hendursa1 (~weechat@user/hendursaga) (Quit: hendursa1)
[18:19:33] *** Quits: pmetzger (~pmetzger@c-73-60-229-197.hsd1.nh.comcast.net) (Client Quit)
[18:20:08] <d_bot> <darrenldl> the only exception i'd make is if the distinction is very significant, say when dealing with cryptographic keys or what have you
[18:20:16] <saltrocklamp[m]> interesting, that "discriminator" design i think is considered an antipattern in other languages
[18:20:45] *** Joins: hendursaga (~weechat@user/hendursaga)
[18:21:05] <d_bot> <darrenldl> incidentally i have no clue what's the idiomatic way : D
[18:21:26] <saltrocklamp[m]> also, it's not as easy to pattern match on individual record fields on those other languages
[18:21:46] <Manis> saltrocklamp: What languages are you talking of?
[18:26:15] *** Joins: rgrinberg (~textual@ip152-195-159-186.ct.co.cr)
[18:33:12] *** Joins: gravicappa (~gravicapp@145.255.9.64)
[18:40:36] <d_bot> <RegularSpatula> Do the different ID types get different “treatments” or whatever, or do you just need to make sure they start with the correct 3 letter code and then “remember” it?
[18:41:00] <d_bot> <RegularSpatula> But not really treat them any differently
[18:45:34] *** Quits: bartholin (~bartholin@158.110.155.0) (Quit: Leaving)
[18:45:50] <Manis> RegularSpatula: They are not treated differently. There will be an API in front of it and I just need to make sure that the "NSA"-API only accepts NSA IDs and then look up the values for that NSA ID in the hashtbl and return it.
[18:48:31] <d_bot> <RegularSpatula> Ahh i see , that makes sense
[18:48:57] <d_bot> <darrenldl> so an array/triple of hashtable is all you need really for look up
[18:49:32] <Manis> I just need to figure out how to get the data in the hashtbl now.
[18:50:03] <Manis> Is it possible to match variants in a record field without using a guard?
[18:50:07] <saltrocklamp[m]> Manis: java and python, for example
[18:51:02] <d_bot> <darrenldl> i thought match x.field with | ... is pretty simple already
[18:51:16] <Manis> saltrocklamp[m]: Ah, yes, that's probably what confused me because I feel more comfortable in those languages :-)
[18:51:52] <Manis> m( sometimes I really wonder what I'm doing here…
[18:52:17] <d_bot> <darrenldl> saltrocklamp: those languages dont have pattern matching to begin with, let alone record field
[18:52:18] <Manis> I was trying `match rec with | { NSA; id } -> ...`
[18:52:34] <Manis> Python 3.10 has now added pattern matching btw.
[18:52:46] <octachron> using a guard is an anti-pattern for matching the content of a field: `{ field = X; _ }` works and is more efficient
[18:54:44] <Manis> octachron: YES! Thanks, that's what I was looking for.
[18:55:20] <Manis> One more question to record field matches: What is the order of fields in a match? The definition order?
[18:55:42] <d_bot> <darrenldl> i dont know about pattern matching in languages with no good enum
[18:55:54] <d_bot> <darrenldl> you can pick any order
[18:56:04] <d_bot> <darrenldl> but _ must be at the end
[18:56:27] <Manis> as long as the "variables"(?) have the same name as the field?
[18:56:56] <octachron> (and `_` is optional and is only here to tell the compiler that you are aware that there are other fields)
[18:57:36] <Manis> I see.
[18:57:41] <d_bot> <darrenldl> { field; _ } pattern matches the field and binds it to name "field"
[18:57:41] <d_bot> <darrenldl>
[18:57:43] <d_bot> <darrenldl> { field = x; _ } binds it to name x
[18:59:03] <Manis> That's confusing. comparison is = and assignment, too?
[18:59:09] *** Joins: Tuplanolla (~Tuplanoll@91-159-69-50.elisa-laajakaista.fi)
[18:59:30] <companion_cube> there is no real assignment
[18:59:33] <companion_cube> there's `let x = y in …`
[19:00:28] <Manis> That depends on your definition of assignment, doesn't it?
[19:00:48] <Manis> You assign the value of said field to a new name.
[19:01:08] <Manis> I still call them variables, although they are static.
[19:01:16] <companion_cube> it's a binding, but yeah
[19:01:17] <Manis> or constant, rather.
[19:01:19] <Corbin> It's a binding, for sure.
[19:01:24] <companion_cube> you can do `let (x,y) = … ` too
[19:01:35] <companion_cube> so it's more of a irrefutable pattern matching
[19:01:40] <Manis> companion_cube: Is there a semantic difference between binding and assigning?
[19:02:09] <companion_cube> idk, assigning for me is more like `:=`
[19:02:15] <companion_cube> put a value in a mutable box :p
[19:02:38] <Corbin> An assignment to a name occurs after the name is created. A binding creates the name and attaches its value in one single motion.
[19:03:00] <Manis> ^ this sounds legit.
[19:03:12] <Manis> I just never thought about it.
[19:03:22] <Corbin> There's an underlying assumption that we are usually making: Assignable names are a specific sort of created object.
[19:04:40] <Corbin> Whereas a binding is just a feature of the syntax, subject to at least a gentle form of referential transparency. `let` is a great example of this; `let x = y in z` is just like `(fun x -> z)(y)`, with the same sort of binding. (Modulo companion_cube's point about irrefutable patterns!)
[19:06:33] <Manis> That's a very good explanation for why let ... and ... cannot reference each other.
[19:07:16] <Manis> So it's very unlike Haskell's let which (AFAIK) creates an alias for some "code".
[19:07:44] <companion_cube> haskell's let is recursive by default, and is in a lazy language, so yeah :D
[19:07:53] <Corbin> Haskell's let is a "letrec" -- what companion_cube said.
[19:07:57] <companion_cube> in OCaml, `let x = y in z`  means y is a value already
[19:08:08] <companion_cube> in haskell, y woudl be  a thunk
[19:17:00] <Manis> Can't a function inside a submodule call another function from that submodule?
[19:17:33] <Manis> Or rather, can a function in a submodule reference the submodule it's in?
[19:18:33] <companion_cube> no
[19:19:20] <octachron> A function can always call any other functions which is in the scope.
[19:19:58] <octachron> But you cannot sneak in recursion in a function through a submodule
[19:22:29] <Manis> How would calling another function defined in the same submodule make some other function recursive?
[19:23:45] <companion_cube> module M = struct  let f x = M.f x end
[19:23:47] <companion_cube> no? :p
[19:26:49] *** Quits: rond_ (~rond_@2a02:a31a:a23c:f480:2fd7:e087:5546:a438) (Quit: Client closed)
[19:28:22] <Manis> I was thinking of `module M = struct let f x = M.g x let g x = 42 end`.
[19:28:47] <d_bot> <somebody> re: assignment vs rebinding, imo it's more obvious when you think about reassignment vs rebinding (since, well, that's where the differences lie). so reassignment (basically) updates a previous reference, rebinding always creates a new one
[19:29:29] <d_bot> <darrenldl> Manis: there is also the gotcha of assignment when the name is visible across multiple smaller scopes
[19:29:59] <d_bot> <somebody> aka shadowing
[19:30:20] <d_bot> <somebody> i mean... assignment in general comes with a lot of gotchas imo
[19:30:26] <Manis> rebinding shadows the old binding but reassigning doesn't.
[19:31:12] <d_bot> <somebody> e.g. assigning to the same variable in an async loop is a relatively common source of trouble in some languages
[19:31:17] <d_bot> <darrenldl> reassigning also means you need to restore state more often than you might want
[19:31:54] *** Quits: Haudegen (~quassel@91.114.49.10) (Quit: Bin weg.)
[19:45:42] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[19:47:23] *** Joins: hendursaga (~weechat@user/hendursaga)
[20:12:51] *** Quits: Tuplanolla (~Tuplanoll@91-159-69-50.elisa-laajakaista.fi) (Quit: Leaving.)
[20:35:57] *** Joins: zebrag (~chris@user/zebrag)
[20:36:43] *** Joins: Haudegen (~quassel@178.115.237.87.static.drei.at)
[20:41:59] *** Joins: wonko (~wjc@62.115.229.50)
[20:54:59] *** Quits: rgrinberg (~textual@ip152-195-159-186.ct.co.cr) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[20:56:13] *** Joins: rgrinberg (~textual@201.182.226.118)
[21:16:26] *** Quits: kakadu (~kakadu@195.19.236.234) (Quit: Konversation terminated!)
[21:17:31] *** Joins: kurfen (~kurfen@37.120.204.67)
[21:36:02] *** Quits: Skyfire (~pyon@user/pyon) (Quit: WeeChat 3.3)
[21:48:22] *** Quits: chrisz (o4zf2oybb5@55d4cb2f.access.ecotel.net) (Quit: leaving)
[21:51:50] *** Quits: olle (~olle@i5E8666F6.versanet.de) (Ping timeout: 260 seconds)
[22:00:19] *** Joins: bobo (~bobo@37.171.12.253)
[22:00:30] *** Quits: spip (~bobo@37.173.213.27) (Ping timeout: 260 seconds)
[22:03:57] *** Quits: rgrinberg (~textual@201.182.226.118) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[22:06:37] *** Joins: rgrinberg (~textual@201.182.226.118)
[22:30:29] *** Quits: Manis (~Manis@77-56-190-146.dclient.hispeed.ch) (Quit: Manis)
[22:44:50] *** Quits: gravicappa (~gravicapp@145.255.9.64) (Ping timeout: 260 seconds)
[23:05:55] *** Quits: cedric (~cedric@2a01:cb11:821:7c00:1b9d:4c8d:f219:3247) (Quit: Konversation terminated!)
[23:20:56] *** Joins: gravicappa (~gravicapp@145.255.9.64)
[23:26:08] *** Quits: rgrinberg (~textual@201.182.226.118) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[23:31:22] *** Joins: herrschreinerei (~herrschre@88.171.43.194)
[23:32:22] <herrschreinerei> hello guys. I stumbled upon the >|= operator and I really don't know how to look it up, I guess it's in Batteries but I really have no clue. Do you have any pointer?
[23:32:34] <companion_cube> it's in the stdlib too
[23:32:40] <companion_cube> look for it in the Stdlib module
[23:32:43] <herrschreinerei> ow
[23:32:44] <herrschreinerei> ok
[23:32:45] <companion_cube> it's called the pipe operator
[23:32:45] <herrschreinerei> thx
[23:32:58] <herrschreinerei> rly
[23:33:02] <herrschreinerei> it's not |>?
[23:33:59] <companion_cube> oh fuck, I misread
[23:34:04] <companion_cube> ok, >|= is not standard
[23:34:11] <companion_cube> it's an infix "map" operator by convention
[23:34:26] <companion_cube> for many different things (option, list, monads…)
[23:34:30] <herrschreinerei> oooh that make sense in the context
[23:34:39] <herrschreinerei> ok thx
[23:34:39] <companion_cube> >>= is bind, >|= is map
[23:34:41] <companion_cube> generally
[23:36:18] *** Quits: kurfen (~kurfen@37.120.204.67) (Quit: WeeChat 2.3)
[23:36:59] <herrschreinerei> yeah that's what I missed
[23:37:01] <herrschreinerei> let (>|=) = Lwt.(>|=)
[23:37:12] <herrschreinerei> all right sorry for the noise, simple stuff :D
[23:38:35] *** Quits: gravicappa (~gravicapp@145.255.9.64) (Ping timeout: 260 seconds)
[23:43:47] *** ski_ is now known as ski
[23:53:58] *** Quits: wonko (~wjc@62.115.229.50) (Ping timeout: 252 seconds)
