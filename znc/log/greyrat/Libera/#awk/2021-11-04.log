[01:15:24] *** Parts: ash_worksi (~ash_m@user/ash-m/x-3292451) ()
[01:27:08] *** Quits: jetchisel (jetchisel@user/jetchisel) (Ping timeout: 268 seconds)
[01:37:51] *** Quits: kensanata (~user@user/kensanata) (Remote host closed the connection)
[01:39:43] *** Quits: YaoNai (~YaoNai@user/yaonai) (Quit: leaving)
[02:13:15] *** Joins: jetchisel (jetchisel@user/jetchisel)
[02:14:18] *** Quits: elastic_dog (~elastic_d@2a01:118f:822:9c00:f583:aa51:9ad4:d4fb) (Ping timeout: 268 seconds)
[02:20:11] *** Joins: elastic_dog (~elastic_d@2a01:118f:822:9c00:f583:aa51:9ad4:d4fb)
[02:31:34] *** Quits: asdflkj_sh (asdflkj@bsdforall.org) (Ping timeout: 260 seconds)
[02:55:20] *** Joins: asdflkj_sh (asdflkj@bsdforall.org)
[03:16:23] *** Joins: yuesbeez (uid458354@id-458354.tinside.irccloud.com)
[03:42:00] *** Joins: loganlee (~Thunderbi@user/loganlee)
[04:01:58] *** Joins: Torr (~Torr@user/torr)
[04:28:49] *** Joins: roarde (~roarde@user/roarde)
[04:50:01] *** Quits: earnestly (~earnest@user/earnestly) (Ping timeout: 268 seconds)
[05:18:26] *** Quits: seninha (~seninha@user/seninha) (Quit: Leaving)
[05:24:36] *** Joins: gaussianblue (~gaussianb@78-61-246-87.static.zebra.lt)
[05:29:05] *** Joins: BSaboia (~bsaboia@177.190.210.217)
[05:30:28] *** Quits: vlm (~vlm@user/vlm) (Quit: "")
[05:34:45] *** Joins: X-Scale` (~ARM@165.201.137.78.rev.vodafone.pt)
[05:36:16] *** Quits: X-Scale (~ARM@46.50.0.1) (Ping timeout: 268 seconds)
[05:37:24] *** X-Scale` is now known as X-Scale
[06:02:36] *** Quits: BSaboia (~bsaboia@177.190.210.217) (Quit: This computer has gone to sleep)
[06:03:46] *** Quits: yuesbeez (uid458354@id-458354.tinside.irccloud.com) (Quit: Connection closed for inactivity)
[06:07:06] *** Quits: Meli (~meli@user/meli) (Ping timeout: 268 seconds)
[06:22:41] *** Joins: Meli (~meli@user/meli)
[06:28:19] *** Joins: seninha (~seninha@user/seninha)
[06:49:24] *** Quits: seninha (~seninha@user/seninha) (Remote host closed the connection)
[06:52:43] *** Quits: euandreh (~euandreh@2804:14c:33:9fe5:3a97:eaba:c01a:d700) (Ping timeout: 268 seconds)
[06:53:36] *** Joins: euandreh (~euandreh@2804:14c:33:9fe5:25ae:baa7:4680:70ca)
[07:51:32] *** Joins: tirnanog (~tirnanog@user/tirnanog)
[08:07:32] *** Joins: vlm (~vlm@user/vlm)
[09:57:06] *** Quits: jetchisel (jetchisel@user/jetchisel) (Ping timeout: 268 seconds)
[09:58:58] *** Joins: jetchisel (jetchisel@user/jetchisel)
[10:57:53] *** Quits: roarde (~roarde@user/roarde) (Quit: Leaving)
[11:13:44] *** Joins: lgc (~lgc@user/lgc)
[11:19:52] *** Joins: aramtsamtsam (~Thunderbi@2001:861:388a:5600:1710:c3dc:c776:df35)
[11:21:24] *** Quits: aramtsamtsam (~Thunderbi@2001:861:388a:5600:1710:c3dc:c776:df35) (Client Quit)
[11:23:50] *** Joins: extern (~archer@80.246.138.162)
[11:35:59] *** Quits: crabbedhaloablut (~crabbedha@user/crabbedhaloablut) (Remote host closed the connection)
[11:36:47] *** Joins: crabbedhaloablut (~crabbedha@user/crabbedhaloablut)
[11:41:59] *** Joins: earnestly (~earnest@user/earnestly)
[11:45:01] *** Quits: extern (~archer@80.246.138.162) (Quit: nvm gotta go to work cya)
[12:41:19] *** Joins: aramtsamtsam (~Thunderbi@2001:861:388a:5600:1710:c3dc:c776:df35)
[12:54:13] *** Quits: gaussianblue (~gaussianb@78-61-246-87.static.zebra.lt) (Quit: leaving)
[13:02:25] *** Joins: ravan (~ravan@user/ravan)
[13:02:43] *** Quits: aramtsamtsam (~Thunderbi@2001:861:388a:5600:1710:c3dc:c776:df35) (Ping timeout: 268 seconds)
[13:02:50] *** Joins: aramtsamtsam1 (~Thunderbi@94.239.102.102)
[13:07:40] *** Quits: aramtsamtsam1 (~Thunderbi@94.239.102.102) (Ping timeout: 268 seconds)
[13:08:13] *** Joins: ravan_ (~ravan@110.93.228.3)
[13:11:11] *** Quits: ravan (~ravan@user/ravan) (Ping timeout: 264 seconds)
[13:11:53] *** Quits: ravan_ (~ravan@110.93.228.3) (Client Quit)
[13:13:20] *** Quits: loganlee (~Thunderbi@user/loganlee) (Quit: loganlee)
[13:30:45] *** Joins: aramtsamtsam (~Thunderbi@94.239.102.102)
[14:18:40] *** Joins: Everything (~Everythin@37.115.210.35)
[14:36:27] *** Quits: jetchisel (jetchisel@user/jetchisel) (Ping timeout: 256 seconds)
[14:37:41] *** Joins: jetchisel (jetchisel@user/jetchisel)
[14:43:10] *** Quits: aramtsamtsam (~Thunderbi@94.239.102.102) (Quit: aramtsamtsam)
[14:49:46] *** Joins: seninha (~seninha@user/seninha)
[16:48:35] *** Quits: tirnanog (~tirnanog@user/tirnanog) (Quit: = "")
[16:49:59] *** Joins: mikeliuk (~mikeliuk@213.205.198.227)
[17:23:26] *** Quits: X-Scale (~ARM@165.201.137.78.rev.vodafone.pt) (Ping timeout: 260 seconds)
[17:23:48] *** Joins: X-Scale` (~ARM@83.223.227.196)
[17:25:20] *** Joins: Thanatermesis (~Thanaterm@191.92.148.122)
[17:26:04] *** X-Scale` is now known as X-Scale
[17:42:57] *** Quits: Everything (~Everythin@37.115.210.35) (Quit: leaving)
[18:02:09] *** Joins: YaoNai (~YaoNai@user/yaonai)
[18:12:50] *** Joins: justsomeguy (~justsomeg@user/justsomeguy)
[18:24:19] <justsomeguy> I have a huge file with tons of assignments on it, similar to the format you'd see in the /etc/os-release file on linux (which is the sameple input I link to here). How can I align the lines in https://termbin.com/p7rh on the equal sign, without inserting spaces around the "=", so that it looks like this https://termbin.com/molm ?
[18:27:53] <justsomeguy> Roughly speaking...I was thinking that first I'd try to find the maximum length of the identifier before the equals sign, and then prepend n spaces, where n is the difference between the identifier length and the max identifier length.
[18:28:37] <justsomeguy> ...for every line other than the one with the largest identifier.
[18:36:22] <yeti> is that file really huge compared to available RAM?
[18:37:17] <yeti> it could be read into an array while calculating the longest identifier and then be spit out from the recorded lines in the pretty printed way
[18:37:47] <yeti> if it doesnt fit this strategy, 2 passes will be needed
[18:37:55] <e36freak> awk -F= '{a[NR]=$1; b[NR]=$2; len=length($1); if (len>max) max=len} END {for (i=1; i<=NR; i++) printf("%*s=%s\n", max, a[i], b[i])}'
[18:38:02] <e36freak> would be that first strat
[18:38:11] <yeti> ;-)
[18:38:37] *** Joins: tirnanog (~tirnanog@user/tirnanog)
[18:39:32] <emanuele6> should be b[NR]=substr($0,length($1)+1) 
[18:39:40] <e36freak> yeah, i was just thinking that
[18:39:57] <e36freak> or use sub()
[18:40:01] <justsomeguy> yeti: It's a 10GiB file, but I have 63GiB of ram available and tons of disk space. I don't mind running it in the background for a long time, either. Also, the lines don't have to stay in order.
[18:40:13] <emanuele6> lol
[18:40:36] * justsomeguy is digesting e36freaks comment -- it may take a minute
[18:43:19] <yeti> with 64G RAM the once read file probably is in the FS cache, so a 2nd read wouldnt matter much
[18:43:41] <justsomeguy> Cool.
[18:44:59] <emanuele6> awk -F= 'NR==FNR && max < length($1) { max=length($1) } NR != FNR { printf("%*s=%s\n", max, $1, substr($0,index($0,"=")+1)) }' /etc/os-release /etc/os-release
[18:45:07] <emanuele6> this is how you can do it in two passes
[18:45:16] <emanuele6> notice that /etc/os-release is passed twice
[18:47:49] <emanuele6> b[NR]=substr($0,length($1)+1)  was incorrect (it includes "=") but it should be either  b[NR]=substr($0,length($1)+2)  or  substr($0,index($0,"=")+1) 
[18:48:12] <emanuele6> or just   substr($0,index($0,"="))   with  =  removed from the format
[18:49:57] <emanuele6> s/but //
[18:53:13] <justsomeguy> Cool, both commands work on my sample input. Now to try it on the big file.
[18:53:51] * justsomeguy learned about the length() and substr() functions just now, too, which is cool.
[18:56:30] <emanuele6> actually it can also just be written as
[18:56:35] <emanuele6> awk -F= 'NR==FNR && max < length($1) { max=length($1) } NR != FNR { printf "%*s%s\n", max-length($1), "", $0 }' /etc/os-release /etc/os-release
[18:56:57] <emanuele6> without the need to substring
[19:04:10] <yeti> # awk 'NR==1' /etc/os-release   # hey bot... you have os-release?
[19:04:11] <shbot> yeti: awk: can't open file /etc/os-release
[19:04:12] <shbot> yeti:  source line number 1
[19:04:16] <yeti> :-/
[19:05:13] <nmz> maybe I'm coming in late, but, NR==FNR is like testing for the first record of the first file right? so max will always be 0 no?
[19:05:48] <yeti> FNR counts from 1 for each file
[19:05:56] <yeti> NR counts all lines seen
[19:06:10] <nmz> so I'm right then
[19:06:29] <emanuele6> i don't understand what you are thinking
[19:06:41] <nmz> because max is undefined, that can just be length($1)
[19:06:56] <emanuele6> 0 < length($1)
[19:07:15] <nmz> don't even need the NR==FNR, put getline in a BEGIN{}
[19:07:15] <yeti> empty vars in numerical context are 0
[19:07:37] <nmz> remove the NR!=FNR
[19:07:48] <nmz> no conditionals
[19:07:53] <emanuele6> what?
[19:08:14] <emanuele6> that program is reading a file two times
[19:08:21] <emanuele6> awk -F= ... /etc/os-release /etc/os-release
[19:08:48] <emanuele6> the first time, it runs the NR==FNR code; the second time, it runs the NR!=FNR code
[19:09:57] <emanuele6> not sure what you mean with add getline in BEGIN and remove conditionals
[19:10:14] <nmz> awk -F= 'BEGIN {getline; max=length($1) } { printf "%*s%s\n", max-length($1), "", $0 }' /etc/os-release /etc/os-release
[19:10:19] <nmz> should be equivalent
[19:10:25] <nmz> but I might be missing something, I dunno
[19:10:44] <nmz> oh oh
[19:10:44] <emanuele6>  that's not even close to equivalent
[19:10:47] <nmz> I get it
[19:10:48] <nmz> I woke up
[19:11:05] <yeti> NR==FNR is thue for the whole 1st file
[19:11:09] <yeti> rRue
[19:11:16] <yeti> &%ยง)"!&ยง!("perl!perl!perl!
[19:11:17] <emanuele6> you could write it as:  awk -F= '{ if (NR != FNR) { printf "%*s%s\n", max-length($1), "", $0 } else if (max < length($1)) { max=length($1) } }' /etc/os-release /etc/os-release
[19:11:18] <nmz> you're still better off putting the first file in a begin
[19:11:23] <emanuele6> to avoid checking twice
[19:11:41] <emanuele6> but it doesn't matter that much imho
[19:12:02] <emanuele6> NR==FNR is a common awk pattern to check if you are reading the first file
[19:13:28] <emanuele6> # awk '{ printf "FILENAME=%s;NR=%s;FNR=%s", FILENAME, NR, FNR }' <(printf 'a\nb\n') <(printf 'x\n')
[19:13:30] <shbot> emanuele6: FILENAME=/dev/fd/63;NR=1;FNR=1FILENAME=/dev/fd/63;NR=2;FNR=2FILENAME=/dev/fd/62;NR=3;FNR=1
[19:13:32] <emanuele6> err
[19:13:37] <emanuele6> # awk '{ printf "FILENAME=%s;NR=%s;FNR=%s\n", FILENAME, NR, FNR }' <(printf 'a\nb\n') <(printf 'x\n')
[19:13:38] <shbot> emanuele6: FILENAME=/dev/fd/63;NR=1;FNR=1
[19:13:38] <shbot> emanuele6: FILENAME=/dev/fd/63;NR=2;FNR=2
[19:13:38] <shbot> emanuele6: FILENAME=/dev/fd/62;NR=3;FNR=1
[19:13:56] <emanuele6> FNR==NR will only be true for the first file
[19:14:33] <emanuele6> NR is a counter of all the records read so far and FNR is a counter of all the records read so far for the current file
[19:19:39] <emanuele6> <nmz > you're still better off putting the first file in a begin
[19:19:49] <emanuele6> i missed this message, i don't get it :/
[19:21:46] <emanuele6> # printf '%s=text\n' a aaa aa > fff; awk -F= 'NR==FNR && max < length($1) { max=length($1) } NR != FNR { printf "%*s%s\n", max-length($1), "", $0 }' fff fff
[19:21:48] <shbot> emanuele6:   a=text
[19:21:48] <shbot> emanuele6: aaa=text
[19:21:49] <shbot> emanuele6:  aa=text
[19:21:55] <emanuele6> nmz: this is what the script does
[19:23:20] <emanuele6> it aligns the first "=" of each line of the input file
[19:23:36] <emanuele6> # printf '%s=text\n' a aaa aa > fff; awk '1==1' fff
[19:23:38] <shbot> emanuele6: a=text
[19:23:38] <shbot> emanuele6: aaa=text
[19:23:38] <shbot> emanuele6: aa=text
[19:32:29] *** Quits: justsomeguy (~justsomeg@user/justsomeguy) (Quit: WeeChat 3.2)
[19:47:46] <e36freak> 1
[19:47:53] <e36freak> 1==1 is a little verbose for no reason, no?
[19:48:49] <emanuele6> # printf 'a\n' > file; oawk '1' file # e36freak
[19:48:51] <shbot> emanuele6: oawk: syntax error near line 1
[19:48:51] <shbot> emanuele6: oawk: bailing out near line 1
[19:48:55] <emanuele6> # printf 'a\n' > file; oawk '1==1' file # e36freak
[19:48:56] <shbot> emanuele6: a
[19:49:51] <emanuele6> we discovered that oawk doesn't like '1' some days ago
[19:50:09] <e36freak> i see
[19:50:21] <e36freak> that's dumb
[19:51:33] <emanuele6> oh, actually i should not care about that
[19:51:36] <emanuele6> # echo hi | oawk '!a[$0]++'
[19:51:38] <shbot> emanuele6: oawk: syntax error near line 1
[19:51:38] <shbot> emanuele6: oawk: bailing out near line 1
[19:51:57] <emanuele6> !a[$0]++ doesn't work in oawk either
[19:53:39] <emanuele6> i thought maybe 1 being equivalent to truth in a conditional was not fully guaranteed by the spec
[19:54:06] <emanuele6> but clearly the issue is just that oawk is a subset of modern awk
[19:54:22] <emanuele6> i should have just used '1'
[20:18:47] <nmz> # printf '%s=text\n' a aaa aa > fff; awk '2' fff
[20:18:49] <shbot> nmz: a=text
[20:18:49] <shbot> nmz: aaa=text
[20:18:49] <shbot> nmz: aa=text
[20:18:53] <nmz> so its just 1
[20:18:57] <nmz> lol
[20:21:17] <emanuele6> nmz: awk is not oawk
[20:21:21] <emanuele6> awk is nawk
[20:21:30] <nmz> # printf '%s=text\n' a aaa aa > fff; oawk '2' fff
[20:21:32] <shbot> nmz: oawk: syntax error near line 1
[20:21:32] <shbot> nmz: oawk: bailing out near line 1
[20:22:02] <nmz> so it doesn't like single comparisons?
[20:22:15] <nmz> # printf '%s=text\n' a aaa aa > fff; oawk 'BEGIN{x=1} x' fff
[20:22:17] <shbot> nmz: oawk: syntax error near line 1
[20:22:17] <shbot> nmz: oawk: bailing out near line 1
[20:22:32] <nmz> # oawk --version
[20:22:40] <shbot> nmz: no output within the time limit
[20:22:45] <emanuele6> i think it expects ==, <=, >=, !=, >, <, // or ~ 
[20:22:51] <nmz> I get your code now, I've never had to use %*s so was a bit lost on what that meant
[20:23:17] <nmz> patterns should be an expression
[20:23:38] <nmz> ?
[20:23:40] <emanuele6>   printf "%*s", 20, str   is equivalent to   printf "%20s", str
[20:24:00] <emanuele6> nmz: i don't know exactly what oawk expects
[20:24:33] <emanuele6> but it only like comparison operators and patterns
[20:24:55] <emanuele6> # printf '%s\n' aba ccc ada | oawk '/a/'
[20:24:56] <shbot> emanuele6: aba
[20:24:57] <shbot> emanuele6: ada
[20:25:15] <emanuele6> # printf '%s\n' aba ccc ada | oawk '$0=="aba"'
[20:25:16] <shbot> emanuele6: aba
[20:25:24] <emanuele6> # printf '%s\n' aba ccc ada | oawk '$0'
[20:25:26] <shbot> emanuele6: oawk: syntax error near line 1
[20:25:26] <shbot> emanuele6: oawk: bailing out near line 1
[20:25:54] <emanuele6> yeah, it only likes binary comparison operators and // in conditionals
[20:26:39] <nmz> I guess that's why the manual says it expects a pattern, while nawks expect an expression
[20:26:44] <emanuele6> they can be joined with && and || and negated with !, but the atoms must contain a comparison operator or //
[20:26:57] <emanuele6> # man oawk
[20:26:59] <shbot> emanuele6: man oawk: http://ix.io/aPd
[20:27:07] <emanuele6> oh, yeah
[20:27:17] <emanuele6> i never read oawk's man page
[20:27:41] <nmz> well, they all say "pattern" but in reality its expression
[20:27:44] <emanuele6> nawk's man page says the same
[20:27:47] <emanuele6> what do you mean?
[20:28:00] <emanuele6> # man nawk
[20:28:01] <shbot> emanuele6: man nawk: http://ix.io/aO1
[20:28:01] <nmz> I always thought that was weird, so that clear that up
[20:28:19] <emanuele6> nawk's man and oawk's man both say pattern
[20:29:11] <emanuele6> > !a[$0]++ doesn't work in oawk either
[20:29:21] <emanuele6> oh, that doesn't work for another reason
[20:29:26] <emanuele6> oawk doesn't have arrays
[20:29:54] <emanuele6> # : does !0 work then?; oawk '!0' <<< 'a' 
[20:29:56] <shbot> emanuele6: oawk: syntax error near line 1
[20:29:56] <shbot> emanuele6: oawk: bailing out near line 1
[20:30:00] <nmz> # printf '%s\n' aba ccc ada | oawk 'function a(){return 1} a()'
[20:30:02] <emanuele6> no, !0 doesn't work
[20:30:09] <shbot> nmz: oawk: syntax error near line 1
[20:30:09] <shbot> nmz: oawk: bailing out near line 1
[20:30:09] <shbot> nmz: etc... ( http://ix.io/3E0T )
[20:31:03] <nmz> idk what that oawk is, but my oawk works
[20:31:23] <emanuele6> oawk is original awk
[20:31:32] <emanuele6> # man oawk
[20:31:33] <shbot> emanuele6: man oawk: http://ix.io/aPd
[20:32:07] <emanuele6> anyway, man oawk says that    Patterns  are  arbitrary Boolean combinations (!, ||, &&, and parentheses)  of  regular  expressions  and  relational  expressions.
[20:32:27] <emanuele6> and that   A relational expression is one of the following:   expression matchop regular-expression    expression relop expression
[20:32:34] <emanuele6> so that is why it doesn't work
[20:33:44] <nmz> yeah but you just tried !0
[20:34:12] <emanuele6> Boolean combinations    of    regular  expressions  and  relational  expressions.
[20:34:13] <yeti> # oawk '!(0)' <<<moo
[20:34:15] <shbot> yeti: oawk: syntax error near line 1
[20:34:16] <shbot> yeti: oawk: bailing out near line 1
[20:34:23] <yeti> ok... no loophole
[20:34:23] <emanuele6> 0 is not a relational expression
[20:34:28] <emanuele6> it's just an expression
[20:34:48] <yeti> seems the description really matches the code
[20:34:52] <emanuele6> to be a relational expression, it needs to be   expression relop expression
[20:34:53] <nmz> but it is boolean combination
[20:35:03] <emanuele6> nmz: 0 is an expression
[20:35:25] <emanuele6> a pattern is a boolean combination of just regular  expressions  and  relational  expressions.
[20:36:05] <emanuele6> 0 is neither  expression matchop regular-expression   nor   expression relop expression   so it  !0  does not qualify as a pattern
[20:36:19] <emanuele6> !(0==1) would qualify as a pattern
[20:36:34] <emanuele6> or !/pat/
[21:52:42] *** Quits: mikeliuk (~mikeliuk@213.205.198.227) (Quit: Connection closed)
[22:38:25] *** Quits: YaoNai (~YaoNai@user/yaonai) (Quit: leaving)
[22:50:45] *** Joins: roarde (~roarde@user/roarde)
[23:05:52] *** Quits: lgc (~lgc@user/lgc) (Quit: WeeChat 3.2-dev)
[23:09:47] *** Joins: aramtsamtsam (~Thunderbi@2001:861:388a:5600:1710:c3dc:c776:df35)
[23:09:48] *** Quits: aramtsamtsam (~Thunderbi@2001:861:388a:5600:1710:c3dc:c776:df35) (Client Quit)
[23:21:23] *** Quits: nmz (~nmz@24.137.228.140) (Ping timeout: 265 seconds)
[23:23:24] *** Joins: nmz (~nmz@24.137.228.140)
[23:30:30] *** Quits: tirnanog (~tirnanog@user/tirnanog) (Ping timeout: 268 seconds)
