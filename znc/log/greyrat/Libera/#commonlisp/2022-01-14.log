[00:01:29] <rotateq> jeosol: okay much to work through for me in this book too, not to mention AMOP
[00:02:19] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[00:02:29] *** Joins: johnjaye (~pi@154.6.152.74)
[00:04:04] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[00:05:21] *** Quits: attila_lendvai (~alendvai@2a02:120b:2c72:1dc0:2e07:56d9:2bb8:283d) (Quit: Leaving)
[00:06:18] *** Joins: attila_lendvai (~alendvai@2a02:120b:2c72:1dc0:2e07:56d9:2bb8:283d)
[00:07:39] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[00:08:14] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[00:08:47] *** Quits: aartaka (aartaka@gateway/vpn/protonvpn/aartaka) (Ping timeout: 256 seconds)
[00:09:44] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[00:09:57] *** Quits: thomp (~thomp@c-98-239-97-121.hsd1.ca.comcast.net) (Ping timeout: 240 seconds)
[00:10:29] *** Quits: marcoxa (~user@77-57-64-215.dclient.hispeed.ch) (Quit: Time for bed...)
[00:11:19] *** Joins: Oladon (~olad@98.43.81.226)
[00:12:04] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[00:12:29] *** Odin-FOO is now known as Odin-
[00:13:40] <mfiano> Does a SIMPLE-VECTOR require a fixed size?
[00:13:59] <mfiano> How would I specify the most specific type specifier for a vector of non-zero size?
[00:14:18] <mfiano> arbitrary element types
[00:14:54] <White_Flame> simple-vectoris always of type T
[00:15:08] <White_Flame> and no it doesn't require a fixed size
[00:15:11] <mfiano> RIght and that's what I want
[00:15:22] <mfiano> I want to specify a simple-vector of at least 1 in length
[00:15:27] <mfiano> as a type specifier
[00:15:43] <Bike> "at least 1 in length" is not something the type system can do (short of SATISFIES)
[00:15:49] <mfiano> I see, ok
[00:16:34] <White_Flame> yeah, you can declare a specific size or "any size" in the type
[00:16:37] <mfiano> So just 'simple-vector and a runtime check is fine then
[00:17:11] <Bike> if you want arbitrary element type, you'll have to use (simple-array * (*)) rather than simple-vector (which is (simple-array t (*)))
[00:17:37] <mfiano> What is the difference here?
[00:17:57] <phoe> specialization
[00:18:00] <White_Flame> T is already the arbitrary element type?
[00:18:02] <mfiano> Isn't T the top type?
[00:18:08] <phoe> it is
[00:18:15] <phoe> btu T and * are distinct in case of array types
[00:18:19] <Bike> (simple-array bit) is not a (simple-array t).
[00:18:23] <phoe> SIMPLE-ARRAY T means that it is specialized to hold any element
[00:18:38] <phoe> SIMPLE-ARRAY (UNSIGNED-BYTE 8) means that it's specialized to hold ub8s
[00:18:41] <phoe> these two types are distinct
[00:18:49] <White_Flame> hmm, true
[00:18:50] <phoe> check it yourself with your favorite implementation of SUBTYPEP!
[00:18:53] <mfiano> and SIMPLE-ARRAY *
[00:18:56] <phoe> then compare it with SIMPLE-ARRAY *
[00:19:05] <phoe> which is *any* SIMPLE-ARRAY, no matter the specialization
[00:19:46] <pjb> Bike: obviously, the bug is in aref: (let ((a (foo))) (map nil #'print a) (elt a 0)) will work for any sequence returned by FOO.
[00:19:52] <mfiano> In this case I'm storing pointers
[00:20:03] <phoe> pointers, hmmm
[00:20:11] <phoe> in case of SBCL they are boxed objects, right?
[00:20:17] <mfiano> struct types. These aren't immediates so I can't really store any simple-array that is not of type T. SBCL says it is a simple-vector
[00:20:29] <phoe> I assume you could store ub64s and convert from/to pointers for storage
[00:20:38] <phoe> but that's a hack of sorts
[00:20:41] <mfiano> By pointers I mean Common Lisp references
[00:20:47] <mfiano> I am storing struct instances
[00:21:08] <phoe> oooooh
[00:21:18] <phoe> then use a SIMPLE-ARRAY T all right
[00:21:41] <mfiano> TYPE-OF said simple-vector, so i was using that, but fair enough
[00:21:46] <Bike> you can also specify (simple-array your-struct-type).
[00:21:58] <phoe> that'll decay to T though, won't it?
[00:22:02] <Bike> probably
[00:22:04] <mfiano> Yes it will
[00:22:11] <mfiano> Any non-immediates will
[00:22:13] <Bike> but if it's full of structs, you may as well say that
[00:22:36] <phoe> Bike: yes
[00:22:49] <mfiano> I don'[t have a common ancestor type :)
[00:22:59] <mfiano> I could say struct-object, but...
[00:23:02] <phoe> ;; you do, it's called T
[00:23:10] * phoe ducks
[00:23:17] <Bike> no, arrays with non-immediates can exist. unboxed doubles for one.
[00:24:02] <mfiano> Ah true. I guess anything non-numbers/characters, on SBCL at least.
[00:24:42] <phoe> but arrays of structs can't because of identity issues - I remember discussing that problem some time ago
[00:24:46] <Bike> it is unlikely that anything but numbers or characters will have specializations, due to how eq is defined. yes.
[00:25:21] <mfiano> fixnums at that.
[00:25:45] <mfiano> for the integral subset
[00:26:08] <Bike> i think sbcl has a specialization for (unsigned-byte 64).
[00:26:09] <mfiano> oh hmm. ui guess SBCL can handle ub64's
[00:26:13] <mfiano> i*
[00:26:20] *** Joins: miique (~miiquemat@2001:470:69fc:105::1:6901)
[00:26:21] <Bike> kind of the point of specialization is that tags aren't necessary.
[00:27:42] <mfiano> Yes I have cheated and boxed a ub64 return value inside a 0-d array when the caller couldn't inline the function...
[00:30:53] <mfiano> So how do the type specifiers SIMPLE-VECTOR and (SIMPLE-ARRAY T (*)) differ exactly?
[00:31:00] <Bike> they don't.
[00:31:08] <mfiano> Ok, as I expected. Thanks.
[00:31:19] *** Joins: karlosz (~karlosz@47.151.136.69)
[00:31:27] <rotateq> i thought simple-vectors mustn't have fill-pointer and can't be adjustable
[00:31:37] <mfiano> Simple arrays must not either
[00:31:54] <rotateq> okay thanks, i'll fresh up :)
[00:31:55] <mfiano> Either feature automatically devolves to a VECTOR
[00:35:03] *** Quits: Oladon (~olad@98.43.81.226) (Read error: Connection reset by peer)
[00:37:00] *** Joins: Oladon (~olad@98.43.81.226)
[00:37:35] <Bike> it's a little bit more complicated. the standard says that a non-adjustable non-displaced array with no fill pointer is a simple array, but it doesn't say that a displaced array or etc is _not_ a simple array. so like, an implementation could say all arrays are simple.
[00:37:41] <Bike> i don't think any do, although sicl is planned to.
[00:39:41] *** Joins: myrrh (~markus@user/poet)
[00:41:44] *** Joins: thomp (~thomp@c-98-239-97-121.hsd1.ca.comcast.net)
[00:42:22] *** Quits: attila_lendvai (~alendvai@2a02:120b:2c72:1dc0:2e07:56d9:2bb8:283d) (Ping timeout: 268 seconds)
[00:43:18] *** Quits: rgherdt (~rgherdt@ip5f5af455.dynamic.kabel-deutschland.de) (Ping timeout: 250 seconds)
[00:46:54] <mfiano> I suppose that's true.
[00:47:26] *** Quits: sloanr (~user@97-127-122-25.mpls.qwest.net) (Remote host closed the connection)
[00:47:40] *** Joins: sloanr (~user@97-127-122-25.mpls.qwest.net)
[00:48:15] <mfiano> Admittedly I am too used to static analysis of SBCL with regard to arrays of varying types, and it maps very well to my mind with what the machine code will look like.
[00:50:12] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[00:54:00] <mfiano> Without satisfies couldn't I use (and simple-vector (not (simple-vector 0))) ?
[00:54:59] <Bike> hmm. i think you're right.
[00:56:38] *** Quits: sloanr (~user@97-127-122-25.mpls.qwest.net) (Remote host closed the connection)
[00:56:51] *** Joins: sloanr (~user@97-127-122-25.mpls.qwest.net)
[00:57:07] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[00:57:35] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[00:57:44] <mfiano> I'll probably stick with the runtime check though. I would have to greatly change the load order of my code, as this is for a struct definition that needs to be loaded earlier than the structure-objects the elements of this slot will contain
[00:59:19] *** Quits: raeda_ (~raeda@72.49.214.135) (Quit: Leaving)
[00:59:38] <mfiano> Normally I would use standard-objects, but this is very low-level code that I am doing the early 75% optimization that doesn't take too much time and will more than pay for itself. It's the other 25% that is not going to happen.
[01:01:46] <mfiano> That or I could have some sentinel initial value like #(nil)
[01:02:20] <mfiano> Which would still be a runtime check. I am getting into a hole I don't want to be in, so simple wins the race.
[01:03:07] *** Quits: ksp (~ksp@cpc115140-livi7-2-0-cust438.18-2.cable.virginm.net) (Quit: WeeChat 3.4)
[01:03:25] *** Quits: scymtym (~user@2001:638:504:20e6:d2b:67db:8460:2e05) (Ping timeout: 250 seconds)
[01:07:16] <rotateq> (make-array 0 :element-type 'nil)
[01:16:22] *** Joins: lisp123 (~lisp123@5.30.23.247)
[01:21:09] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[01:27:20] *** Joins: varjag (~user@ti0040a400-5479.bb.online.no)
[01:33:27] *** Joins: Algernon69 (~Algernon6@88.124.69.179)
[01:34:24] *** Joins: Algernon91 (~Algernon6@2a04:cec0:10e5:449e:2095:3f70:5084:b6c4)
[01:36:10] *** Quits: nature (~nature@45.32.235.173) (Ping timeout: 250 seconds)
[01:36:36] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[01:38:17] *** Quits: Algernon69 (~Algernon6@88.124.69.179) (Ping timeout: 252 seconds)
[01:40:13] *** Joins: kevingal (~quassel@2a02:8084:4140:f300:f43d:bda7:b2e4:74b8)
[01:44:18] *** Quits: gaqwas (~john@dynamic-077-009-125-230.77.9.pool.telefonica.de) (Remote host closed the connection)
[01:49:15] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[01:50:33] *** Joins: scymtym (~user@ip-94-114-248-79.unity-media.net)
[02:01:00] *** form_fee- is now known as form_feed
[02:02:48] *** Joins: pillton (~user@193-116-101-87.tpgi.com.au)
[02:04:08] <morganw> Hopefully this is not too much of an annoying beginner question, but I'm following exercises in a book and accidentally made a function which remembers its previous let binding values. Could anyone point me at the mistake? https://pastebin.com/R5x5DBtN
[02:04:50] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[02:08:04] <theothornhill> morganw: what does the input look like?
[02:09:13] <morganw> (count-bases '(a g t a c t c t)) or (count-bases '((g c) (a t) (t a) (t a) (c g))) are the given examples to work with.
[02:12:49] *** Quits: cage (~cage@dynamic-adsl-84-221-50-16.clienti.tiscali.it) (Quit: rcirc on GNU Emacs 27.1)
[02:13:33] <morganw> Basically, just count the symbols in either case and return the counts. I thought I was being smart and efficient by modifying the return list in-place, but apparently I'm not that smart... It does work on the first run but somehow the ret list is preserved for the next run.
[02:14:59] <rotateq> morganw: there's also #clschool :)
[02:15:09] *** Quits: pve (~pve@178-55-65-112.bb.dnainternet.fi) (Quit: leaving)
[02:15:17] <rotateq> ahhh i did similar stuff as well some time ago playwise ^^
[02:15:55] <rotateq> is this from rosalind?
[02:16:12] <morganw> It is from "A Gentle Introduction to Symbolic Computing"
[02:17:03] <rotateq> just use (loop for symbol in list ...)
[02:17:12] <rotateq> ohh nice intro book
[02:17:15] <morganw> (in the chapter about iteration, so the function is meant to be iterative in how it works even when the problem doesn't naturally fit)
[02:18:57] *** Quits: shka (~herr@109.231.0.226) (Ping timeout: 256 seconds)
[02:21:01] <rotateq> (loop named count-loop with as = 0 with cs = 0 with gs = 0 with ts = 0 for symbol in list when (eq symbol 'a) do (incf as) when (eq symbol 'c) do (incf cs) when (eq symbol 'g) do (incf gs) when (eq symbol 't) do (incf ts) finally (return-from count-loop (values as cs gs ts)))
[02:21:35] <rotateq> but watch out, the T will really be seen as the top-value too, but okayish in this case
[02:22:00] <rotateq> but don't try something like (let ((t ...)) ...)
[02:23:12] <rotateq> okay, value 'true' but highest system-class top or better ⊤, the T is just by accident similar taken as 'true
[02:23:25] <rotateq> 'true' just in quotes i mean
[02:24:06] <morganw> Just to double-check, if you run my function does it also remember the previous runs? (just to check I haven't somehow broken the whole environment)
[02:24:17] <rotateq> ehm ..
[02:25:02] <rotateq> ah okay, it goes recursively as long as there is no cons anymore
[02:25:20] <rotateq> sorry just saw the link of yours now, let me see ...
[02:25:24] <_death> morganw: you shouldn't modify literals.. the result of '(a g t ...) is a literal.  instead, you can use (list 'a 'g ...) or copy the list to create a fresh one, (copy-list '(a g t ...)) .. you can also use copy-tree to copy the sublists in the second one
[02:25:26] <pillton> morganw: You are using '((a 0) (t 0) (g 0) (c 0)) which is a literal.
[02:26:19] <rotateq> looks good :)
[02:26:25] <morganw> So the literal can persist as optimisation?
[02:26:41] <pillton> morganw: "The consequences are undefined if literal objects (including quoted objects) are destructively modified." from the CLHS entry for QUOTE.
[02:26:47] <pillton> clhs quote
[02:26:47] <specbot> http://www.lispworks.com/reference/HyperSpec/Body/s_quote.htm
[02:27:01] <_death> oh, I didn't look at the paste.. the literal you modify is '((a 0) ...) so you can use copy-tree, or simply variables and construct a list when returning
[02:27:24] <morganw> Ah right, thank you everyone for the help.
[02:27:24] <rotateq> i would have said, that better do it with (let ((%a 0) (%c 0) (%g 0) (%t 0)) ...) and you won't get a headache for your SETF forms
[02:27:42] <rotateq> then you can return with VALUES or LIST
[02:28:06] <rotateq> :)
[02:28:32] <rotateq> hmm, as a symbol i should use '|:)| ^^
[02:29:54] *** Quits: VincentVega (~user@212.97.1.105) (Ping timeout: 250 seconds)
[02:30:00] *** Joins: VincentV` (~user@212.97.1.105)
[02:33:20] *** Quits: karlosz (~karlosz@47.151.136.69) (Quit: karlosz)
[02:34:06] *** Quits: Catie (~user@user/catie) (Quit: Going home)
[02:37:41] *** Quits: Algernon91 (~Algernon6@2a04:cec0:10e5:449e:2095:3f70:5084:b6c4) (Ping timeout: 268 seconds)
[02:37:42] *** Quits: occ (~occ@user/occ) (Ping timeout: 250 seconds)
[02:44:37] *** Quits: kevingal (~quassel@2a02:8084:4140:f300:f43d:bda7:b2e4:74b8) (Ping timeout: 240 seconds)
[02:46:18] <rotateq> today i had a thought to something of mine "so this is the prototype for the prototype" :D
[02:49:29] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[02:50:54] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[02:54:28] *** Quits: varjag (~user@ti0040a400-5479.bb.online.no) (Quit: ERC 5.4.1 (IRC client for GNU Emacs 29.0.50))
[03:01:14] <NotThatRPG> rotateq: Is that Touretzky's book?
[03:03:21] <NotThatRPG> If so, not sure I would recommend it.
[03:04:08] *** Quits: cosimone (~user@93-47-228-11.ip115.fastwebnet.it) (Ping timeout: 250 seconds)
[03:08:19] *** Quits: sloanr (~user@97-127-122-25.mpls.qwest.net) (Remote host closed the connection)
[03:08:20] <morganw> It is that book. But it seems that part of the learning process is being restricted to certain methods in each chapter.
[03:08:32] *** Joins: sloanr (~user@97-127-122-25.mpls.qwest.net)
[03:08:58] <rotateq> NotThatRPG: the "gentle intro"?
[03:09:06] <NotThatRPG> Yes.
[03:09:13] <NotThatRPG> Who wrote it?
[03:09:45] <rotateq> yes morganw, maybe as in SICP, just in lecture 5 they start with assignment
[03:09:55] <rotateq> ehm don't know from memory now ^^
[03:10:38] <rotateq> but they provide a CAR and CDR spelling advise :)
[03:13:23] <morganw> Order of chapters is first learn about applicative methods, then recursion, then iteration.
[03:13:46] <rotateq> :)
[03:13:58] <rotateq> and what conses are, with picturing!
[03:14:22] <morganw> I imagine after this chapter I'd actually be free to pick the most appropriate way to suit the problem. No mention of loop yet though.
[03:14:24] <rotateq> there's a small nice package by bagger "draw-cons-tree"
[03:14:48] <rotateq> morganw: yes take your time, LOOP is a complex beast like FORMAT
[03:17:47] *** Joins: lisp123 (~lisp123@5.30.23.247)
[03:22:35] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[03:23:32] <NotThatRPG> TBQH I prefer to use the ITERATE macro over LOOP because it's not a separate language like LOOP (also LOOP has some specific defects in terms of conditionals and handling multiple values)
[03:23:39] *** NotThatRPG is now known as NotThatRPG_away
[03:24:01] <rotateq> i don't really have experience with iterate (yet)
[03:24:12] <rotateq> maybe then use the SICL LOOP module :)
[03:25:10] *** Joins: karlosz (~karlosz@47.151.136.69)
[03:26:58] *** Quits: mgl (~mgl@cpc87455-finc19-2-0-cust234.4-2.cable.virginm.net) (Ping timeout: 256 seconds)
[03:28:24] *** Parts: VincentV` (~user@212.97.1.105) (ERC (IRC client for Emacs 27.2))
[03:30:09] *** Joins: taiju (~user@240b:253:ec40:2400:b7d1:436e:2d61:e925)
[03:45:22] <aeth> I don't like ITERATE because it's not LOOP-with-parentheses that people promise when they compare the two
[03:45:35] <aeth> And if I have to learn it to use it, everyone else will have to learn it to read my code.
[03:45:53] <aeth> On the other hand, an actual LOOP-with-parentheses would be a very nice macro.
[03:46:12] <aeth> even a properly configured Emacs can't properly indent a LOOP that's advanced enough.
[03:47:19] <moon-child> indeed
[03:47:37] <moon-child> doesn't even need to be that advanced.  Nested if-elses are enough to trip it up
[03:47:44] <aeth> right
[03:47:55] <aeth> all you need is conditional collect
[03:48:00] <aeth> which you kind of want to use LOOP for
[03:48:42] <aeth> If you don't have to collect (or similar) you can just use CL:COND or whatever, but if you are going to use collect, you suddenly need to use LOOP's if/else system
[03:49:06] <moon-child> yes
[03:49:28] <moon-child> raku and mathematica have gather/take, which are better because they compose with the rest of the language
[03:50:00] <aeth> again, sounds like something that would require special training, making code that only you can read
[03:50:06] <aeth> at least, if ported to CL
[03:50:22] <moon-child> sure.  But you can already read lisp
[03:50:34] <aeth> all I want is a hypothetical, e.g. called DO-LOOP, that uses parentheses in a way that makes it fit in... every other feature the same except perhaps for a few things that break the syntax too much
[03:50:39] <moon-child> it's not a completely separate language, like loop
[03:51:14] <moon-child> adding parens to loop won't make it compose any better
[03:51:52] <aeth> it wouldn't just be parens
[03:52:17] <aeth> most of LOOP, parenthesized, could be turned into trailing plists. A few parts couldn't, e.g. the hash table stuff that uses multiple symbols in a row
[03:52:34] <aeth> or where order matters
[03:52:42] <aeth> once you have things as parenthesized and key/value plists, you have a reason to use it: extensibility
[03:53:11] <moon-child> if you want extensible loop, use sicl's version
[03:53:13] <aeth> (:for i :of-type (unsigned-byte 32) :from 0 :below 1234)
[03:53:20] <moon-child> parsers are fairly easy to write
[03:53:32] <aeth> that doesn't even need a parser, that's just a DESTRUCTURING-BIND
[03:53:35] <aeth> a few ()s go a long way.
[03:53:51] <aeth> (and :s I guess)
[03:54:06] <moon-child> sure.  It might more might not be _better_, but I think it is definitely not _significantly_ better
[03:54:35] <moon-child> s/more/or/
[03:55:07] <aeth> (to anticipate being poked 5 hours from now... OK, a DESTRUCTURING-BIND or an APPLY, depending on how you'd want to do it)
[03:56:50] <moon-child> (in case anyone cares, here is my loop extensions wishlist: collect into string/array, collect major cells of multi-dimensional array, resulting-in clause, bind multiple values)
[03:57:53] <aeth> most important is the last one
[03:58:07] <moon-child> oh, also an initially clause
[03:58:08] <aeth> otherwise you have to cons up an intermediate list or give up half of the convenience of the LOOP form
[03:58:19] <aeth> and sometimes you REALLY just need to get the 2nd value of a function
[03:58:53] <aeth> I usually just PSETF at the start of a DO in the body when I need multiple values iirc.
[03:59:10] <aeth> or just MULTIPLE-VALUE-BIND if it's only relevant to that part of the iteration
[04:00:01] <moon-child> well, I mean--it's all convenience features, I don't think any of these are particularly _important_.  Can just PROG like it's the 60s
[04:00:26] <aeth> poorly-written gigantic LOOPs are where bugs are found
[04:00:52] <aeth> but consing up in a giant LOOP isn't good, either
[04:01:17] <aeth> not having a M-V-B seems to be the main flaw, as well as no collect-into-array (which means you have to manually track the index)
[04:01:24] *** Joins: semz (~semz@2001:9e8:4bc1:b000:10fa:6cd1:6326:8c0f)
[04:01:24] *** Quits: semz (~semz@2001:9e8:4bc1:b000:10fa:6cd1:6326:8c0f) (Changing host)
[04:01:24] *** Joins: semz (~semz@user/semz)
[04:01:43] <moon-child> VECTOR-PUSH-EXTEND?
[04:02:16] *** Quits: Volt (~Volt@c-73-145-161-51.hsd1.mi.comcast.net) (Remote host closed the connection)
[04:02:42] *** Quits: amk (~amk@109.255.169.126) (Ping timeout: 260 seconds)
[04:02:49] <moon-child> NB. I suggest SELECT, VOLITA, and VOLITAS for strings, array elements, and array major cells, respectively.
[04:05:44] *** Joins: amk (~amk@109.255.169.126)
[04:09:12] <aeth> moon-child: collect-into-array at an implementation level of CL:LOOP (so you couldn't do it yourself) could be unsafe
[04:09:23] <aeth> so it could outperform VECTOR-PUSH-EXTEND
[04:09:39] <aeth> at least, if you want a simple-vector at the end (which requires copying, unless the implementation optimizes it, which they won't)
[04:10:18] *** Joins: occ (~occ@user/occ)
[04:10:37] *** Quits: semz (~semz@user/semz) (Quit: Leaving)
[04:10:48] *** Joins: semz (~semz@2001:9e8:4bc1:b000:10fa:6cd1:6326:8c0f)
[04:10:48] *** Quits: semz (~semz@2001:9e8:4bc1:b000:10fa:6cd1:6326:8c0f) (Changing host)
[04:10:48] *** Joins: semz (~semz@user/semz)
[04:11:23] *** Quits: semz (~semz@user/semz) (Client Quit)
[04:11:41] <aeth> i.e. an adjustable vector only when creating it, and then once returning it it becomes a simple-vector. This requires implementation-level support afaik
[04:11:43] *** Joins: semz (~semz@2001:9e8:4bc1:b000:10fa:6cd1:6326:8c0f)
[04:11:43] *** Quits: semz (~semz@2001:9e8:4bc1:b000:10fa:6cd1:6326:8c0f) (Changing host)
[04:11:43] *** Joins: semz (~semz@user/semz)
[04:12:54] <moon-child> so, it couldn't be implemented portably anyway :P
[04:14:38] <moon-child> (also would result in arguably odd behaviour; (let (x) (loop repeat 1 volita 5 into y do (setf x y)))
[04:16:50] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[04:16:58] <jstoddard> ,wuit
[04:17:13] <jstoddard> sorry, typing too fast
[04:17:29] <jstoddard> On my way home from work, so see everyone later.
[04:17:31] *** Quits: jstoddard (~user@107-142-159-57.lightspeed.sndgca.sbcglobal.net) (Quit: ERC (IRC client for Emacs 27.2))
[04:19:44] <Josh_2> Fukamachi says he is willing to hand over  Dex to citizenandrew
[04:20:19] *** Joins: gaqwas (~john@dynamic-077-009-125-230.77.9.pool.telefonica.de)
[04:20:46] *** Joins: kingofcsu (~kingofcsu@114.249.133.203)
[04:25:49] <aeth> moon-child: no, it could be implemented portably, it just couldn't be optimized portably... it would have to be optimized at the implementation level
[04:26:07] <aeth> moon-child: I just told you the portable implementation... SUBSEQ at the end to turn an adjustable vector into a simple-vector
[04:26:12] *** Joins: agrewal (~Aman@cpe-74-68-64-28.si.res.rr.com)
[04:26:26] <aeth> it's just that implementations have several ways that they could avoid that copy
[04:27:14] <agrewal> phoe: Just finished your condition system. It was a good read
[04:27:40] <moon-child> 'just couldn't be optimized portably' sure
[04:27:53] <moon-child> but 'SUBSEQ at the end' again, this exposes the inconsistency
[04:28:30] *** Quits: sloanr (~user@97-127-122-25.mpls.qwest.net) (Remote host closed the connection)
[04:28:43] *** Joins: sloanr (~user@97-127-122-25.mpls.qwest.net)
[04:28:46] <aeth> you could just have into not apply to collect-as-array, except perhaps if that variable is only accessed inside of a finally
[04:28:54] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[04:28:59] <aeth> since it's not collect, it's collect-as-array
[04:29:14] <aeth> between the loop body and the finally, you'd do the magic
[04:31:31] <moon-child> sure.  I would rather have to ability to use INTO if I want it
[04:31:41] <moon-child> and: it doesn't seem like a problem for the result to be an adjustable array
[04:31:57] *** Quits: gaqwas (~john@dynamic-077-009-125-230.77.9.pool.telefonica.de) (Ping timeout: 240 seconds)
[04:32:13] <aeth> except anyone who optimizes array code turns their function into one that only accepts a simple-array, for "free" optimization at the cost of breaking, well, this
[04:33:06] <moon-child> I would rather have whatever implementation-specific functionality is required to turn an adjustable array into a simple vector be exposed explicitly
[04:33:53] <moon-child> (with a portable fallback to SUBSEQ, presumably--it is not necessary to retain identity, and may even be impossible with certain tagging schemes.  As with other destructive functions, the source may be left in undefined state)
[04:33:58] <aeth> (type-of (subseq (make-array 3 :adjustable t :initial-contents '(1 2 3)) 0 2))
[04:34:04] <aeth> should be (SIMPLE-VECTOR 2)
[04:34:15] <aeth> well, I probably should have used typep
[04:35:20] <aeth> It's specified to return a simple array of the rank, anyway. And as you see, it doesn't need to return the whole thing, so you only need to track the end point
[04:36:19] <aeth> If you wanted it to be portable, then you'd just have to get implementations to optimize the idiom of a SUBSEQ on an adjustable array that never leaves scope and so can't be referenced anywhere else... just used to build up a simple-array
[04:44:34] *** Joins: molson (~molson@2001-48F8-704A-123D-0-0-75F-1013-static.midco.net)
[04:44:36] *** Joins: molson_ (~molson@2001-48F8-704A-123D-0-0-75F-1013-static.midco.net)
[04:44:36] *** Quits: molson_ (~molson@2001-48F8-704A-123D-0-0-75F-1013-static.midco.net) (Client Quit)
[04:46:06] *** Joins: osp (~osp@84.19.72.107)
[04:52:44] *** Joins: phantomics (~phantomic@71-218-243-149.hlrn.qwest.net)
[04:53:46] *** Quits: sloanr (~user@97-127-122-25.mpls.qwest.net) (Ping timeout: 250 seconds)
[04:56:13] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[04:59:42] *** Joins: Oladon (~olad@98.43.81.226)
[05:00:16] *** Quits: myrrh (~markus@user/poet) (Ping timeout: 250 seconds)
[05:05:09] *** Quits: igemnace (~ian@user/igemnace) (Ping timeout: 256 seconds)
[05:09:47] *** Joins: ahammer (~ahammer@2409:8954:8cc:52c1:3534:681d:f1d0:740c)
[05:10:15] *** Quits: thomp (~thomp@c-98-239-97-121.hsd1.ca.comcast.net) (Ping timeout: 256 seconds)
[05:13:57] *** Quits: ahammer (~ahammer@2409:8954:8cc:52c1:3534:681d:f1d0:740c) (Ping timeout: 240 seconds)
[05:14:13] *** Quits: rotateq (~user@p200300e787097300818cd04b4ea1a4f3.dip0.t-ipconnect.de) (Quit: ERC (IRC client for Emacs 27.2))
[05:16:41] *** Joins: kevingal (~quassel@2a02:8084:4140:f300:f43d:bda7:b2e4:74b8)
[05:18:49] *** Joins: ahammer (~ahammer@157.122.68.227)
[05:19:26] *** Joins: lisp123 (~lisp123@5.30.23.247)
[05:21:54] *** Quits: johnjaye (~pi@154.6.152.74) (Quit: WeeChat 3.3)
[05:22:04] *** Joins: myrrh (~markus@172.58.196.36)
[05:24:15] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[05:26:07] *** Quits: ahammer (~ahammer@157.122.68.227) (Ping timeout: 256 seconds)
[05:26:07] *** Quits: kingofcsu (~kingofcsu@114.249.133.203) (Quit: kingofcsu)
[05:27:32] *** Joins: sloanr (~user@97-127-122-25.mpls.qwest.net)
[05:27:34] *** Quits: random-nick (~random-ni@87.116.167.125) (Ping timeout: 250 seconds)
[05:30:30] *** Quits: sloanr (~user@97-127-122-25.mpls.qwest.net) (Remote host closed the connection)
[05:30:40] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[05:30:43] *** Joins: sloanr (~user@97-127-122-25.mpls.qwest.net)
[05:32:52] *** Quits: morganw (~user@80.225.24.132) (Remote host closed the connection)
[05:38:13] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[05:51:25] *** Joins: ahammer (~ahammer@157.122.68.227)
[05:55:44] *** Quits: ahammer (~ahammer@157.122.68.227) (Ping timeout: 250 seconds)
[05:56:19] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[05:57:26] *** Joins: ahammer (~ahammer@157.122.68.227)
[06:00:12] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[06:08:37] *** Quits: ahammer (~ahammer@157.122.68.227) (Ping timeout: 256 seconds)
[06:09:45] *** Quits: flip214 (~marek@user/flip214) (Ping timeout: 256 seconds)
[06:09:45] *** Quits: jdz (~jdz@185.23.160.114) (Ping timeout: 256 seconds)
[06:09:52] *** Joins: flip214 (~marek@user/flip214)
[06:10:43] *** Joins: ahammer (~ahammer@157.122.68.227)
[06:11:56] *** Joins: jdz (~jdz@185.23.160.114)
[06:14:45] *** Joins: frodef_ (~frode@46.212.93.4)
[06:15:15] *** Quits: frodef (~frode@46.212.93.4) (Ping timeout: 256 seconds)
[06:19:08] *** Quits: ahammer (~ahammer@157.122.68.227) (Ping timeout: 250 seconds)
[06:26:28] *** Joins: s-liao (~s-liao@101.86.96.21)
[06:28:31] *** Quits: kevingal (~quassel@2a02:8084:4140:f300:f43d:bda7:b2e4:74b8) (Remote host closed the connection)
[06:37:29] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[06:39:12] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[06:40:37] <Josh_2> I have thousands of SLOC that rely on plists, and now I have to convert it all to use hash tables :facepalm:
[06:41:46] <lagash> Josh_2: what for? performance?
[06:42:09] <Josh_2> Because I'm an idiot. I wish that Jonathan parsed as hash-table by default...
[06:42:58] *** Quits: occ (~occ@user/occ) (Ping timeout: 250 seconds)
[06:43:03] *** Quits: ec (~ec@gateway/tor-sasl/ec) (Ping timeout: 276 seconds)
[06:56:16] *** Quits: molson (~molson@2001-48F8-704A-123D-0-0-75F-1013-static.midco.net) (Quit: Leaving)
[06:58:47] *** Joins: frodef (~frode@46.212.93.4)
[06:59:26] *** Quits: frodef_ (~frode@46.212.93.4) (Ping timeout: 250 seconds)
[07:00:45] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[07:00:47] <White_Flame> yeah, JSON tools really need configurability per use
[07:01:35] *** Quits: sloanr (~user@97-127-122-25.mpls.qwest.net) (Remote host closed the connection)
[07:03:35] *** Quits: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 256 seconds)
[07:05:36] *** Joins: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[07:15:56] *** Joins: rotateq (~user@p200300e787097300818cd04b4ea1a4f3.dip0.t-ipconnect.de)
[07:20:58] *** Joins: lisp123 (~lisp123@5.30.23.247)
[07:25:31] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[07:26:15] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[07:28:47] *** Joins: molson (~molson@2001-48F8-704A-123D-0-0-75F-1013-static.midco.net)
[07:30:28] <beach> Good morning everyone!
[07:40:21] *** Quits: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4) (Ping timeout: 250 seconds)
[07:40:37] *** Quits: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 240 seconds)
[07:42:57] *** Joins: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[07:48:37] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[07:49:37] *** Parts: pranavats (3fba1d1b34@jabberfr.org) (Error from remote client)
[07:50:12] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[07:50:35] <Josh_2> Mornin'
[07:53:18] *** Quits: s-liao (~s-liao@101.86.96.21) (Ping timeout: 256 seconds)
[07:55:34] *** Joins: s-liao (~s-liao@101.86.96.21)
[07:58:57] *** Joins: molson_ (~molson@2001-48F8-704A-123D-0-0-75F-1015-static.midco.net)
[08:00:23] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[08:02:11] *** Quits: molson (~molson@2001-48F8-704A-123D-0-0-75F-1013-static.midco.net) (Ping timeout: 252 seconds)
[08:02:33] <beach> Bike: I think your suggestion would be a violation of Common Lisp semantics.
[08:02:52] <Bike> you think? i'm not sure.
[08:02:56] <beach> But I can point to the exact location in the standard that would be relevant.
[08:03:23] <Bike> i think the question is whether undefined behavior means the entire program is undefined, or just the particular form
[08:03:24] <beach> It would seem to me that the forms have to be evaluated in order.
[08:03:36] <beach> Oh, sorry, you are right.
[08:03:45] <beach> I assumed WSCL already in place. :)
[08:04:36] <beach> Let me modify what I just said then: Provided AREF is required to signal an error, I think you example is a violation of Common Lisp semantics.
[08:04:52] <Bike> if aref is required to signal an error, sure.
[08:04:53] <beach> But yeah, you might very well be right.
[08:05:44] <Bike> but i was less asking about whether this would be conforming and more with whether people would like or dislike it or what if that was how it worked
[08:06:24] <beach> You are opening a Pandora's box here.  Now, Common Lisp implementations can do what implementations of C do, namely exploit all undefined behavior to improve performance at all cost. :)
[08:07:09] <beach> Ah, yes, I understand.  Well, my opinion would be that the definition of AREF should be fixed, so...
[08:07:15] <Bike> that's why i phrased it in terms of type errors
[08:07:35] <Bike> i recently spent like two entire days chasing down bugs caused by c compilers doing that, so i have no desire to continue that into lisp
[08:08:15] <beach> Whew! :)
[08:09:09] <Bike> i mean, let me put this another way. should WSCL or whatever else require type errors to be signaled by the operator, or could it just say that an error is signaled somewhere? for example, at any point after the violation is inevitable.
[08:09:47] <beach> That's a very good question.  The latter could then allow for more optimizations.
[08:10:12] <rotateq> Good morning you smart people. :)
[08:10:23] <Bike> in any case i'd like the situation clarified, since as far as i can tell CLHS is ambiguous here
[08:10:29] <beach> Bike: But I have no idea how that would be phrased.
[08:10:49] *** Joins: molson__ (~molson@2001-48F8-704A-123D-0-0-75F-1015-static.midco.net)
[08:10:59] <beach> rotateq: As Bike pointed out, simple arrays can very well have fill pointers and such.
[08:11:37] <rotateq> Oh okay, I wasn't too sure, so it was good again we talked about it. I just tried then a simple example in SBCL.
[08:12:00] <Bike> any phrasing would probably be pretty involved, but i think that's sort of required. the standard is kind of... vague in this area
[08:12:05] <rotateq> beach: All C implementations? I read some time Symbolics had their own too as with Ada and Fortran. :)
[08:12:09] <beach> You can't use a particular implementation to determine what the standard says.
[08:12:15] * rotateq should read backlog ..
[08:12:26] <Bike> there's a distinction made between "unspecified" versus "undefined" consequences, and the distinction is that unspecified consequences are "harmless"
[08:12:30] <rotateq> beach: You're right of course!
[08:12:33] <beach> Bike: Yes, that would be an interesting exercise.
[08:12:34] *** Quits: gko (~user@user/gko) (Remote host closed the connection)
[08:12:34] <Bike> no definition of harmlessness that i can see
[08:13:01] *** Joins: gko (~user@user/gko)
[08:13:01] <Bike> i can intuit that it means, you know, don't segfault, but it's unspecific
[08:13:11] *** Quits: molson_ (~molson@2001-48F8-704A-123D-0-0-75F-1015-static.midco.net) (Ping timeout: 252 seconds)
[08:13:18] <beach> Bike: Yes, very interesting.
[08:14:16] <rotateq> Maybe the loopus also hunts C code when nothing else is there to eat.
[08:14:39] <beach> Bike: It looks to me like we (collectively) now have the ability to improve on the standard.  Exciting!
[08:14:48] <Bike> I hope so
[08:16:11] <moon-child> (progn (setf x 5) (setf *y* 5) (aref x 0))
[08:16:31] <moon-child> if you signal an error early you kill the assignment to *y*
[08:16:41] *** Quits: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 256 seconds)
[08:16:42] <moon-child> this may be undesirable
[08:16:56] <rotateq> beach: As I often see, even more things to learn about what others so easily call just "trivial" and that's way more worth to explore and deepen as just flying in too abstract and "modern" things.
[08:17:21] *** Quits: jealousmonk (~user@2804:431:e7c5:b880:889f:205:ed34:5b22) (Remote host closed the connection)
[08:17:26] <rotateq> maybe using UNWIND-PROTECT? :)
[08:17:29] <Bike> is it? i mean, i can imagine it being so, but on the other hand, maybe if the error is signaled earlier the program is stopped before it can get halfway through a state change
[08:17:31] *** Joins: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[08:17:46] <Bike> and leaving things inconsistent
[08:17:47] <rotateq> very powerful spell
[08:17:55] <moon-child> the program is probably already halfway through a state change when it figures out the thing that it's going to index later is not an array
[08:18:02] <moon-child> you just change where in that state change the problem happens
[08:18:20] <moon-child> realistically, you are not going to recover state from a program which fails a bounds-check
[08:18:27] <moon-child> without manual intervention (which can fix up such a thing anyway)
[08:18:33] <moon-child> but
[08:18:52] <Bike> why would it matter how far the program gets, then
[08:20:12] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[08:20:53] <moon-child> I don't know.  But I can imagine cases where it would matter, esp. in context of other transformations
[08:22:10] <Bike> the other reason i'm thinking about this is that in a few cases, it is outright impossible to signal an error at the violation point
[08:23:13] <Bike> if you have (let ((f (the (function * float) f))) ...), there's no way (in general, but practically speaking, pretty much at all) for the implementation to determine f will return a non-float until it actually does
[08:24:11] <Bike> strictly speaking with the way function types are defined, it could technically work out, but nonetheless the error would be some time after the THE is evaluated
[08:26:32] *** Quits: euandreh (~euandreh@2804:14c:33:9fe5:b997:c1f9:27c:1247) (Ping timeout: 250 seconds)
[08:27:10] <Bike> (and i don't think anybody would seriously expect an error to be signaled immediately)
[08:27:48] *** Joins: semz_ (~semz@2001:9e8:4bc3:b800:ad17:5967:d69a:4e63)
[08:27:48] *** Quits: semz_ (~semz@2001:9e8:4bc3:b800:ad17:5967:d69a:4e63) (Changing host)
[08:27:48] *** Joins: semz_ (~semz@user/semz)
[08:29:28] <Bike> oh, and i forgot there is an analogous situation where the clhs does sort of say something
[08:30:07] <Bike> in 3.5.1.1.1, it says that when an error is signaled for a call problem (too many arguments etc), "it might be signaled at compile time or at run time, and if signaled at run time, it might be prior to, during, or after executing the call"
[08:30:07] *** Quits: jeosol (~jeosol@user/jeosol) (Ping timeout: 256 seconds)
[08:30:11] *** Quits: semz (~semz@user/semz) (Ping timeout: 250 seconds)
[08:30:17] <Bike> still pretty vague.
[08:30:25] *** Joins: light (~light@user/light)
[08:36:48] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 276 seconds)
[08:37:26] <Bike> anyway mostly i want to sound out if someone has some code that this behavior would ruin, that kind of thing. and i'm just fishing for thoughts.
[08:37:30] *** Quits: Bike (~Glossina@71.69.170.70) (Quit: and now, i'm sleeping)
[08:37:38] *** Joins: thomp (~thomp@c-98-239-97-121.hsd1.ca.comcast.net)
[08:38:03] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[08:41:17] <rotateq> hihi
[08:41:37] <rotateq> hm from which time zone is Bike?
[08:42:00] <beach> Eastern USA usually.
[08:47:28] <rotateq> ah :) okay today my sleep rhythm is again really broken
[08:56:16] <pillton> The (function * float) example is a good one. I think AREF should signal an error though. I think there should be another operator or operators introduced which either avoid using AREF or ensure that every call to AREF does not require checking its arguments.
[08:56:26] *** Quits: pjb (~pjb@user/pjb) (Read error: Connection reset by peer)
[08:58:58] <beach> I was just wondering what the advantage would be to signal the error early.  I can imagine that there would be performance advantages.  However, nothing prevents an implementation from detecting the error early, but not signaling it immediately.  Instead, it would have two branches, one of which evaluates the intermediate forms and then signals an error.
[08:59:15] *** Quits: osp (~osp@84.19.72.107) (Quit: Leaving)
[09:01:11] *** Quits: thomp (~thomp@c-98-239-97-121.hsd1.ca.comcast.net) (Quit: Konversation terminated!)
[09:01:23] *** Joins: thomp (~thomp@c-98-239-97-121.hsd1.ca.comcast.net)
[09:04:43] <beach> Does that make sense?  I mean, we would then have the performance advantage in that the normal branch could be optimized to assume the right type, but we would still respect a more strict definition of semantics.
[09:05:37] *** Quits: thomp (~thomp@c-98-239-97-121.hsd1.ca.comcast.net) (Ping timeout: 240 seconds)
[09:09:05] <pillton> Are we talking about AREF or more general?
[09:10:29] <beach> More generally I think.  I am contemplating a way to maintain the possible performance advantages with an early detection while still respecting the semantics of individual operators doing the signaling.
[09:10:31] <beach> So (let ((a (foo))) (map nil #'print a) (aref a 0)) would turn into (let ((a (foo))) (if (arrayp a) (progn (map nil #'print a) (aref a 0)) (progn (map nil #'print a) (error 'type-error...))))
[09:12:00] <beach> In the "normal" branch, the call to MAP could then be optimized to sasume A is an array.
[09:12:43] <beach> But the MAP operation would be performed in both branches, thereby respecting the semantics that AREF has to do the type check.
[09:13:17] <beach> And I believe this example could generalize to pretty much all similar cases.
[09:13:54] <pillton> I mostly worry about checking that the index is valid, which you still need to do in your example.
[09:14:27] <beach> It was Bike's example and he considered only the type of A.
[09:15:41] <pillton> Ok.
[09:19:01] *** Quits: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 256 seconds)
[09:19:57] *** Quits: frodef (~frode@46.212.93.4) (Ping timeout: 240 seconds)
[09:20:34] *** Joins: frodef (~frode@46.212.93.4)
[09:20:57] *** Joins: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[09:21:04] *** Joins: thomp (~thomp@c-98-239-97-121.hsd1.ca.comcast.net)
[09:21:38] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[09:22:34] *** Joins: lisp123 (~lisp123@5.30.23.247)
[09:25:36] *** Joins: aartaka (aartaka@gateway/vpn/protonvpn/aartaka)
[09:26:29] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[09:27:12] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 250 seconds)
[09:27:54] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[09:29:07] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[09:30:23] *** Joins: Jing (~hedgehog@240e:390:7c53:a7e1:87f:3f13:7a62:d6c7)
[09:36:18] *** Quits: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 250 seconds)
[09:37:00] <moon-child> beach: (let (a) (if cond (setf a definitely-an-array) (setf a who-knows-what)) (aref a 0))
[09:38:18] *** Joins: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[09:38:27] <moon-child> in that case, hm, you could hoist the check without any observable change in behaviour
[09:38:50] <moon-child> (if cond (setf a definitely-an-array) (progn (setf a who-knows-what) (check-type)))
[09:39:00] <ns12> Hello. If I have a string stored in a file, and I want to use that string as a string literal in Common Lisp code, I could use the hash-dot `#.` reader macro to read the string from the file. If I produce an executable of this program, the user will not need to have the file present because the file is only read at "read-time". My question is: how
[09:39:01] <ns12> does read-time differ from compile-time?
[09:40:00] <rotateq> yes ns12 :)
[09:40:05] <rotateq> and no.
[09:40:21] <rotateq> cause you can have pre-compiletime at readtime too like runtime
[09:40:52] <ns12> Oh? What does that mean?
[09:40:57] <moon-child> (however given more complex control flow such a simplification would no longer be feasible)
[09:41:21] <rotateq> ns12: That at the three main phases you always could have the other two.
[09:42:20] <rotateq> and when you have a string with "foo" in this .lisp it is read directly as an object of class simple-string
[09:42:37] <rotateq> cause #\" is one of the standard so called readmacros
[09:42:51] <rotateq> or is it in a "normal" file?
[09:42:57] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Remote host closed the connection)
[09:43:10] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[09:44:02] <ns12> From my understanding, the three phases are: read-time, compile-time, and run-time. During run-time, I can have read-time and compile-time by using COMPILE and EVAL. During compile time, there will always be a read-time phase. But where is the run-time? During read-time, where is the compile-time and run-time?
[09:45:00] <rotateq> most times there is no need to use EVAL directly ;)
[09:45:19] <rotateq> and no, compile main phase comes really AFTER readtime
[09:45:37] <rotateq> runtime is when you let expressions pre-evaluate
[09:45:54] <rotateq> or do other kinds of in between calculations
[09:46:21] <rotateq> when you do #.(+ 1 2) it is really done at readtime
[09:47:21] <rotateq> or when using the #+sbcl(+ 1 2) it first looks if :SBCL is in *features* at readtime but if not gives back (values) directly
[09:47:38] *** Joins: rgherdt (~rgherdt@2a02:8109:86c0:d8d:c53f:d83a:dd8d:27ab)
[09:50:12] <White_Flame> ns12: the phases really only have to do with compilation itself.  It all happens "at runtime" and whatever is in the image at that time is available to any code at any phase
[09:50:42] <White_Flame> EVAL, however, does not invoke the reader.  It starts from already-read source code
[09:50:45] <White_Flame> *source code forms
[09:51:06] <White_Flame> the reader is purely the text characters -> forms conversion
[09:51:25] <ns12> I think I need to study the HyperSpec. What is the relevant chapter? Is the chapter 3 "Evaluation and Compilation"?
[09:51:38] <ns12> http://www.lispworks.com/documentation/HyperSpec/Body/03_.htm
[09:51:39] <White_Flame> I think it's fairly easily intuitive
[09:51:42] <White_Flame> the spec is complex
[09:52:18] <ns12> s/Is the chapter/Is it chapter/
[09:52:22] <White_Flame> the reader converts "(+ foo #.(+ 2 3))" to the list form (cl:+ cl-user:foo 5), assuming *PACKAGE is cl-user
[09:52:42] <rotateq> ns12: 15MB of mostly *pure* HMTL!
[09:52:46] <White_Flame> the compiler then takes that plain list of symbols etc and converts it to another executable form
[09:53:10] <White_Flame> (oh, presumably cl-user::foo, not single-coloned)
[09:54:33] <White_Flame> so when the reader is doing its thing, the current package matters, and it has to evaluate #. forms before any compilation of what it's working with has a chance to be compiled (because the compiler needs the reader to finish)
[09:56:01] <White_Flame> this is why (progn (ql:quickload "etc") (etc:init)) fails
[09:56:11] <White_Flame> assuming that the quickload manifests the package ETC
[09:56:40] <White_Flame> because the reader has to read that entire PROGN form before executing it, and the etc: package doesn't exist yet, meaning etc:init will fail the _read_ step
[09:57:07] <ns12> I see. The reader is a parser that converts strings to Lisp lists. The reader is programmable using reader macros. The reader will evaluate #. forms.
[09:57:17] <White_Flame> the actual creation of the symbol in the source code list (etc:init) fails, because that package doesn't exist at that time
[09:57:41] <White_Flame> and the reader is written in lisp itself, and all is executing in the same image :)
[09:59:00] <White_Flame> once these notions start being more known, the spec becomes much easier to read.  It's not a tutorial at all
[09:59:02] <beach> moon-child: Yes, I see.
[10:00:09] <White_Flame> ns12: and once the reader is done, pretty much none of the rest of the system ever knows or cares about the original string representation.  It's all about forms (which is what macros deal with, too)
[10:00:38] <ns12> White_Flame, rotateq: Thanks for the explanation.
[10:00:43] <White_Flame> np
[10:00:49] <rotateq> yes ns12, as it calls functions when defined readmacros are seen. the readtable works as a lookup-table
[10:01:51] <ns12> In the #. form, can I call any function? Even a function I defined myself?
[10:02:05] <White_Flame> sure, as long as it exists in the image
[10:02:36] <White_Flame> so for instance in your .asd file, any file that has been loaded before the current one should have all its macros, functions, toplevel vars, etc available
[10:02:54] <rotateq> and you can nest such things
[10:03:41] <White_Flame> the real muckety muck is loading from .fasl, though.  If you have purely read/compile time effects that leave things set, those won't necessarily reappear next time you load your project
[10:03:46] <ns12> What if the user-defined function is in the same file as the #. form that calls the function? I think EVAL-WHEN is needed, no?
[10:04:17] *** Quits: thomp (~thomp@c-98-239-97-121.hsd1.ca.comcast.net) (Ping timeout: 240 seconds)
[10:04:19] <rotateq> hm no wouldn't work the first time i would say
[10:04:20] <White_Flame> I'm not sure, it might be up to the implementation
[10:04:39] <White_Flame> because of stuff like (in-package), some forms have to be read one at a time, because they affect how the next one is read
[10:04:52] <rotateq> so better doing such things in files that are processed before, as with pushing keywords to *features*
[10:04:57] <White_Flame> *read/compiled/executed  one at a time
[10:05:09] <White_Flame> rotateq: yep
[10:06:55] <ns12> Okay. I'll experiment with these things.
[10:07:26] <rotateq> yes go ahead, we have it to do so :)
[10:11:31] <phoe> agrewal: thanks! glad that you liked it
[10:12:13] <ns12> White_Flame: "... the etc: package doesn't exist yet, meaning etc:init will fail the _read_ step" - Is this because the reader will try to intern `init` in the symbol table of the `etc` package, but that symbol table doesn't exist yet?
[10:12:36] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Remote host closed the connection)
[10:12:46] <rotateq> good morning phoe :)
[10:12:52] <phoe> good morning
[10:12:59] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[10:13:10] <phoe> (eval-always (defun foo ...)) #.(foo ...) should work though
[10:13:26] <rotateq> pre-readtime maybe :D
[10:13:57] <rotateq> (eval-before (:big-bang) ...)
[10:20:36] <White_Flame> ns12: correct
[10:20:54] <White_Flame> it sees the string "etc:init", and tries to hit the package ETC
[10:21:03] <White_Flame> in order to manifest the symbol (be it new in the package, or existing)
[10:21:50] <White_Flame> (well, with a single colon, even manifesting a new symbol will still not be exported, and still error)
[10:23:45] *** Quits: dec0d3r (~dec0d3r@2001:8003:480a:e00:e07:e7c3:7efc:ed0f) (Quit: Leaving)
[10:26:23] *** Joins: Cymew (~ante@c-e989225c.023-1144-7570702.bbcust.telenor.se)
[10:31:35] *** Quits: myrrh (~markus@172.58.196.36) (Remote host closed the connection)
[10:32:23] *** Joins: ksqsf (~user@2001:da8:d800:611:dceb:3079:7447:6f34)
[10:33:59] *** Parts: ksqsf (~user@2001:da8:d800:611:dceb:3079:7447:6f34) (ERC 5.4.1 (IRC client for GNU Emacs 29.0.50))
[10:44:21] *** Joins: Algernon69 (~Algernon6@88.124.69.179)
[10:48:41] *** Quits: Algernon69 (~Algernon6@88.124.69.179) (Ping timeout: 245 seconds)
[11:11:30] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 276 seconds)
[11:13:55] *** Joins: _ante_ (~ante@c-e989225c.023-1144-7570702.bbcust.telenor.se)
[11:15:50] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[11:17:57] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[11:18:39] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[11:24:22] *** Joins: lisp123 (~lisp123@5.30.23.247)
[11:28:47] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[11:29:55] *** Quits: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 256 seconds)
[11:29:55] *** Quits: amb007 (~a_bakic@102.215.76.86.rev.sfr.net) (Ping timeout: 256 seconds)
[11:30:54] *** Joins: amb007 (~a_bakic@108.36.22.93.rev.sfr.net)
[11:31:33] *** Joins: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[11:38:51] *** Joins: Algernon69 (~Algernon6@88.124.69.179)
[11:40:44] *** Joins: Algernon91 (~Algernon6@2a04:cec0:10e5:449e:d488:648c:46b0:f14f)
[11:40:44] *** Joins: mgl (~mgl@cpc87455-finc19-2-0-cust234.4-2.cable.virginm.net)
[11:44:31] *** Quits: Algernon69 (~Algernon6@88.124.69.179) (Ping timeout: 245 seconds)
[11:46:27] *** Joins: gaqwas (~john@dynamic-095-114-023-134.95.114.pool.telefonica.de)
[11:49:48] *** Quits: moon-child (~moon-chil@cardinal.elronnd.net) (Read error: Connection reset by peer)
[11:49:59] *** Joins: moon-child (~moon-chil@cardinal.elronnd.net)
[11:59:03] <mgl> With paste.lisp.org gone, what's the current policy on pasting code?
[12:02:30] <phoe> plaster
[12:02:37] <phoe> https://plaster.tymoon.eu/
[12:03:19] <engblom> Maybe it should be added to the topic
[12:04:07] * phoe inhales
[12:04:25] *** ChanServ sets mode: +o phoe
[12:04:32] *** phoe changes topic to 'Common Lisp, the #1=(programmable . #1#) programming language | Wiki: <https://www.cliki.net> | IRC Logs: <https://irclog.tymoon.eu/libera/%23commonlisp> | Cookbook: <https://lispcookbook.github.io/cl-cookbook> | Pastebin: <https://plaster.tymoon.eu/>'
[12:04:39] *** ChanServ sets mode: -o phoe
[12:04:43] <jackdaniel> shouldn't it be plasterbin ?
[12:04:56] <phoe> hmmm
[12:04:56] *** Quits: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 250 seconds)
[12:05:02] <phoe> maybe
[12:06:38] <mgl> https://plaster.tymoon.eu/view/2864
[12:07:10] *** Joins: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[12:07:26] <mgl> Anyway, the above is on SBCL, but the same happens on all other lisps I tried AllegroCL, CCL, CMUCL, ECL.
[12:07:47] <jackdaniel> and what's wrong with this?
[12:08:09] <mgl> The XXX restart is only printed in one of the cases.
[12:08:47] <jackdaniel> I see, thanks
[12:09:31] <mgl> Needless to say, I don't understand this behaviour.
[12:11:26] <jackdaniel> If the restartable-form is a list whose car is any of the symbols signal, error, cerror, or warn (or is a macro form which macroexpands into such a list), then with-condition-restarts is used implicitly to associate the indicated restarts with the condition to be signaled.
[12:11:31] <jackdaniel> in http://www.lispworks.com/documentation/HyperSpec/Body/m_rst_ca.htm
[12:12:10] <jackdaniel> somewhat confusing requirement (especially given your use case) but that's what it says
[12:14:40] <phoe> the (in)famous condition-restart association
[12:15:01] <phoe> one of the least known features of CL
[12:16:14] <jackdaniel> mgl: there is a cleanup issue in the spec explaining the rationale
[12:17:38] <phoe> tl;dr if you are in the debugger because of condition A, and then you do something that signals a nested condition B and you end up in a nested debugger, then you usually do not want to see restarts that are strictly related to condition A because they would be confusing
[12:18:14] <phoe> usually you want to only see restarts not associated with any condition *OR* those associated with condition B
[12:18:32] <phoe> and that's what WITH-CONDITION-RESTARTS does, and what RESTART-CASE implicitly does as well
[12:19:46] <phoe> if inside (progn (error "one") 1) you instead do (let ((error (make-condition ...))) (with-condition-restarts ... (error error) 1)) then you will be able to reproduce this behavior
[12:20:03] <phoe> RESTART-CASE does it for you in simple cases
[12:23:37] *** Joins: pve (~pve@188-67-147-47.bb.dnainternet.fi)
[12:23:37] *** Quits: amb007 (~a_bakic@108.36.22.93.rev.sfr.net) (Read error: Connection reset by peer)
[12:23:51] <mgl> jackdaniel: Thank you. It is unlike the spec to mandate such magic.
[12:24:20] *** Quits: Alfr (~Alfr@user/alfr) (Quit: Leaving)
[12:24:21] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[12:24:30] <mgl> phoe: Thanks. I'm aware of the condition-restart association, but this restart-case magic caught me offguard.
[12:24:35] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[12:25:16] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[12:27:30] <phoe> mgl: sure; if condition-restart association is one of the least known features of CL, then the fact that RESTART-CASE performs it implicitly is surely one of the least known features of the least known features
[12:27:30] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[12:27:56] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[12:28:34] *** Joins: igemnace (~ian@user/igemnace)
[12:29:24] *** Joins: varjag (~user@ti0040a400-5479.bb.online.no)
[12:29:25] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[12:29:45] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[12:30:06] *** Quits: icepic1984[m] (~icepic198@2001:470:69fc:105::cd23) (Quit: You have been kicked for being idle)
[12:33:27] *** Joins: lisp123 (~lisp123@5.30.23.247)
[12:35:03] *** Joins: Alfr (~Alfr@user/alfr)
[12:40:02] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 250 seconds)
[12:42:51] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[12:43:29] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[12:43:58] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[12:50:57] *** Quits: gaqwas (~john@dynamic-095-114-023-134.95.114.pool.telefonica.de) (Ping timeout: 256 seconds)
[12:52:38] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[12:52:59] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[12:55:12] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[12:55:47] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[13:00:27] *** semz_ is now known as semz
[13:02:43] *** Joins: shka (~herr@109.231.0.226)
[13:05:31] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[13:07:17] *** Joins: lispy (~lispy4@84.69.59.93)
[13:07:23] <lispy> Hi
[13:07:43] <rotateq> hi lispy :)
[13:08:07] <phoe> heyyy
[13:16:37] <rotateq> phoe: in which intervals do you rise new from the ashes?
[13:17:17] *** Quits: _ante_ (~ante@c-e989225c.023-1144-7570702.bbcust.telenor.se) (Ping timeout: 240 seconds)
[13:18:17] <lispy> I'm not sure how to interpret that question rotateq LOL
[13:18:37] <rotateq> but phoe does :P
[13:18:50] *** Joins: lisp123 (~lisp123@5.30.23.247)
[13:18:58] <lispy> hi isp123
[13:19:16] <rotateq> (nreverse 'lisp123)
[13:19:38] *** Joins: lisp123_ (~lisp123@45.132.225.26)
[13:19:39] <rotateq> now you're lisp321 aka lispcountdown
[13:20:15] *** Quits: karlosz (~karlosz@47.151.136.69) (Ping timeout: 256 seconds)
[13:20:36] *** Quits: pillton (~user@193-116-101-87.tpgi.com.au) (Remote host closed the connection)
[13:21:06] *** Joins: MajorBiscuit (~MajorBisc@wlan-145-94-216-150.wlan.tudelft.nl)
[13:21:37] *** Quits: MajorBiscuit (~MajorBisc@wlan-145-94-216-150.wlan.tudelft.nl) (Client Quit)
[13:21:47] *** Joins: MajorBiscuit (~MajorBisc@wlan-145-94-216-150.wlan.tudelft.nl)
[13:22:46] <phoe> rotateq: #.most-positive-fixnum
[13:22:54] <phoe> I just don't know what unit that number is in
[13:23:17] <rotateq> nice so maybe you're a celestial like being
[13:23:32] *** Joins: erjag (~user@188.95.247.248)
[13:23:49] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[13:24:02] <rotateq> haha i can violate the rule i follow every other time from physics studies :) "which unit?"
[13:24:57] *** Quits: varjag (~user@ti0040a400-5479.bb.online.no) (Ping timeout: 256 seconds)
[13:30:53] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[13:31:49] *** Joins: lisp123 (~lisp123@5.30.23.247)
[13:32:08] <lisp123> lispy: Hey :D
[13:32:40] <lispy> We both have good creative names
[13:33:03] <jackdaniel> lisp-service
[13:33:08] <rotateq> lispy: and you're the lispiest of them all :)
[13:33:29] <rotateq> jackdaniel: maybe 'jacklisp'?
[13:34:11] <jackdaniel> maybe
[13:35:04] *** Quits: lisp123_ (~lisp123@45.132.225.26) (Ping timeout: 250 seconds)
[13:37:04] <lispy> rotateq: thank you, you're also pretty lispy
[13:38:57] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 256 seconds)
[13:39:34] <phoe>  /msg LispServ eval (length '#1=(nil . #1#))
[13:39:37] <phoe> oops
[13:40:11] <lispy> Oh, you can do that?
[13:41:02] <phoe> nope
[13:41:28] <rotateq> yes lispy, i wanted such a name too. others also know me as "lotuseater"
[13:42:31] <lispy> lotuseater is a good name
[13:42:45] <beach> Can we please limit the off-topic stuff?
[13:43:19] <rotateq> Sorry.
[13:45:55] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[13:54:16] *** Quits: taiju (~user@240b:253:ec40:2400:b7d1:436e:2d61:e925) (Remote host closed the connection)
[13:55:59] *** Joins: VincentVega (~user@212.97.1.105)
[13:58:57] *** Joins: pjb (~pjb@user/pjb)
[14:07:45] <ns12> For making CRUD web apps, is it conventional to use the combination of sbcl, cl-hunchentoot, cl-who, and cl-postmodern?
[14:08:29] <jackdaniel> it is (for many people), except that some libraries doesn't have cl- as the name prefix
[14:11:10] <ns12> Are Lisp web apps typically structured using the MVC pattern? Are there examples?
[14:14:30] *** Joins: cage (~cage@dynamic-adsl-84-221-50-16.clienti.tiscali.it)
[14:15:43] *** Quits: Inline (~Inline@aftr-37-201-240-204.unity-media.net) (Quit: Leaving)
[14:22:52] *** Joins: kevingal (~quassel@149.157.111.113)
[14:31:15] *** Quits: kevingal (~quassel@149.157.111.113) (Ping timeout: 256 seconds)
[14:31:22] *** Joins: kevingal (~quassel@hamilton-nat.nuim.ie)
[14:34:30] *** Quits: Posterdati (~posterdat@host-87-19-166-231.retail.telecomitalia.it) (Quit: KVIrc 5.0.0 Aria http://www.kvirc.net/)
[14:37:18] *** Joins: Lord_of_Life (~Lord@user/lord-of-life/x-2819915)
[14:41:20] <flip214> ns12: well, that architecture is independent of the programming language.
[14:41:20] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[14:41:43] *** Joins: amb007 (~a_bakic@125.36.22.93.rev.sfr.net)
[14:41:48] <flip214> there's the parenscript library - it allows to push (a subset of) CL code as javascript to the client
[14:42:45] <flip214> which is nice for simple checks of input fields; eg. in lisp you'd have (defun check-field (stg) (cl-ppcre:scan "^regex$" stg)) and this snippet can be sent as JS to allow front-end verification without code duplication
[14:47:24] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[14:53:02] *** Quits: Algernon91 (~Algernon6@2a04:cec0:10e5:449e:d488:648c:46b0:f14f) (Ping timeout: 252 seconds)
[14:53:48] *** Joins: _ante_ (~ante@c-e989225c.023-1144-7570702.bbcust.telenor.se)
[14:54:33] *** Joins: Algernon91 (~Algernon6@2a04:cec0:10e5:449e:d488:648c:46b0:f14f)
[14:55:04] *** Quits: amb007 (~a_bakic@125.36.22.93.rev.sfr.net) (Read error: Connection reset by peer)
[14:55:10] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[14:55:43] *** Joins: Posterdati (~posterdat@host-87-19-166-231.retail.telecomitalia.it)
[14:56:42] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[14:56:42] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[14:57:25] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[15:04:57] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[15:05:38] *** Quits: kevingal (~quassel@hamilton-nat.nuim.ie) (Ping timeout: 250 seconds)
[15:05:48] *** Joins: kevingal (~quassel@2001:770:c0:401:c8b5:3649:797d:f4ed)
[15:07:23] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[15:14:11] *** Joins: VincentV` (~user@212.97.1.105)
[15:15:51] *** Quits: VincentVega (~user@212.97.1.105) (Ping timeout: 256 seconds)
[15:22:43] *** Quits: Algernon91 (~Algernon6@2a04:cec0:10e5:449e:d488:648c:46b0:f14f) (Ping timeout: 250 seconds)
[15:23:00] *** Joins: dec0d3r (~dec0d3r@2001:8003:480a:e00:e07:e7c3:7efc:ed0f)
[15:28:54] *** Joins: Algernon91 (~Algernon6@2a04:cec0:10e5:449e:d488:648c:46b0:f14f)
[15:29:46] *** Quits: MajorBiscuit (~MajorBisc@wlan-145-94-216-150.wlan.tudelft.nl) (Quit: WeeChat 3.3)
[15:29:56] *** Joins: MajorBiscuit (~MajorBisc@wlan-145-94-216-150.wlan.tudelft.nl)
[15:32:44] *** erjag is now known as varjag
[15:35:20] *** Joins: mcoll (1cd8fbb055@2604:bf00:561:2000::160)
[15:37:21] *** Joins: nature (~nature@45.32.235.173)
[15:44:01] *** Quits: lispy (~lispy4@84.69.59.93) (Quit: Leaving)
[15:47:42] *** Joins: lisp123 (~lisp123@5.30.23.247)
[15:49:44] *** Parts: pranavats (3fba1d1b34@jabberfr.org) (Error from remote client)
[15:50:02] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[15:52:17] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 256 seconds)
[15:54:39] *** Joins: random-nick (~random-ni@87.116.167.125)
[16:01:07] <ns12> flip214: Is ppcre the only library that can be used in parenscript?
[16:02:29] *** Quits: VincentV` (~user@212.97.1.105) (Ping timeout: 256 seconds)
[16:02:59] *** Joins: lisp123 (~lisp123@5.30.23.247)
[16:04:25] <lisp123> ns12: https://ashok-khanna.medium.com/lisp-the-web-4c00c88d11f9 for a guide
[16:05:32] *** Joins: VincentVega (~user@212.97.1.105)
[16:05:35] <flip214> ns12: also, it's open-source, so you can extend the function set
[16:10:00] <lisp123> Does #+sbcl: work within asdf forms?
[16:11:59] <yitzi> lisp123: Like defsystem?
[16:12:04] <phoe> lisp123: it should, but it shouldn't use it
[16:12:32] <yitzi> Yes, use the feature stuff defined in the manual.
[16:12:39] <phoe> there is syntax for loading particular files if a feature expression succeeds
[16:12:43] <lisp123> yitzi: Yes. phoe: Oh okay
[16:13:00] <lisp123> Oh cool, let me read into that now
[16:13:02] <lisp123> thanks
[16:13:23] <phoe> https://common-lisp.net/project/asdf/asdf.html#if_002dfeature-option
[16:13:57] <lisp123> phoe: Awesome, thanks so much!
[16:19:54] *** Joins: biog (~user1@static.39.160.132.142.clients.your-server.de)
[16:34:38] *** Joins: gamaliel (~gamaliel@24.171.221.75)
[16:38:25] <gamaliel> Hi, common lisp newbie here. I was wondering whether there was a way to evaluate a quoted push statement. For instance, if I write (let ((a nil)) (eval `(push 2 a))), the eval statement fails, as it does not recognize 'a'. How could I express it so that (eval `(push 2 a)) makes a '(2)?
[16:39:25] <phoe> you can't
[16:39:29] <beach> gamaliel: You can't.  Luckily, EVAL does not have access to the lexical environment.  Only to the global environment.
[16:39:51] <phoe> but the more important question is: what are you trying to do?
[16:40:25] <lisp123> To add to that, this will work (for the reasons mentioned above) (let ((a nil)) (declare (special a))(eval `(push 2 a)))
[16:40:42] <lisp123> But do not it of course ;)
[16:40:59] <gamaliel> Ok. I was trying to circumvent a recursion by crafting a nested loop in quotes, but got stuck when I had to do the inside statement which involved push.
[16:41:12] <phoe> circumvent recursion, how exactly?
[16:41:34] <phoe> if anything, you can defer computation using closures, like (let ((a '())) (lambda () (push 2 a) a)) - this returns an anonymous function that repeatedly pushes a 2 into some list, and then returns that list
[16:41:44] <phoe> but I have no idea if that is what you are trying to do
[16:43:58] <rotateq> hi gamaliel
[16:44:51] *** Joins: epolanski (uid312403@id-312403.helmsley.irccloud.com)
[16:45:00] <gamaliel> Ok. I was just seeing if it was possible to generate unevaluated nested loops to create a list of combinations.
[16:47:28] <gamaliel> So, for example, to generate the combinations of 3 elements from {0,1,2,3,4}, I could write (loop for i from 2 below 5 do (loop for j from 1 below i do (loop for k from 0 below j do (list i j k))))
[16:47:49] <beach> Sort of.
[16:48:03] <beach> But `do (list ...)' won't do very much.
[16:48:19] <beach> And you can do that, of course.
[16:48:32] <gamaliel> That's true. But coming up with a way to store it was where I got stumped.
[16:48:32] <beach> You just can't have EVAL access the lexical environment.
[16:48:47] <beach> Why not just return it as a value then.
[16:49:12] <beach> (let ((<mumble> (eval '(loop ....))))) if you need EVAL.
[16:49:36] <phoe> unevaluated nested loops? seems weird
[16:49:44] <phoe> nothing that you'd write in standard Common Lisp
[16:50:09] <phoe> or rather, nothing that you'd commonly encounter in Common Lisp that's written commonly
[16:50:22] <phoe> EVAL is almost never needed, truth be told
[16:50:36] <phoe> (dolist
[16:50:38] <phoe> (oops)
[16:50:52] <gamaliel> Yeah, I'm very new to the language. Just tinkering around some exercise problems I found to practice.
[16:51:13] <phoe> iterating over three variables would be like (dolist (i (iota 5)) (dolist (j (iota 5)) (dolist (k (iota 5)) ...)))
[16:51:30] <phoe> where IOTA is available in the Alexandria library, (ql:quickload :alexandria)
[16:51:47] <phoe> or just (defun iota (n) (loop for i below n collect i))
[16:52:16] <phoe> or even better
[16:52:28] <phoe> (dotimes (i 5) (dotimes (j 5) (dotimes (k 5) ...)))
[16:52:39] <semz> I think he wants the number of variables to be variable
[16:52:46] <phoe> oh, like that
[16:53:19] *** Quits: agrewal (~Aman@cpe-74-68-64-28.si.res.rr.com) (Ping timeout: 256 seconds)
[16:54:35] <gamaliel> That would be correct. I mean, it's quite readily solvable using recursion, but I wanted to challenge myself into the new parts of the language using a way to construct the loops unevaluated and collecting the final call afterwards.
[16:54:46] <gamaliel> *calling
[16:54:52] <phoe> you sound like you want macros
[16:54:58] <phoe> at least, unless the requirement is to stay functional, I'd macro it away - write something that can expand into nested DOLIST or DOTIMES
[16:55:48] <gamaliel> Ok, I will keep trying. Thank you everyone!
[16:55:48] <rotateq> so first learning to use the given macros :)
[16:56:16] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[16:58:07] <phoe> https://plaster.tymoon.eu/view/2865#2865
[16:58:21] *** Joins: s-liao (~s-liao@101.86.96.21)
[16:58:22] <phoe> it's not really customizable at runtime, just syntax sugar over DOLIST
[16:58:35] <phoe> but if you want it to be customizable at runtime then you have a slightly more involved problem to solve
[16:58:47] <phoe> no matter whether you recurse or iterate
[16:59:20] *** Quits: MajorBiscuit (~MajorBisc@wlan-145-94-216-150.wlan.tudelft.nl) (Quit: WeeChat 3.3)
[16:59:29] *** Joins: MajorBiscuit (~MajorBisc@wlan-145-94-216-150.wlan.tudelft.nl)
[17:00:49] <gamaliel> The nested dolist seems like a very doable solution. I can modify it to use loop and it may just expand exactly the way I need it. Thank you!
[17:02:51] <phoe> gamaliel: the general way of thinking in CL is - if you need to operate on something in its raw, unevaluated form, then you most likely need macros
[17:03:28] *** Joins: skeemer (~skeemer@h-158-174-23-219.NA.cust.bahnhof.se)
[17:03:55] <gamaliel> Ok. My experience doing that is limited to simple bquote() statements in R programming language for statistics courses. This will be a good refresher.
[17:07:32] <gamaliel> Something like this could be a start for the solution: https://plaster.tymoon.eu/view/2866#2866
[17:08:12] <phoe> I think you need ,(car end-vals)
[17:08:28] <phoe> but looks OK, even if I'd prepare bindings the other direction
[17:08:41] <phoe> as in, group each var and start-val and end-val together
[17:08:44] <phoe> but that's just syntax sugar
[17:09:23] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[17:09:55] *** Joins: agrewal (~Aman@cpe-74-68-64-28.si.res.rr.com)
[17:10:13] <gamaliel> Ok. I just planned to use it as an internal template. Recursive macros are really mind-boggling for someone who has only programmed in other languages.
[17:10:33] *** Quits: gamaliel (~gamaliel@24.171.221.75) (Quit: Client closed)
[17:10:55] *** Joins: gamaliel (~gamaliel@24.171.221.75)
[17:11:10] <phoe> recursion is recursion - remember to check your termination conditions, and try to expand your macros one step at a time
[17:11:32] <gamaliel> phoe: thank you very much for your help.
[17:11:38] <phoe> macro writing is basically writing pure functions that transform one soup of conses and symbols into another soup of conses and symbols
[17:13:55] <gamaliel> I have to go, thank you all for your answers and help. Have an excellent day.
[17:14:16] *** Parts: gamaliel (~gamaliel@24.171.221.75) ()
[17:16:18] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[17:19:37] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[17:20:46] *** Quits: kevingal (~quassel@2001:770:c0:401:c8b5:3649:797d:f4ed) (Ping timeout: 245 seconds)
[17:22:00] <ns12> Which computer architecture is best for Lisp? x86, ARM, or RISC-V?
[17:22:58] <Xach> yes
[17:23:23] <rotateq> :D
[17:23:32] <empwilli> (please someone say lisp machine)
[17:23:39] <rotateq> ns12: it's not just as special purpose in hardware terms as say C :)
[17:24:30] <Xach> empwilli: rainer joswig has a funny post about running lisp on his macbook air m1 6000x faster than his symbolic hardware, and consuming 6 watts vs 1KW for symboilcs
[17:24:44] *** Joins: s-liao (~s-liao@101.86.96.21)
[17:24:46] * Xach cannot spell symbolics today
[17:24:59] <jackdaniel> symbollocks
[17:25:01] <empwilli> :)
[17:27:46] *** Quits: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 250 seconds)
[17:27:49] <ns12> Xach: High energy use means that you are doing more work.
[17:29:48] *** Joins: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[17:29:52] <rotateq> ehm :D
[17:32:00] *** Joins: Bike (~Glossina@71.69.170.70)
[17:32:00] *** ChanServ sets mode: +o Bike
[17:34:41] <Bike> ::notify pillton "I think there should be another operator or operators introduced which either avoid using AREF or ensure that every call to AREF does not require checking its arguments." what do you mean?
[17:34:41] <Colleen> Bike: Got it. I'll let pillton know as soon as possible.
[17:34:47] *** Joins: kevingal (~quassel@2001:770:c0:401:c8b5:3649:797d:f4ed)
[17:38:10] *** Quits: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 250 seconds)
[17:40:10] *** Joins: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[17:47:51] *** Joins: raeda (~raeda@72.49.214.135)
[17:48:52] <beach> ns12: Lisp works fine on pretty much any modern architecture.
[17:51:36] *** Quits: MajorBiscuit (~MajorBisc@wlan-145-94-216-150.wlan.tudelft.nl) (Ping timeout: 250 seconds)
[17:51:56] <beach> ns12: What is the reason for your question?
[17:55:49] *** Quits: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 256 seconds)
[17:57:31] *** Joins: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[18:01:34] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 250 seconds)
[18:02:48] *** Joins: MajorBiscuit (~MajorBisc@wlan-145-94-216-150.wlan.tudelft.nl)
[18:07:43] *** Quits: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 256 seconds)
[18:08:53] *** Joins: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[18:11:05] *** Joins: ec (~ec@gateway/tor-sasl/ec)
[18:12:21] *** Joins: VincentV` (~user@212.97.1.105)
[18:13:32] *** Quits: s-liao (~s-liao@101.86.96.21) (Quit: Client closed)
[18:13:47] *** Quits: VincentVega (~user@212.97.1.105) (Ping timeout: 256 seconds)
[18:22:45] <ns12> beach: I'm planning to learn an architecture in more detail. Just wondering if there is anything that's better for Lisp.
[18:25:22] <beach> I recommend you learn RISC-V.  Not particularly for Lisp, but because it is clean and it could very well become widespread.
[18:27:27] <Bike> i mean, what did lisp machines have that was so great for lisp? 36 bit registers so you could store a 32 bit integer with tag? everything's 64 bit now anyway
[18:28:01] <Bike> i wouldn't be surprised if some architecture changes could make things easier for lisp, but as far as i can tell it's not a huge deal
[18:28:09] <semz> parallel type/bounds checks come to mind
[18:28:30] <semz> I also seem to recall some hardware support for GC, but don't remember any details
[18:29:05] *** Quits: agrewal (~Aman@cpe-74-68-64-28.si.res.rr.com) (Ping timeout: 256 seconds)
[18:29:12] <Bike> "parallel type/bounds checks"?
[18:29:55] *** Joins: Devon (~devon@c-24-2-157-5.hsd1.ma.comcast.net)
[18:32:27] *** Quits: dec0d3r (~dec0d3r@2001:8003:480a:e00:e07:e7c3:7efc:ed0f) (Quit: Leaving)
[18:33:09] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[18:37:35] *** Quits: Devon (~devon@c-24-2-157-5.hsd1.ma.comcast.net) (Ping timeout: 256 seconds)
[18:39:55] <semz> As in, they're performed while the actual computation is done, so that a successful check doesn't come with a performance penalty
[18:42:03] <Bike> what would be an example?
[18:45:52] <semz> On a current machine, e.g. an unchecked array access is faster than a checked array access, even if the index lies within bounds, because the check comes before the access. Iirc on a Symbolics, both would be performed in parallel, and if the index lies in bounds, things would just carry on as if the check never happened.
[18:46:21] <semz> So there is no reason to elide them
[18:46:44] <Bike> so, what, no possibility of a memory fault or anything?
[18:48:35] <semz> I don't know about "no possibility", but significantly reduced risk for sure.
[18:48:38] *** Joins: jealousmonk (~user@2804:431:e7c5:b880:889f:205:ed34:5b22)
[18:53:20] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[18:59:17] *** Quits: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 256 seconds)
[19:01:10] *** Joins: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[19:05:01] <lisp123> When I paste into plaster.tymoon.eu, the indenting is all wrong. But in Emacs / GitHub, it is fine. Does anybody know the setting to fix this?
[19:05:47] <lisp123> Its either something to do with spaces/tabs or some sort of hidden / incorrect space characters on my end
[19:06:24] <semz> Is it correct when you open the raw view? Might be your browser collapsing spaces. Lisp code usually is spaces-only so I doubt it's tabs.
[19:06:40] <phoe> lisp123: untabify your buffers
[19:06:48] <phoe> and/or teach your emacs to do it on its own
[19:07:54] <lisp123> semz: Yes, its fine in raw
[19:08:15] <lisp123> phoe: Thanks, will try that
[19:10:14] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[19:15:29] *** Joins: Devon (~devon@c-24-2-157-5.hsd1.ma.comcast.net)
[19:16:00] *** Joins: euandreh (~euandreh@2804:14c:33:9fe5:6113:2671:c33c:ef4a)
[19:17:53] *** Quits: semz (~semz@user/semz) (Remote host closed the connection)
[19:18:16] *** Quits: Cymew (~ante@c-e989225c.023-1144-7570702.bbcust.telenor.se) (Ping timeout: 250 seconds)
[19:19:17] *** Joins: semz (~semz@2001:9e8:4bc3:b800:ad17:5967:d69a:4e63)
[19:19:18] *** Quits: semz (~semz@2001:9e8:4bc3:b800:ad17:5967:d69a:4e63) (Changing host)
[19:19:18] *** Joins: semz (~semz@user/semz)
[19:20:49] *** Quits: aartaka (aartaka@gateway/vpn/protonvpn/aartaka) (Ping timeout: 256 seconds)
[19:21:06] *** Joins: aartaka (aartaka@gateway/vpn/protonvpn/aartaka)
[19:29:17] *** Quits: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 240 seconds)
[19:31:38] *** Joins: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[19:32:18] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[19:32:56] <lisp123> phoe: Thanks..got there in the end with untabbify. What a stupid default for Emacs
[19:32:57] <rotateq> hehe in another german channel on libera with mostly also autistic/asperger people i sometimes express things in CL code and now some girl asked what i would would speak: "elisp?" :D no ANSI CL it is with full steam! even not write, but THINK in it
[19:33:08] *** Quits: mgl (~mgl@cpc87455-finc19-2-0-cust234.4-2.cable.virginm.net) (Ping timeout: 256 seconds)
[19:36:11] <lisp123> rotateq: That's the way! ANSI compliant thoughts ;)
[19:37:12] <rotateq> The way of Mandalor.
[19:37:21] <ns12> rotateq: ooo... What channel is that?
[19:37:21] <edgar-rft> emacs sucks because it forces us to learn things
[19:37:42] <rotateq> ns12: #autistenchat is the main one and often much fun and wonderful people
[19:38:14] <rotateq> edgar-rft: again, you bring it wisely to the point (now i hide from the ontopic police)
[19:46:56] <Josh_2> edgar-rft: You joke but this really is a massive barrier to entry for people :facepalm:
[19:49:05] <beach> Yeah, we wouldn't want people to have to learn things, now would we?
[19:50:38] <lisp123> Josh_2: Emacs is a very good excuse for Lispers not actually doing work :D
[19:51:39] <Josh_2> beach: apparently not. People seem to get very upset when someone says "uh if you cant learn emacs how are you gonna learn lisp?"
[19:52:27] *** Joins: waleee (~waleee@2001:9b0:21d:fc00:398f:b003:b90d:acf4)
[19:54:50] <lisp123> Josh_2: I find its always a similar type of complainer. (1) Emacs, (2) Standard not updated, (3) GUI, (4) Some random obscure detail, (5) etc. I don't think beginners actually complain that much, but its just the similar type who rather make excuses than actually program
[19:55:20] <Josh_2> Something like that, at the end of the day it seems to boil down to not liking the parens
[19:55:54] <Josh_2> seems to me that its easier to evangelize to people who have never written code but wish to learn, I had this experience yesterday irl
[19:56:53] <Bike> i don't think it's unreasonable to want to use an editor you're familiar with. if someone told me i had to use some specific program to use haskell i'd certainly be less inclined to learn and use haskell.
[19:56:58] <lisp123> Yeah, exactly. Its something to do with Lisp, because as far as I can tell from reading historic sources, this was an issue since the 90s
[19:57:45] <lisp123> For some reason it attracts this certain type of individual as well (apart from all the good and productive lispers out there)
[19:57:47] <Alfr> rotateq, lisp123 what, no mop?
[19:58:48] <lisp123> Bike: But VSCode / Atom has a Lisp plugin. And most IDEs take time to get used to. And there is always LW personal edition for those who want something more 'modern' in terms of keybindings
[19:59:35] <Bike> i was referring to "uh if you can't learn emacs how are you gonna learn lisp"
[20:00:35] <semz> "but can it do games?!"
[20:01:16] <Bike> if you can write lisp in something else, great. but condescending to someone who doesn't want to learn a new editor on top of a new language is silly.
[20:01:25] <lisp123> Swift requires Xcode, I (assume) Java is best done in JetBrains, most Microsoft languages (assuming again) are done in Visual Studio ~shrugs~
[20:03:28] <semz> I don't think anyone does Java in a raw text editor, it's miserable.
[20:04:28] <aeth> depends on if it's your own code or someone else's
[20:04:40] <lagash> semz: I used to, over a decade ago..
[20:04:45] <aeth> Java isn't THAT bad, it's the style people use in it
[20:04:56] <aeth> obligatory https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition
[20:06:03] <lisp123> Bike: I don't think people say that comment to beginners, if so, yes its not good to be condescending
[20:06:20] <aeth> I'm sure you could write CL where M-. and autocomplete are mandatory
[20:06:26] <aeth> they're just rare
[20:08:17] <aeth> maybe the equivalent would be macro-heavy code where you basically need to expand macros to see what's going on
[20:08:36] <Josh_2> Bike: yes but if that editor is VSC, they can get bent imo
[20:12:21] *** Joins: sloanr (~user@97-127-122-25.mpls.qwest.net)
[20:12:52] <sveit_> XB
[20:13:11] *** Joins: notzmv (~zmv@user/notzmv)
[20:13:18] *** Quits: _ante_ (~ante@c-e989225c.023-1144-7570702.bbcust.telenor.se) (Ping timeout: 250 seconds)
[20:16:12] *** Joins: cosimone` (~user@93-44-186-159.ip98.fastwebnet.it)
[20:18:10] *** Quits: Algernon91 (~Algernon6@2a04:cec0:10e5:449e:d488:648c:46b0:f14f) (Read error: Connection reset by peer)
[20:18:25] *** Joins: Algernon91 (~Algernon6@2a01:e0a:511:6ce0:edf5:da40:98ab:ea5e)
[20:19:22] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Ping timeout: 250 seconds)
[20:19:41] *** Quits: NotThatRPG_away (~NotThatRP@162-219-230-90.fttp.usinternet.com) (Read error: Connection reset by peer)
[20:21:06] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[20:22:40] *** Joins: Guest74 (~Guest74@modemcable110.164-177-173.mc.videotron.ca)
[20:25:16] *** Joins: asarch (~asarch@2806:10ae:7:9368:d6a5:a45a:93c6:c233)
[20:27:31] *** Quits: aartaka (aartaka@gateway/vpn/protonvpn/aartaka) (Ping timeout: 256 seconds)
[20:28:49] *** Quits: sloanr (~user@97-127-122-25.mpls.qwest.net) (Remote host closed the connection)
[20:29:02] *** Joins: sloanr (~user@97-127-122-25.mpls.qwest.net)
[20:29:06] *** Joins: aartaka (aartaka@gateway/vpn/protonvpn/aartaka)
[20:30:04] *** Quits: Algernon91 (~Algernon6@2a01:e0a:511:6ce0:edf5:da40:98ab:ea5e) (Ping timeout: 268 seconds)
[20:30:21] *** Quits: monaaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 256 seconds)
[20:30:51] *** Joins: Catie (~user@user/catie)
[20:32:23] *** Joins: morganw (~user@80.225.24.132)
[20:35:48] *** Quits: MajorBiscuit (~MajorBisc@wlan-145-94-216-150.wlan.tudelft.nl) (Quit: WeeChat 3.3)
[20:36:31] *** Quits: lisp123 (~lisp123@5.30.23.247) (Quit: Leaving...)
[20:38:02] *** Joins: johnjaye (~pi@154.6.152.74)
[20:44:12] *** Joins: Algernon91 (~Algernon6@2a01:e0a:511:6ce0:edf5:da40:98ab:ea5e)
[20:44:31] *** Quits: epolanski (uid312403@id-312403.helmsley.irccloud.com) (Quit: Connection closed for inactivity)
[20:44:43] *** Quits: gxt (~gxt@gateway/tor-sasl/gxt) (Remote host closed the connection)
[20:45:02] *** Joins: gxt (~gxt@gateway/tor-sasl/gxt)
[20:46:13] *** Quits: nature (~nature@45.32.235.173) (Quit: Lost terminal)
[20:48:42] *** Parts: ori (~atdt@user/ori) (WeeChat 3.3)
[20:53:13] *** Joins: domovod (~domovod@176.196.122.197)
[21:00:34] <Josh_2> Oops, having that annoying problem with connecting to my remote lisp, I remember writing the solution in here but now looking through the logs I cannot find
[21:04:46] <luis> https://github.com/commonqt/commonqt5 lives. Just in time for Qt6.
[21:06:09] <luis> not yet as plug-and-play as the original commonqt was, since there's no precompiled binaries available yet.
[21:06:14] * luis eyes Shinmera 
[21:06:53] <Josh_2> I knew when I updated my lisp I would have this problem
[21:08:50] <phoe> I might be able to help with building on Linux
[21:08:54] * phoe adds to his pile of TODOs
[21:10:01] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[21:13:52] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[21:14:26] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[21:16:15] *** Joins: MichaelRaskin (~MichaelRa@ipb21a9944.dynamic.kabel-deutschland.de)
[21:16:15] *** ChanServ sets mode: +o MichaelRaskin
[21:17:43] *** Quits: Lord_Nightmare (~Lord_Nigh@user/lord-nightmare/x-3657113) (Read error: Connection reset by peer)
[21:17:54] *** Joins: dra (~dra@2a04:4540:6409:9600:3465:7864:114:561c)
[21:18:53] *** Quits: Jing (~hedgehog@240e:390:7c53:a7e1:87f:3f13:7a62:d6c7) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[21:19:31] *** Joins: Lord_Nightmare (~Lord_Nigh@user/lord-nightmare/x-3657113)
[21:31:06] *** Joins: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz)
[21:31:10] *** Quits: triffid (~triffid@gateway/tor-sasl/triffid) (Quit: triffid)
[21:34:15] *** Parts: thomaslewis (6e04fe5c02@mail.nobodyhasthe.biz) ()
[21:43:52] *** Quits: VincentV` (~user@212.97.1.105) (Ping timeout: 250 seconds)
[21:49:40] *** Joins: NotThatRPG (~NotThatRP@162-219-230-90.fttp.usinternet.com)
[21:51:32] *** Joins: jeosol (~jeosol@user/jeosol)
[21:58:39] <Guest74> my only problem with people saying use emacs for common lisp because it 'indents properly' is that you get a rude awakening when pasting stuff because emacs by default does not indent CL properly since it sticks in a bunch of tabs.
[21:59:05] <phoe> yes, and it greatly displeases me
[22:01:02] <aeth> It also doesn't indent properly without SLIME, and without the libraries in question loaded into an active SLIME REPL
[22:01:16] <aeth> because it uses some things like the distinction between &rest and &body to inform its indentation
[22:01:46] <aeth> and without loading the library, it's going to assume that the macro is a function unless it's a COMMON-LISP built-in
[22:01:51] *** Quits: cosimone` (~user@93-44-186-159.ip98.fastwebnet.it) (Remote host closed the connection)
[22:02:18] *** Joins: cosimone (~user@93-44-186-159.ip98.fastwebnet.it)
[22:02:32] <aeth> Forgot to Quickload it before modifying it? Well, that means that you've just messed up your file's indentation.
[22:03:22] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Ping timeout: 250 seconds)
[22:03:47] *** Joins: amb007 (~a_bakic@108.36.22.93.rev.sfr.net)
[22:04:05] *** Joins: thomp (~thomp@162.212.34.219)
[22:23:23] <Guest74> phoe: if I steal your rotation stuff you did for imago what would be the best way to credit you?  Mind you I still haven't looked at it.
[22:24:17] <phoe> Guest74: Michał "phoe" Herda <phoe@disroot.org> is good enough
[22:25:17] <Guest74> I guess I can stick that in the commit message?  It seems like a comment in code isn't sufficient attribution, at least in my mind.
[22:25:24] *** Joins: lisp123 (~lisp123@5.30.23.247)
[22:25:33] <phoe> why not both~
[22:26:17] <phoe> also be cautious not to take too much imago code along the way if your code isn't LLGPL
[22:27:01] *** Quits: Algernon91 (~Algernon6@2a01:e0a:511:6ce0:edf5:da40:98ab:ea5e) (Ping timeout: 245 seconds)
[22:27:12] <Guest74> yes, I'll do both.  I guess I should probably have asked a more git specific method of attributing a commit to someone else.  Though I'll probably have to change the code somewhat as all my stuff uses linear arrays.
[22:27:12] *** Quits: Noisytoot (~noisytoot@sourcehut/user/noisytoot) (Quit: ZNC 1.8.2 - https://znc.in)
[22:27:43] <asarch> Any way to render bar and qr codes?
[22:27:50] <Guest74> rotations is the only thing I don't have(besides 90 degree rotations/mirroring), and everything is lgpl.
[22:27:53] <phoe> Guest74: sure, just modify the accessors
[22:31:00] <Guest74> just took a look, looks like I can just change a few function names and it should work as is.
[22:31:23] <phoe> yes
[22:32:06] <yitzi> asarch: There is at least one qr code encoder in quicklisp.
[22:32:23] <Guest74> anyways, thanks, one less thing to do myself.
[22:32:56] <yitzi> asarch: cl-qrencode and lispqr
[22:33:07] <asarch> Thank you! Thank you very much! :-)
[22:33:08] <phoe> Guest74: remember to grab the updated code from imago and not from my commit, there were some fixes made later on
[22:34:28] <Guest74> will do.
[22:46:49] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[22:47:43] *** Quits: kevingal (~quassel@2001:770:c0:401:c8b5:3649:797d:f4ed) (Remote host closed the connection)
[22:48:02] *** Joins: lisp123 (~lisp123@5.30.23.247)
[22:52:24] *** Joins: agrewal (~Aman@cpe-74-68-64-28.si.res.rr.com)
[22:55:51] *** Joins: Inline (~Inline@aftr-37-201-240-204.unity-media.net)
[22:57:06] *** Quits: agrewal (~Aman@cpe-74-68-64-28.si.res.rr.com) (Client Quit)
[22:57:07] *** Quits: amb007 (~a_bakic@108.36.22.93.rev.sfr.net) (Read error: Connection reset by peer)
[22:57:41] *** Joins: amb007 (~a_bakic@102.215.76.86.rev.sfr.net)
[22:58:38] *** Quits: Inline (~Inline@aftr-37-201-240-204.unity-media.net) (Client Quit)
[22:58:57] *** Quits: Guest74 (~Guest74@modemcable110.164-177-173.mc.videotron.ca) (Quit: Connection closed)
[23:00:05] *** Joins: Inline (~Inline@aftr-37-201-240-204.unity-media.net)
[23:01:21] *** Joins: gaqwas (~john@dynamic-095-114-023-134.95.114.pool.telefonica.de)
[23:02:06] <rotateq> semz: no java in vim?
[23:02:18] <semz> I've done it once
[23:02:22] <semz> never again
[23:02:27] <rotateq> i would do it too :)
[23:02:50] <rotateq> and then also never again, java i mean
[23:02:57] *** Quits: domovod (~domovod@176.196.122.197) (Ping timeout: 256 seconds)
[23:06:47] <Josh_2> Where is the best definition of image based programming?
[23:07:00] <Josh_2> I used to use http://wiki.c2.com/?ImageBasedLanguage but the site appears to be dead :cry:
[23:07:13] <moon-child> works for me
[23:07:41] <moon-child> website started doing some kind of weird js rendering at one point
[23:09:27] <Josh_2> huh
[23:14:12] <_death> https://wiki.kluv.in/
[23:14:57] <_death> can also download it via the gitlab repo
[23:15:48] <Josh_2> Well
[23:15:53] <Josh_2> The search isn't working
[23:16:16] <_death> right.. https://wiki.kluv.in/a/ImageBasedLanguage
[23:16:33] <Josh_2> Thanks :)
[23:17:13] <Josh_2> Finally managed to find my note to my future self from 6 months ago in the IRC logs
[23:17:31] <Josh_2> Sunday 5th of September
[23:17:52] *** Joins: karlosz (~karlosz@47.151.136.69)
[23:20:42] *** Quits: gaqwas (~john@dynamic-095-114-023-134.95.114.pool.telefonica.de) (Remote host closed the connection)
[23:20:43] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[23:24:17] *** Quits: thomp (~thomp@162.212.34.219) (Ping timeout: 240 seconds)
[23:26:43] <Josh_2> And ofcourse I followed the instructions I left myself and it didn't work
[23:26:46] <Josh_2> :facepalm:
[23:30:46] *** Joins: Oladon (~olad@98.43.81.226)
[23:30:59] *** Joins: Algernon91 (~Algernon6@2a01:e0a:511:6ce0:edf5:da40:98ab:ea5e)
[23:31:01] *** Joins: Noisytoot (~noisytoot@sourcehut/user/noisytoot)
[23:31:21] *** Joins: nij- (~jin@2001-48F8-9021-806-0-0-0-619B-dynamic.midco.net)
[23:32:50] <nij-> Hi! I'm using sly in emacs. However, its completion doesn't work. When I do M-x sly-next-completion, a message says "No buffer named *sly-completion*." Anyone had this issue before?
[23:34:13] <nij-> sly-symbol-completion-mode is on btw.
[23:35:25] *** Quits: Algernon91 (~Algernon6@2a01:e0a:511:6ce0:edf5:da40:98ab:ea5e) (Ping timeout: 240 seconds)
[23:35:32] <Josh_2> Okay finally fixed it
[23:39:30] *** Quits: sloanr (~user@97-127-122-25.mpls.qwest.net) (Remote host closed the connection)
[23:39:43] *** Joins: sloanr (~user@97-127-122-25.mpls.qwest.net)
[23:45:37] *** Quits: johnjaye (~pi@154.6.152.74) (Quit: WeeChat 3.3)
[23:50:31] *** Quits: karlosz (~karlosz@47.151.136.69) (Quit: karlosz)
[23:52:35] *** Joins: _ante_ (~ante@c-e989225c.023-1144-7570702.bbcust.telenor.se)
[23:59:41] *** Quits: sloanr (~user@97-127-122-25.mpls.qwest.net) (Remote host closed the connection)
[23:59:55] *** Joins: sloanr (~user@97-127-122-25.mpls.qwest.net)
