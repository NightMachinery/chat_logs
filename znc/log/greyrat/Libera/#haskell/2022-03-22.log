[01:00:55] <tomsmeding> maerwald: minor side-comment about code.world, with the ddg browser extension it fails to do anything useful (shows a <textarea> and not much more)
[01:01:24] *** Quits: bahamas (~lucian@84.232.140.158) (Ping timeout: 252 seconds)
[01:01:48] *** Quits: drdo (~drdo@roach0.drdo.eu) (Quit: The Lounge - https://thelounge.chat)
[01:02:46] *** Quits: k8yun (~k8yun@user/k8yun) (Quit: Leaving)
[01:02:52] *** Joins: drdo (~drdo@roach0.drdo.eu)
[01:03:16] <tomsmeding> maerwald: re pastebin, sounds interesting and cool, though not sure I'd have the time to implement that
[01:04:25] *** Quits: jiribenes (~jiribenes@rosa.jiribenes.com) (Ping timeout: 250 seconds)
[01:04:42] *** Quits: lechner (~lechner@debian/lechner) (Ping timeout: 252 seconds)
[01:06:04] *** Quits: acidsys (~LSD@2a03:4000:55:d20::3) (Excess Flood)
[01:06:35] *** Joins: acidsys (~LSD@2a03:4000:55:d20::3)
[01:07:12] <maerwald> I think the backend should be easy. Bubblewrap cleans up after the process exits. So it seems like the right fit.
[01:08:20] <maerwald> is it possible with TH to cause compilation loops?
[01:08:37] *** Quits: foul_owl (~kerry@23.82.193.87) (Ping timeout: 240 seconds)
[01:08:46] *** Quits: dhouthoo (~dhouthoo@178-117-36-167.access.telenet.be) (Quit: WeeChat 3.4)
[01:09:13] *** Quits: javiergarea (~javiergar@62.83.194.64.dyn.user.ono.com) (Quit: Client closed)
[01:09:36] <tomsmeding> yes
[01:09:44] <tomsmeding> % :set -XTemplateHaskell
[01:09:45] <yahb> tomsmeding: 
[01:09:48] <tomsmeding> % import Language.Haskell.TH
[01:09:48] <yahb> tomsmeding: 
[01:09:50] <tomsmeding> % $(VarE <$> newName (let loop = loop in loop))
[01:09:55] <yahb> tomsmeding: [Timed out]
[01:10:28] *** Joins: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl)
[01:11:22] *** Quits: mc47 (~mc47@xmonad/TheMC47) (Remote host closed the connection)
[01:16:45] <tomsmeding> maerwald: https://wiki.archlinux.org/title/Bubblewrap claims that bubblewrap doesn't fully protect the machine from malicious code
[01:17:34] <maerwald> that's specific to X11 it seems
[01:18:09] <maerwald> I mean yeah... if you expose the docker socket into a bubblewrap chroot, you're done as well
[01:18:11] <tomsmeding> the "like" in "like the X11 window system" makes me nervous though
[01:18:18] <tomsmeding> yeah lol
[01:18:36] <tomsmeding> ah I see
[01:18:48] <tomsmeding> so with a tiny enough chroot, it should be fine
[01:19:17] <maerwald> and then run this crap on some HF paid cloud where no one needs to deal with DoS 
[01:19:24] <tomsmeding> heh yeah
[01:19:47] <tomsmeding> DoS is going to be a problem anyway, but less bad than exploiable holes
[01:20:32] *** Joins: pavonia (~user@user/siracusa)
[01:23:52] *** Joins: foul_owl (~kerry@174-21-69-110.tukw.qwest.net)
[01:24:14] <maerwald> send a key-value pair or some dumb machine-parsable challenge on first POST request?
[01:24:15] *** Quits: Pickchea (~private@user/pickchea) (Quit: Leaving)
[01:25:10] <tomsmeding> what would that do, make the DoS script somewhat more complicated?
[01:25:49] <maerwald> no, just prevent trash posts firing through to the ghc process
[01:25:58] <maerwald> if someone targets the backend, they'll find a way anyway
[01:26:10] <tomsmeding> ah, good point, that's actually useful
[01:26:52] <maerwald> could embed a secret in the frontend, but then you can just use a selenium script :p
[01:27:25] <tomsmeding> I know a website that does that, and indeed we worked around that using a browser control script ;p
[01:27:33] <tomsmeding> fun times
[01:28:54] <sm> lol
[01:29:19] <sm> I see you wearing a MHGA hat  maerwald
[01:30:35] *** Joins: werneta (~werneta@70-142-214-115.lightspeed.irvnca.sbcglobal.net)
[01:30:40] <tomsmeding> I encourate you to do a web search on "MHGA" and amuse yourself with the variety of completely unrelated hits you get
[01:30:45] <tomsmeding> *encourage
[01:30:51] <maerwald> sm: repl.it is open source?
[01:31:44] <sm> I don't think so but I wouldn't rule it out
[01:33:18] <sm> bits of it are at least: https://github.com/replit
[01:33:30] <[exa]> repl.it has lots of components out except AFAIK the actual main web frontend integration
[01:33:41] <maerwald> I think it has way more features than what I'm interested in
[01:33:57] <maerwald> and doesn't have those I am interested in
[01:33:59] <[exa]> there's the docker wrapper for executing the replits
[01:34:05] <maerwald> (selecting the ghc version)
[01:34:40] *** Quits: hgolden (~hgolden2@cpe-172-114-81-123.socal.res.rr.com) (Remote host closed the connection)
[01:34:43] <maerwald> seems like a different use case to me than a simple rust like playground
[01:35:17] <sm> that's why I'm asking for your use cases/objectives on the issue, it helps everyone see what will work best
[01:36:33] *** Joins: hgolden (~hgolden2@cpe-172-114-81-123.socal.res.rr.com)
[01:36:35] *** Quits: mikoto-chan (~mikoto-ch@213.177.151.239) (Ping timeout: 252 seconds)
[01:36:40] <sm> I mentioned repl.it just in case could fit the need, even in the short term, since it exists and that would free up a lot of time and energy for the next task
[01:37:49] <sm> but maybe code.world even more so
[01:38:43] <sm> what's your goal with providing all GHC versions ?
[01:39:09] <sm> because that seems in tension with "simple backend"
[01:39:31] *** Quits: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl) (Ping timeout: 245 seconds)
[01:39:59] <sm> for testing compatibility of code snippets, troubleshooting etc. ?
[01:40:12] <tomsmeding> I'm not sure providing multiple versions of ghc is really the most difficult part of building such a thing
[01:40:14] <maerwald> sm: I think it is simple to implement
[01:40:27] <tomsmeding> assuming you're not talking about ghc 5.1 or something, just the easily installable ghcup versions
[01:40:46] <sm> ok, it sounded difficult for code world at least
[01:40:55] <maerwald> sm: they have different feature sets as well
[01:41:01] <maerwald> they need ghcjs, libraries etc.
[01:41:12] <maerwald> we don't need ghcjs
[01:41:47] <sm> I'll try to refrain from further brainstorming until I understand your use cases / end goals 
[01:41:47] <maerwald> so I'd just copy the API how cdsmith described it
[01:42:02] <maerwald> sm: https://play.rust-lang.org/ :p
[01:42:12] <maerwald> that to me is the right feature set
[01:42:14] <sm> why ? :)
[01:42:15] <maerwald> and presentation
[01:42:15] <geekosaur> I went looking for the source to yahb and didn't find it immediately. had a URL once but suspect it's on the dead HD :(
[01:42:25] <sm> right for what ?
[01:42:43] <tomsmeding> geekosaur: are you saying that yahb is running but source is gone?
[01:42:53] <maerwald> sm: sharing some code you can run, e.g. advent of code, a simple problem etc.
[01:43:17] <maerwald> repl.it was always broken on my mobile, something with the input
[01:43:28] <geekosaur> just saying I can't find it now
[01:44:06] <maerwald> sm: I might also steal ideas from plutus playground :p
[01:44:08] <maerwald> https://playground.plutus.iohkdev.io/
[01:44:12] <sm> ok, so like a superpastebin/jsfiddle .. that just works, and is community managed so responsive to our needs, and prominently located so people will actually find and use it.. and why multiple GHC versions ? well never mind, sounds great
[01:44:43] <sm> +1
[01:45:00] <geekosaur> actually it seems to be https://github.com/mniip/xsBot
[01:45:12] *** Joins: grimey (~grimey@pool-108-26-35-23.syrcny.east.verizon.net)
[01:45:45] <monochrom> A long time ago I used chrisdone's https://tryhaskell.org/ . It also has a web API, I have a usage example at view-source:https://www.vex.net/~trebla/haskell/testbed.cgi
[01:45:57] <geekosaur> I'm not sure multiple versions is actually necessary, we don'tchange *quite* as quickly as rust
[01:46:03] <sm> (https://playground.plutus.iohkdev.io doesn't work in safari..)
[01:46:33] <geekosaur> oh. I meant the url was on the dead HD
[01:46:36] <geekosaur> yahb isn't mine
[01:46:42] <monochrom> (Hell, https://www.haskell.org/ uses it too :) )
[01:47:16] <geekosaur> its sandbox appears to be one of mniip'sother repos
[01:47:36] <sm> monochrom: I was assuming that's the thing currently on haskell.org front page, that maerwald has rejected as too basic.. is it not ?
[01:47:39] <janus> monochrom: it keeps saying 'waiting'
[01:47:45] <monochrom> Ah OK.
[01:48:04] <janus> aaah it is blocked because of strict origin policy
[01:48:31] <sm> I guess that is it. I think that gizmo is very cool and should be kept, perhaps expanded
[01:48:41] <monochrom> I just mean if you can find its source code, it may be a good starting point for building your own.
[01:48:44] <maerwald> sm: and then ideally it would integrate with paste.tomsmeding.com
[01:48:58] <sm> sounds good
[01:52:14] *** Joins: Guest50 (~Guest50@p435057.gifunt01.ap.so-net.ne.jp)
[01:52:36] *** Quits: fendor (~fendor@91.141.35.69.wireless.dyn.drei.com) (Remote host closed the connection)
[01:52:42] *** Quits: Guest50 (~Guest50@p435057.gifunt01.ap.so-net.ne.jp) (Client Quit)
[01:52:55] *** Joins: fendor (~fendor@91.141.35.69.wireless.dyn.drei.com)
[01:59:01] *** Quits: mud (~mud@user/kadoban) (Ping timeout: 240 seconds)
[01:59:32] *** Quits: moet (~moet@mobile-166-170-43-26.mycingular.net) (Ping timeout: 240 seconds)
[02:01:00] *** Quits: machinedgod (~machinedg@24.105.81.50) (Ping timeout: 240 seconds)
[02:01:19] *** Joins: moet (~moet@mobile-166-177-250-99.mycingular.net)
[02:02:51] *** Joins: lottaquestions (~nick@2607:fa49:5041:a200:746b:7a76:5f:680b)
[02:08:33] *** Quits: sammelweis (~quassel@2601:401:8200:2d4c:bd9:d04c:7f69:eb10) (Ping timeout: 256 seconds)
[02:09:39] *** Quits: zincy_ (~zincy@2a00:23c8:970c:4801:a9ba:a14e:e332:b83f) (Remote host closed the connection)
[02:10:21] *** Joins: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net)
[02:12:32] *** ec_ is now known as ec
[02:12:35] *** Quits: wyrd (~wyrd@gateway/tor-sasl/wyrd) (Ping timeout: 240 seconds)
[02:12:48] <[itchyjunk]> Hm, is there a hard coded PI in ghci somewhere? i need a 25 digit excpansion of pi :x
[02:13:10] *** Joins: sammelweis (~quassel@2601:401:8200:2d4c:bd9:d04c:7f69:eb10)
[02:13:51] <geekosaur> % :info pi
[02:13:52] <yahb> geekosaur: type Floating :: * -> Constraint; class Fractional a => Floating a where; pi :: a; ...; -- Defined in `GHC.Float'
[02:13:54] <tomsmeding> [itchyjunk]: in what data type were you planning to store that
[02:14:02] <tomsmeding> > pi :: Double
[02:14:04] <lambdabot>  3.141592653589793
[02:14:21] <geekosaur> so it fits the type, which must have a Floating instance. neither Float nor Double will do for 25 digits
[02:14:33] <geekosaur> > pi :: CReal
[02:14:34] <lambdabot>  3.1415926535897932384626433832795028841972
[02:14:50] <geekosaur> note that CReal is *slow*
[02:15:00] <tomsmeding> oh is that the computable reals thing?
[02:15:01] *** Quits: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net) (Ping timeout: 256 seconds)
[02:15:03] <geekosaur> yes
[02:15:15] <geekosaur> default is 50 digits precision iirc
[02:15:15] <tomsmeding> I'm always fascinated by that stuff
[02:15:23] *** Joins: acidjnk (~acidjnk@p200300d0c7049f41b9198ff49f7dde11.dip0.t-ipconnect.de)
[02:16:13] <abastro[m]> Computable reals? How is it encoded
[02:16:39] <sm> "the Haskell Prelude was nearly all written before there was even a working compiler" - true ?
[02:17:53] <[itchyjunk]> tomsmeding, ideally in a list as integers
[02:17:55] <geekosaur> numbers package. I don't recall how it's encoded
[02:17:59] <[itchyjunk]> to do this stuff blob:https://imgur.com/c45d51be-f11b-421c-9572-8f0925c3eeab
[02:18:00] <leah2> sm: i guess hugs was first, and was an interpreter
[02:18:01] <[itchyjunk]> oops
[02:18:05] <[itchyjunk]> https://i.imgur.com/wsSa2wS.png
[02:18:06] <[itchyjunk]> this stuff
[02:18:26] <tomsmeding> right, there's no such constant in the standard library
[02:18:33] <tomsmeding> but, like, copy it from the internet :p
[02:18:51] <[itchyjunk]> right, i guess i'll have to use the power of internet :x
[02:18:57] <tomsmeding> https://duckduckgo.com/?q=pi+25+digits&t=newext&atb=v309-1&ia=answer
[02:18:59] <boxscape_> alternatively, do it the fun way and implement an infinite series to compute the digits
[02:18:59] <geekosaur> the first Prelude was part of the first Report before there was a compiler, no?
[02:19:12] <abastro[m]> Interesting
[02:19:30] <[itchyjunk]> I had implemented some way of computing pi but past 6 digit, the accuracy was slow..
[02:19:39] <geekosaur> but note that it will have had substantial differences from the one we know, like not having Monad (and therefore monadic IO)
[02:19:39] <[itchyjunk]> it was some sort of convergent series.. not sure what i had tried
[02:19:45] <[itchyjunk]> maybe something involving tan
[02:20:08] <leah2> but ghc started in 1992, so...
[02:20:24] <tomsmeding> [itchyjunk]: did you do the computation with Doubles? That wouldn't ever get more precise than the `pi` already present :p
[02:20:34] <geekosaur> right, first Haskell Report was 1990 though
[02:20:47] <abastro[m]> Did not know ghc was so recent
[02:20:50] <[itchyjunk]> tomsmeding, ah :< well copy from internet it is
[02:21:07] <abastro[m]> I guess it is after python then
[02:21:16] <abastro[m]> * is after (c)python then
[02:21:31] <tomsmeding> [itchyjunk]: Double itself only has ~16 digits of precision
[02:22:24] <abastro[m]> Prob sth like 4 * (1 - 1/3 + 1/5 ...)?
[02:22:29] <abastro[m]> That stuff is terribly slow
[02:22:32] <tomsmeding> [itchyjunk]: if you want to try a series again, perhaps try this one: https://en.wikipedia.org/wiki/Pi#Spigot_algorithms
[02:22:45] <geekosaur> python 1.0 goes back to the late 80s, yes
[02:22:49] <tomsmeding> that gives you any part of the (base-16) expansion of pi without having to compute the rest
[02:23:04] <tomsmeding> but realistically, copy the 25 digits from somewhere lol
[02:23:28] <abastro[m]> Idk why I hear python being influenced by haskell then
[02:23:40] <tomsmeding> python evolved after 1.0 ;)
[02:23:46] <geekosaur> because python 1.0 was much simpler
[02:24:19] <geekosaur> list comprehensions (most often mentioned example of copying from haskell) came much later
[02:25:25] <abastro[m]> I see, I guess many of those ppl might not like list comprehension then
[02:26:30] <[itchyjunk]> oh.. wow didn't think about the double's precision itself limiting me. hmm xD
[02:26:30] <abastro[m]> What was the language first had indentation instead of semicolon, btw?
[02:26:39] <geekosaur> I don't think many people want to go back to python 1
[02:27:13] <abastro[m]> I heard massive backlash from structured pattern matching
[02:27:44] <abastro[m]> So I can only imagine what it was like in introducing list comprehension
[02:29:23] <geekosaur> as for indentation, I'm tempted to point to languages that were entered on punched cards; there were column restrictions
[02:29:39] <geekosaur> but python 1 had indentation before haskell did
[02:30:40] <geekosaur> I don't recall at this point whether snobol had column restrictions on fail/success annotations or not;if it did then that pushes it back to the early 60s
[02:30:41] <tomsmeding> hah the original FORTRANs
[02:31:01] <boxscape_> I imagine Miranda had it, too, did it take meaningful indentation from another language?
[02:31:17] <geekosaur> right, but I think the only thing fortran cared about was columns 8-72 for program and 7 marked a continuation line
[02:31:32] <tomsmeding> yeah
[02:31:38] <abastro[m]> History is hard
[02:31:45] <geekosaur> (by convention the first 6 were sequence number and last 8 the program name)
[02:32:02] <abastro[m]> ~~Perhaps python influenced haskell~~?
[02:32:23] <abastro[m]> s/~~/~/, s/~~?/~?/
[02:32:33] <tomsmeding> lots of stuff influenced lots of stuff
[02:32:36] <abastro[m]> s/~~/~*/, s/~~?/*~?/
[02:32:48] <abastro[m]> Oh.
[02:33:04] <geekosaur> miranda was 1985 so before python
[02:34:04] <geekosaur> wikipedia says layout was taken from ISWIM which was first described in 1966
[02:34:12] <abastro[m]> Ah, right miranda was what haskell is based on
[02:34:17] *** Joins: ph88^ (~ph88@ip5f5af71f.dynamic.kabel-deutschland.de)
[02:34:23] <abastro[m]> 1966? Wow
[02:34:26] <geekosaur> haskell was based on miranda and gofer
[02:34:52] *** Joins: mud (~mud@user/kadoban)
[02:34:59] <abastro[m]> Guess indentation just lost out to semicolons in language landscapes
[02:35:07] *** Joins: wyrd (~wyrd@gateway/tor-sasl/wyrd)
[02:35:10] <abastro[m]> ..because of C, I guess
[02:35:21] <geekosaur> C is to blame for a lot of things, yes
[02:35:59] <abastro[m]> Yet ppl praise python for its indentation scheme
[02:36:00] *** Joins: lavaman (~lavaman@c-174-63-118-52.hsd1.ma.comcast.net)
[02:36:01] <abastro[m]> Hmmmmmmm
[02:36:15] <tomsmeding> that's just people not knowing the history
[02:36:27] <abastro[m]> Indeed
[02:36:46] <hpc> let's be honest, most people praise python for saving them the keys "public static void main", but not in so many words
[02:37:11] <abastro[m]> LMAO true
[02:37:18] <abastro[m]> "J a v a"
[02:37:19] *** Quits: takuan (~takuan@178-116-218-225.access.telenet.be) (Remote host closed the connection)
[02:37:27] *** Joins: Codaraxis (~Codaraxis@user/codaraxis)
[02:37:31] <tomsmeding> public class Main { public static void main(String[] args) { ... } }
[02:37:42] <tomsmeding> System.Console.writeLn("hi")
[02:37:44] <abastro[m]> Hahahahahahahaha
[02:37:51] <tomsmeding> > putStrLn "hi"
[02:37:52] <lambdabot>  <IO ()>
[02:37:58] <tomsmeding> % putStrLn "hi"
[02:37:58] <yahb> tomsmeding: hi
[02:38:00] <tomsmeding> okay then
[02:38:01] <jackdk> If you're teaching imperative code, being able to explain the execution model by saying "read the named file, then line-by-line ..." is a damn sight better than needing to explain classes before you get to "Hello, world!"
[02:38:12] *** Quits: ph88 (~ph88@2a02:8109:9e00:71d0:54e3:425d:deaa:23c2) (Ping timeout: 240 seconds)
[02:38:21] <tomsmeding> indeed
[02:38:48] <jackdk> But much of python (at least when I learned) only makes sense if you imagine a harried C programmer writing the runtime: truncating division of ints, old-style classes, ...
[02:38:54] <abastro[m]> Well tbh writing "public static void" makes you feel you are doing something
[02:39:27] <abastro[m]> Also it supposedly helps with readability
[02:39:31] <tomsmeding> I like that haskell sometimes makes me feel like I'm not doing much
[02:39:40] <abastro[m]> Hehe right
[02:39:57] <jackdk> "definition, definition, definition, whoops the problem is solved! how did that happen?"
[02:40:14] <jackdk> some of jle's adventures with Free structures really have that flavour
[02:40:58] *** Quits: EsoAlgo (~EsoAlgo@152.70.142.52) (Remote host closed the connection)
[02:41:40] <hpc> when i have explained haskell, people have unironically asked me where the code was
[02:41:54] <abastro[m]> > If you're teaching imperative code, being able to explain the execution model by saying "read the named file, then line-by-line ..." is a damn sight better than needing to explain classes before you get to "Hello, world!"
[02:41:54] <abastro[m]> Why does "having to explain class" feel familiar.. wait. Burritos.
[02:41:56] <lambdabot>  <hint>:1:35: error: parse error on input â€˜,â€™
[02:41:56] <hpc> "all you did was define some constants"
[02:42:40] <abastro[m]> For real? They thought it was not code?
[02:42:45] *** Joins: EsoAlgo (~EsoAlgo@152.70.142.52)
[02:42:48] <hpc> yep
[02:42:53] <abastro[m]> Ah right, imperative programmers.
[02:42:54] <hpc> @quote cried
[02:42:54] <lambdabot> Ferdirand says: I was TA for a C++ programming course aimed at 1st year physics once. Some girl asked for help "i wrote pseudo-code but I cannot translate it to C++". Her pseudo-code was valid
[02:42:54] <lambdabot> haskell. I cried.
[02:43:08] <Hecate> :')
[02:43:35] <jackdk> abastro[m]: LOL, good point. But you can at least do computations without understanding classes, and there's a few good and gentle paths through to Monad these days
[02:44:02] <boxscape_> you can also write "hello world" without touching Monads, you only need do notation if you want to do more than one IO action :P
[02:44:06] <jackdk> abastro[m]: Also happened in the Haskell vs. Awk vs. C++ vs. whatever the rest was paper - the Haskell solution was mistaken for a specification language instead of executable code.
[02:44:10] <abastro[m]> Yea, wish IO monad was easier
[02:44:32] <abastro[m]> Mistaken for specification lang, ya
[02:44:33] <abastro[m]> Saw that thing
[02:44:47] <abastro[m]> Tho I cannot believe a girl writing valid haskell
[02:44:48] <jackdk> boxscape_: Yeah. Separating "the `IO` type constuctor", "`do` notation", and "the `Monad` class" is an important part of educating beginners
[02:44:58] <abastro[m]> (Perhaps the girl was haskeller)
[02:45:03] <hpc> fun historical fact, the "mistaken for a specification language" thing happened to lisp to
[02:45:06] <hpc> /by its creator/
[02:45:19] <abastro[m]> ??????
[02:45:23] <hpc> lisp was never intended to be run, it was just a nice way to publish papers
[02:45:39] <jackdk> "you can't write a lisp interpreter, that's theory, not application" - McCarthy, to one of his grad students maybe, paraphrased
[02:45:43] <hpc> he even defined eval in the paper
[02:45:50] <boxscape_> sounds like LaTeX
[02:45:56] <Hecate> did you tell the story of the journal that didn't accept pseudo-code in paper submissions, and a paper showing Haskell code was refused on this ground?
[02:46:01] <hpc> so this other guy realized "if i just hand-compile eval, i have everything else for free"
[02:46:04] <hpc> so he did
[02:46:23] <abastro[m]> I did not know ppl love parenthesis to the point of using it for specifications
[02:46:36] <abastro[m]> Perhaps I should use parens more liberally
[02:46:39] <jackdk> S-Exprs are great fun to work in, if you have a good editor
[02:46:51] <abastro[m]> Instead of littering $ around
[02:46:51] <monochrom> Hello world is too easy. Once you go next to "ask user for name, then print that name" it's a lot more challenging.
[02:47:08] <hpc> it was an unambiguous notation for lambda calculus that's easy to typeset and could be extended as needed to get a particular paper out there
[02:47:29] <leah2> curiously, he didnt understand lambda calculus either :p
[02:48:05] <tomsmeding> abastro[m]: jackdk was talking about this paper, see second paragraph of section 7 https://classes.cs.uoregon.edu/16F/cis425/Papers/hudak-jones.pdf
[02:48:48] <abastro[m]> Yep, saw the comparison paper
[02:48:58] <tomsmeding> each time I look that paper up I am sad that "Appendix B" is not present
[02:50:09] <boxscape_> tomsmeding you're describing my emotional state from a minute ago
[02:50:26] <jackdk> Pretty sure I've seen it elsewhere. Basic gist is `type Region = Point -> Bool`; `(/\) :: Region -> Region -> Region` etc
[02:50:31] <tomsmeding> boxscape_: :p
[02:50:46] *** Quits: moet (~moet@mobile-166-177-250-99.mycingular.net) (Quit: leaving)
[02:51:34] *** Joins: whatsupdoc (uid509081@id-509081.hampstead.irccloud.com)
[02:52:51] <jackdk> http://www.cs.yale.edu/publications/techreports/tr1031.pdf check out convexPoly on PDF page 30 (printed page 26)
[02:53:00] <abastro[m]> `Point -> Bool` sounds horribly slow tho
[02:53:43] <tomsmeding> depends on what you're doing with those regions
[02:53:43] <jackdk> If function application is slow, we're sunk.
[02:53:56] <tomsmeding> if the end task is "determine whether these points are in the region", it might be good
[02:54:02] <jackdk> That's the primary task, yes.
[02:54:03] <tomsmeding> if the end task is "plot the region", it might be bad
[02:54:50] *** Joins: Tuplanolla (~Tuplanoll@91-159-69-98.elisa-laajakaista.fi)
[02:55:00] <jackdk> You could also build an AST of your unions/intersections/etc and eval it to `Point -> Bool` for `inRegion` testing, or to better graphics primitives, or...; but that's not what the spec asked for
[02:55:51] *** Quits: pretty_dumm_guy (trottel@gateway/vpn/protonvpn/prettydummguy/x-88029655) (Quit: WeeChat 3.4.1)
[02:56:02] *** Quits: L29Ah (~L29Ah@wikipedia/L29Ah) (Ping timeout: 240 seconds)
[02:56:17] <abastro[m]> Yea
[03:05:46] *** Quits: gehmehgeh (~user@user/gehmehgeh) (Quit: Leaving)
[03:07:43] *** Joins: Pickchea (~private@user/pickchea)
[03:08:54] <monochrom> A thought crosses my mind right now. It is in the FP culture that you are always open to the options of Point->Bool and the AST way. You always consider them. You probably always try them first during prototyping. Maybe later you replace them when performance matter.
[03:09:09] <monochrom> Whereas in imperative cultures, they would never even cross your mind.
[03:09:44] <tomsmeding> well the AST way might perhaps
[03:09:44] *** Joins: bitdex (~bitdex@gateway/tor-sasl/bitdex)
[03:10:03] *** Quits: michalz (~michalz@185.246.204.40) (Remote host closed the connection)
[03:10:08] <abastro[m]> Indeed
[03:10:36] <monochrom> Very reluctantly because the cultural brainwashing says "it's cheating; write real code already!"
[03:10:45] <tomsmeding> especially for stuff like geometry, where "what is the intersection of an annulus and a square" can't be answered much better than "the intersection of that annulus with that square"
[03:11:09] <tomsmeding> though that is true
[03:11:31] <monochrom> A very religious line between "unioning is an operation, write real code already" vs "AST is data, just declare some subclasses / tagged union".
[03:11:50] <abastro[m]> I was surprised when ppl started to talk about side effect
[03:12:05] <tomsmeding> now we're getting to the core of the issue: try writing a sum type in Java, C++ or C#
[03:12:15] *** Quits: pgib (~textual@173.38.117.89) (Ping timeout: 256 seconds)
[03:12:37] <tomsmeding> you either end up making a class hierarchy which is the most abominable way ever, or using std::variant in C++ which is almost as bad
[03:12:49] <tomsmeding> I think C# may have obtained a more reasonable way recently but not sure
[03:12:50] <abastro[m]> When I first entered programming (in imperative way), never seen any concept alike side effect
[03:13:32] <abastro[m]> For record, OOP ppl prefer class hierarchy as kind of open union tho
[03:13:48] <tomsmeding> but it's so verbose
[03:13:51] <abastro[m]> They argue that closed union lack extensibility
[03:13:57] <boxscape_> tomsmeding Java is getting fairly close to getting reasonable sum types with sealed types and records
[03:14:05] <boxscape_> and switch expressions
[03:14:06] <tomsmeding> ah right
[03:14:15] <tomsmeding> here, at least 30 years late
[03:14:18] <boxscape_> right
[03:14:24] *** Joins: lechner (~lechner@debian/lechner)
[03:14:51] <tomsmeding> but in any case, even if the languages are slowly getting sum types, it's not a common good yet
[03:15:08] <tomsmeding> one of the first things one sees in haskell is 'data Maybe a = Nothing | Just a'
[03:15:24] <abastro[m]> Meh I guess some would be saying "pattern matching is FAD"
[03:15:42] <tomsmeding> FAD?
[03:15:50] <abastro[m]> Or FUD
[03:16:30] <abastro[m]> (I guess I forgot the expression)
[03:16:31] <abastro[m]> Also FOMO
[03:16:48] <abastro[m]> Is what they claim the feature to be :<
[03:17:02] <boxscape_> when I told my coworkers that Java will be introducing pattern matching, I was told "I suppose that's nice, but then again, regexes can be pretty hard to read tbh"
[03:17:18] <boxscape_> (paraphrased)
[03:17:19] <tomsmeding> lol
[03:17:21] <Axman6> :thinkingface:
[03:17:26] <monochrom> heh can't be helped
[03:17:32] <abastro[m]> Haha
[03:18:12] <monochrom> Cultural clash again. "pattern" = regex, by definition, in their culture.
[03:18:17] <boxscape_> yeah
[03:18:31] <Axman6> Pattern? All objects have the same shape!
[03:18:31] <abastro[m]> I wonder how ppl resorted to regex.. and they had to expand it horribly
[03:19:04] <Axman6> It would be LITERALLY impossible to program if the same object could have different shapes!
[03:19:15] <monochrom> Racket isn't helping either. Its pattern matching construct covers both the regex kind and the data constructor kind.
[03:19:32] <abastro[m]> Noooo
[03:19:34] <geekosaur> awk and perl
[03:20:12] <abastro[m]> Meh, perl
[03:20:12] *** Quits: lavaman (~lavaman@c-174-63-118-52.hsd1.ma.comcast.net) (Ping timeout: 240 seconds)
[03:20:36] <monochrom> At least count yourself blessed that no one looks at "pattern matching" and go "I know, this is the next thing after Design Patterns" >:)
[03:21:09] <tomsmeding> there was a post on /r/haskell a while ago where someone asked what common design patterns in haskell were
[03:21:09] *** Joins: son0p (~ff@181.136.122.143)
[03:21:17] <geekosaur> perlwas great when your alternatives were shell scripts and C
[03:21:31] <pavonia> Given a set of strings where prefixes of elements may be part of the set too. What library can be used to find a partition of a string into those smaller strings (if possible)?
[03:21:40] <Axman6> tomsmeding: "functions"
[03:21:44] <jackdk> "Design pattern" is when you hand-compile an abstraction your language doesn't have. The GoF book just locked everyone's brains onto a small set of target languages.
[03:21:46] <abastro[m]> I think haskell do have common design patterns tho
[03:22:08] <abastro[m]> Like tagless final
[03:22:12] <monochrom> pavonia: Would it help to use a trie?
[03:22:15] <abastro[m]> Or something
[03:22:53] <geekosaur> lenses are a design pattern :)
[03:23:06] <Axman6> pavonia: a ternary tree would be useful for that
[03:23:13] *** Quits: fendor (~fendor@91.141.35.69.wireless.dyn.drei.com) (Remote host closed the connection)
[03:23:32] <tomsmeding> I guess Trees That Grow is also a design pattern
[03:23:49] <pavonia> monochrom, Axman6: My concern is more the backtracking part
[03:24:07] <Axman6> a ternary tree basically gives you what you want for free
[03:25:00] <abastro[m]> Oh more data structures to learn
[03:25:01] <Axman6> data TTree a = Leaf | Node { val :: a, less, equal, greater :: Tree a }
[03:25:19] <jackdk> https://blog.jle.im/entry/tries-with-recursion-schemes.html is quite advanced but I'm posting it because it's got prequel memes in it
[03:25:31] <Axman6> if you go down equal nodes, you find all strings with the same prefix
[03:26:05] <Axman6> SOMEONE might have even written a package for this over a decade ago... https://hackage.haskell.org/package/TernaryTrees
[03:26:26] <Axman6> It probably won't compile any more...
[03:26:50] <abastro[m]> Haskell evolves fast..
[03:26:58] <jackdk> Axman6: `base >=4.0.0.0 && <5.0.0.0` -_-
[03:27:03] <Axman6> And as shitty as that package might be, it got cited in a paper once =)
[03:27:35] <pavonia> Axman6: This can only be used for storing string, no? I can't see how to easily obtain the desired solution with it
[03:27:48] <Axman6> I'm pretty proud of the Binary instance in that package
[03:28:38] <jackdk> Axman6: I can get a pre-built copy from cache.nixos.org built against ghc8107
[03:28:56] <Axman6> jackdk: that's genuinely amazing
[03:29:10] <abastro[m]> :O
[03:29:55] *** Quits: bitdex (~bitdex@gateway/tor-sasl/bitdex) (Ping timeout: 240 seconds)
[03:30:02] <Axman6> pavonia: I'm not sure I understand - if a string exists in the set, then finding all prefixes of that string is trivial
[03:30:08] <Axman6> isn't that what you want?
[03:30:25] <jackdk> Axman6: nix isn't that magical
[03:31:06] <Axman6> just that it even compiles with a compiler which is like a decade older than the one it was written against
[03:31:50] <boxscape_> weird to see source files without extensions enabled, but that probably helps
[03:32:02] *** Quits: jgeerds (~jgeerds@55d4548e.access.ecotel.net) (Ping timeout: 240 seconds)
[03:32:04] <boxscape_> s/extensions enabled/enabled extensions
[03:32:09] <pavonia> Axman6: I want to find a partition of a string such that it consists of only strings from the set
[03:32:33] <Axman6> I shouldn't've hiden the constructors in that package
[03:32:39] <Axman6> hidden*
[03:34:25] <jackdk> Axman6: I get it, I was making a joke that you were amazed at getting precompiled anything from nix. You should do another release.
[03:34:32] <abastro[m]> So the equal branch is for the strings starting with that char, right?
[03:34:39] <Axman6> yep
[03:34:55] *** Quits: Akiva (~Akiva@user/Akiva) (Ping timeout: 256 seconds)
[03:35:21] *** Quits: alp (~alp@user/alp) (Ping timeout: 245 seconds)
[03:35:26] <Axman6> in the map case, you end up with all the keys with the same prefix sharing that prefix in the structure, and you only branch when there's a differing character
[03:37:09] <pavonia> e.g. given ["a", "ab", "bc"] and "abc" as input string, a partiton is "a|bc". Checking the longest prefix first wouldn't give a correct result
[03:37:10] <abastro[m]> So that package is what pavonia want if the constructors were exposed
[03:37:57] *** Joins: bitdex (~bitdex@gateway/tor-sasl/bitdex)
[03:38:37] *** Quits: Vajb (~Vajb@hag-jnsbng11-58c3a8-176.dhcp.inet.fi) (Read error: Connection reset by peer)
[03:38:59] <Axman6> pavonia: given ["a", "ab", "bc"] and "abc", what output do you expect?
[03:39:22] <geekosaur> pavonia showed it, "a|bc"
[03:39:23] <pavonia> ["a", "bc"]
[03:39:24] <Axman6> because it sounds like I haven't understood the question you're asking if a ternary tree doesn't solve your problem
[03:39:33] <Axman6> sure, but I'm not sure what that means
[03:39:40] <abastro[m]> Oh. So ternary breaks down for the suffix part
[03:40:07] *** Joins: Vajb (~Vajb@hag-jnsbng11-58c3a8-176.dhcp.inet.fi)
[03:40:07] <Axman6> given ["ab", "bc"] and "abc", what should the output be?
[03:40:18] <abastro[m]> I guess it would error
[03:40:21] <pavonia> Axman6: It's like building the input string from strings of the set. Imagine a set of Lego bricks to build the final result from
[03:40:38] <abastro[m]> Because both the prefix and suffix part is supposed to be in the set
[03:40:41] <pavonia> Yeah, that wouldn't give legal result
[03:41:26] <Axman6> but given ["ab", "bc", "c"] and "abc", you'd get back ["ab","c"]?
[03:41:26] <pavonia> extra credits if it would give *all* possible partitions if there are multiple
[03:41:38] <pavonia> Axman6: Yep
[03:41:52] <Axman6> that's definitely doable with a ternary tree, in both cases
[03:42:01] <geekosaur> mm, I'm now imagining somnething in the list monad
[03:42:03] <Axman6> (not using my package, I didn't expose enough)
[03:43:00] <abastro[m]> Idk perhaps just split at arbitrary place and check if both prefix and suffix are in the set
[03:43:03] <pavonia> I imagine this is a common problem so I guessed there would already be a package for that
[03:43:06] <Axman6> you take your string, and traverse the tree as far as possible while the prefix matches, once it doesn't match, return that prefix, and the remaining suffix, and do the same thing again
[03:43:13] <abastro[m]> Ternary tree does make it easier for prefix
[03:43:13] <Axman6> returning all matches is also trivial
[03:43:29] <Axman6> pavonia: it's literally a problem I've never heard of :P
[03:43:39] <pavonia> :S
[03:44:12] <abastro[m]> You need to check if suffix exists as well
[03:44:45] *** Joins: machinedgod (~machinedg@24.105.81.50)
[03:45:25] <abastro[m]> Btw how does scala's performance compare with haskell
[03:46:15] <abastro[m]> In a algorithm problem solving site, scala has done poorly in performance. I wonder how haskell would have faired if it was supported
[03:46:44] <Axman6> Scala's developer performance is fucking attrocious. 
[03:47:02] <Axman6> I cannot state just how much of a dogshit language Scala is
[03:47:35] <energizer> what is developer performance?
[03:47:56] <jackdk> don't worry about it, unless you're doing something wild. There were gnarly Haskell solutions on shootout.alioth.debian.org or whatever it was, but they were all highly tuned. Naive haskell is faster than python/ruby/whatever and you'll be dominated by good data structures etc outside microbenchmarks
[03:48:14] <Axman6> developer productivity, the language and one of the libraries we're using at work have cost our project literally years of development time because of how fucked it all is. 
[03:48:17] <jackdk> energizer: how hard the language makes the developer work to produce an acceptable solution to a problem
[03:49:13] <abastro[m]> I mean, the time spent performance of scala
[03:49:14] <abastro[m]> That and memory
[03:49:20] <Axman6> it makes me angry that anyone could even consider it a reasonable language. It's what you'd get if you took Haskell and Java and kept only the worst, most complex parts of both. it's insanely complex, with only C++ beating it in terms of complexity
[03:49:28] <abastro[m]> Because it never beats python there
[03:49:56] <Axman6> abastro[m]: my point is that it doesn't even matter if the language makes you want to tear your eyes out (or quit, in my case, I've come very close purely because of how fucked working with Scala is)
[03:50:01] <abastro[m]> I mean, it is literally the only FP option in my country
[03:50:11] <energizer> https://benchmarksgame-team.pages.debian.net/benchmarksgame/box-plot-summary-charts.html
[03:50:15] <geekosaur> not even F#
[03:50:16] <geekosaur> ?
[03:50:20] <Axman6> or Rust?
[03:50:24] *** Joins: segfaultfizzbuzz (~segfaultf@2602:306:cd3c:9350:a1ac:7cf2:d212:eed8)
[03:50:29] <Axman6> or lisp? or OCaml?
[03:50:30] <abastro[m]> F# is considered as dead language
[03:50:40] <abastro[m]> No lisp. No ocaml
[03:50:42] <geekosaur> and scala isn't?
[03:50:43] <Axman6> which country, if you dosn't mind me asking?
[03:50:47] *** Quits: xff0x (~xff0x@i121-117-52-147.s41.a013.ap.plala.or.jp) (Ping timeout: 256 seconds)
[03:50:49] <abastro[m]> Rust is just began to be considered
[03:51:00] <abastro[m]> And somehow scala got afloat thanks to java
[03:51:03] <Axman6> scala deserves to be a dead language more than any language that has ever died
[03:51:05] <abastro[m]> It is South Korea
[03:51:25] <abastro[m]> Wow, you dislike scala quite a bit
[03:51:26] <Axman6> Move south to Japan, plenty of Haskell there =)
[03:51:38] <segfaultfizzbuzz> is there such thing as an instruction set which is total? (i'm not sure how to avoid trivial definitions of totality here...)
[03:51:44] <abastro[m]> Well if only that was feasible
[03:52:01] <abastro[m]> It is as easy to move to US altogether
[03:52:10] <segfaultfizzbuzz> meaning that you can do a many/most computations in the instruction set but you cannot perform computations which are turing complete
[03:52:39] <monochrom> Yeah Japan doesn't like immigrants or even work visa.
[03:53:09] *** Joins: alMalsamo (~alMalsamo@gateway/tor-sasl/almalsamo)
[03:53:13] <monochrom> Moving to US is actually less difficult.
[03:53:26] <Axman6> it does if you don't tell them >_>
[03:53:40] <monochrom> Well, apart from work visa for teaching English. OK I'll stop being off-topic, sorry!
[03:53:40] <geekosaur> hm, ladder logic?
[03:54:01] <jackdk> Dhall does this, and it's more of a design philosophy than a useful result. Having to write all list functions in terms of foldr is a bit annoying.
[03:54:22] <jackdk> And a non-turing-complete language can still write busy-beaver-esque programs that take more time than you have to execute
[03:55:01] <segfaultfizzbuzz> so the turing/non-turing distinction is moot?
[03:55:08] <jackdk> also, a lambda calculus is not an instruction set
[03:55:10] <abastro[m]> Actually leetcode accepts racket, I might try that
[03:55:26] <monochrom> Does Calculus of Construction count as an "instruction set"? :)
[03:55:48] <jackdk> in my worldview, maybe, but it's still an important theoretical result. I would rather say: "input your program, I'll let you run it for 500 reduction steps" or whatever.
[03:57:12] <segfaultfizzbuzz> maybe the answer here is that there is no useful constrained way of computing?
[03:57:16] <abastro[m]> At least having total language makes proofs more reliable
[03:57:32] <jackdk> Did I not just provide an alternative constraint on computing?
[03:57:45] <monochrom> But yeah my philosophy opinion (influenced by my thesis supervisor) is also that "it terminates but god knows how long it takes" is a pretty useless thing to know.
[03:58:21] <segfaultfizzbuzz> so maybe you always need a wallclock time constraint?
[03:58:22] <Axman6> segfaultfizzbuzz: I have a feeling that thight might be somewhat relevant: https://www.youtube.com/watch?v=96o8G5dVCaM&list=PLIpl4GKFQR6fg3CBx65LXnj3gz2MFNN5O&index=18 
[03:58:24] <abastro[m]> Is it globally true that C# is losing off to Java?
[03:58:40] <geekosaur> segfaultfizzbuzz, did you look at ladderlogic as I suggested?
[03:58:46] <Axman6> it covers how plutus is a total languiage by construction (I think, I'm pretty sure this is the talk I was looking for)
[03:58:48] <jackdk> monochrom: Exactly. The influence of a design philosophy that sets out to make a non-TC language like Dhall is more important IMHO - people don't try to write overly-complicated things
[03:58:55] <segfaultfizzbuzz> axman6: yes i am looking at ladder logic at the moment. 
[03:59:29] <segfaultfizzbuzz> lol ladder logic ranked #50 out of 52 programming languages in popularity lol ;-)
[03:59:33] <geekosaur> infinite loops and such are pretty much forbidden because they lead to things like train collisions
[03:59:59] <monochrom> Fortunately, in practice, even highly theoretical mathematicians don't really mean to be that useless. Observe that whenever their theorem states "it terminates", the time bound is somewhere in the proof. It is their culture that you are supposed to look at the proofs too, not just the anti-climatic theorem statement.
[04:00:11] <geekosaur> it's still highly important as a result
[04:00:31] <Axman6> hmmm, maybe that's not the talk I was after... skimming isn't showing me what I remember
[04:00:46] <segfaultfizzbuzz> axman6: yeah i don't see the relevance of cardano here hehe ;-)
[04:01:00] <abastro[m]> Typical Mathematicians do not deal with computation/termination, soo
[04:01:10] <monochrom> But yes, it's their strange culture that they speak like "Theorem: There exists an algorithm for regex emptiness" and the algorithm is not part of the theorem, just part of the proof.
[04:01:29] <segfaultfizzbuzz> i don't like/can't make sense of non-constructive mathematics
[04:01:43] <abastro[m]> Oh so computer scientists I guess
[04:01:54] <abastro[m]> Eh, nonconstructive math is how 90% of math is done so
[04:01:55] <abastro[m]> Idk
[04:02:06] <segfaultfizzbuzz> yeah, for now. i don't believe that real numbers exist, for example
[04:03:15] <abastro[m]> Like, In my uni, there is no one doing constructive mathematics
[04:03:25] <segfaultfizzbuzz> for now ;-)
[04:03:34] <abastro[m]> Hehe
[04:03:44] <geekosaur> numbers don't exist. you cannot show me a three.
[04:04:02] <monochrom> There are "computer scientists" who are secretly mathematicians but they joined the computer science department because more funding. It means they go on to do what mathematicians do, especially culture, manners, styles.
[04:04:18] <segfaultfizzbuzz> hahaha
[04:04:28] <abastro[m]> The uni might cease to exist before constructive mathematics
[04:04:55] <monochrom> Stephen Cook explicitly admitted, when asked, "yeah both the math department and the cs department made me offers. I chose the cs department because more research funding". That does it.
[04:05:07] <abastro[m]> Btw my uni head praises scala for its combination of FP and OOP
[04:05:28] <abastro[m]> * my uni CS head praises
[04:05:36] <Axman6> he absolutely should not do that
[04:05:41] <Axman6> (or she)
[04:06:02] <abastro[m]> As a professor of Programming Language, she advocates Scala
[04:06:10] <abastro[m]> And that is how I learned scala
[04:06:42] <abastro[m]> Tbh I think `.flatMap` thing is interesting, at least.
[04:07:32] <abastro[m]> Other than that.. meh
[04:07:59] <boxscape_> which aspect of .flatMap are you referring to?
[04:08:13] <abastro[m]> That you can chain
[04:08:15] <Axman6> I find using .flatMap over do notation/for comprehensions really painful
[04:08:23] *** Quits: acidjnk (~acidjnk@p200300d0c7049f41b9198ff49f7dde11.dip0.t-ipconnect.de) (Ping timeout: 252 seconds)
[04:08:39] <Axman6> I think I've only used it once to essentially build join for Maybe/Option
[04:08:41] <boxscape_> I suppose with record dot notation similar things are becoming possible in Haskell, though not necessarily widespread
[04:08:47] <abastro[m]> Ya true, but interesting nonetheless
[04:08:58] <segfaultfizzbuzz> axman6: trying to understand how ladder logic would differ from simply a fixed logic statement here
[04:09:19] <monochrom> I teach students >>= without do-notation. Perhaps it's just as painful? >:)
[04:09:42] <Axman6> I don't know what ladder logic is, so I won't be of any use to you :P
[04:10:02] <abastro[m]> A few more language rant: Many ppl in my country advocates Go, Python, JS as the next big language after Java. Rust is a bit forgotten.
[04:10:12] <Axman6> the necessity of using brackets with flatMap makes it really gross
[04:10:29] <geekosaur> Axman6, I think segfaultfizzbuzz confused us
[04:10:29] <segfaultfizzbuzz> Microsoft Visual Functional Basic is the next great language
[04:10:42] <dolio> Knowing something terminates, but not knowing how long it would take, can be useful.
[04:10:42] <abastro[m]> Lmao
[04:10:50] <dolio> It means you don't have to wait to see if it terminates.
[04:10:53] <monochrom> Ugh, Go Python JS were the next big language last decade already. :)
[04:11:15] <Axman6> Scala has not surpassed Go in my language hatred ranking. Go is simply insulting to developers, it assumes they are dumb and can't handle abstraction, but I'd take it over Scala I think... only just 
[04:11:18] <abastro[m]> Ya I mean my country is slow, I guess
[04:11:41] <segfaultfizzbuzz> Microsoft Visual Functional Basic is Visual Basic but with functional features, in the same way that scala is java with functional features
[04:11:49] <abastro[m]> "Go is so simple, it is great. It is also made by google geniuses" :facepalm:
[04:12:07] <jackdk> monochrom: I agree with "teach >>= first". Then I go "here's the best layout I've found for >>=, but isn't it annoying to write all these nested lambdas?" And then I show the translation into do-notation.
[04:12:11] <geekosaur> sounds like about the intelligence level it was aimed at
[04:12:25] <dolio> For instance, if you prove `a ~ b` to GHC, but it has to evaluate the Ackermann function to get the proof witness, it has to actually evaluate it to avoid doing something unsound.
[04:12:45] <Axman6> I was at uni when Go was announced, and Andrew whatshisface, one of the main developers came and gave a talk, and even back then, I remember thinking "how the fuck can a modern language not have generics???" I might have even asked him something along those lines
[04:13:01] <dolio> Because it doesn't know that your proof is legitimate until it fully evaluates it.
[04:13:04] <monochrom> I do respect Go for being simple.
[04:13:10] <segfaultfizzbuzz> abatro[m]: have you used Functional Go ?
[04:13:12] <abastro[m]> They say, generics are too hard
[04:13:18] <monochrom> But worship of big corporations is unhealthy.
[04:13:19] <boxscape_> @do teach >>= first
[04:13:19] <lambdabot> do { a <- teach; first a}
[04:13:24] *** Quits: __monty__ (~toonn@user/toonn) (Quit: leaving)
[04:13:40] <abastro[m]> Idk, ppl nowadays dislike any hard concepts I guess
[04:13:41] <segfaultfizzbuzz> Functional Go is Go with mapreduce and serverless lambdas.
[04:13:53] <abastro[m]> Eww
[04:14:08] <monochrom> But it may take another couple of centuries for East Asia to grow out of worshipping authorities.
[04:14:13] <jackdk> Axman6: I remember hearing a similar story involving Java's announcement and Bertrand Meyer
[04:14:19] <Axman6> IMO it feels like Go is intentionally contrarian to the entire field of PL research
[04:14:54] <abastro[m]> Yea, because of their "research is bad"
[04:14:55] <boxscape_> the only thing I know about Go is that reddit post where someone faked generics by using type names with symbols that look like < and > but are actually letters
[04:15:19] <Axman6> just for the sake of it, the idea that even novice programmers can't understand the idea of a structurew that can hold any type and being able to write function which work on those structures no matter what the type contained is, is ludacris
[04:15:44] <geekosaur> segfaultfizzbuzz, ladder logic is a bit more than a fixed logic statement, and in particular you can implement math in it (but you have limits on what you can do with it)
[04:15:53] <Axman6> boxscape_: that was legendary - using Canadian Aboriginal characters to ram generics into Go
[04:16:09] <boxscape_> yeah
[04:16:12] <abastro[m]> Dunno, there are def ppl who have hard time comprehending those structures
[04:16:19] <boxscape_> though apparently a proposal to add generics has been accepted https://github.com/golang/go/issues/43651#issuecomment-776944155
[04:16:43] <abastro[m]> Gophers hate generics being introduced l
[04:16:46] <abastro[m]> Lol
[04:16:49] <segfaultfizzbuzz> geekosaur: implement math...?
[04:16:56] <hpc> yeah, it seems like some hiring manager looked at the success rate of fizzbuzz and thought google was missing out on some valuable talent
[04:17:11] <segfaultfizzbuzz> geekosaur: you mean you can perform arithmetic with it (but you can't with ordinary logic statements...?)
[04:17:11] <Axman6> yeah generics is finally coming, but it should have been there since day one - particularly since they _already are_ in the language, but the Go devbelopers have decided you are too stupid to use them, only maps can
[04:17:27] <Axman6> hpc: snap, far too accurate
[04:17:31] <boxscape_> hmm sounds vaguely reminiscent of Elm
[04:17:36] <segfaultfizzbuzz> Rob Pike said HKT are coming to Go in 2024
[04:17:41] <geekosaur> wikipedia showed how to implement nand, once you have nand you can build full adders
[04:18:02] <geekosaur> and once you have those you can go on to subtraction and multiplication. division is a bit harder
[04:18:17] <abastro[m]> "Go is great at asynchronous programming"
[04:18:24] <abastro[m]> Gah I dislike these days
[04:19:03] <Axman6> abastro[m]: that's also nonsense, it has one tool, and it is often not a good tool for concurrency. Language like Haskell and Ada both embarrass Go's concurrency model
[04:19:28] <abastro[m]> I wonder what kind of panic they would have after seeing haskell code. Like they would say "The hell is this mess"
[04:19:41] <abastro[m]> Just because non-C syntax & declarativeness
[04:19:50] <geekosaur> I suspect you'd get more like that paper quote from a couple hours ago
[04:19:59] <Axman6> I remember years ago someone making a post showing how some really trivial concurrent programming problem was literallyt impossible in go, because the abstractions of goroutines and channels weren't universal enough. Can't remember what the problem was, but it was pretty simepl
[04:20:05] <zzz> what . do (you $ mean) -- ?
[04:20:40] <hpc> Axman6: remember the async "what color is your function" javascript post?
[04:20:43] <Axman6> zzz: I hate that that is syntactically valid, and I can unnderstand what it would do
[04:20:43] <hpc> that one was painful too
[04:20:54] <Axman6> not sure I've seen that
[04:21:03] <abastro[m]> Hm, I guess, perhaps I was bad in showing scala code
[04:21:24] <abastro[m]> Tho I don't expect much for ppl who worship Go
[04:21:28] <hpc> it was something along the lines of synchronous functions are blue, async functions are red, and here's some annoyingly specific rules about how to combine them
[04:21:49] <hpc> and it gets thiiiiis close to saying "monad" and then doesn't make the connection and just goes off into more random details
[04:21:50] <segfaultfizzbuzz> the future is functional golang with hkt on the jvm on v8 on webassembly
[04:21:55] *** Quits: ix (~ix@2a02:8010:674f:0:d65d:64ff:fe52:5efe) (Remote host closed the connection)
[04:22:02] *** Joins: ix (~ix@2a02:8010:674f:0:d65d:64ff:fe52:5efe)
[04:22:14] <Axman6> ha
[04:22:44] <hpc> end result, not really explaining async at all anyway
[04:22:46] <monochrom> No, the future is everyone trash-talking each other.
[04:22:56] <jackdk> monochrom: The future is now
[04:23:20] <Axman6> the future will be fulfilled, that is its promise
[04:23:58] <abastro[m]> Tbh seeing Go's success, I think something like Scratch would be the next big language
[04:23:58] <abastro[m]> Sincerely.. ppl love not having to learn much
[04:24:09] <geekosaur> logo
[04:24:20] <abastro[m]> Async color haha
[04:24:31] <geekosaur> the next browserwill be implemented with turtle graphics :Ã¾
[04:24:39] <hpc> i want to see rust be the winner in all these silly language wars
[04:24:58] *** Quits: ChaiTRex (~ChaiTRex@user/chaitrex) (Quit: ChaiTRex)
[04:25:13] <abastro[m]> I love the github issue about how they aren't going to allow monad semantics in promise
[04:25:24] <hpc> it respects the programmer enough to be a more powerful tool instead of a simpler tool with a rubber handle
[04:25:31] *** Joins: ChaiTRex (~ChaiTRex@user/chaitrex)
[04:25:33] <segfaultfizzbuzz> hpc: me too, sort of. the problem i ran into is that there is no way i will never be intelligent enough to write correct unsafe code, and i'm not sure anyone else ever will be either
[04:25:40] <hpc> and it just seems like the people developing it are way more concerned about solving the real problems of language
[04:25:50] <abastro[m]> Interesting that many of you like Rust
[04:26:02] <abastro[m]> Perhaps I should really try it.. someday
[04:26:19] <segfaultfizzbuzz> if haskell was reimplemented with the DX of rust i think it would be my fav lang
[04:26:20] <hpc> instead of being the n-th vaguely buggy inconsistent implementation of a third of ADTs
[04:26:23] <abastro[m]> Tho it is not FP
[04:26:30] <Axman6> I need to take some time to learn rust, there's a lot of interesting stuff there, particularly for someone who enjoys low level programming
[04:26:38] <segfaultfizzbuzz> abastro[m]: rust is my go-to language these days
[04:26:58] <hpc> segfaultfizzbuzz: pun intended?
[04:27:10] <segfaultfizzbuzz> hpc: which pun?
[04:27:13] <hpc> goto
[04:27:21] <segfaultfizzbuzz> oh, go-to, haha. maybe double or triple entendre
[04:27:23] <abastro[m]> Ya, I was avoiding rust because it is more imperative than functional
[04:27:36] *** Quits: grimey (~grimey@pool-108-26-35-23.syrcny.east.verizon.net) (Ping timeout: 268 seconds)
[04:27:44] <hpc> abastro[m]: don't - it feels very functional when you go to actually use it imo
[04:27:44] <segfaultfizzbuzz> abastro[m]: i think there is some kind of joke about haskell being an imperative language...
[04:28:01] *** Joins: mvk (~mvk@2607:fea8:5cc3:7e00::7980)
[04:28:03] <hpc> like you're always in a do block, rather than always in a vaguely fancy bash prompt
[04:28:12] <Axman6> yeah I've always considered rust mildly functional
[04:28:16] <segfaultfizzbuzz> is haskell a vaguely fancy bash prompt?
[04:28:41] <hpc> haskell makes me wish i paid more attention in my math classes
[04:28:51] <hpc> it feels like what math could have been if i didn't go with CS
[04:28:51] <segfaultfizzbuzz> hpc: to what...?
[04:28:53] <geekosaur> there used to be a joke about haskell being the best imperative language, yes
[04:29:01] <hpc> geekosaur: that's my joke!
[04:29:07] <geekosaur> I'm not sure if xmonad is an argument for or against that. :Ã¾
[04:29:10] <hpc> haskell is the best imperative language and perl's the best functional language
[04:29:13] <monochrom> Ugh that's SPJ's joke...
[04:29:22] <hpc> monochrom: oh, TIL
[04:29:31] <geekosaur> thought SPJ's was that excel was the best functional language
[04:29:34] <monochrom> But you can have the perl one :)
[04:29:43] <hpc> haha, i will grant that excel is pretty great
[04:29:44] <abastro[m]> I mean, first order function is harder to apply in rust iirc
[04:29:59] <hpc> it's like invisible programming
[04:30:03] <abastro[m]> Also no monad trair in rust
[04:30:03] <segfaultfizzbuzz> SPJ says that the next haskell will be strict, while the idris dude says that the next idris (which i have been told is the next haskell) will be nonstrict   *eyes crossing*
[04:30:25] <segfaultfizzbuzz> abastro[m]: why? have you looked at itertools?
[04:30:27] *** Quits: Pickchea (~private@user/pickchea) (Quit: Leaving)
[04:30:27] <energizer> i never understood why nobody uses haskell as a system shell
[04:30:41] *** Joins: werneta_ (~werneta@70-142-214-115.lightspeed.irvnca.sbcglobal.net)
[04:30:52] <hpc> energizer: nothing beats bash for just writing a command and making stuff happen
[04:31:04] <hpc> its default mode is exec()
[04:31:04] <energizer> good joke
[04:31:08] <abastro[m]> Itertools? How do you use it?
[04:31:21] <geekosaur> now I'm reminded of the old NOTES entry in the v7 unix m4 manpage
[04:31:29] <hpc> every other plausible shell's default mode is variable-level
[04:31:35] *** Quits: werneta (~werneta@70-142-214-115.lightspeed.irvnca.sbcglobal.net) (Ping timeout: 256 seconds)
[04:31:47] <geekosaur> referring to m4 -e
[04:31:47] <segfaultfizzbuzz> abastro[m]: https://docs.rs/itertools/latest/itertools/ it's a haskell-y/functional way of iterating on collections
[04:32:14] <segfaultfizzbuzz> itertools is zip, join, fold, etc
[04:32:16] <hpc> haha, "beats bash", just noticed it
[04:32:38] <geekosaur> shouldhave been bashing out a command
[04:32:57] <energizer> hpc: sorry i was being sarcastic, i think bash and shells in general are bad
[04:33:28] <hpc> i put bash in the same bucket as vim
[04:33:33] <abastro[m]> Oh I see
[04:33:36] <hpc> or like, chorded keyboards
[04:33:44] <segfaultfizzbuzz> hey i use vim
[04:33:57] <abastro[m]> I mean, things like FunOnce in rust
[04:34:08] <hpc> it's a ridiculously specific tool that you have to get good at, but when you're truly good at it nothing else makes you more productive for that specific thing
[04:34:12] <segfaultfizzbuzz> ooooh FunOnce ;-) i had FunOnce
[04:34:14] <abastro[m]> That you cannot use any function in the function parameter slot.
[04:34:23] <abastro[m]> It complicates things I heard.
[04:34:41] <hpc> vim's command language is similar, very specific and idiosyncratic and there's nothing else like it
[04:34:49] <segfaultfizzbuzz> abastro[m]: by far rust is the highest productivity lang i have used. probably because im not smart enough to use haskell yet
[04:34:57] <hpc> but then you're showing someone how to do something and you go tap-tap-tap and the whole file changes
[04:35:07] <hpc> and that someone's head explodes from how easy it was
[04:35:28] <zzz> hpc: ok so that's why vim is good. but why is it bad?
[04:35:42] <abastro[m]> Hahaha
[04:35:43] <hpc> vim is objectively perfect
[04:35:45] <energizer> segfaultfizzbuzz: which languages is rust more productive than?
[04:35:49] <hpc> it's like that greek statue that's missing its head
[04:36:01] <hpc> it's so much better without it
[04:36:13] <segfaultfizzbuzz> energizer: pretty much everything i think. i am a rust kool aid zealot fundamentalist
[04:36:19] <abastro[m]> segfaultfizzbuzz, Well I feel productive doing haskell, I would have hard time dealing with borrow checker
[04:36:25] <energizer> segfaultfizzbuzz: well that's implausible
[04:36:36] <monochrom> I heard it was the arm. But perhaps different statue.
[04:36:48] <hpc> abastro[m]: you'd be surprised - it's like dealing with haskell's type checker
[04:36:55] <energizer> segfaultfizzbuzz: which ones are you comparing
[04:37:05] <hpc> a lot of it gets inferred and you don't have to muck about with lifetimes unless you are doing something very interesting
[04:37:19] <hpc> and it always catches some sort of lurking bug, even if you can't tell what that bug might have been
[04:37:25] <zzz> energizer: hackage.haskell.org/package/turtle
[04:37:33] <segfaultfizzbuzz> abastro[m]: the rust borrow checker used to be a little bit of work, now you won't encounter it that much. what kind of software are you trying to write?
[04:37:39] <abastro[m]> (Tbh I wonder why you guys are persuading to use rust in a haskell chat)
[04:37:42] *** Quits: ProfSimm (~ProfSimm@87.227.196.109) (Remote host closed the connection)
[04:37:47] *** Joins: chenqisu1 (~chenqisu1@183.217.201.47)
[04:37:58] <hpc> abastro[m]: we're the heroes programming deserves :D
[04:38:00] *** Joins: ProfSimm (~ProfSimm@87.227.196.109)
[04:38:25] <monochrom> We persuade people to be rational. As opposed to religious.
[04:38:27] <segfaultfizzbuzz> there also is https://github.com/gluon-lang/gluon
[04:38:28] <abastro[m]> Oh right, I realized why I dislike rust. It steals ppl from haskell
[04:38:48] <monochrom> At least I do.
[04:39:03] <hpc> same
[04:39:13] <abastro[m]> I guess I love HKT and lenses too much
[04:39:58] <abastro[m]> And stateful list monad
[04:40:29] <abastro[m]> Is stateful list monad doable in rust?
[04:40:59] *** Quits: werneta_ (~werneta@70-142-214-115.lightspeed.irvnca.sbcglobal.net) (Ping timeout: 256 seconds)
[04:41:00] <segfaultfizzbuzz> abastro[m]: afaik you don't need lists except for some kind of flow control circumstance i don't really understand
[04:41:04] <abastro[m]> The nondeterminism which can duplicates state
[04:41:20] <segfaultfizzbuzz> abastro[m]: usually when you think you want a list you actually want a Vec
[04:41:37] <abastro[m]> I mean, haskell list is a stream
[04:41:57] <dolio> I know when I want a vector vs. a list.
[04:42:18] <segfaultfizzbuzz> dolio: well feel free to enlighten us 
[04:42:25] *** Joins: werneta (~werneta@70-142-214-115.lightspeed.irvnca.sbcglobal.net)
[04:42:32] <abastro[m]> So like, stateful list monad works as backtracking with state
[04:42:41] *** Quits: mmhat (~mmh@55d49471.access.ecotel.net) (Quit: WeeChat 3.4.1)
[04:42:43] <abastro[m]> You can backtrack to certain state
[04:42:48] <dolio> What does that mean? I just know when I want one or the other, on a case-by-case basis.
[04:42:55] *** Quits: nicbk (~nicbk@user/nicbk) (Ping timeout: 240 seconds)
[04:43:21] <dolio> It's more often lists, though.
[04:43:25] <abastro[m]> Sometimes list is more useful, indeed. Tho ppl don't see that happen often
[04:43:27] <abastro[m]> Oh wait
[04:43:31] <abastro[m]> More often lists?
[04:43:50] <abastro[m]> Isn't vec typically faster
[04:44:26] <segfaultfizzbuzz> dolio: when should i use a list?
[04:44:43] <segfaultfizzbuzz> abastro[m]: vec is "usually" what you want, not list
[04:44:51] <dolio> That question is too open ended to answer reasonably.
[04:44:54] <zzz> oh no haskell has become popular
[04:45:07] <geekosaur> I rarely use lists longer than a few elements, so I usually don't bother with Vector (or Text for that matter)
[04:45:10] *** Quits: Tuplanolla (~Tuplanoll@91-159-69-98.elisa-laajakaista.fi) (Quit: Leaving.)
[04:45:31] <hpc> also, in haskell or in rust?
[04:45:33] <zzz> segfaultfizzbuzz: do you use vectors for flow control?
[04:45:37] <abastro[m]> I mean for haskell, list is obv better
[04:45:47] <dolio> When I'm storing a context to translate to de Bruijn indices, though, I want a list, because I don't want to pay O(n) to add a variable to the front of the list.
[04:45:50] <monochrom> abastro[m]: In the Haskell standard library, StateT [] fits your description. I don't know how easy it is to do in Rust.
[04:45:50] <abastro[m]> But in rust..
[04:46:03] <segfaultfizzbuzz> zzz: tbh i am not sophisticated enough of a programmer (yet?) to have needed this mysterious "flow control" phenomenon
[04:46:06] <abastro[m]> Yea, I meant StateT []
[04:46:12] <monochrom> Err, StateT S [], where S is your state type.
[04:46:22] <zzz> segfaultfizzbuzz: maybe because i meant "control flow"
[04:46:24] <abastro[m]> Something like that is what I often resort to
[04:46:29] <abastro[m]> Idk if I am abusing monads
[04:46:41] <segfaultfizzbuzz> s/"flow control"/"control flow"
[04:46:52] <geekosaur> segfaultfizzbuzz, ever loopedover something? a list is a loop encoded as data
[04:46:56] <monochrom> Don't worry, StateT S [] is the right choice :)
[04:47:15] <abastro[m]> Isn't Rust list a linked list?
[04:47:24] *** Quits: machinedgod (~machinedg@24.105.81.50) (Ping timeout: 240 seconds)
[04:47:25] <segfaultfizzbuzz> geekosaur: interesting perspective
[04:47:57] <segfaultfizzbuzz> abastro[m]: probably but i don't think i have ever run across a list once in a couple years of production use of rust
[04:48:01] <abastro[m]> Now I wonder how to run StateT s [] asynchronously
[04:48:30] <abastro[m]> Well rust does make it easier to use imperative constructs like for / while
[04:48:37] <segfaultfizzbuzz> lists encourage pointer chasing whereas vecs encourage sequential memory access, which can be much faster
[04:48:49] <segfaultfizzbuzz> so lists tend to have a lot of random memory access going on
[04:49:06] <hpc> rust's list-like container situation is complicated, and focused on things like memory layout
[04:49:10] <hpc> so like, slices
[04:49:29] <zzz> segfaultfizzbuzz: haskell lists are stacks
[04:49:30] <hpc> if you have a bytestring "abcdefg" in memory somewhere, and you do some substringing to it
[04:49:33] <segfaultfizzbuzz> yes, rust has more direct concern for memory layout vs haskell/haskell data structures, as i understand it
[04:49:36] <abastro[m]> At least OS uses linked lists
[04:49:58] <hpc> you have a "cde" slice, which behaves like the bytestring "cde" except that it also holds onto the memory around it
[04:50:02] <segfaultfizzbuzz> zzz: i see, and stacks have good memory ordering?
[04:50:10] <abastro[m]> So there's your list application
[04:50:21] <zzz> segfaultfizzbuzz: no, that's why you shouldn't use lists for everything
[04:50:35] <abastro[m]> Haskell lists often unrolls into loops btw
[04:50:48] <segfaultfizzbuzz> zzz: right, so this reinforces my point that lists are a sometimes snack
[04:51:16] <segfaultfizzbuzz> zzz: unfortunately all the haskell introductory materials emphasize lists everywhere, and it seems like many common haskell data structures depend on them...?
[04:51:31] <zzz> segfaultfizzbuzz: but your point is that "vec is usually what you want, not a list", which is the point im debating against
[04:52:00] <zzz> you want vec when you want vec
[04:52:01] <segfaultfizzbuzz> zzz: ok? why do i usually want a list instead then?
[04:54:08] <zzz> iteration is a big one
[04:54:23] <abastro[m]> I guess nearly no use of lists in rust
[04:54:30] <segfaultfizzbuzz> zzz: itertools?
[04:55:05] <abastro[m]> Think haskell list is more capable than just itertools
[04:55:09] <segfaultfizzbuzz> abastro[m]: you can get very far in rust without lists, and it's possible that you will never encounter them. what are you trying to write
[04:55:29] <segfaultfizzbuzz> itertools is effectively lazy i think (?) it only computes what is necessary (??)
[04:55:33] <monochrom> Allow me to play devil's advocate and remind that the vector library also enjoys vector fusion, therefore WLOG you can always default to the vector library, even when [] is no worse. >:)
[04:55:55] <abastro[m]> I mean, I am not trying to write something. Just that I like my `StateT s []`
[04:56:01] <monochrom> OK OK except when you desired infinite lists!
[04:56:43] <abastro[m]> IIRC Rust does not have backtrack-able iteration
[04:57:07] <dolio> Not all uses for lists are fusible loops expressed via lists, though.
[04:57:14] <segfaultfizzbuzz> abastro[m]: backtrack-able? are you mutating the structure you are iterating over?
[04:57:27] <monochrom> Rust's list is not lazy. This can hurt some backtracking use cases.
[04:57:48] <segfaultfizzbuzz> monochrom: can you point to the docs for "Rust's list"? i have never seen this
[04:58:13] <segfaultfizzbuzz> monochrom: and as i said above, itertools is effectively lazy
[04:58:20] <zzz> abastro[m]: my favorite monad is the Tardis Monad
[04:59:15] <monochrom> Recall the N-queen problem that has a pretty natural forward constraint propagation + backtracking solution in functional programming. Using lists for choice and backtracking, the SML version takes huge memory, the Haskell version is pretty lean.
[04:59:59] <segfaultfizzbuzz> SML?
[05:00:13] <jackdk> Standard ML, probably
[05:00:25] <geekosaur> https://en.wikipedia.org/wiki/Standard_ML
[05:00:29] <zzz> Saturday Monad Live
[05:00:35] <segfaultfizzbuzz> ah... lol saturday monad live lol
[05:00:55] <zzz> sorry
[05:02:31] <segfaultfizzbuzz> monochrom: i think i would have to study this to see the difference
[05:03:26] <zzz>  https://www.lri.fr/~filliatr/publis/enum2.pdf
[05:03:33] <segfaultfizzbuzz> but i think you are saying that branch and bound can be naturally expressed in haskell with lists but not in rust/an ML family language?
[05:03:37] *** Quits: foul_owl (~kerry@174-21-69-110.tukw.qwest.net) (Ping timeout: 240 seconds)
[05:04:10] <monochrom> Natural in all languages.
[05:04:29] <monochrom> But laziness causes cost differences.
[05:05:01] <segfaultfizzbuzz> is there a "maximum language overhead"?
[05:05:17] <segfaultfizzbuzz> across languages?
[05:05:42] <segfaultfizzbuzz> and if language overhead exists is it just because there are unknown compiler optimizations, or can the overhead be fundamental
[05:06:03] *** Joins: Akiva (~Akiva@user/Akiva)
[05:06:23] <geekosaur> every language has things it does better and things it does worse, where the metric can be memory, time, etc.
[05:06:37] <segfaultfizzbuzz> right, but absolute worst case is 100x or something?
[05:06:48] <geekosaur> this can differ by implementation or be fundamental to the language design
[05:06:50] <zzz> segfaultfizzbuzz: Haskell is not "not ML"
[05:07:00] *** Quits: vorpuni (~pvorp@2001:861:3881:c690:6385:bd9:c0d2:296c) (Remote host closed the connection)
[05:07:31] <geekosaur> and haskell is an ML family language. it's just the non-strict member of the family
[05:08:52] <zzz> Haskell does *not* do well on saving space :X
[05:08:59] <geekosaur> I doubt a hard maximum exists
[05:11:02] <zzz> but that's the (increasingly small imo) price to pay for doing almost everything else right
[05:11:07] *** Quits: vicfred (~vicfred@user/vicfred) (Quit: Leaving)
[05:11:48] <geekosaur> I've only found space to be a probloem once, and that was my own damn fault
[05:11:55] *** Joins: Guest26 (~Guest26@60-241-4-164.static.tpgi.com.au)
[05:12:11] <geekosaur> (population simulator, run with bounds disabled. can you say "exponential growth", kids?)
[05:13:40] <zzz> I am ashamed to say how much disk space i dedicate to haskell tooling alone
[05:15:23] <abastro[m]> Oh right
[05:15:30] <abastro[m]> Cabal cache takes quite a size
[05:17:29] *** Quits: lbseale (~ep1ctetus@user/ep1ctetus) (Read error: Connection reset by peer)
[05:17:42] * zzz laughs in nix
[05:17:53] *** Joins: lavaman (~lavaman@c-174-63-118-52.hsd1.ma.comcast.net)
[05:18:53] *** Joins: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net)
[05:18:59] *** Joins: foul_owl (~kerry@23.82.193.88)
[05:22:36] <jackdk> zzz: I saw a "heaviest objects in the universe" meme that went sun; neutron star; black hole; node_modules, /nix/store
[05:25:00] *** Quits: segfaultfizzbuzz (~segfaultf@2602:306:cd3c:9350:a1ac:7cf2:d212:eed8) (Ping timeout: 240 seconds)
[05:27:11] *** Quits: Guest26 (~Guest26@60-241-4-164.static.tpgi.com.au) (Quit: Ping timeout (120 seconds))
[05:28:58] <abastro[m]> Is nix cache better?
[05:29:02] <abastro[m]> Gah I need to learn nix
[05:29:09] <abastro[m]> But I find it hard to get into
[05:29:17] <abastro[m]> I am dumb I guess
[05:29:28] <Maxdamantus> 327G    /nix/store/
[05:29:39] * Maxdamantus doesn't use nix much though.
[05:30:03] * Maxdamantus should probably delete all his profiles from 2018 or so.
[05:30:09] <abastro[m]> Wait wha
[05:31:04] <geekosaur> you need to gc nix every so often to remove unused profiles and their associated program versions
[05:31:36] <geekosaur> it's been a while and I forget details; I decided duplicating my system multiple times under /nix/store was ridiculous
[05:31:45] <geekosaur> haven't really missed it
[05:32:41] <abastro[m]> At least nix has gc right
[05:33:15] <abastro[m]> Cabal does not it seems
[05:34:15] * monochrom wonders where emacs stands in the tier of heavy objects in the universe. :)  https://www.gnu.org/fun/jokes/ed-msg.en.html
[05:34:55] *** Quits: bitdex (~bitdex@gateway/tor-sasl/bitdex) (Ping timeout: 240 seconds)
[05:35:02] <abastro[m]> I have to nuke the cache but I am wary of the compile time it takea
[05:35:11] <geekosaur> once upon a time it was fairly high. nvim beat it years ago, then along came node, then nix
[05:35:26] <geekosaur> also monochrom wrote a cache pruner iirc
[05:35:32] <geekosaur> for cabal
[05:35:48] <monochrom> Yeah https://github.com/treblacy/cabalgc
[05:36:10] *** Joins: bitdex (~bitdex@gateway/tor-sasl/bitdex)
[05:36:39] <monochrom> Although, if you upgrade GHC version every half a year, maybe it's simplest to just delete .cabal/store/ghc-<old version>
[05:36:41] <sm> see also stack-clean-old for stack and ghcup tui for ghcup-installed stuff
[05:37:00] <sm> and as fallback, ncdu on ~/.{ghc,cabal,stack,ghcide,...} is good
[05:37:44] <sm> so now in Rust land, would cargo manage all of this stuff ?
[05:37:58] * sm votes for ghcup to gc all the things
[05:38:04] <monochrom> Assuming, for installing executables, you refuse cabal-install's blatantly stupid default of "--install-method=symlink".
[05:39:50] <sclv> would be great for someone to step up and add this https://github.com/haskell/cabal/issues/3333
[05:40:13] *** Quits: cosimone (~user@93-44-187-176.ip98.fastwebnet.it) (Quit: ERC (IRC client for Emacs 27.1))
[05:40:53] <abastro[m]> So I have to pick ones to keep with cabal gc :<
[05:41:14] *** Quits: albet70 (~xxx@2400:8902::f03c:92ff:fe60:98d8) (Remote host closed the connection)
[05:41:26] *** Quits: Techcable (~Techcable@168.235.93.147) (Changing host)
[05:41:26] *** Joins: Techcable (~Techcable@user/Techcable)
[05:42:06] <geekosaur> see sclv's ticket, at present it's rather difficult to automate that
[05:42:49] <abastro[m]> Wish I could automatically set up to specify projects to keep.
[05:43:01] <abastro[m]> * to keep dependency of.
[05:44:11] <Maxdamantus> 173485 store paths deleted, 242080.20 MiB freed
[05:47:21] *** Joins: albet70 (~xxx@2400:8902::f03c:92ff:fe60:98d8)
[05:55:06] *** Joins: segfaultfizzbuzz (~segfaultf@2602:306:cd3c:9350:a1ac:7cf2:d212:eed8)
[06:00:27] *** Joins: khumba (~khumba@user/khumba)
[06:01:03] <zzz> Maxdamantus: that's a lot
[06:01:29] *** Quits: ProfSimm (~ProfSimm@87.227.196.109) (Remote host closed the connection)
[06:01:51] <abastro[m]> Wait, 242GB???
[06:02:26] *** Quits: hughjfchen (~hughjfche@vmi556545.contaboserver.net) (Quit: WeeChat 2.8)
[06:04:25] *** Quits: lavaman (~lavaman@c-174-63-118-52.hsd1.ma.comcast.net) (Ping timeout: 268 seconds)
[06:08:46] <geekosaur> that was /nix/store, I think
[06:09:02] <geekosaur> [22 00:59:28] <Maxdamantus> 327G    /nix/store/
[06:10:00] <monochrom> 6.02e23  /usr/bin/emacs  :)
[06:10:37] <geekosaur> avogadro's editor?
[06:10:44] <monochrom> yeah heehee
[06:11:48] <abastro[m]> Lmao
[06:12:16] <monochrom> 125GeV   /boot/higgs
[06:12:17] *** Quits: segfaultfizzbuzz (~segfaultf@2602:306:cd3c:9350:a1ac:7cf2:d212:eed8) (Ping timeout: 240 seconds)
[06:14:54] <zzz> one point to vim i guess
[06:16:49] *** Quits: mud (~mud@user/kadoban) (Quit: quit)
[06:19:26] *** Quits: [itchyjunk] (~itchyjunk@user/itchyjunk/x-7353470) (Remote host closed the connection)
[06:19:46] *** Joins: [itchyjunk] (~itchyjunk@user/itchyjunk/x-7353470)
[06:20:13] *** Quits: khumba (~khumba@user/khumba) ()
[06:24:44] <abastro[m]> Rate my sht code... (full message at https://libera.ems.host/_matrix/media/r0/download/libera.chat/1b07672699d44ca82dd3c634dd92e61b42fbfcb2)
[06:28:43] *** Joins: Topsi (~Tobias@dyndsl-095-033-018-177.ewe-ip-backbone.de)
[06:31:29] *** Quits: ix (~ix@2a02:8010:674f:0:d65d:64ff:fe52:5efe) (Remote host closed the connection)
[06:31:38] *** Joins: ix (~ix@2a02:8010:674f:0:d65d:64ff:fe52:5efe)
[06:32:08] *** Quits: ix (~ix@2a02:8010:674f:0:d65d:64ff:fe52:5efe) (Remote host closed the connection)
[06:32:20] *** Joins: ix (~ix@2a02:8010:674f:0:d65d:64ff:fe52:5efe)
[06:32:47] *** Quits: Akiva (~Akiva@user/Akiva) (Ping timeout: 268 seconds)
[06:32:48] <Axman6> abastro[m]: FYI, long messages like that don't work well for IRC - just use a paste website like...
[06:32:50] <Axman6> @where paste
[06:32:50] <lambdabot> Help us help you: please paste full code, input and/or output at e.g. https://paste.tomsmeding.com
[06:33:31] <abastro[m]> Well then I guess rather post it like, https://github.com/Abastro/AdventOfCode/blob/master/src/Y2021/Prob10.hs
[06:35:01] *** Joins: vysn (~vysn@user/vysn)
[06:35:47] *** Joins: bitmapper (uid464869@id-464869.lymington.irccloud.com)
[06:36:12] <Axman6> any background on what problem you're solving? it looks pretty arbitrary
[06:37:11] <abastro[m]> https://adventofcode.com/2021/day/10  - it is likely my code being messy.
[06:40:07] *** Quits: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net) (Remote host closed the connection)
[06:40:42] *** Joins: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net)
[06:45:53] *** Quits: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net) (Ping timeout: 256 seconds)
[06:58:55] *** Joins: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net)
[06:59:19] *** Joins: wroathe (~wroathe@206-55-188-8.fttp.usinternet.com)
[06:59:19] *** Quits: wroathe (~wroathe@206-55-188-8.fttp.usinternet.com) (Changing host)
[06:59:19] *** Joins: wroathe (~wroathe@user/wroathe)
[07:00:18] *** Joins: hughjfchen (~hughjfche@vmi556545.contaboserver.net)
[07:00:26] *** Quits: ptrcmd (~ptrcmd@user/ptrcmd) (Ping timeout: 250 seconds)
[07:00:35] *** Joins: ptrcmd (~ptrcmd@user/ptrcmd)
[07:03:24] *** Joins: ubert1 (~Thunderbi@p548c8d44.dip0.t-ipconnect.de)
[07:04:55] *** Quits: ubert (~Thunderbi@p200300ecdf1588ca0b7aa2fbaa2d0440.dip0.t-ipconnect.de) (Ping timeout: 256 seconds)
[07:04:55] *** ubert1 is now known as ubert
[07:07:24] *** Quits: neurocyte0917090 (~neurocyte@user/neurocyte) (Ping timeout: 240 seconds)
[07:07:44] *** Parts: jakalx (~jakalx@base.jakalx.net) ()
[07:10:16] *** Joins: jakalx (~jakalx@base.jakalx.net)
[07:10:35] *** Quits: raehik (~raehik@cpc95906-rdng25-2-0-cust156.15-3.cable.virginm.net) (Ping timeout: 256 seconds)
[07:14:56] *** Quits: acidsys (~LSD@2a03:4000:55:d20::3) (Excess Flood)
[07:15:27] *** Joins: acidsys (~LSD@2a03:4000:55:d20::3)
[07:21:01] <DigitalKiwi> Axman6: matrix is the future!
[07:21:59] *** Joins: mud (~mud@user/kadoban)
[07:22:30] <geekosaur> I wouldn't actually complain about the long message since matrix helpfully auto-pastebinned it anyway
[07:22:51] <geekosaur> it's matrix edits that are really annoying because they just spam the channel
[07:24:11] *** Quits: hughjfchen (~hughjfche@vmi556545.contaboserver.net) (Quit: WeeChat 2.8)
[07:26:09] *** Joins: aviladev[m] (~aviladevm@2001:470:69fc:105::1:cbc7)
[07:33:48] *** Quits: mvk (~mvk@2607:fea8:5cc3:7e00::7980) (Ping timeout: 240 seconds)
[07:34:35] *** Quits: jpds (~jpds@gateway/tor-sasl/jpds) (Ping timeout: 240 seconds)
[07:38:32] *** Joins: hughjfchen (~hughjfche@vmi556545.contaboserver.net)
[07:39:13] <Axman6> DigitalKiwi: so was ICQ, and MSN, and Facebook Messenger, and Slack, and Discord, and ...  and what still remains? IRC, forever and always
[07:39:42] <Axman6> yeah I was mostly pointing it out because matrix users sometimes don't know that their messages get manipulated like that sometimes
[07:40:23] *** Joins: xff0x (~xff0x@125x102x200x106.ap125.ftth.ucom.ne.jp)
[07:40:54] *** Joins: Logio_ (em@kapsi.fi)
[07:40:55] <DigitalKiwi> never had icq
[07:40:57] *** Joins: lll (~o@user/offon)
[07:41:00] *** Joins: nonzen_ (~nonzen@user/nonzen)
[07:41:11] *** Joins: sviermsung (owJr4HCxlX@user/s4msung)
[07:41:15] *** Joins: burakcan- (~burakcank@has.arrived.and.is.ready-to.party)
[07:41:16] *** Joins: kmein_ (~weechat@user/kmein)
[07:41:18] *** Joins: thonkpod_ (~thonkpod@user/thonkpod)
[07:41:21] *** Joins: lawt2 (~lawt@2601:200:8101:f140:dea6:32ff:fea1:adf9)
[07:41:29] *** Quits: kmein (~weechat@user/kmein) (*.net *.split)
[07:41:29] *** Quits: Inoperable (~PLAYER_1@fancydata.science) (*.net *.split)
[07:41:29] *** Quits: mcglk (~mcglk@131.191.49.120) (*.net *.split)
[07:41:29] *** Quits: Logio (em@kapsi.fi) (*.net *.split)
[07:41:29] *** Quits: s4msung (z4rgS71Nb1@user/s4msung) (*.net *.split)
[07:41:29] *** Quits: burakcank (~burakcank@has.arrived.and.is.ready-to.party) (*.net *.split)
[07:41:29] *** Quits: Jon (jon@dow.land) (*.net *.split)
[07:41:29] *** Quits: lawt (~lawt@2601:200:8101:f140:dea6:32ff:fea1:adf9) (*.net *.split)
[07:41:29] *** Quits: nonzen (~nonzen@user/nonzen) (*.net *.split)
[07:41:29] *** Quits: _\_ (~o@user/offon) (*.net *.split)
[07:41:29] *** Quits: thonkpod (~thonkpod@user/thonkpod) (*.net *.split)
[07:41:29] *** Quits: jakalx (~jakalx@base.jakalx.net) (*.net *.split)
[07:41:44] *** lll is now known as _\_
[07:41:49] *** Joins: Jon (jon@dow.land)
[07:42:09] <corisco[m]> actually mirc is the future
[07:42:14] <Axman6> I used to use Adium, so at some point I probably did because I ended up making an account for basically every protocol it supported
[07:42:24] *** burakcan- is now known as burakcank
[07:44:15] *** Quits: boborygmy_ (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net) (Ping timeout: 256 seconds)
[07:45:20] <DigitalKiwi> pidgin/adium/trillian gang
[07:45:32] <Axman6> \m/
[07:46:06] <Axman6> adium was the shit back in high school
[07:46:33] *** Joins: In0perable (~PLAYER_1@fancydata.science)
[07:46:36] *** Joins: mcglk (~mcglk@131.191.49.120)
[07:46:44] *** Joins: vglfr (~vglfr@88.155.11.162)
[07:48:26] <Axman6> :t foldlM
[07:48:27] <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
[07:49:19] <sm> yeah long inline pastes from matrix clients are fine for IRC, they show up as a nice paste link
[07:50:23] <Axman6> it's fine, other than that the author may not know it's happened and IMo the experience is nicer if you ask a question and link to code ratheer than asking half a question and then people needing to click a link to finish reading it
[07:51:45] *** Quits: geranim0 (~geranim0@modemcable242.171-178-173.mc.videotron.ca) (Remote host closed the connection)
[07:52:03] <sm> good point, an inline paste by itself might not be clear. The best way is to paste it preceded by your descriptive comment. IRC users will see at least the start of the comment, plus the link
[07:52:08] *** Joins: karim (~karim@102.43.202.169)
[07:52:51] <Axman6> abastro[m]: finally got a chance to look at your code - looks fine to me, pretty clear how it works once you've read the problem description. the foldlM feels a bit magical and took me a sec to understand (I was going to suggest using foldr because of early termination, but realised I misunderstood what was happening)
[07:55:32] *** Quits: boxscape_ (~boxscape_@p4ff0b60b.dip0.t-ipconnect.de) (Ping timeout: 240 seconds)
[07:55:32] <abastro[m]> Oh, I should avoid editing in matrix then, if it spams :<
[07:55:49] <Axman6> yes, it spams for each edit :)
[07:56:00] <abastro[m]> ya, I guess `foldlM` is not really intuitive
[07:56:21] <abastro[m]> I wonder what would be more intuitive
[07:56:27] *** Quits: Topsi (~Tobias@dyndsl-095-033-018-177.ewe-ip-backbone.de) (Read error: Connection reset by peer)
[07:58:28] *** Quits: Unicorn_Princess (~Unicorn_P@46-54-248-191.static.kate-wing.si) (Remote host closed the connection)
[07:58:56] <Axman6> I would probably have written things by having a function with type String -> Either Char [ChToken] to make the processing part clear, and then the other code is just mapping, filtering and reducing, it felt a bit tangled having that in the function too. not that that's necessarily a good design, just how I would have written it
[07:59:47] <Axman6> also, me being the sort of person I am, I immediately though about if I could save memory by not using a list and instead storing the stack in as Integer, two bits at a time XD
[08:00:36] <Axman6> > divMod (-7) 4
[08:00:38] <lambdabot>  (-2,1)
[08:00:52] <Axman6> > quotRem (-7) 4
[08:00:53] <lambdabot>  (-1,-3)
[08:00:57] *** Quits: raym (~raym@user/raym) (Ping timeout: 240 seconds)
[08:01:42] *** Joins: lavaman (~lavaman@c-174-63-118-52.hsd1.ma.comcast.net)
[08:02:16] *** Quits: lagooned (~lagooned@108-208-149-42.lightspeed.hstntx.sbcglobal.net) (Quit: WeeChat 3.4)
[08:02:51] *** Joins: raym (~raym@user/raym)
[08:02:58] <abastro[m]> I see, think your approach would be better
[08:03:10] <abastro[m]> Btw is posting paste better than a link?
[08:04:24] <zzz> @where paste
[08:04:24] <lambdabot> Help us help you: please paste full code, input and/or output at e.g. https://paste.tomsmeding.com
[08:05:40] <sm> stop me if I'm being a bore... as a matrix user I like to paste inline (following descriptive comment, as you did). Because it's much more immediate and usable for other matrix users, and as already discussed shows up as a nice trustworthy minimalist paste link for IRC users. 
[08:06:33] *** Joins: Akiva (~Akiva@user/Akiva)
[08:07:23] <sm> On the downside, the matrix pastebin won't highlight haskell code or provide the other features of a richer site like paste.tomsmeding.com. Personally though, a plain text resizable window filling no-messing raw paste is often what I want. On tomsmeding that's not the default
[08:07:25] *** Quits: Techcable (~Techcable@user/Techcable) (Ping timeout: 240 seconds)
[08:09:11] *** Quits: raym (~raym@user/raym) (Ping timeout: 256 seconds)
[08:13:43] *** Quits: ubert (~Thunderbi@p548c8d44.dip0.t-ipconnect.de) (Read error: Connection reset by peer)
[08:14:00] *** Joins: ubert (~Thunderbi@p200300ecdf158894255673a7c9121e6c.dip0.t-ipconnect.de)
[08:15:31] <sm> (see https://paste.tomsmeding.com/sb9sRUY4, eg tomsmeding . Ideally content is the most visible thing, but often it's not. Here I accidentally pasted a single line with no breaks. Even if I fix that, the content is still the smallest part of the page content)
[08:15:55] *** Quits: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net) (Remote host closed the connection)
[08:16:18] <sm> don't get me wrong, most other things about it are great
[08:17:05] *** Joins: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net)
[08:17:24] *** Quits: vglfr (~vglfr@88.155.11.162) (Ping timeout: 240 seconds)
[08:17:47] *** Quits: terrorjack (~terrorjac@2a01:4f8:1c1e:509a::1) (Quit: The Lounge - https://thelounge.chat)
[08:18:05] <zzz> i made my own minimalist pastebin which works nice on text based browsers even https://paste.jrvieira.com/1647920833364
[08:18:50] *** Quits: meinside (uid24933@id-24933.helmsley.irccloud.com) (Quit: Connection closed for inactivity)
[08:19:05] *** Joins: terrorjack (~terrorjac@static.3.200.12.49.clients.your-server.de)
[08:19:14] *** Quits: Nahra (~user@static.161.95.99.88.clients.your-server.de) (Remote host closed the connection)
[08:20:33] *** Quits: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net) (Remote host closed the connection)
[08:21:30] *** Joins: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net)
[08:22:24] <zzz> i removed the highlighting though but it's easy enough to implement one
[08:26:13] *** Quits: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net) (Ping timeout: 240 seconds)
[08:31:11] *** Joins: raym (~raym@user/raym)
[08:37:56] *** Joins: vglfr (~vglfr@88.155.11.162)
[08:38:32] *** Quits: raym (~raym@user/raym) (Ping timeout: 240 seconds)
[08:39:26] *** Quits: kaph (~kaph@net-109-116-124-149.cust.vodafonedsl.it) (Read error: Connection reset by peer)
[08:40:29] *** Joins: raym (~raym@user/raym)
[08:40:35] *** Quits: bitdex (~bitdex@gateway/tor-sasl/bitdex) (Ping timeout: 240 seconds)
[08:42:01] *** Quits: cyphase (~cyphase@user/cyphase) (Ping timeout: 245 seconds)
[08:42:23] *** Quits: lavaman (~lavaman@c-174-63-118-52.hsd1.ma.comcast.net) (Ping timeout: 256 seconds)
[08:42:50] *** Joins: bitdex (~bitdex@gateway/tor-sasl/bitdex)
[08:48:55] *** Quits: bitdex (~bitdex@gateway/tor-sasl/bitdex) (Ping timeout: 240 seconds)
[08:50:32] *** Joins: cyphase (~cyphase@user/cyphase)
[08:50:37] *** Quits: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340) (Ping timeout: 240 seconds)
[08:59:06] *** Joins: k8yun (~k8yun@user/k8yun)
[09:00:00] *** Joins: bahamas (~lucian@84.232.140.158)
[09:00:56] *** Joins: mbuf (~Shakthi@136.185.72.170)
[09:01:11] *** Joins: nicbk (~nicbk@user/nicbk)
[09:02:27] *** Quits: [itchyjunk] (~itchyjunk@user/itchyjunk/x-7353470) (Ping timeout: 256 seconds)
[09:03:26] *** Joins: kaph (~kaph@net-109-116-124-149.cust.vodafonedsl.it)
[09:04:32] *** Quits: bahamas (~lucian@84.232.140.158) (Ping timeout: 240 seconds)
[09:06:16] *** Joins: [itchyjunk] (~itchyjunk@user/itchyjunk/x-7353470)
[09:06:54] *** Quits: zaquest (~notzaques@5.130.79.72) (Remote host closed the connection)
[09:08:03] *** Joins: zaquest (~notzaques@5.130.79.72)
[09:09:21] *** Joins: Techcable (~Techcable@user/Techcable)
[09:10:06] <abastro[m]> Hm, I guess I'd use paste.tomsmeding.com from now on
[09:10:36] *** Joins: benin (~benin@183.82.26.94)
[09:12:02] *** Quits: vglfr (~vglfr@88.155.11.162) (Ping timeout: 240 seconds)
[09:19:27] *** Quits: wroathe (~wroathe@user/wroathe) (Ping timeout: 256 seconds)
[09:23:24] *** Quits: Maxdamantus (~Maxdamant@user/maxdamantus) (Ping timeout: 240 seconds)
[09:24:37] *** Joins: Maxdamantus (~Maxdamant@user/maxdamantus)
[09:28:38] *** Joins: bitdex (~bitdex@gateway/tor-sasl/bitdex)
[09:38:17] *** Quits: k8yun (~k8yun@user/k8yun) (Read error: Connection reset by peer)
[09:39:16] *** Joins: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl)
[09:55:32] *** Quits: lechner (~lechner@debian/lechner) (Ping timeout: 240 seconds)
[09:56:49] *** Joins: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net)
[09:57:59] *** Quits: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net) (Ping timeout: 256 seconds)
[10:01:29] <Axman6> abastro[m]: I didn't really notice this before, but your use of sort xs !! n is kinda fun, since sort in Haskell is lazy you end up only producing half the sorted list.
[10:03:00] <Axman6> I've had an idea mulling around in my head for a while to build a structure for finding the median of some data, with something that looks like data Median a = Median (Set a) a (Set a), where inserting maintains the invariant that the single a is always the median or one off it and the sets are no more than one element different in size
[10:03:16] <abastro[m]> It is why I love haskell's laziness
[10:03:32] <abastro[m]> Oh, Median datatype would be nice
[10:04:25] <Axman6> I was also thinking about where the median element would live in a min-max heap (which is the combination of a min heap and a max heap into one structure so you have efficient access to the min and max). it feels like the median is probably just the last element in the array
[10:05:17] <Axman6> what problem is sol10S trying to solve anyway? It doesn't seem to be anything on the challenge you linked
[10:07:58] <abastro[m]> Oh right. Sadly, it displays after putting in the solution..
[10:08:10] <Axman6> fair enough
[10:08:53] *** Joins: sagax (~sagax_nb@user/sagax)
[10:09:32] <abastro[m]> https://paste.tomsmeding.com/NMRHRV6t
[10:11:04] <dsal> Oh, I remember that one.
[10:12:21] <Axman6> heh, it's interesting how close the answer is to what I was proposing as an efficient way to store the stack in an integer!
[10:12:34] <dsal> I did kind of weird stuff there.  glg did this thing was like, 5 lines of code and quite fast.
[10:13:37] *** Quits: toulene (~toulene@user/toulene) (Ping timeout: 256 seconds)
[10:13:38] <Axman6> I suggested above storing the stack as an integer which used two bits per element of the stack... if I'd suggested mod 5 and never used zero, then I would have had the answer immediately, by accident XD
[10:13:53] <abastro[m]> 5 lines of code for both 2?
[10:13:55] <abastro[m]> * both 2? Wow, how...
[10:14:10] *** Quits: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl) (Ping timeout: 268 seconds)
[10:14:24] <dsal> Mine was pretty slow, but I wanted to use megaparsec and figure out how to get its error messages to drive me to a solution.
[10:15:06] *** Joins: toulene (~toulene@user/toulene)
[10:15:29] <abastro[m]> Oh, megaparsec
[10:15:43] *** Quits: zebrag (~chris@user/zebrag) (Quit: Konversation terminated!)
[10:15:45] <abastro[m]> I guess AoC also presents a cue to learn those
[10:16:57] <dsal> Mine was only about half a page, but messing around with megaparsec errors was some work.
[10:17:15] *** Quits: karim (~karim@102.43.202.169) (Ping timeout: 256 seconds)
[10:18:08] <abastro[m]> Oh wait. so you mean, glg did the 5 lines & fast
[10:18:15] <abastro[m]> I thought that was you
[10:18:45] <dsal> Nah, my goal was to learn how to do megaparsec errors.  He tends to boil problems down to their essence and express them as a single foldMap.
[10:18:56] <dsal> (or in this case, foldM)
[10:19:04] <abastro[m]> Oh, foldMap
[10:19:31] <abastro[m]> Right, I should have summarized it into single thing using Monoids
[10:19:56] <dsal> I do that as often as I can.
[10:20:18] <abastro[m]> I need to do it more
[10:20:34] <abastro[m]> Granted, it is a functionality only haskell offers as of now
[10:20:35] <Axman6> I tried to make a monoid for validating UTF-8 text but never figured it out :'(
[10:21:21] <abastro[m]> Oooh
[10:21:27] <abastro[m]> UTF-8 including unicode dealings?
[10:22:40] <abastro[m]> (..I forgot how unicode is handled, like graphemes codepoints etc)
[10:22:58] <Axman6> at the very least validating that each codepoint was valid - I wouldn't check .... the things which end up being made from multiple code points
[10:23:31] <abastro[m]> Yea, multiple code points. Maybe that is too much
[10:23:35] <dsal> Unicode wasn't too bad before they started adding color photos into it.
[10:24:04] <abastro[m]> Hahaha..wait color photos?
[10:24:15] <abastro[m]> You mean emotes?
[10:24:19] <dsal> ðŸš€
[10:24:40] <Maxdamantus> That square just looks white to me.
[10:25:01] *** Quits: alMalsamo (~alMalsamo@gateway/tor-sasl/almalsamo) (Remote host closed the connection)
[10:25:06] <dsal> That's at least part of my point.  It's super hard for everyone to be able to render all the characters.
[10:25:13] <abastro[m]> So, emotes
[10:25:17] <Maxdamantus> emojis*
[10:25:17] *** Joins: alMalsamo (~alMalsamo@gateway/tor-sasl/almalsamo)
[10:25:20] <dsal> Then you have things like people emojis with codepoints for defining skin color.
[10:25:27] <abastro[m]> Ya, rendering these is hard
[10:25:45] <dsal> Back in my day, we had ascii, and we liked it.
[10:26:17] <dsal> (though I literally just wrote a parser that has to autodetect EBCDIC source)
[10:26:42] <Maxdamantus> Well, it's either add them to Unicode, or else have different ways of encoding them for each messaging protocol and phone manufacturer.
[10:26:45] <abastro[m]> Non-latin alphabet folks: Wh
[10:26:46] <Axman6> Haskell's handling of unicode leaves a bit to be desired, it's pretty fun doing things like:
[10:26:49] <Axman6> % let flags = "ðŸ‡¦ðŸ‡º "in print (flags, reverse flags) >>  putStrLn flags >> putStrLn (reverse flags) 
[10:26:49] <yahb> Axman6: ("\127462\127482 "," \127482\127462"); ðŸ‡¦ðŸ‡º ; ðŸ‡ºðŸ‡¦
[10:26:52] <dsal> ðŸ§“
[10:27:05] <Axman6> hmmmm, well I just broke my terminal somewhat with that...
[10:27:56] <dsal> I kind of like having things like flag and rocketship letters when other people are making it work.
[10:28:08] <dsal> I'm insufficiently principled.
[10:29:31] <Maxdamantus> $Reversing Unicode is a nonsense operation anyway.\u202E If you really want to reverse something, there are code points for that.
[10:29:34] <Maxdamantus> er
[10:29:43] <abastro[m]> Does `String` as `[Char]` mesh well with unicode?
[10:29:46] <Maxdamantus> Damn it, wrong shell.
[10:30:27] <Maxdamantus> Reversing Unicode is a nonsense operation anyway.â€® If you really want to reverse something, there are code points for that.
[10:30:42] <Axman6> abastro[m]: it does surprisingly well up to the point of needing to deal with things at the multiple codepoint level, a Char is a single unicode codepoint
[10:31:15] <abastro[m]> Hm.. characters with multiple codepoint level could suffer, then.
[10:32:28] <Maxdamantus> imo it should just be a list of code units, as Unicode intended.
[10:33:18] <Maxdamantus> list of code points gives people a false impression of Unicode correctness (similarly to how UTF-16 does), and Unicode never intended to pass around lists of code points.
[10:34:08] <Maxdamantus> The official ICU library just provides abstractions that work on code units.
[10:35:02] <Maxdamantus> Seems like people are trying to reinstate the UCS philosophy.
[10:35:45] <abastro[m]> I see, so code unit is like 8 bits for UTF8
[10:36:17] <abastro[m]> In that case, I imagine it would be harder to deal with individual characters, though.
[10:36:20] <Maxdamantus> Yes. Preferably strings should be sequences of code units that are conventionally UTF-8.
[10:36:21] *** Joins: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com)
[10:36:34] <Maxdamantus> It wouldn't be any harder than working with code points.
[10:37:08] <abastro[m]> I mean, we cannot easily pattern match on a character then.
[10:37:28] <Maxdamantus> You can't do that with code points either.
[10:37:40] <Maxdamantus> > reverse "heÌllo"
[10:37:42] <lambdabot>  "oll\769eh"
[10:37:55] <Maxdamantus> > putStrLn $ reverse "heÌllo"
[10:37:57] <lambdabot>  <IO ()>
[10:38:01] <Maxdamantus> % putStrLn $ reverse "heÌllo"
[10:38:01] <yahb> Maxdamantus: ollÌeh
[10:38:30] <abastro[m]> I mean for common cases.
[10:39:01] *** Joins: sloorush (~sloorush@136.233.9.99)
[10:39:19] <Maxdamantus> So you want to have something that usually matches one character, but you're okay with it being incorrect?
[10:39:21] <abastro[m]> Like with CJK characters, makes it easier to deal with it.
[10:39:50] *** Joins: lavaman (~lavaman@c-174-63-118-52.hsd1.ma.comcast.net)
[10:40:01] <abastro[m]> Idk, at least sometimes it is going to be incorrect
[10:40:12] <abastro[m]> Perhaps better approach is revising pattern matching for strings
[10:40:23] <Maxdamantus> How so? Korean is known for being able to compose multiple code points into a single glyph.
[10:41:03] <Maxdamantus> "match a single character" only makes sense if you're doing something like a character limit.
[10:41:30] <abastro[m]>  Using regex 
[10:41:38] <Maxdamantus> If you're doing something like /foo.*bar/, that works just as well on code units as it does code points.
[10:41:53] <abastro[m]> Oh, Korean letters are usually single code points
[10:42:33] <abastro[m]> You can compose multiple alphabets to form a character, but the character is represented by specific code point.
[10:42:45] <Maxdamantus> Usually, but there are separate code points for the individual jamo (the letters within the characters) that can be combined together.
[10:43:05] <abastro[m]> Yep, but they are usually rendered separately
[10:43:08] <Maxdamantus> Just like how you can write "Ã©" as one or two code points.
[10:43:12] <Maxdamantus> No, they're rendered the same way.
[10:43:18] <abastro[m]> They do not gather and form a glyph.
[10:43:23] <Maxdamantus> They do.
[10:43:32] <Maxdamantus> > "eÌ" == "Ã©"
[10:43:33] <lambdabot>  False
[10:43:57] <abastro[m]> Well, does ã„±ã…ã…‡ render as combined for you?
[10:44:00] <Axman6> I mentioned a while ago min-max heaps in relation to your problem abastro[m] - I finally foudn the article I was looking for that explain them; if you want to learn about cool structures, this is a great place one: https://probablydance.com/2020/08/31/on-modern-hardware-the-min-max-heap-beats-a-binary-heap/
[10:44:41] <abastro[m]> Wow, Axman6, great article! I'll take a look.
[10:44:51] <Maxdamantus> abastro[m]: you need to use a combining character.
[10:45:08] <Axman6> the fact that unicode has multiple ways to represent the same thing annoys me, the "eÌ" == "Ã©" thing annoys me
[10:45:39] <Axman6> abastro[m]: are you already familiar with min/max heaps?
[10:46:56] <abastro[m]> No, I am not familiar, so I would look at the article
[10:47:18] <abastro[m]> Btw by combining characters, do you mean https://en.wikipedia.org/wiki/Combining_character
[10:47:25] <abastro[m]> IIRC there is no combining character for Korean characters.
[10:47:33] <Axman6> I would learn about those first (not that a min heap and a max heap are basically the same thing, and a min-max heap basically combines them)
[10:48:10] <abastro[m]> Oh. I see, I thought the article was describing about the min-max heap
[10:48:35] <abastro[m]> I do know about min heap and max heap, but min-max heap should be something different right
[10:48:35] <Axman6> that article decscribes min-max heaps, but you should know what a min-heap is first
[10:48:47] <abastro[m]> Oh, I def knows min-heap and max-heap
[10:48:50] <Axman6> ok, then you should be good to go
[10:48:56] <abastro[m]> Yea, thanks!
[10:49:24] *** Joins: takuan (~takuan@178-116-218-225.access.telenet.be)
[10:50:02] *** Joins: alp (~alp@user/alp)
[10:53:04] <Maxdamantus> abastro[m]: oh, actually, the code points you used were the non-composing ones.
[10:53:43] <abastro[m]> Yep, IIRC there is no composing characters for Korean.
[10:53:59] <Maxdamantus> Yes, there are different code points that compose.
[10:54:35] <Maxdamantus> > length "á„€á…¡á„‹"
[10:54:37] <lambdabot>  3
[10:54:50] <Maxdamantus> That doesn't render correctly for me (urxvt)
[10:55:03] <Maxdamantus> but it should in a proper Unicode renderer afaict
[10:55:23] <abastro[m]> Well, only 2 combined, but it did combine. Hmm
[10:55:27] <Maxdamantus> er, oops.
[10:55:33] <Maxdamantus> that was three lead jamo.
[10:55:53] * Maxdamantus figures it out again from the table.
[10:56:37] <Maxdamantus> > length "á„€á…¡á†¼"
[10:56:38] <lambdabot>  3
[10:56:45] <Maxdamantus> Maybe that.
[10:57:02] *** Quits: doyougnu (~doyougnu@cpe-67-249-83-190.twcny.res.rr.com) (Ping timeout: 240 seconds)
[10:57:46] <Maxdamantus> Looks reasonable on Android.
[10:58:22] *** Quits: phma (phma@2001:5b0:211f:ad58:d57e:9b56:2014:519f) (Read error: Connection reset by peer)
[10:59:20] *** Joins: phma (~phma@host-67-44-208-58.hnremote.net)
[10:59:30] *** Quits: califax (~califax@user/califx) (Remote host closed the connection)
[10:59:53] *** Joins: califax (~califax@user/califx)
[11:00:03] <abastro[m]> I see, I stand corrected. I did not know about it as it is nearly never used.
[11:00:39] <Maxdamantus> How do you know?
[11:01:06] <Maxdamantus> If you're using a correct Unicode renderer, you shouldn't be able to tell the difference, unless you copy the text and look at it in a hex editor or something.
[11:01:19] <Maxdamantus> or use the `length` function in Haskell.
[11:02:24] *** Quits: Techcable (~Techcable@user/Techcable) (Remote host closed the connection)
[11:04:37] *** Joins: Techcable (~Techcable@user/Techcable)
[11:04:38] *** Quits: img (~img@user/img) (Quit: ZNC 1.8.2 - https://znc.in)
[11:04:47] <abastro[m]> > length "á„€á…¡á†¼"
[11:04:49] <lambdabot>  3
[11:05:03] <abastro[m]> Oh
[11:05:12] <abastro[m]> Yea, I confused something I guess.
[11:05:52] *** Quits: whatsupdoc (uid509081@id-509081.hampstead.irccloud.com) (Quit: Connection closed for inactivity)
[11:06:43] <abastro[m]> Namely, I thought Hangul Jamo region characters are not supposed to be combined
[11:07:18] <Maxdamantus> btw, regarding regex, the author of the main Rust regex library also created `bstr`, particularly for use as the basis of the regex library.
[11:07:35] <Maxdamantus> where `bstr` is basically the same as `str`, but without a constraint on UTF-8 well-formedness.
[11:08:00] <abastro[m]> Though, I can guarantee these encoding is rarely used - because 'combine format' is developed for ancient characters (those which are no longer used)
[11:08:55] <Maxdamantus> Well, if you convert to NFC or NFKC for whatever reason, you'll have those separate code points.
[11:08:55] *** Quits: bitdex (~bitdex@gateway/tor-sasl/bitdex) (Ping timeout: 240 seconds)
[11:09:03] <Maxdamantus> er, NFD or NFKD*
[11:10:15] *** Joins: bitdex (~bitdex@gateway/tor-sasl/bitdex)
[11:10:31] <Maxdamantus> but sure, in general it's usually more sensible to generate precomposed code points where possible. that includes "Ã©" just as much as "ê°•".
[11:10:46] <abastro[m]> Oh, yep I was going to ask that
[11:10:48] *** alMalsamo is now known as lumberjack123
[11:10:59] <abastro[m]> * ask that: Is precomposed codepoints normally used
[11:11:21] *** Quits: alp (~alp@user/alp) (Ping timeout: 252 seconds)
[11:11:33] <Maxdamantus> https://docs.rs/bstr/0.2.13/bstr/#when-should-i-use-byte-strings
[11:14:01] <abastro[m]> > UTF-8 by convention is a better trade off in some circumstances than guaranteed UTF-8
[11:14:01] <abastro[m]> What does this mean?
[11:14:02] <lambdabot>  <hint>:1:43: error: parse error on input â€˜inâ€™
[11:14:21] <Maxdamantus> In Rust, the standard string type `str` is guaranteed to be valid UTF-8.
[11:14:25] <c_wraith> abastro[m]: it means that sometimes it's better to not actually parse the data
[11:15:12] <abastro[m]> Oh, not parsing the data
[11:15:14] <Maxdamantus> So when constructing a `str` from `[u8]`, the constructor will raise an error if the data is not well-formed UTF-8.
[11:15:17] <c_wraith> which is certainly true.  Lots of applications where it's better to just store the bytes you receive
[11:15:52] <Maxdamantus> imo the main problem with doing that is that you end up with lots of cases where you legitimately want to deal with "strings" that potentially are not UTF-8, and then you have to do something really weird.
[11:16:08] <abastro[m]> So it does validation? I guess extra validation pass would indeed cost some more
[11:16:18] <Maxdamantus> eg in Rust, you've got `str`, `OsStr`, `[u8]`. I think there's something else too, but I haven't used Rust much.
[11:16:58] <abastro[m]> str is internally just [u8] validated as UTF8, right?
[11:17:05] <Maxdamantus> Yes.
[11:17:38] <Maxdamantus> It doesn't maintain any extra information, so eg, the length of a `str` is just the number of UTF-8 code units.
[11:18:07] <Maxdamantus> It just provides some nice UTF-8 abstractions on top, which is how Unicode handling should normally work.
[11:18:24] <Maxdamantus> (though preferably without the validation constraint, which leads to messy APIs)
[11:19:16] <abastro[m]> Hmm, unicode business is indeed complex
[11:20:09] *** Quits: sloorush (~sloorush@136.233.9.99) (Ping timeout: 256 seconds)
[11:20:12] *** Quits: lavaman (~lavaman@c-174-63-118-52.hsd1.ma.comcast.net) (Ping timeout: 240 seconds)
[11:20:32] <Maxdamantus> The main problem is that people think they need to do something special with the complexity in many more cases than they actually do.
[11:20:47] *** Quits: acidsys (~LSD@2a03:4000:55:d20::3) (Excess Flood)
[11:21:18] *** Joins: acidsys (~LSD@2a03:4000:55:d20::3)
[11:21:23] <abastro[m]> Hmm
[11:22:40] <Maxdamantus> Unicode was designed such that you don't normally have to deal with that complexity. A string is just a sequence of code units. Most applications are only concerned with passing strings around or matching equal strings, or occasionally concatenating strings, all of which can be done on code units, and none of which necessitate a well-formedness check.
[11:24:04] <Maxdamantus> If you're doing something like rendering text, then you need to deal with the complexity. Also, in some cases when you're doing some sort of search, you might need to deal with some normalised form.
[11:24:09] *** Joins: img (~img@user/img)
[11:25:20] <Maxdamantus> Usually when people claim that Unicode is hard, they use examples of nonsensical operations like reversing text, which noone ever actually wants to do.
[11:25:45] <hololeap> I have a 'package *' stanza and 'ghc-options:' in it, inside of cabal.project.local. it doesn't seem like these options are being used. what would be a good way to test this to be sure?
[11:26:47] *** Quits: Batzy (~quassel@user/batzy) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
[11:27:30] <Maxdamantus> % putStrLn $ reverse "á„‹á…¡á†¨"
[11:27:30] <yahb> Maxdamantus: á†¨á…¡á„‹
[11:27:56] *** Joins: Batzy (~quassel@user/batzy)
[11:30:39] <hololeap> am I doing this right? https://dpaste.com/GFKKMJX6P
[11:31:53] <abastro[m]> As you have -Wall there, you can try sth like `ff:: [Int] -> [Int]; ff [] = []` and see if it reports incomplete pattern matching.
[11:32:33] *** Joins: cfricke (~cfricke@user/cfricke)
[11:34:35] *** Quits: [itchyjunk] (~itchyjunk@user/itchyjunk/x-7353470) (Read error: Connection reset by peer)
[11:37:08] *** Quits: tzh (~tzh@c-24-21-73-154.hsd1.or.comcast.net) (Quit: zzz)
[11:39:35] *** Quits: bitdex (~bitdex@gateway/tor-sasl/bitdex) (Ping timeout: 240 seconds)
[11:39:35] *** Quits: nicbk (~nicbk@user/nicbk) (Ping timeout: 240 seconds)
[11:41:06] *** Quits: benin (~benin@183.82.26.94) (Quit: The Lounge - https://thelounge.chat)
[11:41:36] *** Joins: bitdex (~bitdex@gateway/tor-sasl/bitdex)
[11:41:42] *** Joins: nicbk (~nicbk@user/nicbk)
[11:43:00] *** Joins: whatsupdoc (uid509081@id-509081.hampstead.irccloud.com)
[11:43:26] *** Joins: acidjnk (~acidjnk@pd9e0b763.dip0.t-ipconnect.de)
[11:52:35] *** Quits: bitdex (~bitdex@gateway/tor-sasl/bitdex) (Ping timeout: 240 seconds)
[11:55:02] *** Joins: _ht (~quassel@231-169-21-31.ftth.glasoperator.nl)
[11:55:08] *** Joins: bitdex (~bitdex@gateway/tor-sasl/bitdex)
[11:57:53] *** Quits: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com) (Ping timeout: 256 seconds)
[11:59:22] <sclv> hololeap: you can use the verbose flag
[12:00:34] <sclv> also i think youâ€™re right. currently you need to enumerate options for each local package individually. the * confusingly enough, i think, only refers to nonlocal packages.
[12:02:32] <sclv> Maxdamantus: what about slicing strings? thats tricky, and also common.
[12:03:09] <sclv> or dealing with right to left script, especially admixed with regular script
[12:06:26] <abastro[m]> Right to left, hm..
[12:06:37] <abastro[m]> How is it dealt in unicode?
[12:08:00] <Maxdamantus> sclv: slicing works on code units as well, you just need to know where to slice from.
[12:08:21] <Maxdamantus> sclv: usually you'd want to slice after searching for a substring or something, which is fine.
[12:08:34] <sclv> well yes, but thats the slightly tricky bit
[12:08:39] *** Joins: mmhat (~mmh@55d48f06.access.ecotel.net)
[12:08:57] <Maxdamantus> What? Searching for a substring? All of the UTFs are designed such that substring searches work.
[12:10:07] *** Joins: mikoto-chan (~mikoto-ch@213.177.151.239)
[12:10:33] <Maxdamantus> If you remove a well-formed substring of a well-formed UTF code unit sequence, you will still have a well-formed code unit sequence.
[12:10:36] *** Joins: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com)
[12:10:58] <Maxdamantus> There's no overlap, eg, https://news.ycombinator.com/item?id=30266023
[12:11:00] <sclv> right. but you have to work code unit wise not bytewise.
[12:11:06] <sclv> thatâ€™s all.
[12:11:22] <Maxdamantus> code units are bytes (in UTF-8).
[12:11:45] <Maxdamantus> in UTF-16, code units are 16-bit values.
[12:11:55] <Maxdamantus> in UTF-8, code units are 8-bit values (aka bytes).
[12:12:01] <Maxdamantus> in UTF-32, code units are 32-bit values.
[12:12:22] <sclv> i should have said code point wise, not code unit wise
[12:12:49] <Maxdamantus> Why do you think you have to work code point-wise?
[12:13:07] *** Quits: Sgeo (~Sgeo@user/sgeo) (Read error: Connection reset by peer)
[12:13:19] <Maxdamantus> If you search for a substring and get a position in code units, you can use that code unit position to slice the string.
[12:13:27] <sclv> because you shouldnâ€™t split a codepoint down the middle. you want to work with logical characters
[12:13:33] <Maxdamantus> It works whether you're using code points or code units.
[12:13:42] *** Joins: lortabac (~lortabac@2a01:e0a:541:b8f0:4242:d6b8:d93f:54e5)
[12:13:50] <Maxdamantus> So don't search for partial code points.
[12:14:04] <sclv> your substring search should give back code points not units. and you shouldnâ€™t be able to split a code point in two
[12:14:14] <sclv> if your types permit this, thats a bad api
[12:14:18] <Maxdamantus> It should give back an offset that can be used to slice the string.
[12:14:33] <sclv> so youâ€™re saying to not enforce the abstration?
[12:14:55] <sclv> â€œlet users shoot themselves in the foot?â€
[12:15:00] <Maxdamantus> You mean enforce well-formedness? Correct. I'm saying not to enforce well-formedness. That's how Unicode was designed to work.
[12:15:15] <Maxdamantus> Unicode doesn't expect strings to always be well-formed, because it was designed as an encoding on top of code units.
[12:15:19] *** Joins: lavaman (~lavaman@c-174-63-118-52.hsd1.ma.comcast.net)
[12:15:21] *** Quits: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com) (Ping timeout: 245 seconds)
[12:15:22] <sclv> thats silly
[12:15:30] <sclv> haskellers like well formed things
[12:15:43] <Maxdamantus> No, what's silly is making an API that claims that filenames are well-formed UTF-8 strings.
[12:15:47] <sclv> if a user can write an ill formed thing they will
[12:15:58] <sclv> i agree on that but not because unicode
[12:16:16] <sclv> filenames are not even necessarily unicode encoded
[12:16:20] <Maxdamantus> Exactly.
[12:16:25] <Maxdamantus> Neither are text files.
[12:16:29] <sclv> theyâ€™re bytes with locale dependent interpretation
[12:16:37] <sclv> unicode is irrelevant
[12:16:41] <Maxdamantus> but grep works on Unicode text files anyway. It doesn't care whether it's well-formed UTF-8.
[12:16:50] <Maxdamantus> this is by design of UTF-8.
[12:16:51] <sclv> there is no such thing as a â€œtext fileâ€
[12:17:00] <Maxdamantus> Exactly.
[12:17:03] <sclv> there is a file as a sequence of bytes
[12:17:21] <sclv> unicode is one interpretation of the file
[12:17:22] <Maxdamantus> Indeed. If the data exists outside of the application, it's bytes.
[12:17:45] <Maxdamantus> And Unicode was designed to allow people to make it so that those bytes represent human text.
[12:17:51] <sclv> but in the app, we like to enforce well formed representation and keep the problems at the barrier
[12:18:08] <sclv> if the types let people write ill formed things, they will
[12:18:09] <Maxdamantus> But that doesn't match reality, which is bytes.
[12:18:18] *** Joins: machinedgod (~machinedg@24.105.81.50)
[12:18:29] <sclv> well why have floats or integers then? its all bytes!!
[12:18:35] <sclv> we use haskell, not c
[12:18:38] <Maxdamantus> If the types claim something counter to reality, your program will crash.
[12:18:45] <sclv> Not in haskell!
[12:18:57] <sclv> Because the types here donâ€™t lie.
[12:19:02] <sclv> Thats the whole point
[12:19:12] <Maxdamantus> Yes, so Haskell will crash on non-UTF-8 data.
[12:19:13] <abastro[m]> Hm, lengthy discussion
[12:19:13] <Maxdamantus> That's bad.
[12:19:36] <sclv> no, text in haskell is guaranteed well formed
[12:19:48] <sclv> thats what the text library gives you
[12:19:51] <abastro[m]> Non-UTF-8 data is not supposed to be String, right?
[12:19:57] <Maxdamantus> The text library doesn't generate data.
[12:20:01] <Maxdamantus> Data comes from outside the application.
[12:20:04] <sclv> a string is a sequence of codepoints
[12:20:10] <Maxdamantus> Not according to Unicode.
[12:20:16] <Maxdamantus> According to Unicode, a string is a sequence of code units.
[12:20:29] <Maxdamantus> And they are not expected to always be well-formed.
[12:20:34] <Maxdamantus> Unicode explicitly says this.
[12:20:56] <sclv> In haskell the literal string type is a list of characters and characters are code units
[12:21:17] <sclv> I donâ€™t care if unicode defines â€œstringâ€ differently
[12:21:40] <Maxdamantus> Haskell has an even weirder handling of Unicode, since it has code points but it doesn't enforce use of scalar values.
[12:21:54] <sclv> when parsing in bytes you get back either the answer or an error you can handle
[12:21:57] <sclv> Sigh
[12:22:18] <Maxdamantus> % putStrLn [toEnum 0xd800]
[12:22:18] <yahb> Maxdamantus: *** Exception: <stdout>: hPutChar: invalid argument (invalid character)
[12:22:54] <Maxdamantus> What sort of string is "\55296"?
[12:23:19] <sclv> ok but can you do that with Text which is the proper abstraction?
[12:23:41] <abastro[m]> So String is indeed wrong abstraction, right
[12:23:42] <Maxdamantus> What OS API gives back `Text`?
[12:24:14] <sclv> they all give back bytes. but we enforce abstraction at the boundaries when possible
[12:24:20] *** Quits: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net) (Remote host closed the connection)
[12:24:28] <sclv> thats what you are dismissing
[12:24:38] <sclv> is enforcing abstraction at the boundaries
[12:24:41] <Maxdamantus> If you do that, your program will crash unnecessarily.
[12:24:55] <sclv> no, if you do that it wonâ€™t crash
[12:24:55] *** Joins: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net)
[12:25:01] <sclv> thats the point
[12:25:03] <Maxdamantus> It would suck having a `grep` that crashes as soon as it sees some ill-formed UTF-8.
[12:25:23] <sclv> nobody is arguing it should
[12:25:33] <sclv> youâ€™re arguing against a straw man
[12:26:00] <sclv> but sometimes you want actual well formed text and to enforce that. how hard is that to grok!?
[12:26:02] <Maxdamantus> You're arguing that text inputs should be enforced as well-formed Unicode.
[12:26:09] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 252 seconds)
[12:26:11] <sclv> when it makes sense, yes
[12:26:12] <Maxdamantus> "sometimes", sure.
[12:26:28] <sclv> grep isnâ€™t something thats about text. it is
[12:26:32] <Maxdamantus> So you can have an assertion for that, or even come up with a wrapper type.
[12:26:34] <sclv> about bytes
[12:26:49] <sclv> we have that type. it is called text!!
[12:27:03] <sclv> We have the other type too. it is called bytestring!
[12:27:14] <Maxdamantus> Do you intentionally grep binary files?
[12:27:22] <sclv> we can pick the one we want. it rules!
[12:27:29] <sclv> (sometimes, yes)
[12:27:33] <Maxdamantus> I mean .. grep does have a "binary" mode (as opposed to the default "text" mode).
[12:27:48] <Maxdamantus> but usually you expect to use grep in text mode, where it prints out the lines that are matched.
[12:27:53] <Maxdamantus> it's very much text-based.
[12:28:01] *** Joins: fef (~thedawn@user/thedawn)
[12:28:09] <sclv> i am aware
[12:28:12] *** Quits: _ht (~quassel@231-169-21-31.ftth.glasoperator.nl) (Remote host closed the connection)
[12:28:22] *** Joins: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com)
[12:29:22] <abastro[m]> I guess one point of debate is, if a string of nonstandard encoding should be counted as string or not.
[12:29:28] <Franciman> Maxdamantus: there is bytestring for dealing with possibly invalid utf8
[12:29:32] *** Quits: Akiva (~Akiva@user/Akiva) (Ping timeout: 240 seconds)
[12:29:37] *** Quits: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net) (Ping timeout: 240 seconds)
[12:29:48] <Franciman> if you use lazy bytestrings, you can have lazy decoding composed 
[12:29:51] <Maxdamantus> Franciman: sure, but noone wants to pass `ByteString`s around because nothing accepts them.
[12:30:04] <Maxdamantus> Franciman: printing bytestrings is annoying.
[12:30:05] <Franciman> lazy decoding!
[12:30:09] <Franciman> to a text
[12:30:11] <Franciman> look
[12:30:17] <Franciman> :t decodeUtf8
[12:30:18] <lambdabot> error: Variable not in scope: decodeUtf8
[12:30:19] <Franciman> ofc
[12:30:43] <Franciman> https://hackage.haskell.org/package/text-2.0/docs/Data-Text-Encoding.html#v:decodeUtf8-39-
[12:30:46] <Franciman> here you can catch the error
[12:30:46] <Maxdamantus> That gives you back a `String` iirc, which is inappropriate.
[12:30:53] <Franciman> it gives back a text!
[12:30:54] <Maxdamantus> or a `Text`, I guess.
[12:31:00] <Maxdamantus> again, inappropriate.
[12:31:05] <Franciman> what do you need?
[12:31:07] *** Joins: vglfr (~vglfr@88.155.11.162)
[12:31:13] <Maxdamantus> Some text to print to stdout.
[12:31:21] <Maxdamantus> putStrLn myText
[12:31:36] <Franciman> i don't understand why the previous types are innapropriate, then
[12:31:40] <Maxdamantus> Why do I care if it's well-formed? If a user inputs ill-formed data, that's their problem. GIGO.
[12:32:13] <Franciman> then just use text, and when catching the exception, print "GIGO, input is ill formed"
[12:32:27] <Maxdamantus> But that's not the intended behaviour.
[12:32:38] <Franciman> so you care if it's ill formed?
[12:32:39] <Maxdamantus> If a user enters a string, I want to print back their string.
[12:32:48] <Franciman> then you want to print out bytes 
[12:32:49] <Maxdamantus> If a user enters a garbage string, I want to print back their garbage string.
[12:33:00] <Franciman> and let the console handle the encoding for you
[12:33:02] <Maxdamantus> No, I don't care whether it's well-formed.
[12:33:20] <Maxdamantus> Most programs shouldn't care whether their inputs are well-formed, since all they're doing is passing them to something else.
[12:33:27] <Maxdamantus> and again, GIGO.
[12:34:06] <Maxdamantus> read some text from a file, write the text to another file. There's no need to add a corner case for ill-formed data.
[12:34:40] <abastro[m]> Uhm, if you just read a text from a file into another, then you could use ByteString to do the task
[12:34:41] <Franciman> i would use ByteString and print it with https://hackage.haskell.org/package/bytestring-0.11.3.0/docs/Data-ByteString.html#v:putStr
[12:35:33] <Maxdamantus> Franciman: the point is there is no need for a separate `ByteString` type.
[12:35:51] <Maxdamantus> The standard `String` type should be able to cater to both use cases, by itself being a byte string.
[12:35:57] <Franciman> String is a list
[12:36:07] <Franciman> it's a synonym with [Char]
[12:36:14] <Maxdamantus> I'm aware.
[12:36:33] <Franciman> and Char is a codepoint, a 32bit integer
[12:36:43] <Franciman> it can't deal with utf8
[12:36:45] <Franciman> or 16
[12:36:47] <Franciman> or whatever
[12:36:56] <sclv> the type you want would be [byte] not list of char
[12:37:00] <sclv> we have that too
[12:37:05] <Maxdamantus> Actually, it's not a particular number of bits. It's a value in the range [0..0x10ffff]
[12:37:17] <sclv> but we have bytestring because it is more efficient
[12:37:44] <Franciman> also i think having a type which guarantees well formed text is important in many cases
[12:38:28] <Franciman> tautologically, when you have to ensure that the input is well formed :P
[12:38:35] <Franciman> Text is a proof that input is well formed
[12:38:46] <Maxdamantus> It might be useful in a small number of cases, but in general it only adds unnecessary corner cases where your program is just going to crash instead of passing the user's data through.
[12:39:00] <Franciman> if you don't need it, you use a stream of bytes. After decoding the stream of bytes, if successful you have proof of correctness
[12:39:06] <Franciman> and i like that it's retained in the type system
[12:39:25] *** Joins: dschrempf (~dominik@070-207.dynamic.dsl.fonira.net)
[12:39:27] <Maxdamantus> It should be a conscious decision to reject ill-formed Unicode. It shouldn't be the default.
[12:39:54] <Maxdamantus> There are very few cases where it's actually useful.
[12:39:59] *** Joins: alp (~alp@user/alp)
[12:40:09] <Maxdamantus> And there are lots of cases where users are going to be glad that your program doesn't break on ill-formed input.
[12:40:10] <Franciman> Maxdamantus: if you have to deal with both ill formed and well formed unicode, then character accessing rutines get more difficult
[12:40:12] <Maxdamantus> eg, grep.
[12:40:21] <Franciman> you have to always deal with two cases to access the n-th character
[12:40:27] *** Joins: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net)
[12:40:32] <Franciman> what's the n-th code point of an ill formed input sequence?
[12:40:52] <Maxdamantus> Franciman: where does `n` come from?
[12:41:25] <Maxdamantus> Is it a constant value you've hardcoded into your program? What does it mean?
[12:41:43] <abastro[m]> Hm, I guess many uses of String is going to be ill-formed - since one might just need to pass "string"s around in quite a many cases.
[12:41:44] <Maxdamantus> This sounds like another one of these nonsense operations, like reversing a string.
[12:41:46] <Franciman> https://hackage.haskell.org/package/text-2.0/docs/Data-Text.html#v:take
[12:41:50] <Franciman> for exaple this function
[12:41:58] <Maxdamantus> Franciman: my question stands.
[12:42:31] <Maxdamantus> Franciman: there's also a `reverse` function. Doesn't mean it's useful.
[12:42:44] <Maxdamantus> Franciman: `take` makes sense if you've measured a substring.
[12:43:06] <Franciman> Maxdamantus: so you seem to imply that there is no need to have static guarantees that the input string is well formed
[12:43:08] <Franciman> ever
[12:43:18] <Maxdamantus> Franciman: in which case `n` is just the length of some other string. Whether it was measured in bytes or code units or glyphs should be irrelevant, just as long as it's consistent.
[12:43:45] <Franciman> and it would be nice if the compiler could check that it's consistent
[12:43:46] <Maxdamantus> Franciman: I wouldn't say "not ever"
[12:43:51] <Maxdamantus> 21:08:46 < Maxdamantus> It might be useful in a small number of cases, but in general it only adds unnecessary corner cases where your program is just going to crash instead of passing the user's data through.
[12:44:00] <Franciman> Maxdamantus: if there is at least one case, i don't see why we can't have a library for dealing with it 
[12:44:17] <Maxdamantus> Franciman: if you want to make it consistent, don't provide `ByteString` and `Text`
[12:44:19] <Franciman> so i don't understand your whole proposal of "it's useless to have distinct types"
[12:44:24] <Franciman> i dont' see why!
[12:44:29] <Franciman> they serve different purposes
[12:44:35] *** Quits: mikoto-chan (~mikoto-ch@213.177.151.239) (Quit: mikoto-chan)
[12:44:36] *** Quits: xff0x (~xff0x@125x102x200x106.ap125.ftth.ucom.ne.jp) (Ping timeout: 240 seconds)
[12:44:55] <Maxdamantus> Franciman: because it's unnecessarily introducing an additional string length, one based on a concept that is useless in all other cases.
[12:45:05] <Maxdamantus> https://hsivonen.fi/string-length/
[12:45:38] <Franciman> they are distinct types
[12:45:41] <Franciman> with distinct requirements
[12:45:51] <Franciman> and serve different purposes
[12:45:56] <Franciman> you use which one suits you best in each case
[12:46:30] <Franciman> as you said: `n` is just the length of some other string, whether misured in bytes, or code units or glyphs should be irrelevant, just as long as it's consistent
[12:46:34] <Franciman> the types give you the consistency
[12:46:40] <Franciman> if you use the bytestring interface it's bytes
[12:46:48] <Franciman> if you use the text interface it's codepoints IIUC
[12:46:49] <Maxdamantus> Right, so when is it *useful* for that `n` to be based on code points?
[12:47:05] <Maxdamantus> Yes, it's only useful for using `Text`.
[12:47:21] <Maxdamantus> So a code point length is used by `Text` because it's useful for `Text`.
[12:47:26] <Maxdamantus> Recursive logic.
[12:47:37] <Maxdamantus> code point lengths don't exist in the outside world.
[12:47:40] *** Joins: dhouthoo (~dhouthoo@178-117-36-167.access.telenet.be)
[12:47:43] <Franciman> i used it for my lexer
[12:47:59] <Franciman> and it was easier to use rather than bytestring
[12:48:09] <Franciman> and it was acceptable to reject ill formed utf8
[12:48:16] <Franciman> so it was much easier to work with Text than raw bytes
[12:48:32] <Franciman> and Text gives me the static guarantees to work that way, with an easier interface
[12:48:44] <Franciman> which i know is statically guaranteed to talk about codepoints, rather than bytes
[12:50:41] *** Joins: chele (~chele@user/chele)
[12:51:24] <Maxdamantus> So what `Text` operations were you able to use that made it easier, and why could they not be implemented on byte strings?
[12:51:36] *** Quits: lavaman (~lavaman@c-174-63-118-52.hsd1.ma.comcast.net) (Ping timeout: 245 seconds)
[12:52:06] <Maxdamantus> If you want to reject ill-formed UTF-8, that's fine. There can be an `isWellFormed` function that checks that, and you can throw an error if someone gives you text that doesn't pass that check.
[12:52:27] <Franciman> bytecode only has single byte operations
[12:52:36] <Franciman> so you have to manually check where each codepoint starts
[12:53:03] <Maxdamantus> What does your lexer actually do? Is it not based on substring searching? That works on byte strings.
[12:53:36] <Maxdamantus> Not sure about Haskell `ByteString`, I'd have to look it up.
[12:54:14] <Maxdamantus> Right, there's `breakSubstring`
[12:54:31] <Maxdamantus> so you could presumably use something like `breakSubstring " "` if you want to separate by a space.
[12:54:34] *** Joins: jgeerds (~jgeerds@55d4548e.access.ecotel.net)
[12:54:48] <Franciman> yes
[12:55:19] <Maxdamantus> And there should preferably also be a way of checking if the string starts with a given string, since that's also very useful in a lexer.
[12:55:19] <abastro[m]> What is codepoint btw, really?
[12:55:32] <Franciman> it's a number representing something
[12:55:55] <Franciman> i don't remember if it represent a glyph or there is an intermediate step
[12:56:10] <Maxdamantus> abastro[m]: technically, it's a number between 0x0 and 0x10FFFF (inclusive), normally denoted as `U+0000` to `U+10FFFF`
[12:56:23] <Franciman> Maxdamantus: so are you trying to argue that Text is useless and everybody should use ByteString?
[12:56:24] <abastro[m]> Hm I don't think it represents glyph
[12:57:04] <Maxdamantus> abastro[m]: though there are code points that are not allowed to be encoded in Unicode, particularly U+D800 to U+DFFF (inclusive). Excluding those invalid code points gives you the set of "Unicode scalar values".
[12:58:03] <Maxdamantus> abastro[m]: Unicode defines a meaning for lots of the Unicode scalar values, and it defines three encodings, UTF-8, UTF-16 and UTF-32 that are able to encode sequences of Unicode scalar values to sequences of 8-bit, 16-bit or 32-bit code units respectively.
[12:58:13] *** Joins: vorpuni (~pvorp@2001:861:3881:c690:b51e:da9f:aa64:a038)
[12:58:33] <abastro[m]> So it is just a scalar values, which does not represent anythint
[12:59:02] <Maxdamantus> abastro[m]: correct. They don't necessarily represent a glyph. eg, I can write a glyph like "aÌ" as [U+61 U+301], using those two code points.
[12:59:06] <abastro[m]> Just some unit of representing a symbol, which is then combined to form glyphs, graphemes and suxh
[12:59:35] <Franciman> is U+61 alone a glyph?
[12:59:47] <abastro[m]> I guess that is the crux of argument against using codepoint array/list
[12:59:47] <Maxdamantus> Yes, usually.
[13:00:05] <Franciman> yes one would need also a normalized chunk of text
[13:00:07] <Maxdamantus> U+61 is 'a'
[13:00:12] <abastro[m]> Oh wow, glyph business is complicated
[13:00:19] <Franciman> oh i mean u+301 sorry xD
[13:00:52] <Maxdamantus> then no, U+301 is not really a glyph on its own. It's a "combining character" which can be added to other glyphs.
[13:01:26] <Franciman> btw working on codepoints is still nice when you want to know which category they belong with
[13:01:36] <Franciman> that's why i used text rather than bytestring
[13:01:39] <[exa]> unicode defines characters (i.e., tiny pieces with semantic meaning), not glyphs (unless the character explicitly refers to some kind of a glyph)
[13:01:49] <Maxdamantus> There's no reason why a decent byte string library couldn't offer that.
[13:02:06] <Franciman> Maxdamantus: because haskell's bytestring deals with bytes
[13:02:35] <Maxdamantus> It could offer a function `splitFirstCodePoint :: ByteString -> (Maybe Char, ByteString)`
[13:02:40] <Franciman> it's a separation of concerns
[13:02:43] <abastro[m]> How do you get category from a codepoint?
[13:02:54] <Franciman> there are huge tables lol
[13:03:01] <[exa]> Maxdamantus: you may eventually notice that the current selection of string libraries already packs a bit of survivor bias :]
[13:03:06] <Maxdamantus> or `splitFirstCodePoint :: ByteString -> (Either Char Word8, ByteString)`
[13:03:19] <[exa]> abastro[m]: you look it up a table encoded in libicu or something
[13:03:35] <abastro[m]> Oh, so codepoint does mean something then
[13:03:48] <abastro[m]> (Albeit only occasionally)
[13:04:13] <abastro[m]> Anyway, I wonder if it is good practice to use `Text` for a file name
[13:04:19] <Franciman> btw i agree that unicode is very complicated, and most of the time working on single codepoints isn't enough
[13:04:36] <Franciman> but albeit it's user friendly lol
[13:04:50] <Franciman> because it provides a simplified model
[13:04:57] <Maxdamantus> abastro[m]: my overall point has been that people shouldn't be pushed into doing that.
[13:05:20] <Franciman> abastro[m]: depends on the platform
[13:05:25] <Franciman> iiuc on linux no
[13:05:33] <Franciman> because linux paths can contain invalid utf8
[13:05:50] <Maxdamantus> Haskell has `type FilePath = String`, which is just as problematic as `Text`
[13:05:56] <Franciman> yes
[13:06:00] <Franciman> true
[13:06:28] <tomsmeding> sm: so basically you want soft-wrapping of the paste? That's been on my todo list for a while :)
[13:06:36] *** Joins: doyougnu (~doyougnu@cpe-67-249-83-190.twcny.res.rr.com)
[13:06:40] <abastro[m]> I guess `type FilePath = String` is one huge problem
[13:06:45] <abastro[m]> Separate FilePath type would be great
[13:06:59] <abastro[m]> Tho it would be breaking change :<
[13:07:04] <Maxdamantus> actually, arguably I guess someone could come up with an encoding for ill-formed UTF-8 into `String` (Python 3 did this .. a few months after release when they realised it was a problem).
[13:07:22] <Maxdamantus> but that thing that Python does is a hack.
[13:07:29] <Maxdamantus> Python 3*
[13:07:53] *** Joins: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl)
[13:08:16] <Maxdamantus> https://peps.python.org/pep-0383/
[13:09:11] <Maxdamantus> So since Python 3 strings can also represent invalid code points (in the range 0xD800 to 0xDFFF), it uses that range to encode ill-formed UTF-8.
[13:09:13] <Hecate> abastro[m]: maerwald[m]: is on it already
[13:09:31] *** Quits: vglfr (~vglfr@88.155.11.162) (Ping timeout: 256 seconds)
[13:09:38] <abastro[m]> Oh, changing FilePath?
[13:09:41] <Maxdamantus> abastro[m]: my point is that there shouldn't be a separate type.
[13:09:47] <abastro[m]> It would be great! ..but at what cost
[13:10:01] <Hecate> abastro[m]: the price to pay for shitty design
[13:10:10] <Maxdamantus> There should be one type that is usable for the vast majority of strings, and that type is basically a wrapper around byte strings.
[13:10:12] <abastro[m]> Hahaha
[13:10:29] <abastro[m]> Btw, It would be great to have FilePath /= ByteString or Text, indeed
[13:10:40] <Maxdamantus> Then when people design APIs, they know which string to use, and don't have to pick between `String`, `ByteString`, `Text`, `FilePath`, whatever.
[13:10:43] *** Quits: dextaa_ (~dextaa@user/dextaa) (Remote host closed the connection)
[13:10:47] <abastro[m]> More utilities to have for FilePath.. but yea it would involve OS business
[13:10:55] <dibblego> just use lens and defer the decision, since there is no winner anyway
[13:10:56] *** Joins: vglfr (~vglfr@88.155.11.162)
[13:15:23] <abastro[m]> One of criticism against haskell was that it has too many types for string, but I think rust took that now.
[13:16:03] <Maxdamantus> Yes, Rust also has a bunch of hacks to work around this issue.
[13:16:11] <Maxdamantus> `str`, `OsStr`, `[u8]`
[13:16:28] <abastro[m]> There would surely be a reason for that, right
[13:16:43] <Maxdamantus> and ime, libraries often end up providing filesystem functions for both `&str` and `&OsStr`
[13:16:54] <abastro[m]> At least their `str` is not linked list of code points
[13:16:57] <Maxdamantus> Yes, because `str` is guaranteed well-formed.
[13:17:08] <Maxdamantus> If they didn't have that unnecessary restriction, there would only be one string type.
[13:17:12] *** Joins: mikoto-chan (~mikoto-ch@84.199.144.235)
[13:17:19] <Maxdamantus> and APIs wouldn't have to decide whether to use `str` or `OsStr`.
[13:17:24] <abastro[m]> Wouldn't converting OsStr into str and back trivial?
[13:17:45] <Maxdamantus> No. Some `OsStr`s can't be converted to `str`, because they contain ill-formed Unicode.
[13:18:35] <Hecate> I just want three types in my life: a grapheme cluster, a binary blob, and an FFI blob
[13:18:47] <abastro[m]> I mean, at least when we have expectation that it is str
[13:18:48] *** Joins: Pickchea (~private@user/pickchea)
[13:20:10] <Maxdamantus> another interesting one is Raku .. Raku decided to make its strings be a sequence of grapheme clusters, which are very awkward to actually detect.
[13:20:51] <Maxdamantus> it also has a funny hack for handling ill-formed strings, and they've changed it a few times to handle extra cases they didn't think of, particularly because they automatically normalise strings too.
[13:21:38] <Hecate> https://hexdocs.pm/elixir/String.html#content <- I like this page a lot
[13:21:43] *** Joins: MajorBiscuit (~MajorBisc@wlan-145-94-218-48.wlan.tudelft.nl)
[13:21:47] <abastro[m]> Hm I recall some names not being valid unicode btw
[13:21:50] <Hecate> especially this section https://hexdocs.pm/elixir/String.html#module-code-points-and-grapheme-cluster
[13:22:08] <Hecate> abastro[m]: "some names" is quite vague, like people's names?
[13:22:13] *** Quits: vglfr (~vglfr@88.155.11.162) (Ping timeout: 240 seconds)
[13:22:23] <Hecate> because their alphabet wasn't incorporated into the Unicode standard?
[13:22:27] <Maxdamantus> Basically, there are "synthetic" grapheme clusters that look something like "\u101000xFF", which are distinct from strings that are literally written that way in the source code (in which case the string is made up of 4 grapheme clusters, "\u101000", "x", "F", "F".
[13:22:29] <abastro[m]> Yea, people's names
[13:22:39] <abastro[m]> I recall seeing the article. Yes, likely because not incorporated
[13:23:24] *** Joins: zeenk (~zeenk@2a02:2f04:a110:7d00:2011:cfed:bad7:3c94)
[13:23:28] <Hecate> abastro[m]: yeah, then it's not something that can be actionable at the PL level
[13:23:49] <Maxdamantus> and I reported some bugs for weird behaviour with their handling of grapheme clusters. you can construct a well-formed UTF-8 string that's about 140 KiB, but when read in Raku it allocates about 20 GiB of memory.
[13:24:01] <Hecate> Maxdamantus: oh that's vile :D
[13:24:05] <abastro[m]> Well, you could use ByteString for the names
[13:24:12] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 240 seconds)
[13:24:29] <Hecate> abastro[m]: which you still have to decode into UTF-8 or UTF-16 or latin1 if you want to display :-P
[13:24:30] <Maxdamantus> https://github.com/MoarVM/MoarVM/issues/1648
[13:24:40] <Hecate> otherwise it's an opaque string and doesn't serve the basic purpose of a name ;-)
[13:24:58] <abastro[m]> Hm, I think names do have more purpose than display
[13:25:06] <Maxdamantus> 240 KiB, not 140 KiB.
[13:25:23] *** Joins: mc47 (~mc47@xmonad/TheMC47)
[13:25:26] <abastro[m]> Like some part of the identification
[13:25:39] <Hecate> abastro[m]: I agree with you but I think the display of a name in a computer system is the root of most of these other purposes
[13:26:00] *** Quits: MajorBiscuit (~MajorBisc@wlan-145-94-218-48.wlan.tudelft.nl) (Client Quit)
[13:26:09] *** Joins: MajorBiscuit (~MajorBisc@wlan-145-94-218-48.wlan.tudelft.nl)
[13:26:13] <Hecate> yes but then you'd have to support entering non-unicode stuff in all the chain of equipment and software that leads to this name being compared in the database
[13:26:17] <abastro[m]> I recall many pages which combines name and other properties for identification process
[13:26:18] <Hecate> so, the keyboard must support it
[13:26:25] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[13:28:00] <abastro[m]> Keyboard? Uhm
[13:28:12] <abastro[m]> There are tons of input methods
[13:29:04] <merijn> I mean, I can't even properly write my IRC name on IRC, because no non-ascii allowed >.>
[13:29:58] <abastro[m]> Oh...
[13:30:09] *** Quits: considerate[m] (~considera@2001:470:69fc:105::1:c2aa) (Quit: You have been kicked for being idle)
[13:30:15] <abastro[m]> Yea language support in programming is rather tenuous
[13:30:29] <abastro[m]> https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/ I guess this is the article
[13:30:53] *** Quits: jgeerds (~jgeerds@55d4548e.access.ecotel.net) (Ping timeout: 268 seconds)
[13:32:17] *** Quits: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com) (Ping timeout: 240 seconds)
[13:34:27] <tomsmeding> merijn: that's kind of stretching dutch spelilng :p
[13:34:36] *** Joins: fendor (~fendor@91.141.35.69.wireless.dyn.drei.com)
[13:34:45] <tomsmeding> other people on this planet have more right to that statement
[13:35:16] <Hecate> astra: I'll do you one better: https://shinesolutions.com/2018/01/08/falsehoods-programmers-believe-about-names-with-examples/
[13:36:27] <merijn> tomsmeding: My name has 5 letters, new-fangled revisionism be damned! >.<
[13:37:13] <tomsmeding> and where is that letter in the alphabet? :)
[13:37:35] *** Quits: shriekingnoise (~shrieking@201.231.16.156) (Quit: Quit)
[13:37:40] <merijn> tomsmeding: Irrelevant, loads of letters are not in the alphabet
[13:38:01] <tomsmeding> fair
[13:38:40] *** Quits: eggplantade (~Eggplanta@108-201-191-115.lightspeed.sntcca.sbcglobal.net) (Remote host closed the connection)
[13:38:53] <merijn> tomsmeding: It is clearly not a digraph like oe/au/ou/eu/ie, because don't get capitalised as one
[13:39:49] <tomsmeding> that _is_ true
[13:39:49] *** Quits: chenqisu1 (~chenqisu1@183.217.201.47) (Quit: Leaving)
[13:40:09] <tomsmeding> it does look ridiculous in a monospace font though
[13:40:49] <merijn> It looks fine, if you write it right :p
[13:40:50] *** Joins: vglfr (~vglfr@88.155.11.162)
[13:41:01] *** Quits: vorpuni (~pvorp@2001:861:3881:c690:b51e:da9f:aa64:a038) (Ping timeout: 256 seconds)
[13:41:05] <abastro[m]> astra?
[13:41:21] <merijn> Looks fine in my monospace font: Ä²sland
[13:41:45] <merijn> The real problem is that computer make unicode like Ä² too hard to type
[13:42:22] *** Joins: Akiva (~Akiva@user/Akiva)
[13:43:00] <merijn> tomsmeding: Incidentally, I'm pretty sure that when I was taught the alphabet it just took the place of y, since there's like 3 words with y in it anyway
[13:44:18] *** Joins: ccntrq (~Thunderbi@2a01:c23:8960:6a00:997e:ae12:2988:d2c3)
[13:44:18] *** Joins: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com)
[13:45:45] <tomsmeding> I'm quite sure I was taught that the alphabet one had no dots, though we didn't complete primary school in the same year -- might have changed, dunno
[13:49:03] *** Quits: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com) (Ping timeout: 250 seconds)
[13:50:09] <abastro[m]> Hm.. string makes programming pretty hard
[13:56:15] *** Joins: michalz (~michalz@185.246.204.62)
[13:56:59] *** Joins: bahamas (~lucian@86.120.77.115)
[13:57:54] <abastro[m]> > (const <> flip const) [1, 2] [3, 4, 5]
[13:57:55] <lambdabot>  [1,2,3,4,5]
[13:58:01] *** Joins: pretty_dumm_guy (trottel@gateway/vpn/protonvpn/prettydummguy/x-88029655)
[13:58:46] *** w1gz_ is now known as w1gz
[13:58:54] <abastro[m]> Why does this work?
[13:59:08] <merijn> abastro[m]: The realisation that "strings are *really* hard" is one of the key milestones in programmer life :)
[13:59:27] <merijn> abastro[m]: Is there a reason why you think it shouldn't?
[13:59:56] <abastro[m]> Haha, key milestone
[14:00:03] *** Joins: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com)
[14:00:24] <abastro[m]> I wonder how go would handle it with its tact at publicity
[14:00:40] <abastro[m]> I find (const <> flip const) working alike (<>) surprising.
[14:02:23] <merijn> So, let's start of with: (<>)
[14:02:25] <merijn> :t (<>)
[14:02:27] <lambdabot> Semigroup a => a -> a -> a
[14:02:35] <merijn> That's obvious for lists, yeah?
[14:03:15] *** Joins: obp (~user@87.72.37.104)
[14:03:33] <abastro[m]> Yep
[14:03:35] <merijn> So, next step: My favourite Semigroup instance: "instance Semigroup r => Semigroup (a -> r) where f <> g = \x -> f x <> g x"
[14:03:41] *** Quits: Akiva (~Akiva@user/Akiva) (Ping timeout: 256 seconds)
[14:04:00] <abastro[m]> But const is function
[14:04:03] <merijn> i.e. "any function that returns something that is a Semigroup instance, is itself a Semigroup instance"
[14:04:11] <abastro[m]> Er wha
[14:04:45] <abastro[m]> Oh right, there is such instance
[14:04:53] <merijn> Note that that Semigroup instance applies recursively (i.e. since "a -> b -> c" is just "a -> (b -> c)" and "b -> c" is a Semigroup instance if 'c' is a Semigroup instance
[14:05:07] <abastro[m]> But how does specific combinator such as const and flip const bring us back to mappend?
[14:05:08] *** Quits: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com) (Ping timeout: 252 seconds)
[14:05:32] *** Parts: obp (~user@87.72.37.104) ()
[14:05:34] <merijn> abastro[m]: So "const <> flip const" returns a new function that takes two arguments, passes them on to const and "flip const" and concat the result via <>
[14:05:50] <merijn> > const 'a' True
[14:05:51] <lambdabot>  'a'
[14:05:58] <merijn> > flip const 'a' True
[14:06:00] <lambdabot>  True
[14:06:24] <merijn> So, you just have 2 functions, one returning the first argument, one returning the second, and then using <> on their results
[14:07:08] <abastro[m]> Yep.
[14:07:18] <abastro[m]> Ohh
[14:07:32] <abastro[m]> So it appends the first argument and second argument!
[14:07:38] <abastro[m]> :t (const <> const)
[14:07:39] <lambdabot> Semigroup a => a -> b -> a
[14:08:15] <merijn> > (const <> const) "ab" "c"
[14:08:16] <lambdabot>  "abab"
[14:09:04] <abastro[m]> I guess this is going to be like  (id <> id) which ignores the second parameter
[14:09:15] <abastro[m]> > (id <> id) "ab"
[14:09:17] <lambdabot>  "abab"
[14:09:35] *** Quits: Pickchea (~private@user/pickchea) (Ping timeout: 256 seconds)
[14:10:05] <abastro[m]> fold (repeat 10 id) "ab"
[14:10:15] <abastro[m]> > fold (repeat 10 id) "ab"
[14:10:17] <lambdabot>  error:
[14:10:17] <lambdabot>      â€¢ Couldn't match expected type â€˜(a0 -> a0) -> t0 ([Char] -> t)â€™
[14:10:17] <lambdabot>                    with actual type â€˜[a1]â€™
[14:10:37] <abastro[m]> Uhm why this doesn't work?
[14:10:46] <int-e> > mconcat [id, reverse, map succ] "ab"
[14:10:47] <lambdabot>  "abbabc"
[14:13:06] <int-e> abastro[m]: you want `replicate` rather than `repeat`
[14:13:42] <abastro[m]> Gah, I need more haskell experience
[14:14:21] <int-e> I'd probably write it correctly, but I needed a second glance to see what's wrong :-P
[14:15:30] <int-e> @src mconcat
[14:15:31] <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
[14:15:57] <abastro[m]> =>)  anyway, this thing is nice replacement for mtimes
[14:16:04] <int-e> Oh, class member... also @src is too outdated to check whether  mconcat = fold  is the current definition.
[14:16:27] *** Joins: obp (~user@87.72.37.104)
[14:16:58] <abastro[m]> Monoid is def one of the coolest I learned in haskell
[14:17:08] *** Joins: kmand (~user@188.120.85.216)
[14:17:34] <int-e> Default implementation is  mconcat = foldr mappend mempty ...that's a no then.
[14:17:45] *** Joins: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com)
[14:18:54] *** Quits: cfricke (~cfricke@user/cfricke) (Quit: WeeChat 3.3)
[14:21:43] <merijn> The source from @src (generally) lists the code from the report, not actual source used by GHC
[14:22:17] *** Quits: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com) (Ping timeout: 240 seconds)
[14:22:41] <abastro[m]> That is interesting, I guess it does that because report does not change
[14:22:59] <merijn> Also because @src is just a string to string lookup table :p
[14:23:04] <merijn> And not anything smart
[14:24:35] <abastro[m]> At least they need not care about the ghc version
[14:25:06] *** Quits: mcglk (~mcglk@131.191.49.120) (Ping timeout: 260 seconds)
[14:25:09] *** kmein_ is now known as kmein
[14:25:22] *** Parts: kmand (~user@188.120.85.216) (ERC (IRC client for Emacs 27.2))
[14:25:52] *** Quits: whatsupdoc (uid509081@id-509081.hampstead.irccloud.com) (Quit: Connection closed for inactivity)
[14:28:32] *** Joins: krappix (~krappix@nat-eduroam-76-gw-01-lne.lille.inria.fr)
[14:28:52] *** Joins: mcglk (~mcglk@131.191.49.120)
[14:34:48] *** Joins: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com)
[14:39:18] *** Joins: eggplantade (~Eggplanta@108-201-191-115.lightspeed.sntcca.sbcglobal.net)
[14:39:31] *** Quits: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com) (Ping timeout: 245 seconds)
[14:43:37] *** Quits: eggplantade (~Eggplanta@108-201-191-115.lightspeed.sntcca.sbcglobal.net) (Ping timeout: 240 seconds)
[14:45:20] *** Quits: toulene (~toulene@user/toulene) (Quit: Ping timeout (120 seconds))
[14:45:27] *** Joins: Graham31415 (~Graham314@5.33.52.156)
[14:46:01] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[14:46:46] *** Joins: toulene (~toulene@user/toulene)
[14:47:32] *** Joins: notzmv (~zmv@user/notzmv)
[14:48:07] *** Joins: cfricke (~cfricke@user/cfricke)
[14:51:23] *** Quits: kaph (~kaph@net-109-116-124-149.cust.vodafonedsl.it) (Read error: Connection reset by peer)
[14:52:46] *** Joins: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com)
[14:53:23] *** Quits: gentauro (~gentauro@user/gentauro) (Read error: Connection reset by peer)
[14:53:55] *** Quits: econo (uid147250@user/econo) (Quit: Connection closed for inactivity)
[14:57:24] *** Quits: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com) (Ping timeout: 240 seconds)
[14:59:18] *** Joins: gentauro (~gentauro@user/gentauro)
[14:59:42] *** Joins: lavaman (~lavaman@c-174-63-118-52.hsd1.ma.comcast.net)
[14:59:55] *** Quits: nicbk (~nicbk@user/nicbk) (Ping timeout: 240 seconds)
[15:02:08] *** Joins: Pickchea (~private@user/pickchea)
[15:03:53] *** Quits: tiferrei (~tiferrei@user/tiferrei) (Remote host closed the connection)
[15:04:51] *** Joins: tiferrei (~tiferrei@user/tiferrei)
[15:04:55] *** Quits: toulene (~toulene@user/toulene) (Quit: Ping timeout (120 seconds))
[15:05:31] *** Quits: bitmapper (uid464869@id-464869.lymington.irccloud.com) (Quit: Connection closed for inactivity)
[15:06:23] *** Joins: toulene (~toulene@user/toulene)
[15:06:40] *** Quits: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net) (Remote host closed the connection)
[15:07:12] *** Joins: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net)
[15:09:08] *** Joins: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com)
[15:10:14] *** Joins: kuribas (~user@ptr-25vy0i7hp9xee3gx8cn.18120a2.ip6.access.telenet.be)
[15:13:20] *** Quits: bahamas (~lucian@86.120.77.115) (Ping timeout: 252 seconds)
[15:23:11] *** Joins: kaph (~kaph@net-109-116-124-149.cust.vodafonedsl.it)
[15:26:39] *** Quits: mmhat (~mmh@55d48f06.access.ecotel.net) (Ping timeout: 256 seconds)
[15:32:19] *** Quits: lavaman (~lavaman@c-174-63-118-52.hsd1.ma.comcast.net) (Ping timeout: 256 seconds)
[15:37:25] *** Quits: krappix (~krappix@nat-eduroam-76-gw-01-lne.lille.inria.fr) (Ping timeout: 256 seconds)
[15:39:59] *** Joins: mmhat (~mmh@55d48f06.access.ecotel.net)
[15:41:46] *** Joins: jgeerds (~jgeerds@55d4548e.access.ecotel.net)
[15:45:06] <kuribas> I am back to higher kinded records and type families.  There doesn't seem to be a way to put business logic into data structures, without either loosing all type info, or using advanced features.
[15:47:19] <kuribas> And the haskell way of making algebras seems to make redundancy necessary.
[15:48:35] <[exa]> what's "business logic" in this case?
[15:49:25] <kuribas> in this case it's the "model" of our database.
[15:50:00] *** Joins: razetime (~quassel@117.254.35.226)
[15:50:25] <kuribas> We have on "object" table with objects and their type, then other tables with attributes which can belong to that type or object.
[15:51:59] <kuribas> I can then put this information in data tables, which are then used to generate queries to read or write to the database.
[15:52:07] <[exa]> so the business logic is basically a db schema?
[15:52:36] <kuribas> no, it's more like meta information about the db schema
[15:52:42] <kuribas> how the object model maps to the db schema.
[15:52:57] <kuribas> Currently I use higher kinded records to provide a mapping.
[15:53:11] <[exa]> so it's a description of isomorphism, kinda, right?
[15:53:29] <kuribas> yeah
[15:53:47] <kuribas> the database and object model should be isomorphic.
[15:54:08] <kuribas> And it's complicated because we have a history of changes also there.
[15:54:19] <[exa]> the database is sql?
[15:54:24] <kuribas> yeah
[15:55:04] <[exa]> ah well, you're not the first one to hit difficulties with this then (/me points at the list of failed ORMs and the queue of failing ORMs)
[15:55:14] *** Parts: obp (~user@87.72.37.104) (ERC 5.4.1 (IRC client for GNU Emacs 29.0.50))
[15:55:53] <kuribas> well, it's not really an ORM, since the database schema was designed for this.
[15:56:14] <[exa]> "orm with assumptions"
[15:57:08] <kuribas> I mean, it was moddelled after our domain, not a generic ORM.
[15:57:19] <kuribas> In our case "objects" are devices.
[15:57:55] <[exa]> this is going to be a really very highlevel generic hint but the general error in this kind of designs is that the "objects" do not really exist (or compose well) in SQL. Esp. in functional programming it's much easier to have an isomorphism between queries and transformations, instead of between rows and objects
[15:58:20] <kuribas> What do you mean?
[15:58:22] <[exa]> I'll probably spend half of the day now searching for a good example, hoping that someone will supply one :D
[15:58:35] <kuribas> If the "object" is in the "object" table, it exists?
[15:59:08] <kuribas> well, I lied, it's called the "device table" :)
[15:59:21] <kuribas> the idea is the same.
[15:59:31] <kuribas> Things like addresses are not in the device table.
[16:01:11] <[exa]> the "object" in your program transforms to a very hairy collection of rows, (invisible) index entries and (unmaterialized) satisfied constraints that are specified somewhere else, and if you want it to find an actual isomorphism, it just gets hard. Instead of that, finding an isomorphism on the transformations/queries is easy and pretty much well-defined (SQL queries compose nicely!)
[16:01:59] <kuribas> that's basically my code now, but I find there is still a lot of duplication.
[16:02:13] <kuribas> separate code for reading, insertion.
[16:02:26] *** Quits: razetime (~quassel@117.254.35.226) (Remote host closed the connection)
[16:03:33] <kuribas> So now I have a datatype for devices: like "data Device = Toaster | Fridge".  Then a type family to map the device to a record with "Attributes".  Then a type family to map each attribute to a record of attributeFields.
[16:03:42] *** Joins: raehik (~raehik@cpc95906-rdng25-2-0-cust156.15-3.cable.virginm.net)
[16:04:31] *** Quits: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl) (Ping timeout: 245 seconds)
[16:04:45] <[exa]> I've seen a pretty good approach for abstracting over this (you basically model everything as SELECT INTO and sometimes you select from the program into the database) but no bookmark :/
[16:05:32] *** Joins: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl)
[16:06:54] <kuribas> [exa]: how does that give me both inserts and reads?
[16:07:12] *** Joins: razetime (~quassel@117.254.35.226)
[16:09:41] <[exa]> the data stream is basically a "row stream" and it's pretty easy to have the row stream ingested into SQL from the program (needs a bit of query transformations but nothing too harsh, they made it work with something like COPY FROM), as well as to program from SQL (that's the easy way, just SELECT)
[16:10:19] <abastro[m]> Coding in Immutability to DB?
[16:10:20] <abastro[m]> Tho how would it perform
[16:10:45] *** Quits: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl) (Ping timeout: 250 seconds)
[16:11:23] *** Joins: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl)
[16:11:25] <kuribas> abastro[m]: only add, never delete or update :)
[16:11:41] *** Joins: xff0x (~xff0x@i121-117-52-147.s41.a013.ap.plala.or.jp)
[16:11:42] <kuribas> or garbage collect
[16:12:07] <abastro[m]> I mean, wait. You only add in your DB?
[16:12:12] <abastro[m]> How would that work
[16:12:37] *** Quits: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com) (Ping timeout: 240 seconds)
[16:12:58] <kuribas> I was being facetious
[16:14:24] *** Quits: acidjnk (~acidjnk@pd9e0b763.dip0.t-ipconnect.de) (Ping timeout: 252 seconds)
[16:14:41] <kuribas> [exa]: maybe a datastructure which contains both an insertor and reader?
[16:15:21] <kuribas> And is composable so I can compose the reader for single field into a reader of the feature.
[16:15:30] <abastro[m]> Ahh
[16:15:54] <abastro[m]> Hm wait, you need update as well, right?
[16:15:56] <[exa]> yeah, something like that, (RowStream -> RowStream)
[16:16:12] <kuribas> abastro[m]: typically in haskell, you manipulate your data and effects in a pure way, then execute the effects later.
[16:16:13] *** Quits: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl) (Ping timeout: 240 seconds)
[16:16:31] <[exa]> updates can be streamed, you need a selecting and updating part of the row stream
[16:17:00] <[exa]> same with deletes, again needs only a tiny bit of metainformation here and there
[16:17:10] <kuribas> [exa]: what do you mean by stream here?  A stream of devices?
[16:17:12] <abastro[m]> Oh, so you currently have separate insert and update there - that's what you mean, right?
[16:17:23] <kuribas> abastro[m]: yes
[16:17:28] <[exa]> kuribas: stream of literal sql rows
[16:17:31] <abastro[m]> insert and update-capable data structure
[16:17:32] <abastro[m]> I see.
[16:17:39] <abastro[m]> Oh wait. I mean insert and read, duh
[16:17:49] <abastro[m]> and update is performed by the interpreter or whatever
[16:18:06] <kuribas> abastro[m]: in lisp you then make a datastructure describing which rows are "attributes", part of a "feature". then generate the query based on that.
[16:21:35] <kuribas> [exa]: concrete example, let's say I have data "Device = Toaster | Fridge | ...".  Then I want to get a Toaster, and know which "features" belong to the Toaster.  For example a feature table "Electrical" and "Baking".
[16:22:47] <abastro[m]> Uhm why does this sound like sum type example
[16:23:02] <abastro[m]> Like `Device = Toaster ToasterFeatures | Fridge FridgeFeatures | ...`
[16:23:03] *** Joins: neurocyte0917090 (~neurocyte@IP-045014191158.dynamic.medianet-world.de)
[16:23:03] *** Quits: neurocyte0917090 (~neurocyte@IP-045014191158.dynamic.medianet-world.de) (Changing host)
[16:23:03] *** Joins: neurocyte0917090 (~neurocyte@user/neurocyte)
[16:23:45] <kuribas> abastro[m]: right, that is what I have now.
[16:24:12] <abastro[m]> Oh, what was the problem with this design?
[16:24:42] <abastro[m]> Like you wanted general statement over each field?
[16:24:51] *** Joins: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com)
[16:24:58] <abastro[m]> (Asking since this sounds interesting)
[16:25:03] *** Quits: bitdex (~bitdex@gateway/tor-sasl/bitdex) (Remote host closed the connection)
[16:25:30] <kuribas> well, now I have to write separate queries to read and write the features.
[16:25:47] *** Joins: ProfSimm (~ProfSimm@87.227.196.109)
[16:26:02] *** Quits: Graham31415 (~Graham314@5.33.52.156) (Quit: Ping timeout (120 seconds))
[16:26:27] <abastro[m]> I thought there were utilities to automatically generate queries
[16:26:44] <abastro[m]> Or, are your queries quite complicated?
[16:26:48] <kuribas> not really
[16:27:29] <kuribas> I just find the logic is a bit spread out 
[16:28:08] <kuribas> To generate a query, I have to know that the attribute "wattage" is read from the column "wattage" in the table "Electrical".
[16:28:33] <kuribas> I am not using an ORM, because I hate them :)
[16:29:09] <abastro[m]> Eh, can't infer attribute "wattage" from column name?
[16:29:31] <kuribas> yes, but they aren't all unique.
[16:29:48] *** Quits: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com) (Ping timeout: 240 seconds)
[16:29:49] <kuribas> so sometime I want to make a custom mapping.
[16:29:57] *** Quits: mmhat (~mmh@55d48f06.access.ecotel.net) (Ping timeout: 240 seconds)
[16:30:13] <kuribas> abastro[m]: I suppose you are hinting towards using HT or generics to generate the queries?
[16:30:19] <kuribas> TH
[16:31:18] *** Quits: toulene (~toulene@user/toulene) (Read error: Connection reset by peer)
[16:31:24] <abastro[m]> Yea, I'm quite sure it goes towards that end.
[16:32:10] *** Joins: toulene (~toulene@user/toulene)
[16:32:23] <kuribas> So now I am trying to use HKD records.  I have data Electrical f = Electrical { wattage :: f Double }
[16:33:22] <kuribas> Then I can make (Electrical SQLRows), which maps the fields to the SQL rows.
[16:33:46] <kuribas> And I have decoupled the actual implementation from the database description.
[16:33:59] <kuribas> However, it's not boring haskell anymore.
[16:42:21] *** Joins: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com)
[16:44:36] *** Joins: boxscape_ (~boxscape_@p4ff0b60b.dip0.t-ipconnect.de)
[16:44:58] *** Joins: gehmehgeh (~user@user/gehmehgeh)
[16:46:14] *** Joins: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl)
[16:51:12] <kuribas> So I turn each field into a query, and since the query builder is applicative, I can use ftraverse to make a query over the table.
[16:51:15] *** Quits: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl) (Ping timeout: 250 seconds)
[16:51:24] <kuribas> https://hackage.haskell.org/package/hkd-0.1/docs/Data-HKD.html#v:ftraverse
[16:51:51] <kuribas> My point is, the lispers claim that with dynamic languages you get more flexibility that when using types, and I have been trying to disprove it.
[16:52:13] <kuribas> And that you need to go to advanced type systems to make up for it.
[16:52:19] <kuribas> So far it just seems that they are right.
[16:52:51] <kuribas> well, save for not recognizing that haskell is the best dynamic language :)
[16:53:47] <kuribas> and "you cannot do this in haskell" is BS, since I can do any clojure technique using one big sum and partial functions.
[16:54:06] <kuribas> But the question is if this is satisfying...
[16:54:43] <abastro[m]> Personally I think their claim of flexibility is right
[16:55:00] <abastro[m]> Where, instead, haskell got edge on correctness
[16:55:26] *** Joins: grimey63 (~grimey@pool-108-26-37-118.syrcny.east.verizon.net)
[16:55:42] <abastro[m]> I wonder how you use HKD records though, why would you have `Electrical SQLRows`
[16:55:45] <kuribas> you need full dependent types to get both the same amount of flexibility and correctness.
[16:55:58] *** Joins: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl)
[16:56:33] <kuribas> abastro[m]: SQLRows describes a row.
[16:56:47] <abastro[m]> Indeed, perhaps I just love to compromise some correctness
[16:57:17] <kuribas> compromising some correctness is better than compromising all correctness, which is what lispers do.
[16:57:32] <kuribas> Or rather, not having the language check any correctness.
[16:58:02] <abastro[m]> Oh, lispers compromise all correctness?
[16:58:05] <abastro[m]> I mean
[16:58:17] <abastro[m]> lispers only compromise some of correctness?
[16:58:32] <abastro[m]> Oh right, correctness could be enforced without types
[16:58:39] <kuribas> better said, they more correctness either into the programmer responsibility, or into tests.
[16:58:52] <kuribas> s/more/move
[16:59:11] <abastro[m]> Ah so you mean they do not allow language to check correctness
[16:59:17] <kuribas> yes
[16:59:35] *** Joins: acidjnk (~acidjnk@p200300d0c7049f30b166e41192d3e532.dip0.t-ipconnect.de)
[16:59:36] *** Quits: doyougnu (~doyougnu@cpe-67-249-83-190.twcny.res.rr.com) (Remote host closed the connection)
[17:00:06] <kuribas> validation (if it is there), is only to filter out the user input, not to ensure the program is correct.
[17:00:32] <kuribas> s/lispers/dynamic programmers in general.
[17:00:46] <abastro[m]> So ye, I'd just have unreachable states in this case.
[17:00:58] <abastro[m]> As GADTs could make things complicated
[17:01:04] <abastro[m]> But that's just me.
[17:03:04] <kuribas> There is little complicated code in my case.  But that's because the "magick" is done by the HKD library.
[17:03:21] <kuribas> Compared to clojure, where it is just builtin map manipulation functions.
[17:03:22] *** Joins: karim (~karim@41.36.17.45)
[17:03:49] <abastro[m]> Oh, you mean a little complicated?
[17:04:06] <kuribas> abastro[m]: I mean not much.
[17:04:34] <kuribas> Not like, say, the implementation of servant.
[17:04:43] <abastro[m]> Tbh I still do not see why you have the type parameter
[17:04:47] <abastro[m]> Why is it?
[17:05:04] *** Joins: epolanski (uid312403@id-312403.helmsley.irccloud.com)
[17:05:07] <kuribas> abastro[m]: So I know it matches the database type :)
[17:05:16] <abastro[m]> Do you have to somehow embed SQLRows there?
[17:05:35] <Philonous> How do I export an associated data constructor? E.g. I have Â»class Foo a where data Bar aÂ« and Â»instance Foo int where data Bar Int = BarIntÂ«, how do I export the BarInt constructor? 
[17:06:57] <geekosaur> should be Foo(Bar) or Foo(..)
[17:07:17] <kuribas> abastro[m]: yeah, like electricalFields = Electrical { wattage = Field "Electrical" "wattage" }
[17:07:20] *** Quits: vglfr (~vglfr@88.155.11.162) (Ping timeout: 268 seconds)
[17:08:13] *** Quits: karim (~karim@41.36.17.45) (Ping timeout: 240 seconds)
[17:09:23] <abastro[m]> Eh, why do you need Field "Electrical" "wattage" thing
[17:09:36] <kuribas> abastro[m]: or "wattage = Field electrical_tbl wattage_field", if the tables and fields are generated from the database schema.
[17:10:07] <abastro[m]> I mean why do you need that
[17:10:33] <Philonous> geekosaur, Ah, played around with it, both Â»Bar(..)Â« and Â»Bar(BarInt)Â« work. 
[17:10:34] <Philonous> Thanks!
[17:10:35] <abastro[m]> To scrap boilerplate of e.g. reading from query?
[17:10:36] *** Quits: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net) (Remote host closed the connection)
[17:10:55] <kuribas> abastro[m]: yeah
[17:11:11] *** Joins: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net)
[17:11:16] <kuribas> to avoid writing a lot of manual queries.
[17:11:36] *** Quits: jgeerds (~jgeerds@55d4548e.access.ecotel.net) (Ping timeout: 252 seconds)
[17:11:38] <abastro[m]> Yea, sounds like TH thing
[17:11:54] <abastro[m]> I guess you dislike using that?
[17:12:08] <kuribas> yeah
[17:12:35] *** Joins: mmhat (~mmh@55d48f06.access.ecotel.net)
[17:12:41] <kuribas> I already have TH to generate typed fields and tables from the DB schema.
[17:13:49] <kuribas> abastro[m]: but I see, the haskell solution would be "less flexible", "more boilerplaty", but more correct.
[17:14:06] <kuribas> Only with dependent types you can have both.
[17:14:21] <kuribas> Or you need to hack around it with TH or generics.
[17:14:35] *** Quits: hololeap (~hololeap@user/hololeap) (Ping timeout: 240 seconds)
[17:14:43] <abastro[m]> Oh, yep.
[17:15:13] <abastro[m]> I often use generics so I did not know it was a hack ðŸ˜£
[17:15:25] *** Quits: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net) (Ping timeout: 240 seconds)
[17:16:07] <abastro[m]> Dependent types also have boilerplates though. ...on the proof side.
[17:17:45] <abastro[m]> I realized when I say I dislike dynamic typing, I mean languages like python and js. lol
[17:17:58] *** Joins: vglfr (~vglfr@88.155.11.162)
[17:18:00] <kuribas> abastro[m]: not lisp/clojure? :)
[17:18:18] <abastro[m]> Yep, I guess I am fine with lisp
[17:18:43] <abastro[m]> (I just used to meme with  (l(i(s(p))) tho)
[17:19:21] <kuribas> abastro[m]: in my SQL library, I not use TH to generate columns and tables.  But in a DT language I could write a constraint that looks up the fields in the database schema.
[17:19:36] <kuribas> abastro[m]: the latter is much cleaner IMO.
[17:20:16] <abastro[m]> But to see if the constraint conforms, you need proofs
[17:20:22] *** Joins: Graham31415 (~Graham314@5.33.52.156)
[17:20:24] <abastro[m]> Well, at least that was my experience with DT
[17:21:00] <abastro[m]> Pervasive problems with proof proliferation
[17:21:07] *** Quits: pavonia (~user@user/siracusa) (Quit: Bye!)
[17:21:16] <kuribas> it can be a simple proof, like "IsJust (lookup table schema)"
[17:21:50] <kuribas> if the table is in the schema, lookup returns "Just table", and the proof is done.
[17:21:57] <kuribas> otherwise it will fail at compile time.
[17:22:20] <kuribas> no need for complex tactics or rewrites :)
[17:22:44] <abastro[m]> The table needs to be on compile-time though
[17:22:45] *** Quits: vglfr (~vglfr@88.155.11.162) (Ping timeout: 268 seconds)
[17:22:58] <abastro[m]> And there is whole can of worms in describing datatypes in DT
[17:23:14] <kuribas> yeah, but it can be just a constant value.
[17:23:22] <kuribas> Idris1 even had type providers.
[17:23:30] <abastro[m]> Had hard time using DT in Coq
[17:23:33] <kuribas> Where you could read a value from a side-effect.
[17:23:38] <abastro[m]> Oh, I wonder how Idris would serve there
[17:24:04] <kuribas> well, an idris datatype is just like a haskell datatype.
[17:24:11] <abastro[m]> Yep, Idris is interesting. Just that I don't see it production-ready yet (Without trying, I know.. I should try at least once)
[17:24:19] <kuribas> oh, it isn't :)
[17:26:27] *** Quits: MajorBiscuit (~MajorBisc@wlan-145-94-218-48.wlan.tudelft.nl) (Ping timeout: 252 seconds)
[17:26:58] <kuribas> be prepared to implement half of the libraries that you take for granted in haskell.
[17:27:27] <abastro[m]> XD
[17:27:59] *** Quits: acidsys (~LSD@2a03:4000:55:d20::3) (Excess Flood)
[17:28:30] *** Joins: acidsys (~LSD@2a03:4000:55:d20::3)
[17:28:34] *** Joins: MajorBiscuit (~MajorBisc@wlan-145-94-218-48.wlan.tudelft.nl)
[17:29:26] <kuribas> hmm, if I combine SQL inserters and readers, I'll end up with a profunctor.  
[17:30:04] *** Joins: lavaman (~lavaman@c-174-63-118-52.hsd1.ma.comcast.net)
[17:30:07] <kuribas> Data SQLRow from to = SQLRow (Insertor from) (Reader to)
[17:31:45] *** Joins: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net)
[17:32:01] *** Quits: acidjnk (~acidjnk@p200300d0c7049f30b166e41192d3e532.dip0.t-ipconnect.de) (Ping timeout: 245 seconds)
[17:33:26] <kuribas> That could be one way to remove duplication.
[17:34:43] <abastro[m]> Profunctor? Sounds great!
[17:35:58] *** Quits: cheater (~Username@user/cheater) (Remote host closed the connection)
[17:36:56] *** Joins: cheater (~Username@user/cheater)
[17:42:37] *** Quits: toulene (~toulene@user/toulene) (Ping timeout: 240 seconds)
[17:42:53] *** Quits: dschrempf (~dominik@070-207.dynamic.dsl.fonira.net) (Quit: WeeChat 3.3)
[17:44:32] *** Joins: toulene (~toulene@user/toulene)
[17:46:43] *** Quits: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com) (Ping timeout: 250 seconds)
[17:47:31] <kuribas> the problem with DT is that most research is into proving programs correct, instead of in how to avoid the mess that the haskell typesystem has gone into.
[17:47:46] <kuribas> having a principled way to do typelevel programming.
[17:48:05] <merijn> Most DT research doesn't use Haskell
[17:48:17] <merijn> Because bolting DT onto Haskell does not an elegant language make
[17:49:36] <kuribas> isn't the argument that making haskell DT is easier than making a DT language production ready.
[17:50:17] <merijn> No
[17:50:21] <merijn> I mean, it depends
[17:50:27] *** Quits: razetime (~quassel@117.254.35.226) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
[17:50:44] <merijn> I don't think anyone expect Dependent Haskell to be as elegant/clean as Idris
[17:50:53] <merijn> At least not anyone "in the know" on these things :p
[17:52:55] <kuribas> Unless they want to phase out other extensions, this will only introduce complexity, no?
[17:53:24] <maerwald> I think the point is: DT languages are not production ready. And you should ask why :p
[17:53:58] *** Quits: ubert (~Thunderbi@p200300ecdf158894255673a7c9121e6c.dip0.t-ipconnect.de) (Quit: ubert)
[17:54:11] <kuribas> maerwald: chicken and egg question.  People don't use it because they aren't production ready, and it's not production ready because people don't use them.
[17:54:16] *** Joins: ubert (~Thunderbi@p200300ecdf1588942c242a19e1a99324.dip0.t-ipconnect.de)
[17:54:19] <maerwald> People use them
[17:54:28] <maerwald> but they are not general purpose languages
[17:54:49] <kuribas> I mean outside of an academic or mathematical proof oriented setting
[17:55:14] <geekosaur> dunno, idris is trying hard to be production ready
[17:55:28] <geekosaur> it just needs a threshold number of users to start developing an ecosystem
[17:55:58] <kuribas> geekosaur: yeah, nobody is to blame, but it's hard with 10 people or so :-)
[17:56:08] *** Joins: shriekingnoise (~shrieking@201.231.16.156)
[17:56:23] <maerwald> Not every feature fits into a general purpose language
[17:56:35] <maerwald> And you don't need to have a general purpose language for every purpose
[17:56:52] <geekosaur> and what peoplew are saying about idris now, they were saying about haskell 15 years ago
[17:57:22] <geekosaur> (and some are still saying about it, because hackage isn't node or etc.)
[17:59:56] *** Joins: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com)
[18:00:14] *** Joins: hololeap (~hololeap@user/hololeap)
[18:01:33] *** Quits: gehmehgeh (~user@user/gehmehgeh) (Quit: Leaving)
[18:02:15] <maerwald> you mean completely unaudited dumpster of code? I think it is :p
[18:02:15] *** Joins: boborygmy_ (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net)
[18:02:25] <maerwald> Don't know any language that does it different
[18:02:52] <maerwald> not hard to upload malicious packages
[18:03:20] <geekosaur> I meant size
[18:03:35] <geekosaur> most programmers don't even think about "dumpster of code"
[18:03:42] <maerwald> code size? I think average code size is 10 LOC on npm :D
[18:04:29] <maerwald> negate_bool(lol: bool): bool { not lol }
[18:04:37] *** Quits: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com) (Ping timeout: 240 seconds)
[18:05:05] <kuribas> maerwald: package count
[18:05:58] *** Joins: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com)
[18:08:03] <geekosaur> shitpile depth
[18:10:53] *** Joins: wroathe (~wroathe@206-55-188-8.fttp.usinternet.com)
[18:10:53] *** Quits: wroathe (~wroathe@206-55-188-8.fttp.usinternet.com) (Changing host)
[18:10:53] *** Joins: wroathe (~wroathe@user/wroathe)
[18:10:58] *** Quits: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com) (Ping timeout: 260 seconds)
[18:15:00] <maerwald> :D
[18:15:00] *** Quits: lavaman (~lavaman@c-174-63-118-52.hsd1.ma.comcast.net) (Ping timeout: 240 seconds)
[18:15:04] <maerwald> log n
[18:17:25] <dminuoso> 14:41:35   maerwald | [13:32:52] not hard to upload malicious packages
[18:17:39] <dminuoso> There's good reason why Google has internal rules to vendor dependencies in repositories.
[18:18:00] <dminuoso> So some degree I wish cabal-install had sufficient tooling to do the same.
[18:18:05] *** Quits: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net) (Remote host closed the connection)
[18:18:11] <dminuoso> Maybe I might look into that in my next vacation
[18:18:29] <maerwald> dminuoso: yes... I was thinking of that too, because it would solve the problem of HLS not being able to jump to dependency definitions
[18:18:34] <maerwald> if you vendor everything, it can
[18:19:16] <dminuoso> Superficially, it seems like it shouldn't be a very hard thing (I know, famous last words)
[18:20:09] <maerwald> via plan.json it should indeed be easy
[18:21:25] <maerwald> just collect everything, run `cabal unpack` in a subdir, then add optional-packages in cabal.project.local
[18:22:10] *** Joins: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com)
[18:23:53] *** Quits: lortabac (~lortabac@2a01:e0a:541:b8f0:4242:d6b8:d93f:54e5) (Quit: WeeChat 2.8)
[18:26:49] *** Joins: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net)
[18:26:51] *** Quits: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475) (Ping timeout: 256 seconds)
[18:27:17] *** Quits: ix (~ix@2a02:8010:674f:0:d65d:64ff:fe52:5efe) (Remote host closed the connection)
[18:27:26] *** Joins: ix (~ix@2a02:8010:674f:0:d65d:64ff:fe52:5efe)
[18:27:38] *** Joins: bahamas (~lucian@86.120.77.115)
[18:27:53] *** Quits: ix (~ix@2a02:8010:674f:0:d65d:64ff:fe52:5efe) (Remote host closed the connection)
[18:28:02] *** Joins: ix (~ix@2a02:8010:674f:0:d65d:64ff:fe52:5efe)
[18:28:12] *** Quits: acidsys (~LSD@2a03:4000:55:d20::3) (Excess Flood)
[18:28:22] *** Quits: ix (~ix@2a02:8010:674f:0:d65d:64ff:fe52:5efe) (Remote host closed the connection)
[18:28:36] *** Joins: ix (~ix@2a02:8010:674f:0:d65d:64ff:fe52:5efe)
[18:28:38] *** Quits: boborygmy_ (~bob@pool-173-54-217-168.nwrknj.fios.verizon.net) (Read error: Connection reset by peer)
[18:28:42] *** Quits: wroathe (~wroathe@user/wroathe) (Ping timeout: 260 seconds)
[18:28:43] *** Joins: acidsys (~LSD@2a03:4000:55:d20::3)
[18:28:57] *** Quits: ix (~ix@2a02:8010:674f:0:d65d:64ff:fe52:5efe) (Remote host closed the connection)
[18:29:05] *** Joins: ix (~ix@2a02:8010:674f:0:d65d:64ff:fe52:5efe)
[18:29:24] *** Quits: ix (~ix@2a02:8010:674f:0:d65d:64ff:fe52:5efe) (Remote host closed the connection)
[18:29:53] *** Quits: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net) (Remote host closed the connection)
[18:30:29] *** Joins: Sgeo (~Sgeo@user/sgeo)
[18:31:33] *** Joins: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net)
[18:32:22] <dminuoso> maerwald: So one way this starts getting complicated is if you have already vendored packages, say you have ./foo/foo.cabal and ./bar/bar.cabal
[18:32:22] <merijn> dminuoso: You can point it at your own hackage pretty easily and I think there's a way to point it at a local repo of tarballs too
[18:32:39] <dminuoso> merijn: "own hackage" and "easily" in one sentence is a bit amusing!
[18:32:46] <dminuoso> Been there, dont want to experience that again.
[18:32:57] <merijn> dminuoso: You can point it at a local cache of tarballs too, iirc
[18:33:17] <merijn> don't ask me how, though :)
[18:35:23] <dminuoso> maerwald: So yeah, I think this actually is a bit more subtle than at first look. 
[18:35:39] *** Joins: krappix (~krappix@nat-eduroam-76-gw-01-lne.lille.inria.fr)
[18:35:42] <maerwald> dminuoso: I don't understand your remark
[18:35:47] <dminuoso> So imagine foo/foo.cabal and bar/bar.cabal depend on the same package but in a different flavour
[18:36:19] <maerwald> flavour?
[18:36:25] <dminuoso> Versions, build flags
[18:36:50] <dminuoso> Or.. no just versinos.
[18:36:52] <maerwald> how's that possible even non-vendored?
[18:37:26] <dminuoso> It wouldnt, but the vendored style is very common in single repository/multiple packages style
[18:37:27] <maerwald> relying on plan.json means there is a *correct* and successful resolution
[18:37:36] <dminuoso> Yes, but that's per build target.
[18:38:01] <tdammers> vendoring doesn't mean you don't have to resolve dependencies, you just do it at a different point in your workflow, and you avoid some supply chain attacks
[18:38:12] <dminuoso> So say you have foo/ and bar/ as locally vendored packages, `cabal build foo` gives you a completely different build plan from `cabal build bar`
[18:38:30] <maerwald> dminuoso: very simple, you vendor per target then
[18:40:00] <dminuoso> maerwald: can you do this with a singular cabal.project.local? Or would that imply a separate such file per target, and you specify that with --project-file?
[18:40:20] <maerwald> dminuoso: yeah
[18:40:27] <dminuoso> Which one?
[18:40:35] <maerwald> --project-file
[18:43:06] *** Joins: benin (~benin@183.82.207.30)
[18:43:41] <maerwald> but if `cabal build all` fails resolution, you're already in trouble
[18:43:57] <dminuoso> I guess it's just a bit annoying because you might end up duplicating dependencies this way. This would already happen for test and benchmark targets
[18:44:38] <maerwald> I've only discovered this on unmaintainned packages
[18:44:40] <dminuoso> maerwald: im not convinced of that. we have several projects that I dont think would produce good coherent singular build plans.
[18:45:10] <dminuoso> in fact, we split them up intentionally such that foo-cli and bar-cli dont affect each others build plans needlessly
[18:45:26] <maerwald> yeah, then have separate project files for them
[18:45:49] <dminuoso> It's just too darn convenient to type `cabal run foo-cli`! :)
[18:50:21] <dminuoso> I guess the interface Id be looking for is a specification for possible build targets, generate a build plan for all, collect all deduplicated dependencies, and then teach cabal to use a directory of unpacked tarballs as a hackage replacement
[18:51:43] *** Quits: Midjak (~Midjak@82.66.147.146) (Quit: This computer has gone to sleep)
[18:51:48] *** Quits: mikoto-chan (~mikoto-ch@84.199.144.235) (Ping timeout: 240 seconds)
[18:52:26] <dminuoso> It would just be nice if, as far as cabal-install is concerned, this would be transparent, such that all you might do is configure some `hackage: .vendored_deps/` in your cabal.project if that makes sense
[18:54:29] <maerwald> this wouldn't be the primary use case I'd think about when hacking up a solution
[18:54:33] <maerwald> PR's welcome ;)
[18:54:51] *** Joins: lortabac (~lortabac@2a01:e0a:541:b8f0:4242:d6b8:d93f:54e5)
[18:55:14] <dminuoso> oh absolutely, Im willing to try and build this myself
[18:57:00] *** Quits: Pickchea (~private@user/pickchea) (Ping timeout: 240 seconds)
[18:58:41] <maerwald> my main motivation is to have jump-to-dependency in HLS
[19:00:55] *** Joins: lechner (~lechner@debian/lechner)
[19:02:09] *** Quits: alp (~alp@user/alp) (Ping timeout: 252 seconds)
[19:03:30] <abastro[m]> Jump to dependency for given definition? Import?
[19:06:01] *** Joins: mikoto-chan (~mikoto-ch@213.177.151.239)
[19:06:02] *** Quits: acidsys (~LSD@2a03:4000:55:d20::3) (Excess Flood)
[19:06:33] *** Joins: acidsys (~LSD@2a03:4000:55:d20::3)
[19:06:45] <dminuoso> Yeah, my concern is just auditing transitive dependency changes. But it seems whatever the solution, would would be served.
[19:07:49] <abastro[m]> Oh transitive dependency
[19:12:37] *** Joins: waleee (~waleee@2001:9b0:213:7200:cc36:a556:b1e8:b340)
[19:16:20] *** Quits: mmhat (~mmh@55d48f06.access.ecotel.net) (Quit: WeeChat 3.4.1)
[19:16:45] *** Joins: lavaman (~lavaman@c-174-63-118-52.hsd1.ma.comcast.net)
[19:18:15] <janus> has anyone encountered the GC bug 20959 in 9.0.2? is a 9.0.3 planned?
[19:19:40] *** Joins: Unicorn_Princess (~Unicorn_P@46-54-248-191.static.kate-wing.si)
[19:27:29] *** Quits: bahamas (~lucian@86.120.77.115) (Ping timeout: 256 seconds)
[19:27:47] *** Joins: xkuru (~xkuru@user/xkuru)
[19:31:51] *** Joins: acidjnk (~acidjnk@p200300d0c7049f30e5337983ccb1fe06.dip0.t-ipconnect.de)
[19:33:43] *** Quits: mikoto-chan (~mikoto-ch@213.177.151.239) (Ping timeout: 256 seconds)
[19:35:19] *** Joins: mikoto-chan (~mikoto-ch@213.177.151.239)
[19:37:03] *** Joins: dschrempf (~dominik@070-207.dynamic.dsl.fonira.net)
[19:37:48] *** Quits: cfricke (~cfricke@user/cfricke) (Quit: WeeChat 3.4.1)
[19:38:57] *** Joins: [itchyjunk] (~itchyjunk@user/itchyjunk/x-7353470)
[19:39:02] *** Quits: vysn (~vysn@user/vysn) (Ping timeout: 240 seconds)
[19:40:56] *** Joins: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net)
[19:40:58] *** Joins: vglfr (~vglfr@88.155.11.162)
[19:43:44] *** Joins: eggplantade (~Eggplanta@108-201-191-115.lightspeed.sntcca.sbcglobal.net)
[19:44:05] *** Joins: justsomeguy (~justsomeg@user/justsomeguy)
[19:48:27] *** Quits: eggplantade (~Eggplanta@108-201-191-115.lightspeed.sntcca.sbcglobal.net) (Ping timeout: 256 seconds)
[19:48:54] *** Joins: razetime (~quassel@117.254.35.226)
[19:49:39] *** Joins: javiergarea (~javiergar@static-60-220-27-46.ipcom.comunitel.net)
[19:50:00] *** Quits: dschrempf (~dominik@070-207.dynamic.dsl.fonira.net) (Quit: WeeChat 3.3)
[19:50:39] *** Joins: tzh (~tzh@c-24-21-73-154.hsd1.or.comcast.net)
[19:51:45] *** Quits: stiell (~stiell@gateway/tor-sasl/stiell) (Remote host closed the connection)
[19:52:08] *** Joins: stiell (~stiell@gateway/tor-sasl/stiell)
[19:53:02] *** Quits: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net) (Remote host closed the connection)
[19:53:34] *** Joins: Pickchea (~private@user/pickchea)
[19:53:39] *** Joins: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net)
[19:57:01] *** Quits: acidjnk (~acidjnk@p200300d0c7049f30e5337983ccb1fe06.dip0.t-ipconnect.de) (Ping timeout: 240 seconds)
[19:59:37] *** Quits: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com) (Ping timeout: 240 seconds)
[20:00:21] *** Quits: lavaman (~lavaman@c-174-63-118-52.hsd1.ma.comcast.net) (Ping timeout: 256 seconds)
[20:01:23] *** Joins: mon_aaraj (~MonAaraj@user/mon-aaraj/x-4416475)
[20:04:42] *** Quits: neurocyte0917090 (~neurocyte@user/neurocyte) (Quit: The Lounge - https://thelounge.chat)
[20:04:45] *** Quits: MajorBiscuit (~MajorBisc@wlan-145-94-218-48.wlan.tudelft.nl) (Ping timeout: 250 seconds)
[20:05:24] *** Quits: Graham31415 (~Graham314@5.33.52.156) (Quit: Client closed)
[20:06:39] *** Quits: benin (~benin@183.82.207.30) (Quit: The Lounge - https://thelounge.chat)
[20:08:24] *** Joins: neurocyte0917090 (~neurocyte@IP-045014191158.dynamic.medianet-world.de)
[20:08:24] *** Quits: neurocyte0917090 (~neurocyte@IP-045014191158.dynamic.medianet-world.de) (Changing host)
[20:08:24] *** Joins: neurocyte0917090 (~neurocyte@user/neurocyte)
[20:08:43] *** Joins: eggplantade (~Eggplanta@108-201-191-115.lightspeed.sntcca.sbcglobal.net)
[20:11:05] *** Joins: dsrt^ (~dsrt@96-67-120-105-static.hfc.comcastbusiness.net)
[20:12:02] *** Joins: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com)
[20:13:29] *** Quits: neurocyte0917090 (~neurocyte@user/neurocyte) (Quit: The Lounge - https://thelounge.chat)
[20:13:31] *** Quits: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net) (Read error: Connection reset by peer)
[20:13:37] *** Joins: yauhsien_ (~yauhsien@61-231-22-192.dynamic-ip.hinet.net)
[20:15:51] <justsomeguy> Where did the name fold come from? Is there some kind of metaphor for how the data structure is reduced in the name?
[20:16:30] *** Joins: neurocyte0917090 (~neurocyte@IP-045014191158.dynamic.medianet-world.de)
[20:16:30] *** Quits: neurocyte0917090 (~neurocyte@IP-045014191158.dynamic.medianet-world.de) (Changing host)
[20:16:30] *** Joins: neurocyte0917090 (~neurocyte@user/neurocyte)
[20:16:36] *** Quits: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com) (Ping timeout: 245 seconds)
[20:17:52] <[exa]> justsomeguy: I always imagined folding a long strip of paper or something
[20:19:46] <[exa]> [1~so yeah definitely metaphorical, unless well someone here comes with an explanation for F.O.L.D. acronym
[20:22:05] *** Quits: vglfr (~vglfr@88.155.11.162) (Ping timeout: 250 seconds)
[20:22:05] <kuribas> I prefer reduce as in lisp.
[20:22:50] <kuribas> folding something doesn't reduce it.
[20:24:02] <dminuoso> kuribas: Arguably thats why folding is more honest?
[20:24:20] <dminuoso> % foldr (:) [] [1,2,3,4]
[20:24:20] <yahb> dminuoso: [1,2,3,4]
[20:24:24] <dminuoso> Is this "reduced" in any way?
[20:25:32] <dminuoso> Either way, mentally I always imagine a structure/tree of data being folded like origami by means of a function :)
[20:25:38] <dminuoso> Into something.. else..
[20:26:36] <Zemyla> > foldr (:) [5,6,7,8] [1,2,3,4]
[20:26:37] <lambdabot>  [1,2,3,4,5,6,7,8]
[20:27:04] <kuribas> dminuoso: yeah, to a new list :)
[20:27:09] *** Joins: Graham31415 (~Graham314@5.33.52.156)
[20:27:12] <kuribas> dminuoso: it just looks like the old one.
[20:27:14] <dminuoso> Zemyla: Mmm, what a cunning way to pre/append!
[20:27:15] <stefan-_> in scala there is a `reduce` function on collections: https://www.scala-lang.org/api/2.13.3/scala/collection/immutable/List.html#reduce[B%3E:A](op:(B,B)=%3EB):B
[20:27:53] <dminuoso> Besides, folding has a nice matching opposite unfolding.
[20:27:55] *** Quits: ystael_ (~ystael@user/ystael) (Read error: Connection reset by peer)
[20:27:56] <dminuoso> So that's quite nice as well
[20:28:12] <Zemyla> That's actually how append works in the build/foldr fusion system in GHC.List.
[20:28:18] <janus> reduce has an nice opposite too: embiggen :D
[20:28:43] <kuribas> dminuoso: unfold this: foldl (+) 0 [2, 5, 4]
[20:28:46] *** Joins: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com)
[20:29:19] <dminuoso> Zemyla: conceptually it's just a delayed fold, such that you can simply compose the functions in between right?
[20:29:59] <byorgey> the word 'fold' seems to be already used in Miranda
[20:30:03] <justsomeguy> Maybe I should just think about it is as a "constructor substitution" function?
[20:30:16] *** Joins: lbseale (~ep1ctetus@user/ep1ctetus)
[20:30:19] <byorgey> justsomeguy: yes, that's exactly what it is
[20:30:28] <dminuoso> Well, in case of foldr anyway
[20:30:35] <dminuoso> foldl' is better thought of as a loop
[20:30:38] *** Joins: ystael (~ystael@user/ystael)
[20:32:16] *** Quits: haskl (~haskl@user/haskl) (Read error: Connection reset by peer)
[20:32:18] <monochrom> https://docs.racket-lang.org/srfi/srfi-std/srfi-1.html#reduce
[20:32:58] *** Quits: eggplantade (~Eggplanta@108-201-191-115.lightspeed.sntcca.sbcglobal.net) (Remote host closed the connection)
[20:33:35] <kuribas> > foldr (+) 0 [2, 5, 4]
[20:33:37] <lambdabot>  11
[20:33:59] <monochrom> Every programmer tries to be honest when naming. But foresight and logical conclusions are much harder, not something you can achieve by just willing.
[20:34:22] <kuribas> monochrom: still, reduce was already commonly used.
[20:34:41] <kuribas> http://clhs.lisp.se/Body/f_reduce.htm
[20:35:05] *** Quits: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com) (Ping timeout: 252 seconds)
[20:35:14] *** Joins: haskl (~haskl@user/haskl)
[20:35:55] *** Quits: lortabac (~lortabac@2a01:e0a:541:b8f0:4242:d6b8:d93f:54e5) (Quit: WeeChat 2.8)
[20:36:15] <monochrom> Yeah, I'm saying "reduce" is just as honest and intuitive as "fold" for a lot of people.
[20:38:58] <Zemyla> dminuoso: Yes. It's a composable fold.
[20:40:02] *** Quits: Vajb (~Vajb@hag-jnsbng11-58c3a8-176.dhcp.inet.fi) (Ping timeout: 240 seconds)
[20:40:30] *** Quits: son0p (~ff@181.136.122.143) (Remote host closed the connection)
[20:40:36] *** Joins: Akiva (~Akiva@user/Akiva)
[20:40:54] *** Quits: krappix (~krappix@nat-eduroam-76-gw-01-lne.lille.inria.fr) (Quit: Client closed)
[20:41:00] <monochrom> marinate :: (b -> Maybe (a, b)) -> b -> [a]  >:)
[20:41:04] *** Joins: Vajb (~Vajb@2001:999:62:aa00:7f5a:4f10:c894:3813)
[20:43:22] <justsomeguy> :D
[20:43:41] *** Joins: jakalx (~jakalx@base.jakalx.net)
[20:44:42] *** Quits: neurocyte0917090 (~neurocyte@user/neurocyte) (Quit: The Lounge - https://thelounge.chat)
[20:46:36] *** Joins: neurocyte0917090 (~neurocyte@IP-045014191158.dynamic.medianet-world.de)
[20:46:36] *** Quits: neurocyte0917090 (~neurocyte@IP-045014191158.dynamic.medianet-world.de) (Changing host)
[20:46:36] *** Joins: neurocyte0917090 (~neurocyte@user/neurocyte)
[20:47:14] *** Joins: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com)
[20:48:37] *** Quits: Pickchea (~private@user/pickchea) (Ping timeout: 240 seconds)
[20:49:53] <merijn> monochrom: Surely that'd be 'stew' or 'simmer'? :p
[20:51:49] *** Quits: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com) (Ping timeout: 240 seconds)
[20:53:40] *** Joins: son0p (~ff@181.136.122.143)
[20:54:53] *** Quits: ubert (~Thunderbi@p200300ecdf1588942c242a19e1a99324.dip0.t-ipconnect.de) (Ping timeout: 252 seconds)
[20:57:27] *** Quits: ccntrq (~Thunderbi@2a01:c23:8960:6a00:997e:ae12:2988:d2c3) (Remote host closed the connection)
[20:57:37] *** Joins: eggplantade (~Eggplanta@108-201-191-115.lightspeed.sntcca.sbcglobal.net)
[20:59:03] *** Quits: justsomeguy (~justsomeg@user/justsomeguy) (Quit: WeeChat 3.4)
[21:02:56] *** Quits: son0p (~ff@181.136.122.143) (Read error: Connection reset by peer)
[21:03:42] *** Joins: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com)
[21:04:08] *** Joins: bahamas (~lucian@84.232.140.158)
[21:05:18] *** Joins: karim (~karim@41.34.201.10)
[21:07:38] *** Joins: econo (uid147250@user/econo)
[21:08:17] *** Quits: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com) (Ping timeout: 240 seconds)
[21:09:10] *** Joins: __monty__ (~toonn@user/toonn)
[21:17:57] *** Quits: razetime (~quassel@117.254.35.226) (Quit: https://quassel-irc.org - Chat comfortably. Anywhere.)
[21:19:18] *** Joins: benin (~benin@183.82.207.30)
[21:19:34] *** Joins: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com)
[21:24:38] *** Quits: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com) (Ping timeout: 260 seconds)
[21:26:43] *** Quits: Graham31415 (~Graham314@5.33.52.156) (Quit: Client closed)
[21:26:44] *** Quits: Vajb (~Vajb@2001:999:62:aa00:7f5a:4f10:c894:3813) (Read error: Connection reset by peer)
[21:27:24] *** Joins: Vajb (~Vajb@hag-jnsbng11-58c3a8-176.dhcp.inet.fi)
[21:29:27] *** Joins: jpds (~jpds@gateway/tor-sasl/jpds)
[21:30:45] *** Quits: chele (~chele@user/chele) (Remote host closed the connection)
[21:30:48] *** Joins: ubert (~Thunderbi@p200300ecdf158894f1c8f499466ba149.dip0.t-ipconnect.de)
[21:30:53] *** Joins: boxscape (~boxscape@user/boxscape)
[21:31:36] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Ping timeout: 245 seconds)
[21:31:44] *** Quits: ProfSimm (~ProfSimm@87.227.196.109) (Remote host closed the connection)
[21:32:02] *** Joins: ProfSimm (~ProfSimm@87.227.196.109)
[21:33:42] <Zemyla> The opposite of reduce would be rehydrate, I think.
[21:34:00] <geekosaur> induce?
[21:34:59] <Zemyla> No, it works because a reduction is a dehydrated list.
[21:36:57] *** Joins: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com)
[21:37:00] *** Quits: neurocyte0917090 (~neurocyte@user/neurocyte) (Quit: The Lounge - https://thelounge.chat)
[21:37:46] *** nf is now known as ju
[21:38:02] *** Joins: neurocyte0917090 (~neurocyte@IP-045014191158.dynamic.medianet-world.de)
[21:38:02] *** Quits: neurocyte0917090 (~neurocyte@IP-045014191158.dynamic.medianet-world.de) (Changing host)
[21:38:02] *** Joins: neurocyte0917090 (~neurocyte@user/neurocyte)
[21:38:16] *** ju is now known as Guest3578
[21:38:24] *** Guest3578 is now known as nf
[21:39:21] *** Quits: jpds (~jpds@gateway/tor-sasl/jpds) (Remote host closed the connection)
[21:42:06] *** Joins: jpds (~jpds@gateway/tor-sasl/jpds)
[21:44:05] *** Joins: _ht (~quassel@231-169-21-31.ftth.glasoperator.nl)
[21:50:38] *** Joins: dschrempf (~dominik@070-207.dynamic.dsl.fonira.net)
[21:50:58] *** Quits: dschrempf (~dominik@070-207.dynamic.dsl.fonira.net) (Client Quit)
[21:51:22] *** Joins: dschrempf (~dominik@070-207.dynamic.dsl.fonira.net)
[21:51:25] *** Joins: alp (~alp@user/alp)
[21:51:26] *** Quits: dschrempf (~dominik@070-207.dynamic.dsl.fonira.net) (Client Quit)
[21:52:45] *** Joins: fendor_ (~fendor@178.115.72.153.wireless.dyn.drei.com)
[21:55:09] *** Quits: fendor (~fendor@91.141.35.69.wireless.dyn.drei.com) (Ping timeout: 256 seconds)
[21:55:25] <dsal> How do I replace `Nothing` in a lens traversal?
[21:56:04] *** Quits: ProfSimm (~ProfSimm@87.227.196.109) (Remote host closed the connection)
[21:56:25] *** Joins: Graham31415 (~Graham314@5.33.52.156)
[21:57:42] *** Joins: lavaman (~lavaman@c-174-63-118-52.hsd1.ma.comcast.net)
[21:58:36] <dsal> I guess I can `%~ Just . fromMaybe x` 
[21:59:35] <dsal> Which is <|> I guess
[22:02:44] *** Quits: epolanski (uid312403@id-312403.helmsley.irccloud.com) (Quit: Connection closed for inactivity)
[22:03:33] *** Quits: javiergarea (~javiergar@static-60-220-27-46.ipcom.comunitel.net) (Quit: Client closed)
[22:06:26] <dsal> I wrote `<|>~` -- that seems clear enough
[22:07:43] *** Joins: vglfr (~vglfr@88.155.11.162)
[22:09:10] *** Joins: kayvank (~user@52-119-115-185.PUBLIC.monkeybrains.net)
[22:10:22] *** Quits: mbuf (~Shakthi@136.185.72.170) (Quit: Leaving)
[22:14:39] *** Quits: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl) (Ping timeout: 256 seconds)
[22:14:46] *** Joins: Guest|71 (~Guest|71@ip70-186-124-59.no.no.cox.net)
[22:15:27] *** Quits: Guest|71 (~Guest|71@ip70-186-124-59.no.no.cox.net) (Client Quit)
[22:16:01] *** Quits: jlamothe (~jlamothe@198.251.61.229) (Quit: leaving)
[22:16:07] *** Joins: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl)
[22:17:06] *** Quits: FinnElija (~finn_elij@user/finn-elija/x-0085643) (Remote host closed the connection)
[22:17:38] *** Quits: yauhsien_ (~yauhsien@61-231-22-192.dynamic-ip.hinet.net) (Remote host closed the connection)
[22:17:38] *** Joins: FinnElija (~finn_elij@user/finn-elija/x-0085643)
[22:19:55] *** Joins: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net)
[22:21:27] *** Quits: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl) (Ping timeout: 256 seconds)
[22:21:27] *** Quits: vglfr (~vglfr@88.155.11.162) (Read error: Connection reset by peer)
[22:21:46] *** Joins: vglfr (~vglfr@88.155.11.162)
[22:24:32] *** Quits: yauhsien (~yauhsien@61-231-22-192.dynamic-ip.hinet.net) (Ping timeout: 252 seconds)
[22:33:00] *** Quits: benin (~benin@183.82.207.30) (Quit: The Lounge - https://thelounge.chat)
[22:33:21] *** Quits: Graham31415 (~Graham314@5.33.52.156) (Quit: Client closed)
[22:34:19] *** Joins: jlamothe (~jlamothe@198.251.61.229)
[22:35:30] *** Joins: ix (~ix@2a02:8010:674f:0:d65d:64ff:fe52:5efe)
[22:35:55] *** Joins: cosimone (~user@93-44-187-176.ip98.fastwebnet.it)
[22:36:25] *** Quits: raehik (~raehik@cpc95906-rdng25-2-0-cust156.15-3.cable.virginm.net) (Ping timeout: 250 seconds)
[22:36:50] *** Joins: raehik (~raehik@78.129.150.252)
[22:37:19] *** Quits: vglfr (~vglfr@88.155.11.162) (Ping timeout: 256 seconds)
[22:38:16] *** Joins: Graham31415 (~Graham314@5.33.52.156)
[22:39:33] <hololeap> % :t \x m -> m <|> pure x
[22:39:33] <yahb> hololeap: Alternative f => a -> f a -> f a
[22:40:46] <hololeap> I guess that's called 'option' in parser combinators
[22:41:00] *** Quits: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com) (Ping timeout: 240 seconds)
[22:42:37] *** Quits: EvanR (~EvanR@user/evanr) (Quit: Leaving)
[22:42:49] *** Quits: neurocyte0917090 (~neurocyte@user/neurocyte) (Read error: Connection reset by peer)
[22:43:01] *** Quits: lavaman (~lavaman@c-174-63-118-52.hsd1.ma.comcast.net) (Ping timeout: 240 seconds)
[22:43:41] *** Joins: neurocyte0917090 (~neurocyte@IP-045014191158.dynamic.medianet-world.de)
[22:43:41] *** Quits: neurocyte0917090 (~neurocyte@IP-045014191158.dynamic.medianet-world.de) (Changing host)
[22:43:41] *** Joins: neurocyte0917090 (~neurocyte@user/neurocyte)
[22:45:36] *** Joins: vicfred (~vicfred@user/vicfred)
[22:45:48] *** Quits: raehik (~raehik@78.129.150.252) (Ping timeout: 240 seconds)
[22:46:26] *** Parts: jakalx (~jakalx@base.jakalx.net) (Error from remote client)
[22:47:06] *** Quits: mikoto-chan (~mikoto-ch@213.177.151.239) (Ping timeout: 252 seconds)
[22:48:10] *** Joins: raehik (~raehik@cpc95906-rdng25-2-0-cust156.15-3.cable.virginm.net)
[22:48:35] <Zemyla> @pl \x m -> m <|> pure x
[22:48:35] <lambdabot> flip (<|>) . pure
[22:49:09] *** Joins: mikoto-chan (~mikoto-ch@213.177.151.239)
[22:51:23] *** Joins: vysn (~vysn@user/vysn)
[22:52:18] *** Joins: jakalx (~jakalx@base.jakalx.net)
[22:52:23] *** Quits: bahamas (~lucian@84.232.140.158) (Ping timeout: 256 seconds)
[22:53:54] *** Joins: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com)
[22:53:55] <monochrom> Yeah it's "option".
[22:54:41] *** Joins: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl)
[22:56:24] *** Joins: ub (~Thunderbi@p200300ecdf158894bc3487aad6770a01.dip0.t-ipconnect.de)
[22:58:37] *** Quits: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com) (Ping timeout: 240 seconds)
[22:59:25] *** Quits: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl) (Ping timeout: 240 seconds)
[23:01:25] *** Joins: ProfSimm (~ProfSimm@87.227.196.109)
[23:01:48] *** Joins: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl)
[23:01:52] *** Quits: Graham31415 (~Graham314@5.33.52.156) (Quit: Client closed)
[23:03:42] *** Joins: vglfr (~vglfr@88.155.11.162)
[23:04:19] *** Quits: fef (~thedawn@user/thedawn) (Remote host closed the connection)
[23:06:36] *** Quits: merijn (~merijn@c-001-001-001.client.esciencecenter.eduvpn.nl) (Ping timeout: 240 seconds)
[23:11:47] *** Joins: leungbk (~user@2603-8000-1201-2dd2-e446-391d-2222-0a22.res6.spectrum.com)
[23:11:51] *** Joins: wroathe (~wroathe@206-55-188-8.fttp.usinternet.com)
[23:11:51] *** Quits: wroathe (~wroathe@206-55-188-8.fttp.usinternet.com) (Changing host)
[23:11:51] *** Joins: wroathe (~wroathe@user/wroathe)
[23:19:56] *** Quits: justOkay (~justache@user/justache) (Read error: Connection reset by peer)
[23:20:55] *** Joins: justOkay (~justache@user/justache)
[23:21:15] *** Joins: Graham31415 (~Graham314@5.33.52.156)
[23:21:35] *** Quits: geekosaur (~geekosaur@xmonad/geekosaur) (Remote host closed the connection)
[23:24:29] <hololeap> hm, it seems that cabal is influenced by cabal.project in a parent directory. e.g. I'm in subdir/ and working with subdir/subdir.cabal, but it keeps looking at the top level (and putting cabal.project.local there)
[23:26:04] *** Joins: sloorush (~sloorush@2401:4900:234a:ee9b:8aa3:1d87:a269:b8a8)
[23:26:23] <hololeap> any way to disable this, so it's only looking at subdir/ ?
[23:27:02] <maerwald[m]> Symlink
[23:27:10] <hololeap> for reference, I'm working on the dhall/ subdir here: https://github.com/dhall-lang/dhall-haskell
[23:27:28] <hololeap> symlink what?
[23:28:05] *** Quits: alp (~alp@user/alp) (Ping timeout: 256 seconds)
[23:28:11] <maerwald[m]> hololeap: you move the subdir out and symlink it back in
[23:28:41] <maerwald[m]> They the original cabal.project still sees the subdir, but when you cd to it. Cabal doesn't see the parent calab.project 
[23:28:58] <maerwald[m]> Because ../ doesn't resolve that way
[23:29:48] <maerwald[m]> That may break your git checkout though :)
[23:30:17] *** Joins: zincy_ (~zincy@2a00:23c8:970c:4801:a9ba:a14e:e332:b83f)
[23:31:20] <sclv> you can just put a cabal.project in the subdir
[23:31:26] <sclv> that only applies to the subdir
[23:33:33] *** Joins: zebrag (~chris@user/zebrag)
[23:34:13] *** Quits: vysn (~vysn@user/vysn) (Ping timeout: 240 seconds)
[23:34:57] *** Joins: geekosaur (~geekosaur@xmonad/geekosaur)
[23:35:14] <hololeap> there seems to be some undocumented --ignore-project option
[23:35:43] *** Joins: sciencentistguy (~sciencent@hacksoc/ordinary-member)
[23:35:47] <sciencentistguy> :config
[23:35:53] <sciencentistguy> whoops, sorry
[23:37:09] *** Quits: jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net) (Ping timeout: 252 seconds)
[23:38:32] *** Joins: justsomeguy (~justsomeg@user/justsomeguy)
[23:38:56] *** Joins: jao (~jao@45.152.183.53)
[23:39:05] <hololeap> it's mentioned once here: https://cabal.readthedocs.io/en/3.6/cabal-commands.html?highlight=ignore-project#cabal-v2-repl
[23:39:58] <hololeap> cabal configure added "ignore-project: False" to my cabal.project.local which is how I discovered it
[23:40:40] <monochrom> Hrm there is a chance --ignore-project is only for repl.
[23:41:02] *** Quits: mud (~mud@user/kadoban) (Quit: quit)
[23:41:10] <monochrom> I haven't tested anything, but I looked at "cabal build --help" and "cabal repl --help".
[23:42:00] <monochrom> Does it help to say --project-file=/dev/null ? :)
[23:42:14] <sclv> ignore project works mainly but not always iirc
[23:42:45] <hololeap> at this point I can't reproduce the behavior... I'm just going to move on for now
[23:43:34] <sclv> https://github.com/haskell/cabal/issues/7965
[23:44:07] <sclv> its ugly :-/
[23:44:50] <sclv> by "mainly" i should have said "sporadically"
[23:46:05] <hololeap> thanks, good to see someone filed a bug for this
[23:51:49] *** Joins: bahamas (~lucian@84.232.140.158)
[23:57:29] *** Quits: bahamas (~lucian@84.232.140.158) (Ping timeout: 252 seconds)
