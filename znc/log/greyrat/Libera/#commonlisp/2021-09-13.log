[00:00:26] *** Quits: amb007 (~a_bakic@241.13.23.93.rev.sfr.net) (Read error: Connection reset by peer)
[00:00:38] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[00:02:54] *** Quits: cage (~cage@dynamic-adsl-78-15-41-207.clienti.tiscali.it) (Remote host closed the connection)
[00:04:55] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Ping timeout: 252 seconds)
[00:06:06] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[00:12:01] *** Joins: shka (~herr@109.231.62.239)
[00:12:49] *** Quits: shka (~herr@109.231.62.239) (Client Quit)
[00:13:05] *** Joins: shka (~herr@109.231.62.239)
[00:13:57] *** Joins: yitzi_ (~yitzi@173-27-106-188.client.mchsi.com)
[00:15:46] *** Quits: yitzi (~yitzi@173-27-106-188.client.mchsi.com) (Ping timeout: 260 seconds)
[00:18:24] *** Quits: yitzi_ (~yitzi@173-27-106-188.client.mchsi.com) (Client Quit)
[00:22:18] *** Quits: shka (~herr@109.231.62.239) (Ping timeout: 260 seconds)
[00:25:00] *** Quits: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431) (Ping timeout: 260 seconds)
[00:39:10] *** Quits: scymtym_ (~user@ip-94-114-248-79.unity-media.net) (Ping timeout: 252 seconds)
[00:40:53] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[01:01:45] *** Joins: Wairu_Goodman (~Wairu_Goo@2804:389:e018:5655:745f:f21b:7f29:2f71)
[01:06:23] *** Joins: kakuhen (~kakuhen@user/kakuhen)
[01:09:52] *** Quits: asarch (~asarch@2806:10ae:7:9cc2:f73e:28a0:4ca2:6e57) (Quit: Leaving)
[01:11:42] *** Joins: icer (eric@gateway/vpn/protonvpn/icer)
[01:12:02] *** Joins: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431)
[01:22:49] *** Joins: akoana (~ah@user/akoana)
[01:29:29] *** Joins: Lord_of_Life_ (~Lord@user/lord-of-life/x-2819915)
[01:30:43] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 252 seconds)
[01:30:44] *** Lord_of_Life_ is now known as Lord_of_Life
[01:33:08] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Remote host closed the connection)
[01:33:21] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[01:53:47] *** Quits: vats (~vats@103.70.83.191) (Ping timeout: 245 seconds)
[01:59:19] *** Quits: flip214 (~marek@user/flip214) (Ping timeout: 252 seconds)
[01:59:26] *** Joins: flip214 (~marek@user/flip214)
[02:01:07] *** Quits: gaqwas (~john@dynamic-095-115-065-228.95.115.pool.telefonica.de) (Ping timeout: 252 seconds)
[02:13:28] *** Joins: slyrus (~slyrus@192-184-223-165.static.sonic.net)
[02:17:35] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Ping timeout: 252 seconds)
[02:24:15] *** Quits: pve (~pve@178-55-46-33.bb.dnainternet.fi) (Quit: leaving)
[02:26:45] <jcowan> I came up with an idea for a non-portable extension of CL.  It may be doable with the MOP, but I never learned the MOP.  It looks like this:  (define-type-class name type-specifier).  The instances of such a class are all the objects which belong to the specified type.  Otherwise they work like built-in types (or perhaps I should say they are built-in types: no slots and no constructors.  However, parent types are possible, in
[02:26:45] <jcowan> which case the
[02:27:41] <jcowan> parent type specifiers are rewritten to include the subtypes with OR>
[02:27:50] <jcowan> What do people think of this?
[02:30:07] <hayley> (beach: For what it is worth, I would believe that the URL was an honest mistake on mfiano's behalf. Usually you don't see server URLs on Matrix, so it is hard to spot bad servers. And there are some of _that_ kind of person present in Lisp rooms; I know cause I had to get rid of some of them.)
[02:31:10] <Gnuxie> ( there's some of those people lurking in this channel for sure for what it is worth )
[02:33:03] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[02:33:23] <hayley> What does rewriting the parent types achieve that inheritance doesn't achieve? Is it that classes defined with define-type-class don't inherit any slots or anything like that?
[02:36:30] <slyrus> any vellum and/or teddy users around? Other data-frame like libraries I should consider?
[02:38:54] <jcowan> Hayley: they have no slots
[02:39:46] <hayley> Right, I think it would be quite possible with the MOP. You could just rig COMPUTE-SLOTS to return the empty list.
[02:40:11] <jcowan> The trick is to get class-of to use the type specifier.
[02:40:59] <hayley> I seem to have missed that part. Not sure if you can do that.
[02:41:34] <hayley> If it was possible, I was going to use it for network proxying once, as I can handle everything else lazily.
[02:42:32] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Remote host closed the connection)
[02:42:45] *** Joins: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20)
[02:43:18] <jcowan> Anyway, I think the better approach is to say that where the type specifier of the class being defined is t_c and the type specifier of each superclass is t_s, then for each superclass, subtypep(t_s, t_c) returns T T.
[02:44:32] <hayley> With t_s <: t_c, isn't it the case that t_c is the superclass?
[02:44:49] <hayley> That arrangement reminds me of stealth mixins, though you would reuse one mixin for multiple classes.
[02:47:14] *** Quits: cosimone (~user@2001:b07:ae5:db26:c24a:d20:4d91:1e20) (Remote host closed the connection)
[02:47:28] *** Joins: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3)
[02:50:09] *** Quits: moon-child (~moon-chil@cardinal.elronnd.net) (Ping timeout: 240 seconds)
[02:50:20] *** Joins: childlikempress (~moon-chil@cardinal.elronnd.net)
[02:51:06] *** childlikempress is now known as moon-child
[02:54:14] *** Joins: cjb (~cjbayliss@user/cjb)
[02:55:50] *** Quits: Wairu_Goodman (~Wairu_Goo@2804:389:e018:5655:745f:f21b:7f29:2f71) (Ping timeout: 260 seconds)
[02:58:10] *** Quits: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3) (Ping timeout: 260 seconds)
[03:15:29] <stylewarning> Are there any JSON libraries that let you customize the structure that gets built?
[03:16:16] <stylewarning> Everything I‚Äôm seeing let‚Äôs you do small customizations (like make an alist or plist, or use lisp booleans or symbols or ‚Ä¶), but I‚Äôm not seeing anything that allows me to instruct the parser what exactly I want it to build
[03:16:40] <stylewarning> lets*
[03:19:27] *** Joins: NeoCron (~NeoCron@p200300c4cf4f9c00198c896a0feeb747.dip0.t-ipconnect.de)
[03:24:30] <random-nick> stylewarning: going through the libraries on cliki, this looks like it lets you take parse events https://github.com/rotatef/json-streams
[03:24:41] <random-nick> haven't tested it though
[03:27:48] *** Quits: NeoCron (~NeoCron@p200300c4cf4f9c00198c896a0feeb747.dip0.t-ipconnect.de) (Remote host closed the connection)
[03:31:10] <stylewarning> random-nick: thanks! very interesting library design
[03:36:18] *** Joins: dra_ (~dra@2a04:4540:6417:ed00:ece8:867a:9e59:aae8)
[03:39:01] *** Quits: dra (~dra@2a04:4540:641e:b500:ece8:867a:9e59:aae8) (Ping timeout: 252 seconds)
[04:04:12] *** Quits: dra_ (~dra@2a04:4540:6417:ed00:ece8:867a:9e59:aae8) (Remote host closed the connection)
[04:17:31] *** Quits: akoana (~ah@user/akoana) (Quit: leaving)
[04:26:48] *** Joins: akoana (~ah@user/akoana)
[04:28:45] *** Joins: xsperry (~as@user/xsperry)
[04:59:12] *** Quits: Fare (~fare@2601:184:4a7f:995c:dd68:9c41:abc:66e5) (Ping timeout: 245 seconds)
[05:12:25] *** Quits: nature_ (~nature@mail.blazebone.com) (Ping timeout: 265 seconds)
[05:15:28] <moon-child> on x86, why does cmucl generate code that pops the return address manually and jumps to it, instead of using the native RET instruction?
[05:17:29] <hayley> I've never used CMUCL, so I don't have the disassembly on it. But one thing which came up when discussing the calling convention of SICL was that you also have to pop more of the stack before returning.
[05:20:50] <moon-child> hmm, I see
[05:22:20] <moon-child> It's a shame; I understand there is a dedicated return predictor, which is being bypassed in favour of a (much harder to predict) indirect jump.  I wonder how setting up the return stack manually at the call site would compare
[05:22:26] *** Joins: dstein64 (~dstein64@dannyadam.com)
[05:22:26] <hayley> The choice here was to put another location on the cold end of the stack, which we copy the return address to. While I guess jumping makes more sense, meddling with the stack to get RET to work makes some predictor work.
[05:22:28] <moon-child> (so the return address is pushed before the arguments)
[05:22:54] <hayley> But then you don't have CALL, and I think the predictor works on CALL/RET pairs.
[05:23:21] *** Joins: nature (~nature@mail.blazebone.com)
[05:25:11] <moon-child> https://twitter.com/ktemkin/status/1375835935061942274  I think this technique is faster than regular threading, which would indicate the return predictor can work without a corresponding call
[05:25:48] <moon-child> hm, agner's manual disagrees
[05:26:00] * hayley is terrified
[05:26:43] <moon-child> you don't like the return threader?
[05:26:46] <moon-child> I thought it was cute
[05:26:54] <moon-child> anyway  'A Last-In-First-Out buffer, called the return stack buffer, remembers the return address every time a call instruction is executed, and it uses this for predicting where the corresponding return will go.'
[05:28:21] <moon-child> hmm, if you do something like this:  push L1; push arg; push arg; call func; L1:  then you will have a redundant entry on the stack, but the return predictor will work correctly
[05:41:31] *** Quits: random-nick (~random-ni@87.116.165.220) (Ping timeout: 252 seconds)
[05:54:26] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca) (Remote host closed the connection)
[06:17:37] *** Joins: molson_ (~molson@2001-48F8-704A-CA1-0-0-75F-1023-static.midco.net)
[06:20:42] *** Quits: molson__ (~molson@2001-48F8-704A-CA1-0-0-75F-101C-static.midco.net) (Ping timeout: 260 seconds)
[06:21:22] *** Joins: karlosz (~karlosz@12.196.174.98)
[06:27:34] *** Joins: Fare (~fare@2601:184:4a7f:995c:acf2:97c4:dfba:129e)
[06:38:17] *** Quits: nature (~nature@mail.blazebone.com) (Remote host closed the connection)
[06:42:44] *** Joins: nature (~nature@mail.blazebone.com)
[07:03:04] *** Quits: X-Scale (~ARM@128.229.28.37.rev.vodafone.pt) (Ping timeout: 252 seconds)
[07:08:26] *** Joins: lisp123 (~lisp123@5.30.23.247)
[07:31:43] <beach> Good morning everyone!
[07:34:11] <beach> moon-child: What we do is leave a space right near the frame pointer, so we do push <arg1>, push <arg2>... call.  Then we pop the return address and put it first in the frame.  So then, to return, we first deallocate the arguments and then RET.
[07:51:28] *** Joins: asarch (~asarch@2806:10ae:7:7289:f634:a401:5f3d:1c16)
[07:59:11] *** Quits: sm2n (~sm2n@user/sm2n) (Ping timeout: 265 seconds)
[08:00:13] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[08:01:58] *** Joins: sm2n (~sm2n@user/sm2n)
[08:02:29] *** Parts: akoana (~ah@user/akoana) ()
[08:20:10] *** Quits: semz (~none@user/semz) (Ping timeout: 260 seconds)
[08:21:35] *** Quits: nature (~nature@mail.blazebone.com) (Ping timeout: 260 seconds)
[08:33:12] *** Joins: semz (~none@user/semz)
[08:34:00] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[08:34:29] *** Joins: Oladon (~olad@98.43.81.226)
[08:34:37] *** Quits: karlosz (~karlosz@12.196.174.98) (Ping timeout: 245 seconds)
[08:35:15] *** Joins: lisp123 (~lisp123@5.30.23.247)
[08:36:03] *** Quits: greyrat (~greyrat@ip202.ip-51-178-215.eu) (Bye)
[08:37:30] *** Joins: greyrat (~greyrat@ip202.ip-51-178-215.eu)
[08:37:50] *** Server sets mode: +Ccntz 
[08:38:42] *** Joins: anddam (~anddam@user/anddam)
[08:39:43] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[08:40:07] *** Joins: Mrtn[m] (~mrtn@2001:470:69fc:105::1f44)
[08:40:14] *** Joins: loke[m] (~loke@2001:470:69fc:105::237)
[08:40:27] *** Joins: katco (~katco@2001:470:69fc:105::2b8)
[08:40:45] *** Quits: ski (~ski@remote12.chalmers.se) (Ping timeout: 265 seconds)
[08:43:25] *** Quits: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431) (Quit: Leaving)
[08:49:16] *** Quits: nckx (~nckx@tobias.gr) (*.net *.split)
[08:49:16] *** Quits: madnificent (~madnifice@static.210.74.63.178.clients.your-server.de) (*.net *.split)
[08:49:16] *** Quits: ggoes (~gregf@fsf/staff/ggoes) (*.net *.split)
[08:49:16] *** Quits: etimmons (~etimmons@2001:470:69fc:105::5d5) (*.net *.split)
[08:49:17] *** Quits: santiagopim[m] (~santiagop@2001:470:69fc:105::e57d) (*.net *.split)
[08:49:17] *** Quits: happy-dude (~happy-dud@2001:470:69fc:105::b4d7) (*.net *.split)
[08:49:17] *** Quits: mikko (~mikko@2a02:7b40:d418:6a61::1) (*.net *.split)
[08:49:17] *** Quits: pok (~pok@user/pok) (*.net *.split)
[08:49:17] *** Quits: |3b| (bbb@user/3b/x-2324788) (*.net *.split)
[08:49:17] *** Quits: jfb4 (~jfb4@178.62.2.68) (*.net *.split)
[08:49:17] *** Quits: hisacro (~OBSD@my.displ.nl) (*.net *.split)
[08:49:17] *** Quits: leo_song (~leo_song@1.156.52.78) (*.net *.split)
[08:49:17] *** Quits: samebchase (~thelounge@51.15.68.182) (*.net *.split)
[08:49:17] *** Quits: deck4rd (~deckard@ec2-3-129-211-221.us-east-2.compute.amazonaws.com) (*.net *.split)
[08:49:17] *** Quits: hirez (~hirez@104.128.237.40) (*.net *.split)
[08:49:17] *** Quits: antoszka (~antoni@rozalia.antoszka.pl) (*.net *.split)
[08:49:17] *** Quits: skempf (~Kabriel@user/kabriel) (*.net *.split)
[08:49:21] *** Joins: pok_ (~pok@castor.klingenberg.no)
[08:49:29] *** Joins: samebchase (~thelounge@51.15.68.182)
[08:49:34] *** pok_ is now known as pok
[08:49:34] *** Joins: |3b| (bbb@user/3b/x-2324788)
[08:49:46] *** Joins: mikko (~mikko@2a02:7b40:d418:6a61::1)
[08:49:47] *** Joins: madnificent_ (~madnifice@static.210.74.63.178.clients.your-server.de)
[08:49:55] *** Joins: leo_song (~leo_song@1.156.52.78)
[08:50:06] *** Quits: pok (~pok@castor.klingenberg.no) (Changing host)
[08:50:06] *** Joins: pok (~pok@user/pok)
[08:50:12] *** Joins: hirez (~hirez@104.128.237.40)
[08:50:22] *** Joins: Kabriel (~Kabriel@user/kabriel)
[08:50:22] *** Joins: deck4rd (~deckard@ec2-3-129-211-221.us-east-2.compute.amazonaws.com)
[08:50:22] *** Joins: hisacro (~OBSD@my.displ.nl)
[08:50:24] *** Joins: antoszka (~antoni@rozalia.antoszka.pl)
[08:51:02] *** Joins: jfb4 (~jfb4@178.62.2.68)
[08:51:05] *** Joins: ggoes (~gregf@fsf/staff/ggoes)
[08:51:30] *** Joins: nckx (~nckx@tobias.gr)
[08:51:32] *** Joins: etimmons (~etimmons@2001:470:69fc:105::5d5)
[08:54:15] *** Quits: igemnace (~ian@user/igemnace) (Ping timeout: 260 seconds)
[08:54:45] *** Joins: santiagopim[m] (~santiagop@2001:470:69fc:105::e57d)
[08:56:02] *** Joins: igemnace (~ian@user/igemnace)
[09:00:05] *** Quits: nature (~nature@mail.blazebone.com) (Ping timeout: 265 seconds)
[09:02:13] *** Joins: happy-dude (~happy-dud@2001:470:69fc:105::b4d7)
[09:02:34] *** Joins: diskzero (~textual@2601:500:8500:4340:9c58:a26a:d260:271d)
[09:14:57] *** Joins: lisp123 (~lisp123@5.30.23.247)
[09:39:43] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[10:08:56] *** Joins: gaqwas (~john@dynamic-077-009-164-187.77.9.pool.telefonica.de)
[10:09:58] *** Joins: shka (~herr@109.231.62.239)
[10:10:28] *** Joins: rain3 (~rain3___@2a02:2f09:d30b:1300:514:bcc7:8202:1798)
[10:13:20] <rain3> beach: is it a good idea to  separate "add-mixin" out of define-stealth-mixin ? https://termbin.com/2o62 Sometimes I need to add to victim classes mixins which are already defined so I need this add-mixin
[10:19:21] <beach> I think STEALTH-MIXIN handles that case fine.
[10:20:53] <moon-child> rain3: (define-stealth-mixin dummy culprit victim)
[10:21:45] <beach> rain3: Oh, maybe I misunderstood what you were saying.
[10:22:24] <beach> But yes, you can use the existing mixin as a superclass.
[10:22:45] <rain3> moon-child: define-stealth-mixin always calls defclass
[10:23:28] <moon-child> (make that #:dummy)
[10:24:11] <moon-child> rain3: that is not a _pretty_ solution, but it is effective and concise
[10:24:57] <beach> rain3: If you want to write ADD-MIXIN, I'll add it to the library.
[10:25:20] <moon-child> beach: I think they just did--in the termbin.com link
[10:25:30] <beach> Oh, heh!
[10:25:46] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[10:25:48] <contrapunctus> I don't know anything about OOP in other languages, and all I know of OOP is basic CLOS. Is there anything I might read to understand what mixins are, and how they're created and used in CLOS?
[10:25:55] <beach> OK, well then, send me a pull request.
[10:25:59] <rain3> beach: okay
[10:26:28] <rain3> contrapunctus: read the paper about stealth-mixins
[10:26:33] <beach> contrapunctus: Technically, they are just ordinary classes.  What qualifies them as mixins is just conventional use.
[10:26:48] <rain3> nothing complicated
[10:27:39] <beach> contrapunctus: They are not intended to be directly instantiated, and instead are used as superclasses to "normal" classes in order to capture common things between several "normal" classes.
[10:28:10] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[10:28:26] <beach> contrapunctus: Example: (defclass name-mixin () ((%name :initarg :name :reader name))) could be used as a superclass for both a PERSON class and an ORGANIZATION class.
[10:28:40] <contrapunctus> rain3: thanks, looking it up.
[10:28:43] <mfiano> How does stealth-mixin differ from my solution? https://gist.github.com/mfiano/af1a31d1a4767834b96d39f425ee75e9
[10:28:44] <contrapunctus> beach: oh. Sounds straightforward.
[10:28:49] <beach> Very simple.
[10:30:14] <beach> mfiano: This is Monday and Monday mornings are chaotic around here.  I'll have a look later, unless someone else gets there first.
[10:30:28] <mfiano> Sure
[10:30:46] <beach> mfiano: But we had a paper published in the Australian Conference on Software Engineering on it some two decades ago.
[10:30:50] <mfiano> In the meantime I'll read the 2008 paper
[10:30:55] <mfiano> 2007*
[10:31:02] <beach> Oh, that recent.  OK.
[10:31:18] *** Quits: CrashTestDummy (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 260 seconds)
[10:31:22] *** Quits: borodust (~irc@user/borodust) (Ping timeout: 252 seconds)
[10:31:41] *** Joins: borodust (~irc@user/borodust)
[10:31:57] *** Joins: mjoerg (~user@user/mjoerg)
[10:32:05] <moon-child> http://clhs.lisp.se/Body/m_pshnew.htm  the first example here mutates literal data!
[10:33:10] *** Quits: gaqwas (~john@dynamic-077-009-164-187.77.9.pool.telefonica.de) (Ping timeout: 268 seconds)
[10:34:28] <mfiano> Good thing the examples and notes are not considered part of the standard :)
[10:36:36] <hayley> moon-child: https://i.redd.it/wrvgxpeopno61.png
[10:36:36] <hayley> In which the spec goes to spec jail
[10:37:18] <Alfr> It's only undefined, so some implementation might simply behave as shown in that example.
[10:37:19] <moon-child> hehe
[10:37:55] <mfiano> it's also not part of the spec, so spec is saved from the bonk
[10:37:59] <rain3> moon-child: see this example, for DESCRIBE-ing circular objects https://termbin.com/cabo     add-mixin allows one to add an existing mixin that has behaviour defined through defmethod . It is different from using a #:dummy class which has no behavior
[10:38:55] <mfiano> ::clhs 1.4.3
[10:38:56] <Colleen> Clhs: section 1.4.3 http://www.lispworks.com/documentation/HyperSpec/Body/01_dc.htm
[10:39:05] <moon-child> mfiano: not part of the spec, or just normative?
[10:39:13] <mfiano> ^
[10:40:18] <moon-child> rain3: why is it different from using a dummy?
[10:40:54] *** Quits: cjb (~cjbayliss@user/cjb) ()
[10:41:22] <moon-child> mfiano: notably 'so that we retain the flexibility needed to update these sections even at the last minute without fear of needing a formal vote to change those parts of the document'.  Given that, I think they are not intended to be unauthoritative
[10:41:28] <rain3> moon-child: how do you define methods specialized on objects of a class named  #:dummy ?
[10:42:16] <moon-child> rain3: I meant that, instead of writing '(stealth-mixin:add-mixin 'safely-describe-mixin 'c1)', you can write (stealth-mixin:define-stealth-mixin #:dummy safely-describe-mixin c1)
[10:42:40] <rain3> oh, to write it as a superclass there
[10:42:43] <moon-child> yes
[10:44:49] <rain3> okay got your point. btw add-mixin can be written as a function rather than as a macro
[10:45:01] <mfiano> moon-child: That quote is regarding front and back matter only. Examples only pertain to the rest of the section.
[10:47:19] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Ping timeout: 252 seconds)
[10:47:37] *** Joins: amb007 (~a_bakic@61.133.22.93.rev.sfr.net)
[10:48:51] *** Quits: diskzero (~textual@2601:500:8500:4340:9c58:a26a:d260:271d) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[10:49:41] *** Joins: diskzero (~textual@2601:500:8500:4340:9c58:a26a:d260:271d)
[10:54:45] *** Quits: diskzero (~textual@2601:500:8500:4340:9c58:a26a:d260:271d) (Ping timeout: 268 seconds)
[10:56:11] *** Joins: spiaggia (~user@2a01:cb19:150:3400:6437:56ab:400b:5f1e)
[10:56:45] <spiaggia> mfiano: Does your code handle redefinition of the victim class?
[10:57:05] <spiaggia> gilberth went to a lot of trouble to make sure it works. .
[10:59:37] *** Joins: attila_lendvai (~alendvai@catv-213-222-131-28.catv.broadband.hu)
[11:00:25] <mfiano> Well I am not sure, but I can explain how my code works
[11:00:53] *** Joins: lisp123 (~lisp123@5.30.23.247)
[11:01:06] <spiaggia> Sure.  But I don't think I can digest that right now.  Monday mornings,...
[11:01:10] *** Quits: Fare (~fare@2601:184:4a7f:995c:acf2:97c4:dfba:129e) (Ping timeout: 260 seconds)
[11:01:14] <mfiano> #'MIX is the main interaction. It takes as arguments a standard instance and a standard-class type.
[11:01:45] <mfiano> It constructs a new anonymous class with the class of the instance and the class denoted by the type argument as superclasses
[11:01:59] <mfiano> and then change-class's instance to be that class
[11:02:19] <spiaggia> Oh, I think that's very different from what stealth-mixin does.
[11:02:49] <mfiano> Ok :)
[11:03:21] <spiaggia> STEALTH-MIXIN adds a superclass to an existing class, so that client code can, say, add its own slots to a library class that wasn't designed for it.
[11:03:50] <spiaggia> Thanks to the package system, there is no conflict involved.
[11:04:15] <mfiano> How does it handle conflicting keyword-interned initargs?
[11:04:30] <spiaggia> It doesn't as far as I know.
[11:04:44] *** Quits: mjoerg (~user@user/mjoerg) (Remote host closed the connection)
[11:04:59] <spiaggia> I guess to be safe, the stealth mixin class should use ordinary symbols.
[11:05:45] <mfiano> Yeah, same here. It's unfortunate because some slots with initargs may be implementation details not intended for make-instance to be used.
[11:06:44] <mfiano> Well all slots should be implementation details in my opinion...and I guess to make initargs "private" they'd need to be interned into the library package
[11:06:47] <spiaggia> I am not sure why that is a problem, but I take your word for it.
[11:07:29] <spiaggia> I think it is fine if the client which defines the mixin use symbols in its own package only.
[11:07:41] <mfiano> The reason why I don't use this pattern much though, is due to something you hinted at above
[11:08:23] <spiaggia> What was that?  [Sorry again, distracted...]
[11:08:46] <mfiano> SBCL will emit a style warning if slots have the same symbol name but different package. I really don't want to wrap defclass in my own macro to muffle that, as most of the time the user will be defining their own mixin classes
[11:09:04] <spiaggia> Oh, yes, that sucks.
[11:09:27] <spiaggia> I wonder who came up with the idea to emit a style warning, and why.
[11:10:19] <mfiano> I have no idea. It's probably my biggest complaint about SBCL, as small of problem it is, it has a large effect on my codes.
[11:10:27] <spiaggia> I mean, to avoid the style warning, client code must know the implementation details of the library, which is contrary to the idea of modularity.
[11:10:45] <mfiano> Yes, and also contrary to the idea that slots should be implementation details.
[11:10:52] <spiaggia> Indeed.
[11:10:57] *** Joins: silasfox (~silasfox@xdsl-84-44-182-29.nc.de)
[11:11:10] <spiaggia> I would much rather have a style warning when a DEFMETHOD is used without a DEFGENERIC for the same function.
[11:11:34] <mfiano> That used to be the case, and I agree.
[11:12:04] *** Quits: amb007 (~a_bakic@61.133.22.93.rev.sfr.net) (Ping timeout: 252 seconds)
[11:12:20] <spiaggia> We will make sure to do that for SICL.  :)
[11:12:31] <mfiano> :)
[11:12:52] *** Joins: amb007 (~a_bakic@20.151.22.93.rev.sfr.net)
[11:14:58] *** Joins: Cymew (~ante@c-e989225c.023-1144-7570702.bbcust.telenor.se)
[11:16:47] *** Joins: pve (~pve@178-55-14-237.bb.dnainternet.fi)
[11:18:25] <saturn2> newbies tend to assume exporting the class name from a package also exports all the slot names
[11:18:44] <saturn2> i wonder if that's why sbcl did it
[11:19:46] <mfiano> spiaggia: Why don't I remember seeing you here before in all the years I've been paying attention? Did you change your nick?
[11:20:23] <moon-child> spiaggia is beach
[11:20:46] <mfiano> Huh. Interesting
[11:22:30] *** Quits: amb007 (~a_bakic@20.151.22.93.rev.sfr.net) (Ping timeout: 268 seconds)
[11:22:53] *** Joins: amb007 (~a_bakic@123.133.22.93.rev.sfr.net)
[11:25:23] *** Quits: peterhil (~peterhil@dsl-hkibng32-54fb52-57.dhcp.inet.fi) (Ping timeout: 252 seconds)
[11:27:34] *** Quits: asarch (~asarch@2806:10ae:7:7289:f634:a401:5f3d:1c16) (Quit: Leaving)
[11:28:52] <mfiano> I guess he only brings that nick on for special occasions and to confuse me :)
[11:30:14] <hayley> I think spiaggia uses spiaggia when he is strand(h)ed from the computer logged into beach all the time.
[11:30:16] *** Parts: pranavats (3fba1d1b34@jabberfr.org) ()
[11:31:29] <mfiano> too many puns in this early hour for me :)
[11:32:18] <hayley> Put all blame on defunkydrummer, because he once called spiggia Robert Strandh"ed at the beach".
[11:37:25] <spiaggia> mfiano: Italian vs English translation of my last name.
[11:37:43] <spiaggia> hayley: Heh, correct!
[11:38:57] <spiaggia> I have been know to use playa, plage, and Ufer as well in the distant past.
[11:40:23] *** Quits: amb007 (~a_bakic@123.133.22.93.rev.sfr.net) (Read error: Connection reset by peer)
[11:41:27] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[11:45:23] <mfiano> I raised the topic (again) in #sbcl. If this behavior affects anyone else, I kindly ask you to voice your opinion.
[11:45:44] <spiaggia> The unjustified style warning?
[11:45:54] <mfiano> Yes, it is like the 3rd time I raised the issue.
[11:46:00] <mfiano> It is not gaining traction for some reason
[11:46:03] <spiaggia> I don't hang out in #sbcl, but it is fine to let them know I agree.
[11:46:05] <mfiano> Help would be appreciated
[11:47:53] <spiaggia> I am accumulating evidence that the package system was used a lot less in the past, but I have seen no reason why that would be the case.
[11:48:25] <spiaggia> The naming convention for slot accessors in a bit older code is also evidence in that direction.
[11:49:30] <spiaggia> CLIM uses that convention, like SHEET-PARENT, and CLIM also has only two package defined by the specification, CLIM and CLIM-INTERNALS.
[11:50:05] <mfiano> Yes I see.
[11:50:10] <spiaggia> If I were to write the CLIM specification today, I would probably define many more packages; maybe one for each "module".
[11:50:41] <mfiano> I frown when I see the class prefix on accessor names instead of utilizing packages, at least for non-legacy code.
[11:51:11] <spiaggia> Yes, and it looks silly when inheritance is deep, like (SHEET-PARENT PANE) in CLIM.
[11:51:24] <mfiano> ha yeah
[11:52:33] <spiaggia> Yay, I am again allowed to enter my office!
[11:52:39] *** Parts: spiaggia (~user@2a01:cb19:150:3400:6437:56ab:400b:5f1e) (ERC Version 5.3 (IRC client for Emacs))
[11:52:46] <Cymew> Hasn't Graham or someone else vocal described the CL package system as "somewhat weak" or words to that effect?
[11:56:06] <beach> If what you want is a module system, then it is weak.  But if you use it for what it is, it is great.  I think the two concepts are orthogonal.
[11:56:20] <beach> Unfortunately, of course, Common Lisp doesn't have a module system.
[11:56:53] <beach> But first-class global environments play that role in SICL.
[11:59:23] <Cymew> Personally I think the word "orthogonal" is overused, but otherwise my experience mirror yours.
[11:59:45] <moon-child> beach: what do you mean by 'module system'?
[12:01:22] <beach> moon-child: A thing that can encapsulate sets of entities such as classes, functions, types, etc.  As opposed to just map names to entities as the package system does.
[12:01:46] <beach> Er, "A module is a thing that...".
[12:02:25] <moon-child> encapsulate how, and why?
[12:02:43] <hayley> beach: Silly question, have you read "Modules as Objects in Newspeak" <https://bracha.org/newspeak-modules.pdf>?
[12:03:00] <beach> hayley: Probably not.
[12:03:51] <beach> moon-child: I am not sure I can formulate the argument immediately, since modules are so fundamental in programming.
[12:04:00] <hayley> In the code examples there is a "platform" object which is eerily similar to a first-class global environment, in my opinion. But this object is an explicit argument used when instantiating a "library" class, and not an implicit "argument" like the FCGE.
[12:04:03] <moon-child> beach: ok
[12:04:39] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 268 seconds)
[12:04:54] <beach> moon-child: Let me give you an example instead: People often complain that you can't have two versions of the same library loaded into the same image, which is problematic because some client might want one version, and a different client a different version.
[12:05:27] <beach> moon-child: A module system would put one client and one version of the library in one module, and the other client with the other version of the library in a different module.
[12:05:39] <mfiano> beach: For what it's worth, I am familiar with modules, but I am curious to hear your thoughts as they relate to the missing Lisp piece (outside of FCGI)
[12:06:13] <hayley> The other difference is that a library in Newspeak is a class, where as a library in Common Lisp with first-class global environments is an effect on a first-class global environment, and the library is only reified if you use a fresh environment for each library.
[12:06:45] <beach> hayley: I'll read the paper at some point.
[12:07:22] <mfiano> beach: How does that address the primary issue; colliding package names in the global environment.
[12:08:03] <beach> First-class global environments?  Well, since they allow multiple global environments, that's how.
[12:08:28] <hayley> The solution is to give either client its own environment, where each environment has access to the desired version of the module.
[12:09:35] *** Quits: igemnace (~ian@user/igemnace) (Ping timeout: 268 seconds)
[12:09:37] <mfiano> So you mean that I can refer to either package #:foo (in module A) or #:foo (in module B) in client code (or even both if that is your cup of tea)?
[12:10:40] <hayley> (I had to think this through as one day Gnuxie showed me the Newspeak paper, said modules-as-objects looked neater, and it took a while for me to figure what my gut told me when it said FCGEs could be made more ore less equivalent.)
[12:10:41] <beach> Right, each first-class global environment has its own mapping from strings to packages.
[12:11:55] <mfiano> That is much more useful that I originally thought about fcgi. I wonder what client code looks like for interacting with different gi's from user code
[12:12:59] <beach> mfiano: It would be used only fairly infrequently.  I am not thinking of any fine-grain use of this feature.
[12:13:56] <beach> In fact, I invented it (jcowan says I "reinvented" it) to solve the bootstrapping problem, which requires me to execute SICL code in a host Common Lisp system, and to prepare for CLOSOS so that different users have different environments.
[12:14:37] <mfiano> beach: I am thinking as it relates to a "dependency manager" (as to not overload "package" from other languages), that supports versioned dependencies, where the transitive graph could include many of versions of the same library.
[12:14:44] <hayley> Another useful ability would be to share packages between environments, so that it is still possible to have another module which is a client of both of the forementioned modules.
[12:14:58] <moon-child> first-class environments have definitely existed for a while
[12:15:28] <mfiano> the client code here is the code that loads systems. the invidual systems can't be modified to refer to some particular gi
[12:15:42] <beach> moon-child: But all attempts I could find required a hash-table lookup for each function call.
[12:16:04] <hayley> In 20 years, we will surely have someone saying that you should explicitly prefix global environments somehow, rather than implicitly :use-ing environments :)
[12:16:31] <beach> mfiano: First-class global environments have no features for managing dependencies.
[12:16:38] <moon-child> beach: javascript 'requires' a hash-table lookup for every slot access.  Obviously there are fast javascript implementations.  I see your point, though
[12:17:20] <mfiano> beach: Yes I understand that. The issue is loading multiple versions of the same library, perhaps with the same package-name, into an image. The fact they came from a dependency graph is kind of irrelevant
[12:17:24] <beach> hayley: Hmm.  We'll see.
[12:17:28] <hayley> Still, if you load each module into a fresh global environment, you more or less have module "objects".
[12:17:36] <White_Flame> moon-child: JS compiles down to typecheck & direct ptr/offset access
[12:17:38] <mfiano> The point I'm trying to make, is the code being loaded is not aware of any environment
[12:17:45] <mfiano> Only the code that is loading them
[12:17:48] <mfiano> If that makes sense
[12:17:57] <beach> Sure.
[12:18:13] <hayley> Sure, that's how it works.
[12:18:48] <beach> rain3: Merged!  Thanks!
[12:19:09] <beach> rain3: If there is a problem, you get to be the maintainer. :)
[12:19:39] <rain3> Okay
[12:20:05] <mfiano> This problem is why I gave up on my "quicklisp alternative" some years ago, and why CLPM opted to not recursively resolve manifest files.
[12:21:32] <beach> Also, I see first-class global environments as a safety issue.  For SICL, I want to put all the code for the compiler in a separate first-class global environment, and then just import COMPILE, COMPILE-FILE, and EVAL to the default global environment.
[12:22:23] <beach> Then it would take an environment switch to alter the code generator, and presumably that switch is password protected, so that loading any arbitrary code can not easily alter the code generator.
[12:22:23] <hayley> Well, there may be a few things which appear to "break" if you go through environments in specific ways.
[12:23:16] <beach> Like what?
[12:23:28] <hayley> For example, a symbol from another environment might or might not have a function binding in the current environment, even if it was bound in the environment from whence it came. So using such a symbol as a function designator might not be a good idea.
[12:25:12] <hayley> But this kind of situation would probably only occur in my very absurd plan to use first class global environments as part of a Newspeak-esque module system, while still using modules written in normal Common Lisp.
[12:27:59] <moon-child> so symbols are not closed over their packages?
[12:28:34] <beach> Correct.  They are not.
[12:29:17] <beach> hayley: That would not happen in Clostrum environments.  Code is "tied" to an environment when it is loaded, so references to named global functions are resolved then.
[12:31:24] <hayley> Right, but I don't think tying would affect something like having (defun f (symbol) (funcall symbol)) evaluated in one environment, and having (defun g () 'welcome-stranger) (defun h () (f 'g)) evaluated in another environment which a function binding for F.
[12:32:13] <beach> moon-child: There are certain aspects that we haven't worked out yet.  For instance, I am not sure whether (SYMBOL-PACKAGE <SYMBOL>) could return a different package in different environments.
[12:32:39] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[12:33:18] <mfiano> beach: the style warning was intended to catch a hard-to-debug programmer-error situation: where they intended to extend a slot, but because of a package snafu ended up "silently" creating a new slot instead.
[12:33:40] <mfiano> The solution they want to take is to only emit it if the slot in question is exported, and thus not an implementation detail.
[12:33:42] <hayley> Would we evaluate (h), the function binding for G would be looked up at runtime, no?
[12:33:53] <beach> hayley: Right, an example like that would go through FDEFINITION which will result in a hash-table lookup.
[12:34:24] <moon-child> it occurs to me that symbols not being closed over their environments is consistent.  If you redefine a package, symbols which were already interned into it will continue to be
[12:36:02] <beach> moon-child: Like I said, I haven't imagined all possible scenarios.  I think that more experience will be required to iron out the details.
[12:36:18] *** Joins: hendursa1 (~weechat@user/hendursaga)
[12:37:00] <beach> What I think I do know is that I don't want any "module prefix", so that one could say <module>.<function-name> or something like that.
[12:37:09] <moon-child> however functions _are_ closed over their environments.  If symbols were too, then SYMBOL-PACKAGE would always have to return the same package regardless of which environment it were evaluated in
[12:37:17] <moon-child> beach: idneed, but that's no reason not to speculate!
[12:37:40] <pve> I'm trying to understand these first class global environments. Would it be possible to implement them (meaningfully) as a library that could be loaded into any CL implementation?
[12:38:14] <beach> moon-child: Right.  I am just explaining why I am unable to think very fast, so I don't have an answer to all potential issues.
[12:38:25] <mfiano> As a library? I don't think so. As an extension proposition like PLN, probably.
[12:38:34] <moon-child> err, sorry, in 'symbols not being closed over their environments is consistent', 'environments' should have been 'packages'
[12:39:00] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 276 seconds)
[12:40:03] <beach> pve: Well, Clostrum is a library that implements first-class global environments, and we certainly use it during SICL bootstrapping to isolate the host environment from multiple SICL environments, but executing code relative to an environment currently takes a factor 4 or so performance hit compared to host code.
[12:40:26] <beach> pve: So I don't think you can use it in a transparent way as a library.
[12:40:39] *** Joins: asarch (~asarch@2806:10ae:7:7289:f634:a401:5f3d:1c16)
[12:42:25] <beach> pve: Essentially, every reference to a global function, variable, etc. in source code must be replaced by a load-time access to a particular first-class global environments in order to find "cells" containing the entity being referred to.
[12:42:35] <mfiano> Ok good, the stealth-mixins paper is rather short. I don't have time for too much attention today :)
[12:42:52] <beach> pve: And the way we do it now is to turn source code to a Cleavir AST, and then turn that to host code for compilation by the host compiler.
[12:43:26] <beach> pve: Probably, that process could be optimized a bit, but I have seen no reason for it, since it is plenty fast as it is for SICL bootstrapping.
[12:45:07] <pve> beach: Ok, I see. And is there any amount of package trickery (renaming packages etc) that could be done to "simulate" FCGEs (or a module system)?
[12:45:37] *** Joins: lisp123 (~lisp123@5.30.23.247)
[12:46:01] <beach> pve: Probably.  That's what SBCL does for bootstrapping.  I just found that unappealing which is why I didn't want it.
[12:46:19] <mfiano> Good call
[12:46:45] <beach> Thanks.
[12:47:11] <pve> beach: oh, didn't know that about SBCL, thanks.
[12:47:22] <mfiano> Just noticed I said FCGI twice and GI twice instead of FCGE and GE. You know it's a Monday :/
[12:47:23] <beach> pve: There is a paper about that.
[12:48:05] <moon-child> mfiano: oh!--I was trying to figure out what the present discussion had to do with fastcgi :)
[12:48:31] <hayley> beach: Yeah, and so if someone wrote a module which actually relied on passing around symbols as function designators, they would find that the program looks for the FDEFINITION in the "wrong" environment.
[12:48:39] <beach> So a typical SICL "module" (now "module" means ASDF system definition plus package definition) has a package definition that :USEs only the CL package, and every component starts with (cl:in-package <module-name>), like (cl:in-package #:sicl-array) for instance.
[12:49:51] <beach> hayley: I don't think so, because FDEFINITION would be in a particular environment and it would look for functions in that environment.
[12:50:14] <hayley> Right.
[12:50:41] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Ping timeout: 268 seconds)
[12:50:42] <beach> hayley: So code doing (FDEFINITION 'FOO) would be loaded into some environment E, and FDEFINTION would be resolved to the one in E and functions returned would be those in E.
[12:50:43] <mfiano> moon-child:  Yeah, that is why I probably made that connection...I am not completely with it yet today.
[12:51:15] * beach has an abbrev "fcge", so if it doesn't expand, it is not used right.
[12:51:40] <hayley> I would expect FDEFINITION to look for the function in the former environment (which we evaluated the (defun f ...) form in), and so it would be unable to find the function named G in the latter environment.
[12:51:44] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[12:53:32] <beach> hayley: In your example, it would be the G in the environment that FUNCALL is taken from.
[12:53:39] <mfiano> beach: Not everyone uses Emacs, or a client with abbreviations. Some people prefer the typewriter experience :) I for one, despise Emacs, and only use it is a barely sufficient means to interact with CL.
[12:54:23] <beach> mfiano: Well, I find it very surprising that there are clients without abbrevs.
[12:54:38] <mfiano> IRC is simple enough to use netcat to communicate with
[12:54:44] <mfiano> If that's your thing
[12:55:17] <hayley> On the other hand, expecting FDEFINITION to work across environments would require some sort of ambient authority (probably by unnecessarily sharing bindings for H between environments somehow?) so I'm theoretically fine with that. I'm, however, less fine about how normal Common Lisp code might expect such code to work.
[12:56:16] *** Quits: silasfox (~silasfox@xdsl-84-44-182-29.nc.de) (Quit: silasfox)
[12:56:21] *** Joins: cosimone (~user@151.14.38.15)
[12:56:31] <rain3> I only recently have started using emacs without 'evil-mode' . I had been under the impression that it is not possible, because vi was my first editor and my psyche shaped after it
[12:57:08] *** Joins: silasfox (~user@2001-4dd1-68e2-0-286d-7bf4-8223-de6a.ipv6dyn.netcologne.de)
[12:57:47] <mfiano> rain3: I took the opposing path, because years of non-evil Emacs use has hurt my fingers.
[12:57:47] <beach> Here is my opinion: First-class global environments solve a real problem for bootstrapping, and also likely for a multi-user Common Lisp system.  But there are details that need to be figured out.  Either way, it will work better than without them.  My brain is too small to figure things out a priori, so it is fine for others to try that, but I am not going to be much help at this point.
[12:58:24] <contrapunctus> mfiano: why do you "despise" Emacs? O.o
[12:59:03] <rain3> abbreviations and hot keys are so useful that they should be available even across clients=  the operating system/a background service should deal with them
[12:59:16] <hayley> I agree. Really I'm only doing stupid thought experiments and wondering why they run into stupid problems.
[12:59:21] <beach> I think Emacs is fine, except possibly for editing Common Lisp code. :)
[12:59:52] <mfiano> contrapunctus: Plenty of reasons, such as its terminal mode not supporting truecolour unlike vim, or font-locking being unbearably slow compared to Vim on old hardware/large buffers. Mostly though, I just prefer the UNIX philosophy, so shoot me
[12:59:56] <beach> rain3: I totally agree.
[13:00:05] <contrapunctus> mfiano: hm...
[13:00:25] *** Joins: Lycurgus (~juan@98.4.112.204)
[13:01:13] <beach> rain3: I get very angry every time I use (say) bash, and don't have the spell checker or the abbrev processor.
[13:01:29] <contrapunctus> rain3: I've recently used this program called kmonad to do some crazy (/s) things like having Space act like Ctrl when held down, and Shift to insert () when tapped. Might be pretty good to avoid the Emacs pinky, too.
[13:01:51] <akater[m]> I'm only interested in Lisp because it makes environments like Emacs possible.  (Or rather, I'm only interested in programming because of that.)
[13:02:06] <beach> rain3: Or M-/ completion, or ....
[13:02:39] <beach> akater[m]: Yes, it seems clear from your utterances that you are not particularly interested in Common Lisp as such.
[13:03:40] <hayley> Does "only" qualify that you don't have any other reasons to be interested in Lisp, or that the reason is unique to Lisp?
[13:04:32] <contrapunctus> mfiano: I do feel a little dissatisfied with Emacs in that it does not have much in the way of means of composition for users. Perhaps keyboard macros, at most.
[13:04:48] <hayley> I would joke and say "I'm only interested in Lisp because it makes environments better than Emacs possible", but the same could be achieved in Smalltalk, and it is not the only reason that I like Common Lisp.
[13:05:17] <lisp123> I was thinking today, Elisp is basically an 'embedded language' in Common Lisp, that's my new company line on the two - Elisp is for the most parts well designed for customising text editors
[13:05:22] <contrapunctus> mfiano: Interop between Emacs packages happens by conscious design, not automatically through the design of the environment.
[13:05:34] <mfiano> contrapunctus: My opinions are mine and just that, opinions. Please don't take this as the start of a holy war. I accept that I have to use it, and I get by with things like evil-mode, even though it is barely acceptable to me.
[13:05:40] <rain3> I have made my own tool with common lisp that can program any additional usb keyboard . It doesn't support abbreviations yet or key combinations  , but I can program any single key to do execute arbitrary common lisp code (including code that simulates text typing and pressing key combinations ,since that was the primary purpose of this program)
[13:05:45] <beach> hayley: Well, your phrase means "I am only INTERESTED in Lisp...", as opposed to also being (say) INVOLVED in it.
[13:06:07] <hayley> Also true, yes.
[13:06:52] <contrapunctus> mfiano: you shared you dissatisfactions with Emacs, I'm sharing my dissatisfactions with Emacs...where's the "holy war"? ü§∑Ô∏è
[13:06:55] <beach> rain3: Sounds very useful.
[13:07:56] <rain3> beach: I may release it after I clean it a bit. it uses codes stolen from here and there
[13:08:03] <mfiano> contrapunctus: Ok good. I didn't want to imply I was claiming "the other editor" to be superior to Emacs in any way, especially CL interaction (because it is severely lacking there)
[13:09:08] <lisp123> What are the deficiencies of Emacs for CL interaction? Does it boil down to having to pass data between the CL image and Emacs?
[13:09:56] <akater[m]> Common Lisp has a community with attitude to programming that I'm comfortable with, good compilers, good books, and if I had enough money, I'd spend it on adding proper CL support to Emacs.  It's just that there are less and less reasons to write in CL when Elisp gradually gets feature parity.  I have only one CL library published ‚Äî due to optimisation techniques that would be wasted in Elisp at the moment.
[13:10:18] <lisp123> I have started writing some tools that go across Elisp & CL, its annoying having to learn parts of the Elisp API & rules, but I wonder if they alternative of not having an Elisp approach will make it harder to write text editing tools for CL
[13:10:31] <hayley> In part. Other pain points include that the syntax detection in Emacs could be better, the debugger interface could be better, and generally a real "integrated development environment" needs more information passed to the editor.
[13:10:37] <mfiano> One of the big mistakes of Vim as it relates to CL integration, is indentation is fully static. If you need some macro to indent differently, you have to add it to a flat file with information about how many spaces to indent it.
[13:10:48] <rain3> akater[m] why not contribute to Climacs
[13:11:55] <mfiano> For Emacs, it has similar problems with indentation, but at least it is dynamically reconfigurable with SLIME.
[13:12:37] <lisp123> hayley: ok that makes sense. I guess one is limited to Emacs UI (which is quite unique and can't really be extended without hacks). I think syntax detection could be improved with simply more refined code on the Elisp side, unless I am missing some particular difficulties
[13:12:59] <mfiano> CL indentation piggybacks off of elisp indentation code in Emacs, and as such, is not aware of packages. If you load 2 macros into your image that should both be indented differently, the latter one will get added to the "lossage table", and the indentation of the former will be used.
[13:13:08] <mfiano> That is, indentation is only symbol-name aware
[13:14:14] <beach> lisp123: Emacs doesn't do a good job analyzing the Common Lisp code.  It has no idea of the role of different symbols for instance.  Try (let ((x<newline> 234) (prog1<newline> 234))... and observe the mysterious difference.
[13:14:50] <mfiano> beach: I found a really ugly indentation case recently
[13:14:55] <_death> mfiano: slime has a cl-indent module, and it takes packages into consideration.. it had an issue with package nicknames, which I patched in my slime fork
[13:15:21] <beach> akater[m]: So you are trying to convince is to switch?
[13:15:28] <mfiano> beach: https://gist.github.com/mfiano/0e741f97d1f2657eaa95d8802f975648
[13:15:39] <beach> _death: This is not a package issue though.
[13:16:04] <mfiano> "DEF"* in operator position indents it like an operator, even if said symbol is uninterned or it is some arbitrary DSL list like :depends-on
[13:16:11] <beach> mfiano: Wow, yes, I see.
[13:16:13] <lisp123> beach: thanks, that's a strange result. Will look into it. Okay that is helpful, without full understanding of the CL image, I can imagine it would be harder to get all edge cases right for indentation
[13:16:17] <hayley> Another thing is that, even with the big and fancy IDEs, you still are spending time looking at dead code. While it is not hard to come up with testing data to poke at after you learned some library, you start out with some dead code, and documentation if you are lucky.
[13:16:46] <akater[m]> rain3: Mostly because I have not seen a single Climacs user.  The proper way would be to add CL runtime to Emacs in parallel to Elisp.  5000 packages can't be replaced.  Org and magit alone can't be replaced.
[13:17:17] <beach> lisp123: Emacs uses regular expressions to parse the Common Lisp code, which is obviously incorrect for Common Lisp.  That's why Second Climacs uses Eclector instead, which is a full Common Lisp reader, so it analyses the code correctly.
[13:17:51] <rain3> The Best Way to Predict the Future is to Create It
[13:18:00] <hayley> Not to say that copying example code from the documentation doesn't work, of course. But if you care for more Bracha-ware, then this demo of presenting "exemplar" data when you look at code is neat: https://blog.bracha.org/exemplarDemo/exemplar2021.html?snapshot=BankAccountExemplarDemo.vfuel
[13:18:13] <_death> beach: not sure I understand your reply
[13:18:52] <lisp123> beach: But that could theoretically be solved by using the CL reader within Emacs, right? To me it looks like the biggest issue is not having full access to image / package / etc.? That one seems insurmountable
[13:19:25] <hayley> rain3: s/Create/Invent/
[13:19:40] <beach> _death: My example with (let ((x...) (prog1...)) is not a package problem.
[13:19:46] <mfiano> _death: Interesting. I admit it's been some years since I looked at SLIME code, and that I was mostly speaking of Sly above. Does SLIME not have an equivalent of (slynk:print-indentation-lossage) ?
[13:20:02] <beach> lisp123: That's what I just said.  We use Eclector.
[13:20:32] <akater[m]> beach: No of course not.  But I think my observation ‚ÄúElisp is gradually getting feature parity with CL while allowing the same level of freedom of expression and utilizing Lisp code that is very, very compatible, to the point of porting not being needed at all in some cases‚Äù is valuable to anyone who wants CL to prosper.
[13:20:44] <beach> lisp123: But you can't do it with any Common Lisp reader.  It would have to be much better with error recovery.
[13:21:19] <beach> lisp123: Sure, our plan is to run it in the same image as the Common Lisp system.
[13:22:27] <_death> beach: I agree that there are more correct approaches to indentation, but I was replying about the current approach used in slime
[13:22:33] <beach> akater[m]: Oh, we get SOOO many ideas on why Common Lisp is not prosperous at the moment, and each one is accompanied with a different "solution" to the problem.
[13:22:34] <lisp123> beach: Yes that makes sense and I was agreeing. I was mostly replying to the regex part - but yes I agree with you on your points overall
[13:22:44] <beach> _death: Got it.  Sorry.
[13:25:43] <beach> akater[m]: Another way of viewing what you say is that Emacs Lisp is turning into Common Lisp, so that Emacs will become another Common Lisp application.  That sounds great!
[13:26:00] <lisp123> The Elisp approach (heavy use of special variables) is actually not too bad for its specific purposes. Something to consider for any CL text editors of the future
[13:26:45] <beach> lisp123: In what way are special variables good for that particular application?
[13:27:59] *** Joins: Qwnavery (~Qwnavery@user/qwnavery)
[13:28:24] <_death> mfiano: I think there is a precedence order, where if a symbol doesn't have a package-specific indentation, the indentation associated with the symbol's name only is used
[13:28:29] <mfiano> It's my understanding that all local bindings in Emacs are dynamic in scope by default.
[13:28:34] <mfiano> I could be wrong though
[13:28:57] <lisp123> beach: https://plaster.tymoon.eu/view/2634#2634 (I need to find a better example, also I may be jumping on and off from my computer, so apologies if I reply late)
[13:29:49] <lisp123> But stuff like (newline), (insert "asdf"), (line-beginning-position) --> all are standard functions that are much easier to write when you assume which part of a program you are in
[13:30:23] <lisp123> It gets rid of alot of the staging clutter that one may have to introduce by specifying lexical scope
[13:30:27] <beach> lisp123: That looks awful to me.  I would create a parser that would work incrementally each time the buffer contents is altered, and I would have commands like this operate on the output of the parser.
[13:30:59] <beach> lisp123: And that is indeed how we do it with Eclector in Second Climacs.
[13:31:48] <lisp123> beach: As in you use special variables?
[13:32:04] <contrapunctus> akater[m]: Emacs is at its heart a text editor. It's a cool environment and head and shoulders above most software. But even if Elisp suddenly turned into Common Lisp, it would not do a thing about Emacs' core assumptions and limitations.
[13:32:55] <contrapunctus> akater[m]: Org and Magit are...unfortunate relics of the past, same as Emacs, same as 99% of software.
[13:33:09] <mfiano> It's circulatory system has a failing heart then.
[13:33:17] <beach> lisp123: I am afraid I don't see any more usage of special variables in your example, nor in our parser, than would be normal in most programs.
[13:34:20] <rain3> contrapunctus: even git itself, is not very great
[13:34:37] <beach> Speaking of which, let me renew my suggestion for a McCLIM-based application that combines the features of Magit and gitk.
[13:35:18] <lisp123> beach: Its not the best example (also ignore the parser thats a red herring, this is more of a general note). For example, I do not mention which buffer I am working on, which text region I am in, etc. Everything happens on the back of the global values of current-buffer, point (where I am currently in the screen), etc.
[13:35:46] <lisp123> Perhaps you are already doing that, but that was the main point I was making. A beginner just has to type (newline) to get a newline --> no need to specify too many details
[13:36:10] <beach> Sure.
[13:36:32] <mfiano> I am not a fan of implicit global state. I would rather be explicit with the client API
[13:38:58] *** Quits: asarch (~asarch@2806:10ae:7:7289:f634:a401:5f3d:1c16) (Quit: Leaving)
[13:40:35] <lisp123> mfiano: The interest part is that it its implicit global state as the default values for the variable, but you can also override them and be explicit on how you want to use a particular function
[13:40:40] <mfiano> I tend to establish methods on generic function hooks that specialize on a "context", that can usually be extended with some mixin extension to CLOS.
[13:40:55] <lisp123> Most functions work on current-buffer, but you be explicit on which buffer to work on
[13:41:11] <mfiano> But I accept that Emacs is full of global state
[13:43:10] *** Joins: silasfox` (~user@xdsl-84-44-182-29.nc.de)
[13:43:19] *** Quits: silasfox (~user@2001-4dd1-68e2-0-286d-7bf4-8223-de6a.ipv6dyn.netcologne.de) (Ping timeout: 268 seconds)
[13:47:18] *** Joins: ln43 (~ln43@user/ln43)
[13:48:38] *** Quits: xsperry (~as@user/xsperry) ()
[13:48:42] *** Quits: pjb (~pjb@user/pjb) (Ping timeout: 260 seconds)
[13:49:07] <mfiano> beach: Do you use stealth-mixin for more recent projects other than Gsharp?
[13:49:31] <beach> SICL uses it in a few places.
[13:49:40] <mfiano> Ah
[13:49:48] <beach> We add slots to instructions to avoid hash-table lookups.
[13:49:49] *** Joins: silasfox (~user@2001-4dd1-68e2-0-286d-7bf4-8223-de6a.ipv6dyn.netcologne.de)
[13:49:51] <beach> for instance.
[13:50:01] *** Quits: silasfox (~user@2001-4dd1-68e2-0-286d-7bf4-8223-de6a.ipv6dyn.netcologne.de) (Client Quit)
[13:50:03] *** Quits: silasfox` (~user@xdsl-84-44-182-29.nc.de) (Remote host closed the connection)
[13:50:06] <beach> And just yesterday, I used it to add a slot to a Clostrum class.
[13:50:59] <mfiano> It sounds like something that would be useful for a project I have been designing on paper for a while. Reading more of the paper...
[13:51:04] <jackdaniel> I'm using it sometimes to add a protocol class to an unrelated 3rd-party class when I want to incorporate it
[13:52:53] *** Joins: silasfox (~user@2001-4dd1-68e2-0-286d-7bf4-8223-de6a.ipv6dyn.netcologne.de)
[13:52:56] *** Quits: silasfox (~user@2001-4dd1-68e2-0-286d-7bf4-8223-de6a.ipv6dyn.netcologne.de) (Client Quit)
[13:53:05] *** Joins: silasfox (~sbv@2001-4dd1-68e2-0-286d-7bf4-8223-de6a.ipv6dyn.netcologne.de)
[13:56:55] <rain3> https://github.com/ahefner/piddling-plugins  <- uses stealth-mixins to achieve dynamic plugin effect
[13:58:09] *** Joins: tfeb (~tfb@host81-129-8-142.range81-129.btcentralplus.com)
[13:59:25] *** Quits: ln43 (~ln43@user/ln43) (Quit: Connection closed)
[14:02:07] *** Parts: pranavats (3fba1d1b34@jabberfr.org) ()
[14:02:11] *** Quits: tfeb (~tfb@host81-129-8-142.range81-129.btcentralplus.com) (Read error: Connection reset by peer)
[14:02:32] <mfiano> rain3: Thanks for the link. I hadn't seen it before
[14:05:33] <_death> beach: I see that there is a paper "Using Stealth Mixins to Achieve Modularity" but the stealth-mixin repository does not contain it.. is there a link to it?
[14:05:58] <beach> Unfortunately not.  I think that conference was pretty strict about copyright.
[14:06:47] <mfiano> I could only find it on IEEE Xplore, if you have access
[14:07:58] *** Quits: kakuhen (~kakuhen@user/kakuhen) (Quit: Leaving...)
[14:10:53] <rudi> also sci-hub but as a working scientist I strongly discourage the use of a website where papers are freely accessible to the public
[14:11:49] <_death> ;)
[14:12:19] <hayley> "What's a pirate's favourite letter? P, without it they would be irate."
[14:12:54] *** Quits: cosimone (~user@151.14.38.15) (Remote host closed the connection)
[14:12:55] <beach> rudi: Are you the "Rudi" I know?
[14:13:27] <rudi> In the sense that I had some wine at your home once?
[14:13:30] <mfiano> I am against piracy and try to support creators as much as I can, but at the same time, I do not believe in these paywalls for research information where the creators don't even get any of the money.
[14:13:46] <beach> rudi: Wow, long time no see!  Welcome back!
[14:13:57] <Qwnavery> hayley: heh
[14:14:04] <jackdaniel> well, there's also that these paywalls shield public from accessing knowledge funded from public money ,)
[14:14:23] <hayley> gilberth told me he would be fine with it, but that doesn't make it legal of course.
[14:14:30] <rudi> mfiano: scientific publishing is weird and screwed up - any author will be so happy if you read their paper, and we don't collect any royalties
[14:15:00] <rudi> so - sci-hub away! It's good for everyone except Elsevier's bottom line and they can go *** ***** ****
[14:15:11] <mfiano> Right that was my point, and jackdaniel touched on the other aspect I was going to comment on...._publicly_ funded research
[14:15:13] <rudi> beach: I'm still mostly gone, just hanging out ;)
[14:15:23] <Qwnavery> arXiv for the win
[14:15:30] <beach> rudi: Still.
[14:15:47] * jackdaniel quickly check mcclim copyrights
[14:16:04] <jackdaniel> and is englightened ,)
[14:16:08] <rudi> beach: while I'm procrastinating - have you looked at tree-sitter? They use GLR for incremental parsing and most-likely-error-location
[14:16:30] <rudi> Seems to work ok for them in practice, cross-language
[14:16:50] <beach> rudi: Yes, I looked into GLR at the time was into parsing.
[14:17:04] <beach> jackdaniel: You will find rudi's name in a few McCLIM files.
[14:17:22] <jackdaniel> sure, I remembered that there was some Rudi, that's why I have checked
[14:17:29] <jackdaniel> (and got englightened)
[14:17:32] <beach> Heh.
[14:17:45] <rudi> haha, I was in the periphery of many projects
[14:17:47] <beach> rudi: But not specifically at tree-sitter.
[14:18:23] <rudi> beach: it seems to work in practice, if not in theory.  (It's quite recent, maybe 3-4 years old)
[14:19:08] <beach> Interesting!  I should have a look.  Now, though, scymtym is in charge of most of the parsing I am using, and he is mostly using packrat parsing.
[14:21:12] *** Joins: scymtym (~user@2001:638:504:20e6:6ac3:87e0:e782:f3fc)
[14:21:25] *** Quits: silasfox (~sbv@2001-4dd1-68e2-0-286d-7bf4-8223-de6a.ipv6dyn.netcologne.de) (Quit: WeeChat 3.2)
[14:22:28] *** Joins: silasfox (~user@2001-4dd1-68e2-0-286d-7bf4-8223-de6a.ipv6dyn.netcologne.de)
[14:23:30] <rudi> It looks like emacs 29 will have support for tree-sitter built-in. Meaning in practice, major modes can tell emacs to load the dynamic library containing the parser for their language, and then always have access to an up-to-date parse tree
[14:24:54] <beach> rudi: The problem is that Common Lisp does not have a fixed syntax.  That's why we use Eclector to parse Common Lisp code in Second Climacs.
[14:25:03] <_death> it might be better than regexes, but CL's syntax is very context-dependent, so perhaps tree-sitter won't be too useful..
[14:25:17] <beach> Exactly.
[14:25:28] <rudi> right, I assume so.  It's a cheap way of supporting the n+1 other languages out there
[14:26:22] <beach> rudi: It takes into account things like read tables, but it can also do Common Lisp analysis, so it can determine different roles of the same symbol.
[14:27:45] <_death> I was somewhat disappointed that each language had a totally independent parse tree representation, without some baseline or higher level commonality..
[14:27:58] <mfiano> beach: Reading your stealth-mixin paper is scaring me. The progression of possible solutions happens in the same sequence as some recent thoughts I had for a similar modular project.
[14:29:29] <mfiano> The two different ways of obtaining attributes with the hash table mediator is very unsatisfactory, and about where I left off before writing my mixin solution.
[14:30:07] <mfiano> Plus it assumes that the keys that are to be consumed by the view be exported from the model, or interned into the keyword package...both poor solutions to the problem.
[14:30:39] <jackdaniel> meet mop, the saviour ,)
[14:30:44] *** Quits: Qwnavery (~Qwnavery@user/qwnavery) (Quit: WeeChat 3.2)
[14:31:09] *** Joins: random-nick (~random-ni@87.116.183.93)
[14:31:21] <mfiano> I need to be exposed to more MOP code. My use of it has been few and far between
[14:31:37] <beach> mfiano: I see.
[14:32:36] <jackdaniel> mfiano: reading through amop is a very fine experience - it is written in a very digestable way (along with the motivation for mop, open questions for its future development etc)
[14:32:54] <jackdaniel> and as well - practical problems that inspired particular solutions
[14:33:23] <mfiano> I think I read some of it years ago. It might be on my bookshelf somewhere still.
[14:33:53] <mfiano> I have a hard time finding practical solutions to problems using the MOP for the stuff I work on.
[14:34:22] <jackdaniel> that's why I've mentioned amop, that gives you some "mindset exposure" I suppose
[14:34:27] <mfiano> Probably just because I haven't had much MOP exposure
[14:34:39] <_death> there's also the Paepcke book
[14:35:40] <_death> Object-Oriented Programming: The CLOS Perspective.. it has some nice papers about CLOS and MOP
[14:35:42] <mfiano> Ok, I'm moving those 2 books to the top of my reading queue.
[14:35:55] <mfiano> Indeed I have them
[14:36:12] <mfiano> Thanks btw!
[14:36:29] <jackdaniel> sure. I haven't read the other book
[14:38:23] <mfiano> Oh no, I don't have the Paepcke book
[14:38:41] <mfiano> I confused it with a similar title...the Keene book
[14:39:08] *** Joins: seok (~Seok@n114-73-75-18.bla3.nsw.optusnet.com.au)
[14:40:36] <seok> How does py4cl work? where is the python environment ?
[14:43:20] <_death> it works by communicating with a python process
[14:44:10] <_death> unfortunately it doesn't cleanly separate control and data
[14:44:17] <rain3> https://github.com/rainthree/manardb/blob/master/src/mop.lisp
[14:46:47] <akater[m]> beach: The fact that Elisp is on the track of getting feature parity with CL doesn't mean it turns into a Common Lisp application unfortunately.  Code is very compatible but still not automatically translatable.  My point is, people get to write essentially the same code they would be writing in CL but in a much more rewarding environment: immediate applications to everyday needs, larger community (bound by political goals, not solely
[14:46:47] <akater[m]> technical, which also works in its advantage), and with feature set offered by the language getting closer and closer to that of CL.  If feature parity is ever achieved (the advantages listed above make it likely), there'll be virtually no reason to even look at CL anymore ‚Äî except if you want an ANSI standard language no matter what, or implementanion-specific features ‚Äî by that time it will likely be easier to add them to Elisp
[14:46:47] <akater[m]> compiler(s) as well.
[14:46:47] <akater[m]> I'm not making any conclusions.  It's just that many people would say CL is in a somewhat undesirable situation because parenthesis, or because Clojure/Scheme attracts all the mindshare, or because ‚ÄúLisp curse, get a language with more bondage or die out‚Äù.  Elisp story shows that all this is not very important.
[14:47:31] <hayley> Hm.
[14:47:48] <hayley> I am tempted to disagree, because some people only think that Lisp can be a scripting language. They wouldn't dare write a whole application in Lisp.
[14:49:56] <beach> They only THINK that? :)
[14:50:05] <_death> one feature of CL is that it has a standard
[14:50:38] <hayley> It seems I have given beach ideas.
[14:51:48] <White_Flame> I think emacs might put off non-lisp people more than lisp itself :-P
[14:51:57] <beach> hayley: You wouldn't believe how many times I corrected jimka's dissertation for strange places for "only".
[14:52:03] <mfiano> White_Flame: Agreed, lol
[14:52:10] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Ping timeout: 268 seconds)
[14:52:16] <hayley> Not only do people think that Lisp is good for scripting, they also act upon their thoughts and don't write applications in Lisp.
[14:52:25] <_death> often I see certain people on the emacs-devel list pushing for backwards-incompatible changes (although others do an admirable job of resisting the agents of chaos ;)
[14:52:36] *** Joins: amb007 (~a_bakic@91.133.22.93.rev.sfr.net)
[14:52:36] <jackdaniel> right, I often have a feeling that many people are dropping the idea of learning cl because they are shoved with emacs (as in a package)
[14:53:05] <beach> jackdaniel: That happened recently with my brother. :(
[14:54:06] <hayley> There is a substantial stretch between "I use Lisp to customize a text editor" and "I use Lisp to implement all of the network stack that one can reasonably be expected to implement".
[14:54:19] <mfiano> At least we all don't converge to AutoLisp conventions
[14:54:24] *** Joins: john-a-carroll (~john-a-ca@host-92-28-178-6.as13285.net)
[14:54:27] <jackdaniel> beach: I'm sorry to hear that
[14:55:02] <beach> Me too!  But it is not essential that he learn Common Lisp.  He is a hardware person.
[14:55:15] <jackdaniel> despite knowing emacs on a level to use it daily it still pisses^wamuses me with its warts
[14:56:00] <hayley> (Last week I got to remark to my classmates that I found the "crash Emacs" button. It hasn't crashed before.)
[14:56:14] <beach> I am thinking that Second Climacs could be a solution.  It is not particularly tied to any keys and such.
[14:56:46] <jackdaniel> emacs has cua mode as well, I don't think that keys are the, ekhm, key problem :)
[14:57:01] <beach> "cua"?
[14:57:54] <jackdaniel> I don't remember the exact actronym, but cua is "standard shortcuts - C-c for copy, C-v for paste etc)
[14:58:07] <mfiano> Common User Access
[14:58:36] <jackdaniel> I'm not sure whether these conventions were pioneered by ms or apple but they are adopted in various user-facing applications (and treated often as granted)
[14:58:51] <White_Flame> at least home/end keys, and ctrl-del/shif-t-del/shift-ins generally work nowadays
[14:58:58] <beach> jackdaniel: So what is the problem with Emacs, and why could that problem not be solved with Second Climacs?
[14:59:12] <jackdaniel> I have not asserted that it can't be solved with second climacs
[14:59:24] <beach> Oh, misunderstood.  Sorry.
[14:59:56] *** Joins: pjb (~pjb@user/pjb)
[15:00:09] <jackdaniel> one of emacs issues I have constantly are ever-changing buffers, it is hard to keep a constant layout (and I'll just wave my hand at people who will say that with sufficient amount of elisp I may prevent that)
[15:00:32] <mfiano> jackdaniel: Can you elaborate?
[15:00:35] <beach> Yes, I see.
[15:01:00] <beach> I mean, it would be cute if we supplied a mostly-VIM-compatible interaction style for Second Climacs.  Then VIM users would have a better Common Lisp editing environment that Emacs users. :)
[15:01:20] <beach> s/that/than/
[15:01:21] <jackdaniel> mfiano: say I'm running some application from a repl, and I have two buffers with the source code. then I have an error and a debugger pops in in a random place
[15:01:28] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 252 seconds)
[15:01:36] <jackdaniel> then I start magit, it also opens in a random place destroying my layout
[15:01:43] <beach> Yes, that is annoying.
[15:01:59] <mfiano> Ah yes, I have a couple solutions to that problem
[15:02:04] <jackdaniel> so I'm struggling to reposition my windows so I can have a look at _what I'm currently doing_
[15:02:15] *** Quits: amb007 (~a_bakic@91.133.22.93.rev.sfr.net) (Read error: Connection reset by peer)
[15:02:24] <jackdaniel> yes, I've tried a few but all that amounts for a pain. Currently I'm storing the frame layout in a register
[15:02:31] <mfiano> One is to use Sly, which patches SLIME to pop up new buffers in a deterministic window. The second is to use purpose-mode, to extewnd that to any Emacs package :)
[15:02:38] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[15:02:46] <lotuseater> jackdaniel: Oh I totally know what you mean. :)
[15:03:50] <jackdaniel> either way that's the problems of a person who uses emacs for years, imagine that you want to learn common lisp and you are strongly asserted that doing CL without Emacs (and SLIME) is bad‚Ñ¢ and that you should learn emacs
[15:04:41] <jackdaniel> in other words, I believe that a nice environment in cl (with sub-par features compared to emacs) would be superior (for learning purposes, and for seasoned emacs users like myself)
[15:04:52] <White_Flame> this is also why I always push back as emacs being an "IDE".  It's not, it's just a general editor
[15:06:07] <jackdaniel> needless to say, marketing-wise having LSP implementation for CL would be beneficial for folks with random editors like vscode
[15:06:15] <White_Flame> emacs is not very integrated as far as the editor's awareness of your project/workflow is concerned
[15:06:39] <pjb> jackdaniel: embrace them ever-changing buffers.  Store your position and window configuration in registers! C-x r C-h #| ERROR: Unbound variable: c-h |#
[15:06:47] <pjb> s/ #| ERROR: Unbound variable: c-h |# //
[15:07:10] * jackdaniel waves his hand at pjb
[15:12:44] *** Quits: alanz (sid110616@id-110616.highgate.irccloud.com) ()
[15:13:00] *** Joins: alanz (sid110616@id-110616.uxbridge.irccloud.com)
[15:13:09] <mfiano> jackdaniel: LSP would be a step backwards as the protocol lacks too much required by CL, and poorly defines others.
[15:13:24] <jackdaniel> that's why I've mentioned "marketing-wise"
[15:13:44] <mfiano> and DAP would be needed to "catch on"
[15:13:50] <rudi> both LSP and tree-sitter are Worse Is Better solutions
[15:13:59] <mfiano> But I consider that a failure at this point, given current editor support
[15:14:15] <jackdaniel> supporting worse *and* providing better solutions sounds like a good pitch, doesn't it?
[15:14:26] <rudi> jackdaniel: there's tab-bar-history-back (I bind it to C-c t C-/) and winner-mode
[15:15:16] <jackdaniel> rudi: I've tried a few things and I'm (barely) satisfied with juggling with frame registers, I've sank enough time on configuring emacs to not want to try it again - thanks though!
[15:16:51] *** Joins: yitzi (~yitzi@173-27-106-188.client.mchsi.com)
[15:17:40] <mfiano> That's the thing about Emacs. You allocate a few minutes of your time to fix one thing, and 2 weeks later you have a new config due to everything tripping over all the global state and monkey-patching of foreign packages.
[15:19:05] <yitzi> mfiano: DAP is not quite as bad as LSP as far as CL is concerned, IMHO. I have a CL DAP inside of common-lisp-jupyter and biggest problem is supporting restarts which I did by adding extra stuff to the continue request.
[15:19:41] <rudi> "So, how did you spend the pandemic year?" "Well, there's this text editor ..."
[15:21:26] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Read error: Connection reset by peer)
[15:22:54] *** Joins: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com)
[15:23:02] <mfiano> yitzi: I was just stating that editor implementation support is lacking compared to LSP, making it not very far reaching or robust.
[15:25:04] *** Quits: john-a-carroll (~john-a-ca@host-92-28-178-6.as13285.net) (Ping timeout: 252 seconds)
[15:28:11] *** Quits: Lycurgus (~juan@98.4.112.204) (Quit: Exeunt)
[15:28:23] <yitzi> mfiano: Ok, understood.
[15:37:20] *** Quits: yitzi (~yitzi@173-27-106-188.client.mchsi.com) (Quit: Leaving)
[15:37:26] *** Quits: theBlackDragon (~dragon@fvwm/admin) (Ping timeout: 260 seconds)
[15:39:39] *** Quits: rain3 (~rain3___@2a02:2f09:d30b:1300:514:bcc7:8202:1798) (Ping timeout: 268 seconds)
[15:44:29] *** Joins: ln43 (~ln43@user/ln43)
[15:50:01] *** Quits: shka (~herr@109.231.62.239) (Quit: Konversation terminated!)
[15:50:19] *** Joins: shka (~herr@109.231.62.239)
[15:54:15] *** Joins: theBlackDragon (~dragon@fvwm/admin)
[16:02:02] *** Quits: icer (eric@gateway/vpn/protonvpn/icer) (Ping timeout: 265 seconds)
[16:07:23] *** Joins: Fare (~fare@2601:184:4a7f:995c:f32:c0e3:1269:a9d)
[16:10:09] *** Joins: tyson2 (~user@70.31.33.162)
[16:11:56] *** Joins: yitzi (~yitzi@172.98.105.250)
[16:17:55] *** Quits: khrbt (~znc@user/khrbt) (Ping timeout: 252 seconds)
[16:18:09] *** Joins: khrbt (~znc@user/khrbt)
[16:18:20] *** Quits: ln43 (~ln43@user/ln43) (Quit: Connection closed)
[16:23:12] <_death> beach: I've read the stealthy mixins paper.. I think it's a good solution for annotations.. for the events problem, I think the usual solution is the "observer" pattern, often with per-instance granularity, which may be efficient for some scenarios and inefficient for others, but the paper made no mention of it.. for implementation of the idea, I'm not sure I'd go with a define-stealth-mixin operator that includes defclass
[16:23:13] <_death> functionality, but maybe instead have an install-stealth-mixin operator (and have a remove-stealth-mixin operator)
[16:31:03] *** Quits: nckx (~nckx@tobias.gr) (Quit: Updating my Guix System <https://guix.gnu.org>)
[16:32:03] *** Joins: nckx (~nckx@tobias.gr)
[16:33:28] *** Joins: rain3 (~rain3___@2a02:2f09:d30b:1300:514:bcc7:8202:1798)
[16:33:49] *** Joins: pranavats (3fba1d1b34@jabberfr.org)
[16:37:03] *** Quits: nckx (~nckx@tobias.gr) (Quit: Updating my Guix System <https://guix.gnu.org>)
[16:42:23] *** Joins: nckx (~nckx@tobias.gr)
[16:51:51] *** Quits: nckx (~nckx@tobias.gr) (Quit: Updating my Guix System <https://guix.gnu.org>)
[16:55:02] *** Quits: silasfox (~user@2001-4dd1-68e2-0-286d-7bf4-8223-de6a.ipv6dyn.netcologne.de) (Remote host closed the connection)
[16:55:04] *** Joins: silasfox` (~user@2001-4dd1-68e2-0-286d-7bf4-8223-de6a.ipv6dyn.netcologne.de)
[16:55:42] *** silasfox` is now known as silasfox
[17:00:22] *** Joins: frgo (~frgo@dynamic-046-114-146-001.46.114.pool.telefonica.de)
[17:02:43] *** Joins: silasfox` (~user@xdsl-84-44-182-29.nc.de)
[17:03:24] *** Joins: X-Scale (~ARM@46.50.5.253)
[17:03:44] *** Quits: silasfox (~user@2001-4dd1-68e2-0-286d-7bf4-8223-de6a.ipv6dyn.netcologne.de) (Ping timeout: 268 seconds)
[17:04:52] *** Joins: nckx (~nckx@tobias.gr)
[17:08:03] *** Quits: Fare (~fare@2601:184:4a7f:995c:f32:c0e3:1269:a9d) (Ping timeout: 268 seconds)
[17:09:36] *** Quits: specbot (~specbot@common-lisp.net) (Remote host closed the connection)
[17:09:36] *** Quits: minion (~minion@common-lisp.net) (Read error: Connection reset by peer)
[17:09:59] *** Joins: specbot (~specbot@common-lisp.net)
[17:09:59] *** Joins: minion (~minion@common-lisp.net)
[17:26:07] *** Joins: Bike (~Glossina@71.69.170.70)
[17:26:07] *** ChanServ sets mode: +o Bike
[17:32:45] *** Joins: peterhil (~peterhil@dsl-hkibng32-54fb52-57.dhcp.inet.fi)
[17:33:02] *** Joins: makomo_ (~makomo@user/makomo)
[17:39:17] *** Joins: frgo_ (~frgo@dynamic-046-114-150-059.46.114.pool.telefonica.de)
[17:40:43] <beach> _death: Thanks.
[17:41:45] *** Quits: frgo (~frgo@dynamic-046-114-146-001.46.114.pool.telefonica.de) (Ping timeout: 268 seconds)
[17:44:01] <mfiano> beach: I am confused at what you mean when you say you specialize on an instance rather than a class, and then the method lambda list in the associated figure looks like (class (name (eql 'c)) ...)
[17:47:14] <beach> I am sorry, but I don't remember.  I can re-read the paper if you like (but I don't have time right now).
[17:48:21] *** Joins: raeda_ (~raeda@72.49.219.33)
[17:48:38] <_death> an instance of symbol
[17:48:44] *** Quits: raeda (~raeda@72.49.219.33) (Remote host closed the connection)
[17:49:06] <beach> Maybe so.
[17:49:14] <mfiano> Ah it was talking about instances of metaclasses so I assumed I missed something
[17:51:05] <mfiano> I haven't finished reading the paper yet. My mind is multi-tasking today. One thing that I didn't see mentioned (yet) is the utility of being able to specify WHERE in the superclasses of the victim class the new class is inserted.
[17:51:31] <mfiano> This becomes important in my own codes at least, as I use progn method combination a lot with mixins :)
[17:52:03] <beach> I am pretty sure we didn't think of that.
[17:52:04] <_death> mixins should usually come first, so that's what it does
[17:52:20] <mfiano> Sure, but first is not specific enough when multiple exist
[17:52:48] *** Quits: silasfox` (~user@xdsl-84-44-182-29.nc.de) (Quit: ERC (IRC client for Emacs 27.2))
[17:53:09] <mfiano> In our codes, our define-* macro includes information for a topological sorting of mixin classes
[17:53:10] <_death> indeed when that matters you may need some way to specify precedence
[17:53:28] <beach> I am still angry with my co-author (John Hamer) about that paper.  He and I were both in Auckland when we wrote the paper together, and I was back in Bordeaux when the conference took place, but he refused to take the 3 hour flight to Melbourne, so I had to take the >20 hour flight from Bordeaux.
[17:56:56] <jmercouris> maybe he has a fear of fllying
[17:56:58] <mfiano> I tend to agree with _death though about being able to install/deinstall a mixin and perhaps removing the need for the define-* form
[17:57:18] <beach> jmercouris: Nah.
[17:57:28] <mfiano> It could be made more dynamic this way, changing the class of an arbitrary standard-instance at runtime for example
[17:57:33] <_death> with an install operator you can have a single class be a mixin for multiple victims, for example
[17:58:19] <mfiano> and that
[18:00:25] <beach> OK, I have a suggestion.  This is a small-ish library, so someone should feel free to either clone it and improve it, or just create a better one.  Once it is in Quicklisp, I'll use the new one instead.
[18:01:25] <pjb> beach: and you didn't find any compensations from this travel itself?
[18:02:02] <mfiano> I was thinking of possibly doing that actually, whenever I get time. I tend to copy/modify my smallish mixin code I linked above in various projects
[18:03:23] <beach> pjb: I don't remember, but stuff like that was typically reimbursed by my employer.  But that's not the point.  It's more about the wasted jet fuel and time.
[18:03:40] <beach> mfiano: Perfect.
[18:12:22] *** Joins: john-a-carroll (~john-a-ca@host-92-28-178-6.as13285.net)
[18:17:50] <mfiano> beach: Do you still write papers with a proportional font for Common Lisp code blocks? I will admit it is a bit difficult to read some of the code for me :)
[18:18:50] <beach> No, I don't.  I suspect the layout was done by Hamer.
[18:19:18] <beach> Or maybe the publisher re-typed it.
[18:21:31] <mfiano> Well they suck. The backtick is a stylized single "close" quote, very hard to differentiate between a quote character unless you look carefully.
[18:22:42] <mfiano> Actually no, it appears the backtick is an open quote and quote is a close quote.
[18:28:23] *** Quits: frgo_ (~frgo@dynamic-046-114-150-059.46.114.pool.telefonica.de) (Read error: Connection reset by peer)
[18:28:29] *** Joins: frgo (~frgo@p200300deef0cee00398daaa4f322e80b.dip0.t-ipconnect.de)
[18:35:21] *** Joins: nature (~nature@mail.blazebone.com)
[18:37:43] <jcowan> I doubt that's the font: some upstream process is trying to change straight to curly quotes, even in code.
[18:44:06] <mfiano> _death: is the "observer" pattern useful in Lisp? I'm not aware of what exactly this pattern is without reading GOF...
[18:44:40] *** Joins: vats (~vats@103.70.83.191)
[18:44:58] <_death> mfiano: of course it's useful..
[18:45:35] <mfiano> I was under the impression most design patterns were invented to work around the design mistakes of class-centric object systems
[18:46:49] *** Joins: cosimone (~user@2001:b07:ae5:db26:d2bc:859:4e2a:62c4)
[18:48:18] <saltrocklamp[m]> i think the idea of "having a collection of listeners that are notified upon certain events" is definitely not an OO-specific pattern
[18:49:03] <_death> mfiano: I don't take that view.. while they may be implemented differently or as part of the language in Lisp, it's still useful to name and describe these patterns
[18:49:17] <rain3> http://faculty.chas.uni.edu/~wallingf/teaching/172/materials/session13/ the observer pattern
[18:49:29] <mfiano> I usuallly handle that problem with a progn method as to not couple that information to the subject
[18:49:49] <mfiano> Maybe that is bad? I don't know
[18:50:49] <beach> As I recall, in traditional object-oriented languages, the observer pattern has to be implemented by the observed, so it has to be designed in from the start.
[18:51:13] <beach> Whereas in Common Lisp, any client can observe anything.
[18:51:29] <_death> what do you mean by "anything"?
[18:51:36] <beach> I no doubt forget the details.
[18:52:07] <beach> Well, I guess any generic function specialized to any standard class at the very least.
[18:52:08] *** Joins: ec_ (~ec@gateway/tor-sasl/ec)
[18:52:19] <_death> if you think progn combination or :before/after, that means you need the right GFs
[18:52:41] <_death> so you need to think of the events you want to make possible to listen to anyway
[18:53:10] <beach> You may be right.  I should be quiet since I forget the details.
[18:53:49] <mfiano> In recent codes I push messages to a queue, and eql specialize progn listener methods on the type of message.
[18:54:11] <_death> and with traditional observer as in the GoF book, iirc, you can add/remove listeners to particular instances
[18:54:11] <mfiano> and also the context class of course, to support many listeners per message type
[18:54:29] <saltrocklamp[m]> that's my understanding as well; the observed thing needs to have 1) a collection of things that are observing it, and 2) some way to notify those things. i suppose that's the core of design patterns, managing which parts of the code "know" which pieces of knowled
[18:54:39] <saltrocklamp[m]> how exactly you implement that i think is and should be language-dependent
[18:54:58] <saltrocklamp[m]> *pieces of knowledge
[18:55:16] <rudi> Once in comp.lang.lisp, Richard Gabriel briefly surfaced during an instance of the patterns discussion and said (paraphrased) "If there are no patterns, there's nothing a more experienced programmer can teach a newbie"
[18:55:28] <rudi> I think about this a lot
[18:55:33] <mfiano> I'm not sure what is wrong with that as opposed to the observer pattern that seems to need to have a list of listeners coupled to the observed
[18:55:50] <_death> so if you have a lot of instances and you need to listen to them all, you have duplicate entries which is a bit inefficient.. but if you only need to listen to a few, it makes sense.. the stealth mixins approach is more class-oriented, e.g., all instances will have annotation class slots, whether or not they need them
[18:56:01] <rudi> (FWIW, he also tacitly agreed on the worth of the GoF book ;) )
[18:56:45] <saltrocklamp[m]>  rudi in python help forums, i frequently caution newbies against "learning design patterns", because a lot of the related documentation and literature is very OO-oriented, and i don't want to encourage excessively OO python code
[18:57:39] <rudi> oh, thoroughly agreed about this!  Check out Norvig's "design patterns for dynamic languages" if you haven't yet
[18:57:44] <saltrocklamp[m]> maybe i should be making a more nuanced recommendation, "learn the patterns, but keep in mind that you can implement these things more easily in python/(or whatever) than the examples in C# and Java"
[18:57:46] <random-nick> saltrocklamp[m]: that would mean the observer pattern could just be an observable mixing?
[18:57:47] <saltrocklamp[m]> i haven't, i will!
[18:57:52] <rudi> s/for/in/
[18:58:18] <random-nick> s/mixing/mixin/
[18:58:30] <_death> rudi: yeah, I guess RPG's criticism would be that the GoF book doesn't place enough emphasis on the concept of a "pattern language"
[18:58:31] <rudi> salt rock lamp: it's an extended dunk on the GoF book - highly enjoyable
[18:58:40] *** Quits: shka (~herr@109.231.62.239) (Quit: Konversation terminated!)
[18:58:54] <mfiano> My favorite author describes patterns as purported ‚Äúmaster programmer advice‚Äù strongly suggesting to young or otherwise impressionable programmers that the design patterns convey important concepts, practices, or principles that have been ‚Äúprethought.‚Äù, as if you could simply dish out a small number of generic solutions for generic situations, as opposed to every situation being
[18:58:57] <mfiano> different and warranting its own solution.
[18:59:02] *** Joins: shka (~herr@109.231.62.239)
[18:59:22] <rudi> The best thing that patterns did for me was getting me to read Christopher Alexander's books, which changed me and how I look at the world
[18:59:58] <saltrocklamp[m]> the other thing about GoF design patterns for me is that they're not the kinds of "patterns" that total newbies should be learning. they're really intermediate patterns for when you are progressing to large applications
[19:00:03] <rudi> Here's a pattern talk I enjoyed: https://www.deconstructconf.com/2017/brian-marick-patterns-failed-why-should-we-care
[19:00:10] <saltrocklamp[m]> rudi: what's a book title i can look for?
[19:00:22] <saltrocklamp[m]> A Pattern Language?
[19:01:12] *** Quits: markthom_ (~markthom_@2604:3d09:3e7e:e32e:3b:371e:5b3f:2887) (Quit: Client closed)
[19:01:12] <rudi> salt rock lamp: Hmm, my introduction to Alexander was a chapter in Gabriel's "Patterns of Software"
[19:01:22] <saltrocklamp[m]> i haven't read Gabriel either, i will look that up too
[19:01:24] <rudi> "The Timeless Way of Building" for an intermediate snapshot of his thinking
[19:02:03] <rudi> and "The Nature of Order" for an old-man, "I finally understood this" summary of his life's work
[19:02:11] <_death> rudi: interesting.. I don't think I've read Alexander's books.. or if I did, only a small part
[19:02:15] <rudi> (Beware: none of them apply directly to programming)
[19:06:53] <saltrocklamp[m]> thanks for the recommendations
[19:09:18] *** Quits: makomo_ (~makomo@user/makomo) (Ping timeout: 260 seconds)
[19:09:41] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[19:10:12] <_death> rudi: I think that was a Naggum thread, wasn't it?
[19:10:19] *** Joins: Fare (~fare@2601:184:4a7f:995c:f865:4a3:b1f8:3ac4)
[19:11:47] <_death> later on Naggum wrote a post about a split-sequence operator design which considered syntax-related patterns
[19:12:00] *** Quits: Cymew (~ante@c-e989225c.023-1144-7570702.bbcust.telenor.se) (Ping timeout: 268 seconds)
[19:13:14] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 268 seconds)
[19:14:54] <rudi> It possibly involved EN but I distinctly remember Gabriel popping up while everyone was dunking on both the GoF book and patterns in general
[19:16:49] <_death> maybe https://groups.google.com/g/comp.lang.lisp/c/3GoG3oR9qYA/m/e2ztyh6_EgsJ
[19:16:59] *** Joins: azimut_ (~azimut@gateway/tor-sasl/azimut)
[19:18:45] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Ping timeout: 276 seconds)
[19:21:06] <rudi> It's in that thread, yes: "Here's another true statement about patterns: If there are no such things as... (full message at https://libera.ems.host/_matrix/media/r0/download/libera.chat/a1b3877c7832a07364bcb32a8090be3cf9639e06)
[19:21:17] * rudi apologizes for spam
[19:25:59] <rain3> what spam, thanks for the insights
[19:28:39] <jcowan> The difference once you get past the absolute beginner stage ("What, I have to couont all these parens?") is in writing macros as opposed to using other people's macros.
[19:43:17] *** Quits: john-a-carroll (~john-a-ca@host-92-28-178-6.as13285.net) (Quit: Ping timeout (120 seconds))
[19:46:38] *** lotuseater is now known as rotateq
[19:47:02] *** rotateq is now known as lotuseater
[19:49:22] *** Quits: Fare (~fare@2601:184:4a7f:995c:f865:4a3:b1f8:3ac4) (Quit: Leaving)
[19:49:33] *** Quits: cosimone (~user@2001:b07:ae5:db26:d2bc:859:4e2a:62c4) (Remote host closed the connection)
[19:50:02] <lotuseater> had there been a ROTATEQ in one of the other lisps that predate CL?
[19:51:42] *** Joins: makomo_ (~makomo@user/makomo)
[19:52:11] *** Joins: waleee (~waleee@student-223-182.eduroam.uu.se)
[19:52:36] *** Quits: makomo_ (~makomo@user/makomo) (Client Quit)
[19:55:31] <beach> lotuseater: I don't know the answer, but why do you ask?
[19:56:50] <lotuseater> Just by accident. :) I tried if this as a secondary nickname is still free and as there is ROTATEF I had this thought, like with SETQ and SETF.
[20:06:04] <bhyde[m]> lotuseater: probably not
[20:06:52] <_death> there was SETQQ though ;)
[20:07:08] <lotuseater> Oh where was it? :)
[20:07:21] <lotuseater> And what did it do exactly?
[20:08:22] <_death> it quoted both arguments
[20:08:27] <lotuseater> Back when I wasn't aware about PSETQ, PSETF and ROTATEF it was a good exercise writing a SWAP macro to let two things switch places.
[20:08:34] <lotuseater> Ah okay.
[20:09:44] *** Joins: markthom_ (~markthom_@2604:3d09:3e7e:e32e:3b:371e:5b3f:2887)
[20:09:56] <_death> BBN Lisp had it.. and Interlisp as well
[20:10:30] <lotuseater> The BBN is new to me.
[20:10:41] <bhyde[m]> i'm trying to recall the author of a paper in the mid70s by a guy at CMU that argued for swap and rotate over assignment.  good for reducing memory leaks
[20:11:03] <lotuseater> yay
[20:11:40] <lotuseater> Carnegie Mellon seems to had done much such research, not just CMUCL :)
[20:12:46] *** Quits: waleee (~waleee@student-223-182.eduroam.uu.se) (Ping timeout: 260 seconds)
[20:13:14] <bhyde[m]> i don't recall any (much) lisp at cmu prior to cmucl.
[20:14:48] *** Joins: waleee (~waleee@student-223-182.eduroam.uu.se)
[20:18:53] *** Joins: doyougnu (~user@c-73-25-202-122.hsd1.or.comcast.net)
[20:22:05] *** Quits: iisi (sid19824@id-19824.stonehaven.irccloud.com) ()
[20:22:21] *** Joins: iisi (sid19824@id-19824.hampstead.irccloud.com)
[20:22:50] <beach> Wasn't Spice Lisp at CMU?
[20:26:03] <Shinmera> Heck yeah, I made a big step with my new build system, Forge: https://filebox.tymoon.eu//file/TWpNMU9RPT0=
[20:26:05] <lotuseater> Wikipedia says yes and that from that came the CMUCL implementation.
[20:26:39] <Shinmera> It's now able to analyse a loose graph of dependencies and version constraints, and devise a graph of actions to take to perform the necessary operations to reach a requested effect.
[20:27:55] <beach> Shinmera: Congratulations!  Is Forge meant to replace ASDF?
[20:28:16] <Shinmera> First part of the buffer is the definition of components and operations (similar to ASDF), and effects. RUN-TEST is a simple setup of known components and dependencies. Then the repl shows some sample plans that prove it's properly resolving the version constrains.
[20:28:59] <Shinmera> beach: Sssort of. It will be able to do more than ASDF, but I don't have the time to go rewrite all the ASDs people wrote. So my hope is to have it drop down to ASDF for systems it doesn't have "natively", or provide some kinda translation. Not sure yet.
[20:29:51] <beach> Got it.
[20:30:59] <Shinmera> My next step is going to be devising the RPC stuff and making sure a Lisp image can spin up a Forge process, ask it to do something, and then serve as a client to execute the necessary side-effects. That should allow out-of-process building.
[20:38:01] *** Quits: santiagopim (~user@90.167.66.93) (Ping timeout: 252 seconds)
[20:38:39] <Shinmera> Another neat thing not shown in the above demo is that, since Forge distinguishes the "effect" of something from the operation and component that spawn it, you can have multiple known ways to achieve the same effect in the system, and the chosen policy object can disambiguate it. So for instance in order to achivee "load system A", it can either be loaded from source or loaded from (and
[20:38:41] <Shinmera> potentially compiled to) fasl. The policy could decide on one or the other if it matters to you.
[20:39:03] <bhyde[m]> yup, slice lisp mutated into cmu lisp
[20:39:28] <beach> bhyde[m]: "Spice" not "slice".
[20:40:08] <bhyde[m]> +1
[20:40:26] <lotuseater> So it gets spicy and doesn't get cut into slices. ^^
[20:41:26] <bhyde[m]> custom microcode/instruction sets - popular for a while back then
[20:41:47] *** Quits: d_run (sid83858@id-83858.stonehaven.irccloud.com) ()
[20:42:01] *** Joins: d_run (sid83858@id-83858.hampstead.irccloud.com)
[20:44:58] *** Quits: amb007 (~a_bakic@host.26.88.68.195.rev.coltfrance.com) (Ping timeout: 260 seconds)
[20:45:15] *** Joins: amb007 (~a_bakic@107.133.22.93.rev.sfr.net)
[20:48:44] *** Quits: gendl (sid100083@id-100083.stonehaven.irccloud.com) ()
[20:48:59] *** Joins: gendl (sid100083@id-100083.hampstead.irccloud.com)
[20:53:54] *** Joins: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431)
[20:58:24] *** Joins: Guest734 (~Guest7@97-118-72-33.hlrn.qwest.net)
[20:58:32] <Guest734> phoe oh hellp
[20:58:36] <Guest734> phoe oh hello
[20:58:48] <phoe> Guest734: hello
[20:58:56] <Guest734> is there someone named @phantomics here?
[20:59:09] <Guest734> or who would otherwise be here?
[20:59:58] <phoe> seems like he's not here at the moment
[21:01:09] *** Quits: waleee (~waleee@student-223-182.eduroam.uu.se) (Ping timeout: 268 seconds)
[21:01:10] <beach> The April person?
[21:01:25] <Guest734> yes
[21:01:27] <lotuseater> Guest734: yes but in the last days not :/
[21:01:30] *** Guest734 is now known as Cpt
[21:01:39] *** Cpt is now known as CptJimKirk
[21:02:33] <lotuseater> CptJimKirk: do you have a special question?
[21:02:39] *** Joins: cage (~cage@dynamic-adsl-78-15-41-207.clienti.tiscali.it)
[21:05:13] *** Quits: shka (~herr@109.231.62.239) (Quit: Konversation terminated!)
[21:05:33] *** Joins: shka (~herr@109.231.62.239)
[21:09:17] <CptJimKirk> lotuseater I would like to know about dfns and trains, and whether they exist in April
[21:09:22] <CptJimKirk> and to what extent
[21:09:53] <lotuseater> phew okay so deep I'm not yet into it
[21:11:51] <CptJimKirk> Just looking at the examples of April, it looks like it is actually fusing together K ideas with APL, and I do see {‚ç∫√ó‚çµ} there so I guess dfns exist to a degree
[21:13:16] <lotuseater> a big subset of APL is implemented and still much potential for what could be done
[21:13:48] *** Joins: santiagopim (~user@90.167.66.93)
[21:14:42] <lotuseater> and yes you could also do things like (funcall (april-c "{‚ç∫√ó‚çµ+‚ç∫}") 1 2) but (what I also had to realize) then the first arg is going to the ‚çµ and the second for ‚ç∫
[21:15:18] <lotuseater> or calling it automatically on arrays too of course ^^
[21:16:06] <lotuseater> shall we go to #apl with that?
[21:19:12] *** Quits: CptJimKirk (~Guest7@97-118-72-33.hlrn.qwest.net) (Quit: Client closed)
[21:20:45] *** Joins: Guest794 (~Guest7@97-118-72-33.hlrn.qwest.net)
[21:38:03] *** Joins: Oladon (~olad@98.43.81.226)
[21:39:47] *** Quits: santiagopim (~user@90.167.66.93) (Ping timeout: 268 seconds)
[21:41:40] *** Joins: zxcvz (~tobias@h-158-174-22-178.NA.cust.bahnhof.se)
[21:41:51] *** Quits: Guest794 (~Guest7@97-118-72-33.hlrn.qwest.net) (Quit: Client closed)
[21:41:54] *** Quits: amb007 (~a_bakic@107.133.22.93.rev.sfr.net) (Ping timeout: 260 seconds)
[21:42:10] *** Joins: Guest92 (~Guest92@97-118-72-33.hlrn.qwest.net)
[21:42:34] *** Joins: amb007 (~a_bakic@17.15.23.93.rev.sfr.net)
[21:47:52] *** Quits: tyson2 (~user@70.31.33.162) (Ping timeout: 252 seconds)
[21:54:23] *** Quits: amb007 (~a_bakic@17.15.23.93.rev.sfr.net) (Read error: Connection reset by peer)
[21:55:02] *** Joins: amb007 (~a_bakic@17.15.23.93.rev.sfr.net)
[21:55:03] *** Quits: amb007 (~a_bakic@17.15.23.93.rev.sfr.net) (Read error: Connection reset by peer)
[21:57:02] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[22:02:36] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Ping timeout: 268 seconds)
[22:02:50] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[22:07:16] *** Quits: markthom_ (~markthom_@2604:3d09:3e7e:e32e:3b:371e:5b3f:2887) (Quit: Client closed)
[22:08:11] <Guest92> is there a table of | DESTRUCTIVE FUNCTIONS | NON-DESTRUCTIVE EQUIVALENTS |
[22:08:21] <Guest92> also what is WSCL?
[22:09:00] <Guest92> (which for whatever reason my brain is reducing to [W]est [C]oast CL??? stupid brain)
[22:09:01] *** Joins: santiagopim (~user@90.167.66.93)
[22:10:13] <lotuseater> I wrote it to you for what it stands, Well Defined Common Lisp.
[22:10:32] <Guest92> wouldn't that be WDCL/
[22:10:45] <lotuseater> oh wait ..
[22:12:38] <Bike> i don't know if there's any comprehensive table, but there kind of aren't a lot of pairs like that
[22:12:43] <Bike> probably less than ten?
[22:12:45] <lotuseater> okay then iirc it stands for structured, sry
[22:12:52] <Bike> "well-specified"
[22:13:02] <lotuseater> thanks Bike ^^
[22:15:20] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[22:16:22] <Bike> n/sublis, n/subst(-if(-not)), append/nconc, revappend/nreconc, n/butlast, n/intersection, n/set-difference, n/set-exclusive-or, n/union, n/string-upcase etc, n/reverse, n/substitute(-if(-not)), remove/delete(-if(-not)), remove/delete-duplicates
[22:16:25] <Guest92> what is "well specified common lisp"?
[22:16:34] <Guest92> oh, thanks
[22:16:35] <shka> it is an porject
[22:16:38] <Bike> https://github.com/s-expressionists/wscl
[22:16:45] <Bike> "Well Specified Common Lisp is intended as a more strict version of the current Common Lisp standard. It is more strict in that it attempts to specify required behavior of implementations in many cases where the current Common Lisp standard is either silent on the subject, or specifically mentions unspecified behavior."
[22:17:33] <shka> it is essentially bug fix version of the common lisp standard
[22:17:44] <Guest92> will that include fixing the names?
[22:17:50] <shka> no
[22:17:57] <shka> whatever this means
[22:18:06] <Guest92> ehem... filter *cough*
[22:18:24] <shka> what is wrong with filter anyway?
[22:18:25] <Bike> not going to do anything that incompatible, no
[22:18:36] <Bike> presumably Guest92 means that filter would be a better name than remove-if-not
[22:18:41] <Guest92> yes
[22:18:45] <Guest92> but how about include that
[22:18:46] <Guest92> AND filter
[22:18:53] <Guest92> then its compatible, and also better
[22:19:01] <shka> opinionated
[22:19:07] <Bike> adding symbols can still screw things up because most packages use the CL package
[22:19:11] <jcowan> I spotted something that may be a SBCL bug or a failure to specify:  (symbol-name :) => "" (which is right, I think), but (symbol-name ::) => "" also.
[22:19:15] <Bike> so if they define their own symbol "filter", there's a conflict
[22:19:28] <shka> if there would be new CL standard, chances are that remove-if-not would be simply omitted
[22:19:34] <lotuseater> and the ANSI standard is defined since 1994
[22:20:06] <jcowan> Anyone have a view of whether that belongs in a WSCL or a SBCL ticket?
[22:20:08] <shka> you can instead remove-if (complement predicate)
[22:20:11] <Guest92> re:opinionated yes. "remove-if-not" not only inverts the reading of the word "remove" so that it adds a layer of indirection to the expression, but also is just an obscene amount of characters to type of what is basically a boolean expression
[22:20:24] <Guest92> (3 > x) / x
[22:20:28] <Bike> this is not the kind of question WSCL is supposed to target
[22:20:28] <Guest92> pseudo apl
[22:20:34] <mfiano> I saw some mention of pre-ANSI GENERIC-FLET and GENERIC-LABELS. I guess these got dropped, but I am curious if these would need to be special operators like their non-generic counterparts, or if they could be user-defined macros.
[22:20:35] <Bike> jcowan: how are you doing this? i get an error from either one
[22:21:03] <Bike> mfiano: i don't see any way to define them with flet/labels
[22:21:17] <Bike> you can't use a proxy
[22:21:19] <jcowan> huh, I must have screwed up somehow
[22:22:17] <Bike> i think either one is invalid per 2.3.5 but i'm not sure
[22:22:44] <Guest92> why is there a distinction between let and labels
[22:22:45] <jcowan> Ah, it's ECL that does that.
[22:22:48] <Guest92> or let and let*?
[22:23:00] <Guest92> why would the more general case not simply be default?
[22:23:07] <Guest92> sorry *flet and labels
[22:23:11] <mfiano> Yeah I thought as much. The global environment would have to be used and cleaned up afterwards at best.
[22:23:43] <jcowan> let*  binds sequentially, whereas let binds concurrently
[22:23:54] <jcowan> so let* can be reduced to nested lets
[22:24:07] <jcowan> but let cannot be reduced to let*.
[22:24:12] <Guest92> are let blocks typically so large that actually matters?
[22:24:23] <lotuseater> Guest92: also for runtime security
[22:24:29] <mfiano> We don't call them blocks. "block" means something else entirely
[22:24:29] <Guest92> what does that mean?
[22:24:37] <Bike> sometimes you have enough bindings that nested lets would be inconvenient, sure
[22:24:37] *** Joins: lisp123 (~lisp123@5.30.23.247)
[22:24:40] <Guest92> let ... bodies?
[22:24:48] <jcowan> yes
[22:24:48] <shka> Guest92: label is not more general case of the flet
[22:25:17] <shka> as for let* vs let, lisp is weird language because of the code generation prevalence
[22:25:18] <Guest92> I thought labels was flet but I can refer to a name bound within the same ... ... what ever you call it?
[22:25:28] <Guest92> declaring scope?
[22:25:35] <Bike> in the same form, you could say
[22:25:35] <Guest92> what idk what you call that part of the thing
[22:25:51] <shka> Guest92: consider the following use case
[22:25:53] <Guest92> (labels ((f ...) (g ... mentions f))...)
[22:25:59] <Bike> but that doesn't make it more general. an flet definition referring to a name also bound by the flet isn't undefined, it just refers to an outside definition
[22:26:04] <Guest92> I thought that's the difference between flet and labels that I can mention f in g in labels
[22:26:06] <Guest92> but not in f
[22:26:11] <Guest92> but not in flet******
[22:26:39] <mfiano> Guest92: swap f and g and it will still work, unlike serial LET bindings of course.
[22:26:46] <shka> Guest92: (defun yield (x) x) (defun something () (flet ((yield (x) (yield x))) ...)
[22:26:50] <Bike> the difference is that you can refer to THAT f in g
[22:26:55] <Bike> with flet you can refer to a DIFFERENT f
[22:27:00] <Bike> one isn't a subset of the other
[22:27:18] <Guest92> my point is, in any other language, just use a different name? a more specific name?
[22:27:49] <shka> Guest92: so this code may look weird, but it is something which can be used as a paradigm when programming macros
[22:27:50] <Bike> what?
[22:28:01] <shka> Guest92: you mean, why this convention in particular?
[22:28:08] <Guest92> I can't think of any time you'd define an f, then in a nested place define another f, but then later on in another nested context... another f
[22:28:20] <Guest92> that just seems like the author is bad at naming things
[22:28:25] <Guest92> so just... name things better
[22:28:32] <Bike> They're bad at naming things because they keep naming functions shit like "f"
[22:28:41] <Guest92> I'm using f as an example
[22:29:01] <Guest92> so I don't have to type out a fully qualified name like group-itmes-by-key
[22:29:01] <shka> Guest92: lisp, by convention uses separate names for separate object types
[22:29:04] <Guest92> 15 times in an example
[22:29:21] <shka> so you have defun, but also defmethod
[22:29:54] <Guest92> but isn't that handled by the dispatcher and not the scope in which the function is called?
[22:30:11] <Guest92> like the CLOS associates methods with its typeclass?
[22:30:13] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[22:30:39] <shka> generic function is not an ordinary function
[22:30:42] <Guest92> I realize that I'm probably coming accross as combative, but really its just that I don't know what things are called and I'm trying to understand why things are the way they are
[22:31:12] <Bike> I'd say the basic reason for flet/labels is less about the best way to name things and more about simple semantics
[22:31:15] <Guest92> so not trying to be combative. I really just don't know the difference between flet and labels and why there should be both
[22:31:27] <Bike> flet is the way it is because you say: the functions bound by FLET are evaluated in the environment the flet is in (which includes outer functions)
[22:31:38] <shka> i don't think i can put this any other way, but different semantic leads to different name in lisp
[22:31:43] <Bike> whereas for labels they are evaluated in the new environment
[22:31:54] <Bike> which may do shadowing.
[22:32:04] <shka> lisp rarely reuses symbol meaning
[22:32:40] <Guest92> I don't think I mean to suggest reuse, but that there is 1 actual use, and the other is a more specific though unnecessary use given adequate name separation
[22:32:40] <shka> this is also arguably a good thing
[22:33:08] <mfiano> With flet you can locally "patch" a function in the global environment, and still call it if need be (perhaps in a different branch or as a prologue/epilogue).
[22:33:12] <shka> Guest92: can you provide a specific example of that?
[22:33:21] <shka> because neither flet/labels or let/let* is that
[22:34:03] <Guest92> (defun f ...) (another (play (labels ((f ...) (g ... (f ...))) (f ... this f is the same name as the other one, but "here"))))
[22:34:17] <Guest92> like, just rename (defun f ...) or use a different name for f in labels
[22:34:32] <shka> Guest92: yes, and how this is the same as flet?
[22:34:47] <Guest92> how is flet different than labels if not for this one specific usage?
[22:34:52] <mfiano> Consider (funcall #'f) vs (funcall 'f)
[22:35:01] *** Joins: ln43 (~ln43@user/ln43)
[22:35:21] <lotuseater> the functions defined there can call each other recursively
[22:35:36] <Guest92> not necessarily recursively
[22:35:58] <Guest92> g calls f, doesn't mean f calls f
[22:35:59] <shka> so you would rather do something like (labels () (stuff)) for recursive use case and (labels (:recursive nil) (stuff)) ?
[22:36:10] <shka> am i getting this right?
[22:36:25] <Guest92> I don't know what I would rather do, you're talking about something else
[22:36:31] <Guest92> this is a horrible format for sharing code btw
[22:36:35] <Guest92> what I'm trying to say
[22:36:36] <shka> i agree
[22:36:44] <lotuseater> it is indeed
[22:36:44] *** Quits: robin (~robin@user/terpri) (Read error: Connection reset by peer)
[22:36:49] *** Joins: robin_ (~robin@user/terpri)
[22:36:53] <Guest92> (labels ((f ...) (g ...(call f ...)))
[22:36:56] <Guest92> g calls f
[22:37:01] <Guest92> that is what labels is for
[22:37:10] <Guest92> if this is the most generic form
[22:37:13] <mfiano> Not the only thing, but go on
[22:37:17] <Guest92> then why would you ever want flet
[22:37:19] <shka> well, labels is for label to call itself, actually
[22:37:27] <Guest92> @mfiano I've asked for more information like 5 times
[22:37:50] <Guest92> I have said "what are the differences between flet and labels except g calls f" like 5 times
[22:38:03] <Guest92> if there are differences, I'm all ears, I would like to know what they are
[22:38:31] <shka> Guest92: the difference is that local function defined with labels can call itself, and the function defined with flet can't
[22:38:33] <lotuseater> *sigh*
[22:38:36] <mfiano> Well f could call f in labels. funcall behaves differently as well
[22:38:41] <Guest92> @shka that's what I just said
[22:38:46] <Guest92> labels
[22:38:48] <Guest92> is the generic flet
[22:38:54] <mfiano> No
[22:38:57] <Guest92> it allows me to refer to names in the binding scope
[22:38:58] <mfiano> It is not generic at all
[22:38:59] <shka> Guest92: not really
[22:39:02] <Guest92> how
[22:39:04] <Guest92> is it not generic?
[22:39:07] <mfiano> No
[22:39:12] <Guest92> flet restricts behavior that lables provides
[22:39:12] <lotuseater> he said already to you it's not the generic form
[22:39:13] <Bike> Because flet doesn't do LESS than that, it does something different.
[22:39:16] <Guest92> but they both bind names to functions
[22:39:17] <shka> Guest92: first of all, generic function in lisp has different meaning
[22:39:25] <Guest92> @bike please, ftlog, tell me what that is
[22:39:29] <jcowan> I think this should go to #lispcafe
[22:39:30] <Bike> As I said, the F will refer to an outer function.
[22:39:38] <shka> secondly, labels is not superset functionality of flet
[22:39:40] <Guest92> right
[22:39:42] <shka> not, at, all
[22:39:43] <Guest92> so use a different name
[22:39:43] <jcowan> or rather the Lisp school channel (thinko)
[22:39:54] <lotuseater> or #clschool
[22:40:01] <Guest92> that's what a sensible person would do, use a different name instead of the same one
[22:40:06] <mfiano> Guest92: Calm down and express your problem slowly and clearly in #clschool
[22:40:15] <Guest92> I'm calm
[22:40:19] <mfiano> No need to lay on RET then
[22:40:25] <Guest92> I'm just tired of asking the same question, getting the same non-answer
[22:40:37] <Bike> Guest92: I am telling you why FLET and LABELS are different and FLET is not a subset of LABELS. If you think using FLET like that is dumb, fine, but it does a different thing and its semantics are not a subset of LABELS's semantics.
[22:41:20] <shka> you can't implement labels with flet, and you can't implement flet with labels
[22:41:27] <Guest92> functionally it is. whether its implemented that way or not is not the point I'm making. FLET functionally binds names to functions, labels functionally binds names to functions that can also refer to the names of the functions withing the binding ... area
[22:41:39] <shka> you could implement let with let*, but that would be a little bit pointless
[22:41:40] <Guest92> that means unless you can be more specific, flet is a subset of labels
[22:41:46] <Bike> It's not! People use FLET in this way you think is dumb!
[22:42:01] <Guest92> ok, then please tell me what the actual difference is
[22:42:04] <Bike> It's not a non-issue even if you don't like it.
[22:42:12] <Guest92> i never said what I like
[22:42:16] <Guest92> I'm asking what the differences are
[22:42:30] <Bike> The only difference is how the binding works. That's it. There are no other differences.
[22:42:31] <shka> Guest92: i mean, Bike explained this pretty clear, and that dumb think flet is used for is a real use case for macro programming
[22:42:41] <Guest92> @bike and that's exactly what I'm saying
[22:42:44] <Guest92> the binding works different
[22:42:49] <Bike> But what FLET does is not a subset of what LABELS does. They have different semantics. Programs using one or the other have different behavior.
[22:43:01] <Guest92> maybe I'm using pleb, non-chad CL terms because I don't know what the words are for things
[22:43:18] <Bike> Your terminology is fine, but I think you are confusing an issue of style with an issue of semantics.
[22:43:20] <Guest92> @bike but that isn't what I'm saying... that's something else
[22:43:27] <Guest92> you're saying the behavior is different
[22:43:30] <Bike> Yes.
[22:43:35] <Guest92> yes, and I was saying
[22:43:36] <Bike> It is different.
[22:43:46] <Guest92> "The only difference is how the binding works. That's it. There are no other differences."
[22:43:50] <Bike> Yes.
[22:43:54] <Guest92> but then you added
[22:43:58] <Guest92> the program behavior is different
[22:43:59] <shka> Guest92: which is pretty important difference may i add
[22:44:02] <Guest92> how is it different?
[22:44:11] <Bike> Uh?
[22:44:15] <shka> Guest92: because you can use flet when you can't use labels
[22:44:18] <Bike> How the binding works is obviously part of the program's behavior?
[22:44:22] <Bike> How could it not be?
[22:44:24] <Guest92> ...
[22:44:32] <Guest92> and what I'm trying to say
[22:44:39] <Guest92> is that the only difference so far as I can percieve
[22:44:56] <Guest92> is the availability of the names within the "binding area" as in "the parens within which the names are bound
[22:45:02] <Guest92> yes?
[22:45:24] <shka> Guest92: pretty much, which leads to labels being used for recursive functions
[22:45:27] <Bike> Depends on what you mean by "availability". It is not the case that LABELS necessarily makes more names available than FLET, but rather different names.
[22:45:40] <Guest92> not more or less
[22:45:42] <Bike> or well, it makes different bindings available, i should say
[22:45:57] <Guest92> the names bound within the parens of (labels (...)) are  available within (...)
[22:46:02] <Guest92> whereas with flet, that is not true
[22:46:11] <Bike> Let me give you an example.
[22:46:18] <Guest92> is that not right?
[22:46:22] <shka> Guest92: almost!
[22:46:30] <Guest92> almost... so then what am I missing?
[22:46:33] <Bike> (defun f () 4) (flet ((f () (f))) (f)) => 4
[22:46:40] <shka> Guest92: you miss the global scope
[22:46:43] <Bike> (defun f () 4) (labels ((f () (f))) (f)) => infinite loop
[22:46:52] <Guest92> right
[22:46:54] <Guest92> exactly
[22:46:56] <Bike> Both of these programs are well defined.
[22:47:01] <Guest92> you're saying what I'm saying but you're disagreeing with me
[22:47:04] <Bike> So labels is not a "more generic" version of flet.
[22:47:05] <Guest92> which I don't understand
[22:47:11] <Guest92> yes there is, call it another name
[22:47:33] <Guest92> (defun f() 4) (labels ((g () (g)))) (g))
[22:47:35] <shka> Guest92: yes, because we agree with semantics, i don't understand what we are disagreeing on
[22:47:36] <Bike> Look, if I write (+ 2 2), and I want 5, and you say "just write (+ 2 3) instead", that's a different program.
[22:47:36] <shka> really
[22:47:37] *** Quits: robin_ (~robin@user/terpri) (Ping timeout: 268 seconds)
[22:47:49] <Guest92> look the same thing, but I gave it another name
[22:47:55] *** Joins: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3)
[22:48:01] <Bike> None of these operators are really "needed". We could just use lambda calculus.
[22:48:02] <Guest92> this is where we're diverging
[22:48:27] <Bike> I mean you don't need labels or flet at all. You can use anonymous closures. And you don't even need closures if you do lambda lifting yourself.
[22:48:29] <shka> Guest92: ok, so can you state that you think that labels can do everything flet can and more?
[22:48:34] <Guest92> flet is needlessly restrictive because if you just named things well you wouldn't need its behavior
[22:48:43] <Bike> This is what I meant by a style issue.
[22:49:07] <Bike> You think writing things like this - un "well" as you put it - is wrong. Which is an opinion you're entitled to, but it is a separate question from the actual semantics of the language.
[22:49:10] <lotuseater> so don't simply use it
[22:49:12] *** Joins: robin (~robin@user/terpri)
[22:49:22] <Guest92> @shka (defun f ...) (flet (f () 3) (f)) returns 3
[22:49:33] <Guest92> @shka (defun f ...) (flet (g () 3) (g)) also returns 3
[22:49:35] <Guest92> :O
[22:49:46] <Guest92> @shk waiwaiwai 1 more
[22:49:46] <shka> ok, give me a second
[22:50:00] <Bike> If I said using anonymous functions was bad style and that you should just always use flet instead, that would be a style opinion. But if I said that flet can do everything lambda can do that would not be correct.
[22:50:03] <Guest92> @shka (defun f ...) (labels (g () 3) (g)) what does this return?
[22:50:10] <Guest92> I think its 3
[22:50:14] <Guest92> could be wrong
[22:50:24] <Bike> you dropped some parentheses
[22:50:32] <shka> Guest92: ok
[22:50:35] <Guest92> write, because I'm trying to code inside of irc
[22:50:42] <shka> Guest92: give me 5 minutes
[22:50:50] <Guest92> instead of idk, something that has paredit installed
[22:50:50] *** Quits: amk (~amk@109.255.169.126) (Remote host closed the connection)
[22:50:54] <shka> because it seems you need an example
[22:51:04] <Guest92> yes, that's what I've been asking for for half an hour now
[22:51:06] <Guest92> that would be wonderful
[22:51:09] <Guest92> and thank you for making one
[22:51:17] <shka> you could be more explicit
[22:51:19] <Guest92> ‚Üë not sarcastic
[22:51:28] *** Quits: Guest92 (~Guest92@97-118-72-33.hlrn.qwest.net) (Quit: Client closed)
[22:51:35] <Bike> What do you want an example of, exactly? Oh, well, okay.
[22:51:41] *** Joins: Guest92 (~Guest92@97-118-72-33.hlrn.qwest.net)
[22:51:41] <Guest92> @shka I literally don't know the words to ask more explicitly
[22:51:49] <Bike> What do you want an example of?
[22:51:53] <Guest92> I was trying to be as explicit as possible
[22:52:31] <Bike> We cannot provide an example of a program using flet that could not be rewritten to use labels, any more than we could provide a program using numbers that couldn't be rewritten to use Church arithmetic.
[22:52:34] <Guest92> @bike a proper demonstration that invalidates the assumption of my question, which was for the umpteenth time "what is the difference between flet and labels as it would appear that flet is just a subset of labels"
[22:53:23] <Guest92> I would actually like to know so I don't go around making blunders all over the place
[22:53:35] <Guest92> if its merely a naming thing, then I'm ready to go
[22:53:44] <Bike> Okay. Let's step back. What do you mean by "subset". Because you evidently do not mean that labels's behavior is a superset of flet's behavior.
[22:53:47] <Guest92> if it is changing program behavior, I should like to know what the difference to my program is
[22:54:00] <Guest92> @bike I"m saying labels is the generic form of flet
[22:54:05] <Bike> What does "generic" mean.
[22:54:12] <Bike> Talk to me like I'm five. I'm trying to understand.
[22:54:41] <Guest92> it means that labels does the properly generic form of binding names to *things*, in that I can refer to a *thing* by its *name* within a particular scope
[22:54:45] <Guest92> whereas *flet* does not allow me to do so
[22:54:51] <Guest92> I can define a name, but I'm not allowed to refer to it by name
[22:54:58] <Guest92> I can define a name, but I'm not allowed to refer to it by name by the same rules
[22:55:08] <Guest92> .... as other names
[22:55:38] <Bike> FLET does not allow you to refer to another function from the same flet form in the definition of one of those functions. On the flipside, we could say that LABELS does not allow you to refer to an outside function that has the same name.
[22:55:47] <Guest92> so in that sense, labels gives me the same ability that other forms of function definition allow, which is that I can refer to the function itslef within its own body
[22:55:56] <Guest92> flet doesn't allow that, meaning flet is a more restrictive behavior
[22:56:09] <Guest92> flet restricts the referencing of names bound by itself, labels does not
[22:56:11] <Guest92> labels > flet
[22:56:13] <Bike> LABELS doesn't allow you to refer to an outside function.
[22:56:18] <Guest92> at all?
[22:56:21] <mfiano> Wait really?
[22:56:24] <Bike> With the same name, I mean.
[22:56:27] <Guest92> oh
[22:56:28] <Guest92> right
[22:56:29] <mfiano> (defun f () 1) (labels ((f () 2)) (print (funcall 'f)) (print (funcall #'f)))
[22:56:36] <Guest92> it isn't that it doesn't allow you to Bike
[22:56:48] <Guest92> it is that you overrode the name in the local context
[22:56:51] <White_Flame> let's walk this back to LET vs LET*
[22:56:57] <Guest92> the name in labels is "more local" than the other name
[22:56:59] <Bike> How is that not allowance?
[22:57:00] <White_Flame> LET can be implemented with LAMBDA
[22:57:10] <Guest92> @bike because as you said its a matter of style
[22:57:16] <Guest92> if you want to go around overriding names of things
[22:57:19] <White_Flame> (let ((a 1) (b 2) (c 3)) ...) => ((lambda (a b c) ...) 1 2 3)
[22:57:20] <Bike> You know, it doesn't matter. You understand the difference between FLET and LABELS fine. You're not going to screw up writing programs.
[22:57:23] <Guest92> go right on ahead, but that's just silly
[22:57:55] <lotuseater> what is silly?
[22:57:57] <White_Flame> In the lambda perspective, all expressions are evaluated before passed into the lambda function.  Those parameter expressions cannot reference each other; no container for them yet exists until the lambda is entered
[22:58:20] <Guest92> lotuseater read my comment in the context of my chain of previous comments
[22:58:21] <White_Flame> so all evaluation happens "outside" the binding, and the binding happens in parallel
[22:58:59] <White_Flame> if you want to have this sort of visibility with function parameters, you need to nest a separate binding before the call
[22:59:17] <White_Flame> which is what a nested LET/FLET would do
[22:59:37] <_death> if you think FLET is silly, always use LABELS?.. maybe one day you'll find that you need FLET after all
[22:59:47] <lotuseater> i read the most. think of who you call silly with that
[23:00:55] <Guest92> I'm just saying, I can't think of a context in which, in any other language I would go around rebinding names to things within nested contexts, particularly with functions. I think that's silly stylistically, and you could very well give it some kind of additional designator to distinguish it from other forms of similar functions
[23:01:38] <lotuseater> Yes so as you say, *you*.
[23:01:46] <Guest92> @_death I didn't say I think flet is silly, I said constantly rebinding existing names to other names is silly.
[23:02:00] <White_Flame> Guest92: I gave you explicit examples of where/when such nesting is necessary in general
[23:02:13] <Guest92> I'm still trying to get my head around it
[23:02:16] <White_Flame> eg, with any language that calls functions with parameters :-P
[23:02:23] *** Joins: amk (~amk@109.255.169.126)
[23:03:10] <Guest92> I just don't see why you would ever do that with functions, unless you're doing some kind of "import all" of someone else's library where the could be potential naming conflicts
[23:03:12] <White_Flame> define function foo(a,b,c),  call foo(1, a+1, a+2), except "a" doesn't exist yet because you haven't entered foo yet
[23:03:44] <Guest92> modular code however wouldn't have that problem simply because modules oughtn't be large enough to warrant defining of multiple functions by the same name
[23:03:50] <Guest92> but that goes back to style
[23:03:56] <_death> Guest92: suppose you have a macro that defines a local function called COLLECT, and you want to give a nice error when COLLECT is used outside the context set up by the macro
[23:04:08] <White_Flame> all parameters are evaluated outside the functino scope (with its respective parameter names), then all parameters are bound effectively in parallel as the function is entered
[23:04:45] <_death> (say, the error message should mention the macro's name)
[23:04:53] <White_Flame> the very explicit control of scope in CL is very advantageous to avoid bugs and have more clarity in the intent of bindings
[23:04:55] <Guest92> @_death doesn't that begin to violate lexical scoping rules?
[23:05:08] <_death> Guest92: how so?
[23:05:45] <Guest92> like, I got my scope, I got a name in it, someone on another planet be calling my names but he doesn't know about them, and he's going to suffocate because the error wasn't caught and his oxygen supply is now bugged out
[23:06:17] <Guest92> I shouldn't have to error if someone outside the scope refers to my names
[23:06:27] <Guest92> because... that's already an error
[23:06:31] <mfiano> Sigh
[23:06:36] <mfiano> Night all
[23:06:41] <lotuseater> night mfiano
[23:07:12] <_death> Guest92: it's an error, but the message is a generic "COLLECT not a function" instead of "COLLECT may only be used inside a WITH-COLLECT context"
[23:07:56] <Guest92> i really don't know what the problem is... this is basically the beahvior of any other lexically scoped language
[23:08:04] <Guest92> the "most local scope" of the name is the name that it refers to
[23:08:21] <lotuseater> we're not any other
[23:08:35] <Guest92> so obviously if you define global-x, but then you have local-x, then when you call x it refers to local x
[23:08:56] <Guest92> I think the thing I'm missing is how much CL is reliant on globla scope
[23:09:07] <Guest92> because I literally can't even with global scope
[23:09:12] <Guest92> the model doesn't fit in my brain
[23:09:30] <lotuseater> okay so now the thing is figured out
[23:09:35] *** Joins: markthom_ (~markthom_@2604:3d09:3e7e:e32e:3b:371e:5b3f:2887)
[23:10:38] <Guest92> I would only ever define globally what must be used everywhere throughout an application, like a DSL. But at the same time I'm not going to go around redefining my DSL all over the place inside of nested contexts, where an FLET would be useful
[23:10:54] <Guest92> because that invalidates the purpose of the DSL in the first place
[23:11:20] <_death> Guest92: what I said would work with either FLET or LABELS.. but now, think of a different operator that can be used in a local context, but that may need to call the global COLLECT on some condition
[23:11:40] <Guest92> scary
[23:11:47] <Guest92> I would relaly just give them different names
[23:12:08] <_death> Guest92: or instead of "global COLLECT", the collect of the outer context
[23:12:10] <Guest92> like (if t *collect* COLLECT)
[23:12:18] *** Quits: yitzi (~yitzi@172.98.105.250) (Quit: Leaving)
[23:12:43] <Guest92> but then I remember something about *stdout* and *stdout* getting redefined in loads of differenct contexts for some kind of socket library thing
[23:12:52] <Guest92> that just seems utterly filthy to me
[23:13:57] <shka> shadowed
[23:14:00] <shka> not redefined
[23:14:22] <White_Flame> not even shadowed, but having a new thread-local binding for it
[23:14:49] <White_Flame> it's a great way to just let functions run, and redirect their output to wherever
[23:14:50] <Guest92> and scary
[23:15:02] <White_Flame> are pipes on the unix shell scary?
[23:15:14] <Guest92> no but then they're sequential
[23:15:15] <_death> if you want to call the COLLECT of the outer context, inside your inner COLLECT, then you can use FLET.. alternatively you could use a variable to hold a reference to it and funcall.. but why do that when you have FLET
[23:15:32] <White_Flame> there's nothing non-sequential about redirection in a lisp scope either
[23:15:51] <Guest92> except that I can mutate state on the moon, and behavior on pluto changes
[23:16:07] <White_Flame> yeah, that's why people don't do that :-P
[23:16:15] <Guest92> exactly
[23:16:15] <White_Flame> (let ((*standard-output* my-stream)) ...) is not a mutation
[23:16:32] <White_Flame> it's a thread-contained scope
[23:16:34] <Guest92> you said its a great way for functions to continue running and redirect output
[23:16:54] <Guest92> this implies that you're about to run a new function that has its own output
[23:17:04] <Guest92> sorry, this example
[23:17:27] <Guest92> but the statement implies that some funciton somewhere else is running and its about to have its whole career ended by someone else doing god knows what
[23:17:41] <White_Flame> no other thread can be running which will see that scope
[23:17:52] <White_Flame> any new function called within that scope will see the new binding
[23:18:07] <White_Flame> this is a feature that no popular language really does
[23:18:14] <White_Flame> and the problems of those other languages don't actually apply here
[23:18:32] <Guest92> APL has dynamic scope
[23:18:36] <White_Flame> because it's not a global mutation of the stdout slot
[23:18:51] <Guest92> so i get dynamic scope and what it does, but I stay clear the hell away from it
[23:19:24] <_death> my condolences
[23:19:29] <White_Flame> "popular language"s ;-)
[23:19:58] <Guest92> nah, life's honky dory over here without dynamic scope
[23:20:00] *** Joins: andreyorst (~andreyors@2.92.126.234)
[23:20:15] <White_Flame> if you never use dynamic scope, then you always have to either mutate global scope, or pass around tons of contextual parameters manually even if they're not being changed
[23:20:45] <Guest92> Right, but then the idea is that programs should be a directional graph
[23:20:50] <White_Flame> (or create and mutate explicit scope objects that configure functions, etc)
[23:21:12] <White_Flame> the dynamic bindings are completely associated with the nesting of the call stack & its directional graph
[23:21:13] <mfiano> The parameter object idiom from Uncle Bob is here to the rescue.
[23:21:13] <Guest92> dynamic scope makes that graph all kinds of topsy turvy
[23:21:22] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-19-70-31-33-162.dsl.bell.ca)
[23:21:29] <Guest92> what is that?
[23:22:00] <White_Flame> also, do you ever use thread-local variables?
[23:22:12] <Guest92> meaning?
[23:22:23] <White_Flame> TLS, thread local storage, etc
[23:22:44] <mfiano> A stupid piece of advice from the "Clean Code" series, of wrapping function parameters in objects if you ever have more than 2.
[23:23:23] *** Quits: cosimone (~user@2001:b07:ae5:db26:a7aa:8027:6b4e:2fb3) (Ping timeout: 268 seconds)
[23:24:08] <Guest92> oh idk much about uncle bob except his reputation
[23:24:18] <Guest92> White_Flame I think that's most of the data I work with?
[23:24:49] <White_Flame> ok, so a big dynamic scope per thread is an exact implementation of thread-local storage, too
[23:25:03] <Guest92> I don't do much threading. Most of the applications I work on are some kind of event or data driven model, and small amounts of data from streams are processed, so I'm not really dealing with thread-safety issues
[23:25:21] <Guest92> because data is small and behaviors are deterministic for the most part
[23:26:04] <White_Flame> ok, so you actually never sit in a call graph for any appreciable length of cpu time?
[23:26:14] <Guest92> not actually
[23:26:35] <Guest92> the ones that I do are very flat graphs
[23:28:46] <White_Flame> that kind of programming usually externalizes all its state to a database
[23:29:45] <Guest92> Yes, either a database or further processing which will trigger other behaviors
[23:29:49] <White_Flame> if that's the case, then yeah you're not going to have much to do with larger stateful features in code, though the side-band parameterization of dynamic bindings for things like stdout, print styles, and other config is extremely handy, when the amount of parameterization for things is large
[23:30:06] <Guest92> What sorts of applications use the models you work with?
[23:30:50] <White_Flame> usually dynamic interactive data.  I do a lot with inference, AI, and GUI abstractions
[23:31:22] <White_Flame> large ram footprint, high cpu appliactions
[23:32:19] <White_Flame> but most of the unique strength of CL, IMO, is its metaprogramming facilities
[23:32:28] <Guest92> A lot of the work I've done is monitoring streams at intersections of network layers and network barriers for packets, streams, configurations of devices, requisition of resources, etc
[23:32:54] *** Joins: gaqwas (~john@dynamic-077-009-164-187.77.9.pool.telefonica.de)
[23:33:00] <White_Flame> which means you can basically write pseudocode, and have it directly expand and execute, using all these features to have hll->hll compilation directly at runtime
[23:33:17] <pve> Guest92: Here's a silly example where flet is a better choice than labels (at least I hope, it's getting late here).
[23:33:22] <pve> https://plaster.tymoon.eu/view/2635
[23:33:27] <shka> disclaimer
[23:33:39] <shka> writing code like this is not a good idea
[23:33:53] <shka> i mean, not to pve
[23:34:07] <pve> oops corrected an error, reload that please
[23:34:12] <shka> i mean this: https://gist.github.com/sirherrbatka/fd94eb51d02febc0ac4ae3c8b7d3da7f
[23:34:22] <Guest92> I think my problem at the moment is I did enough common lisp to trigger a change in my brain years ago... but I've forgetten most of it and I'm trying to reacquaint myself. I did a lot of macro practice and trivial code challenge typ things, but never built anything meaningful. I was only getting the hang of ASD before I moved on to APL for the
[23:34:23] <Guest92> past few years
[23:35:15] <shka> anyway, my code demonstrates how you can use flet (but not labels!) to implement poor continuations
[23:35:16] <pve> shka: your statement applies to my example as well :)
[23:35:30] <shka> pve: heh, i'll take it!
[23:35:54] <White_Flame> I'm honestly not a big fan of fine-grain event-based, rdbms-based applications.  The actual code is clean, safe, and small, but the overall complexity of the application then has no real infrastructure (or externalized infrastructure) to try to wrangle it in a much more cat-juggling way
[23:36:18] <_death> pve: good example, but you need a nested loop there to show the difference
[23:36:21] <White_Flame> as what the program actually does is not directly expressed in the code anywhere, but is a gestalt of all the little micro-behaviors
[23:36:41] <shka> Guest92: anyway, the thing with CL is that a lot of it is geared toward the macro programming
[23:36:43] <White_Flame> so the complexity, IMO, is hoisted away without a good concrete expression
[23:36:59] <pve> _death: hmm I was thinking if escape-form wants to call a global (escape) function
[23:37:00] <shka> that's why you need to have very, very, very precise semantics for the most basic operators
[23:37:24] <shka> no sane person would write code in style like i have just did
[23:37:31] <_death> pve: ah, yeah, that'd work too
[23:37:46] <Guest92> White_Flame you are correct. It is very easy to write applications to where no one understands what is being done on what systems and what triggeres the events...
[23:38:08] <Guest92> And it requires discipline in organizaiton and documentation
[23:38:21] <shka> but from my experience, it is one trick in code generation that surprisingly can be useful
[23:38:34] <Guest92> but the networking world is the culprite, I don't think its the applications so much as it is impossible to observe network systems easily
[23:38:38] <White_Flame> in contrast, I like to express the entire system as  a data spec or pseudo code, and have the behavior stem from there
[23:38:50] <White_Flame> it's possible with such systems as yours, but IMO needlessly makes it more complex
[23:38:53] *** Quits: zxcvz (~tobias@h-158-174-22-178.NA.cust.bahnhof.se) (Quit: Leaving)
[23:39:13] <White_Flame> yes, we do distributed, heterogeneous language systems, too
[23:39:24] <Guest92> White_Flame that's how I designed our application. data is the specification, so at any intersection you can view the contents of a message and should be able to understand that leg of the application
[23:39:39] <White_Flame> no, I'm not talking about message data
[23:39:44] <White_Flame> I'm talking about a spec for the overall system
[23:39:44] <Guest92> hmm
[23:40:07] <White_Flame> the actual workflow, orchestration, error response, etc definitions
[23:40:19] <Guest92> oh
[23:40:26] <White_Flame> and at that level, there can be little to no distinction between local and distributed
[23:40:32] <White_Flame> s/can/could/
[23:41:09] <White_Flame> and having that sort of control and high abstraction level code generation is great even for single-process, multithreaded programs
[23:41:41] <White_Flame> or even just defining individual library-ish components
[23:42:29] <White_Flame> and since metaprogramming is so easy in CL (as opposed to nightmarish in most other languages), it's used in the small, too, which eliminates boilerplate and reduces friction in writing code in general
[23:42:49] <White_Flame> something's annoying to implement, and you need to do it more than once?  macro it out
[23:43:17] <White_Flame> which means that the tangible complexity for "large" single process applications shrinks
[23:43:56] <White_Flame> I put that in quotes, because the abstraction power of lisp tends to keep codebases from blowing up as big as most other languages do when the projects get big
[23:44:45] <White_Flame> and from this perspective, you can see my view that the manual fine-grain chopping up of workloads tends to be underneath a more powerful, comfortable level of abstraction
[23:45:11] <White_Flame> hmm, s/underneath/less desirable than/
[23:46:08] <White_Flame> and in a practical sense, CPUs have way better throughput when they can do a ton of crunching at once, instead of always dispatching into little bit sized pieces of work
[23:46:16] <White_Flame> *byte-sized
[23:46:43] <White_Flame> (which of course can be a total batch processing time vs responsiveness time tradeoff)
[23:47:08] <White_Flame> ((but then that's where a good threading discipline comes in, etc etc)
[23:47:34] *** Quits: IUSR (sid348938@stonehaven.irccloud.com) ()
[23:47:36] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[23:47:50] *** Joins: IUSR (sid348938@id-348938.hampstead.irccloud.com)
[23:51:27] <Guest92> I guess I don't have the experience with such applications to know what patterns are even involved with building them
[23:53:21] *** Quits: Oladon (~olad@98.43.81.226) (Quit: Leaving.)
[23:55:52] <White_Flame> personally, I find it very frustrating to work on complex codebases that don't actually do a lot of ... computing. ;)
[23:56:06] *** Joins: akoana (~ah@user/akoana)
[23:56:13] <White_Flame> but it is stil very challenging to get low latency high throughput network stuff, just a different challenge
[23:56:22] *** Joins: yitzi (~yitzi@173-27-106-188.client.mchsi.com)
[23:56:41] *** Quits: rain3 (~rain3___@2a02:2f09:d30b:1300:514:bcc7:8202:1798) (Ping timeout: 268 seconds)
[23:57:39] <White_Flame> but even there, the ability to have good abstractions for your queues etc, and have each compiled & optimized (even at runtime) to your config or heuristic balance takes great advantage of lisp's strengths
