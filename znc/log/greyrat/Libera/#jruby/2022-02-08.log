[00:09:50] *** Joins: nilsding (~nilsding@user/nilsding)
[00:10:00] *** Joins: ahorek[m] (~ahorekmat@2001:470:69fc:105::30e2)
[00:10:00] *** Joins: enebo[m] (~enebo@2001:470:69fc:105::e6)
[00:10:12] *** Joins: ssaschaa[m] (~ssaschaam@2001:470:69fc:105::1:605e)
[00:52:40] <headius> 3F1E
[01:05:23] *** Quits: kroth_lookout[m] (~krothmatr@2001:470:69fc:105::1:8372) (Read error: Connection reset by peer)
[01:05:23] *** Quits: ahorek[m] (~ahorekmat@2001:470:69fc:105::30e2) (Remote host closed the connection)
[01:05:23] *** Quits: mattpatt[m] (~mattpattm@2001:470:69fc:105::315d) (Remote host closed the connection)
[01:05:23] *** Quits: enebo[m] (~enebo@2001:470:69fc:105::e6) (Read error: Connection reset by peer)
[01:05:23] *** Quits: Albertico[m] (~albertico@2001:470:69fc:105::1:3a89) (Read error: Connection reset by peer)
[01:05:23] *** Quits: kares[m] (~karesmatr@2001:470:69fc:105::30d1) (Read error: Connection reset by peer)
[01:05:23] *** Quits: AndyMaleh[m] (~andymaleh@2001:470:69fc:105::1:1a78) (Read error: Connection reset by peer)
[01:05:23] *** Quits: bensheldon[m] (~bensheldo@2001:470:69fc:105::1:634e) (Read error: Connection reset by peer)
[01:05:23] *** Quits: headius (~headius@2001:470:69fc:105::3027) (Read error: Connection reset by peer)
[01:05:23] *** Quits: nilsding (~nilsding@user/nilsding) (Read error: Connection reset by peer)
[01:05:24] *** Quits: rebelwarrior[m] (~rebelwarr@2001:470:69fc:105::beba) (Remote host closed the connection)
[01:05:24] *** Quits: daveg_lookout[m] (~daveglook@2001:470:69fc:105::1:8374) (Remote host closed the connection)
[01:05:24] *** Quits: katafrakt[m] (~katafrakt@2001:470:69fc:105::1:41ff) (Remote host closed the connection)
[01:05:24] *** Quits: klobuczek[m] (~klobuczek@2001:470:69fc:105::1:24c) (Remote host closed the connection)
[01:05:24] *** Quits: lopex[m] (~lopexm]@2001:470:69fc:105::3158) (Read error: Connection reset by peer)
[01:05:24] *** Quits: MateuszFryc[m] (~lirimaery@2001:470:69fc:105::1:3640) (Read error: Connection reset by peer)
[01:05:24] *** Quits: rdubya[m] (~rdubyamat@2001:470:69fc:105::1:7649) (Read error: Connection reset by peer)
[01:05:24] *** Quits: byteit101[m] (~byteit101@2001:470:69fc:105::30ec) (Remote host closed the connection)
[01:05:24] *** Quits: puritylake[m] (~puritylak@2001:470:69fc:105::1:1904) (Read error: Connection reset by peer)
[01:05:24] *** Quits: basshelal[m] (~basshelal@2001:470:69fc:105::30e7) (Read error: Connection reset by peer)
[01:05:24] *** Quits: oblutak[m] (~oblutakma@2001:470:69fc:105::1:7039) (Read error: Connection reset by peer)
[01:05:25] *** Quits: kovyrin[m] (~kovyrinma@2001:470:69fc:105::1:6d6c) (Remote host closed the connection)
[01:05:25] *** Quits: ssaschaa[m] (~ssaschaam@2001:470:69fc:105::1:605e) (Read error: Connection reset by peer)
[01:05:25] *** Quits: MattWelke[m] (~mattwelke@2001:470:69fc:105::1:34bb) (Read error: Connection reset by peer)
[01:05:25] *** Quits: jtarvydas[m] (~jtarvydas@2001:470:69fc:105::1:8387) (Read error: Connection reset by peer)
[01:07:53] *** Joins: ahorek[m] (~ahorekmat@2001:470:69fc:105::30e2)
[01:29:29] *** Joins: enebo[m] (~enebo@2001:470:69fc:105::e6)
[01:29:29] *** Joins: lopex[m] (~lopexm]@2001:470:69fc:105::3158)
[01:29:29] *** Joins: subbu[m] (~subbu@user/subbu)
[01:29:30] *** Joins: andrea[m] (~andreanit@2001:470:69fc:105::1:28a8)
[01:29:41] *** Joins: byteit101[m] (~byteit101@2001:470:69fc:105::30ec)
[01:29:41] *** Joins: AndyMaleh[m] (~andymaleh@2001:470:69fc:105::1:1a78)
[01:29:41] *** Joins: katafrakt[m] (~katafrakt@2001:470:69fc:105::1:41ff)
[01:29:41] *** Joins: kares[m] (~karesmatr@2001:470:69fc:105::30d1)
[01:29:41] *** Joins: oblutak[m] (~oblutakma@2001:470:69fc:105::1:7039)
[01:29:41] *** Joins: rebelwarrior[m] (~rebelwarr@2001:470:69fc:105::beba)
[01:29:41] *** Joins: puritylake[m] (~puritylak@2001:470:69fc:105::1:1904)
[01:29:42] *** Joins: basshelal[m] (~basshelal@2001:470:69fc:105::30e7)
[01:29:42] *** Joins: rdubya[m] (~rdubyamat@2001:470:69fc:105::1:7649)
[01:29:42] *** Joins: MateuszFryc[m] (~lirimaery@2001:470:69fc:105::1:3640)
[01:29:42] *** Joins: kovyrin[m] (~kovyrinma@2001:470:69fc:105::1:6d6c)
[01:29:42] *** Joins: klobuczek[m] (~klobuczek@2001:470:69fc:105::1:24c)
[01:29:42] *** Joins: Albertico[m] (~albertico@2001:470:69fc:105::1:3a89)
[01:29:42] *** Joins: bensheldon[m] (~bensheldo@2001:470:69fc:105::1:634e)
[01:29:42] *** Joins: ssaschaa[m] (~ssaschaam@2001:470:69fc:105::1:605e)
[01:29:43] *** Joins: headius (~headius@2001:470:69fc:105::3027)
[01:29:43] *** Joins: MattWelke[m] (~mattwelke@2001:470:69fc:105::1:34bb)
[01:29:43] *** Joins: mattpatt[m] (~mattpattm@2001:470:69fc:105::315d)
[01:29:43] *** Joins: daveg_lookout[m] (~daveglook@2001:470:69fc:105::1:8374)
[01:29:43] *** Joins: jtarvydas[m] (~jtarvydas@2001:470:69fc:105::1:8387)
[01:29:44] *** Joins: nilsding (~nilsding@user/nilsding)
[01:29:45] *** Joins: kroth_lookout[m] (~krothmatr@2001:470:69fc:105::1:8372)
[01:33:56] *** Quits: andrea[m] (~andreanit@2001:470:69fc:105::1:28a8) (Quit: You have been kicked for being idle)
[01:42:34] <headius> huzzah, 0F0E
[01:42:40] <headius> most of it was adding fixed_anchor support
[02:13:21] <enebo[m]> sweet
[02:23:34] <headius> test:mri:stdlib is not running on master right now
[02:23:35] <headius> org/jruby/RubyModule.java:4198:in `const_missing': uninitialized constant IO::Buffer (NameError)
[02:23:35] <headius> 	from /home/runner/work/jruby/jruby/test/mri/fiber/scheduler.rb:20:in `<class:Scheduler>'
[02:23:35] <headius> 	from /home/runner/work/jruby/jruby/test/mri/fiber/scheduler.rb:16:in `<main>'
[02:23:59] <headius> but this will clear up any failures in strscan once it is running
[02:25:17] <headius> https://github.com/jruby/jruby/pull/7076
[02:25:27] <headius> once that is green and merged I will start moving it over to the gem
[02:25:39] <headius> then on to the next one
[20:31:56] *** Joins: subbu (~subbu@user/subbu)
[21:52:24] <headius> enebo: hey couple check ins on my PRs
[21:52:41] <headius> the PR to clean up locks when a LoadError is raised seems to be green and fixes the issue reported here:
[21:52:56] <headius> https://github.com/jruby/jruby/issues/7070
[21:53:44] <headius> that should be pretty benign but there's not a lot of tests/specs checking these errors being raised during concurrent requires and such
[21:53:48] <enebo[m]> well that is not much to review but I guess I should read the comments
[21:54:10] <headius> I would just merge it but I am kinda form-fitting the fix to apparent behavior
[21:55:05] <enebo[m]> So I guess the risk of the fix is that it is unclear in edge cases if this is enough
[21:55:13] <headius> my reading of the CRuby code seems to indicate that they always remove this lock, but then they do not handle concurrency the same way we do
[21:55:33] <enebo[m]> but the basic problem reported is fixed and the rationale for the change makes sense
[21:55:55] <headius> removing the lock always for us broke the case where two requires are concurrent, the first one into the file raises an error (not LoadError) and that should let the second one acquire the same lock and continue loading
[21:56:13] <enebo[m]> We are early enough into 9.3 I think we should rolll with this
[21:56:26] <headius> ok I agree
[21:56:39] <enebo[m]> I wonder if there is some torture tests we can do on mixed failed autoloads and concurrent ones
[21:57:01] <headius> yeah it is tough to rig up because there's a lot of state invovled
[21:57:08] <enebo[m]> I don't really know how one would formulate a test like this but we obviously have a lot more edges than MRI
[21:57:44] <enebo[m]> I have to say so far so good on all that work you put into this to make zeitwork happy
[21:58:05] <headius> that's great
[21:58:20] <enebo[m]> on Ruby/spec I am down to 5e/f with 2 I cannot fix for Marshal#load.  Getting much closer.
[21:58:48] <headius> cannot fix as in we cannot support the functionality?
[21:58:51] <enebo[m]> The 2 I cannot fix we could probably fix if we marked T_OBJECT/T_DATA on the few types which a T_DATA in MRI but it seems very unimportant
[21:59:01] <headius> right those ones
[21:59:08] <headius> they have been failing forever anyway
[21:59:29] <enebo[m]> 1 test is it is invalid marshal data which tried to object unmarshal but it is a T_DATA type
[21:59:36] <enebo[m]> why someone would test this I don't know
[22:00:01] <enebo[m]> Seems like it should not be possible for this to happen unless you make the marshal string yourself
[22:00:12] <headius> yeah some of these date back to early rubinius days working on pure-Ruby marshal so I'm sure Evan or Brian pushed a lot of edges
[22:00:59] <enebo[m]> In this case I am unclear on when but MRI does actually type check on DATA/OBJECT in the code
[22:01:30] <enebo[m]> So I guess this could be something where you load data across Ruby versions where something switched types or something like that
[22:01:47] <enebo[m]> So I am not concerned
[22:02:05] <headius> does this test have some hardcoded marshaled data and tries to unmarshal that?
[22:02:07] <enebo[m]> I have not implemented a whole feature of marshal for some compat allocator thing
[22:02:16] <enebo[m]> yeah
[22:02:21] <enebo[m]> most of ruby/spec is like that
[22:02:25] <headius> or a related question, is this marshal data that 3.1 can actually produce
[22:02:41] <enebo[m]> There are some load/dump combo things but that presumes you have a working dump already
[22:02:48] <headius> if not then who cares, marshal data between Ruby versions is a massive risk anyway
[22:03:03] <enebo[m]> Which could harken back to Evan/Brian needing only half of it implemented
[22:03:33] <enebo[m]> We definitely had a number of issues.  I am curious to see how I fare once I switch over to MRI tests
[22:04:02] <headius> second PR of mine tries to use native thread status for our thread status but it seems to hang on some tests so that needs more work:
[22:04:02] <headius> https://github.com/jruby/jruby/pull/7075
[22:04:29] <headius> it was a quick attempt and I can iterate on that but this is trying to fix the issue where JI calls will not show up as "sleep" even if they bottom out in some blocking call
[22:04:38] <headius> I think that is worth finding a solution for but this needs work
[22:04:56] <headius> it might not be a 9.3 item
[22:05:13] <headius> changing the way we calculate thread status seems like too high a risk
[22:06:29] <enebo[m]> yeah this one would worry me a little but I am not having a lot of feels on risk
[22:06:34] <enebo[m]> other than it causing hangs :)
[22:07:11] <enebo[m]> headius: and IO scheduler seems like it might play into this
[22:07:37] <headius> yeah that will take some serious investigation to support around JI calls
[22:08:09] <headius> worst case if we wanted to try to support it we might have to put scheduler stuff around all JI calls, which would not really be worth the overhead
[22:09:04] <headius> it may be we have to say it can't be done for JI calls and if you want Ruby scheduler you need to use Ruby blocking calls
[22:09:39] <headius> given that this is not a regression and we have behaved the current way forever I'm going to punt to 9.4 and examine it along with scheduler work there
[22:09:41] <headius> that's a good point
[22:10:00] <headius> last one I don't know where to go with: using frame as target for nonlocal breaks
[22:10:14] <headius> https://github.com/jruby/jruby/pull/7061
[22:10:52] <headius> I got everything working except for the case of a break in a Class.new {} body, which should break all the way to the level above the Class.new call
[22:11:48] <headius> the problem is that the module_eval logic clones the block and its frame before executing them to isolate changes they make while defining methods etc... at a minimum setting the frame class target for defs
[22:12:04] <headius> but that means the frame the block sees does not exist above the Class.new level so it can't target the break right
[22:12:14] <headius> it is a weird edge behavior but we pass it using DynamicScope as target
[22:12:38] <enebo[m]> hmm module_eval as a string or a block?
[22:12:41] <headius> p Class.new { break 1 } should print 1, but with my patch it LJEs
[22:13:05] <headius> the reason I was attempting to switch to frame was because it would be easier to mark them as being from a specific thread, to fix this issue:
[22:13:14] <headius> https://github.com/jruby/jruby/issues/7009
[22:13:29] <headius> or at least it was a way to fix it without walking the thread's stack looking for a jump target
[22:13:38] <enebo[m]> yeah
[22:13:38] <headius> I could just see that the target was from another thread and raise LJE immediately
[22:14:22] <headius> this might still be fixable in module_eval but I'm not sure how... the block has to point at a frame with the Class.new object, but also target another frame for the break
[22:14:41] <headius> the logic in CRuby is pretty tangled as you might expect
[22:14:59] <enebo[m]> yeah this feels like a classic issue with blocks
[22:15:20] <enebo[m]> this feels like proc vs lambda where you have the same thing but different behavior
[22:15:38] <enebo[m]> as in you can have the same literal piece of code be both
[22:16:10] <headius> so that brings us back to the option of flagging DynScope as being from a specific thread, making them bigger and having more state to set up
[22:16:59] <enebo[m]> Or maybe another object altogether?
[22:17:05] <headius> hmm
[22:17:14] <enebo[m]> which I guess would need to be attached to something
[22:17:27] <headius> yeah I'm trying to think now if there's a way to just flag the block itself as having come from another thread
[22:17:38] <headius> without adding state to dynscope
[22:17:47] <headius> like on Binding or something
[22:18:11] <headius> then it just needs to look at its own Binding, see that it is from a foreign thread, and say nope to nonlocal break
[22:18:26] <headius> ok I can play with that idea
[22:18:39] <headius> making binding bigger is still cumbersome but it is already pretty big
[22:18:58] <headius> one more object reference, no additional alloc
[22:20:13] <headius> this level of change might again be too risky for 9.3
[22:20:20] <headius> I'm not sure
[22:20:53] <enebo[m]> I am getting a bogus marshal type byte of 6
[22:21:20] <enebo[m]> it is reading a none-ascii ivar so this has to be some weird issue of us not reading the whole string?
[22:21:27] <enebo[m]> I am getting so close
[22:21:41] <headius> last little tidbit on strscan... it passes tests, builds the gem ok I think, but because we have no existing JRuby that uses it as a gem I'm not sure how best to test it... working through that now
[22:23:04] <enebo[m]> Can we release 9.4+ and have SNAPSHOT work?
[22:25:47] <headius> it's kinda a chicken/egg thing
[22:25:56] <headius> I can't make snapshot use the gem because current gem installs a C ext
[22:26:11] <headius> and I can't release java gem without being able to test against snapshot
[22:26:43] <headius> maybe it will be acceptable that for now it is actually testing against the strscan in the snapshot build?
[22:26:49] <enebo[m]> well like a foreign key constraint you could remove the version check just for the sake of testing
[22:27:01] <headius> that's the problem basically... it loads strscan pretty early so it doesn't use the gem's jar even if we force it to
[22:27:23] <headius> so we have to make a hard break there unlike io-wait
[22:27:33] <headius> io-wait isn't loaded until later so the gem could activate
[22:27:59] <headius> this will be an issue with stringio as well most likely
[22:49:29] <enebo[m]> https://gist.github.com/enebo/e8e02ea2282276e3b22d0d5a0146d192
[22:50:12] <headius> That blows up eh?
[22:50:12] <enebo[m]> Amazing nothing does this in any tests
[22:50:27] <headius> Yeah I'm surprised we didn't run into this working on Unicode identifiers
[22:50:35] <enebo[m]> yeah it assumes base encoding for result string and does not toggle it to proper one
[22:50:45] <headius> Must just be missing some logic for it to encode the Unicode as escaped characters
[22:50:56] <enebo[m]>             // FIXME: bytelist_love: EPICLY wrong but something in MRI gets around identifiers of arbitrary encoding.
[22:51:09] <enebo[m]> HAHA
[22:51:21] <enebo[m]> Well past self Tom is trying to send present self Tom a message
[22:51:38] <headius> At least you knew we were broken
[22:51:51] <enebo[m]> And now I know it again
[22:52:26] <enebo[m]> ok well part of me feels strCat19 was the answer (if we still call it that) but why did past Tom not do that
[22:53:03] <headius> Yeah I'm sure we have logic for presenting inspected unicode string output so it should be the same thing
[22:53:15] <headius> Inspect output is supposed to always be ascii
[22:54:11] <enebo[m]> This should just change entire string to UTF-8 I am sure
[22:54:24] <enebo[m]> but you can have any encoding as an ivar
[22:54:36] <enebo[m]> So it must escape those
[22:54:56] <headius> Yeah it's just an inspect requirement that it never have non-7-bit ASCII I believe
[22:55:04] <headius> Never output
[22:55:35] <enebo[m]> yeah I can see it definitely is UTF-8 on MRI for this
[22:56:09] <enebo[m]> HAHA and ASCII-8BIT when US-ASCII only bytes?
[22:57:14] <enebo[m]> I never realized this but we are outputting as US-ASCII
[22:59:28] <headius> Inspect doesn't output ascii-8bit does it?
[22:59:42] <enebo[m]> we don't no but MRI does
[23:00:12] <enebo[m]> which in this case would also be wrong since it converts to UTF-8
[23:00:13] <headius> That's weird. I thought for sure they never output any bytes outside 7-bit range so why would it be ASCII 8-bit
[23:00:39] <enebo[m]> I believe it is the default since ivars can be multiple incompatible encodings perhaps
[23:00:56] <enebo[m]> I was not aware of this either though
[23:01:21] <enebo[m]> I am just observing inspected instances seems to be ascii-8bit by default back to at least 2.6
[23:02:30] <enebo[m]> These issues always amuse me because 99% of all classes are using 7bit and this is for inspect which most people do not use for useful data in a program (other than debugging/logging)
[23:02:47] <enebo[m]> It is just uncommon enough for no one to notice for years
[23:03:09] <enebo[m]> Pretty much a text book example of the difficulties of compatibility projects
[23:04:37] <headius> Yeah I guess we should add some specs for this
[23:06:20] <headius> You're right though, it is amazing how much coverage you really need for a language implementation like this
[23:06:44] <headius> Or maybe it's amazing how much behavior never gets exercised by any tests or specs or apps but it's still there as a compatibility challenge
[23:07:31] <headius> We probably should do a pass over encoding related MRI tests, not sure the last time we did that
