[00:14:27] *** Quits: Torr (~Torr@user/torr) (Ping timeout: 250 seconds)
[00:34:43] *** Joins: junebug (~junebug@2600:1700:3db0:2540:1bc2:b6e8:b3fd:1f4a)
[00:41:53] *** Joins: lavaball (felix@31.204.155.215)
[00:48:10] *** Joins: Torr (~Torr@user/torr)
[00:48:49] *** Quits: seninha (~seninha@user/seninha) (Quit: Leaving)
[00:52:25] *** Quits: mawk (mawk@wireguard/contributor/mawk) (Ping timeout: 268 seconds)
[00:57:29] *** Quits: junebug (~junebug@2600:1700:3db0:2540:1bc2:b6e8:b3fd:1f4a) (Ping timeout: 252 seconds)
[00:58:46] *** Joins: mawk (~mawk@serveur.io)
[00:58:46] *** Quits: mawk (~mawk@serveur.io) (Changing host)
[00:58:46] *** Joins: mawk (~mawk@wireguard/contributor/mawk)
[01:01:03] *** Quits: egm (~egm@user/egm) (Ping timeout: 268 seconds)
[01:08:21] *** Quits: user51 (~user51@176.228.151.30) (Quit: leaving)
[01:11:57] *** Quits: wuseman (~wuseman@user/wuseman) (Read error: Connection reset by peer)
[01:12:50] *** Joins: wuseman (~wuseman@81-231-55-224-no68.tbcn.telia.com)
[01:17:38] *** Joins: egm (~egm@user/egm)
[01:27:49] *** Quits: lavaball (felix@31.204.155.215) (Remote host closed the connection)
[01:27:52] *** Quits: wuseman (~wuseman@81-231-55-224-no68.tbcn.telia.com) (Changing host)
[01:27:52] *** Joins: wuseman (~wuseman@user/wuseman)
[01:36:49] *** Quits: egm (~egm@user/egm) (Ping timeout: 268 seconds)
[01:45:27] *** Joins: seninha (~seninha@user/seninha)
[01:49:16] *** Quits: seninha (~seninha@user/seninha) (Client Quit)
[01:58:07] *** Joins: egm (~egm@user/egm)
[02:51:57] *** Joins: seninha (~seninha@user/seninha)
[02:54:54] *** Joins: junebug (~junebug@2600:1700:3db0:2540:b62f:6f3c:5a3b:e2c2)
[03:24:37] *** Quits: brennen (~brennen@user/brennen) (Quit: WeeChat 2.8)
[03:26:17] *** Joins: Meli-sama (~meli@user/meli)
[03:26:21] *** Quits: Meli (~meli@user/meli) (Ping timeout: 252 seconds)
[03:27:14] *** Meli-sama is now known as Meli
[03:27:22] *** Joins: lockywolf (~lockywolf@vultr-seoul-openbsd.lockywolf.net)
[03:30:39] *** Joins: brennen (~brennen@user/brennen)
[03:51:00] *** Quits: seninha (~seninha@user/seninha) (Remote host closed the connection)
[03:52:05] *** Quits: wuseman (~wuseman@user/wuseman) (Excess Flood)
[04:03:12] *** Quits: Torr (~Torr@user/torr) (Quit: leaving)
[04:17:33] *** Quits: junebug (~junebug@2600:1700:3db0:2540:b62f:6f3c:5a3b:e2c2) (Quit: Leaving)
[04:21:05] *** Joins: wuseman (~wuseman@81-231-55-224-no68.tbcn.telia.com)
[04:21:06] *** Quits: wuseman (~wuseman@81-231-55-224-no68.tbcn.telia.com) (Excess Flood)
[04:23:14] *** Joins: wuseman (~wuseman@81-231-55-224-no68.tbcn.telia.com)
[04:23:15] *** Quits: wuseman (~wuseman@81-231-55-224-no68.tbcn.telia.com) (Changing host)
[04:23:15] *** Joins: wuseman (~wuseman@user/wuseman)
[04:23:15] *** Quits: wuseman (~wuseman@user/wuseman) (Excess Flood)
[04:23:52] *** Joins: wuseman (~wuseman@81-231-55-224-no68.tbcn.telia.com)
[04:23:53] *** Quits: wuseman (~wuseman@81-231-55-224-no68.tbcn.telia.com) (Changing host)
[04:23:53] *** Joins: wuseman (~wuseman@user/wuseman)
[04:23:53] *** Quits: wuseman (~wuseman@user/wuseman) (Excess Flood)
[04:24:30] *** Joins: wuseman (~wuseman@81-231-55-224-no68.tbcn.telia.com)
[04:24:30] *** Quits: wuseman (~wuseman@81-231-55-224-no68.tbcn.telia.com) (Excess Flood)
[04:25:07] *** Joins: wuseman (~wuseman@81-231-55-224-no68.tbcn.telia.com)
[04:25:07] *** Quits: wuseman (~wuseman@81-231-55-224-no68.tbcn.telia.com) (Excess Flood)
[04:25:29] *** Joins: wuseman (~wuseman@81-231-55-224-no68.tbcn.telia.com)
[04:25:30] *** Quits: wuseman (~wuseman@81-231-55-224-no68.tbcn.telia.com) (Excess Flood)
[04:26:22] *** Joins: wuseman (~wuseman@81-231-55-224-no68.tbcn.telia.com)
[04:26:22] *** Quits: wuseman (~wuseman@81-231-55-224-no68.tbcn.telia.com) (Changing host)
[04:26:22] *** Joins: wuseman (~wuseman@user/wuseman)
[04:32:34] *** Quits: egm (~egm@user/egm) (Ping timeout: 256 seconds)
[04:32:53] *** Quits: wuseman (~wuseman@user/wuseman) (Quit: https://github.com/wuseman)
[04:46:31] *** Joins: seninha (~seninha@user/seninha)
[04:48:50] *** Quits: lockywolf (~lockywolf@vultr-seoul-openbsd.lockywolf.net) (Ping timeout: 260 seconds)
[04:49:31] *** Joins: wuseman (~wuseman@81-231-55-224-no68.tbcn.telia.com)
[04:49:32] *** Quits: wuseman (~wuseman@81-231-55-224-no68.tbcn.telia.com) (Changing host)
[04:49:32] *** Joins: wuseman (~wuseman@user/wuseman)
[04:50:07] *** Quits: wuseman (~wuseman@user/wuseman) (Remote host closed the connection)
[04:54:15] *** Joins: wuseman (~wuseman@81-231-55-224-no68.tbcn.telia.com)
[04:54:16] *** Quits: wuseman (~wuseman@81-231-55-224-no68.tbcn.telia.com) (Changing host)
[04:54:16] *** Joins: wuseman (~wuseman@user/wuseman)
[05:09:40] *** Joins: lockywolf (~lockywolf@vultr-seoul-openbsd.lockywolf.net)
[05:30:03] *** Norkle is now known as sickjoke
[05:30:49] *** sickjoke is now known as NOrkle
[05:30:55] *** Joins: BSaboia (~bsaboia@177.51.33.61)
[05:30:57] *** NOrkle is now known as Norkle
[05:41:26] *** Quits: BSaboia (~bsaboia@177.51.33.61) (Quit: This computer has gone to sleep)
[06:28:09] *** Joins: junebug (~junebug@2600:1700:3db0:2540:f028:88b8:1db1:5d22)
[06:52:34] *** Quits: seninha (~seninha@user/seninha) (Remote host closed the connection)
[07:08:31] *** Parts: wuseman (~wuseman@user/wuseman) ()
[07:10:30] *** Joins: seninha (~seninha@user/seninha)
[07:10:45] *** Quits: mawk (~mawk@wireguard/contributor/mawk) (Ping timeout: 252 seconds)
[07:16:50] *** Joins: mawk (~mawk@serveur.io)
[07:16:51] *** Quits: mawk (~mawk@serveur.io) (Changing host)
[07:16:51] *** Joins: mawk (~mawk@wireguard/contributor/mawk)
[07:23:14] *** Quits: seninha (~seninha@user/seninha) (Remote host closed the connection)
[07:41:34] *** Quits: chasmo77 (~chas77@c-71-193-246-4.hsd1.or.comcast.net) (Quit: It's just that easy)
[07:57:41] *** Quits: junebug (~junebug@2600:1700:3db0:2540:f028:88b8:1db1:5d22) (Ping timeout: 252 seconds)
[07:58:49] <aetnaeus_> is it possible to read and write from the same process?
[08:00:38] *** Quits: earnestly (~earnest@user/earnestly) (Ping timeout: 260 seconds)
[08:23:51] <e36freak> in gawk you have |&
[08:24:25] <e36freak> https://www.gnu.org/software/gawk/manual/gawk.html#Two_002dway-I_002fO
[08:24:28] <e36freak> POSIXly, no
[08:31:02] *** Quits: fford (~fford@p200300c6ff35820060d8bedc1c419ec5.dip0.t-ipconnect.de) (Quit: WeeChat 1.5)
[09:11:59] *** Quits: mawk (~mawk@wireguard/contributor/mawk) (Ping timeout: 250 seconds)
[09:16:37] *** Joins: user51 (~user51@176.228.151.30)
[10:25:01] *** Joins: jle (~jle@user/jle)
[10:31:19] *** Joins: lgc (~lgc@user/lgc)
[10:38:28] *** Joins: hudo (~hhudo_@mail.allm-elektro.de)
[11:01:45] *** Quits: lgc (~lgc@user/lgc) (Quit: WeeChat 3.2-dev)
[11:10:51] <user51> i want to make a table in nawk. my strategy is doing something like:
[11:10:56] <user51> http://sprunge.us/gvosbb
[11:11:47] <user51> any other options?
[11:13:16] <user51> i might also make functions per table column, say 'function first(entry) { return nth(1, entry) }
[11:36:26] *** Joins: lavaball (felix@31.204.155.215)
[12:19:43] <Patsie> # awk 'BEGIN { $0="first second third N"; print $3 }'
[12:19:44] <shbot> Patsie: third
[12:19:53] <Patsie> why not let awk handle the splitting for you?
[12:20:19] <Patsie> it's so much easier than creating functions, calling split(), returning array elements
[12:20:35] <Patsie> awk was meant to split the fields and records for you
[12:21:13] <Patsie> # awk 'BEGIN { $0="first second third N"; for (i=1; i<=NF; i++) print i,$i }'
[12:21:18] <shbot> Patsie: 1 first
[12:21:18] <shbot> Patsie: 2 second
[12:21:18] <shbot> Patsie: etc... ( http://ix.io/3I6O )
[12:24:51] <user51> that means i'd have to keep the current record somewhere, no?
[12:26:15] <user51> i tried doing it with an array but felt doing it with strings only, then using a function to get the nth value is simplier. also avoids accidentally creating an array element.
[12:27:03] <user51> i tried doing it with an array, but it felt more complex than doing it with strings only, then using a function to get the nth value is simplier. also avoids accidentally creating an array element.
[12:27:22] <user51> i'm building a little parse table, for context
[13:21:01] *** Joins: earnestly (~earnest@user/earnestly)
[13:27:05] *** Joins: mawk (~mawk@serveur.io)
[13:27:06] *** Quits: mawk (~mawk@serveur.io) (Changing host)
[13:27:06] *** Joins: mawk (~mawk@wireguard/contributor/mawk)
[14:42:49] *** Joins: seninha (~seninha@user/seninha)
[14:43:28] *** Joins: elastic_1 (~elastic_d@2a01:118f:822:9c00:f583:aa51:9ad4:d4fb)
[14:43:36] *** Quits: elastic_dog (~elastic_d@2a01:118f:822:9c00:f583:aa51:9ad4:d4fb) (Quit: elastic_dog)
[14:44:50] *** Joins: Strykar_ (~wakka@signald/Strykar)
[14:45:01] *** Quits: Strykar (~wakka@signald/Strykar) (Ping timeout: 240 seconds)
[15:40:04] *** Quits: crabbedhaloablut (~crabbedha@user/crabbedhaloablut) (Remote host closed the connection)
[15:40:17] *** Joins: crabbedhaloablut (~crabbedha@user/crabbedhaloablut)
[15:49:28] *** Joins: utis (~utis@vpn-client453.uio.no)
[15:51:06] <utis> hi.  how would one skip the range /foo/,/bar/ unless a line between them matches baz?
[15:54:08] *** Joins: BSaboia (~bsaboia@177.51.33.2)
[16:00:20] <geirha> you'd have to store the range in a buffer and decide whether to print it when you reach the bar line
[16:08:01] *** Quits: BSaboia (~bsaboia@177.51.33.2) (Quit: This computer has gone to sleep)
[16:10:46] *** Joins: BSaboia (~bsaboia@177.51.33.2)
[16:15:17] *** Quits: BSaboia (~bsaboia@177.51.33.2) (Client Quit)
[16:18:49] <geirha> # printf '%s\n' one foo two bar three foo baz bar four | awk '/foo/{ f = 1; buf = $0; next } f && /baz/ { f = 2 } f { buf = buf "\n" $0 } !f {print} /bar/ { if (f == 2) print buf; f = 0 }' | paste -s -
[16:18:50] <shbot> geirha: one     three   foo     baz     bar     four
[16:22:28] <emanuele6> # printf '%s\n' one foo two bar three foo bazbar four | awk '/foo/{ f = 1; buf = $0; next } f == 1 && /baz/ { f = 2 } f { buf = buf "\n" $0 } !f {print} f == 3 && /bar/ { if (f == 2) print buf; f = 0 } f == 2 { f = 3 }' | paste -s -
[16:22:29] <shbot> emanuele6: one
[16:22:40] <emanuele6> oops
[16:23:03] <emanuele6> # printf '%s\n' one foo two bar three foo bazbar four | awk '/foo/{ f = 1; buf = $0; next } f == 1 && /baz/ { f = 2 } f { buf = buf "\n" $0 } !f {print} f == 3 && /bar/ { print buf; f = 0 } f == 2 { f = 3 }' | paste -s -
[16:23:04] <shbot> emanuele6: one
[16:24:11] <emanuele6> oh, it is correct, right
[16:24:29] *** Joins: BSaboia (~bsaboia@177.51.33.2)
[16:24:29] <emanuele6> no, it should print three
[16:27:13] *** Quits: BSaboia (~bsaboia@177.51.33.2) (Read error: Connection reset by peer)
[16:29:56] *** Joins: BSaboia (~bsaboia@177.51.33.2)
[16:33:44] *** Quits: BSaboia (~bsaboia@177.51.33.2) (Client Quit)
[16:41:53] <utis> thanks
[16:43:56] *** Quits: seninha (~seninha@user/seninha) (Ping timeout: 268 seconds)
[16:50:15] <emanuele6> utis: if you want to make it work properly for lines that are both bar and baz, you can use something like this http://0x0.st/-Fxp.txt
[16:51:51] <emanuele6> oh, oops
[16:51:58] <emanuele6> i forgot to print baz_buf
[16:53:32] <emanuele6> here http://0x0.st/-FxO.txt
[16:53:58] <emanuele6> i had `print foo_buf' instead of `print foo_buf "\n" baz_buf'
[16:54:20] <emanuele6> so it was printing only /foo/,/baz/
[17:00:24] *** Joins: seninha (~seninha@user/seninha)
[17:15:57] <emanuele6> (that also fixes the behaviour for "unterminated" /foo/,/bar/ ranges at the end of the input)
[17:21:22] <emanuele6> mm, actually, not quite because it adds an extra newline
[17:22:14] <emanuele6> that is because, in the END block, `print baz_buf' should only be executed `if (f >= 2)'
[17:22:28] <emanuele6> if you change that, it should be correct
[17:25:14] <emanuele6> so like this http://ix.io/3I8o
[18:09:07] *** Joins: chandoo (~chandoo@96.240.98.220)
[19:57:30] *** Quits: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb) (Read error: Connection reset by peer)
[19:58:53] *** Quits: APic (~apic@apic.name) (Quit: [TLS] Client upgrade)
[19:59:03] *** Joins: APic (apic@apic.name)
[19:59:53] <nmz1> you could also do 2 passes
[20:05:19] <emanuele6> how does that help?
[20:25:32] *** Joins: BSaboia (~bsaboia@177.37.198.227)
[20:29:33] *** Quits: BSaboia (~bsaboia@177.37.198.227) (Client Quit)
[20:34:28] <nmz1> not storing the range in a buffer
[20:39:01] *** Joins: BSaboia (~bsaboia@177.37.198.227)
[20:41:32] <emanuele6> i don't understand
[20:42:02] *** Quits: BSaboia (~bsaboia@177.37.198.227) (Client Quit)
[20:58:33] *** Joins: BSaboia (~bsaboia@177.37.198.227)
[20:58:47] <nmz1> mmm yeah its not possible, nvm.
[21:47:30] *** Joins: nvmd (~nvmd@user/nvmd)
[21:57:44] *** Joins: x88x88x (~x88x88x@2001:19f0:5:39a8:5400:3ff:feb6:73cb)
[22:32:17] *** Quits: BSaboia (~bsaboia@177.37.198.227) (Quit: This computer has gone to sleep)
[22:36:06] *** Joins: Celmor[m] (~celmormat@2001:470:69fc:105::434)
[22:36:13] <Celmor[m]> hi
[22:37:17] <Celmor[m]> I'm trying to use this snippet in my (g)awk line: '!s[$0]++'
[22:38:58] <Celmor[m]> started with this line: '{for (i=2; i<NF; i++) printf $i "/"; print ""}'
[22:39:45] <Celmor[m]> to store the generated line I've adapted it to: '{l=$2; for (i=3; i<NF; i++) l=l"/"$i; print l}'
[22:40:37] <emanuele6> { str = $2; for (i = 3; i < NF; i++) str = str "/" $i } !s[str]++
[22:41:05] <e36freak> ok?
[22:41:44] <Celmor[m]> I was failing at combining it with  '!s[$0]++' instead of the print so only uniq lines are printed (without requiring sorting)
[22:42:33] <emanuele6> well, !s[str]++ { print str } actually
[22:43:00] <Celmor[m]> yeah, was already about to say...
[22:43:10] <Celmor[m]> thought that I need some kind of if logic here
[22:43:28] <e36freak> you have if logic there, it's just implicit
[22:43:39] <Celmor[m]> ik
[22:43:45] <e36freak> you could also write it as {str=$2; for (...) ...; if (!s[str]++) print str}
[22:43:49] <Celmor[m]> just the body was missing
[22:44:07] <Celmor[m]> was about to look up how to do if in awk to solve it
[22:44:25] <Celmor[m]> but emanuele6 preempted me
[22:44:43] <e36freak> well there's an if statement
[22:44:51] <Celmor[m]> ik
[22:45:31] <Celmor[m]> I'm also familiar with how `!s[$0]++` is supposed to work, just didn't get the part about needing to add an if body quickly enough
[22:45:50] <emanuele6> but wouldn't it be simpler to just use   { gsub("^[^/]+/|/[^/]$", "") } !a[$0]++   instead of that loop, do you really need that loop?
[22:46:34] <Celmor[m]> I didn't find a better way to concatenate those fields without leaving white spaces from the SO answers I've read
[22:46:35] <emanuele6> err, missed a +, and i should have used * instead of +    { gsub("^[^/]*/|/[^/]*$", "") } !a[$0]++
[22:46:48] <Celmor[m]> certainly doesn't appear simpler
[22:46:57] <emanuele6> without leaving whitespace?
[22:48:27] <Celmor[m]> the first 2 awk solutions here leave white spaces https://stackoverflow.com/questions/2626274/print-all-but-the-first-three-columns
[22:49:14] <e36freak> http://awk.freeshell.org/RangeOfFields
[22:49:18] <Celmor[m]> well, like half of the solutions I've found did it kind of like this: $1="";$2="", etc.
[22:50:36] <Celmor[m]> it lost me after 'Using sub()'
[22:50:58] <Celmor[m]> the for loop is logical. the sub line is cryptic
[22:53:10] <Celmor[m]> anyway, for now the loop will have to suffice. thanks
[23:20:48] <e36freak> just has some options
[23:20:52] <e36freak> for loops work fine
[23:21:07] <e36freak> honestly probably faster/more efficient than regex anyway
[23:22:09] <Celmor[m]> alright
[23:36:24] *** Quits: seninha (~seninha@user/seninha) (Quit: Leaving)
[23:41:39] *** Joins: fford (~fford@p200300c6ff35820060d8bedc1c419ec5.dip0.t-ipconnect.de)
[23:44:25] *** Joins: seninha (~seninha@user/seninha)
