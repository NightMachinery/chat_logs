[00:02:02] *** Quits: Oddity (Oddity@user/oddity) (Remote host closed the connection)
[00:05:05] *** Joins: kevingal (~quassel@2a02:8084:4140:f300:a5ca:745c:6e3:bad5)
[00:10:57] *** Quits: mcfrdy (~mcfrdy@user/mcfrdy) (Ping timeout: 255 seconds)
[00:14:57] *** Joins: mcfrdy (~mcfrdy@45.67.96.77)
[00:14:57] *** Quits: mcfrdy (~mcfrdy@45.67.96.77) (Changing host)
[00:14:57] *** Joins: mcfrdy (~mcfrdy@user/mcfrdy)
[00:15:25] *** Joins: attila_lendvai (~alendvai@C226762F.nat.pool.telekom.hu)
[00:18:26] *** Joins: cage (~cage@dynamic-adsl-78-15-46-179.clienti.tiscali.it)
[00:28:21] <lucerne> How do I convert `#P"/sth/" to `#P"/sth"`?
[00:32:17] <lucerne> (I want to check for symlinks, and `osicat:file-kind` returns the wrong result when the last slash is present.)
[00:33:29] <_death> can't use TRUENAME?
[00:35:25] *** Quits: peterhil_ (~peterhil@dsl-hkibng32-54f849-252.dhcp.inet.fi) (Read error: Connection reset by peer)
[00:41:07] <lucerne> _death: I want to check if a pathname is a symlink or not. Are you suggesting `(equalp (truename path) path)`?
[00:41:27] <lucerne> I think this will encounter edge cases
[00:42:16] <lucerne> I am currently using an SBCL-only solution courtesy of https://stackoverflow.com/questions/32927250/sbcl-determine-if-symbolic-link , but I was hoping to find a portable solution in a library
[00:43:35] *** Joins: tyson2 (~user@cpeac202e798f63-cmac202e798f60.cpe.net.cable.rogers.com)
[00:44:06] <_death> maybe, I've not tried it.. I'm quick to turn to native namestrings for that stuff
[00:52:11] <moon-child> it occurs to me that if you put every macro in its own package, you can elide 'gensym'
[01:03:50] *** Quits: cage (~cage@dynamic-adsl-78-15-46-179.clienti.tiscali.it) (Quit: rcirc on GNU Emacs 27.1)
[01:05:00] *** Joins: hafat (~hafat@95.70.168.45)
[01:26:49] *** Quits: scymtym (~user@2001:638:504:20e6:6ac3:87e0:e782:f3fc) (Ping timeout: 246 seconds)
[01:32:51] *** Joins: tfb (~tfb@88.98.95.237)
[01:33:46] *** Quits: tfb (~tfb@88.98.95.237) (Client Quit)
[01:38:52] *** Quits: Lord_Nightmare (Lord_Night@user/lord-nightmare/x-3657113) (Ping timeout: 245 seconds)
[01:42:32] *** Joins: pjb (~pjb@user/pjb)
[01:44:06] *** Quits: tyson2 (~user@cpeac202e798f63-cmac202e798f60.cpe.net.cable.rogers.com) (Quit: ERC (IRC client for Emacs 27.2))
[01:46:50] *** Quits: hendursaga (~weechat@user/hendursaga) (Remote host closed the connection)
[01:47:15] *** Joins: hendursaga (~weechat@user/hendursaga)
[01:52:04] *** Joins: scymtym (~user@ip-88-153-154-183.hsi04.unitymediagroup.de)
[01:55:46] *** Joins: ems (~ems@2a02:a318:813a:d880:3838:9caa:fbe5:ccac)
[01:56:29] *** Quits: ems (~ems@2a02:a318:813a:d880:3838:9caa:fbe5:ccac) (Client Quit)
[01:56:34] *** Quits: attila_lendvai (~alendvai@C226762F.nat.pool.telekom.hu) (Ping timeout: 246 seconds)
[01:58:56] *** Joins: Lord_Nightmare (Lord_Night@user/lord-nightmare/x-3657113)
[02:01:13] *** Quits: pve (~pve@37-136-221-208.rev.dnainternet.fi) (Quit: leaving)
[02:07:03] *** Quits: mcfrdy (~mcfrdy@user/mcfrdy) (Ping timeout: 255 seconds)
[02:07:24] *** Joins: mcfrdy (~mcfrdy@45.67.96.175)
[02:07:24] *** Quits: mcfrdy (~mcfrdy@45.67.96.175) (Changing host)
[02:07:24] *** Joins: mcfrdy (~mcfrdy@user/mcfrdy)
[02:11:00] *** Quits: amb007 (~a_bakic@52.196.23.93.rev.sfr.net) (Ping timeout: 265 seconds)
[02:12:11] *** Joins: amb007 (~a_bakic@38.199.23.93.rev.sfr.net)
[02:15:38] *** Quits: kpoeck (~kpoeck@87.140.193.0) (Quit: Client closed)
[02:19:44] <pjb> alanz: dsk: yes, sorry, I forgot the pprint I usually use: (let ((*print-circle* t)) (pprint (macroexpand-1 '(rotatef a b)))) #| (multiple-value-bind (#2=#:g17704) a (multiple-value-bind (#1=#:g17705) b (progn (setq a #1#) (setq b #2#) nil))) |#
[02:20:43] *** Quits: amb007 (~a_bakic@38.199.23.93.rev.sfr.net) (Ping timeout: 246 seconds)
[02:21:26] *** Joins: amb007 (~a_bakic@217.104.23.93.rev.sfr.net)
[02:22:44] *** Joins: kakuhen (~kakuhen@user/kakuhen)
[02:23:34] *** Joins: OlCe (~user@lfbn-nic-1-123-149.w2-15.abo.wanadoo.fr)
[02:24:23] <alanz> pjb: thanks, that shows it clearly.
[02:26:19] *** Joins: lotuseater (~user@p200300e787091b00387e7f8a32e5e786.dip0.t-ipconnect.de)
[02:27:13] *** Quits: OlCe (~user@lfbn-nic-1-123-149.w2-15.abo.wanadoo.fr) (Remote host closed the connection)
[02:28:38] *** Joins: lisp123 (~lisp123@5.30.23.247)
[02:29:28] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[02:30:48] *** Joins: lisp123 (~lisp123@5.30.23.247)
[02:35:24] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 255 seconds)
[02:36:06] *** Quits: frgo (~frgo@p200300deef181d00c103409d9357a0fc.dip0.t-ipconnect.de) (Remote host closed the connection)
[02:36:35] *** Joins: frgo (~frgo@p200300deef181d0031e33461748926d3.dip0.t-ipconnect.de)
[02:42:14] *** Quits: gaqwas (~john@dynamic-095-114-101-134.95.114.pool.telefonica.de) (Ping timeout: 268 seconds)
[02:46:44] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-10-70-54-112-49.dsl.bell.ca)
[03:03:10] *** Joins: lisp123 (~lisp123@5.30.23.247)
[03:06:10] *** Quits: PinealGlandOptic (~PinealGla@37.115.210.35) (Quit: leaving)
[03:08:32] *** Joins: PinealGlandOptic (~PinealGla@37.115.210.35)
[03:11:46] *** Quits: isekaijin (~pyon@user/pyon) (Ping timeout: 252 seconds)
[03:15:48] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[03:39:28] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-10-70-54-112-49.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[03:40:56] *** Quits: kevingal (~quassel@2a02:8084:4140:f300:a5ca:745c:6e3:bad5) (Remote host closed the connection)
[03:50:26] *** Joins: selwyn (~selwyn@user/selwyn)
[03:53:57] *** Quits: random-nick (~random-ni@87.116.179.136) (Ping timeout: 265 seconds)
[04:01:53] *** Joins: igemnace (~ian@user/igemnace)
[04:02:24] *** Quits: mcfrdy (~mcfrdy@user/mcfrdy) (Ping timeout: 268 seconds)
[04:07:05] *** Joins: mcfrdy (~mcfrdy@45.67.96.175)
[04:07:05] *** Quits: mcfrdy (~mcfrdy@45.67.96.175) (Changing host)
[04:07:05] *** Joins: mcfrdy (~mcfrdy@user/mcfrdy)
[04:13:43] *** Quits: igemnace (~ian@user/igemnace) (Remote host closed the connection)
[04:14:07] *** Quits: lad_ (~lad@user/lad) (Ping timeout: 268 seconds)
[04:21:26] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-10-70-54-112-49.dsl.bell.ca)
[04:31:58] *** Quits: pjb (~pjb@user/pjb) (Ping timeout: 246 seconds)
[04:46:05] *** Quits: derelict (~derelict@user/derelict) (Ping timeout: 255 seconds)
[04:47:40] *** Quits: selwyn (~selwyn@user/selwyn) (Read error: Connection reset by peer)
[04:50:58] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Quit: WeeChat 3.2)
[04:53:40] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[05:01:48] *** Joins: derelict (~derelict@user/derelict)
[05:06:37] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Ping timeout: 258 seconds)
[05:14:10] *** Parts: akoana (~ah@user/akoana) ()
[05:15:20] *** Quits: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) (Ping timeout: 255 seconds)
[05:17:37] *** Joins: beach` (~user@2a01:cb19:150:3400:fa26:a7f0:7f85:2f3f)
[05:21:38] *** Quits: beach (~user@2a01:cb19:150:3400:f6c1:2990:be56:e904) (Ping timeout: 255 seconds)
[05:33:00] *** Quits: derelict (~derelict@user/derelict) (Quit: WeeChat 3.2)
[05:42:43] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[05:43:02] *** Joins: pjb (~pjb@user/pjb)
[05:44:35] *** Quits: hafat (~hafat@95.70.168.45) (Ping timeout: 255 seconds)
[06:00:54] *** Joins: mcfrdy- (~mcfrdy@45.67.96.175)
[06:01:30] *** Quits: mcfrdy (~mcfrdy@user/mcfrdy) (Ping timeout: 255 seconds)
[06:16:33] *** Joins: lottaquestions_ (~nick@104.221.94.126)
[06:18:09] *** Quits: lottaquestions (~nick@2607:fa49:5040:5c00:600d:8cfc:ec77:20ca) (Ping timeout: 255 seconds)
[06:19:19] *** Joins: Bike (~Bike@71.69.170.70)
[06:19:19] *** ChanServ sets mode: +o Bike
[06:20:59] *** Quits: lottaquestions_ (~nick@104.221.94.126) (Client Quit)
[06:21:23] *** Joins: lottaquestions_ (~nick@2607:fa49:5040:5c00:554d:b7e7:d0d9:1764)
[06:21:58] *** Quits: lottaquestions_ (~nick@2607:fa49:5040:5c00:554d:b7e7:d0d9:1764) (Client Quit)
[06:22:08] <Bike> helloooo. i am working on my threads extension again. can someone give me a name to use for a declaration that means "the compiler can/should insert points where asynchronous signals can be handled"? i'm blanking. i was going to use "interruptible", but then the opposite would be "uninterruptible", but code not having safe points doesn't mean it
[06:22:09] <Bike> cannot be interrupted
[06:25:54] *** Quits: dsk (~dsk@user/dsk) (Ping timeout: 240 seconds)
[06:26:21] <aeth> Bike: asyncable?
[06:26:30] <aeth> (compare with: ignorable)
[06:26:44] <moon-child> I don't think that's a problem per se.  That you've marked some function as interruptible doesn't mean other functions are uninterruptible, only that you haven't explicitly said they're interruptible
[06:29:15] <Bike> well what i mean is there'd be another declaration meaning "do NOT insert these points"
[06:29:32] <Bike> and i don't want to call that "uninterruptible"
[06:29:53] <Bike> because that's different (e.g. the programmer could insert explicit safe points)
[06:29:56] *** Quits: White_Flame (~quassel@user/white-flame/x-6930243) (Ping timeout: 272 seconds)
[06:35:09] <moon-child> ah, fair enough
[06:35:28] <moon-child> so there are three different states a function can have?
[06:35:55] <moon-child> oh, no, I misread
[06:36:13] <Bike> two. either points are inserted or they're not, and by default they're not. i could also add a finer grain to it i guess, like some points are inserted, but i don't know how valuable that would be
[06:40:04] <moon-child> how about 'hooked' and 'unhooked'?  (Because the function contains 'hooks' for async signals)
[06:44:10] <Bike> not bad, but "hook" might have too many other meanings
[06:44:29] <Bike> maybe for now i'll just write something like "insert-safepoints" "noinsert-safepoints" and solve the hardest problem in computer science later
[06:50:28] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-10-70-54-112-49.dsl.bell.ca) (Remote host closed the connection)
[06:56:26] *** Joins: zacts (~zacts@user/zacts)
[07:01:53] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[07:04:57] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 255 seconds)
[07:06:14] *** Joins: peterhil (~peterhil@dsl-hkibng32-54f849-252.dhcp.inet.fi)
[07:24:40] *** Quits: prxq_ (~quassel@x4db42d3f.dyn.telefonica.de) (Ping timeout: 268 seconds)
[07:24:55] *** Joins: prxq (~quassel@x4dbe79cd.dyn.telefonica.de)
[07:25:13] *** Quits: zacts (~zacts@user/zacts) (Ping timeout: 246 seconds)
[07:27:49] *** beach` is now known as beach
[07:28:00] *** ChanServ sets mode: +o beach
[07:29:50] *** beach sets mode: -o beach
[07:31:16] <beach> Good morning everyone!
[07:36:46] *** Quits: lotuseater (~user@p200300e787091b00387e7f8a32e5e786.dip0.t-ipconnect.de) (Ping timeout: 246 seconds)
[07:50:04] *** Quits: pjb (~pjb@user/pjb) (Ping timeout: 246 seconds)
[07:59:30] *** Joins: mcfrdy (~mcfrdy@45.67.96.175)
[07:59:30] *** Quits: mcfrdy (~mcfrdy@45.67.96.175) (Changing host)
[07:59:30] *** Joins: mcfrdy (~mcfrdy@user/mcfrdy)
[08:00:27] *** Quits: mcfrdy- (~mcfrdy@45.67.96.175) (Ping timeout: 265 seconds)
[08:03:20] <PinealGlandOptic> beach: !
[08:03:26] <PinealGlandOptic> beach: you migrated as well
[08:04:39] <beach> To Libera?
[08:09:52] <PinealGlandOptic> beach: yep
[08:10:06] <beach> Sure.  Didn't everyone?
[08:10:23] <PinealGlandOptic> beach: some users are still at Freenode. Dunno why
[08:11:38] <beach> Hmm.
[08:25:03] <remexre> how are &key args efficiently implemented in the absence of inlining?
[08:26:22] <beach> They usually aren't.  But you can get an idea of how it can be done here: http://metamodular.com/SICL/call-site-optimization.pdf
[08:27:25] <beach> The function basically has to loop over all the remaining arguments and compare the keys.
[08:28:27] <remexre> okay, the looping is what I was thinking of; desugaring &key a to something like &key a (error "missing a"), and iterating through
[08:28:39] <beach> Another common "trick" is to define a compiler macro where it matters.
[08:29:14] *** Joins: paulapatience (~paul@23-233-104-4.cpe.pppoe.ca)
[08:29:20] <beach> Why the error?
[08:29:57] <remexre> the language I'm implementing isn't actually CL-compatible, just CL-like
[08:30:48] <remexre> "things don't generally implicitly default to nil" is one of the changes I'm making
[08:31:05] <moon-child> remexre: that's how s7 does it as well
[08:35:53] <beach> remexre: That's not going to make it more efficient though.
[08:36:06] <remexre> right, that's the inefficient one
[08:36:15] <remexre> after reading the one you sent
[08:38:08] <remexre> Is the trampoline he same idea as adding an "inline-arg-parsing" declaration, and making defun generate a wrapper for arg parsing; inline-arg-parsing sets the inline flag only on the outer function, inline sets it on both
[08:39:29] <beach> No.  Anything done at compile time in the caller must be re-done when the callee is redefined.  The technique in the paper does not require the caller to be recompiled when the callee changes.
[08:40:54] *** Quits: paulapatience (~paul@23-233-104-4.cpe.pppoe.ca) (Remote host closed the connection)
[08:42:19] <beach> Recompiling callers is iffy in Common Lisp, because of the requirement of "minimal compilation".  You would need to keep around a fully macroexpanded version of the caller.
[08:42:22] <remexre> how does the snippet get replaced?
[08:42:47] <beach> It's all in the paper.  It gets replaced when the callee is redefined.
[08:42:57] *** Quits: Bike (~Bike@71.69.170.70) (Quit: Connection closed)
[08:42:57] <remexre> er, how, not when
[08:43:04] <remexre> like shouldn't that require updating the caller?
[08:43:09] <beach> No.
[08:43:28] <beach> The arguments that the caller supplies remain the same.
[08:43:34] <beach> So there is no reason to update the caller.
[08:44:20] <remexre> oh, right, (f 1 2 3) is already indirecting through f, so the pointer that looks up can just change since it wouldn't be a direct jmp anyway?
[08:44:51] <remexre> or
[08:44:53] <remexre> hm
[08:45:23] <beach> Right.  The jump target is altered when the callee is redefined, so that it goes to a new trampoline snippet.
[08:45:59] <beach> But if you are designing a new language, you can do what you want.  No need to respect Common Lisp semantics.  You can remove the "minimal compilation" restriction and just recompile the callers.
[08:46:22] <remexre> yeah, the real problem with that is I don't have weak refs yet, lol
[08:46:33] <moon-child> 'just' that could be a nontrivial enterprise, for an optimizing compiler
[08:46:55] <moon-child> (in terms of compile time, I mean)
[08:48:54] <beach> I wouldn't expect there to be a lot of redefinitions of callees with a lot of callers.
[08:49:13] <beach> And it's all compile-time stuff anyway.
[08:50:37] <beach> remexre: If you are designing a new language, introducing weak references is trivial.  I would amount to a maximum of a paragraph in the language definition.
[08:51:02] <beach> But maybe you are implementing it as well.
[08:51:47] <moon-child> most people who design languages are obligated by necessity to implement them themselves, or to go without an implementation
[08:51:56] <remexre> yeah, implementation is the problem
[08:52:09] <remexre> I definitely need weak maps at least, and at that point weak pointers are trivial
[08:52:30] <remexre> but I'm doing my own GC, and they're NYI (and the bootstrapper's GC doesn't support them)
[08:57:11] *** Quits: mcfrdy (~mcfrdy@user/mcfrdy) (Ping timeout: 255 seconds)
[08:58:59] *** Joins: Bike (~Bike@71.69.170.70)
[08:58:59] *** ChanServ sets mode: +o Bike
[09:04:01] <beach> remexre: I am curious.  Why are you designing a new language?
[09:04:10] <remexre> mad @ unix
[09:04:13] *** Quits: Mandus (~aasmundo@0.51-175-33.customer.lyse.net) (Ping timeout: 268 seconds)
[09:04:16] *** Joins: lottaquestions (~nick@2607:fa49:5040:5c00:790d:d034:7297:4543)
[09:04:38] *** Joins: Mandus (~aasmundo@85.112.154.250)
[09:05:30] *** Joins: Volt (~Volt@c-73-145-164-70.hsd1.mi.comcast.net)
[09:05:38] <beach> remexre: Designing a new language is a lot harder than implementing an existing specification, so there must be something you can not tolerate about Common Lisp in your context, no?
[09:06:03] <beach> Apparently, your new language has automatic memory management and keyword arguments, so you are not skimping there.
[09:06:30] <remexre> trying to make something that's like, CL-like but with better support for implementing other languages in it and doing interop in the same process, and making the VM a lot more erlang-like (lots of immutability, message-passing, probably the same supervisor/link/etc design)
[09:06:54] <beach> I see.
[09:07:21] <remexre> probably going to implement an attribute grammar language and a dependent static lang on top of it, maybe a logic language too
[09:08:31] <moon-child> what is it about cl that makes it unamenable to such designs?  You can certainly implement vms and other languages atop it; and frameworks for making such things easier.  There's a fairly complete ml somebody's done, for instance
[09:08:54] <remexre> can I do the erlang-stuff without a code-walker?
[09:09:05] <beach> remexre: Good luck.  Such an undertaking is no doubt an order of magnitude harder than something like SICL.
[09:09:10] <moon-child> since you're not going full-out on the immutability (I assume, since you refer to weak pointers), they don't let you simplify any other aspects of the implementation
[09:10:14] <remexre> I have some types that have mutability, but most don't
[09:10:52] <remexre> e.g. conses are immutable, but I have mutable hashtables, mutable cells, etc
[09:11:36] <moon-child> what erlang stuff?  Context switching?  I think you might be best served by making an implementation with extensions specialized for the purpose, but piggybacking atop cl lets you take advantage of a lot of existing ocde and, as beach mentions, means you don't have to design a language from scratch.  Of course, I dont' have very much right to say such a thing, but ¯\_(ツ)_/¯
[09:13:12] <remexre> like being able to run 10k processes on one machine, being able to structure applications with links+monitors (and supervisors etc on top of them), message-passing of immutable values (with that being checked), etc
[09:13:25] <remexre> idk, not my first lang design or implementation
[09:14:31] <moon-child> remexre: I have full immutability, except for buffers (fixnums/floats/bytes/whatever); this simplifies the gc because you can collect concurrently without barriers.  If you have mutable objects that contain references, then you still have to deal with all the consequences of mutability
[09:16:48] <remexre> I tihnk doing erlang means you don't actually want concurrent GC, because you want to "charge" GC against the process in the scheduler
[09:18:16] *** Quits: Mandus (~aasmundo@85.112.154.250) (Ping timeout: 265 seconds)
[09:19:57] *** Joins: Mandus (~aasmundo@0.51-175-33.customer.lyse.net)
[09:20:50] <moon-child> my understanding is that in erlang every process has its own heap
[09:22:35] <remexre> yeah
[09:27:44] <moon-child> which means that if two erlang processes are running on two different physical cpu cores, one can be gc'd while the other is running
[09:27:49] <moon-child> which looks a lot like concurrent gc
[09:27:57] <remexre> sure, yeah
[09:28:33] <moon-child> however this only works because messages are always copied when sent.  If I try to send a mutable cons cell from one thread to another under this model, all behaviours are wrong
[09:28:45] <remexre> yep, that's why I'm separating immutable vs mutable types
[09:28:58] <moon-child> so mutable data cannot be sent in messages?
[09:29:02] <remexre> yeah
[09:30:04] *** Joins: lisp123 (~lisp123@5.30.23.247)
[09:30:31] <moon-child> hmm.  I prefer actually shared-immutable, but eh you do you :)
[09:31:21] <remexre> considered it, but it'
[09:31:35] <remexre> d be really nice if I could do the multi-machine stuff too
[09:32:05] <moon-child> when you do that you have referential transparency.  So you _can_ do a copy if you want
[09:32:26] <remexre> I guess
[09:33:46] <remexre> idk, if it's expensive enough that it's often showing up in profiles, I'll maybe add a special mechanism for it
[09:34:15] <remexre> but I hypothesize that most data is small or strings/byte-vectors, both of which should be quick to copy
[09:34:47] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Ping timeout: 268 seconds)
[09:35:28] <remexre> er, most data being sent via message*
[09:38:44] *** Quits: jmes (~james@d75-155-42-59.abhsia.telus.net) (Remote host closed the connection)
[09:43:00] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[09:43:15] *** Joins: lisp123 (~lisp123@5.30.23.247)
[09:54:18] *** Quits: Bike (~Bike@71.69.170.70) (Quit: Connection closed)
[10:25:30] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[10:46:40] *** Joins: gaqwas (~john@dynamic-077-009-191-197.77.9.pool.telefonica.de)
[10:48:47] *** Quits: taiju (~taiju@M014013236064.v4.enabler.ne.jp) (Ping timeout: 268 seconds)
[11:08:56] *** Joins: lisp123_ (~lisp123@45.130.83.181)
[11:09:45] *** Joins: taiju (~taiju@240b:253:ec40:2400:654f:7566:b735:5f06)
[11:12:16] *** Joins: lisp123__ (~lisp123@45.130.83.185)
[11:12:28] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[11:15:09] *** Quits: lisp123_ (~lisp123@45.130.83.181) (Ping timeout: 255 seconds)
[11:20:24] *** Joins: lisp123 (~lisp123@5.30.23.247)
[11:22:43] *** Quits: lisp123__ (~lisp123@45.130.83.185) (Read error: Connection reset by peer)
[11:25:30] *** Quits: taiju (~taiju@240b:253:ec40:2400:654f:7566:b735:5f06) (Ping timeout: 255 seconds)
[11:29:28] *** Joins: mcfrdy_ (uid507892@user/mcfrdy)
[11:35:02] *** Quits: gaqwas (~john@dynamic-077-009-191-197.77.9.pool.telefonica.de) (Ping timeout: 268 seconds)
[11:44:10] *** Joins: taiju (~taiju@M014013236064.v4.enabler.ne.jp)
[11:50:51] *** Quits: Volt (~Volt@c-73-145-164-70.hsd1.mi.comcast.net) (Quit:  )
[11:58:57] *** Quits: trufas (~trufas@177.240.218.218) (Ping timeout: 276 seconds)
[11:59:49] *** Joins: trufas (~trufas@177.240.218.218)
[12:16:48] *** Quits: amb007 (~a_bakic@217.104.23.93.rev.sfr.net) (Ping timeout: 255 seconds)
[12:17:57] *** Joins: amb007 (~a_bakic@200.107.23.93.rev.sfr.net)
[12:20:59] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[12:24:22] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 268 seconds)
[12:36:40] *** Joins: pve (~pve@178-55-51-102.bb.dnainternet.fi)
[12:37:01] *** Joins: hendursa1 (~weechat@user/hendursaga)
[12:39:11] *** Quits: hendursaga (~weechat@user/hendursaga) (Ping timeout: 244 seconds)
[12:39:48] <lisp123> Is there a way to test only for 't'?
[12:40:33] <moon-child> (eq t whatever)?
[12:41:03] *** Joins: ems (~ems@2a02:a318:813a:d880:b47f:6b1:d194:72ff)
[12:42:33] *** Quits: ems (~ems@2a02:a318:813a:d880:b47f:6b1:d194:72ff) (Client Quit)
[12:46:25] <lisp123> moon-child: thanks that works. I have then tried (setf test t) and did (eq t test) and it worked - from my understanding eq tests if objects are identical and not their values
[12:47:11] <lisp123> i.e. eq compares pointers - is there a chance that two symbols, both with t value will have pointers to different "t"?
[12:47:25] <moon-child> no
[12:47:30] <moon-child> symbols are interned
[12:47:54] <moon-child> so--it's not the case that  (eq t '#:t),  but I expect you don't want that to be the case
[12:49:04] <moon-child> (obviously two symbols named 't' from different packages will also not be eq, but again that's probably what you want)
[12:49:44] <pve> lisp123: if you are asking whether (eq 'cl:t 'cl:t) is always true, then yes
[12:50:28] *** Joins: treflip (~user@95.79.32.99)
[12:50:37] <lisp123> I am storing values in symbol - which can be either nil, t, or a value
[12:50:45] <lisp123> So I want to be able to distinguish between t & value
[12:51:10] <lisp123> (not knowing what value is)
[12:51:21] <moon-child> in that case, eq does what you want
[12:51:24] <pve> lisp123: then (eq t ... ) is what you need
[12:52:13] <lisp123> thanks, (this is just out of curiousity) does that mean a symbol with value t points to only instance of the value t?
[12:53:59] <pve> lisp123: yes, but like moon-child said, you need to know about packages to have the complete picture
[12:53:59] <moon-child> an interned symbol named "T" (or anything else) is unique within its package.  It is possible to create uninterned symbols, and symbols from different packages are distinct
[12:55:07] <lisp123> oh oaky, thanks pve & moon-child. I think I get it. So I need to be careful if comparing symbols from different packages?
[12:55:14] <lisp123> but within one package, its okay
[12:55:50] <pve> lisp123: and when you say "t", you implicitly mean cl:t
[12:56:07] <moon-child> most packages do not export symbols named NIL or T, so you are probably safe on that count.  In a general sense, you need to be aware of packages when comparing symbols, but the default behaviour is almost certainly what you want
[12:56:39] <pve> lisp123: try (symbol-package t) in your package
[12:57:12] <lisp123> thanks! that all makes sense now
[12:57:21] *** Joins: Lord_of_Life_ (~Lord@user/lord-of-life/x-2819915)
[13:00:36] *** Quits: Lord_of_Life (~Lord@user/lord-of-life/x-2819915) (Ping timeout: 265 seconds)
[13:00:38] *** Lord_of_Life_ is now known as Lord_of_Life
[13:20:31] <conjunctive> Hello, when defining a binary class (using the binary-types package) is it possible to express a sequence of another binary class as a single binary type? For example with class Y I'd like a slot describing 20 of class X in sequence.
[13:29:07] *** Joins: cage (~cage@dynamic-adsl-78-15-46-179.clienti.tiscali.it)
[13:37:45] *** Quits: amb007 (~a_bakic@200.107.23.93.rev.sfr.net) (Ping timeout: 268 seconds)
[13:38:08] *** Joins: pjb (~pjb@user/pjb)
[13:38:46] *** Joins: amb007 (~a_bakic@166.52.205.77.rev.sfr.net)
[13:44:05] *** Joins: lisp123_ (~lisp123@45.130.83.181)
[13:48:14] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 268 seconds)
[13:53:51] *** Joins: lisp123 (~lisp123@5.30.23.247)
[13:57:32] *** Quits: lisp123_ (~lisp123@45.130.83.181) (Ping timeout: 258 seconds)
[14:04:04] <pve> Is there a function similar to "(setf macro-function)", but for symbol macros? I.e. something that can be used to install a symbol macro.
[14:08:56] *** Joins: Guest77 (~Guest77@2402:e280:2117:297:ecf8:f374:8704:f843)
[14:13:01] <pjb> pve: there is not. You have to use the macro define-symbol-macro. You could do: (defun (setf symbol-macro) (new-expansion symbol) (eval `(define-symbol-macro ,symbol ,new-expansion))) and (defun symbol-macro (symbol) (macroexpand-1 symbol))  (symbol-macro 'foo) #| --> foo ; nil |# (setf (symbol-macro 'foo) '(car koo)) #| --> foo |# (symbol-macro 'foo) #| --> (car koo) ; t |# (let ((koo '(a . d))) foo) #| --> a |#
[14:13:36] <pjb> pve: but only for global symbol macros. For lexical symbol macros, you have to use symbol-macrolet.
[14:14:22] <pve> pjb: thanks, I kinda guessed this called for eval
[14:14:22] <pjb> Since macros are compilation-time objects, local symbol macros still have to be known at compilation-time, so you cannot use setf to mutate them.
[14:15:38] *** Joins: ems (~ems@2a02:a318:813a:d880:b47f:6b1:d194:72ff)
[14:16:37] *** Quits: mcfrdy_ (uid507892@user/mcfrdy) (Quit: Connection closed for inactivity)
[14:20:33] *** Joins: hafat (~hafat@95.70.168.45)
[14:22:43] *** Joins: hafat_ (~hafat@95.70.168.45)
[14:22:56] *** Quits: hafat (~hafat@95.70.168.45) (Client Quit)
[14:23:26] *** Parts: hafat_ (~hafat@95.70.168.45) ()
[14:24:57] *** Joins: hafat (~hafat@95.70.168.45)
[14:36:05] *** Quits: frgo (~frgo@p200300deef181d0031e33461748926d3.dip0.t-ipconnect.de) (Remote host closed the connection)
[14:36:32] *** Joins: frgo (~frgo@p200300deef181d0031e33461748926d3.dip0.t-ipconnect.de)
[14:42:24] *** Quits: kakuhen (~kakuhen@user/kakuhen) (Quit: Leaving...)
[14:58:15] *** Joins: dsk (~dsk@user/dsk)
[15:02:04] *** Joins: random-nick (~random-ni@87.116.165.220)
[15:07:34] *** Joins: learning-cl (~learning-@92.40.192.154.threembb.co.uk)
[15:21:37] *** Joins: tyson2 (~user@bras-base-toroon0624w-grc-10-70-54-112-49.dsl.bell.ca)
[15:23:40] *** Quits: dsk (~dsk@user/dsk) (Ping timeout: 246 seconds)
[15:33:53] *** Joins: lisp123_ (~lisp123@45.130.83.185)
[15:37:41] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[15:43:37] *** Joins: lisp123 (~lisp123@5.30.23.247)
[15:44:02] *** Joins: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[15:46:56] *** Quits: rgherdt (~rgherdt@ip5f5af43c.dynamic.kabel-deutschland.de) (Remote host closed the connection)
[15:47:06] *** Quits: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 252 seconds)
[15:47:24] *** Quits: lisp123_ (~lisp123@45.130.83.185) (Ping timeout: 255 seconds)
[15:53:29] *** Quits: lucerne (~lucerne@ip202.ip-51-178-215.eu) (Quit: Bye)
[15:55:03] *** Joins: greyrat_ (~greyrat@ip202.ip-51-178-215.eu)
[15:55:15] *** Joins: lucerne (~lucerne@ip202.ip-51-178-215.eu)
[15:55:35] *** Server sets mode: +Ccntz 
[15:56:34] *** Quits: greyrat (~greyrat@ip202.ip-51-178-215.eu) (Ping timeout: 240 seconds)
[16:06:58] *** Joins: Alfr (~Alfr@user/alfr)
[16:10:41] *** Quits: treflip (~user@95.79.32.99) (Quit: bb)
[16:31:27] *** Joins: aleamb (~aleamb@81.61.187.171.dyn.user.ono.com)
[16:46:37] *** Quits: learning-cl (~learning-@92.40.192.154.threembb.co.uk) (Ping timeout: 246 seconds)
[16:47:35] *** Quits: pjb (~pjb@user/pjb) (Remote host closed the connection)
[17:01:15] *** Quits: silasfox (~sbv@165.56.185.220) (Ping timeout: 268 seconds)
[17:07:23] *** Joins: silasfox (~sbv@165.56.185.42)
[17:16:28] *** Joins: learning-cl (~learning-@92.40.192.154.threembb.co.uk)
[17:27:09] *** Quits: amb007 (~a_bakic@166.52.205.77.rev.sfr.net) (Ping timeout: 268 seconds)
[17:27:55] *** Joins: amb007 (~a_bakic@147.132.22.93.rev.sfr.net)
[17:39:58] *** Quits: aleamb (~aleamb@81.61.187.171.dyn.user.ono.com) (Ping timeout: 265 seconds)
[17:40:11] *** Joins: pjb (~pjb@user/pjb)
[17:49:37] *** Quits: tyson2 (~user@bras-base-toroon0624w-grc-10-70-54-112-49.dsl.bell.ca) (Quit: ERC (IRC client for Emacs 27.2))
[17:50:54] *** Joins: CrashTestDummy2 (~CrashTest@ool-ad02813b.dyn.optonline.net)
[17:54:18] *** Quits: CrashTestDummy3 (~CrashTest@ool-ad02813b.dyn.optonline.net) (Ping timeout: 255 seconds)
[17:58:42] *** Joins: Th30n (~Th30n@cpe-94-253-167-200.zg.cable.xnet.hr)
[18:02:18] *** Quits: amb007 (~a_bakic@147.132.22.93.rev.sfr.net) (Ping timeout: 268 seconds)
[18:02:53] *** Joins: amb007 (~a_bakic@70.151.22.93.rev.sfr.net)
[18:03:39] *** Quits: azimut_ (~azimut@gateway/tor-sasl/azimut) (Ping timeout: 244 seconds)
[18:06:18] *** Joins: azimut (~azimut@gateway/tor-sasl/azimut)
[18:21:38] <lisp123> I was thinking
[18:22:08] <lisp123> Would it have been smarter for CL to define all of its functions as defgenerics / defmethods instead?
[18:22:39] <lisp123> that way one could re-use these function names for one's own classes
[18:25:53] <pve> lisp123: efficiency was probably a concern
[18:26:13] <_death> no, that wouldn't be particularly smart.. a generic function serves a dual role, one for callers and one for extenders.. simply taking an ordinary, nonextensible function (with a contract for callers) and making it generic would get you the worst of both sides
[18:28:14] <lisp123> pve: thanks, makes sense - I guess there is a cost of "looking up" the correct method to apply each time
[18:28:59] <lisp123> _death: could you expand? is it the loss of clarity from having different versions of a given function?
[18:29:40] <pve> though I don't *know* if actually was a concern, much less the main one
[18:30:41] *** Joins: dsk (~dsk@user/dsk)
[18:33:11] <_death> consider a function like EQUAL.. for each pair of objects you can pass to it, there is a rule saying whether it returns true or false.. callers of EQUAL can rely on these fixed semantics.. if you just make it generic, suddenly EQUAL becomes some amorphous function that isn't very useful to callers.. consider function +.. making it a generic function would not be useful for extension, because it accepts any number of terms (including
[18:33:11] <_death> zero) and you wouldn't want to specialize on every term
[18:33:11] *** Quits: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431) (Quit: Leaving)
[18:35:06] <_death> (wrt EQUAL, note that methods can be added or removed at any time)
[18:36:57] <_death> often you need to create one function that is meant to be called, and another function or set of functions that are meant to be extended
[18:37:43] <_death> could CL be more extensible? yes, but that work would involve much more than making all functions generic
[18:38:12] <_death> for example look at Eclector which has protocols for extending the Lisp reader
[18:38:38] *** Joins: Inline (~Inline@2a02:908:1252:7a80:c035:deeb:51be:5431)
[18:40:57] <_death> for an example of parroting caller interface with "shadow" GFs, look at Gray Streams.. the interface for extension is pretty similar to what the callers have, with some tweaks like different behavior on EOF or such.. some of the bad consequences are described in Franz's simple-streams section in their manual
[18:41:46] <lisp123> _death: "and you wouldn't want to specialise on every term" >>> Perhaps my understanding of generic functions is incorrect (likely), but from what I understand (and I was trying to google it now), if there is no method defined for the class in question, the method for a class it inherits from is used? i.e. the most specialised method is used
[18:43:08] <_death> lisp123: what I mean is, suppose you wanted to extend to vectors.. how would you define a + method for doing that..
[18:43:26] <beach> This discussion is a great example of why language design is hard, and why we need to be very careful before thinking that suggested changes are automatically good.
[18:43:26] <beach>  
[18:44:08] <_death> lisp123: the solution in case might be to define two generic functions, UNARY-+ and BINARY-+ and have + call them as needed.. so one interface for callers and another for extenders
[18:44:58] <lisp123> _death: so to summarise, functions are meant to be called and we don't want to change their meaning, while generic functions are meant to be "user-defined" and when one sees it, they work with them in mind. Hence, its not good to make standard functions customizable, especially when multiple people work on the same codebase?
[18:45:42] <_death> lisp123: the point is that you don't always need or want to make things extensible, and when you do, you need to think it through
[18:46:02] <lisp123> beach: yes :-) I find one of the great beauties of Lisp is its clarity of concepts, that even mere mortal users start thinking at a higher level (and that helps improve their abilities - even though 90% of the time they are wrong ;)
[18:46:12] <lisp123> _death: gotcha
[18:46:16] <_death> lisp123: also, sometimes making things extensible doesn't mean using CLOS
[18:47:35] <lisp123> _death: noted
[18:47:46] <beach> lisp123: What I find most impressive about Common Lisp is that, the more I study it (in order to implement it), the more I am impressed by how smart and knowledgeable the people were who created the standard.
[18:47:50] *** Joins: zacts (~zacts@user/zacts)
[18:48:20] <lisp123> (my example came from writing my own 'remove-duplicates' for a certain list of objects and trying to avoid having to use a custom name such as remove-object-duplicates)
[18:48:43] <lisp123> beach: :-) Indeed, it seems like an amazing language
[18:48:47] <beach> lisp123: It has taken me decades to understand the language well enough to hope to implement it.  It will take me another couple of decades to acquire enough knowledge to improve it.
[18:49:23] <beach> ... aside from tiny little things like we do in WSCL.
[18:50:19] <lisp123> beach: at least you will know that what you are doing is on the frontier of Computer Science, whilst other languages keep re-applying the old concepts that CL already worked through
[18:52:20] <lisp123> beach: have you had a chance to talk to some of the CL committee members?
[18:54:29] *** Joins: IPmonger (~IPmonger@c-69-242-83-226.hsd1.pa.comcast.net)
[18:54:44] *** Quits: IPmonger (~IPmonger@c-69-242-83-226.hsd1.pa.comcast.net) (Remote host closed the connection)
[18:54:50] <beach> lisp123: I am sure I have.  I would have to look at the names again.
[18:55:04] <_death> more reasons that CL isn't very extensible in some parts is that it's an evolutionary step and had to take backwards compatibility into account.. also, CLOS was a new design and not everyone had lots of experience with it, and the idea of a CLOS-less subset of CL was in the air as well
[18:55:16] <beach> Kent Pitman was at ELS once, or perhaps ILC, I don't remember.
[18:56:42] <lisp123> _death: Thanks, that is good background knowledge to have
[18:57:00] <beach> pve has a point as well, given that PCL was the best they could do at the time in terms of generic dispatch, generic functions would have had a significant cost associated with them.
[18:57:37] <beach> And then we would have had to take opinions like "Lisp is slow" more seriously.
[18:58:09] <lisp123> beach: nice, his article(s) on exceptional situations in lisp were A+, although I must admit I can't be bothered using conditions when I code lol (although I might for one use-case soon: when I use somebody else's packages and am not guaranteed of the behaviour of that package)
[18:58:29] <beach> That's part of what impresses me with the language.  They didn't include features that they weren't absolutely sure could be implemented efficiently.  Unlike people who create other languages like Python.
[18:59:22] <beach> lisp123: So what do you do when you detect a violation of some precondition?
[18:59:37] <lisp123> Indeed, I think especially given the circumstances of processing power in the 70s and 80s
[18:59:55] <_death> if you have a language like Go, which didn't need to care for any previous codebases, you can see that some parts of its standard library are designed with extensibility in mind that makes things very convenient after adoption.. in CL you can create de-facto standards of extensibility, and it has more powerful tools to adapt the language, but it's more evolutionary and less "intelligent design".. of course, as time goes by, Go has to
[18:59:55] <_death> evolve and cannot be "re-designed" without terrible impact
[19:00:16] *** Quits: peterhil (~peterhil@dsl-hkibng32-54f849-252.dhcp.inet.fi) (Ping timeout: 268 seconds)
[19:00:32] <lisp123> beach: I write 95% of my code, so I keep it all in my head and make sure it all works - as long as I don't open it up to the outside world, it hasn't been too much of an
[19:01:29] <beach> lisp123: Oh, dear.  You must have debugging nightmares, with incorrect results propagating way too far along the way.
[19:01:44] <beach> lisp123: That's not a very efficient way to work.
[19:03:23] <lisp123> beach: lol ;) I'm learning by struggling :-) I'm doing a lot of very conceptual work, so there are less moving pieces and rote code, so for now I'm spending all of my limited energy on the problem at hand. I think as my program evolves, I will switch over to a more robust phase
[19:03:35] <lisp123> I think its about 3k lines of code atm to give you context
[19:05:07] <beach> I recommend the work of Bertrand Meyer about modularity.  He made a lot of concepts clear, like preconditions, invariants, exceptional situations.
[19:05:36] <beach> lisp123: So you are a newbie programmer in general?  Not only in Common Lisp?
[19:07:23] <lisp123> I would say a little bit above newbie, but not professional. I dropped out of IT in University (switched to business), but I do all front-end web dev work without probolem and created my own (somewhat popular :) ) apps in Swift for IOS
[19:08:24] <beach> Here is a short description of his work: https://en.wikipedia.org/wiki/Design_by_contract
[19:08:30] <lisp123> but no formal training, so a lot of stuff I do very badly (error handling and writing proper commit messages seem to be common ones), and wouldn't be able to work in a team for sure
[19:08:41] <lisp123> beach: thanks for the link, will definitely read
[19:10:35] <beach> Sure.
[19:13:16] *** Quits: learning-cl (~learning-@92.40.192.154.threembb.co.uk) (Ping timeout: 246 seconds)
[19:23:49] *** Joins: aleamb (~aleamb@81.61.187.171.dyn.user.ono.com)
[19:26:03] *** Quits: amb007 (~a_bakic@70.151.22.93.rev.sfr.net) (Ping timeout: 258 seconds)
[19:26:30] *** Joins: amb007 (~a_bakic@73.12.23.93.rev.sfr.net)
[19:27:00] *** Quits: dsk (~dsk@user/dsk) (Ping timeout: 255 seconds)
[19:30:46] *** Quits: amb007 (~a_bakic@73.12.23.93.rev.sfr.net) (Ping timeout: 252 seconds)
[19:31:14] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[19:34:06] *** Quits: silasfox (~sbv@165.56.185.42) (Ping timeout: 258 seconds)
[19:35:50] *** Quits: Th30n (~Th30n@cpe-94-253-167-200.zg.cable.xnet.hr) (Quit: WeeChat 3.2)
[19:36:10] *** Joins: learning-cl (~learning-@92.40.192.152.threembb.co.uk)
[19:36:16] *** Parts: learning-cl (~learning-@92.40.192.152.threembb.co.uk) ()
[19:39:30] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[19:40:19] *** Joins: lisp123 (~lisp123@5.30.23.247)
[19:40:25] <jcowan> If you think you want weak pointers, you really want ephemerons.
[19:40:31] *** Joins: OlCe (~user@lfbn-nic-1-123-149.w2-15.abo.wanadoo.fr)
[19:41:23] *** Joins: Bike (~Bike@71.69.170.70)
[19:41:23] *** ChanServ sets mode: +o Bike
[19:44:42] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 252 seconds)
[19:45:54] *** Quits: OlCe (~user@lfbn-nic-1-123-149.w2-15.abo.wanadoo.fr) (Ping timeout: 268 seconds)
[19:48:44] *** Joins: paulapatience (~paul@23-233-104-4.cpe.pppoe.ca)
[19:55:34] *** Joins: isekaijin (~pyon@user/pyon)
[19:56:26] *** Quits: amb007 (~a_bakic@23.184.126.78.rev.sfr.net) (Ping timeout: 252 seconds)
[19:57:11] *** Joins: amb007 (~a_bakic@23.184.126.78.rev.sfr.net)
[19:57:20] *** Joins: lisp123 (~lisp123@5.30.23.247)
[20:02:58] *** Joins: peterhil (~peterhil@dsl-hkibng32-54f849-252.dhcp.inet.fi)
[20:06:01] *** Quits: Alfr (~Alfr@user/alfr) (Quit: Leaving)
[20:11:40] *** Quits: recordgroovy (~recordgro@c-67-185-152-122.hsd1.wa.comcast.net) (Ping timeout: 258 seconds)
[20:12:34] *** Joins: pve_ (~pve@188-67-171-34.bb.dnainternet.fi)
[20:15:36] *** Quits: pve (~pve@178-55-51-102.bb.dnainternet.fi) (Ping timeout: 255 seconds)
[20:18:15] *** Joins: recordgroovy (~recordgro@c-67-185-152-122.hsd1.wa.comcast.net)
[20:18:47] *** pve_ is now known as pve
[20:21:21] *** Quits: recordgroovy (~recordgro@c-67-185-152-122.hsd1.wa.comcast.net) (Remote host closed the connection)
[20:31:19] *** Joins: waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd)
[20:45:40] *** Quits: zacts (~zacts@user/zacts) (Ping timeout: 246 seconds)
[20:46:17] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[20:46:53] *** Joins: zacts (~zacts@user/zacts)
[20:54:25] *** Joins: shka (~herr@109.231.62.239)
[20:55:41] *** Joins: lisp123 (~lisp123@5.30.23.247)
[20:57:59] *** Quits: Bike (~Bike@71.69.170.70) (Quit: Connection closed)
[21:00:21] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 258 seconds)
[21:03:10] *** Joins: lotuseater (~user@p200300e787091b00387e7f8a32e5e786.dip0.t-ipconnect.de)
[21:05:37] *** Quits: zacts (~zacts@user/zacts) (Ping timeout: 246 seconds)
[21:30:19] *** Joins: lisp123 (~lisp123@5.30.23.247)
[21:32:38] <lotuseater> beach: Why did you choose the BSD license for SICL? (I don't know much about licensing yet.)
[21:33:12] *** Joins: gaqwas (~john@dynamic-077-009-191-197.77.9.pool.telefonica.de)
[21:37:04] <shka> bsd and MIT are interchangeable honestly
[21:37:32] <shka> gpl is different, but it is hard to even interpret in the context of lisp program
[21:38:34] *** Joins: silasfox (~sbv@165.56.184.219)
[21:38:46] <shka> would running lisp code in GPL implementation made code also gpl?
[21:39:21] <lotuseater> sounds to be a complex topic
[21:39:35] <shka> i don't know, i am not a lawyer
[21:39:58] <lotuseater> I'm not too (obviously) :D
[21:43:28] <lisp123> shka: what is your feeling? would it make the code GPL?
[21:44:07] <shka> uh, i think so, yeah, but no idea really
[21:44:27] <lisp123> wow thats tough
[21:45:37] <lisp123> (sorry to continue this topic among us non-lawyers, buts its an interesting one), but that would imply all emac packages are GPL?
[21:46:07] <lisp123> whereas people do release their packages under other licenses, so perhaps their view is different
[21:46:14] <jackdaniel> it would not, program is input to the implementation
[21:46:39] <jackdaniel> like document printed with gpl document reader is not gpl
[21:46:49] <lisp123> jackdaniel: that was what my understandign was too
[21:46:51] *** Quits: azimut (~azimut@gateway/tor-sasl/azimut) (Ping timeout: 244 seconds)
[21:46:53] *** Joins: azimut_ (~azimut@gateway/tor-sasl/azimut)
[21:48:25] *** Joins: Alfr (~Alfr@user/alfr)
[21:48:43] <jackdaniel> gpl seems to be often disregarded with passion based on fueled fud (me ceases offtopic ;)
[21:50:18] <shka> at any rate
[21:50:23] <shka> i case of sicl
[21:50:36] <shka> if sicl components are supposed to be used
[21:50:36] *** Quits: paulapatience (~paul@23-233-104-4.cpe.pppoe.ca) (Read error: Connection reset by peer)
[21:50:54] <shka> then bsd license is good fit
[21:52:38] <shka> as majority of existing cl implementations are not written in gpl
[21:54:53] <shka> *licensed under the gpl
[21:57:49] *** Joins: Oladon (~olad@98.43.81.226)
[21:58:35] *** Quits: hendursa1 (~weechat@user/hendursaga) (Quit: hendursa1)
[21:59:23] *** Joins: hendursaga (~weechat@user/hendursaga)
[22:09:42] <lotuseater> sorry I'm away now for some time. have a nice day :)
[22:10:59] *** Quits: hafat (~hafat@95.70.168.45) (Ping timeout: 255 seconds)
[22:21:02] *** Quits: lisp123 (~lisp123@5.30.23.247) (Remote host closed the connection)
[22:21:58] *** Joins: lisp123 (~lisp123@5.30.23.247)
[22:25:18] *** Joins: modula (~defaultxr@99-138-110-241.lightspeed.cicril.sbcglobal.net)
[22:25:37] *** Quits: defaultxr (~defaultxr@99-138-110-241.lightspeed.cicril.sbcglobal.net) (Ping timeout: 265 seconds)
[22:25:38] *** modula is now known as defaultxr
[22:26:22] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 250 seconds)
[22:36:22] *** Quits: Guest77 (~Guest77@2402:e280:2117:297:ecf8:f374:8704:f843) (Quit: Client closed)
[22:45:54] *** Joins: Lycurgus (~juan@cpe-45-46-140-49.buffalo.res.rr.com)
[22:50:01] *** Joins: lisp123mobile (~lisp123mo@91.73.113.100)
[22:54:19] *** Quits: Xach (~xach@user/xach) (Quit: leaving)
[22:57:02] *** Quits: lisp123mobile (~lisp123mo@91.73.113.100) (Ping timeout: 265 seconds)
[23:00:01] *** Joins: lisp123 (~lisp123@5.30.23.247)
[23:03:01] *** Joins: Bike (~Bike@71.69.170.70)
[23:03:01] *** ChanServ sets mode: +o Bike
[23:17:20] *** Joins: dsk (~dsk@user/dsk)
[23:17:35] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 258 seconds)
[23:33:22] *** Joins: pve_ (~pve@87-93-248-238.bb.dnainternet.fi)
[23:34:25] *** Joins: lisp123mobile (~lisp123mo@91.73.113.100)
[23:34:51] *** Quits: lisp123mobile (~lisp123mo@91.73.113.100) (Remote host closed the connection)
[23:36:45] *** Quits: pve (~pve@188-67-171-34.bb.dnainternet.fi) (Ping timeout: 255 seconds)
[23:37:08] *** Quits: peterhil (~peterhil@dsl-hkibng32-54f849-252.dhcp.inet.fi) (Ping timeout: 258 seconds)
[23:46:19] *** Joins: lisp123 (~lisp123@5.30.23.247)
[23:52:37] *** Quits: ems (~ems@2a02:a318:813a:d880:b47f:6b1:d194:72ff) (Quit: Konversation terminated!)
[23:54:22] *** Quits: cage (~cage@dynamic-adsl-78-15-46-179.clienti.tiscali.it) (Quit: rcirc on GNU Emacs 27.1)
[23:56:34] *** Joins: lisp123mobile (~lisp123mo@91.73.113.100)
[23:56:57] *** Quits: lisp123 (~lisp123@5.30.23.247) (Ping timeout: 265 seconds)
[23:57:52] *** Quits: lisp123mobile (~lisp123mo@91.73.113.100) (Remote host closed the connection)
