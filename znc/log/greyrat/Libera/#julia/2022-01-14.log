[00:36:24] *** Joins: adigitoleo_ (~adigitole@139.168.64.98)
[00:37:19] *** Quits: adigitoleo (~adigitole@2001:8003:1d19:4500:9535:ae81:77e9:3952) (Ping timeout: 250 seconds)
[02:59:49] *** Quits: kmh (~kmh@2a00:6020:5004:6800:a7fd:cfa9:a0b2:2b1a) (Quit: Leaving)
[03:14:22] *** Joins: kmh (~kmh@2a00:6020:5004:6800:2584:d164:c7ec:fe17)
[03:20:14] *** Quits: kmh (~kmh@2a00:6020:5004:6800:2584:d164:c7ec:fe17) (Remote host closed the connection)
[03:20:25] *** Joins: kmh (~kmh@2a00:6020:5004:6800:2584:d164:c7ec:fe17)
[04:09:39] *** Quits: anaveragehuman (~anaverage@user/anaveragehuman) (Ping timeout: 276 seconds)
[04:56:13] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[04:56:30] *** Joins: ExpiredKebab (~sgreadly@2407:7000:a239:503:1dd5:fdb3:f5cf:b928)
[05:08:02] *** Joins: karthik (~karthik@user/karthik)
[05:11:39] <karthik> Hi folks. I had a question about types. I have a vector of ODE solutions whose type is Vector{OrdinaryDiffEq.ODECompositeSolution{...}}. Specifically it's this: https://0x0.st/o-pr.txt. How do I write a method that accepts this type?
[05:12:48] <karthik> I tried foo(::Vector{OrdinaryDiffEq.ODECompositeSolution}) but that doesn't work. typeof(this_vector) <: Vector{Any} is false too.
[05:18:04] <adigitoleo_> first question is do you really need to dispatch on this specific type? See https://www.oxinabox.net/2020/04/19/Julia-Antipatterns.html#over-constraining-argument-types
[05:19:45] <ninjin> Seconding what adigitoleo_ said. You can of course do this, but you generally should not.
[05:20:59] *** adigitoleo_ is now known as adigitoleo
[05:22:21] <adigitoleo> note that the JIT will still precompile for your specific type on the first call, so there should generally not be a performance penalty for duck typing
[05:22:45] <adigitoleo> so long as you keep things type-stable
[05:23:17] <adigitoleo> (AFAIK)
[05:23:28] <karthik> Okay, that is a helpful link, thanks.
[05:24:01] <karthik> I don't want to dispatch on this exact type, but on some sufficiently broad supertype
[05:24:44] <adigitoleo> Yes I made the same mistake in the beginning, but noticed that refactoring became super painful
[05:25:20] <karthik> I'm not trying to speed up execution, just organize my code so that foo() does the right general purpose thing
[05:26:42] <adigitoleo> If you do need parametric composite types though I think the syntax is ::Container{<:ElementSuperType} but I don't quite remember
[05:27:49] <ninjin> I am not sure I follow karthik, can you elaborate with a tiny example?
[05:28:17] <ninjin> “Getting” this initially with Julia is tricky though, as a lot of what one learns from dynamic languages do not apply.
[05:30:05] <karthik> Sure. I want plot_sol to work in three cases with different behavior. plot_sol(single_ODEsol), plot_sol(vector_of_ODEsols) and plot_sol(vector_of_ODEsols_transformed)
[05:30:36] <ninjin> Okay, that looks like a case where you *do* want multiple dispatch.
[05:32:12] <karthik> For #3 I defined vector_of_ODEsols_transformed as an instance of a new type, TransformedODESolVector, that's taken care of. Right now I differentiate between #1 and #2 with plot_sol(::Any) and plot_sol(::Vector)
[05:32:49] *** ChanServ sets mode: +o ninjin
[05:33:13] <karthik> This works, since #2 is a vector of... something, #1 gets dispatched to the most general method and #3 has a custom method for a bespoke datatype 
[05:33:29] *** ninjin changes topic to 'A marvellous, high-level, high-performance, dynamic programming language | https://julialang.org | v1.7.1 released on 22 December'
[05:33:35] *** ChanServ sets mode: -o ninjin
[05:34:21] <karthik> But it's quite confusing even to me. I was hoping for a more targeted approach
[05:36:35] <ninjin> Okay, firstly. You should not use `::Any` for #1.
[05:36:55] <ninjin> Do not assign any (hurr hurr…) type for the argument.
[05:37:47] <ninjin> It will work regardless, but I am not 100% sure if it will force the compiler to generate general code when it is not necessary for #1. Regardless, it is “code smell”.
[05:38:13] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[05:38:30] <ninjin> For #3, you will just have to look up the syntax for nested structures. I tend to forget.
[05:39:14] <ninjin> An easy way to ensure that you get it right is to bring up a terminal, create an instance of the type, and then try to ensure that `type <: typeof(instance)` holds.
[05:39:35] <ninjin> Sorry for being a bit brief, meetings starting in a matter of minutes and I have yet to grab breakfast. '^^
[05:40:39] <ninjin> The general rule, right, is that Julia dispatches on the method which is the *closest* in terms of type to the arguments.
[05:41:00] <ninjin> Just to clarify why you do not need `::Any` pretty much ever.
[05:52:35] *** Quits: Erutuon (~Erutuon@user/erutuon) (Ping timeout: 256 seconds)
[05:55:18] *** Joins: Erutuon (~Erutuon@user/erutuon)
[05:56:04] *** Joins: anaveragehuman (~anaverage@user/anaveragehuman)
[05:56:19] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[06:00:12] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[06:14:57] *** Quits: ExpiredKebab (~sgreadly@2407:7000:a239:503:1dd5:fdb3:f5cf:b928) (Quit: Textual IRC Client: www.textualapp.com)
[06:17:08] <karthik> ninjin: I don't use `::Any`, that was for explaining the issue. #3 is not an issue, just foo(my_vector::TransformedODESolVector). 
[06:19:51] <karthik> "An easy way to ensure that you get it right" <-- Yeah, this is what I've been doing.
[06:21:23] <karthik> "Julia dispatches on the method which is the *closest*" <-- Yup, I'm trying to find something closer to the typeof #2 so that I can write more methods if necesssary for other types
[06:32:25] *** Quits: Erutuon (~Erutuon@user/erutuon) (Ping timeout: 256 seconds)
[06:35:31] *** Joins: Erutuon (~Erutuon@user/erutuon)
[06:50:51] *** Quits: anaveragehuman (~anaverage@user/anaveragehuman) (Ping timeout: 276 seconds)
[06:52:57] <karthik> From the helpful link about antipatterns above: "The last reason, which I do think holds some water, is for understandability. Putting in type-constraints on function arguments makes them easier to understand. Adding type-constraints can clarify code, consider apply_inner(f::Function, c::Vector{<:Vector}) vs apply_inner(f, c) does."
[06:53:08] <karthik> This is exactly my use case
[06:56:03] <adigitoleo> karthik: ah, yes that makes sense. In that case you just have to remember that it's ::Vector{<:Vector} not ::Vector{Vector} (I make this mistake all the time...)
[06:57:30] <karthik> I'm not sure that ::Vector{<:OrdinaryDiffEq.ODECompositeSolution} is the right type here, let me check...
[06:58:17] <karthik> Oh it is! That works, but now I'm not sure why it works
[07:00:31] <mikko> i don't think the <: is meaningful if OrdinaryDiffEq.ODECompositeSolution is a concrete type (and I believe it is)
[07:00:43] <mikko> <: is subtype relation
[07:00:45] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[07:00:53] <karthik> So ODECompositeSolution{Float64, 1,...} <: ODECompositeSolution?
[07:01:18] <karthik> I understand what <: means, and that concrete types can't be subtyped in julia
[07:01:59] <mikko> yeah, that is correct
[07:02:34] <karthik> I guess what I don't understand is what ODECompositeSolution{Float64, 1,...} means
[07:03:22] <karthik> (Where ... is a long string of types from my link above)
[07:04:33] <karthik> It means that ::ODECompositeSolution is a "container", kind of like ::Vector is a container, and its constituents have the types listed inside the {}?
[07:05:18] <mikko> it's a struct, kind of "parametric type": https://github.com/SciML/OrdinaryDiffEq.jl/blob/master/src/composite_solution.jl
[07:08:00] <mikko> i'm not sure what would be a good way to explain it, hopefully someone else can help...
[07:26:15] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[07:27:55] <adigitoleo> karthik: maybe this helps: http://ix.io/3M7M
[07:29:00] <adigitoleo> the last line is why you need the <:
[07:30:12] <adigitoleo> That's what's peculiar about parametric types, in comparison to say `typeof(5) == Int64`
[07:48:37] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[07:53:51] *** Quits: Erutuon (~Erutuon@user/erutuon) (Ping timeout: 256 seconds)
[08:20:35] <karthik> adigitoleo: Ahh, okay. I've even used parametric types before but I didn't realize the "ordering" involved. Your example helps.
[08:23:30] <karthik> mikko: That makes sense. I used a struct above for type #3 but didn't realize I could just open up the ODE solver code and look at the definition of ODECompositeSolution!
[08:28:31] <karthik> If I understand correctly, a parametric type (like a struct) is not a concrete type?
[08:28:31] <adigitoleo> tbh I think the Julia docs can be improved here. There is https://docs.julialang.org/en/v1/manual/types/#Parametric-Types and also https://docs.julialang.org/en/v1/devdocs/types/ which are both quite detailed but when I was looking for an example to link to before I couldn't find just a quick intro to parametric types
[08:28:50] <karthik> (So it can be subtyped)
[08:30:12] <adigitoleo> karthik: I think so, to be honest I'm not sure of their classification
[08:32:19] <karthik> I see. Also learnt I can do @which foo(arg) to see which method is being used
[08:32:25] <karthik> That's handy too
[08:34:34] <adigitoleo> OK so I'm pretty sure parametric types are classified as abstract and not concrete
[08:35:07] <adigitoleo> See `?DataType`, which says "Every concrete value in the system is an instance of some DataType.
[08:35:54] <adigitoleo> but from my example above, `typeof(bar) <: DataType` is false
[08:37:43] <adigitoleo> karthik: "a parametric type (like a struct)" <-- note that structs are not by default parametric, the keyword is also used to define concrete types, you just leave out the part in the `{..}`
[08:37:45] <mikko> adigitoleo: you can check with isabstracttype() and isconcretetype()
[08:37:57] <adigitoleo> mikko: nice
[08:38:19] <mikko> turns out Vector is not abstract but it's not concrete either (but Vector{Int64} is concrete) 
[08:38:31] <mikko> which is... slightly confusing
[08:39:50] <karthik> adigitoleo: "note that structs..." Gotcha
[08:39:52] <adigitoleo> wait, according to those methods, `typeof(bar)` where bar is an instance of `Foo` from my example above, is actually concrete!
[08:40:22] <karthik> adigitoleo: bar should be concrete, right?
[08:40:55] <adigitoleo> Oh, it turns out parametric types are neither lol
[08:41:13] <adigitoleo> both isabstracttype and isconcretetype return false for `Foo`
[08:41:43] <karthik> So there are abstract, concrete and parametric types
[08:42:04] <karthik> and any reified instance of a parametric type is concrete.
[08:42:38] <mikko> yeah, i think that's correct
[08:43:12] <mikko> i guess that's why the <: is needed
[08:45:39] <karthik> Learning a lot today.
[08:46:03] <adigitoleo> I think we all are :)
[09:01:14] <adigitoleo> Stumbled across https://github.com/JuliaLang/julia/issues/4935 and the comment by wasshin discusses how lack of fields for abstract types means that parametric types become quite common in Julia, as seen in the ODE package you were using. I think he gives a good outline of how to set up a type hierarchy at the end (which I guess is sort of the conventional way now).
[09:04:03] <adigitoleo> However, if you're just using the package then yeah it's just about remembering to add <:
[09:48:29] *** Joins: Erutuon (~Erutuon@user/erutuon)
[11:41:15] *** Quits: Erutuon (~Erutuon@user/erutuon) (Ping timeout: 256 seconds)
[12:43:58] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[13:05:31] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[13:21:06] *** Joins: MajorBiscuit (~MajorBisc@wlan-145-94-216-150.wlan.tudelft.nl)
[13:21:30] *** Quits: kmh (~kmh@2a00:6020:5004:6800:2584:d164:c7ec:fe17) (Quit: Leaving)
[13:21:37] *** Quits: MajorBiscuit (~MajorBisc@wlan-145-94-216-150.wlan.tudelft.nl) (Client Quit)
[13:21:47] *** Joins: MajorBiscuit (~MajorBisc@wlan-145-94-216-150.wlan.tudelft.nl)
[13:30:53] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[14:20:31] *** Joins: kmh (~kmh@2a00:6020:5004:6800:2087:70fd:6ded:c415)
[15:07:23] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[15:29:46] *** Quits: MajorBiscuit (~MajorBisc@wlan-145-94-216-150.wlan.tudelft.nl) (Quit: WeeChat 3.3)
[15:29:56] *** Joins: MajorBiscuit (~MajorBisc@wlan-145-94-216-150.wlan.tudelft.nl)
[16:36:05] *** Joins: Erutuon (~Erutuon@user/erutuon)
[16:51:38] *** Quits: Erutuon (~Erutuon@user/erutuon) (Quit: WeeChat 2.8)
[16:56:16] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[16:59:20] *** Quits: MajorBiscuit (~MajorBisc@wlan-145-94-216-150.wlan.tudelft.nl) (Quit: WeeChat 3.3)
[16:59:29] *** Joins: MajorBiscuit (~MajorBisc@wlan-145-94-216-150.wlan.tudelft.nl)
[17:09:23] *** Quits: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca) (Quit: WeeChat 3.4)
[17:19:37] *** Joins: perrierjouet (~perrier-j@modemcable012.251-130-66.mc.videotron.ca)
[17:25:03] *** ornx is now known as ornxka
[17:51:36] *** Quits: MajorBiscuit (~MajorBisc@wlan-145-94-216-150.wlan.tudelft.nl) (Ping timeout: 250 seconds)
[18:01:34] *** Quits: notzmv (~zmv@user/notzmv) (Ping timeout: 250 seconds)
[18:02:48] *** Joins: MajorBiscuit (~MajorBisc@wlan-145-94-216-150.wlan.tudelft.nl)
[19:54:44] *** Joins: cul8r (~cul8r@76.113.95.199)
[20:12:33] *** Joins: notzmv (~zmv@user/notzmv)
[20:35:48] *** Quits: MajorBiscuit (~MajorBisc@wlan-145-94-216-150.wlan.tudelft.nl) (Quit: WeeChat 3.3)
[22:18:16] *** Joins: Erutuon (~Erutuon@user/erutuon)
[23:06:09] *** Quits: cmbengue (~Thunderbi@207.191.249.160) (Quit: Thanks, see you later.)
[23:17:11] *** Quits: cul8r (~cul8r@76.113.95.199) (Quit: Leaving)
